[
    {
        "nl_input": "sort by a token in string python",
        "code_input": [
            {
                "url": 4833,
                "code": "def _process_and_sort(s, force_ascii, full_process=True): # pull tokens ts = utils.full_process(s, force_ascii=force_ascii) if full_process else s tokens = ts.split() # sort tokens and join sorted_string = u\" \".join(sorted(tokens)) return sorted_string.strip()"
            },
            {
                "url": 4334,
                "code": "def natural_sort(list, key=lambda s:s): def get_alphanum_key_func(key): convert = lambda text: int(text) if text.isdigit() else text return lambda s: [convert(c) for c in re.split('([0-9]+)', key(s))] sort_key = get_alphanum_key_func(key) list.sort(key=sort_key)"
            },
            {
                "url": 1177,
                "code": "def sort_nicely(l): convert = lambda text: int(text) if text.isdigit() else text alphanum_key = lambda key: [convert(c) for c in re.split('([0-9]+)', key)] l.sort(key=alphanum_key)"
            },
            {
                "url": 5770,
                "code": "def natural_sort(list_to_sort: Iterable[str]) -> List[str]: return sorted(list_to_sort, key=natural_keys)"
            },
            {
                "url": 3265,
                "code": "def sort_func(self, key): if key == self._KEYS.VALUE: return 'aaa' if key == self._KEYS.SOURCE: return 'zzz' return key"
            },
            {
                "url": 1172,
                "code": "def sort_dict(d, key=None, reverse=False): kv_items = [kv for kv in d.items()] # Sort kv_items according to key. if key is None: kv_items.sort(key=lambda t: t[1], reverse=reverse) else: kv_items.sort(key=key, reverse=reverse) # Build ordered dict. return collections.OrderedDict(kv_items)"
            },
            {
                "url": 3607,
                "code": "def es_field_sort(fld_name): parts = fld_name.split(\".\") if \"_\" not in parts[-1]: parts[-1] = \"_\" + parts[-1] return \".\".join(parts)"
            },
            {
                "url": 5890,
                "code": "def sort_key(x): name, (r, u) = x return - len(u) + u.count('}') * 100"
            },
            {
                "url": 5484,
                "code": "def naturalsortkey(s): return [int(part) if part.isdigit() else part for part in re.split('([0-9]+)', s)]"
            },
            {
                "url": 3316,
                "code": "def order_by(self, *fields): doc = [] for field in fields: if field.startswith('-'): doc.append((field.strip('-'), pymongo.DESCENDING)) else: doc.append((field, pymongo.ASCENDING)) return self.sort(doc)"
            },
            {
                "url": 2373,
                "code": "def sort_by_name(self): super(JSSObjectList, self).sort(key=lambda k: k.name)"
            },
            {
                "url": 5685,
                "code": "def sorted_by(key: Callable[[raw_types.Qid], Any]) -> 'QubitOrder': return QubitOrder(lambda qubits: tuple(sorted(qubits, key=key)))"
            },
            {
                "url": 5927,
                "code": "def sortBy(self, keyfunc, ascending=True, numPartitions=None): return self.keyBy(keyfunc).sortByKey(ascending, numPartitions).values()"
            },
            {
                "url": 575,
                "code": "def sort_fn_list(fn_list): dt_list = get_dt_list(fn_list) fn_list_sort = [fn for (dt,fn) in sorted(zip(dt_list,fn_list))] return fn_list_sort"
            },
            {
                "url": 3845,
                "code": "def sort_key(val): return numpy.sum((max(val)+1)**numpy.arange(len(val)-1, -1, -1)*val)"
            }
        ],
        "url": 4833
    },
    {
        "nl_input": "python check file is readonly",
        "code_input": [
            {
                "url": 561,
                "code": "def make_file_read_only(file_path): old_permissions = os.stat(file_path).st_mode os.chmod(file_path, old_permissions & ~WRITE_PERMISSIONS)"
            },
            {
                "url": 4294,
                "code": "def make_file_readable (filename): if not os.path.islink(filename): util.set_mode(filename, stat.S_IRUSR)"
            },
            {
                "url": 4492,
                "code": "def readable(path): try: st = os.stat(path) return 0 != st.st_mode & READABLE_MASK except os.error: return None return True"
            },
            {
                "url": 2445,
                "code": "def is_readable(filename): return os.path.isfile(filename) and os.access(filename, os.R_OK)"
            },
            {
                "url": 978,
                "code": "def is_read_only(object): try: attribute = \"_trace__read__\" setattr(object, attribute, True) delattr(object, attribute) return False except (TypeError, AttributeError): return True"
            },
            {
                "url": 3186,
                "code": "def is_writable_by_others(filename): mode = os.stat(filename)[stat.ST_MODE] return mode & stat.S_IWOTH"
            },
            {
                "url": 3432,
                "code": "def make_writeable(filename): if not os.access(filename, os.W_OK): st = os.stat(filename) new_permissions = stat.S_IMODE(st.st_mode) | stat.S_IWUSR os.chmod(filename, new_permissions)"
            },
            {
                "url": 3049,
                "code": "def check_permission_safety(path): f_stats = os.stat(path) return (f_stats.st_mode & (stat.S_IRWXG | stat.S_IRWXO)) == 0 and f_stats.st_uid == os.getuid()"
            },
            {
                "url": 1644,
                "code": "def is_readable_dir(path): return os.path.isdir(path) and os.access(path, os.R_OK) and os.access(path, os.X_OK)"
            },
            {
                "url": 4838,
                "code": "def flipwritable(fn, mode=None): if os.access(fn, os.W_OK): return None old_mode = os.stat(fn).st_mode os.chmod(fn, stat.S_IWRITE | old_mode) return old_mode"
            },
            {
                "url": 4361,
                "code": "def is_filelike(ob): if hasattr(ob, 'read') and callable(ob.read): return True if hasattr(ob, 'write') and callable(ob.write): return True return False"
            },
            {
                "url": 2424,
                "code": "def chmod(scope, filename, mode): for file in filename: os.chmod(file, mode[0]) return True"
            },
            {
                "url": 4211,
                "code": "def _is_readable(self, obj): try: read = getattr(obj, 'read') except AttributeError: return False else: return is_method(read, max_arity=1)"
            },
            {
                "url": 2778,
                "code": "def lock_file(f, block=False): try: flags = fcntl.LOCK_EX if not block: flags |= fcntl.LOCK_NB fcntl.flock(f.fileno(), flags) except IOError as e: if e.errno in (errno.EACCES, errno.EAGAIN): raise SystemExit(\"ERROR: %s is locked by another process.\" % f.name) raise"
            },
            {
                "url": 5788,
                "code": "def writable_stream(handle): if isinstance(handle, io.IOBase) and sys.version_info >= (3, 5): return handle.writable() try: handle.write(b'') except (io.UnsupportedOperation, IOError): return False else: return True"
            }
        ],
        "url": 2445
    },
    {
        "nl_input": "declaring empty numpy array in python",
        "code_input": [
            {
                "url": 5850,
                "code": "def _create_empty_array(self, frames, always_2d, dtype): import numpy as np if always_2d or self.channels > 1: shape = frames, self.channels else: shape = frames, return np.empty(shape, dtype, order='C')"
            },
            {
                "url": 5815,
                "code": "def to_0d_array(value: Any) -> np.ndarray: if np.isscalar(value) or (isinstance(value, np.ndarray) and value.ndim == 0): return np.array(value) else: return to_0d_object_array(value)"
            },
            {
                "url": 5152,
                "code": "def _parse_array(self, tensor_proto): try: from onnx.numpy_helper import to_array except ImportError as e: raise ImportError(\"Unable to import onnx which is required {}\".format(e)) np_array = to_array(tensor_proto).reshape(tuple(tensor_proto.dims)) return mx.nd.array(np_array)"
            },
            {
                "url": 4776,
                "code": "def _ndarray_representer(dumper, data): mapping = [('object', data.tolist()), ('dtype', data.dtype.name)] return dumper.represent_mapping(_NUMPY_ARRAY_TAG, mapping)"
            },
            {
                "url": 2948,
                "code": "def is_empty(self): if(((self.channels == []) and (not self.shape == (0, 0))) or ((not self.channels == []) and (self.shape == (0, 0)))): raise RuntimeError(\"Channels-shape mismatch.\") return self.channels == [] and self.shape == (0, 0)"
            },
            {
                "url": 304,
                "code": "def torecarray(*args, **kwargs): import numpy as np return toarray(*args, **kwargs).view(np.recarray)"
            },
            {
                "url": 6117,
                "code": "def numpy_to_yaml(representer: Representer, data: np.ndarray) -> Sequence[Any]: return representer.represent_sequence( \"!numpy_array\", data.tolist() )"
            },
            {
                "url": 9,
                "code": "def _convert_to_array(array_like, dtype): if isinstance(array_like, bytes): return np.frombuffer(array_like, dtype=dtype) return np.asarray(array_like, dtype=dtype)"
            },
            {
                "url": 1583,
                "code": "def dict_to_numpy_array(d): return fromarrays(d.values(), np.dtype([(str(k), v.dtype) for k, v in d.items()]))"
            },
            {
                "url": 1885,
                "code": "def c_array(ctype, values): if isinstance(values, np.ndarray) and values.dtype.itemsize == ctypes.sizeof(ctype): return (ctype * len(values)).from_buffer_copy(values) return (ctype * len(values))(*values)"
            },
            {
                "url": 5880,
                "code": "def array_to_npy(array_like): # type: (np.array or Iterable or int or float) -> object buffer = BytesIO() np.save(buffer, array_like) return buffer.getvalue()"
            },
            {
                "url": 2619,
                "code": "def dump_nparray(self, obj, class_name=numpy_ndarray_class_name): return {\"$\" + class_name: self._json_convert(obj.tolist())}"
            },
            {
                "url": 84,
                "code": "def cint8_array_to_numpy(cptr, length): if isinstance(cptr, ctypes.POINTER(ctypes.c_int8)): return np.fromiter(cptr, dtype=np.int8, count=length) else: raise RuntimeError('Expected int pointer')"
            },
            {
                "url": 3936,
                "code": "def read_numpy(fh, byteorder, dtype, count, offsetsize): dtype = 'b' if dtype[-1] == 's' else byteorder+dtype[-1] return fh.read_array(dtype, count)"
            },
            {
                "url": 5209,
                "code": "def to_array(self): dt = np.dtype(list(zip(self.labels, (c.dtype for c in self.columns)))) arr = np.empty_like(self.columns[0], dt) for label in self.labels: arr[label] = self[label] return arr"
            }
        ],
        "url": 4923
    },
    {
        "nl_input": "test for iterable is string in python",
        "code_input": [
            {
                "url": 1640,
                "code": "def is_iterable_but_not_string(obj): return hasattr(obj, '__iter__') and not isinstance(obj, str) and not isinstance(obj, bytes)"
            },
            {
                "url": 2522,
                "code": "def _is_iterable(item): return isinstance(item, collections.Iterable) and not isinstance(item, six.string_types)"
            },
            {
                "url": 3950,
                "code": "def is_iterable(obj): return ( hasattr(obj, \"__iter__\") and not isinstance(obj, str) and not isinstance(obj, tuple) )"
            },
            {
                "url": 2617,
                "code": "def ensure_iterable(inst): if isinstance(inst, string_types): return [inst] elif not isinstance(inst, collections.Iterable): return [inst] else: return inst"
            },
            {
                "url": 657,
                "code": "def is_iter_non_string(obj): if isinstance(obj, list) or isinstance(obj, tuple): return True return False"
            },
            {
                "url": 2976,
                "code": "def is_iterable(value): return isinstance(value, np.ndarray) or isinstance(value, list) or isinstance(value, tuple), value"
            },
            {
                "url": 94,
                "code": "def listlike(obj): return hasattr(obj, \"__iter__\") \\ and not issubclass(type(obj), str)\\ and not issubclass(type(obj), unicode)"
            },
            {
                "url": 1789,
                "code": "def is_string(obj): if PYTHON3: str_type = (bytes, str) else: str_type = (bytes, str, unicode) return isinstance(obj, str_type)"
            },
            {
                "url": 1613,
                "code": "def is_iterable_of_int(l): r if not is_iterable(l): return False return all(is_int(value) for value in l)"
            },
            {
                "url": 5900,
                "code": "def is_iterable(etype) -> bool: return type(etype) is GenericMeta and issubclass(etype.__extra__, Iterable)"
            },
            {
                "url": 753,
                "code": "def is_seq(obj): if not hasattr(obj, '__iter__'): return False if isinstance(obj, basestring): return False return True"
            },
            {
                "url": 2401,
                "code": "def ensure_tuple(obj): if obj is None: return tuple() if isinstance(obj, Iterable) and not isinstance(obj, six.string_types): return tuple(obj) return obj,"
            },
            {
                "url": 4454,
                "code": "def assert_iter(**kw): for name, value in kw.items(): if not isiter(value): raise TypeError( 'paco: {} must be an iterable object'.format(name))"
            },
            {
                "url": 2443,
                "code": "def is_lazy_iterable(obj): return isinstance(obj, (types.GeneratorType, collections.MappingView, six.moves.range, enumerate))"
            },
            {
                "url": 2141,
                "code": "def isstring(value): classes = (str, bytes) if pyutils.PY3 else basestring # noqa: F821 return isinstance(value, classes)"
            }
        ],
        "url": 1640
    },
    {
        "nl_input": "python print results of query loop",
        "code_input": [
            {
                "url": 4258,
                "code": "def print_runs(query): if query is None: return for tup in query: print((\"{0} @ {1} - {2} id: {3} group: {4}\".format( tup.end, tup.experiment_name, tup.project_name, tup.experiment_group, tup.run_group)))"
            },
            {
                "url": 2611,
                "code": "def print_statements(self): for i, stmt in enumerate(self.statements): print(\"%s: %s\" % (i, stmt))"
            },
            {
                "url": 5404,
                "code": "def print_result_from_timeit(stmt='pass', setup='pass', number=1000000): units = [\"s\", \"ms\", \"us\", \"ns\"] duration = timeit(stmt, setup, number=int(number)) avg_duration = duration / float(number) thousands = int(math.floor(math.log(avg_duration, 1000))) print(\"Total time: %fs. Average run: %.3f%s.\" % ( duration, avg_duration * (1000 ** -thousands), units[-thousands]))"
            },
            {
                "url": 2904,
                "code": "def Print(self): for val, prob in sorted(self.d.iteritems()): print(val, prob)"
            },
            {
                "url": 2223,
                "code": "def print_param_values(self_): self = self_.self for name,val in self.param.get_param_values(): print('%s.%s = %s' % (self.name,name,val))"
            },
            {
                "url": 5954,
                "code": "def execute(cur, *args): stmt = args[0] if len(args) > 1: stmt = stmt.replace('%', '%%').replace('?', '%r') print(stmt % (args[1])) return cur.execute(*args)"
            },
            {
                "url": 3421,
                "code": "def querySQL(self, sql, args=()): if self.debug: result = timeinto(self.queryTimes, self._queryandfetch, sql, args) else: result = self._queryandfetch(sql, args) return result"
            },
            {
                "url": 5937,
                "code": "def execute_sql(self, query): c = self.con.cursor() c.execute(query) result = [] if c.rowcount > 0: try: result = c.fetchall() except psycopg2.ProgrammingError: pass return result"
            },
            {
                "url": 3109,
                "code": "def __call__(self, _): if self.iter % self.step == 0: print(self.fmt.format(self.iter), **self.kwargs) self.iter += 1"
            },
            {
                "url": 5439,
                "code": "def stdout_to_results(s): results = s.strip().split('\\n') return [BenchmarkResult(*r.split()) for r in results]"
            },
            {
                "url": 5518,
                "code": "def printComparison(results, class_or_prop): data = [] Row = namedtuple('Row',[class_or_prop,'VALIDATED']) for k,v in sorted(results.items(), key=lambda x: x[1]): data += [Row(k, str(v))] pprinttable(data)"
            },
            {
                "url": 477,
                "code": "def runcode(code): for line in code: print('# '+line) exec(line,globals()) print('# return ans') return ans"
            },
            {
                "url": 5600,
                "code": "def cli_run(): parser = argparse.ArgumentParser(description='Stupidly simple code answers from StackOverflow') parser.add_argument('query', help=\"What's the problem ?\", type=str, nargs='+') parser.add_argument('-t','--tags', help='semicolon separated tags -> python;lambda') args = parser.parse_args() main(args)"
            },
            {
                "url": 4411,
                "code": "def _executemany(self, cursor, query, parameters): try: self._log(query) cursor.executemany(query, parameters) except OperationalError as e: # pragma: no cover logging.error('Error connecting to PostgreSQL on %s, e', self.host, e) self.close() raise"
            },
            {
                "url": 3339,
                "code": "def print(cls, *args, **kwargs): # pylint: disable=protected-access with _shared._PRINT_LOCK: print(*args, **kwargs) _sys.stdout.flush()"
            }
        ],
        "url": 4258
    },
    {
        "nl_input": "how to save header of fits file to export python",
        "code_input": [
            {
                "url": 4351,
                "code": "def write_fits(data, header, file_name): hdu = fits.PrimaryHDU(data) hdu.header = header hdulist = fits.HDUList([hdu]) hdulist.writeto(file_name, overwrite=True) logging.info(\"Wrote {0}\".format(file_name)) return"
            },
            {
                "url": 1138,
                "code": "def write_fits(self, fitsfile): tab = self.create_table() hdu_data = fits.table_to_hdu(tab) hdus = [fits.PrimaryHDU(), hdu_data] fits_utils.write_hdus(hdus, fitsfile)"
            },
            {
                "url": 301,
                "code": "def create_table_from_fits(fitsfile, hduname, colnames=None): if colnames is None: return Table.read(fitsfile, hduname) cols = [] with fits.open(fitsfile, memmap=True) as h: for k in colnames: data = h[hduname].data.field(k) cols += [Column(name=k, data=data)] return Table(cols)"
            },
            {
                "url": 3584,
                "code": "def printheader(h=None): writer = csv.writer(sys.stdout) writer.writerow(header_fields(h))"
            },
            {
                "url": 974,
                "code": "def save_excel(self, fd): from pylon.io.excel import ExcelWriter ExcelWriter(self).write(fd)"
            },
            {
                "url": 3727,
                "code": "def _put_header(self): self.session._out('%%PDF-%s' % self.pdf_version) if self.session.compression: self.session.buffer += '%' + chr(235) + chr(236) + chr(237) + chr(238) + \"\\n\""
            },
            {
                "url": 3915,
                "code": "def save_hdf(self,filename,path=''): self.dataframe.to_hdf(filename,'{}/df'.format(path))"
            },
            {
                "url": 925,
                "code": "def py(self, output): import pprint pprint.pprint(output, stream=self.outfile)"
            },
            {
                "url": 1561,
                "code": "def save_hdf5(X, y, path): with h5py.File(path, 'w') as f: is_sparse = 1 if sparse.issparse(X) else 0 f['issparse'] = is_sparse f['target'] = y if is_sparse: if not sparse.isspmatrix_csr(X): X = X.tocsr() f['shape'] = np.array(X.shape) f['data'] = X.data f['indices'] = X.indices f['indptr'] = X.indptr else: f['data'] = X"
            },
            {
                "url": 5287,
                "code": "def add_column(filename,column,formula,force=False): columns = parse_formula(formula) logger.info(\"Running file: %s\"%filename) logger.debug(\" Reading columns: %s\"%columns) data = fitsio.read(filename,columns=columns) logger.debug(' Evaluating formula: %s'%formula) col = eval(formula) col = np.asarray(col,dtype=[(column,col.dtype)]) insert_columns(filename,col,force=force) return True"
            },
            {
                "url": 874,
                "code": "def _download_py3(link, path, __hdr__): try: req = urllib.request.Request(link, headers=__hdr__) u = urllib.request.urlopen(req) except Exception as e: raise Exception(' Download failed with the error:\\n{}'.format(e)) with open(path, 'wb') as outf: for l in u: outf.write(l) u.close()"
            },
            {
                "url": 6239,
                "code": "def toHdlConversion(self, top, topName: str, saveTo: str) -> List[str]: raise NotImplementedError( \"Implement this function for your type of your top module\")"
            },
            {
                "url": 1135,
                "code": "def save(variable, filename): fileObj = open(filename, 'wb') pickle.dump(variable, fileObj) fileObj.close()"
            },
            {
                "url": 3075,
                "code": "def read_mm_header(fd, byte_order, dtype, count): return numpy.rec.fromfile(fd, MM_HEADER, 1, byteorder=byte_order)[0]"
            },
            {
                "url": 6129,
                "code": "def to_javascript_(self, table_name: str=\"data\") -> str: try: renderer = pytablewriter.JavaScriptTableWriter data = self._build_export(renderer, table_name) return data except Exception as e: self.err(e, \"Can not convert data to javascript code\")"
            }
        ],
        "url": 1138
    },
    {
        "nl_input": "python calc page align",
        "code_input": [
            {
                "url": 6173,
                "code": "def page_align_content_length(length): # type: (int) -> int mod = length % _PAGEBLOB_BOUNDARY if mod != 0: return length + (_PAGEBLOB_BOUNDARY - mod) return length"
            },
            {
                "url": 816,
                "code": "def align_file_position(f, size): align = (size - 1) - (f.tell() % size) f.seek(align, 1)"
            },
            {
                "url": 6178,
                "code": "def text_alignment(x, y): if x == 0: ha = \"center\" elif x > 0: ha = \"left\" else: ha = \"right\" if y == 0: va = \"center\" elif y > 0: va = \"bottom\" else: va = \"top\" return ha, va"
            },
            {
                "url": 4325,
                "code": "def _write_separator(self): tmp = self._page_width - ((4 * self.__indent_level) + 2) self._write_line('# ' + ('-' * tmp))"
            },
            {
                "url": 1322,
                "code": "def align_to_mmap(num, round_up): res = (num // ALLOCATIONGRANULARITY) * ALLOCATIONGRANULARITY if round_up and (res != num): res += ALLOCATIONGRANULARITY # END handle size return res"
            },
            {
                "url": 2311,
                "code": "def _pad(self, text): top_bottom = (\"\\n\" * self._padding) + \" \" right_left = \" \" * self._padding * self.PAD_WIDTH return top_bottom + right_left + text + right_left + top_bottom"
            },
            {
                "url": 4446,
                "code": "def calculate_bounding_box_from_image(im, curr_page): xMax, y_max = im.size bounding_box = im.getbbox() # note this uses ltrb convention if not bounding_box: #print(\"\\nWarning: could not calculate a bounding box for this page.\" # \"\\nAn empty page is assumed.\", file=sys.stderr) bounding_box = (xMax/2, y_max/2, xMax/2, y_max/2) bounding_box = list(bounding_box) # make temporarily mutable # Compensate for reversal of the image y convention versus PDF. bounding_box[1] = y_max - bounding_box[1] bounding_box[3] = y_max - bounding_box[3] full_page_box = curr_page.mediaBox # should have been set already to chosen box # Convert pixel units to PDF's bp units. convert_x = float(full_page_box.getUpperRight_x() - full_page_box.getLowerLeft_x()) / xMax convert_y = float(full_page_box.getUpperRight_y() - full_page_box.getLowerLeft_y()) / y_max # Get final box; note conversion to lower-left point, upper-right point format. final_box = [ bounding_box[0] * convert_x, bounding_box[3] * convert_y, bounding_box[2] * convert_x, bounding_box[1] * convert_y] return final_box"
            },
            {
                "url": 2023,
                "code": "def write_padding(fp, size, divisor=2): remainder = size % divisor if remainder: return write_bytes(fp, struct.pack('%dx' % (divisor - remainder))) return 0"
            },
            {
                "url": 2982,
                "code": "def indent(text, amount, ch=' '): padding = amount * ch return ''.join(padding+line for line in text.splitlines(True))"
            },
            {
                "url": 5562,
                "code": "def get_margin(length): if length > 23: margin_left = \"\\t\" chars = 1 elif length > 15: margin_left = \"\\t\\t\" chars = 2 elif length > 7: margin_left = \"\\t\\t\\t\" chars = 3 else: margin_left = \"\\t\\t\\t\\t\" chars = 4 return margin_left"
            },
            {
                "url": 2724,
                "code": "def indent(self): blk = IndentBlock(self, self._indent) self._indent += 1 return blk"
            },
            {
                "url": 156,
                "code": "def center_text(text, width=80): centered = [] for line in text.splitlines(): centered.append(line.center(width)) return \"\\n\".join(centered)"
            },
            {
                "url": 4150,
                "code": "def _pad(self): if self._indent: self.whitespace(self._indent * len(self._open_elements))"
            },
            {
                "url": 3014,
                "code": "def get_height_for_line(self, lineno): if self.wrap_lines: return self.ui_content.get_height_for_line(lineno, self.window_width) else: return 1"
            },
            {
                "url": 5915,
                "code": "def left_zero_pad(s, blocksize): if blocksize > 0 and len(s) % blocksize: s = (blocksize - len(s) % blocksize) * b('\\000') + s return s"
            }
        ],
        "url": 6173
    },
    {
        "nl_input": "python numpy array as float",
        "code_input": [
            {
                "url": 82,
                "code": "def cfloat32_array_to_numpy(cptr, length): if isinstance(cptr, ctypes.POINTER(ctypes.c_float)): return np.fromiter(cptr, dtype=np.float32, count=length) else: raise RuntimeError('Expected float pointer')"
            },
            {
                "url": 2305,
                "code": "def is_float_array(val): return is_np_array(val) and issubclass(val.dtype.type, np.floating)"
            },
            {
                "url": 64,
                "code": "def cfloat64_array_to_numpy(cptr, length): if isinstance(cptr, ctypes.POINTER(ctypes.c_double)): return np.fromiter(cptr, dtype=np.float64, count=length) else: raise RuntimeError('Expected double pointer')"
            },
            {
                "url": 655,
                "code": "def is_float_array(l): r if isinstance(l, np.ndarray): if l.dtype.kind == 'f': return True return False"
            },
            {
                "url": 854,
                "code": "def as_float_array(a): return np.asarray(a, dtype=np.quaternion).view((np.double, 4))"
            },
            {
                "url": 4148,
                "code": "def ensure_dtype_float(x, default=np.float64): r if isinstance(x, np.ndarray): if x.dtype.kind == 'f': return x elif x.dtype.kind == 'i': return x.astype(default) else: raise TypeError('x is of type '+str(x.dtype)+' that cannot be converted to float') else: raise TypeError('x is not an array')"
            },
            {
                "url": 772,
                "code": "def is_float(value): return isinstance(value, float) or isinstance(value, int) or isinstance(value, np.float64), float(value)"
            },
            {
                "url": 79,
                "code": "def cint32_array_to_numpy(cptr, length): if isinstance(cptr, ctypes.POINTER(ctypes.c_int32)): return np.fromiter(cptr, dtype=np.int32, count=length) else: raise RuntimeError('Expected int pointer')"
            },
            {
                "url": 1870,
                "code": "def _to_array(value): if isinstance(value, (tuple, list)): return array(value) elif isinstance(value, (float, int)): return np.float64(value) else: return value"
            },
            {
                "url": 84,
                "code": "def cint8_array_to_numpy(cptr, length): if isinstance(cptr, ctypes.POINTER(ctypes.c_int8)): return np.fromiter(cptr, dtype=np.int8, count=length) else: raise RuntimeError('Expected int pointer')"
            },
            {
                "url": 4693,
                "code": "def is_floating(self): return ( self.is_numpy_compatible and np.issubdtype(self.as_numpy_dtype, np.floating) ) or self.base_dtype == bfloat16"
            },
            {
                "url": 4198,
                "code": "def _maybe_cast_to_float64(da): if da.dtype == np.float32: logging.warning('Datapoints were stored using the np.float32 datatype.' 'For accurate reduction operations using bottleneck, ' 'datapoints are being cast to the np.float64 datatype.' ' For more information see: https://github.com/pydata/' 'xarray/issues/1346') return da.astype(np.float64) else: return da"
            },
            {
                "url": 2999,
                "code": "def set_float(val): out = None if not val in (None, ''): try: out = float(val) except ValueError: return None if numpy.isnan(out): out = default return out"
            },
            {
                "url": 5880,
                "code": "def array_to_npy(array_like): # type: (np.array or Iterable or int or float) -> object buffer = BytesIO() np.save(buffer, array_like) return buffer.getvalue()"
            },
            {
                "url": 1885,
                "code": "def c_array(ctype, values): if isinstance(values, np.ndarray) and values.dtype.itemsize == ctypes.sizeof(ctype): return (ctype * len(values)).from_buffer_copy(values) return (ctype * len(values))(*values)"
            }
        ],
        "url": 854
    },
    {
        "nl_input": "input string that replaces occurences python",
        "code_input": [
            {
                "url": 5637,
                "code": "def __replace_all(repls: dict, input: str) -> str: return re.sub('|'.join(re.escape(key) for key in repls.keys()), lambda k: repls[k.group(0)], input)"
            },
            {
                "url": 4308,
                "code": "def _replace(self, data, replacements): for find, repl in replacements: data = data.replace(find, repl) return data"
            },
            {
                "url": 3181,
                "code": "def replace(s, replace): for r in replace: s = s.replace(*r) return s"
            },
            {
                "url": 5928,
                "code": "def multiple_replace(string, replacements): # type: (str, Dict[str,str]) -> str pattern = re.compile(\"|\".join([re.escape(k) for k in sorted(replacements, key=len, reverse=True)]), flags=re.DOTALL) return pattern.sub(lambda x: replacements[x.group(0)], string)"
            },
            {
                "url": 5699,
                "code": "def replace_in_list(stringlist: Iterable[str], replacedict: Dict[str, str]) -> List[str]: newlist = [] for fromstring in stringlist: newlist.append(multiple_replace(fromstring, replacedict)) return newlist"
            },
            {
                "url": 5061,
                "code": "def replace(self, text): for (pattern, repl) in self.patterns: text = re.subn(pattern, repl, text)[0] return text"
            },
            {
                "url": 513,
                "code": "def replace_all(filepath, searchExp, replaceExp): for line in fileinput.input(filepath, inplace=1): if searchExp in line: line = line.replace(searchExp, replaceExp) sys.stdout.write(line)"
            },
            {
                "url": 1023,
                "code": "def multi_replace(instr, search_list=[], repl_list=None): repl_list = [''] * len(search_list) if repl_list is None else repl_list for ser, repl in zip(search_list, repl_list): instr = instr.replace(ser, repl) return instr"
            },
            {
                "url": 2767,
                "code": "def replace_all(text, dic): for i, j in dic.iteritems(): text = text.replace(i, j) return text"
            },
            {
                "url": 3362,
                "code": "def replace_list(items, match, replacement): return [replace(item, match, replacement) for item in items]"
            },
            {
                "url": 5865,
                "code": "def replaceStrs(s, *args): r if args == (): return s mapping = dict((frm, to) for frm, to in args) return re.sub(\"|\".join(map(re.escape, mapping.keys())), lambda match:mapping[match.group(0)], s)"
            },
            {
                "url": 5076,
                "code": "def list_replace(subject_list, replacement, string): for s in subject_list: string = string.replace(s, replacement) return string"
            },
            {
                "url": 6031,
                "code": "def replace_variables(self, source: str, variables: dict) -> str: try: replaced = re.sub( \"{{(.*?)}}\", lambda m: variables.get(m.group(1), \"\"), source ) except TypeError: replaced = source return replaced"
            },
            {
                "url": 1210,
                "code": "def replace(scope, strings, source, dest): return [s.replace(source[0], dest[0]) for s in strings]"
            },
            {
                "url": 656,
                "code": "def myreplace(astr, thefind, thereplace): alist = astr.split(thefind) new_s = alist.split(thereplace) return new_s"
            }
        ],
        "url": 5637
    },
    {
        "nl_input": "python check all items in list are ints",
        "code_input": [
            {
                "url": 1613,
                "code": "def is_iterable_of_int(l): r if not is_iterable(l): return False return all(is_int(value) for value in l)"
            },
            {
                "url": 2466,
                "code": "def toListInt(value): if TypeConverters._can_convert_to_list(value): value = TypeConverters.toList(value) if all(map(lambda v: TypeConverters._is_integer(v), value)): return [int(v) for v in value] raise TypeError(\"Could not convert %s to list of ints\" % value)"
            },
            {
                "url": 2128,
                "code": "def is_integer(obj): if PYTHON3: return isinstance(obj, int) return isinstance(obj, (int, long))"
            },
            {
                "url": 2437,
                "code": "def check_int(integer): if not isinstance(integer, str): return False if integer[0] in ('-', '+'): return integer[1:].isdigit() return integer.isdigit()"
            },
            {
                "url": 761,
                "code": "def isnumber(*args): return all(map(lambda c: isinstance(c, int) or isinstance(c, float), args))"
            },
            {
                "url": 1329,
                "code": "def validate_int(value): if value and not isinstance(value, int): try: int(str(value)) except (TypeError, ValueError): raise ValidationError('not a valid number') return value"
            },
            {
                "url": 637,
                "code": "def is_int(value): if isinstance(value, bool): return False try: int(value) return True except (ValueError, TypeError): return False"
            },
            {
                "url": 5643,
                "code": "def strings_to_integers(strings: Iterable[str]) -> Iterable[int]: return strings_to_(strings, lambda x: int(float(x)))"
            },
            {
                "url": 2675,
                "code": "def is_integer_array(val): return is_np_array(val) and issubclass(val.dtype.type, np.integer)"
            },
            {
                "url": 5567,
                "code": "def is_integer(value: Any) -> bool: return (isinstance(value, int) and not isinstance(value, bool)) or ( isinstance(value, float) and isfinite(value) and int(value) == value )"
            },
            {
                "url": 6037,
                "code": "def ensure_list(iterable: Iterable[A]) -> List[A]: if isinstance(iterable, list): return iterable else: return list(iterable)"
            },
            {
                "url": 3842,
                "code": "def _return_comma_list(self, l): if isinstance(l, (text_type, int)): return l if not isinstance(l, list): raise TypeError(l, ' should be a list of integers, \\ not {0}'.format(type(l))) str_ids = ','.join(str(i) for i in l) return str_ids"
            },
            {
                "url": 1791,
                "code": "def is_int(string): try: a = float(string) b = int(a) except ValueError: return False else: return a == b"
            },
            {
                "url": 3523,
                "code": "def is_int_type(val): try: # Python 2 return isinstance(val, (int, long)) except NameError: # Python 3 return isinstance(val, int)"
            },
            {
                "url": 1757,
                "code": "def items(iterable): if hasattr(iterable, 'iteritems'): return (p for p in iterable.iteritems()) elif hasattr(iterable, 'items'): return (p for p in iterable.items()) else: return (p for p in enumerate(iterable))"
            }
        ],
        "url": 1613
    },
    {
        "nl_input": "how to save variable to text file python",
        "code_input": [
            {
                "url": 1497,
                "code": "def _save_file(self, filename, contents): with open(filename, 'w') as f: f.write(contents)"
            },
            {
                "url": 1135,
                "code": "def save(variable, filename): fileObj = open(filename, 'wb') pickle.dump(variable, fileObj) fileObj.close()"
            },
            {
                "url": 5623,
                "code": "def write_text(filename: str, text: str) -> None: with open(filename, 'w') as f: # type: TextIO print(text, file=f)"
            },
            {
                "url": 4691,
                "code": "def write_to_file(file_path, contents, encoding=\"utf-8\"): with codecs.open(file_path, \"w\", encoding) as f: f.write(contents)"
            },
            {
                "url": 588,
                "code": "def save(self, fname: str): with open(fname, \"wb\") as fp: pickle.dump(self, fp)"
            },
            {
                "url": 686,
                "code": "def save(self, fname): with open(fname, 'wb') as f: json.dump(self, f)"
            },
            {
                "url": 1349,
                "code": "def save_dict_to_file(filename, dictionary): with open(filename, 'w') as f: writer = csv.writer(f) for k, v in iteritems(dictionary): writer.writerow([str(k), str(v)])"
            },
            {
                "url": 2511,
                "code": "def write_str2file(pathname, astr): fname = pathname fhandle = open(fname, 'wb') fhandle.write(astr) fhandle.close()"
            },
            {
                "url": 1258,
                "code": "def write_file(filename, content): print 'Generating {0}'.format(filename) with open(filename, 'wb') as out_f: out_f.write(content)"
            },
            {
                "url": 5455,
                "code": "def put_text(self, key, text): with open(key, \"w\") as fh: fh.write(text)"
            },
            {
                "url": 2013,
                "code": "def example_write_file_to_disk_if_changed(): my_file = FileAsObj('/tmp/example_file.txt') my_file.rm(my_file.egrep('^#')) if my_file.changed: my_file.save()"
            },
            {
                "url": 5372,
                "code": "def make_temp(text): import tempfile (handle, path) = tempfile.mkstemp(text=True) os.close(handle) afile = File(path) afile.write(text) return afile"
            },
            {
                "url": 3818,
                "code": "def save_cache(data, filename): with open(filename, 'wb') as handle: pickle.dump(data, handle)"
            },
            {
                "url": 5347,
                "code": "def append_text(self, txt): with open(self.fullname, \"a\") as myfile: myfile.write(txt)"
            },
            {
                "url": 3187,
                "code": "def write(self): with open(self.path, 'w') as file_: file_.write(self.content)"
            }
        ],
        "url": 1135
    },
    {
        "nl_input": "how to skip an index in a for loop python",
        "code_input": [
            {
                "url": 1137,
                "code": "def skip(self, n): try: self._iter_object.skip(n) except AttributeError: for i in range(0, n): self.next()"
            },
            {
                "url": 3215,
                "code": "def _skip_frame(self): size = self.read_size() for i in range(size+1): line = self._f.readline() if len(line) == 0: raise StopIteration"
            },
            {
                "url": 2047,
                "code": "def stop_at(iterable, idx): for i, item in enumerate(iterable): if i == idx: return yield item"
            },
            {
                "url": 1136,
                "code": "def _skip_frame(self): for line in self._f: if line == 'ITEM: ATOMS\\n': break for i in range(self.num_atoms): next(self._f)"
            },
            {
                "url": 3109,
                "code": "def __call__(self, _): if self.iter % self.step == 0: print(self.fmt.format(self.iter), **self.kwargs) self.iter += 1"
            },
            {
                "url": 6155,
                "code": "def _skip(self, cnt): while cnt > 0: if cnt > 8192: buf = self.read(8192) else: buf = self.read(cnt) if not buf: break cnt -= len(buf)"
            },
            {
                "url": 5576,
                "code": "def _skip_section(self): self._last = self._f.readline() while len(self._last) > 0 and len(self._last[0].strip()) == 0: self._last = self._f.readline()"
            },
            {
                "url": 3216,
                "code": "def _skip_newlines(self): while self._cur_token['type'] is TT.lbreak and not self._finished: self._increment()"
            },
            {
                "url": 1630,
                "code": "def peekiter(iterable): it = iter(iterable) one = next(it) def gen(): \"\"\"Generator that returns first and proxy other items from source\"\"\" yield one while True: yield next(it) return (one, gen())"
            },
            {
                "url": 5821,
                "code": "def getIndex(predicateFn: Callable[[T], bool], items: List[T]) -> int: try: return next(i for i, v in enumerate(items) if predicateFn(v)) except StopIteration: return -1"
            },
            {
                "url": 1973,
                "code": "def iterate(obj): global next, Iteration next = next Iteration = Iteration total = len(obj) if isinstance(obj, Sized) else None iterator = iter(obj) first = True last = False i = 0 try: value = next(iterator) except StopIteration: return while True: try: next_value = next(iterator) except StopIteration: last = True yield Iteration(first, last, i, total, value) if last: return value = next_value i += 1 first = False"
            },
            {
                "url": 1454,
                "code": "def IndexOfNth(s, value, n): remaining = n for i in xrange(0, len(s)): if s[i] == value: remaining -= 1 if remaining == 0: return i return -1"
            },
            {
                "url": 2314,
                "code": "def where_is(strings, pattern, n=1, lookup_func=re.match): count = 0 for idx, item in enumerate(strings): if lookup_func(pattern, item): count += 1 if count == n: return idx return -1"
            },
            {
                "url": 6214,
                "code": "def index(self, item): for i, x in enumerate(self.iter()): if x == item: return i return None"
            },
            {
                "url": 5615,
                "code": "def iterate_items(dictish): if hasattr(dictish, 'iteritems'): return dictish.iteritems() if hasattr(dictish, 'items'): return dictish.items() return dictish"
            }
        ],
        "url": 2047
    },
    {
        "nl_input": "how to create a tokenization code in python",
        "code_input": [
            {
                "url": 855,
                "code": "def tokenize(string): for match in TOKENS_REGEX.finditer(string): yield Token(match.lastgroup, match.group().strip(), match.span())"
            },
            {
                "url": 2461,
                "code": "def listified_tokenizer(source): io_obj = io.StringIO(source) return [list(a) for a in tokenize.generate_tokens(io_obj.readline)]"
            },
            {
                "url": 6106,
                "code": "def get_tokens(line: str) -> Iterator[str]: for token in line.rstrip().split(): if len(token) > 0: yield token"
            },
            {
                "url": 4455,
                "code": "def tokenize(self, s): return [s[start:end] for start, end in self.span_tokenize(s)]"
            },
            {
                "url": 4516,
                "code": "def token(name): def wrap(f): tokenizers.append((name, f)) return f return wrap"
            },
            {
                "url": 1576,
                "code": "def tokenize_list(self, text): return [self.get_record_token(record) for record in self.analyze(text)]"
            },
            {
                "url": 2704,
                "code": "def counter_from_str(self, string): string_list = [chars for chars in string if chars not in self.punctuation] string_joined = ''.join(string_list) tokens = self.punkt.word_tokenize(string_joined) return Counter(tokens)"
            },
            {
                "url": 3274,
                "code": "def lemmatize(self, text, best_guess=True, return_frequencies=False): if isinstance(text, str): tokens = wordpunct_tokenize(text) elif isinstance(text, list): tokens= text else: raise TypeError(\"lemmatize only works with strings or lists of string tokens.\") return [self._lemmatize_token(token, best_guess, return_frequencies) for token in tokens]"
            },
            {
                "url": 3082,
                "code": "def tokenize_words(self, text): return [ self.strip_punctuation(word) for word in text.split(' ') if self.strip_punctuation(word) ]"
            },
            {
                "url": 4458,
                "code": "def _split_python(python): python = _preprocess(python) if not python: return [] lexer = PythonSplitLexer() lexer.read(python) return lexer.chunks"
            },
            {
                "url": 2203,
                "code": "def tree(string, token=[WORD, POS, CHUNK, PNP, REL, ANCHOR, LEMMA]): return Text(string, token)"
            },
            {
                "url": 844,
                "code": "def wordify(text): stopset = set(nltk.corpus.stopwords.words('english')) tokens = nltk.WordPunctTokenizer().tokenize(text) return [w for w in tokens if w not in stopset]"
            },
            {
                "url": 1460,
                "code": "def _replace_token_range(tokens, start, end, replacement): tokens = tokens[:start] + replacement + tokens[end:] return tokens"
            },
            {
                "url": 1568,
                "code": "def token_list_to_text(tokenlist): ZeroWidthEscape = Token.ZeroWidthEscape return ''.join(item[1] for item in tokenlist if item[0] != ZeroWidthEscape)"
            },
            {
                "url": 398,
                "code": "def detokenize(s): print(s) s = re.sub(\"\\s+([;:,\\.\\?!])\", \"\\\\1\", s) s = re.sub(\"\\s+(n't)\", \"\\\\1\", s) return s"
            }
        ],
        "url": 4516
    },
    {
        "nl_input": "python raise without parentheses",
        "code_input": [
            {
                "url": 2589,
                "code": "def raise_(exception=ABSENT, *args, **kwargs): if exception is ABSENT: raise else: if inspect.isclass(exception): raise exception(*args, **kwargs) else: if args or kwargs: raise TypeError(\"can't pass arguments along with \" \"exception object to raise_()\") raise exception"
            },
            {
                "url": 3276,
                "code": "def re_raise(self): if self.exc_info is not None: six.reraise(type(self), self, self.exc_info[2]) else: raise self"
            },
            {
                "url": 6184,
                "code": "def assert_raises(ex_type, func, *args, **kwargs): r try: func(*args, **kwargs) except Exception as ex: assert isinstance(ex, ex_type), ( 'Raised %r but type should have been %r' % (ex, ex_type)) return True else: raise AssertionError('No error was raised')"
            },
            {
                "url": 3219,
                "code": "def _re_raise_as(NewExc, *args, **kw): etype, val, tb = sys.exc_info() raise NewExc(*args, **kw), None, tb"
            },
            {
                "url": 3557,
                "code": "def reraise(error): if hasattr(error, \"_type_\"): six.reraise(type(error), error, error._traceback) raise error"
            },
            {
                "url": 4372,
                "code": "def raises_regex(self, expected_exception, expected_regexp): return unittest_case.assertRaisesRegexp(expected_exception, expected_regexp, self._orig_subject, *self._args, **self._kwargs)"
            },
            {
                "url": 6088,
                "code": "def assert_or_raise(stmt: bool, exception: Exception, *exception_args, **exception_kwargs) -> None: if not stmt: raise exception(*exception_args, **exception_kwargs)"
            },
            {
                "url": 786,
                "code": "def raise_figure_window(f=0): if _fun.is_a_number(f): f = _pylab.figure(f) f.canvas.manager.window.raise_()"
            },
            {
                "url": 3728,
                "code": "def fix_call(callable, *args, **kw): try: val = callable(*args, **kw) except TypeError: exc_info = fix_type_error(None, callable, args, kw) reraise(*exc_info) return val"
            },
            {
                "url": 1383,
                "code": "def maybeparens(lparen, item, rparen): return item | lparen.suppress() + item + rparen.suppress()"
            },
            {
                "url": 5919,
                "code": "def is_none(string_, default='raise'): none = ['none', 'undefined', 'unknown', 'null', ''] if string_.lower() in none: return True elif not default: return False else: raise ValueError('The value \\'{}\\' cannot be mapped to none.' .format(string_))"
            },
            {
                "url": 731,
                "code": "def raise_os_error(_errno, path=None): msg = \"%s: '%s'\" % (strerror(_errno), path) if path else strerror(_errno) raise OSError(_errno, msg)"
            },
            {
                "url": 259,
                "code": "def prepare_for_reraise(error, exc_info=None): if not hasattr(error, \"_type_\"): if exc_info is None: exc_info = sys.exc_info() error._type_ = exc_info[0] error._traceback = exc_info[2] return error"
            },
            {
                "url": 3554,
                "code": "def get_function(function_name): module, basename = str(function_name).rsplit('.', 1) try: return getattr(__import__(module, fromlist=[basename]), basename) except (ImportError, AttributeError): raise FunctionNotFound(function_name)"
            },
            {
                "url": 5441,
                "code": "def tuple_check(*args, func=None): func = func or inspect.stack()[2][3] for var in args: if not isinstance(var, (tuple, collections.abc.Sequence)): name = type(var).__name__ raise TupleError( f'Function {func} expected tuple, {name} got instead.')"
            }
        ],
        "url": 6088
    },
    {
        "nl_input": "how to seperate list with commas python",
        "code_input": [
            {
                "url": 3278,
                "code": "def comma_delimited_to_list(list_param): if isinstance(list_param, list): return list_param if isinstance(list_param, str): return list_param.split(',') else: return []"
            },
            {
                "url": 3842,
                "code": "def _return_comma_list(self, l): if isinstance(l, (text_type, int)): return l if not isinstance(l, list): raise TypeError(l, ' should be a list of integers, \\ not {0}'.format(type(l))) str_ids = ','.join(str(i) for i in l) return str_ids"
            },
            {
                "url": 5700,
                "code": "def list_to_str(list, separator=','): list = [str(x) for x in list] return separator.join(list)"
            },
            {
                "url": 1110,
                "code": "def split_comma_argument(comma_sep_str): terms = [] for term in comma_sep_str.split(','): if term: terms.append(term) return terms"
            },
            {
                "url": 392,
                "code": "def _split_comma_separated(string): return set(text.strip() for text in string.split(',') if text.strip())"
            },
            {
                "url": 3417,
                "code": "def list2string (inlist,delimit=' '): stringlist = [makestr(_) for _ in inlist] return string.join(stringlist,delimit)"
            },
            {
                "url": 2880,
                "code": "def string_to_list(string, sep=\",\", filter_empty=False): return [value.strip() for value in string.split(sep) if (not filter_empty or value)]"
            },
            {
                "url": 1146,
                "code": "def split_strings_in_list_retain_spaces(orig_list): temp_list = list() for line in orig_list: line_split = __re.split(r'(\\s+)', line) temp_list.append(line_split) return temp_list"
            },
            {
                "url": 77,
                "code": "def list_to_csv(value): if isinstance(value, (list, tuple, set)): value = \",\".join(value) return value"
            },
            {
                "url": 160,
                "code": "def commajoin_as_strings(iterable): return _(u',').join((six.text_type(i) for i in iterable))"
            },
            {
                "url": 5723,
                "code": "def _str_to_list(value, separator): value_list = [item.strip() for item in value.split(separator)] value_list_sanitized = builtins.list(filter(None, value_list)) if len(value_list_sanitized) > 0: return value_list_sanitized else: raise ValueError('Invalid list variable.')"
            },
            {
                "url": 2418,
                "code": "def _str_to_list(s): _list = s.split(\",\") return list(map(lambda i: i.lstrip(), _list))"
            },
            {
                "url": 5698,
                "code": "def multi_split(s, split): # type: (S, Iterable[S]) -> List[S] for r in split: s = s.replace(r, \"|\") return [i for i in s.split(\"|\") if len(i) > 0]"
            },
            {
                "url": 1295,
                "code": "def delimited(items, character='|'): return '|'.join(items) if type(items) in (list, tuple, set) else items"
            },
            {
                "url": 404,
                "code": "def linedelimited (inlist,delimiter): outstr = '' for item in inlist: if type(item) != StringType: item = str(item) outstr = outstr + item + delimiter outstr = outstr[0:-1] return outstr"
            }
        ],
        "url": 3842
    },
    {
        "nl_input": "python asynchronous function call return",
        "code_input": [
            {
                "url": 2776,
                "code": "def runcoro(async_function): future = _asyncio.run_coroutine_threadsafe(async_function, client.loop) result = future.result() return result"
            },
            {
                "url": 1943,
                "code": "def action(self): self.return_value = self.function(*self.args, **self.kwargs)"
            },
            {
                "url": 318,
                "code": "def asynchronous(function, event): thread = Thread(target=synchronous, args=(function, event)) thread.daemon = True thread.start()"
            },
            {
                "url": 112,
                "code": "async def _thread_coro(self, *args): return await self._loop.run_in_executor( self._executor, self._function, *args)"
            },
            {
                "url": 1491,
                "code": "def __call__(self, func, *args, **kwargs): return self.run(func, *args, **kwargs)"
            },
            {
                "url": 4964,
                "code": "def apply(self, func, args=(), kwds=dict()): return self.apply_async(func, args, kwds).get()"
            },
            {
                "url": 5681,
                "code": "def _run_sync(self, method: Callable, *args, **kwargs) -> Any: if self.loop.is_running(): raise RuntimeError(\"Event loop is already running.\") if not self.is_connected: self.loop.run_until_complete(self.connect()) task = asyncio.Task(method(*args, **kwargs), loop=self.loop) result = self.loop.run_until_complete(task) self.loop.run_until_complete(self.quit()) return result"
            },
            {
                "url": 407,
                "code": "def return_value(self, *args, **kwargs): self._called() return self._return_value(*args, **kwargs)"
            },
            {
                "url": 5360,
                "code": "def wait_run_in_executor(func, *args, **kwargs): loop = asyncio.get_event_loop() future = loop.run_in_executor(None, functools.partial(func, *args, **kwargs)) yield from asyncio.wait([future]) return future.result()"
            },
            {
                "url": 2736,
                "code": "def submit(self, fn, *args, **kwargs): corofn = asyncio.coroutine(lambda: fn(*args, **kwargs)) return run_coroutine_threadsafe(corofn(), self.loop)"
            },
            {
                "url": 1941,
                "code": "def isfunc(x): return any([ inspect.isfunction(x) and not asyncio.iscoroutinefunction(x), inspect.ismethod(x) and not asyncio.iscoroutinefunction(x) ])"
            },
            {
                "url": 4789,
                "code": "def return_future(fn): @wraps(fn) def decorated(*args, **kwargs): return gen.maybe_future(fn(*args, **kwargs)) return decorated"
            },
            {
                "url": 3977,
                "code": "def run_task(func): def _wrapped(*a, **k): loop = asyncio.get_event_loop() return loop.run_until_complete(func(*a, **k)) return _wrapped"
            },
            {
                "url": 2213,
                "code": "def user_return(self, frame, return_value): pdb.Pdb.user_return(self, frame, return_value)"
            },
            {
                "url": 3976,
                "code": "def delegate(self, fn, *args, **kwargs): callback = functools.partial(fn, *args, **kwargs) coro = self.loop.run_in_executor(self.subexecutor, callback) return asyncio.ensure_future(coro)"
            }
        ],
        "url": 318
    },
    {
        "nl_input": "how to make a seconds to time in python",
        "code_input": [
            {
                "url": 5120,
                "code": "def seconds_to_time(x): t = int(x * 10**6) ms = t % 10**6 t = t // 10**6 s = t % 60 t = t // 60 m = t % 60 t = t // 60 h = t return time(h, m, s, ms)"
            },
            {
                "url": 3009,
                "code": "def str_time_to_day_seconds(time): t = str(time).split(':') seconds = int(t[0]) * 3600 + int(t[1]) * 60 + int(t[2]) return seconds"
            },
            {
                "url": 3713,
                "code": "def time2seconds(t): return t.hour * 3600 + t.minute * 60 + t.second + float(t.microsecond) / 1e6"
            },
            {
                "url": 3264,
                "code": "def hms_to_seconds(time_string): s = time_string.split(':') hours = int(s[0]) minutes = int(s[1]) secs = float(s[2]) return hours * 3600 + minutes * 60 + secs"
            },
            {
                "url": 3379,
                "code": "def seconds_to_hms(input_seconds): minutes, seconds = divmod(input_seconds, 60) hours, minutes = divmod(minutes, 60) hours = int(hours) minutes = int(minutes) seconds = str(int(seconds)).zfill(2) return hours, minutes, seconds"
            },
            {
                "url": 2450,
                "code": "def seconds(num): now = pytime.time() end = now + num until(end)"
            },
            {
                "url": 2239,
                "code": "def time_string(seconds): s = int(round(seconds)) # round to nearest second h, s = divmod(s, 3600) # get hours and remainder m, s = divmod(s, 60) # split remainder into minutes and seconds return \"%2i:%02i:%02i\" % (h, m, s)"
            },
            {
                "url": 162,
                "code": "def seconds_to_hms(seconds): hours = int(seconds / 3600.0) minutes = int((seconds / 60.0) % 60.0) secs = float(seconds % 60.0) return \"{0:02d}:{1:02d}:{2:02.6f}\".format(hours, minutes, secs)"
            },
            {
                "url": 4946,
                "code": "def _to_hours_mins_secs(time_taken): mins, secs = divmod(time_taken, 60) hours, mins = divmod(mins, 60) return hours, mins, secs"
            },
            {
                "url": 2451,
                "code": "def format_time(time): h, r = divmod(time / 1000, 3600) m, s = divmod(r, 60) return \"%02d:%02d:%02d\" % (h, m, s)"
            },
            {
                "url": 5501,
                "code": "def _parse_string_to_list_of_pairs(s, seconds_to_int=False): r ret = [] for p in [s.split(\":\") for s in re.sub(\"[,.;]\", \" \", s).split()]: if len(p) != 2: raise ValueError(\"bad input to _parse_string_to_list_of_pairs %s\" % s) if seconds_to_int: ret.append((p[0], int(p[1]))) else: ret.append(tuple(p)) return ret"
            },
            {
                "url": 4766,
                "code": "def timedelta_seconds(timedelta): return (timedelta.total_seconds() if hasattr(timedelta, \"total_seconds\") else timedelta.days * 24 * 3600 + timedelta.seconds + timedelta.microseconds / 1000000.)"
            },
            {
                "url": 115,
                "code": "def datetime_to_ms(dt): seconds = calendar.timegm(dt.utctimetuple()) return seconds * 1000 + int(dt.microsecond / 1000)"
            },
            {
                "url": 5386,
                "code": "def format_time(timestamp): format_string = '%Y_%m_%d_%Hh%Mm%Ss' formatted_time = datetime.datetime.fromtimestamp(timestamp).strftime(format_string) return formatted_time"
            },
            {
                "url": 5606,
                "code": "def str_to_time(time_str: str) -> datetime.datetime: pieces: Any = [int(piece) for piece in time_str.split('-')] return datetime.datetime(*pieces)"
            }
        ],
        "url": 3713
    },
    {
        "nl_input": "python cast true or false as numbers",
        "code_input": [
            {
                "url": 3360,
                "code": "def _cast_boolean(value): _BOOLEANS = {'1': True, 'yes': True, 'true': True, 'on': True, '0': False, 'no': False, 'false': False, 'off': False, '': False} value = str(value) if value.lower() not in _BOOLEANS: raise ValueError('Not a boolean: %s' % value) return _BOOLEANS[value.lower()]"
            },
            {
                "url": 397,
                "code": "def boolean(value): if isinstance(value, bool): return value if value == \"\": return False return strtobool(value)"
            },
            {
                "url": 5682,
                "code": "def to_bool(value: Any) -> bool: return bool(strtobool(value) if isinstance(value, str) else value)"
            },
            {
                "url": 4683,
                "code": "def _parse_boolean(value, default=False): if value is None: return default try: return bool(value) except ValueError: return default"
            },
            {
                "url": 2429,
                "code": "def numberp(v): return (not(isinstance(v, bool)) and (isinstance(v, int) or isinstance(v, float)))"
            },
            {
                "url": 3092,
                "code": "def FromString(self, string): if string.lower() in (\"false\", \"no\", \"n\"): return False if string.lower() in (\"true\", \"yes\", \"y\"): return True raise TypeValueError(\"%s is not recognized as a boolean value.\" % string)"
            },
            {
                "url": 607,
                "code": "def strToBool(val): if isinstance(val, str): val = val.lower() return val in ['true', 'on', 'yes', True]"
            },
            {
                "url": 5453,
                "code": "def bool_str(string): if string not in BOOL_STRS: raise ValueError('Invalid boolean string: \"{}\"'.format(string)) return True if string == 'true' else False"
            },
            {
                "url": 6148,
                "code": "def to_bool(value): # type: (Any) -> bool if isinstance(value, _compat.string_types): return value.upper() in ('Y', 'YES', 'T', 'TRUE', '1', 'OK') return bool(value)"
            },
            {
                "url": 3258,
                "code": "def from_json(value, **kwargs): if isinstance(value, string_types): value = value.upper() if value in ('TRUE', 'Y', 'YES', 'ON'): return True if value in ('FALSE', 'N', 'NO', 'OFF'): return False if isinstance(value, int): return value raise ValueError('Could not load boolean from JSON: {}'.format(value))"
            },
            {
                "url": 2907,
                "code": "def process_bool_arg(arg): if isinstance(arg, bool): return arg elif isinstance(arg, basestring): if arg.lower() in [\"true\", \"1\"]: return True elif arg.lower() in [\"false\", \"0\"]: return False"
            },
            {
                "url": 742,
                "code": "def autoconvert(string): for fn in (boolify, int, float): try: return fn(string) except ValueError: pass return string"
            },
            {
                "url": 5274,
                "code": "def convert_string(string): if is_int(string): return int(string) elif is_float(string): return float(string) elif convert_bool(string)[0]: return convert_bool(string)[1] elif string == 'None': return None else: return string"
            },
            {
                "url": 4369,
                "code": "def parse_parameter(value): if any((isinstance(value, float), isinstance(value, int), isinstance(value, bool))): return value try: return int(value) except ValueError: try: return float(value) except ValueError: if value in string_aliases.true_boolean_aliases: return True elif value in string_aliases.false_boolean_aliases: return False else: return str(value)"
            },
            {
                "url": 5198,
                "code": "def str_to_boolean(input_str): if not isinstance(input_str, six.string_types): raise ValueError(input_str) input_str = str_quote_stripper(input_str) return input_str.lower() in (\"true\", \"t\", \"1\", \"y\", \"yes\")"
            }
        ],
        "url": 1299
    },
    {
        "nl_input": "add milliseconds to datetime python",
        "code_input": [
            {
                "url": 1259,
                "code": "def ms_to_datetime(ms): dt = datetime.datetime.utcfromtimestamp(ms / 1000) return dt.replace(microsecond=(ms % 1000) * 1000).replace(tzinfo=pytz.utc)"
            },
            {
                "url": 115,
                "code": "def datetime_to_ms(dt): seconds = calendar.timegm(dt.utctimetuple()) return seconds * 1000 + int(dt.microsecond / 1000)"
            },
            {
                "url": 5433,
                "code": "def to_unix(cls, timestamp): if not isinstance(timestamp, datetime.datetime): raise TypeError('Time.milliseconds expects a datetime object') base = time.mktime(timestamp.timetuple()) return base"
            },
            {
                "url": 2902,
                "code": "def datetime_delta_to_ms(delta): delta_ms = delta.days * 24 * 60 * 60 * 1000 delta_ms += delta.seconds * 1000 delta_ms += delta.microseconds / 1000 delta_ms = int(delta_ms) return delta_ms"
            },
            {
                "url": 6014,
                "code": "def python_utc_datetime_to_sqlite_strftime_string( value: datetime.datetime) -> str: millisec_str = str(round(value.microsecond / 1000)).zfill(3) return value.strftime(\"%Y-%m-%d %H:%M:%S\") + \".\" + millisec_str"
            },
            {
                "url": 4056,
                "code": "def convertDatetime(t): epoch = datetime.datetime.utcfromtimestamp(0) delta = t - epoch millis = delta.total_seconds() * 1000 return int(millis)"
            },
            {
                "url": 2816,
                "code": "def add_datetime(dataframe, timestamp_key='UNIXTIME'): def convert_data(timestamp): return datetime.fromtimestamp(float(timestamp) / 1e3, UTC_TZ) try: log.debug(\"Adding DATETIME column to the data\") converted = dataframe[timestamp_key].apply(convert_data) dataframe['DATETIME'] = converted except KeyError: log.warning(\"Could not add DATETIME column\")"
            },
            {
                "url": 1263,
                "code": "def timestamp_to_datetime(timestamp): from datetime import datetime, timedelta obj = datetime.fromtimestamp(timestamp[0]) return obj + timedelta(microseconds=int(timestamp[1]))"
            },
            {
                "url": 2438,
                "code": "def timedelta2millisecond(td): milliseconds = td.days * 24 * 60 * 60 * 1000 milliseconds += td.seconds * 1000 milliseconds += td.microseconds / 1000 return milliseconds"
            },
            {
                "url": 131,
                "code": "def datetime64_to_datetime(dt): dt64 = np.datetime64(dt) ts = (dt64 - np.datetime64('1970-01-01T00:00:00')) / np.timedelta64(1, 's') return datetime.datetime.utcfromtimestamp(ts)"
            },
            {
                "url": 1704,
                "code": "def from_timestamp(microsecond_timestamp): # Create datetime without losing precision from floating point (yes, this # is actually needed): return datetime.datetime.fromtimestamp( microsecond_timestamp // 1000000, datetime.timezone.utc ).replace(microsecond=(microsecond_timestamp % 1000000))"
            },
            {
                "url": 1286,
                "code": "def dt_to_ts(value): if not isinstance(value, datetime): return value return calendar.timegm(value.utctimetuple()) + value.microsecond / 1000000.0"
            },
            {
                "url": 6137,
                "code": "def date_to_datetime(d): if not isinstance(d, datetime): d = datetime.combine(d, datetime.min.time()) return d"
            },
            {
                "url": 5797,
                "code": "def datetime_from_isoformat(value: str): if sys.version_info >= (3, 7): return datetime.fromisoformat(value) return datetime.strptime(value, '%Y-%m-%dT%H:%M:%S.%f')"
            },
            {
                "url": 119,
                "code": "def ToDatetime(self): return datetime.utcfromtimestamp( self.seconds + self.nanos / float(_NANOS_PER_SECOND))"
            }
        ],
        "url": 115
    },
    {
        "nl_input": "how to read the last n lines of a program on python",
        "code_input": [
            {
                "url": 5895,
                "code": "def _read_section(self): lines = [self._last[self._last.find(\":\")+1:]] self._last = self._f.readline() while len(self._last) > 0 and len(self._last[0].strip()) == 0: lines.append(self._last) self._last = self._f.readline() return lines"
            },
            {
                "url": 5576,
                "code": "def _skip_section(self): self._last = self._f.readline() while len(self._last) > 0 and len(self._last[0].strip()) == 0: self._last = self._f.readline()"
            },
            {
                "url": 585,
                "code": "def last(self): # End of file self.__file.seek(0, 2) # Get the last struct data = self.get(self.length - 1) return data"
            },
            {
                "url": 1073,
                "code": "def head(filename, n=10): with freader(filename) as fr: for _ in range(n): print(fr.readline().strip())"
            },
            {
                "url": 2729,
                "code": "def get_readline_tail(self, n=10): end = self.shell.readline.get_current_history_length() + 1 start = max(end-n, 1) ghi = self.shell.readline.get_history_item return [ghi(x) for x in range(start, end)]"
            },
            {
                "url": 933,
                "code": "def line_count(fn): with open(fn) as f: for i, l in enumerate(f): pass return i + 1"
            },
            {
                "url": 4173,
                "code": "def readline( file, skip_blank=False ): while 1: line = file.readline() #print \"every line: %r\" % line if not line: return None if line[0] != '#' and not ( skip_blank and line.isspace() ): return line"
            },
            {
                "url": 971,
                "code": "def getfirstline(file, default): with open(file, 'rb') as fh: content = fh.readlines() if len(content) == 1: return content[0].decode('utf-8').strip('\\n') return default"
            },
            {
                "url": 3663,
                "code": "def getLinesFromLogFile(stream): stream.flush() stream.seek(0) lines = stream.readlines() return lines"
            },
            {
                "url": 4999,
                "code": "def next(self): _LOGGER.debug(\"reading next\") if self.closed: _LOGGER.debug(\"stream is closed\") raise StopIteration() line = self.readline() if not line: _LOGGER.debug(\"nothing more to read\") raise StopIteration() return line"
            },
            {
                "url": 636,
                "code": "def get_lines(handle, line): for i, l in enumerate(handle): if i == line: return l"
            },
            {
                "url": 3541,
                "code": "def empty_line_count_at_the_end(self): count = 0 for line in self.lines[::-1]: if not line or line.isspace(): count += 1 else: break return count"
            },
            {
                "url": 5564,
                "code": "def tail(filename, number_of_bytes): with open(filename, \"rb\") as f: if os.stat(filename).st_size > number_of_bytes: f.seek(-number_of_bytes, 2) return f.read()"
            },
            {
                "url": 1652,
                "code": "def is_empty_object(n, last): if n.strip(): return False # seems to be but can be empty code last = last.strip() markers = { ')', ';', } if not last or last[-1] in markers: return False return True"
            },
            {
                "url": 3271,
                "code": "def clear_last_lines(self, n): self.term.stream.write( self.term.move_up * n + self.term.clear_eos) self.term.stream.flush()"
            }
        ],
        "url": 2729
    },
    {
        "nl_input": "python mysql get list of table columns",
        "code_input": [
            {
                "url": 277,
                "code": "def get_table_columns(dbconn, tablename): cur = dbconn.cursor() cur.execute(\"PRAGMA table_info('%s');\" % tablename) info = cur.fetchall() cols = [(i[1], i[2]) for i in info] return cols"
            },
            {
                "url": 2535,
                "code": "def column_names(self, table): table_info = self.execute( u'PRAGMA table_info(%s)' % quote(table)) return (column['name'] for column in table_info)"
            },
            {
                "url": 5550,
                "code": "def get_column_names(engine: Engine, tablename: str) -> List[str]: return [info.name for info in gen_columns_info(engine, tablename)]"
            },
            {
                "url": 4131,
                "code": "def _columns_for_table(table_name): return {cname: col for (tname, cname), col in _COLUMNS.items() if tname == table_name}"
            },
            {
                "url": 913,
                "code": "def get_column_keys_and_names(table): ins = inspect(table) return ((k, c.name) for k, c in ins.mapper.c.items())"
            },
            {
                "url": 716,
                "code": "def get_table_names(connection): cursor = connection.cursor() cursor.execute(\"SELECT name FROM sqlite_master WHERE type == 'table'\") return [name for (name,) in cursor]"
            },
            {
                "url": 4614,
                "code": "def get_table_list(dbconn): cur = dbconn.cursor() cur.execute(\"SELECT name FROM sqlite_master WHERE type='table';\") try: return [item[0] for item in cur.fetchall()] except IndexError: return get_table_list(dbconn)"
            },
            {
                "url": 950,
                "code": "def get_tablenames(cur): cur.execute(\"SELECT name FROM sqlite_master WHERE type='table'\") tablename_list_ = cur.fetchall() tablename_list = [str(tablename[0]) for tablename in tablename_list_ ] return tablename_list"
            },
            {
                "url": 389,
                "code": "def columns(self): res = [col['name'] for col in self.column_definitions] res.extend([col['name'] for col in self.foreign_key_definitions]) return res"
            },
            {
                "url": 461,
                "code": "def _get_column_types(self, data): columns = list(zip_longest(*data)) return [self._get_column_type(column) for column in columns]"
            },
            {
                "url": 5802,
                "code": "def get_table_names_from_metadata(metadata: MetaData) -> List[str]: return [table.name for table in metadata.tables.values()]"
            },
            {
                "url": 1858,
                "code": "def _get_str_columns(sf): return [name for name in sf.column_names() if sf[name].dtype == str]"
            },
            {
                "url": 4514,
                "code": "def _get_column_by_db_name(cls, name): return cls._columns.get(cls._db_map.get(name, name))"
            },
            {
                "url": 2834,
                "code": "def get_column_definition(self, table, column): # Parse column definitions for match for col in self.get_column_definition_all(table): if col.strip('`').startswith(column): return col.strip(',')"
            },
            {
                "url": 90,
                "code": "def _dictfetchall(self, cursor): columns = [col[0] for col in cursor.description] return [ dict(zip(columns, row)) for row in cursor.fetchall() ]"
            }
        ],
        "url": 277
    },
    {
        "nl_input": "how to get domain part of a url in python",
        "code_input": [
            {
                "url": 5694,
                "code": "def url_host(url: str) -> str: from urllib.parse import urlparse res = urlparse(url) return res.netloc.split(':')[0] if res.netloc else ''"
            },
            {
                "url": 3341,
                "code": "def parse_domain(url): domain_match = lib.DOMAIN_REGEX.match(url) if domain_match: return domain_match.group()"
            },
            {
                "url": 5798,
                "code": "def get_domain(url): parse_result = urlparse(url) domain = \"{schema}://{netloc}\".format( schema=parse_result.scheme, netloc=parse_result.netloc) return domain"
            },
            {
                "url": 4108,
                "code": "def get_site_name(request): urlparts = request.urlparts return ':'.join([urlparts.hostname, str(urlparts.port)])"
            },
            {
                "url": 5155,
                "code": "def fetch(self): api = self.doapi_manager return api._domain(api.request(self.url)[\"domain\"])"
            },
            {
                "url": 1449,
                "code": "def strip_querystring(url): p = six.moves.urllib.parse.urlparse(url) return p.scheme + \"://\" + p.netloc + p.path"
            },
            {
                "url": 3718,
                "code": "def parse_host_port (host_port): host, port = urllib.splitport(host_port.strip()) if port is not None: if urlutil.is_numeric_port(port): port = int(port) return host, port"
            },
            {
                "url": 1660,
                "code": "def clean_url(url): parsed = urlparse(url.strip()) reconstructed = ParseResult( parsed.scheme, parsed.netloc, parsed.path, params='', query='', fragment='') return reconstructed.geturl()"
            },
            {
                "url": 1149,
                "code": "def _config_win32_domain(self, domain): # we call str() on domain to convert it from unicode to ascii self.domain = dns.name.from_text(str(domain))"
            },
            {
                "url": 1054,
                "code": "def parse_s3_url(url): bucket = '' path = '' if url: result = urlparse(url) bucket = result.netloc path = result.path.strip('/') return bucket, path"
            },
            {
                "url": 1199,
                "code": "def is_valid_url(url): pieces = urlparse(url) return all([pieces.scheme, pieces.netloc])"
            },
            {
                "url": 1309,
                "code": "def guess_url(url): if url.lower().startswith(\"www.\"): # syntactic sugar return \"http://%s\" % url elif url.lower().startswith(\"ftp.\"): # syntactic sugar return \"ftp://%s\" % url return url"
            },
            {
                "url": 4581,
                "code": "def get_querystring(uri): parts = urlparse.urlsplit(uri) return urlparse.parse_qs(parts.query)"
            },
            {
                "url": 4153,
                "code": "def top_level(url, fix_protocol=True): ext = tld.get_tld(url, fix_protocol=fix_protocol) toplevel = '.'.join(urlparse(url).netloc.split('.')[-2:]).split( ext)[0] + ext return toplevel"
            },
            {
                "url": 2015,
                "code": "def get_url_file_name(url): assert isinstance(url, (str, _oldstr)) return urlparse.urlparse(url).path.split('/')[-1]"
            }
        ],
        "url": 5694
    },
    {
        "nl_input": "python flatten a nested dictionaary",
        "code_input": [
            {
                "url": 677,
                "code": "def flatten_dict_join_keys(dct, join_symbol=\" \"): return dict( flatten_dict(dct, join=lambda a,b:a+join_symbol+b) )"
            },
            {
                "url": 1816,
                "code": "def flatten(nested): flat_return = list() def __inner_flat(nested,flat): for i in nested: __inner_flat(i, flat) if isinstance(i, list) else flat.append(i) return flat __inner_flat(nested,flat_return) return flat_return"
            },
            {
                "url": 5724,
                "code": "def flatten_multidict(multidict): return dict([(key, value if len(value) > 1 else value[0]) for (key, value) in multidict.iterlists()])"
            },
            {
                "url": 1819,
                "code": "def flatten(nested, containers=(list, tuple)): for item in nested: if hasattr(item, \"next\") or isinstance(item, containers): for subitem in flatten(item): yield subitem else: yield item"
            },
            {
                "url": 1389,
                "code": "def stringify_dict_contents(dct): return { str_if_nested_or_str(k): str_if_nested_or_str(v) for k, v in dct.items() }"
            },
            {
                "url": 664,
                "code": "def flatten(l): return sum(map(flatten, l), []) \\ if isinstance(l, list) or isinstance(l, tuple) else [l]"
            },
            {
                "url": 2174,
                "code": "def flattened_nested_key_indices(nested_dict): outer_keys, inner_keys = collect_nested_keys(nested_dict) combined_keys = list(sorted(set(outer_keys + inner_keys))) return {k: i for (i, k) in enumerate(combined_keys)}"
            },
            {
                "url": 3730,
                "code": "def flatten( iterables ): for it in iterables: if isinstance(it, str): yield it else: for element in it: yield element"
            },
            {
                "url": 5705,
                "code": "def flatten_list(l: List[list]) -> list: return [v for inner_l in l for v in inner_l]"
            },
            {
                "url": 2865,
                "code": "def nest(thing): tfutil = util.get_module('tensorflow.python.util') if tfutil: return tfutil.nest.flatten(thing) else: return [thing]"
            },
            {
                "url": 51,
                "code": "def dictapply(d, fn): for k, v in d.items(): if isinstance(v, dict): v = dictapply(v, fn) else: d[k] = fn(v) return d"
            },
            {
                "url": 566,
                "code": "def flatten(l, types=(list, float)): l = [item if isinstance(item, types) else [item] for item in l] return [item for sublist in l for item in sublist]"
            },
            {
                "url": 1820,
                "code": "def flatten_array(grid): grid = [grid[i][j] for i in range(len(grid)) for j in range(len(grid[i]))] while type(grid[0]) is list: grid = flatten_array(grid) return grid"
            },
            {
                "url": 5658,
                "code": "def flatten_list(x: List[Any]) -> List[Any]: # noqa return [item for sublist in x for item in sublist]"
            },
            {
                "url": 4620,
                "code": "def _iterate_flattened_values(value): if isinstance(value, six.string_types): yield value return if isinstance(value, collections.Mapping): value = collections.ValuesView(value) if isinstance(value, collections.Iterable): for nested_value in value: for nested_nested_value in _iterate_flattened_values(nested_value): yield nested_nested_value yield value"
            }
        ],
        "url": 5724
    },
    {
        "nl_input": "python session set get",
        "code_input": [
            {
                "url": 2346,
                "code": "def _session_set(self, key, value): self.session[self._session_key(key)] = value"
            },
            {
                "url": 4043,
                "code": "def _get_session(): session = getattr(g, '_session', None) if session is None: session = g._session = db.session() return session"
            },
            {
                "url": 3160,
                "code": "def session(self): self._session = requests.session() yield self._session.close() self._session = None"
            },
            {
                "url": 1242,
                "code": "def save_session(self, sid, session, namespace=None): return self.server.save_session( sid, session, namespace=namespace or self.namespace)"
            },
            {
                "url": 3330,
                "code": "def setup_request_sessions(self): self.req_session = requests.Session() self.req_session.headers.update(self.headers)"
            },
            {
                "url": 2301,
                "code": "def requests_request(method, url, **kwargs): session = local_sessions.session response = session.request(method=method, url=url, **kwargs) session.close() return response"
            },
            {
                "url": 236,
                "code": "def keys(self): all_keys = [k.decode('utf-8') for k,v in self.rdb.hgetall(self.session_hash).items()] return all_keys"
            },
            {
                "url": 1031,
                "code": "def save_session_to_file(self, sessionfile): pickle.dump(requests.utils.dict_from_cookiejar(self._session.cookies), sessionfile)"
            },
            {
                "url": 3229,
                "code": "def save(self): self.session.add(self) self.session.flush() return self"
            },
            {
                "url": 3829,
                "code": "def dispatch(self): try: webapp2.RequestHandler.dispatch(self) finally: self.session_store.save_sessions(self.response)"
            },
            {
                "url": 6096,
                "code": "def copy_session(session: requests.Session) -> requests.Session: new = requests.Session() new.cookies = requests.utils.cookiejar_from_dict(requests.utils.dict_from_cookiejar(session.cookies)) new.headers = session.headers.copy() return new"
            },
            {
                "url": 2637,
                "code": "def get_boto_session( region, aws_access_key_id=None, aws_secret_access_key=None, aws_session_token=None ): return boto3.session.Session( region_name=region, aws_secret_access_key=aws_secret_access_key, aws_access_key_id=aws_access_key_id, aws_session_token=aws_session_token )"
            },
            {
                "url": 3951,
                "code": "def _get_set(self, key, operation, create=False): return self._get_by_type(key, operation, create, b'set', set())"
            },
            {
                "url": 4277,
                "code": "def _internal_kv_get(key): worker = ray.worker.get_global_worker() if worker.mode == ray.worker.LOCAL_MODE: return _local.get(key) return worker.redis_client.hget(key, \"value\")"
            },
            {
                "url": 1423,
                "code": "def get(self, key): res = self.connection.get(key) print(res) return res"
            }
        ],
        "url": 2346
    },
    {
        "nl_input": "python save graph into file",
        "code_input": [
            {
                "url": 3702,
                "code": "def to_dotfile(G: nx.DiGraph, filename: str): A = to_agraph(G) A.write(filename)"
            },
            {
                "url": 5070,
                "code": "def plot_dot_graph(graph, filename=None): if not plot.pygraphviz_available: logger.error(\"Pygraphviz is not installed, cannot generate graph plot!\") return if not plot.PIL_available: logger.error(\"PIL is not installed, cannot display graph plot!\") return agraph = AGraph(graph) agraph.layout(prog='dot') if filename is None: filename = tempfile.mktemp(suffix=\".png\") agraph.draw(filename) image = Image.open(filename) image.show()"
            },
            {
                "url": 1756,
                "code": "def draw(graph, fname): ag = networkx.nx_agraph.to_agraph(graph) ag.draw(fname, prog='dot')"
            },
            {
                "url": 2908,
                "code": "def graph_from_dot_file(path): fd = file(path, 'rb') data = fd.read() fd.close() return graph_from_dot_data(data)"
            },
            {
                "url": 5336,
                "code": "def draw_graph(G: nx.DiGraph, filename: str): A = to_agraph(G) A.graph_attr[\"rankdir\"] = \"LR\" A.draw(filename, prog=\"dot\")"
            },
            {
                "url": 2518,
                "code": "def save_dot(self, fd): from pylon.io import DotWriter DotWriter(self).write(fd)"
            },
            {
                "url": 875,
                "code": "def to_dotfile(self): domain = self.get_domain() filename = \"%s.dot\" % (self.__class__.__name__) nx.write_dot(domain, filename) return filename"
            },
            {
                "url": 489,
                "code": "def _text_to_graphiz(self, text): dot = Source(text, format='svg') return dot.pipe().decode('utf-8')"
            },
            {
                "url": 5982,
                "code": "def export_to_dot(self, filename: str = 'output') -> None: with open(filename + '.dot', 'w') as output: output.write(self.as_dot())"
            },
            {
                "url": 2489,
                "code": "def load_graph_from_rdf(fname): print(\"reading RDF from \" + fname + \"....\") store = Graph() store.parse(fname, format=\"n3\") print(\"Loaded \" + str(len(store)) + \" tuples\") return store"
            },
            {
                "url": 5811,
                "code": "def cmd_dot(conf: Config): build_context = BuildContext(conf) populate_targets_graph(build_context, conf) if conf.output_dot_file is None: write_dot(build_context, conf, sys.stdout) else: with open(conf.output_dot_file, 'w') as out_file: write_dot(build_context, conf, out_file)"
            },
            {
                "url": 2330,
                "code": "def plot_and_save(self, **kwargs): self.fig = pyplot.figure() self.plot() self.axes = pyplot.gca() self.save_plot(self.fig, self.axes, **kwargs) pyplot.close(self.fig)"
            },
            {
                "url": 2074,
                "code": "def _check_graphviz_available(output_format): try: subprocess.call([\"dot\", \"-V\"], stdout=subprocess.PIPE, stderr=subprocess.PIPE) except OSError: print( \"The output format '%s' is currently not available.\\n\" \"Please install 'Graphviz' to have other output formats \" \"than 'dot' or 'vcg'.\" % output_format ) sys.exit(32)"
            },
            {
                "url": 588,
                "code": "def save(self, fname: str): with open(fname, \"wb\") as fp: pickle.dump(self, fp)"
            },
            {
                "url": 6047,
                "code": "def to_graphviz(graph): ret = ['digraph g {'] vertices = [] node_ids = dict([(name, 'node' + idx) for (idx, name) in enumerate(list(graph))]) for node in list(graph): ret.append(' \"%s\" [label=\"%s\"];' % (node_ids[node], node)) for target in graph[node]: vertices.append(' \"%s\" -> \"%s\";' % (node_ids[node], node_ids[target])) ret += vertices ret.append('}') return '\\n'.join(ret)"
            }
        ],
        "url": 3702
    },
    {
        "nl_input": "chmod python windows to remove file",
        "code_input": [
            {
                "url": 4551,
                "code": "def rmfile(path): if osp.isfile(path): if is_win: os.chmod(path, 0o777) os.remove(path)"
            },
            {
                "url": 1658,
                "code": "def chmod(f): try: os.chmod(f, S_IWRITE) # windows (cover all) except Exception as e: pass try: os.chmod(f, 0o777) # *nix except Exception as e: pass"
            },
            {
                "url": 3945,
                "code": "def file_remove(self, path, filename): if os.path.isfile(path + filename): os.remove(path + filename)"
            },
            {
                "url": 2424,
                "code": "def chmod(scope, filename, mode): for file in filename: os.chmod(file, mode[0]) return True"
            },
            {
                "url": 1145,
                "code": "def symlink_remove(link): # https://stackoverflow.com/q/26554135/6400719 if os.path.isdir(path2str(link)) and is_windows: # this should only be on Py2.7 and windows os.rmdir(path2str(link)) else: os.unlink(path2str(link))"
            },
            {
                "url": 561,
                "code": "def make_file_read_only(file_path): old_permissions = os.stat(file_path).st_mode os.chmod(file_path, old_permissions & ~WRITE_PERMISSIONS)"
            },
            {
                "url": 2690,
                "code": "def chmod_plus_w(path): path_mode = os.stat(path).st_mode path_mode &= int('777', 8) path_mode |= stat.S_IWRITE os.chmod(path, path_mode)"
            },
            {
                "url": 2188,
                "code": "def safe_delete(filename): try: os.unlink(filename) except OSError as e: if e.errno != errno.ENOENT: raise"
            },
            {
                "url": 2187,
                "code": "def remover(file_path): if os.path.isfile(file_path): os.remove(file_path) return True elif os.path.isdir(file_path): shutil.rmtree(file_path) return True else: return False"
            },
            {
                "url": 2659,
                "code": "def add_exec_permission_to(target_file): mode = os.stat(target_file).st_mode os.chmod(target_file, mode | stat.S_IXUSR)"
            },
            {
                "url": 1428,
                "code": "def remove(self, path): p = self.cmd('shell', 'rm', path) stdout, stderr = p.communicate() if stdout or stderr: return False else: return True"
            },
            {
                "url": 1152,
                "code": "def chmod_add_excute(filename): st = os.stat(filename) os.chmod(filename, st.st_mode | stat.S_IEXEC)"
            },
            {
                "url": 836,
                "code": "def _delete_local(self, filename): if os.path.exists(filename): os.remove(filename)"
            },
            {
                "url": 3032,
                "code": "def set_executable(filename): st = os.stat(filename) os.chmod(filename, st.st_mode | stat.S_IEXEC)"
            },
            {
                "url": 698,
                "code": "def copy_no_perm(src, dst): shutil.copy(src, dst) perm = os.stat(dst).st_mode shutil.copystat(src, dst) os.chmod(dst, perm)"
            }
        ],
        "url": 4551
    },
    {
        "nl_input": "add suffixes on concat python",
        "code_input": [
            {
                "url": 2100,
                "code": "def add_suffix(fullname, suffix): name, ext = os.path.splitext(fullname) return name + '_' + suffix + ext"
            },
            {
                "url": 701,
                "code": "def filename_addstring(filename, text): fn, ext = os.path.splitext(filename) return fn + text + ext"
            },
            {
                "url": 4908,
                "code": "def __add__(self, other): return concat(self, other, copy=True, inplace=False)"
            },
            {
                "url": 2058,
                "code": "def get_abi3_suffix(): for suffix, _, _ in (s for s in imp.get_suffixes() if s[2] == imp.C_EXTENSION): if '.abi3' in suffix: # Unix return suffix elif suffix == '.pyd': # Windows return suffix"
            },
            {
                "url": 3470,
                "code": "def _increment_numeric_suffix(s): if re.match(r\".*\\d+$\", s): return re.sub(r\"\\d+$\", lambda n: str(int(n.group(0)) + 1), s) return s + \"_2\""
            },
            {
                "url": 5829,
                "code": "def url_concat(url, args): if not args: return url if url[-1] not in ('?', '&'): url += '&' if ('?' in url) else '?' return url + urllib.urlencode(args)"
            },
            {
                "url": 4956,
                "code": "def extend_with(func): if not func.__name__ in ArgParseInator._plugins: ArgParseInator._plugins[func.__name__] = func"
            },
            {
                "url": 6023,
                "code": "def add_mark_at(string, index, mark): if index == -1: return string # Python can handle the case which index is out of range of given string return string[:index] + add_mark_char(string[index], mark) + string[index+1:]"
            },
            {
                "url": 6154,
                "code": "def _extension(modpath: str) -> setuptools.Extension: return setuptools.Extension(modpath, [modpath.replace(\".\", \"/\") + \".py\"])"
            },
            {
                "url": 5948,
                "code": "def add_colons(s): return ':'.join([s[i:i + 2] for i in range(0, len(s), 2)])"
            },
            {
                "url": 523,
                "code": "def _get_compiled_ext(): for ext, mode, typ in imp.get_suffixes(): if typ == imp.PY_COMPILED: return ext"
            },
            {
                "url": 3006,
                "code": "def extend(self, item): if not isinstance(item, list): raise TypeError( 'You can only extend lists with lists. ' 'You supplied \\\"%s\\\"' % type(item)) for entry in item: if not isinstance(entry, str): raise TypeError( 'Members of this object must be strings. ' 'You supplied \\\"%s\\\"' % type(entry)) list.append(self, entry)"
            },
            {
                "url": 3058,
                "code": "def pair_strings_sum_formatter(a, b): if b[:1] == \"-\": return \"{0} - {1}\".format(a, b[1:]) return \"{0} + {1}\".format(a, b)"
            },
            {
                "url": 3155,
                "code": "def generic_add(a, b): print logger.info('Called generic_add({}, {})'.format(a, b)) return a + b"
            },
            {
                "url": 5347,
                "code": "def append_text(self, txt): with open(self.fullname, \"a\") as myfile: myfile.write(txt)"
            }
        ],
        "url": 2100
    },
    {
        "nl_input": "how to check python object iterable",
        "code_input": [
            {
                "url": 1640,
                "code": "def is_iterable_but_not_string(obj): return hasattr(obj, '__iter__') and not isinstance(obj, str) and not isinstance(obj, bytes)"
            },
            {
                "url": 3950,
                "code": "def is_iterable(obj): return ( hasattr(obj, \"__iter__\") and not isinstance(obj, str) and not isinstance(obj, tuple) )"
            },
            {
                "url": 2522,
                "code": "def _is_iterable(item): return isinstance(item, collections.Iterable) and not isinstance(item, six.string_types)"
            },
            {
                "url": 2976,
                "code": "def is_iterable(value): return isinstance(value, np.ndarray) or isinstance(value, list) or isinstance(value, tuple), value"
            },
            {
                "url": 5900,
                "code": "def is_iterable(etype) -> bool: return type(etype) is GenericMeta and issubclass(etype.__extra__, Iterable)"
            },
            {
                "url": 2617,
                "code": "def ensure_iterable(inst): if isinstance(inst, string_types): return [inst] elif not isinstance(inst, collections.Iterable): return [inst] else: return inst"
            },
            {
                "url": 657,
                "code": "def is_iter_non_string(obj): if isinstance(obj, list) or isinstance(obj, tuple): return True return False"
            },
            {
                "url": 94,
                "code": "def listlike(obj): return hasattr(obj, \"__iter__\") \\ and not issubclass(type(obj), str)\\ and not issubclass(type(obj), unicode)"
            },
            {
                "url": 2443,
                "code": "def is_lazy_iterable(obj): return isinstance(obj, (types.GeneratorType, collections.MappingView, six.moves.range, enumerate))"
            },
            {
                "url": 1613,
                "code": "def is_iterable_of_int(l): r if not is_iterable(l): return False return all(is_int(value) for value in l)"
            },
            {
                "url": 4454,
                "code": "def assert_iter(**kw): for name, value in kw.items(): if not isiter(value): raise TypeError( 'paco: {} must be an iterable object'.format(name))"
            },
            {
                "url": 2401,
                "code": "def ensure_tuple(obj): if obj is None: return tuple() if isinstance(obj, Iterable) and not isinstance(obj, six.string_types): return tuple(obj) return obj,"
            },
            {
                "url": 753,
                "code": "def is_seq(obj): if not hasattr(obj, '__iter__'): return False if isinstance(obj, basestring): return False return True"
            },
            {
                "url": 850,
                "code": "def is_seq(obj): return (not is_str(obj) and not is_dict(obj) and (hasattr(obj, \"__getitem__\") or hasattr(obj, \"__iter__\")))"
            },
            {
                "url": 1757,
                "code": "def items(iterable): if hasattr(iterable, 'iteritems'): return (p for p in iterable.iteritems()) elif hasattr(iterable, 'items'): return (p for p in iterable.items()) else: return (p for p in enumerate(iterable))"
            }
        ],
        "url": 1640
    },
    {
        "nl_input": "python 3 tkinter open file dialog",
        "code_input": [
            {
                "url": 3956,
                "code": "def askopenfilename(**kwargs): try: from Tkinter import Tk import tkFileDialog as filedialog except ImportError: from tkinter import Tk, filedialog root = Tk() root.withdraw() root.update() filenames = filedialog.askopenfilename(**kwargs) root.destroy() return filenames"
            },
            {
                "url": 3547,
                "code": "def fileopenbox(msg=None, title=None, argInitialFile=None): return psidialogs.ask_file(message=msg, title=title, default=argInitialFile)"
            },
            {
                "url": 5115,
                "code": "def filesavebox(msg=None, title=None, argInitialFile=None): return psidialogs.ask_file(message=msg, title=title, default=argInitialFile, save=True)"
            },
            {
                "url": 3504,
                "code": "def ask_folder(message='Select folder.', default='', title=''): return backend_api.opendialog(\"ask_folder\", dict(message=message, default=default, title=title))"
            },
            {
                "url": 999,
                "code": "def alert(text='', title='', button=OK_TEXT, root=None, timeout=None): assert TKINTER_IMPORT_SUCCEEDED, 'Tkinter is required for pymsgbox' return _buttonbox(msg=text, title=title, choices=[str(button)], root=root, timeout=timeout)"
            },
            {
                "url": 494,
                "code": "def enable_gtk3(self, app=None): from pydev_ipython.inputhookgtk3 import create_inputhook_gtk3 self.set_inputhook(create_inputhook_gtk3(self._stdin_file)) self._current_gui = GUI_GTK"
            },
            {
                "url": 1796,
                "code": "def open_file(file, mode): if hasattr(file, \"read\"): return file if hasattr(file, \"open\"): return file.open(mode) return open(file, mode)"
            },
            {
                "url": 142,
                "code": "def test(): from spyder.utils.qthelpers import qapplication app = qapplication() dlg = ProjectDialog(None) dlg.show() sys.exit(app.exec_())"
            },
            {
                "url": 5737,
                "code": "def browse_dialog_dir(): _go_to_package() logger_directory.info(\"enter browse_dialog\") _path_bytes = subprocess.check_output(['python', 'gui_dir_browse.py'], shell=False) _path = _fix_path_bytes(_path_bytes, file=False) if len(_path) >= 1: _path = _path[0] else: _path = \"\" logger_directory.info(\"chosen path: {}\".format(_path)) logger_directory.info(\"exit browse_dialog\") return _path"
            },
            {
                "url": 5328,
                "code": "def open_as_pillow(filename): with __sys_open(filename, 'rb') as f: data = BytesIO(f.read()) return Image.open(data)"
            },
            {
                "url": 3882,
                "code": "def focusNext(self, event): try: event.widget.tk_focusNext().focus_set() except TypeError: # see tkinter equivalent code for tk_focusNext to see # commented original version name = event.widget.tk.call('tk_focusNext', event.widget._w) event.widget._nametowidget(str(name)).focus_set()"
            },
            {
                "url": 1731,
                "code": "def getFileDialogTitle(msg, title): if msg and title: return \"%s - %s\" % (title, msg) if msg and not title: return str(msg) if title and not msg: return str(title) return None"
            },
            {
                "url": 4640,
                "code": "def __enter__(self): self.fd = open(self.filename, 'a') fcntl.lockf(self.fd, fcntl.LOCK_EX) return self.fd"
            },
            {
                "url": 4899,
                "code": "def open(name=None, fileobj=None, closefd=True): return Guesser().open(name=name, fileobj=fileobj, closefd=closefd)"
            },
            {
                "url": 141,
                "code": "def closing_plugin(self, cancelable=False): self.dialog_manager.close_all() self.shell.exit_interpreter() return True"
            }
        ],
        "url": 3956
    },
    {
        "nl_input": "how to indent self python",
        "code_input": [
            {
                "url": 2724,
                "code": "def indent(self): blk = IndentBlock(self, self._indent) self._indent += 1 return blk"
            },
            {
                "url": 4266,
                "code": "def indent(self, message): indent = self.indent_char * self.indent_size return indent + message"
            },
            {
                "url": 6066,
                "code": "def indent(text: str, num: int = 2) -> str: lines = text.splitlines() return \"\\n\".join(indent_iterable(lines, num=num))"
            },
            {
                "url": 3479,
                "code": "def indent(s, spaces=4): new = re.sub('(\\n+)', '\\\\1%s' % (' ' * spaces), s) return (' ' * spaces) + new.strip()"
            },
            {
                "url": 5844,
                "code": "def PrintIndented(self, file, ident, code): for entry in code: print >>file, '%s%s' % (ident, entry)"
            },
            {
                "url": 3932,
                "code": "def indent(block, spaces): new_block = '' for line in block.split('\\n'): new_block += spaces + line + '\\n' return new_block"
            },
            {
                "url": 1446,
                "code": "def indented_show(text, howmany=1): print(StrTemplate.pad_indent(text=text, howmany=howmany))"
            },
            {
                "url": 3890,
                "code": "def pprint(self, ind): pp = pprint.PrettyPrinter(indent=ind) pp.pprint(self.tree)"
            },
            {
                "url": 1045,
                "code": "def _add_indent(string, indent): lines = string.split(\"\\n\") first, lines = lines[0], lines[1:] lines = [\"{indent}{s}\".format(indent=\" \" * indent, s=s) for s in lines] lines = [first] + lines return \"\\n\".join(lines)"
            },
            {
                "url": 2442,
                "code": "def get_indent(text): indent = '' ret = re.match(r'(\\s*)', text) if ret: indent = ret.group(1) return indent"
            },
            {
                "url": 3217,
                "code": "def indent(txt, spacing=4): return prefix(str(txt), ''.join([' ' for _ in range(spacing)]))"
            },
            {
                "url": 2982,
                "code": "def indent(text, amount, ch=' '): padding = amount * ch return ''.join(padding+line for line in text.splitlines(True))"
            },
            {
                "url": 31,
                "code": "def pformat(object, indent=1, width=80, depth=None): return PrettyPrinter(indent=indent, width=width, depth=depth).pformat(object)"
            },
            {
                "url": 4559,
                "code": "def GetIndentLevel(line): indent = Match(r'^( *)\\S', line) if indent: return len(indent.group(1)) else: return 0"
            },
            {
                "url": 2703,
                "code": "def get_indentation(func): src_lines = getsourcelines(func)[0] for line in src_lines: if not (line.startswith('@') or line.startswith('def') or line.lstrip().startswith('#')): return line[:len(line) - len(line.lstrip())] return pytypes.default_indent"
            }
        ],
        "url": 4150
    },
    {
        "nl_input": "tracking centroid of an object python",
        "code_input": [
            {
                "url": 4486,
                "code": "def compute_centroid(points): lats = [p[1] for p in points] lons = [p[0] for p in points] return Point(np.mean(lats), np.mean(lons), None)"
            },
            {
                "url": 4530,
                "code": "def find_dist_to_centroid(cvects, idx_list, weights=None): centroid = find_centroid(cvects, idx_list, weights) dist_vals = np.degrees(np.arccos((centroid * cvects.T[idx_list]).sum(1))) return dist_vals, centroid"
            },
            {
                "url": 6217,
                "code": "def _centroids(n_clusters: int, points: List[List[float]]) -> List[List[float]]: k_means = KMeans(n_clusters=n_clusters) k_means.fit(points) closest, _ = pairwise_distances_argmin_min(k_means.cluster_centers_, points) return list(map(list, np.array(points)[closest.tolist()]))"
            },
            {
                "url": 3603,
                "code": "def find_centroid(region): x, y = center_of_mass(region) w = np.argwhere(region) i, j = w[np.argmin(np.linalg.norm(w - (x, y), axis=1))] return i, j"
            },
            {
                "url": 1560,
                "code": "def _cal_dist2center(X, center): dmemb2cen = scipy.spatial.distance.cdist(X, center.reshape(1,X.shape[1]), metric='seuclidean') return(np.sum(dmemb2cen))"
            },
            {
                "url": 2064,
                "code": "def classify_clusters(points, n=10): arr = [[p.x, p.y] for p in points.values] clf = KMeans(n_clusters=n) clf.fit(arr) classes = clf.predict(arr) return classes"
            },
            {
                "url": 6124,
                "code": "def signed_distance(mesh, points): # make sure we have a numpy array points = np.asanyarray(points, dtype=np.float64) # find the closest point on the mesh to the queried points closest, distance, triangle_id = closest_point(mesh, points) # we only care about nonzero distances nonzero = distance > tol.merge if not nonzero.any(): return distance inside = mesh.ray.contains_points(points[nonzero]) sign = (inside.astype(int) * 2) - 1 # apply sign to previously computed distance distance[nonzero] *= sign return distance"
            },
            {
                "url": 3298,
                "code": "def manhattan_distance_numpy(object1, object2): return numpy.sum(numpy.absolute(object1 - object2), axis=1).T"
            },
            {
                "url": 5097,
                "code": "def cluster_kmeans(data, n_clusters, **kwargs): km = cl.KMeans(n_clusters, **kwargs) kmf = km.fit(data) labels = kmf.labels_ return labels, [np.nan]"
            },
            {
                "url": 3715,
                "code": "def mouse_get_pos(): p = POINT() AUTO_IT.AU3_MouseGetPos(ctypes.byref(p)) return p.x, p.y"
            },
            {
                "url": 4205,
                "code": "def _iterPoints(self, **kwargs): points = self.points count = len(points) index = 0 while count: yield points[index] count -= 1 index += 1"
            },
            {
                "url": 4743,
                "code": "def parsePoint(line): values = [float(s) for s in line.split(' ')] if values[0] == -1: # Convert -1 labels to 0 for MLlib values[0] = 0 return LabeledPoint(values[0], values[1:])"
            },
            {
                "url": 2502,
                "code": "def _position(): cursor = POINT() ctypes.windll.user32.GetCursorPos(ctypes.byref(cursor)) return (cursor.x, cursor.y)"
            },
            {
                "url": 1880,
                "code": "def debug(sequence): points = [] for i, p in enumerate(sequence): copy = Point(p) copy['index'] = i points.append(copy) return sequence.__class__(points)"
            },
            {
                "url": 347,
                "code": "def from_points(cls, list_of_lists): result = [] for l in list_of_lists: curve = [] for point in l: curve.append((point.lon, point.lat)) result.append(curve) return Polygon(result)"
            }
        ],
        "url": 4486
    },
    {
        "nl_input": "python3 ctypes return float array",
        "code_input": [
            {
                "url": 82,
                "code": "def cfloat32_array_to_numpy(cptr, length): if isinstance(cptr, ctypes.POINTER(ctypes.c_float)): return np.fromiter(cptr, dtype=np.float32, count=length) else: raise RuntimeError('Expected float pointer')"
            },
            {
                "url": 64,
                "code": "def cfloat64_array_to_numpy(cptr, length): if isinstance(cptr, ctypes.POINTER(ctypes.c_double)): return np.fromiter(cptr, dtype=np.float64, count=length) else: raise RuntimeError('Expected double pointer')"
            },
            {
                "url": 79,
                "code": "def cint32_array_to_numpy(cptr, length): if isinstance(cptr, ctypes.POINTER(ctypes.c_int32)): return np.fromiter(cptr, dtype=np.int32, count=length) else: raise RuntimeError('Expected int pointer')"
            },
            {
                "url": 84,
                "code": "def cint8_array_to_numpy(cptr, length): if isinstance(cptr, ctypes.POINTER(ctypes.c_int8)): return np.fromiter(cptr, dtype=np.int8, count=length) else: raise RuntimeError('Expected int pointer')"
            },
            {
                "url": 1885,
                "code": "def c_array(ctype, values): if isinstance(values, np.ndarray) and values.dtype.itemsize == ctypes.sizeof(ctype): return (ctype * len(values)).from_buffer_copy(values) return (ctype * len(values))(*values)"
            },
            {
                "url": 4148,
                "code": "def ensure_dtype_float(x, default=np.float64): r if isinstance(x, np.ndarray): if x.dtype.kind == 'f': return x elif x.dtype.kind == 'i': return x.astype(default) else: raise TypeError('x is of type '+str(x.dtype)+' that cannot be converted to float') else: raise TypeError('x is not an array')"
            },
            {
                "url": 4198,
                "code": "def _maybe_cast_to_float64(da): if da.dtype == np.float32: logging.warning('Datapoints were stored using the np.float32 datatype.' 'For accurate reduction operations using bottleneck, ' 'datapoints are being cast to the np.float64 datatype.' ' For more information see: https://github.com/pydata/' 'xarray/issues/1346') return da.astype(np.float64) else: return da"
            },
            {
                "url": 2305,
                "code": "def is_float_array(val): return is_np_array(val) and issubclass(val.dtype.type, np.floating)"
            },
            {
                "url": 655,
                "code": "def is_float_array(l): r if isinstance(l, np.ndarray): if l.dtype.kind == 'f': return True return False"
            },
            {
                "url": 1870,
                "code": "def _to_array(value): if isinstance(value, (tuple, list)): return array(value) elif isinstance(value, (float, int)): return np.float64(value) else: return value"
            },
            {
                "url": 4251,
                "code": "def from_pystr_to_cstr(data): if not isinstance(data, list): raise NotImplementedError pointers = (ctypes.c_char_p * len(data))() if PY3: data = [bytes(d, 'utf-8') for d in data] else: data = [d.encode('utf-8') if isinstance(d, unicode) else d # pylint: disable=undefined-variable for d in data] pointers[:] = data return pointers"
            },
            {
                "url": 854,
                "code": "def as_float_array(a): return np.asarray(a, dtype=np.quaternion).view((np.double, 4))"
            },
            {
                "url": 9,
                "code": "def _convert_to_array(array_like, dtype): if isinstance(array_like, bytes): return np.frombuffer(array_like, dtype=dtype) return np.asarray(array_like, dtype=dtype)"
            },
            {
                "url": 2549,
                "code": "def read_numpy(fd, byte_order, dtype, count): return numpy.fromfile(fd, byte_order+dtype[-1], count)"
            },
            {
                "url": 1583,
                "code": "def dict_to_numpy_array(d): return fromarrays(d.values(), np.dtype([(str(k), v.dtype) for k, v in d.items()]))"
            }
        ],
        "url": 82
    },
    {
        "nl_input": "how to make paragraphs in python",
        "code_input": [
            {
                "url": 5074,
                "code": "def paragraph(separator='\\n\\n', wrap_start='', wrap_end='', html=False, sentences_quantity=3): return paragraphs(quantity=1, separator=separator, wrap_start=wrap_start, wrap_end=wrap_end, html=html, sentences_quantity=sentences_quantity)"
            },
            {
                "url": 1424,
                "code": "def format_screen(strng): # Paragraph continue par_re = re.compile(r'\\\\$',re.MULTILINE) strng = par_re.sub('',strng) return strng"
            },
            {
                "url": 342,
                "code": "def make_html_code( self, lines ): line = code_header + '\\n' for l in lines: line = line + html_quote( l ) + '\\n' return line + code_footer"
            },
            {
                "url": 1292,
                "code": "def split_into_sentences(s): s = re.sub(r\"\\s+\", \" \", s) s = re.sub(r\"[\\\\.\\\\?\\\\!]\", \"\\n\", s) return s.split(\"\\n\")"
            },
            {
                "url": 5309,
                "code": "def code_from_ipynb(nb, markdown=False): code = PREAMBLE for cell in nb['cells']: if cell['cell_type'] == 'code': # transform the input to executable Python code += ''.join(cell['source']) if cell['cell_type'] == 'markdown': code += '\\n# ' + '# '.join(cell['source']) # We want a blank newline after each cell's output. # And the last line of source doesn't have a newline usually. code += '\\n\\n' return code"
            },
            {
                "url": 6066,
                "code": "def indent(text: str, num: int = 2) -> str: lines = text.splitlines() return \"\\n\".join(indent_iterable(lines, num=num))"
            },
            {
                "url": 4458,
                "code": "def _split_python(python): python = _preprocess(python) if not python: return [] lexer = PythonSplitLexer() lexer.read(python) return lexer.chunks"
            },
            {
                "url": 2970,
                "code": "def markdown_to_text(body): # Turn our input into HTML md = markdown.markdown(body, extensions=[ 'markdown.extensions.extra' ]) # Safely parse HTML so that we don't have to parse it ourselves soup = BeautifulSoup(md, 'html.parser') # Return just the text of the parsed HTML return soup.get_text()"
            },
            {
                "url": 3257,
                "code": "def do_wordwrap(s, width=79, break_long_words=True): import textwrap return u'\\n'.join(textwrap.wrap(s, width=width, expand_tabs=False, replace_whitespace=False, break_long_words=break_long_words))"
            },
            {
                "url": 4035,
                "code": "def get_codeblock(language, text): rst = \"\\n\\n.. code-block:: \" + language + \"\\n\\n\" for line in text.splitlines(): rst += \"\\t\" + line + \"\\n\" rst += \"\\n\" return rst"
            },
            {
                "url": 4788,
                "code": "def clean_text_by_sentences(text, language=\"english\", additional_stopwords=None): init_textcleanner(language, additional_stopwords) original_sentences = split_sentences(text) filtered_sentences = filter_words(original_sentences) return merge_syntactic_units(original_sentences, filtered_sentences)"
            },
            {
                "url": 1446,
                "code": "def indented_show(text, howmany=1): print(StrTemplate.pad_indent(text=text, howmany=howmany))"
            },
            {
                "url": 6222,
                "code": "def enumerate_chunks (phrase, spacy_nlp): if (len(phrase) > 1): found = False text = \" \".join([rl.text for rl in phrase]) doc = spacy_nlp(text.strip(), parse=True) for np in doc.noun_chunks: if np.text != text: found = True yield np.text, find_chunk(phrase, np.text.split(\" \")) if not found and all([rl.pos[0] != \"v\" for rl in phrase]): yield text, phrase"
            },
            {
                "url": 4482,
                "code": "def wrap(text, indent=' '): wrapper = textwrap.TextWrapper( width=int(os.environ.get('COLUMNS', 80)), initial_indent=indent, subsequent_indent=indent ) return '\\n'.join(wrapper.wrap(text))"
            },
            {
                "url": 1938,
                "code": "def fill_document(doc): with doc.create(Section('A section')): doc.append('Some regular text and some ') doc.append(italic('italic text. ')) with doc.create(Subsection('A subsection')): doc.append('Also some crazy characters: $&#{}')"
            }
        ],
        "url": 5074
    },
    {
        "nl_input": "python rest requests delete",
        "code_input": [
            {
                "url": 5719,
                "code": "def delete(self, endpoint: str, **kwargs) -> dict: return self._request('DELETE', endpoint, **kwargs)"
            },
            {
                "url": 2301,
                "code": "def requests_request(method, url, **kwargs): session = local_sessions.session response = session.request(method=method, url=url, **kwargs) session.close() return response"
            },
            {
                "url": 5922,
                "code": "def _request(self, method: str, endpoint: str, params: dict = None, data: dict = None, headers: dict = None) -> dict:"
            },
            {
                "url": 1047,
                "code": "def requests_post(url, data=None, json=None, **kwargs): return requests_request('post', url, data=data, json=json, **kwargs)"
            },
            {
                "url": 3162,
                "code": "def send_post(self, url, data, remove_header=None): return self.send_request(method=\"post\", url=url, data=data, remove_header=remove_header)"
            },
            {
                "url": 5305,
                "code": "def deleteAll(self): for core in self.endpoints: self._send_solr_command(self.endpoints[core], \"{\\\"delete\\\": { \\\"query\\\" : \\\"*:*\\\"}}\")"
            },
            {
                "url": 5042,
                "code": "def request(self, method, url, body=None, headers={}): self._send_request(method, url, body, headers)"
            },
            {
                "url": 4494,
                "code": "def delete(args): m = RiverManager(args.hosts) m.delete(args.name)"
            },
            {
                "url": 6123,
                "code": "def put(self, endpoint: str, **kwargs) -> dict: return self._request('PUT', endpoint, **kwargs)"
            },
            {
                "url": 2630,
                "code": "def delete(gandi, resource): result = gandi.dnssec.delete(resource) gandi.echo('Delete successful.') return result"
            },
            {
                "url": 2569,
                "code": "def _delete_keys(dct, keys): c = deepcopy(dct) assert isinstance(keys, list) for k in keys: c.pop(k) return c"
            },
            {
                "url": 1455,
                "code": "def remove_file_from_s3(awsclient, bucket, key): client_s3 = awsclient.get_client('s3') response = client_s3.delete_object(Bucket=bucket, Key=key)"
            },
            {
                "url": 1027,
                "code": "def http_request_json(*args, **kwargs): ret, status = http_request(*args, **kwargs) return json.loads(ret), status"
            },
            {
                "url": 4062,
                "code": "def __delitem__(self, key): index, value = self._dict.pop(key) key2, value2 = self._list.pop(index) assert key == key2 assert value is value2 self._fix_indices_after_delete(index)"
            },
            {
                "url": 3330,
                "code": "def setup_request_sessions(self): self.req_session = requests.Session() self.req_session.headers.update(self.headers)"
            }
        ],
        "url": 5719
    },
    {
        "nl_input": "python replace month number",
        "code_input": [
            {
                "url": 2762,
                "code": "def replace_month_abbr_with_num(date_str, lang=DEFAULT_DATE_LANG): num, abbr = get_month_from_date_str(date_str, lang) return re.sub(abbr, str(num), date_str, flags=re.IGNORECASE)"
            },
            {
                "url": 5613,
                "code": "def pmon(month): year, month = month.split('-') return '{month_name}, {year}'.format( month_name=calendar.month_name[int(month)], year=year, )"
            },
            {
                "url": 4870,
                "code": "def convert_date(date): date = convert_month(date, shorten=False) clean_string = convert_string(date) return datetime.strptime(clean_string, DATE_FMT.replace('-',''))"
            },
            {
                "url": 4831,
                "code": "def day_to_month(timeperiod): t = datetime.strptime(timeperiod, SYNERGY_DAILY_PATTERN) return t.strftime(SYNERGY_MONTHLY_PATTERN)"
            },
            {
                "url": 4935,
                "code": "def get_month_namedays(self, month=None): if month is None: month = datetime.now().month return self.NAMEDAYS[month-1]"
            },
            {
                "url": 6195,
                "code": "def months_ago(date, nb_months=1): nb_years = nb_months // 12 nb_months = nb_months % 12 month_diff = date.month - nb_months if month_diff > 0: new_month = month_diff else: new_month = 12 + month_diff nb_years += 1 return date.replace(day=1, month=new_month, year=date.year - nb_years)"
            },
            {
                "url": 4308,
                "code": "def _replace(self, data, replacements): for find, repl in replacements: data = data.replace(find, repl) return data"
            },
            {
                "url": 419,
                "code": "def get_month_start(day=None): day = add_timezone(day or datetime.date.today()) return day.replace(day=1)"
            },
            {
                "url": 1709,
                "code": "def monthly(date=datetime.date.today()): return datetime.date(date.year, date.month, 1)"
            },
            {
                "url": 113,
                "code": "def start_of_month(val): if type(val) == date: val = datetime.fromordinal(val.toordinal()) return start_of_day(val).replace(day=1)"
            },
            {
                "url": 405,
                "code": "def get_month_start_end_day(): t = date.today() n = mdays[t.month] return (date(t.year, t.month, 1), date(t.year, t.month, n))"
            },
            {
                "url": 5061,
                "code": "def replace(self, text): for (pattern, repl) in self.patterns: text = re.subn(pattern, repl, text)[0] return text"
            },
            {
                "url": 3181,
                "code": "def replace(s, replace): for r in replace: s = s.replace(*r) return s"
            },
            {
                "url": 403,
                "code": "def calculate_month(birth_date): year = int(birth_date.strftime('%Y')) month = int(birth_date.strftime('%m')) + ((int(year / 100) - 14) % 5) * 20 return month"
            },
            {
                "url": 5637,
                "code": "def __replace_all(repls: dict, input: str) -> str: return re.sub('|'.join(re.escape(key) for key in repls.keys()), lambda k: repls[k.group(0)], input)"
            }
        ],
        "url": 2762
    },
    {
        "nl_input": "how to tell what type of data object is in python",
        "code_input": [
            {
                "url": 3078,
                "code": "def _is_date_data(self, data_type): dt = DATA_TYPES[data_type] if isinstance(self.data, dt['type']): self.type = data_type.upper() self.len = None return True"
            },
            {
                "url": 1789,
                "code": "def is_string(obj): if PYTHON3: str_type = (bytes, str) else: str_type = (bytes, str, unicode) return isinstance(obj, str_type)"
            },
            {
                "url": 218,
                "code": "def is_date(thing): # known date types date_types = (datetime.datetime, datetime.date, DateTime) return isinstance(thing, date_types)"
            },
            {
                "url": 198,
                "code": "def is_dataframe(obj): try: # This is the best method of type checking from pandas import DataFrame return isinstance(obj, DataFrame) except ImportError: # Pandas is not a dependency, so this is scary return obj.__class__.__name__ == \"DataFrame\""
            },
            {
                "url": 2141,
                "code": "def isstring(value): classes = (str, bytes) if pyutils.PY3 else basestring # noqa: F821 return isinstance(value, classes)"
            },
            {
                "url": 530,
                "code": "def _isstring(dtype): return dtype.type == numpy.unicode_ or dtype.type == numpy.string_"
            },
            {
                "url": 285,
                "code": "def make_kind_check(python_types, numpy_kind): def check(value): if hasattr(value, 'dtype'): return value.dtype.kind == numpy_kind return isinstance(value, python_types) return check"
            },
            {
                "url": 848,
                "code": "def _api_type(self, value): if isinstance(value, six.string_types): return 'string' elif isinstance(value, six.integer_types): return 'integer' elif type(value) is datetime.datetime: return 'date'"
            },
            {
                "url": 2997,
                "code": "def is_valid_data(obj): if obj: try: tmp = json.dumps(obj, default=datetime_encoder) del tmp except (TypeError, UnicodeDecodeError): return False return True"
            },
            {
                "url": 2045,
                "code": "def is_date_type(cls): if not isinstance(cls, type): return False return issubclass(cls, date) and not issubclass(cls, datetime)"
            },
            {
                "url": 768,
                "code": "def is_type(value): if isinstance(value, type): return issubclass(value, Type) return isinstance(value, Type)"
            },
            {
                "url": 2087,
                "code": "def is_text(obj, name=None): try: # python2 ans = isinstance(obj, basestring) except NameError: # python3 ans = isinstance(obj, str) if name: print(\"is_text: (%s) %s = %s\" % (ans, name, obj.__class__), file=sys.stderr) return ans"
            },
            {
                "url": 308,
                "code": "def type_converter(text): if text.isdigit(): return int(text), int try: return float(text), float except ValueError: return text, STRING_TYPE"
            },
            {
                "url": 2998,
                "code": "def _deserialize_datetime(self, data): for key in data: if isinstance(data[key], dict): if data[key].get('type') == 'datetime': data[key] = \\ datetime.datetime.fromtimestamp(data[key]['value']) return data"
            },
            {
                "url": 5589,
                "code": "def is_unicode(string): str_type = str(type(string)) if str_type.find('str') > 0 or str_type.find('unicode') > 0: return True return False"
            }
        ],
        "url": 2128
    },
    {
        "nl_input": "python jsonschema validate schema file",
        "code_input": [
            {
                "url": 1679,
                "code": "def schemaValidateFile(self, filename, options): ret = libxml2mod.xmlSchemaValidateFile(self._o, filename, options) return ret"
            },
            {
                "url": 5004,
                "code": "def _validate(data, schema, ac_schema_safe=True, **options): try: jsonschema.validate(data, schema, **options) except (jsonschema.ValidationError, jsonschema.SchemaError, Exception) as exc: if ac_schema_safe: return (False, str(exc)) # Validation was failed. raise return (True, '')"
            },
            {
                "url": 6156,
                "code": "def validate(request: Union[Dict, List], schema: dict) -> Union[Dict, List]: jsonschema_validate(request, schema) return request"
            },
            {
                "url": 1646,
                "code": "def SchemaValidate(self, xsd): ret = libxml2mod.xmlTextReaderSchemaValidate(self._o, xsd) return ret"
            },
            {
                "url": 687,
                "code": "def validate(raw_schema, target=None, **kwargs): schema = schema_validator(raw_schema, **kwargs) if target is not None: validate_object(target, schema=schema, **kwargs)"
            },
            {
                "url": 4707,
                "code": "def validate(schema, data, owner=None): schema._validate(data=data, owner=owner)"
            },
            {
                "url": 1302,
                "code": "def load_schema(schema_path): with open(schema_path, 'r') as schema_file: schema = simplejson.load(schema_file) resolver = RefResolver('', '', schema.get('models', {})) return build_request_to_validator_map(schema, resolver)"
            },
            {
                "url": 5530,
                "code": "def main(source): if source is None: click.echo( \"You need to supply a file or url to a schema to a swagger schema, for\" \"the validator to work.\" ) return 1 try: load(source) click.echo(\"Validation passed\") return 0 except ValidationError as e: raise click.ClickException(str(e))"
            },
            {
                "url": 5130,
                "code": "def timestamping_validate(data, schema): jsonschema.validate(data, schema) data['timestamp'] = str(time.time())"
            },
            {
                "url": 5344,
                "code": "def validate(payload, schema): v = jsonschema.Draft4Validator( schema, format_checker=jsonschema.FormatChecker()) error_list = [] for error in v.iter_errors(payload): message = error.message location = '/' + '/'.join([str(c) for c in error.absolute_path]) error_list.append(message + ' at ' + location) return error_list"
            },
            {
                "url": 3311,
                "code": "def validate(self, xml_input): parsed_xml = etree.parse(self._handle_xml(xml_input)) try: return self.xmlschema.validate(parsed_xml) except AttributeError: raise CannotValidate('Set XSD to validate the XML')"
            },
            {
                "url": 1641,
                "code": "def validate(datum, schema, field=None, raise_errors=True): record_type = extract_record_type(schema) result = None validator = VALIDATORS.get(record_type) if validator: result = validator(datum, schema=schema, parent_ns=field, raise_errors=raise_errors) elif record_type in SCHEMA_DEFS: result = validate(datum, schema=SCHEMA_DEFS[record_type], field=field, raise_errors=raise_errors) else: raise UnknownType(record_type) if raise_errors and result is False: raise ValidationError(ValidationErrorData(datum, schema, field)) return result"
            },
            {
                "url": 3456,
                "code": "def schemaParse(self): ret = libxml2mod.xmlSchemaParse(self._o) if ret is None:raise parserError('xmlSchemaParse() failed') __tmp = Schema(_obj=ret) return __tmp"
            },
            {
                "url": 4252,
                "code": "def document(schema): teleport_schema = from_val(schema) return json.dumps(teleport_schema, sort_keys=True, indent=2)"
            },
            {
                "url": 3826,
                "code": "def cli(yamlfile, format, output): print(OwlSchemaGenerator(yamlfile, format).serialize(output=output))"
            }
        ],
        "url": 5004
    },
    {
        "nl_input": "get wechat access token python",
        "code_input": [
            {
                "url": 6100,
                "code": "def access_token(self): access_token = self.session.get(self.access_token_key) if access_token: if not self.expires_at: # user provided access_token, just return it return access_token timestamp = time.time() if self.expires_at - timestamp > 60: return access_token self.fetch_access_token() return self.session.get(self.access_token_key)"
            },
            {
                "url": 2539,
                "code": "def get_tweepy_auth(twitter_api_key, twitter_api_secret, twitter_access_token, twitter_access_token_secret): auth = tweepy.OAuthHandler(twitter_api_key, twitter_api_secret) auth.set_access_token(twitter_access_token, twitter_access_token_secret) return auth"
            },
            {
                "url": 2605,
                "code": "def fetch_token(self, **kwargs): return super(AsanaOAuth2Session, self).fetch_token(self.token_url, client_secret=self.client_secret, **kwargs)"
            },
            {
                "url": 909,
                "code": "def _get_token(self, oauth_request, token_type='access'): token_field = oauth_request.get_parameter('oauth_token') token = self.data_store.lookup_token(token_type, token_field) if not token: raise OAuthError('Invalid %s token: %s' % (token_type, token_field)) return token"
            },
            {
                "url": 3710,
                "code": "def get_oauth_token(): url = \"{0}/token\".format(DEFAULT_ORIGIN[\"Origin\"]) r = s.get(url=url) return r.json()[\"t\"]"
            },
            {
                "url": 2637,
                "code": "def get_boto_session( region, aws_access_key_id=None, aws_secret_access_key=None, aws_session_token=None ): return boto3.session.Session( region_name=region, aws_secret_access_key=aws_secret_access_key, aws_access_key_id=aws_access_key_id, aws_session_token=aws_session_token )"
            },
            {
                "url": 1041,
                "code": "def get_auth(): import getpass user = input(\"User Name: \") # noqa pswd = getpass.getpass('Password: ') return Github(user, pswd)"
            },
            {
                "url": 5920,
                "code": "async def login( username: str, password: str, brand: str, websession: ClientSession = None) -> API: api = API(brand, websession) await api.authenticate(username, password) return api"
            },
            {
                "url": 3871,
                "code": "def _handle_authentication_error(self): response = make_response('Access Denied') response.headers['WWW-Authenticate'] = self.auth.get_authenticate_header() response.status_code = 401 return response"
            },
            {
                "url": 1570,
                "code": "def get_request(self, request): request.transport_user = self.username request.transport_password = self.api_key return request"
            },
            {
                "url": 5315,
                "code": "def login(self, username, password=None, token=None): self.session.basic_auth(username, password)"
            },
            {
                "url": 3158,
                "code": "def __call__(self, r): r.headers['Authorization'] = 'JWT {jwt}'.format(jwt=self.token) return r"
            },
            {
                "url": 2944,
                "code": "def get_csrf_token(response): cookie_headers = [ h.decode('ascii') for h in response.headers.getlist(\"Set-Cookie\") ] if not cookie_headers: return None csrf_headers = [ h for h in cookie_headers if h.startswith(\"csrftoken=\") ] if not csrf_headers: return None match = re.match(\"csrftoken=([^ ;]+);\", csrf_headers[-1]) return match.group(1)"
            },
            {
                "url": 4117,
                "code": "def __init__(self, token, editor=None): self.token = token self.editor = editor self.session = requests.Session()"
            },
            {
                "url": 3521,
                "code": "def _is_expired_response(self, response): if response.status_code != 401: return False challenge = response.headers.get('www-authenticate', '') return 'error=\"invalid_token\"' in challenge"
            }
        ],
        "url": 6100
    },
    {
        "nl_input": "python change str value to int",
        "code_input": [
            {
                "url": 1860,
                "code": "def str2int(string_with_int): return int(\"\".join([char for char in string_with_int if char in string.digits]) or 0)"
            },
            {
                "url": 4197,
                "code": "def str_to_num(str_value): str_value = str(str_value) try: return int(str_value) except ValueError: return float(str_value)"
            },
            {
                "url": 3791,
                "code": "def cast_int(x): try: x = int(x) except ValueError: try: x = x.strip() except AttributeError as e: logger_misc.warn(\"parse_str: AttributeError: String not number or word, {}, {}\".format(x, e)) return x"
            },
            {
                "url": 1329,
                "code": "def validate_int(value): if value and not isinstance(value, int): try: int(str(value)) except (TypeError, ValueError): raise ValidationError('not a valid number') return value"
            },
            {
                "url": 6171,
                "code": "def convert_to_int(x: Any, default: int = None) -> int: try: return int(x) except (TypeError, ValueError): return default"
            },
            {
                "url": 5836,
                "code": "def clean_int(x) -> int: try: return int(x) except ValueError: raise forms.ValidationError( \"Cannot convert to integer: {}\".format(repr(x)))"
            },
            {
                "url": 1603,
                "code": "def string_to_int( s ): result = 0 for c in s: if not isinstance(c, int): c = ord( c ) result = 256 * result + c return result"
            },
            {
                "url": 2036,
                "code": "def bin_to_int(string): if isinstance(string, str): return struct.unpack(\"b\", string)[0] else: return struct.unpack(\"b\", bytes([string]))[0]"
            },
            {
                "url": 5603,
                "code": "def try_cast_int(s): try: temp = re.findall('\\d', str(s)) temp = ''.join(temp) return int(temp) except: return s"
            },
            {
                "url": 5643,
                "code": "def strings_to_integers(strings: Iterable[str]) -> Iterable[int]: return strings_to_(strings, lambda x: int(float(x)))"
            },
            {
                "url": 2437,
                "code": "def check_int(integer): if not isinstance(integer, str): return False if integer[0] in ('-', '+'): return integer[1:].isdigit() return integer.isdigit()"
            },
            {
                "url": 2494,
                "code": "def safe_int(val, default=None): try: val = int(val) except (ValueError, TypeError): val = default return val"
            },
            {
                "url": 40,
                "code": "def get_number(s, cast=int): import string d = \"\".join(x for x in str(s) if x in string.digits) return cast(d)"
            },
            {
                "url": 1791,
                "code": "def is_int(string): try: a = float(string) b = int(a) except ValueError: return False else: return a == b"
            },
            {
                "url": 1831,
                "code": "def str2int(num, radix=10, alphabet=BASE85): return NumConv(radix, alphabet).str2int(num)"
            }
        ],
        "url": 1831
    },
    {
        "nl_input": "implementing drag and drop python",
        "code_input": [
            {
                "url": 547,
                "code": "def drag_and_drop(self, droppable): self.scroll_to() ActionChains(self.parent.driver).drag_and_drop(self._element, droppable._element).perform()"
            },
            {
                "url": 3970,
                "code": "def mouseMoveEvent(self, event): self.declaration.mouse_move_event(event) super(QtGraphicsView, self).mouseMoveEvent(event)"
            },
            {
                "url": 984,
                "code": "def mouse_move_event(self, event): self.example.mouse_position_event(event.x(), event.y())"
            },
            {
                "url": 1556,
                "code": "def _on_release(self, event): if self._drag_cols or self._drag_rows: self._visual_drag.place_forget() self._dragged_col = None self._dragged_row = None"
            },
            {
                "url": 2473,
                "code": "def onLeftDown(self, event=None): if event is None: return self.cursor_mode_action('leftdown', event=event) self.ForwardEvent(event=event.guiEvent)"
            },
            {
                "url": 5654,
                "code": "def mouse_event(dwFlags: int, dx: int, dy: int, dwData: int, dwExtraInfo: int) -> None: ctypes.windll.user32.mouse_event(dwFlags, dx, dy, dwData, dwExtraInfo)"
            },
            {
                "url": 5125,
                "code": "def detach(self, *items): self._visual_drag.detach(*items) ttk.Treeview.detach(self, *items)"
            },
            {
                "url": 4739,
                "code": "def move(self, x, y): self._cursor = self._normalizePoint(x, y)"
            },
            {
                "url": 4232,
                "code": "def on_mouse_motion(self, x, y, dx, dy): # Screen coordinates relative to the lower-left corner # so we have to flip the y axis to make this consistent with # other window libraries self.example.mouse_position_event(x, self.buffer_height - y)"
            },
            {
                "url": 1082,
                "code": "def mouse_out(self): self.scroll_to() ActionChains(self.parent.driver).move_by_offset(0, 0).click().perform()"
            },
            {
                "url": 4671,
                "code": "def click_by_selector(self, selector): # No need for separate button press step with selector style. elem = find_element_by_jquery(world.browser, selector) elem.click()"
            },
            {
                "url": 4664,
                "code": "def wheel(delta=1): location = get_position() e = Quartz.CGEventCreateMouseEvent( None, Quartz.kCGEventScrollWheel, location, Quartz.kCGMouseButtonLeft) e2 = Quartz.CGEventCreateScrollWheelEvent( None, Quartz.kCGScrollEventUnitLine, 1, delta) Quartz.CGEventPost(Quartz.kCGHIDEventTap, e) Quartz.CGEventPost(Quartz.kCGHIDEventTap, e2)"
            },
            {
                "url": 1924,
                "code": "def OnMove(self, event): # Store window position in config position = self.main_window.GetScreenPositionTuple() config[\"window_position\"] = repr(position)"
            },
            {
                "url": 3498,
                "code": "def get_python(self): if self.multiselect: return super(MultiSelectField, self).get_python() return self._get()"
            },
            {
                "url": 5377,
                "code": "def ms_panset(self, viewer, event, data_x, data_y, msg=True): if self.canpan and (event.state == 'down'): self._panset(viewer, data_x, data_y, msg=msg) return True"
            }
        ],
        "url": 547
    },
    {
        "nl_input": "get unique list from two lists python",
        "code_input": [
            {
                "url": 1903,
                "code": "def unique(list): unique = []; [unique.append(x) for x in list if x not in unique] return unique"
            },
            {
                "url": 351,
                "code": "def unique_list(lst): uniq = [] for item in lst: if item not in uniq: uniq.append(item) return uniq"
            },
            {
                "url": 646,
                "code": "def unique(_list): ret = [] for item in _list: if item not in ret: ret.append(item) return ret"
            },
            {
                "url": 574,
                "code": "def unique(input_list): output = [] for item in input_list: if item not in output: output.append(item) return output"
            },
            {
                "url": 431,
                "code": "def unique_list_dicts(dlist, key): return list(dict((val[key], val) for val in dlist).values())"
            },
            {
                "url": 10,
                "code": "def get_uniques(l): result = [] for i in l: if i not in result: result.append(i) return result"
            },
            {
                "url": 1304,
                "code": "def unique(iterable): seen = set() return [x for x in iterable if x not in seen and not seen.add(x)]"
            },
            {
                "url": 440,
                "code": "def _uniquify(_list): seen = set() result = [] for x in _list: if x not in seen: result.append(x) seen.add(x) return result"
            },
            {
                "url": 1049,
                "code": "def uniquify_list(L): return [e for i, e in enumerate(L) if L.index(e) == i]"
            },
            {
                "url": 1431,
                "code": "def remove_list_duplicates(lista, unique=False): result = [] allready = [] for elem in lista: if elem not in result: result.append(elem) else: allready.append(elem) if unique: for elem in allready: result = list(filter((elem).__ne__, result)) return result"
            },
            {
                "url": 4591,
                "code": "def unique(iterable): seen = set() for item in iterable: if item not in seen: seen.add(item) yield item"
            },
            {
                "url": 5929,
                "code": "def uniqued(iterable): seen = set() return [item for item in iterable if item not in seen and not seen.add(item)]"
            },
            {
                "url": 2358,
                "code": "def unique_element(ll): seen = {} result = [] for item in ll: if item in seen: continue seen[item] = 1 result.append(item) return result"
            },
            {
                "url": 2872,
                "code": "def unique_items(seq): seen = set() return [x for x in seq if not (x in seen or seen.add(x))]"
            },
            {
                "url": 6224,
                "code": "def uniqued(iterable): seen = set() add = seen.add return [i for i in iterable if i not in seen and not add(i)]"
            }
        ],
        "url": 351
    },
    {
        "nl_input": "python 3 not runnning in git bash",
        "code_input": [
            {
                "url": 1084,
                "code": "def bash(filename): sys.stdout.flush() subprocess.call(\"bash {}\".format(filename), shell=True)"
            },
            {
                "url": 632,
                "code": "def check_git(): try: with open(os.devnull, \"wb\") as devnull: subprocess.check_call([\"git\", \"--version\"], stdout=devnull, stderr=devnull) except: raise RuntimeError(\"Please make sure git is installed and on your path.\")"
            },
            {
                "url": 2786,
                "code": "def install_rpm_py(): python_path = sys.executable cmd = '{0} install.py'.format(python_path) exit_status = os.system(cmd) if exit_status != 0: raise Exception('Command failed: {0}'.format(cmd))"
            },
            {
                "url": 1156,
                "code": "def _python_rpath(self): # Windows virtualenv installation installs pip to the [Ss]cripts # folder. Here's a simple check to support: if sys.platform == 'win32': return os.path.join('Scripts', 'python.exe') return os.path.join('bin', 'python')"
            },
            {
                "url": 4079,
                "code": "def run_cmd(command, verbose=True, shell='/bin/bash'): process = Popen(command, shell=True, stdout=PIPE, stderr=STDOUT, executable=shell) output = process.stdout.read().decode().strip().split('\\n') if verbose: # return full output including empty lines return output return [line for line in output if line.strip()]"
            },
            {
                "url": 3289,
                "code": "def venv(): try: import virtualenv # NOQA except ImportError: sh(\"%s -m pip install virtualenv\" % PYTHON) if not os.path.isdir(\"venv\"): sh(\"%s -m virtualenv venv\" % PYTHON) sh(\"venv\\\\Scripts\\\\pip install -r %s\" % (REQUIREMENTS_TXT))"
            },
            {
                "url": 3493,
                "code": "def check_dependencies_remote(args): cmd = [args.python, '-m', 'depends', args.requirement] env = dict(PYTHONPATH=os.path.dirname(__file__)) return subprocess.check_call(cmd, env=env)"
            },
            {
                "url": 118,
                "code": "def test(*args): subprocess.call([\"py.test-2.7\"] + list(args)) subprocess.call([\"py.test-3.4\"] + list(args))"
            },
            {
                "url": 4078,
                "code": "def install_plugin(username, repo): print(\"Installing plugin from \" + username + \"/\" + repo) pip.main(['install', '-U', \"git+git://github.com/\" + username + \"/\" + repo + \".git\"])"
            },
            {
                "url": 4196,
                "code": "def vsh(cmd, *args, **kw): args = '\" \"'.join(i.replace('\"', r'\\\"') for i in args) easy.sh('\"%s\" \"%s\"' % (venv_bin(cmd), args))"
            },
            {
                "url": 2666,
                "code": "def is_git_repo(): cmd = \"git\", \"rev-parse\", \"--git-dir\" try: subprocess.run(cmd, stdout=subprocess.DEVNULL, check=True) return True except subprocess.CalledProcessError: return False"
            },
            {
                "url": 668,
                "code": "def get_python(): if sys.platform == 'win32': python = path.join(VE_ROOT, 'Scripts', 'python.exe') else: python = path.join(VE_ROOT, 'bin', 'python') return python"
            },
            {
                "url": 705,
                "code": "def _stdin_(p): _v = sys.version[0] return input(p) if _v is '3' else raw_input(p)"
            },
            {
                "url": 239,
                "code": "def _pip_exists(self): return os.path.isfile(os.path.join(self.path, 'bin', 'pip'))"
            },
            {
                "url": 1064,
                "code": "def call_and_exit(self, cmd, shell=True): sys.exit(subprocess.call(cmd, shell=shell))"
            }
        ],
        "url": 632
    },
    {
        "nl_input": "create unknown number of names to print in python",
        "code_input": [
            {
                "url": 722,
                "code": "def force_to_string(unknown): result = '' if type(unknown) is str: result = unknown if type(unknown) is int: result = str(unknown) if type(unknown) is float: result = str(unknown) if type(unknown) is dict: result = Dict2String(unknown) if type(unknown) is list: result = List2String(unknown) return result"
            },
            {
                "url": 4009,
                "code": "def str_check(*args, func=None): func = func or inspect.stack()[2][3] for var in args: if not isinstance(var, (str, collections.UserString, collections.abc.Sequence)): name = type(var).__name__ raise StringError( f'Function {func} expected str, {name} got instead.')"
            },
            {
                "url": 5526,
                "code": "def python(string: str): return underscore(singularize(string) if Naming._pluralize(string) else string)"
            },
            {
                "url": 2685,
                "code": "def str_dict(some_dict): return {str(k): str(v) for k, v in some_dict.items()}"
            },
            {
                "url": 2126,
                "code": "def all_strings(arr): if not isinstance([], list): raise TypeError(\"non-list value found where list is expected\") return all(isinstance(x, str) for x in arr)"
            },
            {
                "url": 5700,
                "code": "def list_to_str(list, separator=','): list = [str(x) for x in list] return separator.join(list)"
            },
            {
                "url": 3411,
                "code": "def toList(variable, types=(basestring, int, float, )): if isinstance(variable, types): return [variable] else: return variable"
            },
            {
                "url": 5643,
                "code": "def strings_to_integers(strings: Iterable[str]) -> Iterable[int]: return strings_to_(strings, lambda x: int(float(x)))"
            },
            {
                "url": 5919,
                "code": "def is_none(string_, default='raise'): none = ['none', 'undefined', 'unknown', 'null', ''] if string_.lower() in none: return True elif not default: return False else: raise ValueError('The value \\'{}\\' cannot be mapped to none.' .format(string_))"
            },
            {
                "url": 3579,
                "code": "def _force_float(v): try: return float(v) except Exception as exc: return float('nan') logger.warning('Failed to convert {} to float with {} error. Using 0 instead.'.format(v, exc))"
            },
            {
                "url": 5543,
                "code": "def dictlist_convert_to_float(dict_list: Iterable[Dict], key: str) -> None: for d in dict_list: try: d[key] = float(d[key]) except ValueError: d[key] = None"
            },
            {
                "url": 742,
                "code": "def autoconvert(string): for fn in (boolify, int, float): try: return fn(string) except ValueError: pass return string"
            },
            {
                "url": 5723,
                "code": "def _str_to_list(value, separator): value_list = [item.strip() for item in value.split(separator)] value_list_sanitized = builtins.list(filter(None, value_list)) if len(value_list_sanitized) > 0: return value_list_sanitized else: raise ValueError('Invalid list variable.')"
            },
            {
                "url": 4275,
                "code": "def convert_to_yaml( name, value, indentation, indexOfColon, show_multi_line_character): strings = [] if isinstance(value, list): # special case for single item lists: if len(value) == 1 \\ and isinstance(value[0], str): # value = [\"string\"] should not be converted to # name: # - string # but to \"name: string\" instead value = value[0] elif len(value) == 1 \\ and isinstance(value[0], list) \\ and len(value[0]) == 1 \\ and isinstance(value[0][0], str): # same applies to value = [[\"string\"]] value = value[0][0] if isinstance(value, str): strings.append(\"%s%s%s: %s\" % ( ' ' * indentation, name, ' ' * (indexOfColon-len(name)), indent_multiline_string(value, indentation+4, show_multi_line_character))) elif isinstance(value, list): strings.append(\"%s%s%s: \" % ( ' ' * indentation, name, ' ' * (indexOfColon-len(name)))) for outer in value: # special case for single item sublists if isinstance(outer, list) \\ and len(outer) == 1 \\ and isinstance(outer[0], str): # outer = [\"string\"] should not be converted to # - # - string # but to \"- string\" instead outer = outer[0] if isinstance(outer, str): strings.append(\"%s- %s\" % ( ' ' * (indentation+4), indent_multiline_string( outer, indentation+8, show_multi_line_character))) elif isinstance(outer, list): strings.append(\"%s- \" % (' ' * (indentation+4))) for inner in outer: if isinstance(inner, str): strings.append(\"%s- %s\" % ( ' ' * (indentation+8), indent_multiline_string( inner, indentation+12, show_multi_line_character))) return strings"
            },
            {
                "url": 1650,
                "code": "def is_valid_variable_name(string_to_check): try: parse('{} = None'.format(string_to_check)) return True except (SyntaxError, ValueError, TypeError): return False"
            }
        ],
        "url": 5286
    },
    {
        "nl_input": "python json if element exists",
        "code_input": [
            {
                "url": 711,
                "code": "def dict_jsonp(param): if not isinstance(param, dict): param = dict(param) return jsonp(param)"
            },
            {
                "url": 213,
                "code": "def json_response(data, status=200): from django.http import JsonResponse return JsonResponse(data=data, status=status, safe=isinstance(data, dict))"
            },
            {
                "url": 201,
                "code": "def serialize_json_string(self, value): # Check if the value might be a json string if not isinstance(value, six.string_types): return value # Make sure it starts with a brace if not value.startswith('{') or value.startswith('['): return value # Try to load the string try: return json.loads(value) except: return value"
            },
            {
                "url": 1059,
                "code": "def _dict_to_proto(py_dict, proto): dict_json_str = json.dumps(py_dict) return json_format.Parse(dict_json_str, proto)"
            },
            {
                "url": 691,
                "code": "def _unjsonify(x, isattributes=False): if isattributes: obj = json.loads(x) return dict_class(obj) return json.loads(x)"
            },
            {
                "url": 6236,
                "code": "def to_json(self) -> Mapping: return {str(x): str(y) for x, y in self.items()}"
            },
            {
                "url": 2599,
                "code": "def set_json_item(key, value): data = get_json() data[key] = value request = get_request() request[\"BODY\"] = json.dumps(data)"
            },
            {
                "url": 2062,
                "code": "def json_decode(data): if isinstance(data, six.binary_type): data = data.decode('utf-8') return json.loads(data)"
            },
            {
                "url": 4880,
                "code": "def _convert_dict_to_json(array): return json.dumps( array, skipkeys=False, allow_nan=False, indent=None, separators=(\",\", \":\"), sort_keys=True, default=lambda o: o.__dict__, )"
            },
            {
                "url": 157,
                "code": "def from_json(cls, json_str): d = json.loads(json_str) return cls.from_dict(d)"
            },
            {
                "url": 682,
                "code": "def dump_json(obj): return simplejson.dumps(obj, ignore_nan=True, default=json_util.default)"
            },
            {
                "url": 2057,
                "code": "def json(body, charset='utf-8', **kwargs): return json_converter.loads(text(body, charset=charset))"
            },
            {
                "url": 2670,
                "code": "def jsonify(symbol): try: # all symbols have a toJson method, try it return json.dumps(symbol.toJson(), indent=' ') except AttributeError: pass return json.dumps(symbol, indent=' ')"
            },
            {
                "url": 5832,
                "code": "def __as_list(value: List[JsonObjTypes]) -> List[JsonTypes]: return [e._as_dict if isinstance(e, JsonObj) else e for e in value]"
            },
            {
                "url": 1298,
                "code": "def parse_json_date(value): if not value: return None return datetime.datetime.strptime(value, JSON_DATETIME_FORMAT).replace(tzinfo=pytz.UTC)"
            }
        ],
        "url": 1785
    },
    {
        "nl_input": "number of unique values in list python",
        "code_input": [
            {
                "url": 1903,
                "code": "def unique(list): unique = []; [unique.append(x) for x in list if x not in unique] return unique"
            },
            {
                "url": 646,
                "code": "def unique(_list): ret = [] for item in _list: if item not in ret: ret.append(item) return ret"
            },
            {
                "url": 574,
                "code": "def unique(input_list): output = [] for item in input_list: if item not in output: output.append(item) return output"
            },
            {
                "url": 351,
                "code": "def unique_list(lst): uniq = [] for item in lst: if item not in uniq: uniq.append(item) return uniq"
            },
            {
                "url": 431,
                "code": "def unique_list_dicts(dlist, key): return list(dict((val[key], val) for val in dlist).values())"
            },
            {
                "url": 10,
                "code": "def get_uniques(l): result = [] for i in l: if i not in result: result.append(i) return result"
            },
            {
                "url": 1304,
                "code": "def unique(iterable): seen = set() return [x for x in iterable if x not in seen and not seen.add(x)]"
            },
            {
                "url": 6224,
                "code": "def uniqued(iterable): seen = set() add = seen.add return [i for i in iterable if i not in seen and not add(i)]"
            },
            {
                "url": 5929,
                "code": "def uniqued(iterable): seen = set() return [item for item in iterable if item not in seen and not seen.add(item)]"
            },
            {
                "url": 2872,
                "code": "def unique_items(seq): seen = set() return [x for x in seq if not (x in seen or seen.add(x))]"
            },
            {
                "url": 4591,
                "code": "def unique(iterable): seen = set() for item in iterable: if item not in seen: seen.add(item) yield item"
            },
            {
                "url": 581,
                "code": "def unique(seq): cleaned = [] for each in seq: if each not in cleaned: cleaned.append(each) return cleaned"
            },
            {
                "url": 2358,
                "code": "def unique_element(ll): seen = {} result = [] for item in ll: if item in seen: continue seen[item] = 1 result.append(item) return result"
            },
            {
                "url": 4993,
                "code": "def unique_iter(seq): seen = set() return [x for x in seq if x not in seen and not seen.add(x)]"
            },
            {
                "url": 440,
                "code": "def _uniquify(_list): seen = set() result = [] for x in _list: if x not in seen: result.append(x) seen.add(x) return result"
            }
        ],
        "url": 320
    },
    {
        "nl_input": "how to randomize items in a list in python",
        "code_input": [
            {
                "url": 6250,
                "code": "def consistent_shuffle(*lists): perm = list(range(len(lists[0]))) random.shuffle(perm) lists = tuple([sublist[index] for index in perm] for sublist in lists) return lists"
            },
            {
                "url": 4830,
                "code": "def RandomShuffle(a, seed): if seed: np.random.seed(seed) r = a.copy() np.random.shuffle(r) return r,"
            },
            {
                "url": 3733,
                "code": "def random_numbers(n): return ''.join(random.SystemRandom().choice(string.digits) for _ in range(n))"
            },
            {
                "url": 1129,
                "code": "def _shuffle(data, idx): shuffle_data = [] for idx_k, idx_v in data: shuffle_data.append((idx_k, mx.ndarray.array(idx_v.asnumpy()[idx], idx_v.context))) return shuffle_data"
            },
            {
                "url": 1435,
                "code": "def random_choice(sequence): return random.choice(tuple(sequence) if isinstance(sequence, set) else sequence)"
            },
            {
                "url": 351,
                "code": "def unique_list(lst): uniq = [] for item in lst: if item not in uniq: uniq.append(item) return uniq"
            },
            {
                "url": 3334,
                "code": "def reseed_random(seed): r = random.Random(seed) random_internal_state = r.getstate() set_random_state(random_internal_state)"
            },
            {
                "url": 3765,
                "code": "def SampleSum(dists, n): pmf = MakePmfFromList(RandomSum(dists) for i in xrange(n)) return pmf"
            },
            {
                "url": 1400,
                "code": "def runiform(lower, upper, size=None): return np.random.uniform(lower, upper, size)"
            },
            {
                "url": 4669,
                "code": "def new_random_state(seed=None, fully_random=False): if seed is None: if not fully_random: # sample manually a seed instead of just RandomState(), # because the latter one # is way slower. seed = CURRENT_RANDOM_STATE.randint(SEED_MIN_VALUE, SEED_MAX_VALUE, 1)[0] return np.random.RandomState(seed)"
            },
            {
                "url": 3655,
                "code": "def deduplicate(list_object): new = [] for item in list_object: if item not in new: new.append(item) return new"
            },
            {
                "url": 2010,
                "code": "def random_letters(n): return ''.join(random.SystemRandom().choice(string.ascii_letters) for _ in range(n))"
            },
            {
                "url": 2328,
                "code": "def get_randomized_guid_sample(self, item_count): dataset = self.get_whitelist() random.shuffle(dataset) return dataset[:item_count]"
            },
            {
                "url": 646,
                "code": "def unique(_list): ret = [] for item in _list: if item not in ret: ret.append(item) return ret"
            },
            {
                "url": 4270,
                "code": "def generate_random_string(chars=7): return u\"\".join(random.sample(string.ascii_letters * 2 + string.digits, chars))"
            }
        ],
        "url": 2328
    },
    {
        "nl_input": "python windows check for keypress",
        "code_input": [
            {
                "url": 3266,
                "code": "def on_key_press(self, symbol, modifiers): self.keyboard_event(symbol, self.keys.ACTION_PRESS, modifiers)"
            },
            {
                "url": 3892,
                "code": "def keyPressEvent(self, event): self.keyboard_event(event.key(), self.keys.ACTION_PRESS, 0)"
            },
            {
                "url": 4927,
                "code": "def on_press_key(key, callback, suppress=False): return hook_key(key, lambda e: e.event_type == KEY_UP or callback(e), suppress=suppress)"
            },
            {
                "url": 4161,
                "code": "def onkeyup(self, key, keycode, ctrl, shift, alt): return (key, keycode, ctrl, shift, alt)"
            },
            {
                "url": 5434,
                "code": "def keyReleaseEvent(self, event): self.keyboard_event(event.key(), self.keys.ACTION_RELEASE, 0)"
            },
            {
                "url": 1990,
                "code": "def read_key(suppress=False): event = read_event(suppress) return event.name or event.scan_code"
            },
            {
                "url": 5872,
                "code": "def check_key(self, key: str) -> bool: keys = self.get_keys() return key in keys"
            },
            {
                "url": 1192,
                "code": "def stop_button_click_handler(self): self.stop_button.setDisabled(True) # Interrupt computations or stop debugging if not self.shellwidget._reading: self.interrupt_kernel() else: self.shellwidget.write_to_stdin('exit')"
            },
            {
                "url": 4129,
                "code": "def off(self): self.win.keypad(0) curses.nocbreak() curses.echo() try: curses.curs_set(1) except: pass curses.endwin()"
            },
            {
                "url": 3427,
                "code": "def get_active_window(): active_win = None default = wnck.screen_get_default() while gtk.events_pending(): gtk.main_iteration(False) window_list = default.get_windows() if len(window_list) == 0: print \"No Windows Found\" for win in window_list: if win.is_active(): active_win = win.get_name() return active_win"
            },
            {
                "url": 1656,
                "code": "def install_handle_input(self): self.pointer = self.get_fptr() self.hooked = ctypes.windll.user32.SetWindowsHookExA( 13, self.pointer, ctypes.windll.kernel32.GetModuleHandleW(None), 0 ) if not self.hooked: return False return True"
            },
            {
                "url": 5273,
                "code": "def _check_valid_key(self, key): if not isinstance(key, key_type): raise ValueError('%r is not a valid key type' % key) if not VALID_KEY_RE.match(key): raise ValueError('%r contains illegal characters' % key)"
            },
            {
                "url": 5654,
                "code": "def mouse_event(dwFlags: int, dx: int, dy: int, dwData: int, dwExtraInfo: int) -> None: ctypes.windll.user32.mouse_event(dwFlags, dx, dy, dwData, dwExtraInfo)"
            },
            {
                "url": 999,
                "code": "def alert(text='', title='', button=OK_TEXT, root=None, timeout=None): assert TKINTER_IMPORT_SUCCEEDED, 'Tkinter is required for pymsgbox' return _buttonbox(msg=text, title=title, choices=[str(button)], root=root, timeout=timeout)"
            },
            {
                "url": 4664,
                "code": "def wheel(delta=1): location = get_position() e = Quartz.CGEventCreateMouseEvent( None, Quartz.kCGEventScrollWheel, location, Quartz.kCGMouseButtonLeft) e2 = Quartz.CGEventCreateScrollWheelEvent( None, Quartz.kCGScrollEventUnitLine, 1, delta) Quartz.CGEventPost(Quartz.kCGHIDEventTap, e) Quartz.CGEventPost(Quartz.kCGHIDEventTap, e2)"
            }
        ],
        "url": 5666
    },
    {
        "nl_input": "python bind scrollbar to canvas",
        "code_input": [
            {
                "url": 4010,
                "code": "def set_scrollbars_cb(self, w, tf): scrollbars = 'on' if tf else 'off' self.t_.set(scrollbars=scrollbars)"
            },
            {
                "url": 3619,
                "code": "def __grid_widgets(self): scrollbar_column = 0 if self.__compound is tk.LEFT else 2 self._canvas.grid(row=0, column=1, sticky=\"nswe\") self._scrollbar.grid(row=0, column=scrollbar_column, sticky=\"ns\")"
            },
            {
                "url": 2648,
                "code": "def set_scrollregion(self, event=None): self.canvas.configure(scrollregion=self.canvas.bbox('all'))"
            },
            {
                "url": 1083,
                "code": "def _set_scroll_v(self, *args): self._canvas_categories.yview(*args) self._canvas_scroll.yview(*args)"
            },
            {
                "url": 5123,
                "code": "def _grid_widgets(self): scrollbar_column = 0 if self.__compound is tk.LEFT else 2 self.listbox.grid(row=0, column=1, sticky=\"nswe\") self.scrollbar.grid(row=0, column=scrollbar_column, sticky=\"ns\")"
            },
            {
                "url": 840,
                "code": "def restore_scrollbar_position(self): scrollbar_pos = self.get_option('scrollbar_position', None) if scrollbar_pos is not None: self.explorer.treewidget.set_scrollbar_position(scrollbar_pos)"
            },
            {
                "url": 2585,
                "code": "def __init__(self, master=None, compound=tk.RIGHT, autohidescrollbar=True, **kwargs): ttk.Frame.__init__(self, master) self.columnconfigure(1, weight=1) self.rowconfigure(0, weight=1) self.listbox = tk.Listbox(self, **kwargs) if autohidescrollbar: self.scrollbar = AutoHideScrollbar(self, orient=tk.VERTICAL, command=self.listbox.yview) else: self.scrollbar = ttk.Scrollbar(self, orient=tk.VERTICAL, command=self.listbox.yview) self.config_listbox(yscrollcommand=self.scrollbar.set) if compound is not tk.LEFT and compound is not tk.RIGHT: raise ValueError(\"Invalid compound value passed: {0}\".format(compound)) self.__compound = compound self._grid_widgets()"
            },
            {
                "url": 5346,
                "code": "def register_plugin(self): self.main.restore_scrollbar_position.connect( self.restore_scrollbar_position) self.main.add_dockwidget(self)"
            },
            {
                "url": 3193,
                "code": "def scroll_element_into_view(self): x = self.web_element.location['x'] y = self.web_element.location['y'] self.driver.execute_script('window.scrollTo({0}, {1})'.format(x, y)) return self"
            },
            {
                "url": 5869,
                "code": "def get_cursor(self): x, y = self._cursor width, height = self.parent.get_size() while x >= width: x -= width y += 1 if y >= height and self.scrollMode == 'scroll': y = height - 1 return x, y"
            },
            {
                "url": 5527,
                "code": "def update(self): if not self.canvas: return for visual in self.canvas.visuals: self.update_program(visual.program) self.canvas.update()"
            },
            {
                "url": 4232,
                "code": "def on_mouse_motion(self, x, y, dx, dy): # Screen coordinates relative to the lower-left corner # so we have to flip the y axis to make this consistent with # other window libraries self.example.mouse_position_event(x, self.buffer_height - y)"
            },
            {
                "url": 3051,
                "code": "def set_cursor(self, x, y): curses.curs_set(1) self.screen.move(y, x)"
            },
            {
                "url": 2751,
                "code": "def build_gui(self, container): vbox = Widgets.VBox() vbox.set_border_width(0) w = Viewers.GingaViewerWidget(viewer=self) vbox.add_widget(w, stretch=1) # need to put this in an hbox with an expanding label or the # browser wants to resize the canvas, distorting it hbox = Widgets.HBox() hbox.add_widget(vbox, stretch=0) hbox.add_widget(Widgets.Label(''), stretch=1) container.set_widget(hbox)"
            },
            {
                "url": 4664,
                "code": "def wheel(delta=1): location = get_position() e = Quartz.CGEventCreateMouseEvent( None, Quartz.kCGEventScrollWheel, location, Quartz.kCGMouseButtonLeft) e2 = Quartz.CGEventCreateScrollWheelEvent( None, Quartz.kCGScrollEventUnitLine, 1, delta) Quartz.CGEventPost(Quartz.kCGHIDEventTap, e) Quartz.CGEventPost(Quartz.kCGHIDEventTap, e2)"
            }
        ],
        "url": 2648
    },
    {
        "nl_input": "python setlevel how to only record error",
        "code_input": [
            {
                "url": 1109,
                "code": "def set_log_level(logger_name: str, log_level: str, propagate: bool = False): log = logging.getLogger(logger_name) log.propagate = propagate log.setLevel(log_level)"
            },
            {
                "url": 754,
                "code": "def logger(message, level=10): logging.getLogger(__name__).log(level, str(message))"
            },
            {
                "url": 4418,
                "code": "def log(logger, level, message): if logger.parent.name != 'root': logger.log(level, message) else: print(message, file=sys.stderr)"
            },
            {
                "url": 5020,
                "code": "def set_verbosity(verbosity): Logger._verbosity = min(max(0, WARNING - verbosity), 2) debug(\"Verbosity set to %d\" % (WARNING - Logger._verbosity), 'logging')"
            },
            {
                "url": 2353,
                "code": "def reset_default_logger(): global logger global _loglevel global _logfile global _formatter _loglevel = logging.DEBUG _logfile = None _formatter = None logger = setup_logger(name=LOGZERO_DEFAULT_LOGGER, logfile=_logfile, level=_loglevel, formatter=_formatter)"
            },
            {
                "url": 4313,
                "code": "def set_logging_config(log_level, handlers): logging.basicConfig( format='%(asctime)s %(levelname)s:%(name)s:%(funcName)s: %(message)s', datefmt='%Y-%m-%d %H:%M:%S', level=log_level, handlers=handlers)"
            },
            {
                "url": 5129,
                "code": "def log(self, level, msg=None, *args, **kwargs): return self._log(level, msg, args, kwargs)"
            },
            {
                "url": 5411,
                "code": "def handle_logging(self): configure_logging(self.get_scrapy_options()) # Disable duplicates self.__scrapy_options[\"LOG_ENABLED\"] = False # Now, after log-level is correctly set, lets log them. for msg in self.log_output: if msg[\"level\"] is \"error\": self.log.error(msg[\"msg\"]) elif msg[\"level\"] is \"info\": self.log.info(msg[\"msg\"]) elif msg[\"level\"] is \"debug\": self.log.debug(msg[\"msg\"])"
            },
            {
                "url": 899,
                "code": "def debug_on_error(type, value, tb): traceback.print_exc(type, value, tb) print() pdb.pm()"
            },
            {
                "url": 2284,
                "code": "def on_error(e): # pragma: no cover exname = {'RuntimeError': 'Runtime error', 'Value Error': 'Value error'} sys.stderr.write('{}: {}\\n'.format(exname[e.__class__.__name__], str(e))) sys.stderr.write('See file slam_error.log for additional details.\\n') sys.exit(1)"
            },
            {
                "url": 1444,
                "code": "def pylog(self, *args, **kwargs): printerr(self.name, args, kwargs, traceback.format_exc())"
            },
            {
                "url": 3665,
                "code": "def extract_log_level_from_environment(k, default): return LOG_LEVELS.get(os.environ.get(k)) or int(os.environ.get(k, default))"
            },
            {
                "url": 3782,
                "code": "def error(self, text): self.logger.error(\"{}{}\".format(self.message_prefix, text))"
            },
            {
                "url": 1778,
                "code": "def log_exception(exc_info=None, stream=None): exc_info = exc_info or sys.exc_info() stream = stream or sys.stderr try: from traceback import print_exception print_exception(exc_info[0], exc_info[1], exc_info[2], None, stream) stream.flush() finally: exc_info = None"
            },
            {
                "url": 5502,
                "code": "def calling_logger(height=1): stack = inspect.stack() height = min(len(stack) - 1, height) caller = stack[height] scope = caller[0].f_globals path = scope['__name__'] if path == '__main__': path = scope['__package__'] or os.path.basename(sys.argv[0]) return logging.getLogger(path)"
            }
        ],
        "url": 5088
    },
    {
        "nl_input": "format string with *args python",
        "code_input": [
            {
                "url": 338,
                "code": "def safe_format(s, **kwargs): return string.Formatter().vformat(s, (), defaultdict(str, **kwargs))"
            },
            {
                "url": 2745,
                "code": "def format_arg(value): translator = repr if isinstance(value, six.string_types) else six.text_type return translator(value)"
            },
            {
                "url": 3542,
                "code": "def string_format_func(s): return u\"\\\"%s\\\"\" % unicode(s).replace(u\"\\\\\", u\"\\\\\\\\\").replace(u\"\\\"\", u\"\\\\\\\"\")"
            },
            {
                "url": 1697,
                "code": "def format_vars(args): variables = [] for key, value in args.items(): if value: variables += ['{0}={1}'.format(key, value)] return variables"
            },
            {
                "url": 5053,
                "code": "def PythonPercentFormat(format_str): if format_str.startswith('printf '): fmt = format_str[len('printf '):] return lambda value: fmt % value else: return None"
            },
            {
                "url": 3948,
                "code": "def format_docstring(*args, **kwargs): def decorator(func): func.__doc__ = getdoc(func).format(*args, **kwargs) return func return decorator"
            },
            {
                "url": 4152,
                "code": "def give_str(self): args = self._args[:] kwargs = self._kwargs return self._give_str(args, kwargs)"
            },
            {
                "url": 2207,
                "code": "def reprkwargs(kwargs, sep=', ', fmt=\"{0!s}={1!r}\"): return sep.join(fmt.format(k, v) for k, v in kwargs.iteritems())"
            },
            {
                "url": 3774,
                "code": "def kwargs_to_string(kwargs): outstr = '' for arg in kwargs: outstr += ' -{} {}'.format(arg, kwargs[arg]) return outstr"
            },
            {
                "url": 4700,
                "code": "def represented_args(args, separator=\" \"): result = [] if args: for text in args: result.append(quoted(short(text))) return separator.join(result)"
            },
            {
                "url": 3291,
                "code": "def format(x, format): # don't change the dtype, otherwise for each block the dtype may be different (string length) sl = vaex.strings.format(x, format) return column.ColumnStringArrow(sl.bytes, sl.indices, sl.length, sl.offset, string_sequence=sl)"
            },
            {
                "url": 1201,
                "code": "def format_float(value): # not used string = \"{:g}\".format(value).replace(\"e+\", \"e\") string = re.sub(\"e(-?)0*(\\d+)\", r\"e\\1\\2\", string) return string"
            },
            {
                "url": 5511,
                "code": "def _replace_variables(data, variables): formatter = string.Formatter() return [formatter.vformat(item, [], variables) for item in data]"
            },
            {
                "url": 5865,
                "code": "def replaceStrs(s, *args): r if args == (): return s mapping = dict((frm, to) for frm, to in args) return re.sub(\"|\".join(map(re.escape, mapping.keys())), lambda match:mapping[match.group(0)], s)"
            },
            {
                "url": 5954,
                "code": "def execute(cur, *args): stmt = args[0] if len(args) > 1: stmt = stmt.replace('%', '%%').replace('?', '%r') print(stmt % (args[1])) return cur.execute(*args)"
            }
        ],
        "url": 338
    },
    {
        "nl_input": "python get hostip from url",
        "code_input": [
            {
                "url": 5694,
                "code": "def url_host(url: str) -> str: from urllib.parse import urlparse res = urlparse(url) return res.netloc.split(':')[0] if res.netloc else ''"
            },
            {
                "url": 3718,
                "code": "def parse_host_port (host_port): host, port = urllib.splitport(host_port.strip()) if port is not None: if urlutil.is_numeric_port(port): port = int(port) return host, port"
            },
            {
                "url": 5798,
                "code": "def get_domain(url): parse_result = urlparse(url) domain = \"{schema}://{netloc}\".format( schema=parse_result.scheme, netloc=parse_result.netloc) return domain"
            },
            {
                "url": 1313,
                "code": "def is_safe_url(url, host=None): if not url: return False netloc = urlparse.urlparse(url)[1] return not netloc or netloc == host"
            },
            {
                "url": 432,
                "code": "def _get_local_ip(): return set([x[4][0] for x in socket.getaddrinfo( socket.gethostname(), 80, socket.AF_INET )]).pop()"
            },
            {
                "url": 4108,
                "code": "def get_site_name(request): urlparts = request.urlparts return ':'.join([urlparts.hostname, str(urlparts.port)])"
            },
            {
                "url": 1915,
                "code": "def _get_local_ip(self): try: sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) # Use Google Public DNS server to determine own IP sock.connect(('8.8.8.8', 80)) return sock.getsockname()[0] except socket.error: try: return socket.gethostbyname(socket.gethostname()) except socket.gaierror: return '127.0.0.1' finally: sock.close()"
            },
            {
                "url": 1660,
                "code": "def clean_url(url): parsed = urlparse(url.strip()) reconstructed = ParseResult( parsed.scheme, parsed.netloc, parsed.path, params='', query='', fragment='') return reconstructed.geturl()"
            },
            {
                "url": 1449,
                "code": "def strip_querystring(url): p = six.moves.urllib.parse.urlparse(url) return p.scheme + \"://\" + p.netloc + p.path"
            },
            {
                "url": 1199,
                "code": "def is_valid_url(url): pieces = urlparse(url) return all([pieces.scheme, pieces.netloc])"
            },
            {
                "url": 1632,
                "code": "def is_local_url(target): ref_url = urlparse(request.host_url) test_url = urlparse(urljoin(request.host_url, target)) return test_url.scheme in ('http', 'https') and \\ ref_url.netloc == test_url.netloc"
            },
            {
                "url": 1975,
                "code": "def wget(url): import urllib.parse request = urllib.request.urlopen(url) filestring = request.read() return filestring"
            },
            {
                "url": 3341,
                "code": "def parse_domain(url): domain_match = lib.DOMAIN_REGEX.match(url) if domain_match: return domain_match.group()"
            },
            {
                "url": 335,
                "code": "def generate_unique_host_id(): host = \".\".join(reversed(socket.gethostname().split(\".\"))) pid = os.getpid() return \"%s.%d\" % (host, pid)"
            },
            {
                "url": 1309,
                "code": "def guess_url(url): if url.lower().startswith(\"www.\"): # syntactic sugar return \"http://%s\" % url elif url.lower().startswith(\"ftp.\"): # syntactic sugar return \"ftp://%s\" % url return url"
            }
        ],
        "url": 5694
    },
    {
        "nl_input": "python numpy masked vailding",
        "code_input": [
            {
                "url": 4210,
                "code": "def asMaskedArray(self): return ma.masked_array(data=self.data, mask=self.mask, fill_value=self.fill_value)"
            },
            {
                "url": 861,
                "code": "def ma(self): a = self.array return numpy.ma.MaskedArray(a, mask=numpy.logical_not(numpy.isfinite(a)))"
            },
            {
                "url": 4879,
                "code": "def mask_and_flatten(self): self._check_for_mask() return self.get_data(smoothed=True, masked=True, safe_copy=False)[self.get_mask_indices()],\\ self.get_mask_indices(), self.mask.shape"
            },
            {
                "url": 4695,
                "code": "def _join_masks_from_masked_array(data): if not isinstance(data.mask, np.ndarray): # workaround to handle mask compressed to single value mask = np.empty(data.data.shape, dtype=np.bool) mask.fill(data.mask) return mask mask = data.mask[0].copy() for i in range(1, len(data.mask)): mask = np.logical_or(mask, data.mask[i]) return mask[np.newaxis, :, :]"
            },
            {
                "url": 1803,
                "code": "def inpaint(self): import inpaint filled = inpaint.replace_nans(np.ma.filled(self.raster_data, np.NAN).astype(np.float32), 3, 0.01, 2) self.raster_data = np.ma.masked_invalid(filled)"
            },
            {
                "url": 3252,
                "code": "def mask_nonfinite(self): self.mask = np.logical_and(self.mask, (np.isfinite(self.intensity)))"
            },
            {
                "url": 1544,
                "code": "def maskIndex(self): if isinstance(self.mask, bool): return np.full(self.data.shape, self.mask, dtype=np.bool) else: return self.mask"
            },
            {
                "url": 5993,
                "code": "def negate_mask(mask): res = np.ones(mask.shape, dtype=np.int8) res[mask > 0] = 0 return res"
            },
            {
                "url": 3771,
                "code": "def load_tiff(file): ndv, xsize, ysize, geot, projection, datatype = get_geo_info(file) data = gdalnumeric.LoadFile(file) data = np.ma.masked_array(data, mask=data == ndv, fill_value=ndv) return data"
            },
            {
                "url": 1089,
                "code": "def numpy(self): # load GDCM's image reading functionality image_reader = gdcm.ImageReader() image_reader.SetFileName(self.fname) if not image_reader.Read(): raise IOError(\"Could not read DICOM image\") pixel_array = self._gdcm_to_numpy(image_reader.GetImage()) return pixel_array"
            },
            {
                "url": 4750,
                "code": "def is_array(self, key): data = self.model.get_data() return isinstance(data[key], (ndarray, MaskedArray))"
            },
            {
                "url": 5355,
                "code": "def _normalize_numpy_indices(i): if isinstance(i, np.ndarray): if i.dtype == bool: i = tuple(j.tolist() for j in i.nonzero()) elif i.dtype == int: i = i.tolist() return i"
            },
            {
                "url": 1988,
                "code": "def _normalize(mat: np.ndarray): return ((mat - mat.min()) * (255 / mat.max())).astype(np.uint8)"
            },
            {
                "url": 4667,
                "code": "def zoomed_scaled_array_around_mask(self, mask, buffer=1): return self.new_with_array(array=array_util.extracted_array_2d_from_array_2d_and_coordinates( array_2d=self, y0=mask.zoom_region[0]-buffer, y1=mask.zoom_region[1]+buffer, x0=mask.zoom_region[2]-buffer, x1=mask.zoom_region[3]+buffer))"
            },
            {
                "url": 5850,
                "code": "def _create_empty_array(self, frames, always_2d, dtype): import numpy as np if always_2d or self.channels > 1: shape = frames, self.channels else: shape = frames, return np.empty(shape, dtype, order='C')"
            }
        ],
        "url": 4210
    },
    {
        "nl_input": "python child widget close signal",
        "code_input": [
            {
                "url": 1949,
                "code": "def closeEvent(self, e): self.emit('close_widget') super(DockWidget, self).closeEvent(e)"
            },
            {
                "url": 5213,
                "code": "def closeEvent(self, e): if self._closed: return res = self.emit('close') # Discard the close event if False is returned by one of the callback # functions. if False in res: # pragma: no cover e.ignore() return super(GUI, self).closeEvent(e) self._closed = True"
            },
            {
                "url": 4200,
                "code": "def closeEvent(self, event): logger.debug(\"closeEvent\") self.argosApplication.saveSettingsIfNeeded() self.finalize() self.argosApplication.removeMainWindow(self) event.accept() logger.debug(\"closeEvent accepted\")"
            },
            {
                "url": 1667,
                "code": "def _close_websocket(self): close_method = getattr(self._websocket, \"close\", None) if callable(close_method): asyncio.ensure_future(close_method(), loop=self._event_loop) self._websocket = None self._dispatch_event(event=\"close\")"
            },
            {
                "url": 141,
                "code": "def closing_plugin(self, cancelable=False): self.dialog_manager.close_all() self.shell.exit_interpreter() return True"
            },
            {
                "url": 5497,
                "code": "def closeEvent(self, event): if self.closing(True): event.accept() else: event.ignore()"
            },
            {
                "url": 3878,
                "code": "def __exit__(self, *exc_info): self._loop.create_task(self._close(Client.CLOSED, True))"
            },
            {
                "url": 3911,
                "code": "def _ws_on_close(self, ws: websocket.WebSocketApp): self.connected = False self.logger.error('Websocket closed') self._reconnect_websocket()"
            },
            {
                "url": 3126,
                "code": "def close(self): if self._subprocess is not None: os.killpg(self._subprocess.pid, signal.SIGTERM) self._subprocess = None"
            },
            {
                "url": 4028,
                "code": "def cancel(self, event=None): if self.parent != None: self.parent.focus_set() self.destroy()"
            },
            {
                "url": 1143,
                "code": "def stop(self, dummy_signum=None, dummy_frame=None): logging.info('Shutting down ...') self.socket.close() sys.exit(0)"
            },
            {
                "url": 3210,
                "code": "def signal_handler(signal_name, frame): sys.stdout.flush() print(\"\\nSIGINT in frame signal received. Quitting...\") sys.stdout.flush() sys.exit(0)"
            },
            {
                "url": 3897,
                "code": "def delayed_close(self): self.state = SESSION_STATE.CLOSING reactor.callLater(0, self.close)"
            },
            {
                "url": 3930,
                "code": "def parent_widget(self): parent = self.parent() if parent is not None and isinstance(parent, QtGraphicsItem): return parent.widget"
            },
            {
                "url": 1673,
                "code": "def on_close(self, evt): self.stop() # DoseWatcher if evt.EventObject is not self: # Avoid deadlocks self.Close() # wx.Frame evt.Skip()"
            }
        ],
        "url": 1949
    },
    {
        "nl_input": "python read from csv into numpy array",
        "code_input": [
            {
                "url": 5746,
                "code": "def csv_to_numpy(string_like, dtype=None): # type: (str) -> np.array stream = StringIO(string_like) return np.genfromtxt(stream, dtype=dtype, delimiter=',')"
            },
            {
                "url": 2549,
                "code": "def read_numpy(fd, byte_order, dtype, count): return numpy.fromfile(fd, byte_order+dtype[-1], count)"
            },
            {
                "url": 126,
                "code": "def convert_array(array): out = io.BytesIO(array) out.seek(0) return np.load(out)"
            },
            {
                "url": 3936,
                "code": "def read_numpy(fh, byteorder, dtype, count, offsetsize): dtype = 'b' if dtype[-1] == 's' else byteorder+dtype[-1] return fh.read_array(dtype, count)"
            },
            {
                "url": 5880,
                "code": "def array_to_npy(array_like): # type: (np.array or Iterable or int or float) -> object buffer = BytesIO() np.save(buffer, array_like) return buffer.getvalue()"
            },
            {
                "url": 6117,
                "code": "def numpy_to_yaml(representer: Representer, data: np.ndarray) -> Sequence[Any]: return representer.represent_sequence( \"!numpy_array\", data.tolist() )"
            },
            {
                "url": 9,
                "code": "def _convert_to_array(array_like, dtype): if isinstance(array_like, bytes): return np.frombuffer(array_like, dtype=dtype) return np.asarray(array_like, dtype=dtype)"
            },
            {
                "url": 5152,
                "code": "def _parse_array(self, tensor_proto): try: from onnx.numpy_helper import to_array except ImportError as e: raise ImportError(\"Unable to import onnx which is required {}\".format(e)) np_array = to_array(tensor_proto).reshape(tuple(tensor_proto.dims)) return mx.nd.array(np_array)"
            },
            {
                "url": 1583,
                "code": "def dict_to_numpy_array(d): return fromarrays(d.values(), np.dtype([(str(k), v.dtype) for k, v in d.items()]))"
            },
            {
                "url": 1089,
                "code": "def numpy(self): # load GDCM's image reading functionality image_reader = gdcm.ImageReader() image_reader.SetFileName(self.fname) if not image_reader.Read(): raise IOError(\"Could not read DICOM image\") pixel_array = self._gdcm_to_numpy(image_reader.GetImage()) return pixel_array"
            },
            {
                "url": 2742,
                "code": "def csvtolist(inputstr): reader = csv.reader([inputstr], skipinitialspace=True) output = [] for r in reader: output += r return output"
            },
            {
                "url": 304,
                "code": "def torecarray(*args, **kwargs): import numpy as np return toarray(*args, **kwargs).view(np.recarray)"
            },
            {
                "url": 666,
                "code": "def read_array(path, mmap_mode=None): file_ext = op.splitext(path)[1] if file_ext == '.npy': return np.load(path, mmap_mode=mmap_mode) raise NotImplementedError(\"The file extension `{}` \".format(file_ext) + \"is not currently supported.\")"
            },
            {
                "url": 231,
                "code": "def deserialize_ndarray_npy(d): with io.BytesIO() as f: f.write(json.loads(d['npy']).encode('latin-1')) f.seek(0) return np.load(f)"
            },
            {
                "url": 57,
                "code": "def csv_to_dicts(file, header=None): with open(file) as csvfile: return [row for row in csv.DictReader(csvfile, fieldnames=header)]"
            }
        ],
        "url": 5746
    },
    {
        "nl_input": "cast string to bytearray python",
        "code_input": [
            {
                "url": 3326,
                "code": "def bytes_to_str(s, encoding='utf-8'): if six.PY3 and isinstance(s, bytes): return s.decode(encoding) return s"
            },
            {
                "url": 5522,
                "code": "def cast_bytes(s, encoding=None): if not isinstance(s, bytes): return encode(s, encoding) return s"
            },
            {
                "url": 2538,
                "code": "def to_string(s, encoding='utf-8'): if six.PY2: return s.encode(encoding) if isinstance(s, bytes): return s.decode(encoding) return s"
            },
            {
                "url": 3413,
                "code": "def to_bytes(s, encoding=\"utf-8\"): if isinstance(s, six.binary_type): return s if six.PY3: return bytes(s, encoding) return s.encode(encoding)"
            },
            {
                "url": 1451,
                "code": "def to_str(s): if isinstance(s, bytes): s = s.decode('utf-8') elif not isinstance(s, str): s = str(s) return s"
            },
            {
                "url": 3497,
                "code": "def read_string(cls, string): if PY3 and not isinstance(string, byte_types): string = string.encode() return cls.decode(string)"
            },
            {
                "url": 3322,
                "code": "def ub_to_str(string): if not isinstance(string, str): if six.PY2: return str(string) else: return string.decode() return string"
            },
            {
                "url": 1328,
                "code": "def b2u(string): if (isinstance(string, bytes) or (PY2 and isinstance(string, str))): return string.decode('utf-8') return string"
            },
            {
                "url": 5583,
                "code": "def strtobytes(input, encoding): py_version = sys.version_info[0] if py_version >= 3: return _strtobytes_py3(input, encoding) return _strtobytes_py2(input, encoding)"
            },
            {
                "url": 1897,
                "code": "def decode_bytes(string): if is_string_type(type(string)): string = bytes(string, \"utf-8\") return base64.decodebytes(string)"
            },
            {
                "url": 1191,
                "code": "def to_binary(s, encoding='utf8'): if PY3: # pragma: no cover return s if isinstance(s, binary_type) else binary_type(s, encoding=encoding) return binary_type(s)"
            },
            {
                "url": 5212,
                "code": "def is_bytes(string): if six.PY3 and isinstance(string, (bytes, memoryview, bytearray)): # noqa return True elif six.PY2 and isinstance(string, (buffer, bytearray)): # noqa return True return False"
            },
            {
                "url": 2806,
                "code": "def to_str(obj): if not isinstance(obj, str) and PY3 and isinstance(obj, bytes): obj = obj.decode('utf-8') return obj if isinstance(obj, string_types) else str(obj)"
            },
            {
                "url": 9,
                "code": "def _convert_to_array(array_like, dtype): if isinstance(array_like, bytes): return np.frombuffer(array_like, dtype=dtype) return np.asarray(array_like, dtype=dtype)"
            },
            {
                "url": 3238,
                "code": "def u2b(string): if ((PY2 and isinstance(string, unicode)) or ((not PY2) and isinstance(string, str))): return string.encode('utf-8') return string"
            }
        ],
        "url": 5708
    },
    {
        "nl_input": "load str into python object",
        "code_input": [
            {
                "url": 4866,
                "code": "def loads(string): f = StringIO.StringIO(string) marshaller = JavaObjectUnmarshaller(f) marshaller.add_transformer(DefaultObjectTransformer()) return marshaller.readObject()"
            },
            {
                "url": 1197,
                "code": "def loads(s, model=None, parser=None): with StringIO(s) as f: return load(f, model=model, parser=parser)"
            },
            {
                "url": 4178,
                "code": "def loads(cls, s): with closing(StringIO(s)) as fileobj: return cls.load(fileobj)"
            },
            {
                "url": 4187,
                "code": "def load(file_object): marshaller = JavaObjectUnmarshaller(file_object) marshaller.add_transformer(DefaultObjectTransformer()) return marshaller.readObject()"
            },
            {
                "url": 5016,
                "code": "def load(cls, fp, **kwargs): json_obj = json.load(fp, **kwargs) return parse(cls, json_obj)"
            },
            {
                "url": 3015,
                "code": "def load(filename): if not os.path.exists(filename): LOG.error(\"load object - File '%s' does not exist.\", filename) return None obj = None with open(filename, 'rb') as obj_file: obj = dill.load(obj_file) return obj"
            },
            {
                "url": 157,
                "code": "def from_json(cls, json_str): d = json.loads(json_str) return cls.from_dict(d)"
            },
            {
                "url": 2151,
                "code": "def from_json_str(cls, json_str): return cls.from_json(json.loads(json_str, cls=JsonDecoder))"
            },
            {
                "url": 2552,
                "code": "def load_from_file(cls, file_path: str): with open(file_path, \"r\") as f: data = json.load(f) item = cls.decode(data=data) return item"
            },
            {
                "url": 2806,
                "code": "def to_str(obj): if not isinstance(obj, str) and PY3 and isinstance(obj, bytes): obj = obj.decode('utf-8') return obj if isinstance(obj, string_types) else str(obj)"
            },
            {
                "url": 5353,
                "code": "def load(obj, cls, default_factory): if obj is None: return default_factory() if isinstance(obj, dict): return cls.load(obj) return obj"
            },
            {
                "url": 3497,
                "code": "def read_string(cls, string): if PY3 and not isinstance(string, byte_types): string = string.encode() return cls.decode(string)"
            },
            {
                "url": 2054,
                "code": "def load(raw_bytes): try: if not isinstance(raw_bytes, string_type): raw_bytes = raw_bytes.decode() return json.loads(raw_bytes) except ValueError as e: raise SerializationException(str(e))"
            },
            {
                "url": 3240,
                "code": "def FromString(s, **kwargs): f = StringIO.StringIO(s) return FromFile(f, **kwargs)"
            },
            {
                "url": 3100,
                "code": "def unpickle(pickle_file): pickle = None with open(pickle_file, \"rb\") as pickle_f: pickle = dill.load(pickle_f) if not pickle: LOG.error(\"Could not load python object from file\") return pickle"
            }
        ],
        "url": 1197
    },
    {
        "nl_input": "python ldap get all groups a user belongs to",
        "code_input": [
            {
                "url": 5009,
                "code": "def get_groups(self, username): username = ldap.filter.escape_filter_chars(self._byte_p2(username)) userdn = self._get_user(username, NO_ATTR) searchfilter = self.group_filter_tmpl % { 'userdn': userdn, 'username': username } groups = self._search(searchfilter, NO_ATTR, self.groupdn) ret = [] for entry in groups: ret.append(self._uni(entry[0])) return ret"
            },
            {
                "url": 247,
                "code": "def user_in_all_groups(user, groups): return user_is_superuser(user) or all(user_in_group(user, group) for group in groups)"
            },
            {
                "url": 5007,
                "code": "def query(self, base, filterstr, attrlist=None): return self.conn.search_s(base, ldap.SCOPE_SUBTREE, filterstr, attrlist)"
            },
            {
                "url": 5470,
                "code": "def search(self, filterstr, attrlist): return self._paged_search_ext_s(self.settings.BASE, ldap.SCOPE_SUBTREE, filterstr=filterstr, attrlist=attrlist, page_size=self.settings.PAGE_SIZE)"
            },
            {
                "url": 2276,
                "code": "def _Members(self, group): group.members = set(group.members).union(self.gids.get(group.gid, [])) return group"
            },
            {
                "url": 1234,
                "code": "def members(self, uid=\"*\", objects=False): entries = self.search(uid='*') if objects: return self.memberObjects(entries) result = [] for entry in entries: result.append(entry[1]) return result"
            },
            {
                "url": 203,
                "code": "def group_exists(groupname): try: grp.getgrnam(groupname) group_exists = True except KeyError: group_exists = False return group_exists"
            },
            {
                "url": 667,
                "code": "def group_by(iterable, key_func): groups = ( list(sub) for key, sub in groupby(iterable, key_func) ) return zip(groups, groups)"
            },
            {
                "url": 2932,
                "code": "def user_exists(username): try: pwd.getpwnam(username) user_exists = True except KeyError: user_exists = False return user_exists"
            },
            {
                "url": 620,
                "code": "def get_user_by_id(self, id): return self.db_adapter.get_object(self.UserClass, id=id)"
            },
            {
                "url": 3395,
                "code": "def list_autoscaling_group(region, filter_by_kwargs): conn = boto.ec2.autoscale.connect_to_region(region) groups = conn.get_all_groups() return lookup(groups, filter_by=filter_by_kwargs)"
            },
            {
                "url": 245,
                "code": "def _is_root(): import os import ctypes try: return os.geteuid() == 0 except AttributeError: return ctypes.windll.shell32.IsUserAnAdmin() != 0 return False"
            },
            {
                "url": 3237,
                "code": "def load_logged_in_user(): user_id = session.get(\"user_id\") g.user = User.query.get(user_id) if user_id is not None else None"
            },
            {
                "url": 3566,
                "code": "def _get_gid(name): if getgrnam is None or name is None: return None try: result = getgrnam(name) except KeyError: result = None if result is not None: return result[2] return None"
            },
            {
                "url": 2760,
                "code": "def group(data, num): return [data[i:i+num] for i in range(0, len(data), num)]"
            }
        ],
        "url": 5009
    },
    {
        "nl_input": "python check type if string",
        "code_input": [
            {
                "url": 1789,
                "code": "def is_string(obj): if PYTHON3: str_type = (bytes, str) else: str_type = (bytes, str, unicode) return isinstance(obj, str_type)"
            },
            {
                "url": 2141,
                "code": "def isstring(value): classes = (str, bytes) if pyutils.PY3 else basestring # noqa: F821 return isinstance(value, classes)"
            },
            {
                "url": 530,
                "code": "def _isstring(dtype): return dtype.type == numpy.unicode_ or dtype.type == numpy.string_"
            },
            {
                "url": 5589,
                "code": "def is_unicode(string): str_type = str(type(string)) if str_type.find('str') > 0 or str_type.find('unicode') > 0: return True return False"
            },
            {
                "url": 243,
                "code": "def is_string(val): try: basestring except NameError: return isinstance(val, str) return isinstance(val, basestring)"
            },
            {
                "url": 590,
                "code": "def isString(s): try: return isinstance(s, unicode) or isinstance(s, basestring) except NameError: return isinstance(s, str)"
            },
            {
                "url": 1121,
                "code": "def check_str(obj): if isinstance(obj, str): return obj if isinstance(obj, float): return str(int(obj)) else: return str(obj)"
            },
            {
                "url": 4009,
                "code": "def str_check(*args, func=None): func = func or inspect.stack()[2][3] for var in args: if not isinstance(var, (str, collections.UserString, collections.abc.Sequence)): name = type(var).__name__ raise StringError( f'Function {func} expected str, {name} got instead.')"
            },
            {
                "url": 2584,
                "code": "def validate_string(option, value): if isinstance(value, string_type): return value raise TypeError(\"Wrong type for %s, value must be \" \"an instance of %s\" % (option, string_type.__name__))"
            },
            {
                "url": 285,
                "code": "def make_kind_check(python_types, numpy_kind): def check(value): if hasattr(value, 'dtype'): return value.dtype.kind == numpy_kind return isinstance(value, python_types) return check"
            },
            {
                "url": 768,
                "code": "def is_type(value): if isinstance(value, type): return issubclass(value, Type) return isinstance(value, Type)"
            },
            {
                "url": 5212,
                "code": "def is_bytes(string): if six.PY3 and isinstance(string, (bytes, memoryview, bytearray)): # noqa return True elif six.PY2 and isinstance(string, (buffer, bytearray)): # noqa return True return False"
            },
            {
                "url": 1297,
                "code": "def istype(obj, check): if isinstance(check, tuple): for cls in check: if type(obj) is cls: return True return False else: return type(obj) is check"
            },
            {
                "url": 2087,
                "code": "def is_text(obj, name=None): try: # python2 ans = isinstance(obj, basestring) except NameError: # python3 ans = isinstance(obj, str) if name: print(\"is_text: (%s) %s = %s\" % (ans, name, obj.__class__), file=sys.stderr) return ans"
            },
            {
                "url": 2014,
                "code": "def chkstr(s, v): if type(s) != str: raise TypeError(\"{var} must be str\".format(var=v)) if not s: raise ValueError(\"{var} cannot be empty\".format(var=v))"
            }
        ],
        "url": 5589
    },
    {
        "nl_input": "python get current globals",
        "code_input": [
            {
                "url": 1879,
                "code": "def extract_module_locals(depth=0): f = sys._getframe(depth + 1) global_ns = f.f_globals module = sys.modules[global_ns['__name__']] return (module, f.f_locals)"
            },
            {
                "url": 1793,
                "code": "def getvariable(name): import inspect fr = inspect.currentframe() try: while fr: fr = fr.f_back vars = fr.f_locals if name in vars: return vars[name] except: pass return None"
            },
            {
                "url": 3661,
                "code": "def get_frame_locals(stepback=0): with Frame(stepback=stepback) as frame: locals_dict = frame.f_locals return locals_dict"
            },
            {
                "url": 4938,
                "code": "def _update_globals(): if not sys.platform.startswith('java') and sys.platform != 'cli': return incompatible = 'extract_constant', 'get_module_constant' for name in incompatible: del globals()[name] __all__.remove(name)"
            },
            {
                "url": 263,
                "code": "def exec_function(ast, globals_map): locals_map = globals_map exec ast in globals_map, locals_map return locals_map"
            },
            {
                "url": 4320,
                "code": "def functions(self): return [v for v in self.globals.values() if isinstance(v, values.Function)]"
            },
            {
                "url": 4156,
                "code": "def caller_locals(): import inspect frame = inspect.currentframe() try: return frame.f_back.f_back.f_locals finally: del frame"
            },
            {
                "url": 1836,
                "code": "def set_global(node: Node, key: str, value: Any): node.node_globals[key] = value"
            },
            {
                "url": 4578,
                "code": "def get_parent_var(name, global_ok=False, default=None, skip_frames=0): scope = get_parent_scope_from_var(name, global_ok=global_ok, skip_frames=skip_frames + 1) if not scope: return default if name in scope.locals: return scope.locals.get(name, default) return scope.globals.get(name, default)"
            },
            {
                "url": 5184,
                "code": "def extract_vars_above(*names): callerNS = sys._getframe(2).f_locals return dict((k,callerNS[k]) for k in names)"
            },
            {
                "url": 6188,
                "code": "def get_caller_module(): stack = inspect.stack() assert len(stack) > 1 caller = stack[2][0] return caller.f_globals['__name__']"
            },
            {
                "url": 1746,
                "code": "def import_js(path, lib_name, globals): with codecs.open(path_as_local(path), \"r\", \"utf-8\") as f: js = f.read() e = EvalJs() e.execute(js) var = e.context['var'] globals[lib_name] = var.to_python()"
            },
            {
                "url": 2963,
                "code": "def get_current_frames(): return dict( (thread_id, {'frame': thread2list(frame), 'time': None}) for thread_id, frame in sys._current_frames().items() )"
            },
            {
                "url": 829,
                "code": "def clear_global(self): vname = self.varname logger.debug(f'global clearning {vname}') if vname in globals(): logger.debug('removing global instance var: {}'.format(vname)) del globals()[vname]"
            },
            {
                "url": 1680,
                "code": "def clear_globals_reload_modules(self): self.code_array.clear_globals() self.code_array.reload_modules() # Clear result cache self.code_array.result_cache.clear()"
            }
        ],
        "url": 4156
    },
    {
        "nl_input": "get child loggers python",
        "code_input": [
            {
                "url": 1928,
                "code": "def _get_loggers(): from .. import loader modules = loader.get_package_modules('logger') return list(loader.get_plugins(modules, [_Logger]))"
            },
            {
                "url": 2910,
                "code": "def __getLogger(cls): if cls.__logger is None: cls.__logger = opf_utils.initLogger(cls) return cls.__logger"
            },
            {
                "url": 3556,
                "code": "def register_logging_factories(loader): loader.register_factory(logging.Logger, LoggerFactory) loader.register_factory(logging.Handler, LoggingHandlerFactory)"
            },
            {
                "url": 4418,
                "code": "def log(logger, level, message): if logger.parent.name != 'root': logger.log(level, message) else: print(message, file=sys.stderr)"
            },
            {
                "url": 754,
                "code": "def logger(message, level=10): logging.getLogger(__name__).log(level, str(message))"
            },
            {
                "url": 5978,
                "code": "def scope_logger(cls): cls.log = logging.getLogger('{0}.{1}'.format(cls.__module__, cls.__name__)) return cls"
            },
            {
                "url": 5502,
                "code": "def calling_logger(height=1): stack = inspect.stack() height = min(len(stack) - 1, height) caller = stack[height] scope = caller[0].f_globals path = scope['__name__'] if path == '__main__': path = scope['__package__'] or os.path.basename(sys.argv[0]) return logging.getLogger(path)"
            },
            {
                "url": 3665,
                "code": "def extract_log_level_from_environment(k, default): return LOG_LEVELS.get(os.environ.get(k)) or int(os.environ.get(k, default))"
            },
            {
                "url": 2353,
                "code": "def reset_default_logger(): global logger global _loglevel global _logfile global _formatter _loglevel = logging.DEBUG _logfile = None _formatter = None logger = setup_logger(name=LOGZERO_DEFAULT_LOGGER, logfile=_logfile, level=_loglevel, formatter=_formatter)"
            },
            {
                "url": 1109,
                "code": "def set_log_level(logger_name: str, log_level: str, propagate: bool = False): log = logging.getLogger(logger_name) log.propagate = propagate log.setLevel(log_level)"
            },
            {
                "url": 5129,
                "code": "def log(self, level, msg=None, *args, **kwargs): return self._log(level, msg, args, kwargs)"
            },
            {
                "url": 744,
                "code": "def find_console_handler(logger): for handler in logger.handlers: if (isinstance(handler, logging.StreamHandler) and handler.stream == sys.stderr): return handler"
            },
            {
                "url": 2094,
                "code": "def setLoggerAll(self, mthd): for key in self._logger_methods: self._logger_methods[key] = mthd"
            },
            {
                "url": 4641,
                "code": "def log_stop(logger): handlers = logger.handlers[:] for handler in handlers: handler.close() logger.removeHandler(handler)"
            },
            {
                "url": 2028,
                "code": "def ServerLoggingStartupInit(): global LOGGER if local_log: logging.debug(\"Using local LogInit from %s\", local_log) local_log.LogInit() logging.debug(\"Using local AppLogInit from %s\", local_log) LOGGER = local_log.AppLogInit() else: LogInit() LOGGER = AppLogInit()"
            }
        ],
        "url": 1928
    },
    {
        "nl_input": "how to know if a text file is empty in python",
        "code_input": [
            {
                "url": 5834,
                "code": "def isfile_notempty(inputfile: str) -> bool: try: return isfile(inputfile) and getsize(inputfile) > 0 except TypeError: raise TypeError('inputfile is not a valid type')"
            },
            {
                "url": 3323,
                "code": "def isemptyfile(filepath): exists = os.path.exists(safepath(filepath)) if exists: filesize = os.path.getsize(safepath(filepath)) return filesize == 0 else: return False"
            },
            {
                "url": 286,
                "code": "def file_empty(fp): # for python 2 we need to use a homemade peek() if six.PY2: contents = fp.read() fp.seek(0) return not bool(contents) else: return not fp.peek()"
            },
            {
                "url": 5731,
                "code": "def file_exists(fname): try: return fname and os.path.exists(fname) and os.path.getsize(fname) > 0 except OSError: return False"
            },
            {
                "url": 5672,
                "code": "def _cnx_is_empty(in_file): with open(in_file) as in_handle: for i, line in enumerate(in_handle): if i > 0: return False return True"
            },
            {
                "url": 2011,
                "code": "def _file_and_exists(val, input_files): return ((os.path.exists(val) and os.path.isfile(val)) or val in input_files)"
            },
            {
                "url": 2959,
                "code": "def _file_exists(path, filename): return os.path.isfile(os.path.join(path, filename))"
            },
            {
                "url": 757,
                "code": "def is_non_empty_string(input_string): try: if not input_string.strip(): raise ValueError() except AttributeError as error: raise TypeError(error) return True"
            },
            {
                "url": 3646,
                "code": "def _one_exists(input_files): for f in input_files: if os.path.exists(f): return True return False"
            },
            {
                "url": 5538,
                "code": "def is_empty(self): return all(isinstance(c, ParseNode) and c.is_empty for c in self.children)"
            },
            {
                "url": 190,
                "code": "def is_binary(filename): with open(filename, 'rb') as fp: data = fp.read(1024) if not data: return False if b'\\0' in data: return True return False"
            },
            {
                "url": 847,
                "code": "def contains_empty(features): if not features: return True for feature in features: if feature.shape[0] == 0: return True return False"
            },
            {
                "url": 3698,
                "code": "def match_empty(self, el): is_empty = True for child in self.get_children(el, tags=False): if self.is_tag(child): is_empty = False break elif self.is_content_string(child) and RE_NOT_EMPTY.search(child): is_empty = False break return is_empty"
            },
            {
                "url": 6054,
                "code": "def empty_wav(wav_path: Union[Path, str]) -> bool: with wave.open(str(wav_path), 'rb') as wav_f: return wav_f.getnframes() == 0"
            },
            {
                "url": 3312,
                "code": "def is_empty(self): non_type_attributes = [attr for attr in self.node.attrib.keys() if attr != 'type'] return len(self.node) == 0 and len(non_type_attributes) == 0 \\ and not self.node.text and not self.node.tail"
            }
        ],
        "url": 5672
    },
    {
        "nl_input": "python normal distribution p values",
        "code_input": [
            {
                "url": 1336,
                "code": "def ln_norm(x, mu, sigma=1.0): return np.log(stats.norm(loc=mu, scale=sigma).pdf(x))"
            },
            {
                "url": 741,
                "code": "def lognorm(x, mu, sigma=1.0): return stats.lognorm(sigma, scale=mu).pdf(x)"
            },
            {
                "url": 638,
                "code": "def norm(x, mu, sigma=1.0): return stats.norm(loc=mu, scale=sigma).pdf(x)"
            },
            {
                "url": 376,
                "code": "def EvalGaussianPdf(x, mu, sigma): return scipy.stats.norm.pdf(x, mu, sigma)"
            },
            {
                "url": 2495,
                "code": "def normal_log_q(self,z): means, scale = self.get_means_and_scales() return ss.norm.logpdf(z,loc=means,scale=scale)"
            },
            {
                "url": 3331,
                "code": "def lognormcdf(x, mu, tau): x = np.atleast_1d(x) return np.array( [0.5 * (1 - flib.derf(-(np.sqrt(tau / 2)) * (np.log(y) - mu))) for y in x])"
            },
            {
                "url": 5805,
                "code": "def sample_normal(mean, var, rng): ret = numpy.sqrt(var) * rng.randn(*mean.shape) + mean return ret"
            },
            {
                "url": 551,
                "code": "def rlognormal(mu, tau, size=None): return np.random.lognormal(mu, np.sqrt(1. / tau), size)"
            },
            {
                "url": 1057,
                "code": "def plot_dist_normal(s, mu, sigma): import matplotlib.pyplot as plt count, bins, ignored = plt.hist(s, 30, normed=True) plt.plot(bins, 1/(sigma * np.sqrt(2 * np.pi)) \\ * np.exp( - (bins - mu)**2 / (2 * sigma**2) ), \\ linewidth = 2, color = 'r') plt.show()"
            },
            {
                "url": 96,
                "code": "def pdf(x, mu, std): return (1.0 / (std * sqrt(2 * pi))) * np.exp(-(x - mu) ** 2 / (2 * std ** 2))"
            },
            {
                "url": 5867,
                "code": "def normcdf(x, log=False): y = np.atleast_1d(x).copy() flib.normcdf(y) if log: if (y>0).all(): return np.log(y) return -np.inf return y"
            },
            {
                "url": 955,
                "code": "def rnormal(mu, tau, size=None): return np.random.normal(mu, 1. / np.sqrt(tau), size)"
            },
            {
                "url": 3344,
                "code": "def normal_noise(points): return np.random.rand(1) * np.random.randn(points, 1) \\ + random.sample([2, -2], 1)"
            },
            {
                "url": 3947,
                "code": "def EvalBinomialPmf(k, n, p): return scipy.stats.binom.pmf(k, n, p)"
            },
            {
                "url": 4662,
                "code": "def gaussian_distribution(mean, stdev, num_pts=50): xstart = mean - (4.0 * stdev) xend = mean + (4.0 * stdev) x = np.linspace(xstart,xend,num_pts) y = (1.0/np.sqrt(2.0*np.pi*stdev*stdev)) * np.exp(-1.0 * ((x - mean)**2)/(2.0*stdev*stdev)) return x,y"
            }
        ],
        "url": 376
    },
    {
        "nl_input": "python ctypes array of arrays",
        "code_input": [
            {
                "url": 1885,
                "code": "def c_array(ctype, values): if isinstance(values, np.ndarray) and values.dtype.itemsize == ctypes.sizeof(ctype): return (ctype * len(values)).from_buffer_copy(values) return (ctype * len(values))(*values)"
            },
            {
                "url": 79,
                "code": "def cint32_array_to_numpy(cptr, length): if isinstance(cptr, ctypes.POINTER(ctypes.c_int32)): return np.fromiter(cptr, dtype=np.int32, count=length) else: raise RuntimeError('Expected int pointer')"
            },
            {
                "url": 84,
                "code": "def cint8_array_to_numpy(cptr, length): if isinstance(cptr, ctypes.POINTER(ctypes.c_int8)): return np.fromiter(cptr, dtype=np.int8, count=length) else: raise RuntimeError('Expected int pointer')"
            },
            {
                "url": 82,
                "code": "def cfloat32_array_to_numpy(cptr, length): if isinstance(cptr, ctypes.POINTER(ctypes.c_float)): return np.fromiter(cptr, dtype=np.float32, count=length) else: raise RuntimeError('Expected float pointer')"
            },
            {
                "url": 64,
                "code": "def cfloat64_array_to_numpy(cptr, length): if isinstance(cptr, ctypes.POINTER(ctypes.c_double)): return np.fromiter(cptr, dtype=np.float64, count=length) else: raise RuntimeError('Expected double pointer')"
            },
            {
                "url": 9,
                "code": "def _convert_to_array(array_like, dtype): if isinstance(array_like, bytes): return np.frombuffer(array_like, dtype=dtype) return np.asarray(array_like, dtype=dtype)"
            },
            {
                "url": 1583,
                "code": "def dict_to_numpy_array(d): return fromarrays(d.values(), np.dtype([(str(k), v.dtype) for k, v in d.items()]))"
            },
            {
                "url": 5152,
                "code": "def _parse_array(self, tensor_proto): try: from onnx.numpy_helper import to_array except ImportError as e: raise ImportError(\"Unable to import onnx which is required {}\".format(e)) np_array = to_array(tensor_proto).reshape(tuple(tensor_proto.dims)) return mx.nd.array(np_array)"
            },
            {
                "url": 5880,
                "code": "def array_to_npy(array_like): # type: (np.array or Iterable or int or float) -> object buffer = BytesIO() np.save(buffer, array_like) return buffer.getvalue()"
            },
            {
                "url": 2387,
                "code": "def toArray(self): arr = np.zeros((self.size,), dtype=np.float64) arr[self.indices] = self.values return arr"
            },
            {
                "url": 12,
                "code": "def _array2cstr(arr): out = StringIO() np.save(out, arr) return b64encode(out.getvalue())"
            },
            {
                "url": 1870,
                "code": "def _to_array(value): if isinstance(value, (tuple, list)): return array(value) elif isinstance(value, (float, int)): return np.float64(value) else: return value"
            },
            {
                "url": 4251,
                "code": "def from_pystr_to_cstr(data): if not isinstance(data, list): raise NotImplementedError pointers = (ctypes.c_char_p * len(data))() if PY3: data = [bytes(d, 'utf-8') for d in data] else: data = [d.encode('utf-8') if isinstance(d, unicode) else d # pylint: disable=undefined-variable for d in data] pointers[:] = data return pointers"
            },
            {
                "url": 3936,
                "code": "def read_numpy(fh, byteorder, dtype, count, offsetsize): dtype = 'b' if dtype[-1] == 's' else byteorder+dtype[-1] return fh.read_array(dtype, count)"
            },
            {
                "url": 5850,
                "code": "def _create_empty_array(self, frames, always_2d, dtype): import numpy as np if always_2d or self.channels > 1: shape = frames, self.channels else: shape = frames, return np.empty(shape, dtype, order='C')"
            }
        ],
        "url": 5961
    },
    {
        "nl_input": "scale 1d array python to between 0 and 1",
        "code_input": [
            {
                "url": 5183,
                "code": "def _rescale_array(self, array, scale, zero): if scale != 1.0: sval = numpy.array(scale, dtype=array.dtype) array *= sval if zero != 0.0: zval = numpy.array(zero, dtype=array.dtype) array += zval"
            },
            {
                "url": 2592,
                "code": "def _scale_shape(dshape, scale = (1,1,1)): nshape = np.round(np.array(dshape) * np.array(scale)) return tuple(nshape.astype(np.int))"
            },
            {
                "url": 2813,
                "code": "def scale_dtype(arr, dtype): max_int = np.iinfo(dtype).max return (arr * max_int).astype(dtype)"
            },
            {
                "url": 3650,
                "code": "def _scaleSinglePoint(point, scale=1, convertToInteger=True): x, y = point if convertToInteger: return int(round(x * scale)), int(round(y * scale)) else: return (x * scale, y * scale)"
            },
            {
                "url": 2378,
                "code": "def smooth_array(array, amount=1): if amount==0: return array # we have to store the old values in a temp array to keep the # smoothing from affecting the smoothing new_array = _n.array(array) for n in range(len(array)): new_array[n] = smooth(array, n, amount) return new_array"
            },
            {
                "url": 5815,
                "code": "def to_0d_array(value: Any) -> np.ndarray: if np.isscalar(value) or (isinstance(value, np.ndarray) and value.ndim == 0): return np.array(value) else: return to_0d_object_array(value)"
            },
            {
                "url": 4950,
                "code": "def scaled_fft(fft, scale=1.0): data = np.zeros(len(fft)) for i, v in enumerate(fft): data[i] = scale * (i * v) / NUM_SAMPLES return data"
            },
            {
                "url": 615,
                "code": "def normalize(im, invert=False, scale=None, dtype=np.float64): if dtype not in {np.float16, np.float32, np.float64}: raise ValueError('dtype must be numpy.float16, float32, or float64.') out = im.astype('float').copy() scale = scale or (0.0, 255.0) l, u = (float(i) for i in scale) out = (out - l) / (u - l) if invert: out = -out + (out.max() + out.min()) return out.astype(dtype)"
            },
            {
                "url": 1487,
                "code": "def round_array(array_in): if isinstance(array_in, ndarray): return np.round(array_in).astype(int) else: return int(np.round(array_in))"
            },
            {
                "url": 3686,
                "code": "def set_scale(self, scale, no_reset=False): return self.scale_to(*scale[:2], no_reset=no_reset)"
            },
            {
                "url": 4857,
                "code": "def scale_v2(vec, amount): return Vec2(vec.x * amount, vec.y * amount)"
            },
            {
                "url": 1397,
                "code": "def _normalize(image): offset = tf.constant(MEAN_RGB, shape=[1, 1, 3]) image -= offset scale = tf.constant(STDDEV_RGB, shape=[1, 1, 3]) image /= scale return image"
            },
            {
                "url": 1948,
                "code": "def inverse_transform(self, X): X = check_array(X, copy=self.copy) X -= self.min_ X /= self.scale_ return X"
            },
            {
                "url": 849,
                "code": "def denorm(self,arr): if type(arr) is not np.ndarray: arr = to_np(arr) if len(arr.shape)==3: arr = arr[None] return self.transform.denorm(np.rollaxis(arr,1,4))"
            },
            {
                "url": 1498,
                "code": "def resetScale(self): self.img.scale(1./self.imgScale[0], 1./self.imgScale[1]) self.imgScale = (1.,1.)"
            }
        ],
        "url": 5183
    },
    {
        "nl_input": "python upper case lower case converter",
        "code_input": [
            {
                "url": 5661,
                "code": "def uppercase_chars(string: any) -> str: return ''.join([c if c.isupper() else '' for c in str(string)])"
            },
            {
                "url": 5614,
                "code": "def _lower(string): if not string: return \"\" new_string = [string[0].lower()] for char in string[1:]: if char.isupper(): new_string.append(\"_\") new_string.append(char.lower()) return \"\".join(new_string)"
            },
            {
                "url": 3244,
                "code": "def camelcase(string): string = re.sub(r\"^[\\-_\\.]\", '', str(string)) if not string: return string return lowercase(string[0]) + re.sub(r\"[\\-_\\.\\s]([a-z])\", lambda matched: uppercase(matched.group(1)), string[1:])"
            },
            {
                "url": 5595,
                "code": "def lower_camel_case_from_underscores(string): components = string.split('_') string = components[0] for component in components[1:]: string += component[0].upper() + component[1:] return string"
            },
            {
                "url": 5588,
                "code": "def lowercase_chars(string: any) -> str: return ''.join([c if c.islower() else '' for c in str(string)])"
            },
            {
                "url": 718,
                "code": "def camel_case_from_underscores(string): components = string.split('_') string = '' for component in components: string += component[0].upper() + component[1:] return string"
            },
            {
                "url": 4677,
                "code": "def camelcase2list(s, lower=False): s = re.findall(r'([A-Z][a-z0-9]+)', s) return [w.lower() for w in s] if lower else s"
            },
            {
                "url": 5981,
                "code": "def capitalize(string): if not string: return string if len(string) == 1: return string.upper() return string[0].upper() + string[1:].lower()"
            },
            {
                "url": 5422,
                "code": "def parse_case_snake_to_camel(snake, upper_first=True): snake = snake.split('_') first_part = snake[0] if upper_first: first_part = first_part.title() return first_part + ''.join(word.title() for word in snake[1:])"
            },
            {
                "url": 878,
                "code": "def upcaseTokens(s,l,t): return [ tt.upper() for tt in map(_ustr,t) ]"
            },
            {
                "url": 6176,
                "code": "def convert_camel_case_string(name: str) -> str: string = re.sub(\"(.)([A-Z][a-z]+)\", r\"\\1_\\2\", name) return re.sub(\"([a-z0-9])([A-Z])\", r\"\\1_\\2\", string).lower()"
            },
            {
                "url": 3327,
                "code": "def clean(some_string, uppercase=False): if uppercase: return some_string.strip().upper() else: return some_string.strip().lower()"
            },
            {
                "url": 124,
                "code": "def to_pascal_case(s): return re.sub(r'(?!^)_([a-zA-Z])', lambda m: m.group(1).upper(), s.capitalize())"
            },
            {
                "url": 2591,
                "code": "def camel_to_underscore(string): string = FIRST_CAP_RE.sub(r'\\1_\\2', string) return ALL_CAP_RE.sub(r'\\1_\\2', string).lower()"
            },
            {
                "url": 5767,
                "code": "def camel_to_snake_case(string): s = _1.sub(r'\\1_\\2', string) return _2.sub(r'\\1_\\2', s).lower()"
            }
        ],
        "url": 878
    },
    {
        "nl_input": "ply python expression evaluator",
        "code_input": [
            {
                "url": 470,
                "code": "def xpathEvalExpression(self, str): ret = libxml2mod.xmlXPathEvalExpression(str, self._o) if ret is None:raise xpathError('xmlXPathEvalExpression() failed') return xpathObjectRet(ret)"
            },
            {
                "url": 5002,
                "code": "def eval(self, expression, use_compilation_plan=False): code = 'PyJsEvalResult = eval(%s)' % json.dumps(expression) self.execute(code, use_compilation_plan=use_compilation_plan) return self['PyJsEvalResult']"
            },
            {
                "url": 3296,
                "code": "def eval_script(self, expr): ret = self.conn.issue_command(\"Evaluate\", expr) return json.loads(\"[%s]\" % ret)[0]"
            },
            {
                "url": 6122,
                "code": "def src2ast(src: str) -> Expression: try: return ast.parse(src, mode='eval') except SyntaxError: raise ValueError(\"Not a valid expression.\") from None"
            },
            {
                "url": 4137,
                "code": "def get_value(self, context): if self.value: return expressions.eval_string(self.value, context) else: # Empty input raises cryptic EOF syntax err, this more human # friendly raise ValueError('!py string expression is empty. It must be a ' 'valid python expression instead.')"
            },
            {
                "url": 1830,
                "code": "def xeval(source, optimize=True): native = xcompile(source, optimize=optimize) return native()"
            },
            {
                "url": 261,
                "code": "def eval_in_system_namespace(self, exec_str): ns = self.cmd_namespace try: return eval(exec_str, ns) except Exception as e: self.logger.warning('Could not execute %s, gave error %s', exec_str, e) return None"
            },
            {
                "url": 4328,
                "code": "def compile(expr, params=None): from ibis.sql.alchemy import to_sqlalchemy return to_sqlalchemy(expr, dialect.make_context(params=params))"
            },
            {
                "url": 477,
                "code": "def runcode(code): for line in code: print('# '+line) exec(line,globals()) print('# return ans') return ans"
            },
            {
                "url": 2706,
                "code": "def _try_compile(source, name): try: c = compile(source, name, 'eval') except SyntaxError: c = compile(source, name, 'exec') return c"
            },
            {
                "url": 1784,
                "code": "def _expand(self, str, local_vars={}): return ninja_syntax.expand(str, self.vars, local_vars)"
            },
            {
                "url": 3942,
                "code": "def build(self, **kwargs): self.lexer = ply.lex.lex(object=self, **kwargs)"
            },
            {
                "url": 5053,
                "code": "def PythonPercentFormat(format_str): if format_str.startswith('printf '): fmt = format_str[len('printf '):] return lambda value: fmt % value else: return None"
            },
            {
                "url": 263,
                "code": "def exec_function(ast, globals_map): locals_map = globals_map exec ast in globals_map, locals_map return locals_map"
            },
            {
                "url": 1536,
                "code": "def parse(el, typ): if not el: return typ() txt = text(el) if not txt: return typ() return typ(txt)"
            }
        ],
        "url": 3942
    },
    {
        "nl_input": "python hashlib calc sha1 of file",
        "code_input": [
            {
                "url": 4951,
                "code": "def _get_file_sha1(file): bits = file.read() file.seek(0) h = hashlib.new('sha1', bits).hexdigest() return h"
            },
            {
                "url": 3204,
                "code": "def _sha1_for_file(filename): with open(filename, \"rb\") as fileobj: contents = fileobj.read() return hashlib.sha1(contents).hexdigest()"
            },
            {
                "url": 3205,
                "code": "def sha1(s): h = hashlib.new('sha1') h.update(s) return h.hexdigest()"
            },
            {
                "url": 3336,
                "code": "def generate_hash(filepath): fr = FileReader(filepath) data = fr.read_bin() return _calculate_sha256(data)"
            },
            {
                "url": 5855,
                "code": "def hash_file(fileobj): hasher = hashlib.md5() buf = fileobj.read(65536) while len(buf) > 0: hasher.update(buf) buf = fileobj.read(65536) return hasher.hexdigest()"
            },
            {
                "url": 499,
                "code": "def md5_hash_file(fh): md5 = hashlib.md5() while True: data = fh.read(8192) if not data: break md5.update(data) return md5.hexdigest()"
            },
            {
                "url": 1881,
                "code": "def get_file_md5sum(path): with open(path, 'rb') as fh: h = str(hashlib.md5(fh.read()).hexdigest()) return h"
            },
            {
                "url": 5153,
                "code": "def filehash(path): with open(path, \"rU\") as f: return md5(py3compat.str_to_bytes(f.read())).hexdigest()"
            },
            {
                "url": 6044,
                "code": "def checksum(path): hasher = hashlib.sha1() with open(path, 'rb') as stream: buf = stream.read(BLOCKSIZE) while len(buf) > 0: hasher.update(buf) buf = stream.read(BLOCKSIZE) return hasher.hexdigest()"
            },
            {
                "url": 5995,
                "code": "def _hash_the_file(hasher, filename): BUF_SIZE = 65536 with open(filename, 'rb') as f: buf = f.read(BUF_SIZE) while len(buf) > 0: hasher.update(buf) buf = f.read(BUF_SIZE) return hasher"
            },
            {
                "url": 3435,
                "code": "def file_md5sum(filename): hash_md5 = hashlib.md5() with open(filename, 'rb') as f: for chunk in iter(lambda: f.read(1024 * 4), b''): hash_md5.update(chunk) return hash_md5.hexdigest()"
            },
            {
                "url": 582,
                "code": "def get_md5_for_file(file): md5 = hashlib.md5() while True: data = file.read(md5.block_size) if not data: break md5.update(data) return md5.hexdigest()"
            },
            {
                "url": 3473,
                "code": "def array_sha256(a): dtype = str(a.dtype).encode() shape = numpy.array(a.shape) sha = hashlib.sha256() sha.update(dtype) sha.update(shape) sha.update(a.tobytes()) return sha.hexdigest()"
            },
            {
                "url": 1193,
                "code": "def md5_string(s): m = hashlib.md5() m.update(s) return str(m.hexdigest())"
            },
            {
                "url": 4902,
                "code": "def update_hash(cls, filelike, digest): block_size = digest.block_size * 1024 for chunk in iter(lambda: filelike.read(block_size), b''): digest.update(chunk)"
            }
        ],
        "url": 4951
    },
    {
        "nl_input": "python pdb no capture std output",
        "code_input": [
            {
                "url": 900,
                "code": "def set_trace(): # https://github.com/nose-devs/nose/blob/master/nose/tools/nontrivial.py pdb.Pdb(stdout=sys.__stdout__).set_trace(sys._getframe().f_back)"
            },
            {
                "url": 5695,
                "code": "def suppress_stdout(): save_stdout = sys.stdout sys.stdout = DevNull() yield sys.stdout = save_stdout"
            },
            {
                "url": 6260,
                "code": "def capture_stdout(): stdout = sys.stdout sys.stdout = six.moves.cStringIO() try: yield sys.stdout finally: sys.stdout = stdout"
            },
            {
                "url": 899,
                "code": "def debug_on_error(type, value, tb): traceback.print_exc(type, value, tb) print() pdb.pm()"
            },
            {
                "url": 2887,
                "code": "def disable_stdout_buffering(): stdout_orig = sys.stdout sys.stdout = os.fdopen(sys.stdout.fileno(), 'w', 0) # NOTE(brandyn): This removes the original stdout return stdout_orig"
            },
            {
                "url": 2265,
                "code": "def redirect_std(): stdin = sys.stdin stdout = sys.stdout if not sys.stdin.isatty(): sys.stdin = open_raw(\"/dev/tty\", \"r\", 0) if not sys.stdout.isatty(): sys.stdout = open_raw(\"/dev/tty\", \"w\", 0) return stdin, stdout"
            },
            {
                "url": 5408,
                "code": "def pstd(self, *args, **kwargs): kwargs['file'] = self.out self.print(*args, **kwargs) sys.stdout.flush()"
            },
            {
                "url": 1079,
                "code": "def _stdout_raw(self, s): print(s, end='', file=sys.stdout) sys.stdout.flush()"
            },
            {
                "url": 4276,
                "code": "def __exit__(self, *args): sys.stdout = self._orig self._devnull.close()"
            },
            {
                "url": 5092,
                "code": "def print_message(message=None): kwargs = {'stdout': sys.stdout, 'stderr': sys.stderr, 'shell': True} return subprocess.call('echo \"{0}\"'.format(message or ''), **kwargs)"
            },
            {
                "url": 5019,
                "code": "def _debug_log(self, msg): if not self.debug: return sys.stderr.write('{}\\n'.format(msg))"
            },
            {
                "url": 930,
                "code": "def stdout_display(): if sys.version_info[0] == 2: yield SmartBuffer(sys.stdout) else: yield SmartBuffer(sys.stdout.buffer)"
            },
            {
                "url": 1386,
                "code": "def redirect_stdout(new_stdout): old_stdout, sys.stdout = sys.stdout, new_stdout try: yield None finally: sys.stdout = old_stdout"
            },
            {
                "url": 1485,
                "code": "def redirect_output(fileobj): old = sys.stdout sys.stdout = fileobj try: yield fileobj finally: sys.stdout = old"
            },
            {
                "url": 2453,
                "code": "def start(self): self.streams.append(sys.stdout) sys.stdout = self.stream"
            }
        ],
        "url": 900
    },
    {
        "nl_input": "python how to write a factorial",
        "code_input": [
            {
                "url": 5904,
                "code": "def factorial(n, mod=None): if not (isinstance(n, int) and n >= 0): raise ValueError(\"'n' must be a non-negative integer.\") if mod is not None and not (isinstance(mod, int) and mod > 0): raise ValueError(\"'mod' must be a positive integer\") result = 1 if n == 0: return 1 for i in range(2, n+1): result *= i if mod: result %= mod return result"
            },
            {
                "url": 3527,
                "code": "def computeFactorial(n): sleep_walk(10) ret = 1 for i in range(n): ret = ret * (i + 1) return ret"
            },
            {
                "url": 580,
                "code": "def _factor_generator(n): p = prime_factors(n) factors = {} for p1 in p: try: factors[p1] += 1 except KeyError: factors[p1] = 1 return factors"
            },
            {
                "url": 6090,
                "code": "def factors(n): return set(reduce(list.__add__, ([i, n // i] for i in range(1, int(n ** 0.5) + 1) if n % i == 0)))"
            },
            {
                "url": 5946,
                "code": "def fib(n): assert n > 0 a, b = 1, 1 for i in range(n - 1): a, b = b, a + b return a"
            },
            {
                "url": 529,
                "code": "def getPrimeFactors(n): lo = [1] n2 = n // 2 k = 2 for k in range(2, n2 + 1): if (n // k)*k == n: lo.append(k) return lo + [n, ]"
            },
            {
                "url": 1987,
                "code": "def multiply(self, number): return self.from_list([x * number for x in self.to_list()])"
            },
            {
                "url": 3161,
                "code": "def Exponential(x, a, tau, y0): return np.exp(x / tau) * a + y0"
            },
            {
                "url": 500,
                "code": "def software_fibonacci(n): a, b = 0, 1 for i in range(n): a, b = b, a + b return a"
            },
            {
                "url": 1542,
                "code": "def Bernstein(n, k): coeff = binom(n, k) def _bpoly(x): return coeff * x ** k * (1 - x) ** (n - k) return _bpoly"
            },
            {
                "url": 4962,
                "code": "def parse_float(float_str): factor = __get_factor(float_str) if factor != 1: float_str = float_str[:-1] try: return float(float_str.replace(',', '')) * factor except ValueError: return None"
            },
            {
                "url": 5217,
                "code": "def mul(a, b): def multiply(a, b): \"\"\"Multiplication\"\"\" return a * b return op_with_scalar_cast(a, b, multiply)"
            },
            {
                "url": 3816,
                "code": "def _power(ctx, number, power): return decimal_pow(conversions.to_decimal(number, ctx), conversions.to_decimal(power, ctx))"
            },
            {
                "url": 4229,
                "code": "def tick(self): self.current += 1 if self.current == self.factor: sys.stdout.write('+') sys.stdout.flush() self.current = 0"
            },
            {
                "url": 5885,
                "code": "def interpolate(f1: float, f2: float, factor: float) -> float: return f1 + (f2 - f1) * factor"
            }
        ],
        "url": 5904
    },
    {
        "nl_input": "python get the last column",
        "code_input": [
            {
                "url": 5924,
                "code": "def last(self): if self._last is UNDETERMINED: # not necessarily the last one... self._last = self.sdat.tseries.index[-1] return self[self._last]"
            },
            {
                "url": 1506,
                "code": "def get_last(self, table=None): if table is None: table = self.main_table query = 'SELECT * FROM \"%s\" ORDER BY ROWID DESC LIMIT 1;' % table return self.own_cursor.execute(query).fetchone()"
            },
            {
                "url": 585,
                "code": "def last(self): # End of file self.__file.seek(0, 2) # Get the last struct data = self.get(self.length - 1) return data"
            },
            {
                "url": 587,
                "code": "def get_last_row(dbconn, tablename, n=1, uuid=None): return fetch(dbconn, tablename, n, uuid, end=True)"
            },
            {
                "url": 5054,
                "code": "def _last_index(x, default_dim): if x.get_shape().ndims is not None: return len(x.get_shape()) - 1 else: return default_dim"
            },
            {
                "url": 3231,
                "code": "def get_last_id(self, cur, table='reaction'): cur.execute(\"SELECT seq FROM sqlite_sequence WHERE name='{0}'\" .format(table)) result = cur.fetchone() if result is not None: id = result[0] else: id = 0 return id"
            },
            {
                "url": 4230,
                "code": "def last_item(array): if array.size == 0: # work around for https://github.com/numpy/numpy/issues/5195 return [] indexer = (slice(-1, None),) * array.ndim return np.ravel(array[indexer]).tolist()"
            },
            {
                "url": 4929,
                "code": "def _get_current_label(self): if len(self._last) == 0: raise StopIteration return self._last[:self._last.find(\":\")]"
            },
            {
                "url": 5113,
                "code": "def get_last_filled_cell(self, table=None): maxrow = 0 maxcol = 0 for row, col, tab in self.dict_grid: if table is None or tab == table: maxrow = max(row, maxrow) maxcol = max(col, maxcol) return maxrow, maxcol, table"
            },
            {
                "url": 4844,
                "code": "def do_last(environment, seq): try: return next(iter(reversed(seq))) except StopIteration: return environment.undefined('No last item, sequence was empty.')"
            },
            {
                "url": 435,
                "code": "def last_day(year=_year, month=_month): last_day = calendar.monthrange(year, month)[1] return datetime.date(year=year, month=month, day=last_day)"
            },
            {
                "url": 5320,
                "code": "def move_to_start(self, column_label): self._columns.move_to_end(column_label, last=False) return self"
            },
            {
                "url": 3756,
                "code": "def get_last_or_frame_exception(): try: if inspect.istraceback(sys.last_traceback): # We do have a traceback so prefer that. return sys.last_type, sys.last_value, sys.last_traceback except AttributeError: pass return sys.exc_info()"
            },
            {
                "url": 5667,
                "code": "def get_last_weekday_in_month(year, month, weekday): day = date(year, month, monthrange(year, month)[1]) while True: if day.weekday() == weekday: break day = day - timedelta(days=1) return day"
            },
            {
                "url": 4636,
                "code": "def get_tail(self): node = self.head last_node = self.head while node is not None: last_node = node node = node.next_node return last_node"
            }
        ],
        "url": 587
    },
    {
        "nl_input": "python how to change file extension",
        "code_input": [
            {
                "url": 6048,
                "code": "def get_file_extension(filename): filename_x = filename.split('.') if len(filename_x) > 1: if filename_x[-1].strip() is not '': return filename_x[-1] return None"
            },
            {
                "url": 2527,
                "code": "def get_file_extension_type(filename): ext = get_file_extension(filename) if ext: for name, group in EXTENSIONS.items(): if ext in group: return name return \"OTHER\""
            },
            {
                "url": 5825,
                "code": "def infer_format(filename:str) -> str: _, ext = os.path.splitext(filename) return ext"
            },
            {
                "url": 6154,
                "code": "def _extension(modpath: str) -> setuptools.Extension: return setuptools.Extension(modpath, [modpath.replace(\".\", \"/\") + \".py\"])"
            },
            {
                "url": 2343,
                "code": "def splitext_no_dot(filename): name, ext = os.path.splitext(filename) ext = ext.lower() return name, ext.strip('.')"
            },
            {
                "url": 4924,
                "code": "def get_filetype_icon(fname): ext = osp.splitext(fname)[1] if ext.startswith('.'): ext = ext[1:] return get_icon( \"%s.png\" % ext, ima.icon('FileIcon') )"
            },
            {
                "url": 1489,
                "code": "def lower_ext(abspath): fname, ext = os.path.splitext(abspath) return fname + ext.lower()"
            },
            {
                "url": 2888,
                "code": "def remove_ext(fname): bn = os.path.basename(fname) return os.path.splitext(bn)[0]"
            },
            {
                "url": 701,
                "code": "def filename_addstring(filename, text): fn, ext = os.path.splitext(filename) return fn + text + ext"
            },
            {
                "url": 4465,
                "code": "def slugify_filename(filename): name, ext = os.path.splitext(filename) slugified = get_slugified_name(name) return slugified + ext"
            },
            {
                "url": 2100,
                "code": "def add_suffix(fullname, suffix): name, ext = os.path.splitext(fullname) return name + '_' + suffix + ext"
            },
            {
                "url": 4549,
                "code": "def load(cls,filename): filename = cls.correct_file_extension(filename) with open(filename,'rb') as f: return pickle.load(f)"
            },
            {
                "url": 2015,
                "code": "def get_url_file_name(url): assert isinstance(url, (str, _oldstr)) return urlparse.urlparse(url).path.split('/')[-1]"
            },
            {
                "url": 1614,
                "code": "def is_valid_image_extension(file_path): valid_extensions = ['.jpeg', '.jpg', '.gif', '.png'] _, extension = os.path.splitext(file_path) return extension.lower() in valid_extensions"
            },
            {
                "url": 951,
                "code": "def get_file_name(url): return os.path.basename(urllib.parse.urlparse(url).path) or 'unknown_name'"
            }
        ],
        "url": 1489
    },
    {
        "nl_input": "python get process memory info",
        "code_input": [
            {
                "url": 1459,
                "code": "def get_memory_usage(): process = psutil.Process(os.getpid()) mem = process.memory_info().rss return mem / (1024 * 1024)"
            },
            {
                "url": 5752,
                "code": "def memory_usage(): try: import psutil import os except ImportError: return _memory_usage_ps() process = psutil.Process(os.getpid()) mem = process.memory_info()[0] / float(2 ** 20) return mem"
            },
            {
                "url": 1457,
                "code": "def current_memory_usage(): import psutil proc = psutil.Process(os.getpid()) #meminfo = proc.get_memory_info() meminfo = proc.memory_info() rss = meminfo[0] # Resident Set Size / Mem Usage vms = meminfo[1] # Virtual Memory Size / VM Size # NOQA return rss"
            },
            {
                "url": 401,
                "code": "def memory(): mem_info = dict() for k, v in psutil.virtual_memory()._asdict().items(): mem_info[k] = int(v) return mem_info"
            },
            {
                "url": 3055,
                "code": "def machine_info(): import psutil BYTES_IN_GIG = 1073741824.0 free_bytes = psutil.virtual_memory().total return [{\"memory\": float(\"%.1f\" % (free_bytes / BYTES_IN_GIG)), \"cores\": multiprocessing.cpu_count(), \"name\": socket.gethostname()}]"
            },
            {
                "url": 3041,
                "code": "def peak_memory_usage(): if sys.platform.startswith('win'): p = psutil.Process() return p.memory_info().peak_wset / 1024 / 1024 mem = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss factor_mb = 1 / 1024 if sys.platform == 'darwin': factor_mb = 1 / (1024 * 1024) return mem * factor_mb"
            },
            {
                "url": 469,
                "code": "def get_free_memory_win(): stat = MEMORYSTATUSEX() ctypes.windll.kernel32.GlobalMemoryStatusEx(ctypes.byref(stat)) return int(stat.ullAvailPhys / 1024 / 1024)"
            },
            {
                "url": 1642,
                "code": "def memory_used(self): if self._end_memory: memory_used = self._end_memory - self._start_memory return memory_used else: return None"
            },
            {
                "url": 5684,
                "code": "def memory_full(): current_process = psutil.Process(os.getpid()) return (current_process.memory_percent() > config.MAXIMUM_CACHE_MEMORY_PERCENTAGE)"
            },
            {
                "url": 5624,
                "code": "def psutil_phymem_usage(): import psutil # This is needed to avoid a deprecation warning error with # newer psutil versions try: percent = psutil.virtual_memory().percent except: percent = psutil.phymem_usage().percent return percent"
            },
            {
                "url": 2117,
                "code": "def memory_usage(method): def wrapper(*args, **kwargs): logging.info('Memory before method %s is %s.', method.__name__, runtime.memory_usage().current()) result = method(*args, **kwargs) logging.info('Memory after method %s is %s', method.__name__, runtime.memory_usage().current()) return result return wrapper"
            },
            {
                "url": 1342,
                "code": "def swap_memory(): mem = _psutil_mswindows.get_virtual_mem() total = mem[2] free = mem[3] used = total - free percent = usage_percent(used, total, _round=1) return nt_swapmeminfo(total, used, free, percent, 0, 0)"
            },
            {
                "url": 4575,
                "code": "def memory_usage(self, deep=False): return self._codes.nbytes + self.dtype.categories.memory_usage( deep=deep)"
            },
            {
                "url": 146,
                "code": "def get_system_cpu_times(): user, nice, system, idle = _psutil_osx.get_system_cpu_times() return _cputimes_ntuple(user, nice, system, idle)"
            },
            {
                "url": 622,
                "code": "def _EnforceProcessMemoryLimit(self, memory_limit): # Resource is not supported on Windows. if resource: if memory_limit is None: memory_limit = 4 * 1024 * 1024 * 1024 elif memory_limit == 0: memory_limit = resource.RLIM_INFINITY resource.setrlimit(resource.RLIMIT_DATA, (memory_limit, memory_limit))"
            }
        ],
        "url": 3055
    },
    {
        "nl_input": "check if 2 string are equal python",
        "code_input": [
            {
                "url": 4037,
                "code": "def compare(string1, string2): if len(string1) != len(string2): return False result = True for c1, c2 in izip(string1, string2): result &= c1 == c2 return result"
            },
            {
                "url": 869,
                "code": "def is_equal_strings_ignore_case(first, second): if first and second: return first.upper() == second.upper() else: return not (first or second)"
            },
            {
                "url": 412,
                "code": "def eqstr(a, b): return bool(libspice.eqstr_c(stypes.stringToCharP(a), stypes.stringToCharP(b)))"
            },
            {
                "url": 5851,
                "code": "def assert_equal(first, second, msg_fmt=\"{msg}\"): if isinstance(first, dict) and isinstance(second, dict): assert_dict_equal(first, second, msg_fmt) elif not first == second: msg = \"{!r} != {!r}\".format(first, second) fail(msg_fmt.format(msg=msg, first=first, second=second))"
            },
            {
                "url": 5029,
                "code": "def compare(self, first, second): if first.lower() == second.lower(): return True else: return False"
            },
            {
                "url": 2161,
                "code": "def equal(obj1, obj2): Comparable.log(obj1, obj2, '==') equality = obj1.equality(obj2) Comparable.log(obj1, obj2, '==', result=equality) return equality"
            },
            {
                "url": 5584,
                "code": "def indexes_equal(a: Index, b: Index) -> bool: return str(a) == str(b)"
            },
            {
                "url": 3573,
                "code": "def hamming_distance(str1, str2): if len(str1) != len(str2): raise VisualizationError('Strings not same length.') return sum(s1 != s2 for s1, s2 in zip(str1, str2))"
            },
            {
                "url": 180,
                "code": "def numpy_aware_eq(a, b): if isinstance(a, np.ndarray) or isinstance(b, np.ndarray): return np.array_equal(a, b) if ((isinstance(a, Iterable) and isinstance(b, Iterable)) and not isinstance(a, str) and not isinstance(b, str)): if len(a) != len(b): return False return all(numpy_aware_eq(x, y) for x, y in zip(a, b)) return a == b"
            },
            {
                "url": 2136,
                "code": "def allsame(list_, strict=True): if len(list_) == 0: return True first_item = list_[0] return list_all_eq_to(list_, first_item, strict)"
            },
            {
                "url": 480,
                "code": "def equal(list1, list2): return [item1 == item2 for item1, item2 in broadcast_zip(list1, list2)]"
            },
            {
                "url": 2683,
                "code": "def rsa_eq(key1, key2): pn1 = key1.public_numbers() pn2 = key2.public_numbers() # Check if two RSA keys are in fact the same if pn1 == pn2: return True else: return False"
            },
            {
                "url": 3907,
                "code": "def _eq(self, other): return (self.type, self.value) == (other.type, other.value)"
            },
            {
                "url": 5224,
                "code": "def assert_looks_like(first, second, msg=None): first = _re.sub(\"\\s+\", \" \", first.strip()) second = _re.sub(\"\\s+\", \" \", second.strip()) if first != second: raise AssertionError(msg or \"%r does not look like %r\" % (first, second))"
            },
            {
                "url": 1825,
                "code": "def are_equal_xml(a_xml, b_xml): a_dom = xml.dom.minidom.parseString(a_xml) b_dom = xml.dom.minidom.parseString(b_xml) return are_equal_elements(a_dom.documentElement, b_dom.documentElement)"
            }
        ],
        "url": 5584
    },
    {
        "nl_input": "flask python create one table sqlalchemy",
        "code_input": [
            {
                "url": 3549,
                "code": "def create_db(app, appbuilder): from flask_appbuilder.models.sqla import Base _appbuilder = import_application(app, appbuilder) engine = _appbuilder.get_session.get_bind(mapper=None, clause=None) Base.metadata.create_all(engine) click.echo(click.style(\"DB objects created\", fg=\"green\"))"
            },
            {
                "url": 2780,
                "code": "def create_bigquery_table(self, database, schema, table_name, callback, sql): conn = self.get_thread_connection() client = conn.handle view_ref = self.table_ref(database, schema, table_name, conn) view = google.cloud.bigquery.Table(view_ref) callback(view) with self.exception_handler(sql): client.create_table(view)"
            },
            {
                "url": 1170,
                "code": "def createdb(): manager.db.engine.echo = True manager.db.create_all() set_alembic_revision()"
            },
            {
                "url": 2747,
                "code": "def create_db_schema(cls, cur, schema_name): create_schema_script = \"CREATE SCHEMA {0} ;\\n\".format(schema_name) cur.execute(create_schema_script)"
            },
            {
                "url": 4328,
                "code": "def compile(expr, params=None): from ibis.sql.alchemy import to_sqlalchemy return to_sqlalchemy(expr, dialect.make_context(params=params))"
            },
            {
                "url": 337,
                "code": "def init_db(): db.drop_all() db.configure_mappers() db.create_all() db.session.commit()"
            },
            {
                "url": 315,
                "code": "def sqlmany(self, stringname, *args): if hasattr(self, 'alchemist'): return getattr(self.alchemist.many, stringname)(*args) s = self.strings[stringname] return self.connection.cursor().executemany(s, args)"
            },
            {
                "url": 4517,
                "code": "def add_column(connection, column): stmt = alembic.ddl.base.AddColumn(_State.table.name, column) connection.execute(stmt) _State.reflect_metadata()"
            },
            {
                "url": 5106,
                "code": "def table_exists(cursor, tablename, schema='public'): query = cursor.execute(query, (schema, tablename)) res = cursor.fetchone()[0] return res"
            },
            {
                "url": 3088,
                "code": "def get_table_metadata(engine, table): metadata = MetaData() metadata.reflect(bind=engine, only=[table]) table_metadata = Table(table, metadata, autoload=True) return table_metadata"
            },
            {
                "url": 4461,
                "code": "def create_all(self, check_first: bool = True): self._metadata.create_all(self.engine, checkfirst=check_first)"
            },
            {
                "url": 3059,
                "code": "def drop_all_tables(self): for table_name in self.table_names(): self.execute_sql(\"DROP TABLE %s\" % table_name) self.connection.commit()"
            },
            {
                "url": 5384,
                "code": "def destroy(self): with self._db_conn() as conn: for table_name in self._tables: conn.execute('DROP TABLE IF EXISTS %s' % table_name) return self"
            },
            {
                "url": 2750,
                "code": "def append_table(self, name, **kwargs): self.stack.append(Table(name, **kwargs))"
            },
            {
                "url": 209,
                "code": "def delete_all_from_db(): # The models.CASCADE property is set on all ForeignKey fields, so tables can # be deleted in any order without breaking constraints. for model in django.apps.apps.get_models(): model.objects.all().delete()"
            }
        ],
        "url": 3549
    },
    {
        "nl_input": "clean output folder in python",
        "code_input": [
            {
                "url": 4094,
                "code": "def cleanup(): if _output_dir and os.path.exists(_output_dir): log.msg_warn(\"Cleaning up output directory at '{output_dir}' ...\" .format(output_dir=_output_dir)) if not _dry_run: shutil.rmtree(_output_dir)"
            },
            {
                "url": 4126,
                "code": "def clean(dry_run='n'): file_patterns = ['*.pyc', '*.pyo', '*~'] dir_patterns = ['__pycache__'] recursive_pattern_delete(project_paths.root, file_patterns, dir_patterns, dry_run=bool(dry_run.lower() == 'y'))"
            },
            {
                "url": 2279,
                "code": "def clean(): run('rm -rf build/') run('rm -rf dist/') run('rm -rf puzzle.egg-info') run('find . -name __pycache__ -delete') run('find . -name *.pyc -delete') run('find . -name *.pyo -delete') run('find . -name *~ -delete') log.info('cleaned up')"
            },
            {
                "url": 2576,
                "code": "def clean_py_files(path): for dirname, subdirlist, filelist in os.walk(path): for f in filelist: if f.endswith('py'): os.remove(os.path.join(dirname, f))"
            },
            {
                "url": 4869,
                "code": "def clean(ctx, dry_run=False): basedir = ctx.sphinx.destdir or \"build/docs\" cleanup_dirs([basedir], dry_run=dry_run)"
            },
            {
                "url": 1970,
                "code": "def clean_tmpdir(path): if os.path.exists(path) and \\ os.path.isdir(path): rmtree(path)"
            },
            {
                "url": 6021,
                "code": "def _cleanup(path: str) -> None: if os.path.isdir(path): shutil.rmtree(path)"
            },
            {
                "url": 1906,
                "code": "def clean_out_dir(directory): if not isinstance(directory, path): directory = path(directory) for file_path in directory.files(): file_path.remove() for dir_path in directory.dirs(): dir_path.rmtree()"
            },
            {
                "url": 145,
                "code": "def delete_all_eggs(self): path_to_delete = os.path.join(self.egg_directory, \"lib\", \"python\") if os.path.exists(path_to_delete): shutil.rmtree(path_to_delete)"
            },
            {
                "url": 4963,
                "code": "def cli(ctx, project_dir): exit_code = SCons(project_dir).clean() ctx.exit(exit_code)"
            },
            {
                "url": 776,
                "code": "def clean_all(self, args): self.clean_dists(args) self.clean_builds(args) self.clean_download_cache(args)"
            },
            {
                "url": 2894,
                "code": "def cleanup(self): for file in glob.glob(self.basename + '*'): os.unlink(file)"
            },
            {
                "url": 5787,
                "code": "def output_dir(self, *args) -> str: return os.path.join(self.project_dir, 'output', *args)"
            },
            {
                "url": 925,
                "code": "def py(self, output): import pprint pprint.pprint(output, stream=self.outfile)"
            },
            {
                "url": 3817,
                "code": "def safe_mkdir_for(path, clean=False): safe_mkdir(os.path.dirname(path), clean=clean)"
            }
        ],
        "url": 4094
    },
    {
        "nl_input": "python print nodes binary tree",
        "code_input": [
            {
                "url": 3110,
                "code": "def print_bintree(tree, indent=' '): for n in sorted(tree.keys()): print \"%s%s\" % (indent * depth(n,tree), n)"
            },
            {
                "url": 5626,
                "code": "def debugTreePrint(node,pfx=\"->\"): print pfx,node.item for c in node.children: debugTreePrint(c,\" \"+pfx)"
            },
            {
                "url": 1595,
                "code": "def print_tree(self, indent=2): config.LOGGER.info(\"{indent}{data}\".format(indent=\" \" * indent, data=str(self))) for child in self.children: child.print_tree(indent + 1)"
            },
            {
                "url": 3890,
                "code": "def pprint(self, ind): pp = pprint.PrettyPrinter(indent=ind) pp.pprint(self.tree)"
            },
            {
                "url": 4966,
                "code": "def to_tree(self): tree = TreeLibTree() for node in self: tree.create_node(node, node.node_id, parent=node.parent) return tree"
            },
            {
                "url": 4876,
                "code": "def map_tree(visitor, tree): newn = [map_tree(visitor, node) for node in tree.nodes] return visitor(tree, newn)"
            },
            {
                "url": 995,
                "code": "def make_bintree(levels): G = nx.DiGraph() root = '0' G.add_node(root) add_children(G, root, levels, 2) return G"
            },
            {
                "url": 4427,
                "code": "def draw_tree(t, df, size=10, ratio=0.6, precision=0): s=export_graphviz(t, out_file=None, feature_names=df.columns, filled=True, special_characters=True, rotate=True, precision=precision) IPython.display.display(graphviz.Source(re.sub('Tree {', f'Tree {{ size={size}; ratio={ratio}', s)))"
            },
            {
                "url": 5871,
                "code": "def getRandomBinaryTreeLeafNode(binaryTree): if binaryTree.internal == True: if random.random() > 0.5: return getRandomBinaryTreeLeafNode(binaryTree.left) else: return getRandomBinaryTreeLeafNode(binaryTree.right) else: return binaryTree"
            },
            {
                "url": 1282,
                "code": "def walk_tree(root): yield root for child in root.children: for el in walk_tree(child): yield el"
            },
            {
                "url": 2892,
                "code": "def cric__decision_tree(): model = sklearn.tree.DecisionTreeClassifier(random_state=0, max_depth=4) # we want to explain the raw probability outputs of the trees model.predict = lambda X: model.predict_proba(X)[:,1] return model"
            },
            {
                "url": 5918,
                "code": "def fprint(expr, print_ascii=False): r if print_ascii: pprint(expr, use_unicode=False, num_columns=120) else: return expr"
            },
            {
                "url": 3339,
                "code": "def print(cls, *args, **kwargs): # pylint: disable=protected-access with _shared._PRINT_LOCK: print(*args, **kwargs) _sys.stdout.flush()"
            },
            {
                "url": 2904,
                "code": "def Print(self): for val, prob in sorted(self.d.iteritems()): print(val, prob)"
            },
            {
                "url": 2227,
                "code": "def prettyprint(d): print(json.dumps(d, sort_keys=True, indent=4, separators=(\",\" , \": \")))"
            }
        ],
        "url": 5626
    },
    {
        "nl_input": "python query string parsing",
        "code_input": [
            {
                "url": 2201,
                "code": "def parse_query_string(query): result = {} qparts = query.split('&') for item in qparts: key, value = item.split('=') key = key.strip() value = value.strip() result[key] = unquote_plus(value) return result"
            },
            {
                "url": 4581,
                "code": "def get_querystring(uri): parts = urlparse.urlsplit(uri) return urlparse.parse_qs(parts.query)"
            },
            {
                "url": 601,
                "code": "def parse_querystring(self, req, name, field): return core.get_value(req.args, name, field)"
            },
            {
                "url": 191,
                "code": "def dict_to_querystring(dictionary): s = u\"\" for d in dictionary.keys(): s = unicode.format(u\"{0}{1}={2}&\", s, d, dictionary[d]) return s[:-1]"
            },
            {
                "url": 2540,
                "code": "def urlencoded(body, charset='ascii', **kwargs): return parse_query_string(text(body, charset=charset), False)"
            },
            {
                "url": 1449,
                "code": "def strip_querystring(url): p = six.moves.urllib.parse.urlparse(url) return p.scheme + \"://\" + p.netloc + p.path"
            },
            {
                "url": 1747,
                "code": "def parse_code(url): result = urlparse(url) query = parse_qs(result.query) return query['code']"
            },
            {
                "url": 2871,
                "code": "def filter_query_string(query): return '&'.join([q for q in query.split('&') if not (q.startswith('_k=') or q.startswith('_e=') or q.startswith('_s'))])"
            },
            {
                "url": 1315,
                "code": "def get_url_args(url): url_data = urllib.parse.urlparse(url) arg_dict = urllib.parse.parse_qs(url_data.query) return arg_dict"
            },
            {
                "url": 4682,
                "code": "def coords_from_query(query): try: coords = json.loads(query) except ValueError: vals = re.split(r'[,\\s]+', query.strip()) coords = [float(v) for v in vals] return tuple(coords[:2])"
            },
            {
                "url": 3869,
                "code": "def get_path_from_query_string(req): if req.args.get('path') is None: raise exceptions.UserError('Path not found in query string') return req.args.get('path')"
            },
            {
                "url": 2555,
                "code": "def filter_query(s): matches = re.findall(r'(?:\"([^\"]*)\")|([^\"]*)', s) result_quoted = [t[0].strip() for t in matches if t[0]] result_unquoted = [t[1].strip() for t in matches if t[1]] return result_quoted, result_unquoted"
            },
            {
                "url": 2826,
                "code": "def prepare_query_params(**kwargs): return [ (sub_key, sub_value) for key, value in kwargs.items() for sub_key, sub_value in expand(value, key) if sub_value is not None ]"
            },
            {
                "url": 1464,
                "code": "def parse_form(self, req, name, field): return get_value(req.body_arguments, name, field)"
            },
            {
                "url": 2761,
                "code": "def to_query_parameters(parameters): if parameters is None: return [] if isinstance(parameters, collections_abc.Mapping): return to_query_parameters_dict(parameters) return to_query_parameters_list(parameters)"
            }
        ],
        "url": 2540
    },
    {
        "nl_input": "cycle through a folder of images python",
        "code_input": [
            {
                "url": 2248,
                "code": "def each_img(dir_path): for fname in os.listdir(dir_path): if fname.endswith('.jpg') or fname.endswith('.png') or fname.endswith('.bmp'): yield fname"
            },
            {
                "url": 4868,
                "code": "def each_img(img_dir): for fname in utils.each_img(img_dir): fname = os.path.join(img_dir, fname) yield cv.imread(fname), fname"
            },
            {
                "url": 3908,
                "code": "def get_all_files(folder): for path, dirlist, filelist in os.walk(folder): for fn in filelist: yield op.join(path, fn)"
            },
            {
                "url": 4368,
                "code": "def search_script_directory(self, path): for subdir, dirs, files in os.walk(path): for file_name in files: if file_name.endswith(\".py\"): self.search_script_file(subdir, file_name)"
            },
            {
                "url": 665,
                "code": "def directory_files(path): for entry in os.scandir(path): if not entry.name.startswith('.') and entry.is_file(): yield entry.name"
            },
            {
                "url": 2643,
                "code": "def recursively_get_files_from_directory(directory): return [ os.path.join(root, filename) for root, directories, filenames in os.walk(directory) for filename in filenames ]"
            },
            {
                "url": 2992,
                "code": "def get_files(dir_name): return [(os.path.join('.', d), [os.path.join(d, f) for f in files]) for d, _, files in os.walk(dir_name)]"
            },
            {
                "url": 2459,
                "code": "def listfolderpath(p): for entry in scandir.scandir(p): if entry.is_dir(): yield entry.path"
            },
            {
                "url": 673,
                "code": "def join_images(img_files, out_file): images = [PIL.Image.open(f) for f in img_files] joined = PIL.Image.new( 'RGB', (sum(i.size[0] for i in images), max(i.size[1] for i in images)) ) left = 0 for img in images: joined.paste(im=img, box=(left, 0)) left = left + img.size[0] joined.save(out_file)"
            },
            {
                "url": 860,
                "code": "def print_images(self, *printable_images): printable_image = reduce(lambda x, y: x.append(y), list(printable_images)) self.print_image(printable_image)"
            },
            {
                "url": 2576,
                "code": "def clean_py_files(path): for dirname, subdirlist, filelist in os.walk(path): for f in filelist: if f.endswith('py'): os.remove(os.path.join(dirname, f))"
            },
            {
                "url": 2257,
                "code": "def read_folder(directory): res = [] for filename in os.listdir(directory): with io.open(os.path.join(directory, filename), encoding=\"utf-8\") as f: content = f.read() res.append(content) return res"
            },
            {
                "url": 2870,
                "code": "def list_files(directory): return [f for f in pathlib.Path(directory).iterdir() if f.is_file() and not f.name.startswith('.')]"
            },
            {
                "url": 4493,
                "code": "def imagemagick(color_count, img, magick_command): flags = [\"-resize\", \"25%\", \"-colors\", str(color_count), \"-unique-colors\", \"txt:-\"] img += \"[0]\" return subprocess.check_output([*magick_command, img, *flags]).splitlines()"
            },
            {
                "url": 3743,
                "code": "def globlookup(pattern, root): for subdir, dirnames, filenames in os.walk(root): d = subdir[len(root) + 1:] files = (os.path.join(d, f) for f in filenames) for f in fnmatch.filter(files, pattern): yield f"
            }
        ],
        "url": 2248
    },
    {
        "nl_input": "check if a date is valid python",
        "code_input": [
            {
                "url": 1195,
                "code": "def _validate_date_str(str_): if not str_: return None # Convert to datetime so we can validate it's a real date that exists then # convert it back to the string. try: date = datetime.strptime(str_, DATE_FMT) except ValueError: msg = 'Invalid date format, should be YYYY-MM-DD' raise argparse.ArgumentTypeError(msg) return date.strftime(DATE_FMT)"
            },
            {
                "url": 5581,
                "code": "def valid_date(x: str) -> bool: try: if x != dt.datetime.strptime(x, DATE_FORMAT).strftime(DATE_FORMAT): raise ValueError return True except ValueError: return False"
            },
            {
                "url": 2764,
                "code": "def _converter(self, value): if not isinstance(value, datetime.date): raise TypeError('{0} is not valid date'.format(value)) return value"
            },
            {
                "url": 218,
                "code": "def is_date(thing): # known date types date_types = (datetime.datetime, datetime.date, DateTime) return isinstance(thing, date_types)"
            },
            {
                "url": 5854,
                "code": "def _parse_date(string: str) -> datetime.date: return datetime.datetime.strptime(string, '%Y-%m-%d').date()"
            },
            {
                "url": 888,
                "code": "def parse_date(s): if isinstance(s, (datetime.datetime, datetime.date)): return s try: from dateutil.parser import parse except ImportError: parse = lambda d: datetime.datetime.strptime(d, \"%Y-%m-%d\") return parse(s)"
            },
            {
                "url": 1700,
                "code": "def string_to_date(value): if isinstance(value, datetime.date): return value return dateutil.parser.parse(value).date()"
            },
            {
                "url": 6109,
                "code": "def datetime_is_iso(date_str): try: if len(date_str) > 10: dt = isodate.parse_datetime(date_str) else: dt = isodate.parse_date(date_str) return True, [] except: # Any error qualifies as not ISO format return False, ['Datetime provided is not in a valid ISO 8601 format']"
            },
            {
                "url": 2020,
                "code": "def get_date(date): if type(date) is str: return datetime.strptime(date, '%Y-%m-%d').date() else: return date"
            },
            {
                "url": 2523,
                "code": "def _parse(self, date_str, format='%Y-%m-%d'): rv = pd.to_datetime(date_str, format=format) if hasattr(rv, 'to_pydatetime'): rv = rv.to_pydatetime() return rv"
            },
            {
                "url": 2045,
                "code": "def is_date_type(cls): if not isinstance(cls, type): return False return issubclass(cls, date) and not issubclass(cls, datetime)"
            },
            {
                "url": 5950,
                "code": "def iso_string_to_python_datetime( isostring: str) -> Optional[datetime.datetime]: if not isostring: return None # if you parse() an empty string, you get today's date return dateutil.parser.parse(isostring)"
            },
            {
                "url": 3716,
                "code": "def Date(value): from datetime import datetime try: return datetime(*reversed([int(val) for val in value.split('/')])) except Exception as err: raise argparse.ArgumentTypeError(\"invalid date '%s'\" % value)"
            },
            {
                "url": 154,
                "code": "def _datetime_to_date(arg): _arg = parse(arg) if isinstance(_arg, datetime.datetime): _arg = _arg.date() return _arg"
            },
            {
                "url": 4752,
                "code": "def _date_to_json(value): if isinstance(value, datetime.date): value = value.isoformat() return value"
            }
        ],
        "url": 5581
    },
    {
        "nl_input": "python spherical bessel functions",
        "code_input": [
            {
                "url": 3223,
                "code": "def sbessely(x, N): out = np.zeros(N, dtype=np.float64) out[0] = -np.cos(x) / x out[1] = -np.cos(x) / (x ** 2) - np.sin(x) / x for n in xrange(2, N): out[n] = ((2.0 * n - 1.0) / x) * out[n - 1] - out[n - 2] return out"
            },
            {
                "url": 1542,
                "code": "def Bernstein(n, k): coeff = binom(n, k) def _bpoly(x): return coeff * x ** k * (1 - x) ** (n - k) return _bpoly"
            },
            {
                "url": 1008,
                "code": "def Fsphere(q, R): return 4 * np.pi / q ** 3 * (np.sin(q * R) - q * R * np.cos(q * R))"
            },
            {
                "url": 881,
                "code": "def haversine(x): y = .5*x y = np.sin(y) return y*y"
            },
            {
                "url": 558,
                "code": "def sine_wave(frequency): xs = tf.reshape(tf.range(_samples(), dtype=tf.float32), [1, _samples(), 1]) ts = xs / FLAGS.sample_rate return tf.sin(2 * math.pi * frequency * ts)"
            },
            {
                "url": 5159,
                "code": "def sinwave(n=4,inc=.25): x=np.arange(-n,n,inc) y=np.arange(-n,n,inc) X,Y=np.meshgrid(x,y) R = np.sqrt(X**2 + Y**2) Z = np.sin(R)/(.5*R) return pd.DataFrame(Z,index=x,columns=y)"
            },
            {
                "url": 5196,
                "code": "def stft(func=None, **kwparams): from numpy.fft import fft, ifft return stft.base(transform=fft, inverse_transform=ifft)(func, **kwparams)"
            },
            {
                "url": 4662,
                "code": "def gaussian_distribution(mean, stdev, num_pts=50): xstart = mean - (4.0 * stdev) xend = mean + (4.0 * stdev) x = np.linspace(xstart,xend,num_pts) y = (1.0/np.sqrt(2.0*np.pi*stdev*stdev)) * np.exp(-1.0 * ((x - mean)**2)/(2.0*stdev*stdev)) return x,y"
            },
            {
                "url": 1792,
                "code": "def stft(func=None, **kwparams): from numpy.fft import fft, ifft ifft_r = lambda *args: ifft(*args).real return stft.base(transform=fft, inverse_transform=ifft_r)(func, **kwparams)"
            },
            {
                "url": 2855,
                "code": "def deskew(S): x = np.zeros(3) x[0] = S[2,1] x[1] = S[0,2] x[2] = S[1,0] return x"
            },
            {
                "url": 828,
                "code": "def compute(args): x, y, params = args return x, y, mandelbrot(x, y, params)"
            },
            {
                "url": 4093,
                "code": "def euler(self): e_xyz = transformations.euler_from_matrix(self.rotation, 'sxyz') return np.array([180.0 / np.pi * a for a in e_xyz])"
            },
            {
                "url": 280,
                "code": "def fft_spectrum(frames, fft_points=512): SPECTRUM_VECTOR = np.fft.rfft(frames, n=fft_points, axis=-1, norm=None) return np.absolute(SPECTRUM_VECTOR)"
            },
            {
                "url": 4556,
                "code": "def EvalPoissonPmf(k, lam): # don't use the scipy function (yet). for lam=0 it returns NaN; # should be 0.0 # return scipy.stats.poisson.pmf(k, lam) return lam ** k * math.exp(-lam) / math.factorial(k)"
            },
            {
                "url": 3161,
                "code": "def Exponential(x, a, tau, y0): return np.exp(x / tau) * a + y0"
            }
        ],
        "url": 3223
    },
    {
        "nl_input": "how to check a file is empty in python",
        "code_input": [
            {
                "url": 5834,
                "code": "def isfile_notempty(inputfile: str) -> bool: try: return isfile(inputfile) and getsize(inputfile) > 0 except TypeError: raise TypeError('inputfile is not a valid type')"
            },
            {
                "url": 3323,
                "code": "def isemptyfile(filepath): exists = os.path.exists(safepath(filepath)) if exists: filesize = os.path.getsize(safepath(filepath)) return filesize == 0 else: return False"
            },
            {
                "url": 286,
                "code": "def file_empty(fp): # for python 2 we need to use a homemade peek() if six.PY2: contents = fp.read() fp.seek(0) return not bool(contents) else: return not fp.peek()"
            },
            {
                "url": 5731,
                "code": "def file_exists(fname): try: return fname and os.path.exists(fname) and os.path.getsize(fname) > 0 except OSError: return False"
            },
            {
                "url": 2931,
                "code": "def is_valid_file(parser, arg): arg = os.path.abspath(arg) if not os.path.exists(arg): parser.error(\"The file %s does not exist!\" % arg) else: return arg"
            },
            {
                "url": 4496,
                "code": "def is_valid_file(parser,arg): if not os.path.exists(arg): parser.error(\"File %s not found\"%arg) else: return arg"
            },
            {
                "url": 2959,
                "code": "def _file_exists(path, filename): return os.path.isfile(os.path.join(path, filename))"
            },
            {
                "url": 2011,
                "code": "def _file_and_exists(val, input_files): return ((os.path.exists(val) and os.path.isfile(val)) or val in input_files)"
            },
            {
                "url": 5808,
                "code": "def valid_file(path: str) -> bool: path = Path(path).expanduser() log.debug(\"checking if %s is a valid file\", path) return path.exists() and path.is_file()"
            },
            {
                "url": 757,
                "code": "def is_non_empty_string(input_string): try: if not input_string.strip(): raise ValueError() except AttributeError as error: raise TypeError(error) return True"
            },
            {
                "url": 5672,
                "code": "def _cnx_is_empty(in_file): with open(in_file) as in_handle: for i, line in enumerate(in_handle): if i > 0: return False return True"
            },
            {
                "url": 3646,
                "code": "def _one_exists(input_files): for f in input_files: if os.path.exists(f): return True return False"
            },
            {
                "url": 5533,
                "code": "def is_file_exists_error(e): if six.PY3: return isinstance(e, FileExistsError) # noqa: F821 else: return isinstance(e, OSError) and e.errno == 17"
            },
            {
                "url": 1795,
                "code": "def check_empty_dict(GET_dict): empty = True for k, v in GET_dict.items(): # Don't disable on p(age) or 'all' GET param if v and k != 'p' and k != 'all': empty = False return empty"
            },
            {
                "url": 3256,
                "code": "def _check_format(file_path, content): # TODO: replace with JSON schema validation if not content: # testcase file content is empty err_msg = u\"Testcase file content is empty: {}\".format(file_path) logger.log_error(err_msg) raise exceptions.FileFormatError(err_msg) elif not isinstance(content, (list, dict)): # testcase file content does not match testcase format err_msg = u\"Testcase file content format invalid: {}\".format(file_path) logger.log_error(err_msg) raise exceptions.FileFormatError(err_msg)"
            }
        ],
        "url": 5672
    },
    {
        "nl_input": "python stop process multiprocessing",
        "code_input": [
            {
                "url": 4659,
                "code": "def stop(self, timeout=None): self.stopping = True for process in list(self.processes): self.stop_process(process, timeout=timeout)"
            },
            {
                "url": 2468,
                "code": "def stop_process(self): self._process.terminate() if not self._process.waitForFinished(100): self._process.kill()"
            },
            {
                "url": 2327,
                "code": "def kill_mprocess(process): if process and proc_alive(process): process.terminate() process.communicate() return not proc_alive(process)"
            },
            {
                "url": 2138,
                "code": "def stop(self): try: self.shutdown() except (PyMongoError, ServersError) as exc: logger.info(\"Killing %s with signal, shutdown command failed: %r\", self.name, exc) return process.kill_mprocess(self.proc)"
            },
            {
                "url": 2244,
                "code": "def stop(pid): if psutil.pid_exists(pid): try: p = psutil.Process(pid) p.kill() except Exception: pass"
            },
            {
                "url": 2469,
                "code": "def stop(self): # unsetup_fuse() self.fuse_process.teardown() for uuid in self.processes: self.processes[uuid].terminate()"
            },
            {
                "url": 4376,
                "code": "async def stop(self): # negate pid so that signals apply to process group pgid = -self.process.pid try: os.kill(pgid, signal.SIGTERM) await asyncio.sleep(1) os.kill(pgid, signal.SIGKILL) except (OSError, ProcessLookupError): return"
            },
            {
                "url": 4378,
                "code": "def kill_all(self, kill_signal, kill_shell=False): for key in self.processes.keys(): self.kill_process(key, kill_signal, kill_shell)"
            },
            {
                "url": 2277,
                "code": "def kill(self): if self.process: self.process.kill() self.process.wait()"
            },
            {
                "url": 785,
                "code": "def terminate(self): for t in self._threads: t.quit() self._thread = [] self._workers = []"
            },
            {
                "url": 1761,
                "code": "def parallel(processes, threads): pool = multithread(threads) pool.map(run_process, processes) pool.close() pool.join()"
            },
            {
                "url": 1997,
                "code": "async def terminate(self): self.proc.terminate() await asyncio.wait_for(self.proc.wait(), self.kill_delay) if self.proc.returncode is None: self.proc.kill() await self.proc.wait() await super().terminate()"
            },
            {
                "url": 3126,
                "code": "def close(self): if self._subprocess is not None: os.killpg(self._subprocess.pid, signal.SIGTERM) self._subprocess = None"
            },
            {
                "url": 2728,
                "code": "def process_kill(pid, sig=None): sig = sig or signal.SIGTERM os.kill(pid, sig)"
            },
            {
                "url": 3761,
                "code": "def deinit(self): # Clean up after ourselves self._process.terminate() procs.remove(self._process) self._mq.remove() queues.remove(self._mq)"
            }
        ],
        "url": 4659
    },
    {
        "nl_input": "python make sure all words are separated by a single space",
        "code_input": [
            {
                "url": 1546,
                "code": "def split_into_words(s): s = re.sub(r\"\\W+\", \" \", s) s = re.sub(r\"[_0-9]+\", \" \", s) return s.split()"
            },
            {
                "url": 5571,
                "code": "def split(text: str) -> List[str]: return [word for word in SEPARATOR.split(text) if word.strip(' \\t')]"
            },
            {
                "url": 1292,
                "code": "def split_into_sentences(s): s = re.sub(r\"\\s+\", \" \", s) s = re.sub(r\"[\\\\.\\\\?\\\\!]\", \"\\n\", s) return s.split(\"\\n\")"
            },
            {
                "url": 1160,
                "code": "def split_on(s, sep=\" \"): pattern = '''((?:[^%s\"']|\"[^\"]*\"|'[^']*')+)''' % sep return [_strip_speechmarks(t) for t in re.split(pattern, s)[1::2]]"
            },
            {
                "url": 5519,
                "code": "def split_long_sentence(sentence, words_per_line): words = sentence.split(' ') split_sentence = '' for i in range(len(words)): split_sentence = split_sentence + words[i] if (i+1) % words_per_line == 0: split_sentence = split_sentence + '\\n' elif i != len(words) - 1: split_sentence = split_sentence + \" \" return split_sentence"
            },
            {
                "url": 1146,
                "code": "def split_strings_in_list_retain_spaces(orig_list): temp_list = list() for line in orig_list: line_split = __re.split(r'(\\s+)', line) temp_list.append(line_split) return temp_list"
            },
            {
                "url": 2261,
                "code": "def extract_words(lines): for line in lines: for word in re.findall(r\"\\w+\", line): yield word"
            },
            {
                "url": 5698,
                "code": "def multi_split(s, split): # type: (S, Iterable[S]) -> List[S] for r in split: s = s.replace(r, \"|\") return [i for i in s.split(\"|\") if len(i) > 0]"
            },
            {
                "url": 392,
                "code": "def _split_comma_separated(string): return set(text.strip() for text in string.split(',') if text.strip())"
            },
            {
                "url": 3082,
                "code": "def tokenize_words(self, text): return [ self.strip_punctuation(word) for word in text.split(' ') if self.strip_punctuation(word) ]"
            },
            {
                "url": 2339,
                "code": "def sanitize_word(s): s = re.sub('[^\\w-]+', '_', s) s = re.sub('__+', '_', s) return s.strip('_')"
            },
            {
                "url": 1838,
                "code": "def unpunctuate(s, *, char_blacklist=string.punctuation): # remove punctuation s = \"\".join(c for c in s if c not in char_blacklist) # remove consecutive spaces return \" \".join(filter(None, s.split(\" \")))"
            },
            {
                "url": 1110,
                "code": "def split_comma_argument(comma_sep_str): terms = [] for term in comma_sep_str.split(','): if term: terms.append(term) return terms"
            },
            {
                "url": 6168,
                "code": "def remove_blank_spaces(syllables: List[str]) -> List[str]: cleaned = [] for syl in syllables: if syl == \" \" or syl == '': pass else: cleaned.append(syl) return cleaned"
            },
            {
                "url": 2423,
                "code": "def strip_spaces(value, sep=None, join=True): value = value.strip() value = [v.strip() for v in value.split(sep)] join_sep = sep or ' ' return join_sep.join(value) if join else value"
            }
        ],
        "url": 2339
    },
    {
        "nl_input": "making a multidimensional array of only 1 in python",
        "code_input": [
            {
                "url": 2938,
                "code": "def make_2d(ary): dim_0, *_ = np.atleast_1d(ary).shape return ary.reshape(dim_0, -1, order=\"F\")"
            },
            {
                "url": 5850,
                "code": "def _create_empty_array(self, frames, always_2d, dtype): import numpy as np if always_2d or self.channels > 1: shape = frames, self.channels else: shape = frames, return np.empty(shape, dtype, order='C')"
            },
            {
                "url": 1053,
                "code": "def out_shape_from_array(arr): arr = np.asarray(arr) if arr.ndim == 1: return arr.shape else: return (arr.shape[1],)"
            },
            {
                "url": 3823,
                "code": "def _indexes(arr): myarr = np.array(arr) if myarr.ndim == 1: return list(range(len(myarr))) elif myarr.ndim == 2: return tuple(itertools.product(list(range(arr.shape[0])), list(range(arr.shape[1])))) else: raise NotImplementedError('Only supporting arrays of dimension 1 and 2 as yet.')"
            },
            {
                "url": 5815,
                "code": "def to_0d_array(value: Any) -> np.ndarray: if np.isscalar(value) or (isinstance(value, np.ndarray) and value.ndim == 0): return np.array(value) else: return to_0d_object_array(value)"
            },
            {
                "url": 2080,
                "code": "def get_dimension_array(array): if all(isinstance(el, list) for el in array): result = [len(array), len(max([x for x in array], key=len,))] # elif array and isinstance(array, list): else: result = [len(array), 1] return result"
            },
            {
                "url": 4828,
                "code": "def into2dBlocks(arr, n0, n1): s0, s1 = arr.shape b = blockshaped(arr, s0// n0, s1// n1) return b.reshape(n0, n1, *b.shape[1:])"
            },
            {
                "url": 423,
                "code": "def array_dim(arr): dim = [] while True: try: dim.append(len(arr)) arr = arr[0] except TypeError: return dim"
            },
            {
                "url": 1870,
                "code": "def _to_array(value): if isinstance(value, (tuple, list)): return array(value) elif isinstance(value, (float, int)): return np.float64(value) else: return value"
            },
            {
                "url": 3199,
                "code": "def _split_arrs(array_2d, slices): if len(array_2d) == 0: return np.empty(0, dtype=np.object) rtn = np.empty(len(slices) + 1, dtype=np.object) start = 0 for i, s in enumerate(slices): rtn[i] = array_2d[start:s] start = s rtn[-1] = array_2d[start:] return rtn"
            },
            {
                "url": 5822,
                "code": "def isarray(array, test, dim=2): if dim > 1: return all(isarray(array[i], test, dim - 1) for i in range(len(array))) return all(test(i) for i in array)"
            },
            {
                "url": 3833,
                "code": "def unpack2D(_x): _x = np.atleast_2d(_x) x = _x[:, 0] y = _x[:, 1] return x, y"
            },
            {
                "url": 1820,
                "code": "def flatten_array(grid): grid = [grid[i][j] for i in range(len(grid)) for j in range(len(grid[i]))] while type(grid[0]) is list: grid = flatten_array(grid) return grid"
            },
            {
                "url": 856,
                "code": "def A(*a): return np.array(a[0]) if len(a)==1 else [np.array(o) for o in a]"
            },
            {
                "url": 1798,
                "code": "def _check_2d_shape(X): if X.dtype.names is None and len(X.shape) != 2: raise ValueError('X needs to be 2-dimensional, not ' '{}-dimensional.'.format(len(X.shape)))"
            }
        ],
        "url": 856
    },
    {
        "nl_input": "python initialize variable of an object",
        "code_input": [
            {
                "url": 2595,
                "code": "def _add(self, codeobj): assert isinstance(codeobj, CodeVariable) self.variables.append(codeobj)"
            },
            {
                "url": 2926,
                "code": "def assign_to(self, obj): obj.x = self.x obj.y = self.y"
            },
            {
                "url": 3253,
                "code": "def sg_init(sess): r # initialize variables sess.run(tf.group(tf.global_variables_initializer(), tf.local_variables_initializer()))"
            },
            {
                "url": 61,
                "code": "def create_object(cls, members): obj = cls.__new__(cls) obj.__dict__ = members return obj"
            },
            {
                "url": 1793,
                "code": "def getvariable(name): import inspect fr = inspect.currentframe() try: while fr: fr = fr.f_back vars = fr.f_locals if name in vars: return vars[name] except: pass return None"
            },
            {
                "url": 4601,
                "code": "def get_variables(args): variables_dict = {} if args.variables: for var in args.variables: words = var.split('=') variables_dict[words[0]] = words[1] return variables_dict"
            },
            {
                "url": 44,
                "code": "def populate_obj(obj, attrs): for k, v in attrs.iteritems(): setattr(obj, k, v)"
            },
            {
                "url": 3654,
                "code": "def vars_(self): return [x for x in self[self.current_scope].values() if x.class_ == CLASS.var]"
            },
            {
                "url": 6121,
                "code": "def call_fset(self, obj, value) -> None: vars(obj)[self.name] = self.fset(obj, value)"
            },
            {
                "url": 4384,
                "code": "def add_input_variable(self, var): assert(isinstance(var, Variable)) self.input_variable_list.append(var)"
            },
            {
                "url": 5431,
                "code": "def open_store_variable(self, name, var): data = indexing.LazilyOuterIndexedArray(CDMArrayWrapper(name, self)) return Variable(var.dimensions, data, {a: getattr(var, a) for a in var.ncattrs()})"
            },
            {
                "url": 128,
                "code": "def add_to_js(self, name, var): frame = self.page().mainFrame() frame.addToJavaScriptWindowObject(name, var)"
            },
            {
                "url": 1697,
                "code": "def format_vars(args): variables = [] for key, value in args.items(): if value: variables += ['{0}={1}'.format(key, value)] return variables"
            },
            {
                "url": 3386,
                "code": "def setobjattr(obj, key, value): try: setattr(obj, key, int(value)) except ValueError: try: setattr(obj, key, float(value)) except ValueError: # string if not number try: setattr(obj, key, str(value)) except UnicodeEncodeError: setattr(obj, key, value)"
            },
            {
                "url": 2658,
                "code": "def set_label ( self, object, label ): label_name = self.label if label_name[:1] != '=': xsetattr( object, label_name, label )"
            }
        ],
        "url": 4075
    },
    {
        "nl_input": "python elasticsearch limit results",
        "code_input": [
            {
                "url": 6025,
                "code": "def bulk_load_docs(es, docs): chunk_size = 200 try: results = elasticsearch.helpers.bulk(es, docs, chunk_size=chunk_size) log.debug(f\"Elasticsearch documents loaded: {results[0]}\") # elasticsearch.helpers.parallel_bulk(es, terms, chunk_size=chunk_size, thread_count=4) if len(results[1]) > 0: log.error(\"Bulk load errors {}\".format(results)) except elasticsearch.ElasticsearchException as e: log.error(\"Indexing error: {}\\n\".format(e))"
            },
            {
                "url": 3540,
                "code": "def index_all(self, index_name): oks = 0 notoks = 0 for ok, item in streaming_bulk( self.es_client, self._iter_documents(index_name) ): if ok: oks += 1 else: notoks += 1 logging.info( \"Import results: %d ok, %d not ok\", oks, notoks )"
            },
            {
                "url": 240,
                "code": "def update_index(index): logger.info(\"Updating search index: '%s'\", index) client = get_client() responses = [] for model in get_index_models(index): logger.info(\"Updating search index model: '%s'\", model.search_doc_type) objects = model.objects.get_search_queryset(index).iterator() actions = bulk_actions(objects, index=index, action=\"index\") response = helpers.bulk(client, actions, chunk_size=get_setting(\"chunk_size\")) responses.append(response) return responses"
            },
            {
                "url": 2708,
                "code": "def items(self, limit=0): i = ItemIterator(self.iterator) i.limit = limit return i"
            },
            {
                "url": 4896,
                "code": "def get_index(self, bucket, index, startkey, endkey=None, return_terms=None, max_results=None, continuation=None, timeout=None, term_regex=None): raise NotImplementedError"
            },
            {
                "url": 4542,
                "code": "def can_elasticsearch(record): search = request._methodview.search_class() search = search.get_record(str(record.id)) return search.count() == 1"
            },
            {
                "url": 4271,
                "code": "def paginate(self, request, offset=0, limit=None): return self.collection.offset(offset).limit(limit), self.collection.count()"
            },
            {
                "url": 2818,
                "code": "def all_documents(index=INDEX_NAME): query = { 'query': { 'match_all': {} } } for result in raw_query(query, index=index): yield result"
            },
            {
                "url": 4543,
                "code": "def raw(self): es = self.get_es() params = dict(self.query_params) mlt_fields = self.mlt_fields or params.pop('mlt_fields', []) body = self.s.build_search() if self.s else '' hits = es.mlt( index=self.index, doc_type=self.doctype, id=self.id, mlt_fields=mlt_fields, body=body, **params) log.debug(hits) return hits"
            },
            {
                "url": 330,
                "code": "def bulk_query(self, query, *multiparams): with self.get_connection() as conn: conn.bulk_query(query, *multiparams)"
            },
            {
                "url": 1765,
                "code": "def index(obj, index=INDEX_NAME, doc_type=DOC_TYPE): doc = to_dict(obj) if doc is None: return id = doc.pop('id') return es_conn.index(index, doc_type, doc, id=id)"
            },
            {
                "url": 3712,
                "code": "def delete_index(index): logger.info(\"Deleting search index: '%s'\", index) client = get_client() return client.indices.delete(index=index)"
            },
            {
                "url": 4135,
                "code": "def find_mapping(es_url, index): mapping = None backend = find_perceval_backend(es_url, index) if backend: mapping = backend.get_elastic_mappings() if mapping: logging.debug(\"MAPPING FOUND:\\n%s\", json.dumps(json.loads(mapping['items']), indent=True)) return mapping"
            },
            {
                "url": 654,
                "code": "def batch(items, size): return [items[x:x + size] for x in xrange(0, len(items), size)]"
            },
            {
                "url": 448,
                "code": "def clear_es(): # TODO: should receive a catalog slug. ESHypermap.es.indices.delete(ESHypermap.index_name, ignore=[400, 404]) LOGGER.debug('Elasticsearch: Index cleared')"
            }
        ],
        "url": 1953
    },
    {
        "nl_input": "how to force exit python without raise",
        "code_input": [
            {
                "url": 1961,
                "code": "def fast_exit(code): sys.stdout.flush() sys.stderr.flush() os._exit(code)"
            },
            {
                "url": 74,
                "code": "def exit(exit_code=0): r core.processExitHooks() if state.isExitHooked and not hasattr(sys, 'exitfunc'): # The function is called from the exit hook sys.stderr.flush() sys.stdout.flush() os._exit(exit_code) #pylint: disable=W0212 sys.exit(exit_code)"
            },
            {
                "url": 6074,
                "code": "def _exit(self, status_code): # If there are active threads still running infinite loops, sys.exit # won't kill them but os._exit will. os._exit skips calling cleanup # handlers, flushing stdio buffers, etc. exit_func = os._exit if threading.active_count() > 1 else sys.exit exit_func(status_code)"
            },
            {
                "url": 2542,
                "code": "def exit(self): if self.confirm_exit: if self.ask_yes_no('Do you really want to exit ([y]/n)?','y'): self.ask_exit() else: self.ask_exit()"
            },
            {
                "url": 952,
                "code": "def _quit(self, *args): self.logger.warn('Bye!') sys.exit(self.exit())"
            },
            {
                "url": 5899,
                "code": "def Exit(msg, code=1): print >> sys.stderr, msg sys.exit(code)"
            },
            {
                "url": 537,
                "code": "def safe_exit(output): try: sys.stdout.write(output) sys.stdout.flush() except IOError: pass"
            },
            {
                "url": 1064,
                "code": "def call_and_exit(self, cmd, shell=True): sys.exit(subprocess.call(cmd, shell=shell))"
            },
            {
                "url": 2210,
                "code": "def exit_and_fail(self, msg=None, out=None): self.exit(result=PANTS_FAILED_EXIT_CODE, msg=msg, out=out)"
            },
            {
                "url": 334,
                "code": "def go_to_background(): try: if os.fork(): sys.exit() except OSError as errmsg: LOGGER.error('Fork failed: {0}'.format(errmsg)) sys.exit('Fork failed')"
            },
            {
                "url": 2919,
                "code": "def fail(message=None, exit_status=None): print('Error:', message, file=sys.stderr) sys.exit(exit_status or 1)"
            },
            {
                "url": 76,
                "code": "def reloader_thread(softexit=False): while RUN_RELOADER: if code_changed(): # force reload if softexit: sys.exit(3) else: os._exit(3) time.sleep(1)"
            },
            {
                "url": 859,
                "code": "def quit(self): self.script.LOG.warn(\"Abort due to user choice!\") sys.exit(self.QUIT_RC)"
            },
            {
                "url": 2786,
                "code": "def install_rpm_py(): python_path = sys.executable cmd = '{0} install.py'.format(python_path) exit_status = os.system(cmd) if exit_status != 0: raise Exception('Command failed: {0}'.format(cmd))"
            },
            {
                "url": 3859,
                "code": "def nothread_quit(self, arg): self.debugger.core.stop() self.debugger.core.execution_status = 'Quit command' raise Mexcept.DebuggerQuit"
            }
        ],
        "url": 3086
    },
    {
        "nl_input": "python weak reference to bound method",
        "code_input": [
            {
                "url": 1470,
                "code": "def __is_bound_method(method): if not(hasattr(method, \"__func__\") and hasattr(method, \"__self__\")): return False # Bound methods have a __self__ attribute pointing to the owner instance return six.get_method_self(method) is not None"
            },
            {
                "url": 4473,
                "code": "def __call__(self, obj, *arg, **kw): bound_method = self._manager.__get__(obj, obj.__class__) return bound_method(*arg, **kw)"
            },
            {
                "url": 332,
                "code": "def __set__(self, instance, value): self.map[id(instance)] = (weakref.ref(instance), value)"
            },
            {
                "url": 2312,
                "code": "def __get__(self, obj, objtype): if not self.is_method: self.is_method = True return functools.partial(self.__call__, obj)"
            },
            {
                "url": 1683,
                "code": "def POINTER(obj): p = ctypes.POINTER(obj) if not isinstance(p.from_param, classmethod): def from_param(cls, x): if x is None: return cls() else: return x p.from_param = classmethod(from_param) return p"
            },
            {
                "url": 1374,
                "code": "def FindMethodByName(self, name): for method in self.methods: if name == method.name: return method return None"
            },
            {
                "url": 1321,
                "code": "def static_method(cls, f): setattr(cls, f.__name__, staticmethod(f)) return f"
            },
            {
                "url": 1550,
                "code": "def method_double_for(self, method_name): if method_name not in self._method_doubles: self._method_doubles[method_name] = MethodDouble(method_name, self._target) return self._method_doubles[method_name]"
            },
            {
                "url": 635,
                "code": "def method(func): attr = abc.abstractmethod(func) attr.__imethod__ = True return attr"
            },
            {
                "url": 4389,
                "code": "def attr_cache_clear(self): node = extract_node() return BoundMethod(proxy=node, bound=self._instance.parent.scope())"
            },
            {
                "url": 835,
                "code": "def _synced(method, self, args, kwargs): with self._lock: return method(*args, **kwargs)"
            },
            {
                "url": 1182,
                "code": "def safe_call(cls, method, *args): return cls.call(method, *args, safe=True)"
            },
            {
                "url": 5445,
                "code": "def get_form_bound_field(form, field_name): field = form.fields[field_name] field = field.get_bound_field(form, field_name) return field"
            },
            {
                "url": 5544,
                "code": "def method_caller(method_name, *args, **kwargs): def call_method(target): func = getattr(target, method_name) return func(*args, **kwargs) return call_method"
            },
            {
                "url": 4311,
                "code": "def RemoveMethod(self, function): self.added_methods = [dm for dm in self.added_methods if not dm.method is function]"
            }
        ],
        "url": 4389
    },
    {
        "nl_input": "calling index iterable python",
        "code_input": [
            {
                "url": 1757,
                "code": "def items(iterable): if hasattr(iterable, 'iteritems'): return (p for p in iterable.iteritems()) elif hasattr(iterable, 'items'): return (p for p in iterable.items()) else: return (p for p in enumerate(iterable))"
            },
            {
                "url": 2047,
                "code": "def stop_at(iterable, idx): for i, item in enumerate(iterable): if i == idx: return yield item"
            },
            {
                "url": 5615,
                "code": "def iterate_items(dictish): if hasattr(dictish, 'iteritems'): return dictish.iteritems() if hasattr(dictish, 'items'): return dictish.items() return dictish"
            },
            {
                "url": 570,
                "code": "def force_iterable(f): def wrapper(*args, **kwargs): r = f(*args, **kwargs) if hasattr(r, '__iter__'): return r else: return [r] return wrapper"
            },
            {
                "url": 2529,
                "code": "def iteritems(data, **kwargs): return iter(data.items(**kwargs)) if IS_PY3 else data.iteritems(**kwargs)"
            },
            {
                "url": 4204,
                "code": "def _varargs_to_iterable_method(func): def wrapped(self, iterable, **kwargs): return func(self, *iterable, **kwargs) return wrapped"
            },
            {
                "url": 6214,
                "code": "def index(self, item): for i, x in enumerate(self.iter()): if x == item: return i return None"
            },
            {
                "url": 3950,
                "code": "def is_iterable(obj): return ( hasattr(obj, \"__iter__\") and not isinstance(obj, str) and not isinstance(obj, tuple) )"
            },
            {
                "url": 4454,
                "code": "def assert_iter(**kw): for name, value in kw.items(): if not isiter(value): raise TypeError( 'paco: {} must be an iterable object'.format(name))"
            },
            {
                "url": 5821,
                "code": "def getIndex(predicateFn: Callable[[T], bool], items: List[T]) -> int: try: return next(i for i, v in enumerate(items) if predicateFn(v)) except StopIteration: return -1"
            },
            {
                "url": 1613,
                "code": "def is_iterable_of_int(l): r if not is_iterable(l): return False return all(is_int(value) for value in l)"
            },
            {
                "url": 2522,
                "code": "def _is_iterable(item): return isinstance(item, collections.Iterable) and not isinstance(item, six.string_types)"
            },
            {
                "url": 4058,
                "code": "def _iterable_to_varargs_method(func): def wrapped(self, *args, **kwargs): return func(self, args, **kwargs) return wrapped"
            },
            {
                "url": 2976,
                "code": "def is_iterable(value): return isinstance(value, np.ndarray) or isinstance(value, list) or isinstance(value, tuple), value"
            },
            {
                "url": 2617,
                "code": "def ensure_iterable(inst): if isinstance(inst, string_types): return [inst] elif not isinstance(inst, collections.Iterable): return [inst] else: return inst"
            }
        ],
        "url": 2047
    },
    {
        "nl_input": "python datetime maybe undefined",
        "code_input": [
            {
                "url": 5950,
                "code": "def iso_string_to_python_datetime( isostring: str) -> Optional[datetime.datetime]: if not isostring: return None # if you parse() an empty string, you get today's date return dateutil.parser.parse(isostring)"
            },
            {
                "url": 2523,
                "code": "def _parse(self, date_str, format='%Y-%m-%d'): rv = pd.to_datetime(date_str, format=format) if hasattr(rv, 'to_pydatetime'): rv = rv.to_pydatetime() return rv"
            },
            {
                "url": 888,
                "code": "def parse_date(s): if isinstance(s, (datetime.datetime, datetime.date)): return s try: from dateutil.parser import parse except ImportError: parse = lambda d: datetime.datetime.strptime(d, \"%Y-%m-%d\") return parse(s)"
            },
            {
                "url": 218,
                "code": "def is_date(thing): # known date types date_types = (datetime.datetime, datetime.date, DateTime) return isinstance(thing, date_types)"
            },
            {
                "url": 6109,
                "code": "def datetime_is_iso(date_str): try: if len(date_str) > 10: dt = isodate.parse_datetime(date_str) else: dt = isodate.parse_date(date_str) return True, [] except: # Any error qualifies as not ISO format return False, ['Datetime provided is not in a valid ISO 8601 format']"
            },
            {
                "url": 1298,
                "code": "def parse_json_date(value): if not value: return None return datetime.datetime.strptime(value, JSON_DATETIME_FORMAT).replace(tzinfo=pytz.UTC)"
            },
            {
                "url": 5797,
                "code": "def datetime_from_isoformat(value: str): if sys.version_info >= (3, 7): return datetime.fromisoformat(value) return datetime.strptime(value, '%Y-%m-%dT%H:%M:%S.%f')"
            },
            {
                "url": 3093,
                "code": "def to_datetime(value): if value is None: return None if isinstance(value, six.integer_types): return parser.parse(value) return parser.isoparse(value)"
            },
            {
                "url": 1700,
                "code": "def string_to_date(value): if isinstance(value, datetime.date): return value return dateutil.parser.parse(value).date()"
            },
            {
                "url": 2763,
                "code": "def parse_datetime(dt_str, format): t = time.strptime(dt_str, format) return datetime(t[0], t[1], t[2], t[3], t[4], t[5], t[6], pytz.UTC)"
            },
            {
                "url": 5854,
                "code": "def _parse_date(string: str) -> datetime.date: return datetime.datetime.strptime(string, '%Y-%m-%d').date()"
            },
            {
                "url": 1195,
                "code": "def _validate_date_str(str_): if not str_: return None # Convert to datetime so we can validate it's a real date that exists then # convert it back to the string. try: date = datetime.strptime(str_, DATE_FMT) except ValueError: msg = 'Invalid date format, should be YYYY-MM-DD' raise argparse.ArgumentTypeError(msg) return date.strftime(DATE_FMT)"
            },
            {
                "url": 154,
                "code": "def _datetime_to_date(arg): _arg = parse(arg) if isinstance(_arg, datetime.datetime): _arg = _arg.date() return _arg"
            },
            {
                "url": 1211,
                "code": "def parse_datetime(dt_str): date_format = \"%Y-%m-%dT%H:%M:%S %z\" dt_str = dt_str.replace(\"Z\", \" +0000\") return datetime.datetime.strptime(dt_str, date_format)"
            },
            {
                "url": 2801,
                "code": "def __to_localdatetime(val): try: dt = datetime.strptime(val, __DATE_FORMAT) dt = pytz.timezone(__TIMEZONE).localize(dt) return dt except (ValueError, TypeError): return None"
            }
        ],
        "url": 1753
    },
    {
        "nl_input": "python go to next page",
        "code_input": [
            {
                "url": 3706,
                "code": "def accel_next(self, *args): if self.get_notebook().get_current_page() + 1 == self.get_notebook().get_n_pages(): self.get_notebook().set_current_page(0) else: self.get_notebook().next_page() return True"
            },
            {
                "url": 3487,
                "code": "def accel_prev(self, *args): if self.get_notebook().get_current_page() == 0: self.get_notebook().set_current_page(self.get_notebook().get_n_pages() - 1) else: self.get_notebook().prev_page() return True"
            },
            {
                "url": 36,
                "code": "def do_next(self, args): self._do_print_from_last_cmd = True self._interp.step_over() return True"
            },
            {
                "url": 3090,
                "code": "def autopage(self): while self.items: yield from self.items self.items = self.fetch_next()"
            },
            {
                "url": 4999,
                "code": "def next(self): _LOGGER.debug(\"reading next\") if self.closed: _LOGGER.debug(\"stream is closed\") raise StopIteration() line = self.readline() if not line: _LOGGER.debug(\"nothing more to read\") raise StopIteration() return line"
            },
            {
                "url": 5561,
                "code": "def __next__(self): self.current += 1 if self.current > self.total: raise StopIteration else: return self.iterable[self.current - 1]"
            },
            {
                "url": 818,
                "code": "def go_to_line(self, line): cursor = self.textCursor() cursor.setPosition(self.document().findBlockByNumber(line - 1).position()) self.setTextCursor(cursor) return True"
            },
            {
                "url": 2755,
                "code": "def next(self): # I'm pretty sure this is the completely wrong way to go about this, but # oh well, this works. if not hasattr(self, '_iter'): self._iter = self.readrow_as_dict() return self._iter.next()"
            },
            {
                "url": 579,
                "code": "def next (self): # File-like object. result = self.readline() if result == self._empty_buffer: raise StopIteration return result"
            },
            {
                "url": 2388,
                "code": "def step_next_line(self): self._eol.append(self.position) self._lineno += 1 self._col_offset = 0"
            },
            {
                "url": 814,
                "code": "def _go_to_line(editor, line): b = editor.application.current_buffer b.cursor_position = b.document.translate_row_col_to_index(max(0, int(line) - 1), 0)"
            },
            {
                "url": 1968,
                "code": "def __next__(self, reward, ask_id, lbl): return self.next(reward, ask_id, lbl)"
            },
            {
                "url": 2603,
                "code": "def _iter_response(self, url, params=None): if params is None: params = {} params['page_number'] = 1 # Last page lists itself as next page while True: response = self._request(url, params) for item in response['result_data']: yield item # Last page lists itself as next page if response['service_meta']['next_page_number'] == params['page_number']: break params['page_number'] += 1"
            },
            {
                "url": 1137,
                "code": "def skip(self, n): try: self._iter_object.skip(n) except AttributeError: for i in range(0, n): self.next()"
            },
            {
                "url": 1590,
                "code": "def __next__(self): # Retrieve the row, thereby incrementing the line number: row = super(UnicodeReaderWithLineNumber, self).__next__() return self.lineno + 1, row"
            }
        ],
        "url": 3706
    },
    {
        "nl_input": "filling null value sin data frame in python",
        "code_input": [
            {
                "url": 1801,
                "code": "def fill_nulls(self, col: str): n = [None, \"\"] try: self.df[col] = self.df[col].replace(n, nan) except Exception as e: self.err(e)"
            },
            {
                "url": 4722,
                "code": "def fillna(series_or_arr, missing_value=0.0): if pandas.notnull(missing_value): if isinstance(series_or_arr, (numpy.ndarray)): series_or_arr[numpy.isnan(series_or_arr)] = missing_value else: series_or_arr.fillna(missing_value, inplace=True) return series_or_arr"
            },
            {
                "url": 292,
                "code": "def _maybe_fill(arr, fill_value=np.nan): if _isna_compat(arr, fill_value): arr.fill(fill_value) return arr"
            },
            {
                "url": 6165,
                "code": "def fix_missing(df, col, name, na_dict): if is_numeric_dtype(col): if pd.isnull(col).sum() or (name in na_dict): df[name+'_na'] = pd.isnull(col) filler = na_dict[name] if name in na_dict else col.median() df[name] = col.fillna(filler) na_dict[name] = filler return na_dict"
            },
            {
                "url": 889,
                "code": "def clean_dataframe(df): df = df.fillna(method='ffill') df = df.fillna(0.0) return df"
            },
            {
                "url": 2333,
                "code": "def clean_df(df, fill_nan=True, drop_empty_columns=True): if fill_nan: df = df.fillna(value=np.nan) if drop_empty_columns: df = df.dropna(axis=1, how='all') return df.sort_index()"
            },
            {
                "url": 5888,
                "code": "def warn_if_nans_exist(X): null_count = count_rows_with_nans(X) total = len(X) percent = 100 * null_count / total if null_count > 0: warning_message = \\ 'Warning! Found {} rows of {} ({:0.2f}%) with nan values. Only ' \\ 'complete rows will be plotted.'.format(null_count, total, percent) warnings.warn(warning_message, DataWarning)"
            },
            {
                "url": 1025,
                "code": "def _replace_nan(a, val): mask = isnull(a) return where_method(val, mask, a), mask"
            },
            {
                "url": 5659,
                "code": "def is_not_null(df: DataFrame, col_name: str) -> bool: if ( isinstance(df, pd.DataFrame) and col_name in df.columns and df[col_name].notnull().any() ): return True else: return False"
            },
            {
                "url": 1803,
                "code": "def inpaint(self): import inpaint filled = inpaint.replace_nans(np.ma.filled(self.raster_data, np.NAN).astype(np.float32), 3, 0.01, 2) self.raster_data = np.ma.masked_invalid(filled)"
            },
            {
                "url": 5399,
                "code": "def table_nan_locs(table): ans = [] for rownum, row in enumerate(table): try: if pd.isnull(row).any(): colnums = pd.isnull(row).nonzero()[0] ans += [(rownum, colnum) for colnum in colnums] except AttributeError: # table is really just a sequence of scalars if pd.isnull(row): ans += [(rownum, 0)] return ans"
            },
            {
                "url": 5807,
                "code": "def inject_nulls(data: Mapping, field_names) -> dict: record = dict() for field in field_names: record[field] = data.get(field, None) return record"
            },
            {
                "url": 5021,
                "code": "def count_nulls(self, field): try: n = self.df[field].isnull().sum() except KeyError: self.warning(\"Can not find column\", field) return except Exception as e: self.err(e, \"Can not count nulls\") return self.ok(\"Found\", n, \"nulls in column\", field)"
            },
            {
                "url": 3194,
                "code": "def na_if(series, *values): series = pd.Series(series) series[series.isin(values)] = np.nan return series"
            },
            {
                "url": 4484,
                "code": "def _maybe_pandas_data(data, feature_names, feature_types): if not isinstance(data, DataFrame): return data, feature_names, feature_types data_dtypes = data.dtypes if not all(dtype.name in PANDAS_DTYPE_MAPPER for dtype in data_dtypes): bad_fields = [data.columns[i] for i, dtype in enumerate(data_dtypes) if dtype.name not in PANDAS_DTYPE_MAPPER] msg = \"\"\"DataFrame.dtypes for data must be int, float or bool. Did not expect the data types in fields \"\"\" raise ValueError(msg + ', '.join(bad_fields)) if feature_names is None: if isinstance(data.columns, MultiIndex): feature_names = [ ' '.join([str(x) for x in i]) for i in data.columns ] else: feature_names = data.columns.format() if feature_types is None: feature_types = [PANDAS_DTYPE_MAPPER[dtype.name] for dtype in data_dtypes] data = data.values.astype('float') return data, feature_names, feature_types"
            }
        ],
        "url": 889
    },
    {
        "nl_input": "python run external command and get output",
        "code_input": [
            {
                "url": 609,
                "code": "def call_out(command): # start external command process p = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE) # get outputs out, _ = p.communicate() return p.returncode, out.strip()"
            },
            {
                "url": 1572,
                "code": "def _run_cmd_get_output(cmd): process = subprocess.Popen(cmd.split(), stdout=subprocess.PIPE) out, err = process.communicate() return out or err"
            },
            {
                "url": 1891,
                "code": "def check_output(args): log.debug('run: %s', args) out = subprocess.check_output(args=args).decode('utf-8') log.debug('out: %r', out) return out"
            },
            {
                "url": 3723,
                "code": "def run_command(cmd, *args): command = ' '.join((cmd, args)) p = Popen(command, shell=True, stdout=PIPE, stderr=PIPE) stdout, stderr = p.communicate() return p.retcode, stdout, stderr"
            },
            {
                "url": 114,
                "code": "def check_output(args, env=None, sp=subprocess): log.debug('calling %s with env %s', args, env) output = sp.check_output(args=args, env=env) log.debug('output: %r', output) return output"
            },
            {
                "url": 4079,
                "code": "def run_cmd(command, verbose=True, shell='/bin/bash'): process = Popen(command, shell=True, stdout=PIPE, stderr=STDOUT, executable=shell) output = process.stdout.read().decode().strip().split('\\n') if verbose: # return full output including empty lines return output return [line for line in output if line.strip()]"
            },
            {
                "url": 3098,
                "code": "def getoutput_pexpect(self, cmd): try: return pexpect.run(self.sh, args=['-c', cmd]).replace('\\r\\n', '\\n') except KeyboardInterrupt: print('^C', file=sys.stderr, end='')"
            },
            {
                "url": 1064,
                "code": "def call_and_exit(self, cmd, shell=True): sys.exit(subprocess.call(cmd, shell=shell))"
            },
            {
                "url": 2222,
                "code": "def pylint_raw(options): command = ['pylint'] command.extend(options) proc = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE) outs, __ = proc.communicate() return outs.decode()"
            },
            {
                "url": 5133,
                "code": "def kubectl(*args, input=None, **flags): # Build command line call. line = ['kubectl'] + list(args) line = line + get_flag_args(**flags) if input is not None: line = line + ['-f', '-'] # Run subprocess output = subprocess.run( line, input=input, capture_output=True, text=True ) return output"
            },
            {
                "url": 5939,
                "code": "async def stdout(self) -> AsyncGenerator[str, None]: await self.wait_running() async for line in self._subprocess.stdout: # type: ignore yield line"
            },
            {
                "url": 477,
                "code": "def runcode(code): for line in code: print('# '+line) exec(line,globals()) print('# return ans') return ans"
            },
            {
                "url": 5092,
                "code": "def print_message(message=None): kwargs = {'stdout': sys.stdout, 'stderr': sys.stderr, 'shell': True} return subprocess.call('echo \"{0}\"'.format(message or ''), **kwargs)"
            },
            {
                "url": 4725,
                "code": "def _send_cmd(self, cmd): self._process.stdin.write(\"{}\\n\".format(cmd).encode(\"utf-8\")) self._process.stdin.flush()"
            },
            {
                "url": 1086,
                "code": "def execute_in_background(self): # http://stackoverflow.com/questions/1605520 args = shlex.split(self.cmd) p = Popen(args) return p.pid"
            }
        ],
        "url": 114
    },
    {
        "nl_input": "how to compile python program to use in c++",
        "code_input": [
            {
                "url": 4103,
                "code": "def make_code_from_py(filename): # Open the source file. try: source_file = open_source(filename) except IOError: raise NoSource(\"No file to run: %r\" % filename) try: source = source_file.read() finally: source_file.close() # We have the source. `compile` still needs the last line to be clean, # so make sure it is, then compile a code object from it. if not source or source[-1] != '\\n': source += '\\n' code = compile(source, filename, \"exec\") return code"
            },
            {
                "url": 2706,
                "code": "def _try_compile(source, name): try: c = compile(source, name, 'eval') except SyntaxError: c = compile(source, name, 'exec') return c"
            },
            {
                "url": 1830,
                "code": "def xeval(source, optimize=True): native = xcompile(source, optimize=optimize) return native()"
            },
            {
                "url": 4529,
                "code": "def code(self): return compile(self.source(), self.full_path, 'exec', flags=0, dont_inherit=True)"
            },
            {
                "url": 1415,
                "code": "def get_code(module): fp = open(module.path) try: return compile(fp.read(), str(module.name), 'exec') finally: fp.close()"
            },
            {
                "url": 801,
                "code": "def cpp_prog_builder(build_context, target): yprint(build_context.conf, 'Build CppProg', target) workspace_dir = build_context.get_workspace('CppProg', target.name) build_cpp(build_context, target, target.compiler_config, workspace_dir)"
            },
            {
                "url": 4898,
                "code": "def cpp_checker(code, working_directory): return gcc_checker(code, '.cpp', [os.getenv('CXX', 'g++'), '-std=c++0x'] + INCLUDE_FLAGS, working_directory=working_directory)"
            },
            {
                "url": 523,
                "code": "def _get_compiled_ext(): for ext, mode, typ in imp.get_suffixes(): if typ == imp.PY_COMPILED: return ext"
            },
            {
                "url": 5002,
                "code": "def eval(self, expression, use_compilation_plan=False): code = 'PyJsEvalResult = eval(%s)' % json.dumps(expression) self.execute(code, use_compilation_plan=use_compilation_plan) return self['PyJsEvalResult']"
            },
            {
                "url": 4074,
                "code": "def typescript_compile(source): with open(TS_COMPILER, 'r') as tsservices_js: return evaljs( (tsservices_js.read(), 'ts.transpile(dukpy.tscode, {options});'.format(options=TSC_OPTIONS)), tscode=source )"
            },
            {
                "url": 477,
                "code": "def runcode(code): for line in code: print('# '+line) exec(line,globals()) print('# return ans') return ans"
            },
            {
                "url": 668,
                "code": "def get_python(): if sys.platform == 'win32': python = path.join(VE_ROOT, 'Scripts', 'python.exe') else: python = path.join(VE_ROOT, 'bin', 'python') return python"
            },
            {
                "url": 1414,
                "code": "def execfile(fname, variables): with open(fname) as f: code = compile(f.read(), fname, 'exec') exec(code, variables)"
            },
            {
                "url": 925,
                "code": "def py(self, output): import pprint pprint.pprint(output, stream=self.outfile)"
            },
            {
                "url": 2786,
                "code": "def install_rpm_py(): python_path = sys.executable cmd = '{0} install.py'.format(python_path) exit_status = os.system(cmd) if exit_status != 0: raise Exception('Command failed: {0}'.format(cmd))"
            }
        ],
        "url": 801
    },
    {
        "nl_input": "python img to bytearray",
        "code_input": [
            {
                "url": 1732,
                "code": "def img_encode(arr, **kwargs): sio = BytesIO() imsave(sio, arr, **kwargs) sio.seek(0) img_format = kwargs['format'] if kwargs.get('format') else 'png' img_str = base64.b64encode(sio.getvalue()).decode() return 'data:image/{};base64,{}'.format(img_format, img_str)"
            },
            {
                "url": 2547,
                "code": "def url_to_image(url, flag=cv2.IMREAD_COLOR): resp = urlopen(url) image = np.asarray(bytearray(resp.read()), dtype=\"uint8\") image = cv2.imdecode(image, flag) return image"
            },
            {
                "url": 3304,
                "code": "def base64ToImage(imgData, out_path, out_file): fh = open(os.path.join(out_path, out_file), \"wb\") fh.write(imgData.decode('base64')) fh.close() del fh return os.path.join(out_path, out_file)"
            },
            {
                "url": 3209,
                "code": "def display_pil_image(im): from IPython.core import display b = BytesIO() im.save(b, format='png') data = b.getvalue() ip_img = display.Image(data=data, format='png', embed=True) return ip_img._repr_png_()"
            },
            {
                "url": 4647,
                "code": "def read_image(filepath): im_bytes = tf.io.read_file(filepath) im = tf.image.decode_image(im_bytes, channels=CHANNELS) im = tf.image.convert_image_dtype(im, tf.float32) return im"
            },
            {
                "url": 369,
                "code": "def imdecode(image_path): import os assert os.path.exists(image_path), image_path + ' not found' im = cv2.imread(image_path) return im"
            },
            {
                "url": 1871,
                "code": "def url_to_image(url): r = requests.get(url) image = StringIO(r.content) return image"
            },
            {
                "url": 5421,
                "code": "def file_to_png(fp): import PIL.Image # pylint: disable=import-error with io.BytesIO() as dest: PIL.Image.open(fp).save(dest, \"PNG\", optimize=True) return dest.getvalue()"
            },
            {
                "url": 618,
                "code": "def get_buffer(self, data_np, header, format, output=None): if not have_pil: raise Exception(\"Install PIL to use this method\") image = PILimage.fromarray(data_np) buf = output if buf is None: buf = BytesIO() image.save(buf, format) return buf"
            },
            {
                "url": 3081,
                "code": "def get_image(self, source): buf = StringIO(source.read()) return Image.open(buf)"
            },
            {
                "url": 4784,
                "code": "def get_img_data(f, maxsize = (1200, 850), first = False): img = Image.open(f) img.thumbnail(maxsize) if first: # tkinter is inactive the first time bio = io.BytesIO() img.save(bio, format = \"PNG\") del img return bio.getvalue() return ImageTk.PhotoImage(img)"
            },
            {
                "url": 1142,
                "code": "def resize_image(self, data, size): from machina.core.compat import PILImage as Image image = Image.open(BytesIO(data)) # Resize! image.thumbnail(size, Image.ANTIALIAS) string = BytesIO() image.save(string, format='PNG') return string.getvalue()"
            },
            {
                "url": 2329,
                "code": "def write_image(filename, image): data_format = get_data_format(filename) if data_format is MimeType.JPG: LOGGER.warning('Warning: jpeg is a lossy format therefore saved data will be modified.') return Image.fromarray(image).save(filename)"
            },
            {
                "url": 2485,
                "code": "def load_image(fname): with open(fname, \"rb\") as f: i = Image.open(fname) #i.load() return i"
            },
            {
                "url": 3413,
                "code": "def to_bytes(s, encoding=\"utf-8\"): if isinstance(s, six.binary_type): return s if six.PY3: return bytes(s, encoding) return s.encode(encoding)"
            }
        ],
        "url": 4466
    },
    {
        "nl_input": "how to use access token oauth python",
        "code_input": [
            {
                "url": 2539,
                "code": "def get_tweepy_auth(twitter_api_key, twitter_api_secret, twitter_access_token, twitter_access_token_secret): auth = tweepy.OAuthHandler(twitter_api_key, twitter_api_secret) auth.set_access_token(twitter_access_token, twitter_access_token_secret) return auth"
            },
            {
                "url": 3710,
                "code": "def get_oauth_token(): url = \"{0}/token\".format(DEFAULT_ORIGIN[\"Origin\"]) r = s.get(url=url) return r.json()[\"t\"]"
            },
            {
                "url": 909,
                "code": "def _get_token(self, oauth_request, token_type='access'): token_field = oauth_request.get_parameter('oauth_token') token = self.data_store.lookup_token(token_type, token_field) if not token: raise OAuthError('Invalid %s token: %s' % (token_type, token_field)) return token"
            },
            {
                "url": 2605,
                "code": "def fetch_token(self, **kwargs): return super(AsanaOAuth2Session, self).fetch_token(self.token_url, client_secret=self.client_secret, **kwargs)"
            },
            {
                "url": 6100,
                "code": "def access_token(self): access_token = self.session.get(self.access_token_key) if access_token: if not self.expires_at: # user provided access_token, just return it return access_token timestamp = time.time() if self.expires_at - timestamp > 60: return access_token self.fetch_access_token() return self.session.get(self.access_token_key)"
            },
            {
                "url": 1041,
                "code": "def get_auth(): import getpass user = input(\"User Name: \") # noqa pswd = getpass.getpass('Password: ') return Github(user, pswd)"
            },
            {
                "url": 3158,
                "code": "def __call__(self, r): r.headers['Authorization'] = 'JWT {jwt}'.format(jwt=self.token) return r"
            },
            {
                "url": 3871,
                "code": "def _handle_authentication_error(self): response = make_response('Access Denied') response.headers['WWW-Authenticate'] = self.auth.get_authenticate_header() response.status_code = 401 return response"
            },
            {
                "url": 5315,
                "code": "def login(self, username, password=None, token=None): self.session.basic_auth(username, password)"
            },
            {
                "url": 1926,
                "code": "def auth_request(self, url, headers, body): return self.req.post(url, headers, body=body)"
            },
            {
                "url": 1850,
                "code": "def twitter_timeline(screen_name, since_id=None): consumer_key = twitter_credential('consumer_key') consumer_secret = twitter_credential('consumer_secret') access_token = twitter_credential('access_token') access_token_secret = twitter_credential('access_secret') auth = tweepy.OAuthHandler(consumer_key, consumer_secret) auth.set_access_token(access_token, access_token_secret) api = tweepy.API(auth) return get_all_tweets(screen_name, api, since_id)"
            },
            {
                "url": 5920,
                "code": "async def login( username: str, password: str, brand: str, websession: ClientSession = None) -> API: api = API(brand, websession) await api.authenticate(username, password) return api"
            },
            {
                "url": 1570,
                "code": "def get_request(self, request): request.transport_user = self.username request.transport_password = self.api_key return request"
            },
            {
                "url": 4289,
                "code": "def set_basic_auth(self, username, password): from requests.auth import HTTPBasicAuth self.auth = HTTPBasicAuth(username, password) return self"
            },
            {
                "url": 4117,
                "code": "def __init__(self, token, editor=None): self.token = token self.editor = editor self.session = requests.Session()"
            }
        ],
        "url": 2605
    },
    {
        "nl_input": "have python line continue on to next line",
        "code_input": [
            {
                "url": 2388,
                "code": "def step_next_line(self): self._eol.append(self.position) self._lineno += 1 self._col_offset = 0"
            },
            {
                "url": 34,
                "code": "def advance_one_line(self): current_line = self._current_token.line_number while current_line == self._current_token.line_number: self._current_token = ConfigParser.Token(*next(self._token_generator))"
            },
            {
                "url": 1590,
                "code": "def __next__(self): # Retrieve the row, thereby incrementing the line number: row = super(UnicodeReaderWithLineNumber, self).__next__() return self.lineno + 1, row"
            },
            {
                "url": 4999,
                "code": "def next(self): _LOGGER.debug(\"reading next\") if self.closed: _LOGGER.debug(\"stream is closed\") raise StopIteration() line = self.readline() if not line: _LOGGER.debug(\"nothing more to read\") raise StopIteration() return line"
            },
            {
                "url": 5582,
                "code": "def iter_lines(file_like: Iterable[str]) -> Generator[str, None, None]: for line in file_like: line = line.rstrip('\\r\\n') if line: yield line"
            },
            {
                "url": 3216,
                "code": "def _skip_newlines(self): while self._cur_token['type'] is TT.lbreak and not self._finished: self._increment()"
            },
            {
                "url": 579,
                "code": "def next (self): # File-like object. result = self.readline() if result == self._empty_buffer: raise StopIteration return result"
            },
            {
                "url": 636,
                "code": "def get_lines(handle, line): for i, l in enumerate(handle): if i == line: return l"
            },
            {
                "url": 428,
                "code": "def go_to_new_line(self): self.stdkey_end(False, False) self.insert_text(self.get_line_separator())"
            },
            {
                "url": 5230,
                "code": "def read(self): for line in self.io.read(): with self.parse_line(line) as j: yield j"
            },
            {
                "url": 814,
                "code": "def _go_to_line(editor, line): b = editor.application.current_buffer b.cursor_position = b.document.translate_row_col_to_index(max(0, int(line) - 1), 0)"
            },
            {
                "url": 818,
                "code": "def go_to_line(self, line): cursor = self.textCursor() cursor.setPosition(self.document().findBlockByNumber(line - 1).position()) self.setTextCursor(cursor) return True"
            },
            {
                "url": 4173,
                "code": "def readline( file, skip_blank=False ): while 1: line = file.readline() #print \"every line: %r\" % line if not line: return None if line[0] != '#' and not ( skip_blank and line.isspace() ): return line"
            },
            {
                "url": 783,
                "code": "def erase_lines(n=1): for _ in range(n): print(codes.cursor[\"up\"], end=\"\") print(codes.cursor[\"eol\"], end=\"\")"
            },
            {
                "url": 5707,
                "code": "def is_line_in_file(filename: str, line: str) -> bool: assert \"\\n\" not in line with open(filename, \"r\") as file: for fileline in file: if fileline == line: return True return False"
            }
        ],
        "url": 34
    },
    {
        "nl_input": "precision of ints in python",
        "code_input": [
            {
                "url": 60,
                "code": "def round_to_int(number, precision): precision = int(precision) rounded = (int(number) + precision / 2) // precision * precision return rounded"
            },
            {
                "url": 1840,
                "code": "def get_decimal_quantum(precision): assert isinstance(precision, (int, decimal.Decimal)) return decimal.Decimal(10) ** (-precision)"
            },
            {
                "url": 321,
                "code": "def round_to_float(number, precision): rounded = Decimal(str(floor((number + precision / 2) // precision)) ) * Decimal(str(precision)) return float(rounded)"
            },
            {
                "url": 4489,
                "code": "def round_float(f, digits, rounding=ROUND_HALF_UP): return Decimal(str(f)).quantize(Decimal(10) ** (-1 * digits), rounding=rounding)"
            },
            {
                "url": 323,
                "code": "def intround(value): return int(decimal.Decimal.from_float( value).to_integral_value(decimal.ROUND_HALF_EVEN))"
            },
            {
                "url": 2579,
                "code": "def py3round(number): if abs(round(number) - number) == 0.5: return int(2.0 * round(number / 2.0)) return int(round(number))"
            },
            {
                "url": 5566,
                "code": "def proper_round(n): return int(n) + (n / abs(n)) * int(abs(n - int(n)) >= 0.5) if n != 0 else 0"
            },
            {
                "url": 1487,
                "code": "def round_array(array_in): if isinstance(array_in, ndarray): return np.round(array_in).astype(int) else: return int(np.round(array_in))"
            },
            {
                "url": 1062,
                "code": "def get_rounded(self, digits): result = self.copy() result.round(digits) return result"
            },
            {
                "url": 6258,
                "code": "def trim_decimals(s, precision=-3): encoded = s.encode('ascii', 'ignore') str_val = \"\" if six.PY3: str_val = str(encoded, encoding='ascii', errors='ignore')[:precision] else: # If precision is 0, this must be handled seperately if precision == 0: str_val = str(encoded) else: str_val = str(encoded)[:precision] if len(str_val) > 0: return float(str_val) else: return 0"
            },
            {
                "url": 2300,
                "code": "def specialRound(number, rounding): temp = 0 if rounding == 0: temp = number else: temp = round(number, rounding) if temp % 1 == 0: return int(temp) else: return float(temp)"
            },
            {
                "url": 2309,
                "code": "def price_rounding(price, decimals=2): try: exponent = D('.' + decimals * '0') except InvalidOperation: # Currencies with no decimal places, ex. JPY, HUF exponent = D() return price.quantize(exponent, rounding=ROUND_UP)"
            },
            {
                "url": 4260,
                "code": "def print_float(self, value, decimal_digits=2, justify_right=True): format_string = '{{0:0.{0}F}}'.format(decimal_digits) self.print_number_str(format_string.format(value), justify_right)"
            },
            {
                "url": 658,
                "code": "def round_to_x_digits(number, digits): return round(number * math.pow(10, digits)) / math.pow(10, digits)"
            },
            {
                "url": 3816,
                "code": "def _power(ctx, number, power): return decimal_pow(conversions.to_decimal(number, ctx), conversions.to_decimal(power, ctx))"
            }
        ],
        "url": 60
    },
    {
        "nl_input": "modify the dice roll program to call a function for the die roll s python",
        "code_input": [
            {
                "url": 3313,
                "code": "def roll_dice(): sums = 0 # will return the sum of the roll calls. while True: roll = random.randint(1, 6) sums += roll if(input(\"Enter y or n to continue: \").upper()) == 'N': print(sums) # prints the sum of the roll calls break"
            },
            {
                "url": 6092,
                "code": "def rollapply(data, window, fn): res = data.copy() res[:] = np.nan n = len(data) if window > n: return res for i in range(window - 1, n): res.iloc[i] = fn(data.iloc[i - window + 1:i + 1]) return res"
            },
            {
                "url": 4813,
                "code": "def __unroll(self, rolled): return np.array(np.concatenate([matrix.flatten() for matrix in rolled], axis=1)).reshape(-1)"
            },
            {
                "url": 1491,
                "code": "def __call__(self, func, *args, **kwargs): return self.run(func, *args, **kwargs)"
            },
            {
                "url": 3765,
                "code": "def SampleSum(dists, n): pmf = MakePmfFromList(RandomSum(dists) for i in xrange(n)) return pmf"
            },
            {
                "url": 1748,
                "code": "def __call__(self, args): window, ij = args return self.user_func(srcs, window, ij, global_args), window"
            },
            {
                "url": 1719,
                "code": "def transform(self, df): for name, function in self.outputs: df[name] = function(df)"
            },
            {
                "url": 2776,
                "code": "def runcoro(async_function): future = _asyncio.run_coroutine_threadsafe(async_function, client.loop) result = future.result() return result"
            },
            {
                "url": 3830,
                "code": "def restart_program(): python = sys.executable os.execl(python, python, * sys.argv)"
            },
            {
                "url": 1629,
                "code": "def run_func(entry): if entry.func: if entry.args and entry.krgs: return entry.func(*entry.args, **entry.krgs) if entry.args: return entry.func(*entry.args) if entry.krgs: return entry.func(**entry.krgs) return entry.func()"
            },
            {
                "url": 1400,
                "code": "def runiform(lower, upper, size=None): return np.random.uniform(lower, upper, size)"
            },
            {
                "url": 477,
                "code": "def runcode(code): for line in code: print('# '+line) exec(line,globals()) print('# return ans') return ans"
            },
            {
                "url": 3109,
                "code": "def __call__(self, _): if self.iter % self.step == 0: print(self.fmt.format(self.iter), **self.kwargs) self.iter += 1"
            },
            {
                "url": 4367,
                "code": "def run_func(self, func_path, *func_args, **kwargs): if not self.started: raise ValueError('Session not started, use start()') nargout = kwargs.pop('nargout', 1) func_args += tuple(item for pair in zip(kwargs.keys(), kwargs.values()) for item in pair) dname = os.path.dirname(func_path) fname = os.path.basename(func_path) func_name, ext = os.path.splitext(fname) if ext and not ext == '.m': raise TypeError('Need to give path to .m file') return self._json_response(cmd='eval', func_name=func_name, func_args=func_args or '', dname=dname, nargout=nargout)"
            },
            {
                "url": 5827,
                "code": "def nTimes(n, f, *args, **kwargs): r for i in xrange(n): f(*args, **kwargs)"
            }
        ],
        "url": 3313
    },
    {
        "nl_input": "python 'namespace' object is not iterable",
        "code_input": [
            {
                "url": 3950,
                "code": "def is_iterable(obj): return ( hasattr(obj, \"__iter__\") and not isinstance(obj, str) and not isinstance(obj, tuple) )"
            },
            {
                "url": 2522,
                "code": "def _is_iterable(item): return isinstance(item, collections.Iterable) and not isinstance(item, six.string_types)"
            },
            {
                "url": 1640,
                "code": "def is_iterable_but_not_string(obj): return hasattr(obj, '__iter__') and not isinstance(obj, str) and not isinstance(obj, bytes)"
            },
            {
                "url": 4454,
                "code": "def assert_iter(**kw): for name, value in kw.items(): if not isiter(value): raise TypeError( 'paco: {} must be an iterable object'.format(name))"
            },
            {
                "url": 5352,
                "code": "def _call(callable_obj, arg_names, namespace): arguments = {arg_name: getattr(namespace, arg_name) for arg_name in arg_names} return callable_obj(**arguments)"
            },
            {
                "url": 2976,
                "code": "def is_iterable(value): return isinstance(value, np.ndarray) or isinstance(value, list) or isinstance(value, tuple), value"
            },
            {
                "url": 2617,
                "code": "def ensure_iterable(inst): if isinstance(inst, string_types): return [inst] elif not isinstance(inst, collections.Iterable): return [inst] else: return inst"
            },
            {
                "url": 4204,
                "code": "def _varargs_to_iterable_method(func): def wrapped(self, iterable, **kwargs): return func(self, *iterable, **kwargs) return wrapped"
            },
            {
                "url": 657,
                "code": "def is_iter_non_string(obj): if isinstance(obj, list) or isinstance(obj, tuple): return True return False"
            },
            {
                "url": 1613,
                "code": "def is_iterable_of_int(l): r if not is_iterable(l): return False return all(is_int(value) for value in l)"
            },
            {
                "url": 94,
                "code": "def listlike(obj): return hasattr(obj, \"__iter__\") \\ and not issubclass(type(obj), str)\\ and not issubclass(type(obj), unicode)"
            },
            {
                "url": 570,
                "code": "def force_iterable(f): def wrapper(*args, **kwargs): r = f(*args, **kwargs) if hasattr(r, '__iter__'): return r else: return [r] return wrapper"
            },
            {
                "url": 2401,
                "code": "def ensure_tuple(obj): if obj is None: return tuple() if isinstance(obj, Iterable) and not isinstance(obj, six.string_types): return tuple(obj) return obj,"
            },
            {
                "url": 5900,
                "code": "def is_iterable(etype) -> bool: return type(etype) is GenericMeta and issubclass(etype.__extra__, Iterable)"
            },
            {
                "url": 4058,
                "code": "def _iterable_to_varargs_method(func): def wrapped(self, *args, **kwargs): return func(self, args, **kwargs) return wrapped"
            }
        ],
        "url": 4431
    },
    {
        "nl_input": "how to specify seed for python random",
        "code_input": [
            {
                "url": 1994,
                "code": "def generate_seed(seed): if seed is None: random.seed() seed = random.randint(0, sys.maxsize) random.seed(a=seed) return seed"
            },
            {
                "url": 4669,
                "code": "def new_random_state(seed=None, fully_random=False): if seed is None: if not fully_random: # sample manually a seed instead of just RandomState(), # because the latter one # is way slower. seed = CURRENT_RANDOM_STATE.randint(SEED_MIN_VALUE, SEED_MAX_VALUE, 1)[0] return np.random.RandomState(seed)"
            },
            {
                "url": 3334,
                "code": "def reseed_random(seed): r = random.Random(seed) random_internal_state = r.getstate() set_random_state(random_internal_state)"
            },
            {
                "url": 4830,
                "code": "def RandomShuffle(a, seed): if seed: np.random.seed(seed) r = a.copy() np.random.shuffle(r) return r,"
            },
            {
                "url": 4576,
                "code": "def block(seed): num = SAMPLE_RATE * BLOCK_SIZE rng = RandomState(seed % 2**32) variance = SAMPLE_RATE / 2 return rng.normal(size=num, scale=variance**0.5)"
            },
            {
                "url": 3733,
                "code": "def random_numbers(n): return ''.join(random.SystemRandom().choice(string.digits) for _ in range(n))"
            },
            {
                "url": 592,
                "code": "def const_rand(size, seed=23980): old_seed = np.random.seed() np.random.seed(seed) out = np.random.rand(size) np.random.seed(old_seed) return out"
            },
            {
                "url": 3370,
                "code": "def generate_hash(self, length=30): import random, string chars = string.ascii_letters + string.digits ran = random.SystemRandom().choice hash = ''.join(ran(chars) for i in range(length)) return hash"
            },
            {
                "url": 4270,
                "code": "def generate_random_string(chars=7): return u\"\".join(random.sample(string.ascii_letters * 2 + string.digits, chars))"
            },
            {
                "url": 3763,
                "code": "def gen_random_string(str_len): return ''.join( random.choice(string.ascii_letters + string.digits) for _ in range(str_len))"
            },
            {
                "url": 4569,
                "code": "def random_int(self, min=0, max=9999, step=1): return self.generator.random.randrange(min, max + 1, step)"
            },
            {
                "url": 3764,
                "code": "def uniform_noise(points): return np.random.rand(1) * np.random.uniform(points, 1) \\ + random.sample([2, -2], 1)"
            },
            {
                "url": 2530,
                "code": "def random_id(size=8, chars=string.ascii_letters + string.digits): return ''.join(random.choice(chars) for _ in range(size))"
            },
            {
                "url": 3820,
                "code": "def date(start, end): stime = date_to_timestamp(start) etime = date_to_timestamp(end) ptime = stime + random.random() * (etime - stime) return datetime.date.fromtimestamp(ptime)"
            },
            {
                "url": 1435,
                "code": "def random_choice(sequence): return random.choice(tuple(sequence) if isinstance(sequence, set) else sequence)"
            }
        ],
        "url": 1994
    },
    {
        "nl_input": "python use default arg",
        "code_input": [
            {
                "url": 1432,
                "code": "def arg_default(*args, **kwargs): parser = argparse.ArgumentParser() parser.add_argument(*args, **kwargs) args = vars(parser.parse_args([])) _, default = args.popitem() return default"
            },
            {
                "url": 4452,
                "code": "def args_update(self): for key, value in self._config_data.items(): setattr(self._default_args, key, value)"
            },
            {
                "url": 139,
                "code": "def get_default_args(func): args, varargs, keywords, defaults = getargspec_no_self(func) return dict(zip(args[-len(defaults):], defaults))"
            },
            {
                "url": 4190,
                "code": "def param (self, param, kwargs, default_value=False): if param in kwargs: value= kwargs[param] del kwargs[param] else: value= default_value setattr (self, param, value)"
            },
            {
                "url": 6022,
                "code": "def default_parser() -> argparse.ArgumentParser: parser = argparse.ArgumentParser( prog=CONSOLE_SCRIPT, formatter_class=argparse.ArgumentDefaultsHelpFormatter, ) build_parser(parser) return parser"
            },
            {
                "url": 2192,
                "code": "def apply_argument_parser(argumentsParser, options=None): if options is not None: args = argumentsParser.parse_args(options) else: args = argumentsParser.parse_args() return args"
            },
            {
                "url": 5531,
                "code": "def check_for_positional_argument(kwargs, name, default=False): if name in kwargs: if str(kwargs[name]) == \"True\": return True elif str(kwargs[name]) == \"False\": return False else: return kwargs[name] return default"
            },
            {
                "url": 1505,
                "code": "def add_argument(self, dest, nargs=1, obj=None): if obj is None: obj = dest self._args.append(Argument(dest=dest, nargs=nargs, obj=obj))"
            },
            {
                "url": 4324,
                "code": "def set_default(self_,param_name,value): cls = self_.cls setattr(cls,param_name,value)"
            },
            {
                "url": 3233,
                "code": "def validate_args(**args): if not args['query']: print(\"\\nMissing required query argument.\") sys.exit() for key in DEFAULTS: if key not in args: args[key] = DEFAULTS[key] return args"
            },
            {
                "url": 1315,
                "code": "def get_url_args(url): url_data = urllib.parse.urlparse(url) arg_dict = urllib.parse.parse_qs(url_data.query) return arg_dict"
            },
            {
                "url": 5363,
                "code": "def with_defaults(method, nparams, defaults=None): args = [None] * nparams if not defaults else defaults + max(nparams - len(defaults), 0) * [None] return method(*args)"
            },
            {
                "url": 2600,
                "code": "def sub(name, func,**kwarg): sp = subparsers.add_parser(name, **kwarg) sp.set_defaults(func=func) sp.arg = sp.add_argument return sp"
            },
            {
                "url": 384,
                "code": "def _add_default_arguments(parser): parser.add_argument('-c', '--config', action='store', dest='config', help='Path to the configuration file') parser.add_argument('-f', '--foreground', action='store_true', dest='foreground', help='Run the application interactively')"
            },
            {
                "url": 4450,
                "code": "def set_default(self, section, option, default): if not self.parser.has_option(section, option): self.parser.set(section, option, default)"
            }
        ],
        "url": 1432
    },
    {
        "nl_input": "python change array dtype to int",
        "code_input": [
            {
                "url": 2813,
                "code": "def scale_dtype(arr, dtype): max_int = np.iinfo(dtype).max return (arr * max_int).astype(dtype)"
            },
            {
                "url": 79,
                "code": "def cint32_array_to_numpy(cptr, length): if isinstance(cptr, ctypes.POINTER(ctypes.c_int32)): return np.fromiter(cptr, dtype=np.int32, count=length) else: raise RuntimeError('Expected int pointer')"
            },
            {
                "url": 84,
                "code": "def cint8_array_to_numpy(cptr, length): if isinstance(cptr, ctypes.POINTER(ctypes.c_int8)): return np.fromiter(cptr, dtype=np.int8, count=length) else: raise RuntimeError('Expected int pointer')"
            },
            {
                "url": 5736,
                "code": "def to_int64(a): # build new dtype and replace i4 --> i8 def promote_i4(typestr): if typestr[1:] == 'i4': typestr = typestr[0]+'i8' return typestr dtype = [(name, promote_i4(typestr)) for name,typestr in a.dtype.descr] return a.astype(dtype)"
            },
            {
                "url": 6171,
                "code": "def convert_to_int(x: Any, default: int = None) -> int: try: return int(x) except (TypeError, ValueError): return default"
            },
            {
                "url": 894,
                "code": "def safe_int_conv(number): try: return int(np.array(number).astype(int, casting='safe')) except TypeError: raise ValueError('cannot safely convert {} to integer'.format(number))"
            },
            {
                "url": 2675,
                "code": "def is_integer_array(val): return is_np_array(val) and issubclass(val.dtype.type, np.integer)"
            },
            {
                "url": 4148,
                "code": "def ensure_dtype_float(x, default=np.float64): r if isinstance(x, np.ndarray): if x.dtype.kind == 'f': return x elif x.dtype.kind == 'i': return x.astype(default) else: raise TypeError('x is of type '+str(x.dtype)+' that cannot be converted to float') else: raise TypeError('x is not an array')"
            },
            {
                "url": 9,
                "code": "def _convert_to_array(array_like, dtype): if isinstance(array_like, bytes): return np.frombuffer(array_like, dtype=dtype) return np.asarray(array_like, dtype=dtype)"
            },
            {
                "url": 5701,
                "code": "def convert_bytes_to_ints(in_bytes, num): dt = numpy.dtype('>i' + str(num)) return numpy.frombuffer(in_bytes, dt)"
            },
            {
                "url": 170,
                "code": "def _to_corrected_pandas_type(dt): import numpy as np if type(dt) == ByteType: return np.int8 elif type(dt) == ShortType: return np.int16 elif type(dt) == IntegerType: return np.int32 elif type(dt) == FloatType: return np.float32 else: return None"
            },
            {
                "url": 82,
                "code": "def cfloat32_array_to_numpy(cptr, length): if isinstance(cptr, ctypes.POINTER(ctypes.c_float)): return np.fromiter(cptr, dtype=np.float32, count=length) else: raise RuntimeError('Expected float pointer')"
            },
            {
                "url": 64,
                "code": "def cfloat64_array_to_numpy(cptr, length): if isinstance(cptr, ctypes.POINTER(ctypes.c_double)): return np.fromiter(cptr, dtype=np.float64, count=length) else: raise RuntimeError('Expected double pointer')"
            },
            {
                "url": 4975,
                "code": "def is_integer(dtype): dtype = tf.as_dtype(dtype) if hasattr(dtype, 'is_integer'): return dtype.is_integer return np.issubdtype(np.dtype(dtype), np.integer)"
            },
            {
                "url": 1487,
                "code": "def round_array(array_in): if isinstance(array_in, ndarray): return np.round(array_in).astype(int) else: return int(np.round(array_in))"
            }
        ],
        "url": 5736
    },
    {
        "nl_input": "python forcible close socket before opening",
        "code_input": [
            {
                "url": 1666,
                "code": "def socket_close(self): if self.sock != NC.INVALID_SOCKET: self.sock.close() self.sock = NC.INVALID_SOCKET"
            },
            {
                "url": 262,
                "code": "def _close_socket(self): try: self.socket.shutdown(socket.SHUT_RDWR) except (OSError, socket.error): pass self.socket.close()"
            },
            {
                "url": 4322,
                "code": "def shutdown(self): if self.sock: self.sock.close() self.sock = None self.connected = False"
            },
            {
                "url": 1667,
                "code": "def _close_websocket(self): close_method = getattr(self._websocket, \"close\", None) if callable(close_method): asyncio.ensure_future(close_method(), loop=self._event_loop) self._websocket = None self._dispatch_event(event=\"close\")"
            },
            {
                "url": 4558,
                "code": "def close(self): try: self._conn.send((self._CLOSE, None)) self._conn.close() except IOError: # The connection was already closed. pass self._process.join()"
            },
            {
                "url": 1176,
                "code": "def _shutdown_transport(self): if self.sock is not None: try: unwrap = self.sock.unwrap except AttributeError: return try: self.sock = unwrap() except ValueError: # Failure within SSL might mean unwrap exists but socket is not # deemed wrapped pass"
            },
            {
                "url": 1143,
                "code": "def stop(self, dummy_signum=None, dummy_frame=None): logging.info('Shutting down ...') self.socket.close() sys.exit(0)"
            },
            {
                "url": 4391,
                "code": "def disconnect(self): self.logger.debug('Close connection...') self.auto_reconnect = False if self.websocket is not None: self.websocket.close()"
            },
            {
                "url": 3711,
                "code": "def connected_socket(address, timeout=3): sock = socket.create_connection(address, timeout) yield sock sock.close()"
            },
            {
                "url": 3878,
                "code": "def __exit__(self, *exc_info): self._loop.create_task(self._close(Client.CLOSED, True))"
            },
            {
                "url": 3354,
                "code": "def close_connection (self): if self.url_connection is None: # no connection is open return try: self.url_connection.close() except Exception: # ignore close errors pass self.url_connection = None"
            },
            {
                "url": 4029,
                "code": "def on_close(self, ws): log.debug(\"Closing WebSocket connection with {}\".format(self.url)) if self.keepalive and self.keepalive.is_alive(): self.keepalive.do_run = False self.keepalive.join()"
            },
            {
                "url": 3911,
                "code": "def _ws_on_close(self, ws: websocket.WebSocketApp): self.connected = False self.logger.error('Websocket closed') self._reconnect_websocket()"
            },
            {
                "url": 4774,
                "code": "def flush_on_close(self, stream): assert get_thread_ident() == self.ioloop_thread_id # Prevent futher writes stream.KATCPServer_closing = True # Write empty message to get future that resolves when buffer is flushed return stream.write('\\n')"
            },
            {
                "url": 3897,
                "code": "def delayed_close(self): self.state = SESSION_STATE.CLOSING reactor.callLater(0, self.close)"
            }
        ],
        "url": 4558
    },
    {
        "nl_input": "python series'value non zero index",
        "code_input": [
            {
                "url": 1477,
                "code": "def series_index(self, series): for idx, s in enumerate(self): if series is s: return idx raise ValueError('series not in chart data object')"
            },
            {
                "url": 1331,
                "code": "def _values(self): return [ val for serie in self.series for val in serie.values if val is not None ]"
            },
            {
                "url": 5711,
                "code": "def non_zero_row(arr): if len(arr) == 0: return False for item in arr: if item == 0: return False return True"
            },
            {
                "url": 3194,
                "code": "def na_if(series, *values): series = pd.Series(series) series[series.isin(values)] = np.nan return series"
            },
            {
                "url": 4167,
                "code": "def yvals(self): return [ val[1] for serie in self.series for val in serie.values if val[1] is not None ]"
            },
            {
                "url": 2026,
                "code": "def idx(df, index): if isinstance(df, (pd.DataFrame, pd.Series)): return df.iloc[index] else: return df[index, :]"
            },
            {
                "url": 4722,
                "code": "def fillna(series_or_arr, missing_value=0.0): if pandas.notnull(missing_value): if isinstance(series_or_arr, (numpy.ndarray)): series_or_arr[numpy.isnan(series_or_arr)] = missing_value else: series_or_arr.fillna(missing_value, inplace=True) return series_or_arr"
            },
            {
                "url": 1742,
                "code": "def var(series): if np.issubdtype(series.dtype, np.number): return series.var() else: return np.nan"
            },
            {
                "url": 491,
                "code": "def get_X0(X): if pandas_available and isinstance(X, pd.DataFrame): assert len(X) == 1 x = np.array(X.iloc[0]) else: x, = X return x"
            },
            {
                "url": 3351,
                "code": "def __convert_none_to_zero(self, ts): if not ts: return ts ts_clean = [val if val else 0 for val in ts] return ts_clean"
            },
            {
                "url": 3637,
                "code": "def _nth(arr, n): try: return arr.iloc[n] except (KeyError, IndexError): return np.nan"
            },
            {
                "url": 2075,
                "code": "def index(m, val): mm = np.array(m) idx_tuple = np.where(mm == val) idx = idx_tuple[0].tolist() return idx"
            },
            {
                "url": 5399,
                "code": "def table_nan_locs(table): ans = [] for rownum, row in enumerate(table): try: if pd.isnull(row).any(): colnums = pd.isnull(row).nonzero()[0] ans += [(rownum, colnum) for colnum in colnums] except AttributeError: # table is really just a sequence of scalars if pd.isnull(row): ans += [(rownum, 0)] return ans"
            },
            {
                "url": 2572,
                "code": "def first(series, order_by=None): if order_by is not None: series = order_series_by(series, order_by) first_s = series.iloc[0] return first_s"
            },
            {
                "url": 3381,
                "code": "def get_closest_index(myList, myNumber): closest_values_index = _np.where(self.time == take_closest(myList, myNumber))[0][0] return closest_values_index"
            }
        ],
        "url": 621
    },
    {
        "nl_input": "how to add a number to certain elements of an array numpy python",
        "code_input": [
            {
                "url": 1487,
                "code": "def round_array(array_in): if isinstance(array_in, ndarray): return np.round(array_in).astype(int) else: return int(np.round(array_in))"
            },
            {
                "url": 2300,
                "code": "def specialRound(number, rounding): temp = 0 if rounding == 0: temp = number else: temp = round(number, rounding) if temp % 1 == 0: return int(temp) else: return float(temp)"
            },
            {
                "url": 60,
                "code": "def round_to_int(number, precision): precision = int(precision) rounded = (int(number) + precision / 2) // precision * precision return rounded"
            },
            {
                "url": 321,
                "code": "def round_to_float(number, precision): rounded = Decimal(str(floor((number + precision / 2) // precision)) ) * Decimal(str(precision)) return float(rounded)"
            },
            {
                "url": 1870,
                "code": "def _to_array(value): if isinstance(value, (tuple, list)): return array(value) elif isinstance(value, (float, int)): return np.float64(value) else: return value"
            },
            {
                "url": 2579,
                "code": "def py3round(number): if abs(round(number) - number) == 0.5: return int(2.0 * round(number / 2.0)) return int(round(number))"
            },
            {
                "url": 2378,
                "code": "def smooth_array(array, amount=1): if amount==0: return array # we have to store the old values in a temp array to keep the # smoothing from affecting the smoothing new_array = _n.array(array) for n in range(len(array)): new_array[n] = smooth(array, n, amount) return new_array"
            },
            {
                "url": 4489,
                "code": "def round_float(f, digits, rounding=ROUND_HALF_UP): return Decimal(str(f)).quantize(Decimal(10) ** (-1 * digits), rounding=rounding)"
            },
            {
                "url": 658,
                "code": "def round_to_x_digits(number, digits): return round(number * math.pow(10, digits)) / math.pow(10, digits)"
            },
            {
                "url": 2071,
                "code": "def print_matrix(X, decimals=1): for row in np.round(X, decimals=decimals): print(row)"
            },
            {
                "url": 1062,
                "code": "def get_rounded(self, digits): result = self.copy() result.round(digits) return result"
            },
            {
                "url": 3807,
                "code": "def unbroadcast_numpy_to(array, shape): axis = create_unbroadcast_axis(shape, numpy.shape(array)) return numpy.reshape(numpy.sum(array, axis=axis), shape)"
            },
            {
                "url": 5880,
                "code": "def array_to_npy(array_like): # type: (np.array or Iterable or int or float) -> object buffer = BytesIO() np.save(buffer, array_like) return buffer.getvalue()"
            },
            {
                "url": 1060,
                "code": "def round_to_n(x, n): return round(x, -int(np.floor(np.log10(x))) + (n - 1))"
            },
            {
                "url": 4629,
                "code": "def _increment(arr, indices): arr = _as_array(arr) indices = _as_array(indices) bbins = np.bincount(indices) arr[:len(bbins)] += bbins return arr"
            }
        ],
        "url": 4629
    },
    {
        "nl_input": "python unit test and coverage at same time",
        "code_input": [
            {
                "url": 1305,
                "code": "def test(): command = 'nosetests --with-coverage --cover-package=pwnurl' status = subprocess.call(shlex.split(command)) sys.exit(status)"
            },
            {
                "url": 4778,
                "code": "def coverage(ctx, opts=\"\"): return test(ctx, coverage=True, include_slow=True, opts=opts)"
            },
            {
                "url": 799,
                "code": "def coverage(): # Note: coverage options are controlled by .coveragerc file install() test_setup() sh(\"%s -m coverage run %s\" % (PYTHON, TEST_SCRIPT)) sh(\"%s -m coverage report\" % PYTHON) sh(\"%s -m coverage html\" % PYTHON) sh(\"%s -m webbrowser -t htmlcov/index.html\" % PYTHON)"
            },
            {
                "url": 1493,
                "code": "def test(): # pragma: no cover import pytest import os pytest.main([os.path.dirname(os.path.abspath(__file__))])"
            },
            {
                "url": 199,
                "code": "def test(): import unittest tests = unittest.TestLoader().discover('tests') unittest.TextTestRunner(verbosity=2).run(tests)"
            },
            {
                "url": 2740,
                "code": "def coverage(): run(\"coverage run --source {PROJECT_NAME} -m py.test\".format(PROJECT_NAME=PROJECT_NAME)) run(\"coverage report -m\") run(\"coverage html\") webbrowser.open('file://' + os.path.realpath(\"htmlcov/index.html\"), new=2)"
            },
            {
                "url": 2475,
                "code": "def cover(session): session.interpreter = 'python3.6' session.install('coverage', 'pytest-cov') session.run('coverage', 'report', '--show-missing', '--fail-under=100') session.run('coverage', 'erase')"
            },
            {
                "url": 1291,
                "code": "def test_python_java_rt(): sub_env = {'PYTHONPATH': _build_dir()} log.info('Executing Python unit tests (against Java runtime classes)...') return jpyutil._execute_python_scripts(python_java_rt_tests, env=sub_env)"
            },
            {
                "url": 2070,
                "code": "def run_tests(self): with _save_argv(_sys.argv[:1] + self.addopts): result_code = __import__('pytest').main() if result_code: raise SystemExit(result_code)"
            },
            {
                "url": 3300,
                "code": "def autobuild_python_test(path): env = Environment(tools=[]) target = env.Command(['build/test/output/pytest.log'], [path], action=env.Action(run_pytest, \"Running python unit tests\")) env.AlwaysBuild(target)"
            },
            {
                "url": 118,
                "code": "def test(*args): subprocess.call([\"py.test-2.7\"] + list(args)) subprocess.call([\"py.test-3.4\"] + list(args))"
            },
            {
                "url": 3588,
                "code": "def main(argv=sys.argv, stream=sys.stderr): args = parse_args(argv) suite = build_suite(args) runner = unittest.TextTestRunner(verbosity=args.verbose, stream=stream) result = runner.run(suite) return get_status(result)"
            },
            {
                "url": 942,
                "code": "def test(ctx, all=False, verbose=False): cmd = 'tox' if all else 'py.test' if verbose: cmd += ' -v' return ctx.run(cmd, pty=True).return_code"
            },
            {
                "url": 4326,
                "code": "def run_test(func, fobj): gc.disable() try: begin = time.time() func(fobj) end = time.time() finally: gc.enable() return end - begin"
            },
            {
                "url": 1496,
                "code": "def test(nose_argsuments): from nose import run params = ['__main__', '-c', 'nose.ini'] params.extend(nose_argsuments) run(argv=params)"
            }
        ],
        "url": 4778
    },
    {
        "nl_input": "python only list files with specific extension",
        "code_input": [
            {
                "url": 868,
                "code": "def glob_by_extensions(directory, extensions): directorycheck(directory) files = [] xt = files.extend for ex in extensions: xt(glob.glob('{0}/*.{1}'.format(directory, ex))) return files"
            },
            {
                "url": 2870,
                "code": "def list_files(directory): return [f for f in pathlib.Path(directory).iterdir() if f.is_file() and not f.name.startswith('.')]"
            },
            {
                "url": 2336,
                "code": "def match_files(files, pattern: Pattern): for name in files: if re.match(pattern, name): yield name"
            },
            {
                "url": 3908,
                "code": "def get_all_files(folder): for path, dirlist, filelist in os.walk(folder): for fn in filelist: yield op.join(path, fn)"
            },
            {
                "url": 4976,
                "code": "def matches_glob_list(path, glob_list): for glob in glob_list: try: if PurePath(path).match(glob): return True except TypeError: pass return False"
            },
            {
                "url": 2992,
                "code": "def get_files(dir_name): return [(os.path.join('.', d), [os.path.join(d, f) for f in files]) for d, _, files in os.walk(dir_name)]"
            },
            {
                "url": 3743,
                "code": "def globlookup(pattern, root): for subdir, dirnames, filenames in os.walk(root): d = subdir[len(root) + 1:] files = (os.path.join(d, f) for f in filenames) for f in fnmatch.filter(files, pattern): yield f"
            },
            {
                "url": 2643,
                "code": "def recursively_get_files_from_directory(directory): return [ os.path.join(root, filename) for root, directories, filenames in os.walk(directory) for filename in filenames ]"
            },
            {
                "url": 4368,
                "code": "def search_script_directory(self, path): for subdir, dirs, files in os.walk(path): for file_name in files: if file_name.endswith(\".py\"): self.search_script_file(subdir, file_name)"
            },
            {
                "url": 3533,
                "code": "def file_matches(filename, patterns): return any(fnmatch.fnmatch(filename, pat) for pat in patterns)"
            },
            {
                "url": 665,
                "code": "def directory_files(path): for entry in os.scandir(path): if not entry.name.startswith('.') and entry.is_file(): yield entry.name"
            },
            {
                "url": 5400,
                "code": "def strip_sdist_extras(filelist): return [name for name in filelist if not file_matches(name, IGNORE) and not file_matches_regexps(name, IGNORE_REGEXPS)]"
            },
            {
                "url": 6154,
                "code": "def _extension(modpath: str) -> setuptools.Extension: return setuptools.Extension(modpath, [modpath.replace(\".\", \"/\") + \".py\"])"
            },
            {
                "url": 2527,
                "code": "def get_file_extension_type(filename): ext = get_file_extension(filename) if ext: for name, group in EXTENSIONS.items(): if ext in group: return name return \"OTHER\""
            },
            {
                "url": 2576,
                "code": "def clean_py_files(path): for dirname, subdirlist, filelist in os.walk(path): for f in filelist: if f.endswith('py'): os.remove(os.path.join(dirname, f))"
            }
        ],
        "url": 868
    },
    {
        "nl_input": "python global type hinting",
        "code_input": [
            {
                "url": 285,
                "code": "def make_kind_check(python_types, numpy_kind): def check(value): if hasattr(value, 'dtype'): return value.dtype.kind == numpy_kind return isinstance(value, python_types) return check"
            },
            {
                "url": 768,
                "code": "def is_type(value): if isinstance(value, type): return issubclass(value, Type) return isinstance(value, Type)"
            },
            {
                "url": 5638,
                "code": "def maybe_infer_dtype_type(element): tipo = None if hasattr(element, 'dtype'): tipo = element.dtype elif is_list_like(element): element = np.asarray(element) tipo = element.dtype return tipo"
            },
            {
                "url": 1519,
                "code": "def _assert_is_type(name, value, value_type): if not isinstance(value, value_type): if type(value_type) is tuple: types = ', '.join(t.__name__ for t in value_type) raise ValueError('{0} must be one of ({1})'.format(name, types)) else: raise ValueError('{0} must be {1}' .format(name, value_type.__name__))"
            },
            {
                "url": 534,
                "code": "def is_builtin_type(tp): return hasattr(__builtins__, tp.__name__) and tp is getattr(__builtins__, tp.__name__)"
            },
            {
                "url": 2376,
                "code": "def validate_type(self, type_): if type_ is not None and type_ not in self.types_set: raise ValueError('Invalid type for %s:%s' % (self.__class__, type_))"
            },
            {
                "url": 921,
                "code": "def getTypeStr(_type): r if isinstance(_type, CustomType): return str(_type) if hasattr(_type, '__name__'): return _type.__name__ return ''"
            },
            {
                "url": 530,
                "code": "def _isstring(dtype): return dtype.type == numpy.unicode_ or dtype.type == numpy.string_"
            },
            {
                "url": 4181,
                "code": "def infer_dtype_from(val, pandas_dtype=False): if is_scalar(val): return infer_dtype_from_scalar(val, pandas_dtype=pandas_dtype) return infer_dtype_from_array(val, pandas_dtype=pandas_dtype)"
            },
            {
                "url": 3424,
                "code": "def is_numeric_dtype(dtype): dtype = np.dtype(dtype) return np.issubsctype(getattr(dtype, 'base', None), np.number)"
            },
            {
                "url": 3523,
                "code": "def is_int_type(val): try: # Python 2 return isinstance(val, (int, long)) except NameError: # Python 3 return isinstance(val, int)"
            },
            {
                "url": 218,
                "code": "def is_date(thing): # known date types date_types = (datetime.datetime, datetime.date, DateTime) return isinstance(thing, date_types)"
            },
            {
                "url": 3599,
                "code": "def _py_ex_argtype(executable): result = [] for p in executable.ordered_parameters: atypes = p.argtypes if atypes is not None: result.extend(p.argtypes) else: print((\"No argtypes for: {}\".format(p.definition()))) if type(executable).__name__ == \"Function\": result.extend(executable.argtypes) return result"
            },
            {
                "url": 1297,
                "code": "def istype(obj, check): if isinstance(check, tuple): for cls in check: if type(obj) is cls: return True return False else: return type(obj) is check"
            },
            {
                "url": 1364,
                "code": "def is_real_floating_dtype(dtype): dtype = np.dtype(dtype) return np.issubsctype(getattr(dtype, 'base', None), np.floating)"
            }
        ],
        "url": 534
    },
    {
        "nl_input": "how to make a function in python to take the average of list numbers",
        "code_input": [
            {
                "url": 2957,
                "code": "def calc_list_average(l): total = 0.0 for value in l: total += value return total / len(l)"
            },
            {
                "url": 1530,
                "code": "def average(arr): if len(arr) == 0: sys.stderr.write(\"ERROR: no content in array to take average\\n\") sys.exit() if len(arr) == 1: return arr[0] return float(sum(arr))/float(len(arr))"
            },
            {
                "url": 1278,
                "code": "def mean(inlist): sum = 0 for item in inlist: sum = sum + item return sum / float(len(inlist))"
            },
            {
                "url": 78,
                "code": "def average(iterator): count = 0 total = 0 for num in iterator: count += 1 total += num return float(total)/count"
            },
            {
                "url": 5908,
                "code": "def moving_average(iterable, n): it = iter(iterable) d = collections.deque(itertools.islice(it, n - 1)) d.appendleft(0) s = sum(d) for elem in it: s += elem - d.popleft() d.append(elem) yield s / float(n)"
            },
            {
                "url": 5718,
                "code": "def average_arrays(arrays: List[mx.nd.NDArray]) -> mx.nd.NDArray: if not arrays: raise ValueError(\"arrays is empty.\") if len(arrays) == 1: return arrays[0] check_condition(all(arrays[0].shape == a.shape for a in arrays), \"nd array shapes do not match\") return mx.nd.add_n(*arrays) / len(arrays)"
            },
            {
                "url": 4408,
                "code": "def moving_average(a, n): ret = np.cumsum(a, dtype=float) ret[n:] = ret[n:] - ret[:-n] return ret[n - 1:] / n"
            },
            {
                "url": 3025,
                "code": "def moving_average(array, n=3): ret = _np.cumsum(array, dtype=float) ret[n:] = ret[n:] - ret[:-n] return ret[n - 1:] / n"
            },
            {
                "url": 6111,
                "code": "def moving_average(arr: np.ndarray, n: int = 3) -> np.ndarray: ret = np.cumsum(arr, dtype=float) ret[n:] = ret[n:] - ret[:-n] return ret[n - 1:] / n"
            },
            {
                "url": 2930,
                "code": "def get_average_color(colors): c = reduce(color_reducer, colors) total = len(colors) return tuple(v / total for v in c)"
            },
            {
                "url": 5632,
                "code": "def normalize(numbers): total = float(sum(numbers)) return [n / total for n in numbers]"
            },
            {
                "url": 99,
                "code": "def mean_date(dt_list): dt_list_sort = sorted(dt_list) dt_list_sort_rel = [dt - dt_list_sort[0] for dt in dt_list_sort] avg_timedelta = sum(dt_list_sort_rel, timedelta())/len(dt_list_sort_rel) return dt_list_sort[0] + avg_timedelta"
            },
            {
                "url": 1529,
                "code": "def _mean_dict(dict_list): return {k: np.array([d[k] for d in dict_list]).mean() for k in dict_list[0].keys()}"
            },
            {
                "url": 2406,
                "code": "def standard_deviation(numbers): numbers = list(numbers) if not numbers: return 0 mean = sum(numbers) / len(numbers) return (sum((n - mean) ** 2 for n in numbers) / len(numbers)) ** .5"
            },
            {
                "url": 1531,
                "code": "def _aggr_mean(inList): aggrSum = 0 nonNone = 0 for elem in inList: if elem != SENTINEL_VALUE_FOR_MISSING_DATA: aggrSum += elem nonNone += 1 if nonNone != 0: return aggrSum / nonNone else: return None"
            }
        ],
        "url": 2957
    },
    {
        "nl_input": "check if two arrays are equal python",
        "code_input": [
            {
                "url": 180,
                "code": "def numpy_aware_eq(a, b): if isinstance(a, np.ndarray) or isinstance(b, np.ndarray): return np.array_equal(a, b) if ((isinstance(a, Iterable) and isinstance(b, Iterable)) and not isinstance(a, str) and not isinstance(b, str)): if len(a) != len(b): return False return all(numpy_aware_eq(x, y) for x, y in zip(a, b)) return a == b"
            },
            {
                "url": 5934,
                "code": "def check_lengths(*arrays): lengths = [len(array) for array in arrays] if len(np.unique(lengths)) > 1: raise ValueError('Inconsistent data lengths: {}'.format(lengths))"
            },
            {
                "url": 5851,
                "code": "def assert_equal(first, second, msg_fmt=\"{msg}\"): if isinstance(first, dict) and isinstance(second, dict): assert_dict_equal(first, second, msg_fmt) elif not first == second: msg = \"{!r} != {!r}\".format(first, second) fail(msg_fmt.format(msg=msg, first=first, second=second))"
            },
            {
                "url": 480,
                "code": "def equal(list1, list2): return [item1 == item2 for item1, item2 in broadcast_zip(list1, list2)]"
            },
            {
                "url": 5759,
                "code": "def check_consistent_length(*arrays): uniques = np.unique([_num_samples(X) for X in arrays if X is not None]) if len(uniques) > 1: raise ValueError(\"Found arrays with inconsistent numbers of samples: %s\" % str(uniques))"
            },
            {
                "url": 287,
                "code": "def all_equal(arg1,arg2): if all(hasattr(el, '_infinitely_iterable') for el in [arg1,arg2]): return arg1==arg2 try: return all(a1 == a2 for a1, a2 in zip(arg1, arg2)) except TypeError: return arg1==arg2"
            },
            {
                "url": 2161,
                "code": "def equal(obj1, obj2): Comparable.log(obj1, obj2, '==') equality = obj1.equality(obj2) Comparable.log(obj1, obj2, '==', result=equality) return equality"
            },
            {
                "url": 5584,
                "code": "def indexes_equal(a: Index, b: Index) -> bool: return str(a) == str(b)"
            },
            {
                "url": 192,
                "code": "def _check_elements_equal(lst): assert isinstance(lst, list), \"Input value must be a list.\" return not lst or lst.count(lst[0]) == len(lst)"
            },
            {
                "url": 869,
                "code": "def is_equal_strings_ignore_case(first, second): if first and second: return first.upper() == second.upper() else: return not (first or second)"
            },
            {
                "url": 2136,
                "code": "def allsame(list_, strict=True): if len(list_) == 0: return True first_item = list_[0] return list_all_eq_to(list_, first_item, strict)"
            },
            {
                "url": 6166,
                "code": "def same(*values): if not values: return True first, rest = values[0], values[1:] return all(value == first for value in rest)"
            },
            {
                "url": 283,
                "code": "def is_same_dict(d1, d2): for k, v in d1.items(): if isinstance(v, dict): is_same_dict(v, d2[k]) else: assert d1[k] == d2[k] for k, v in d2.items(): if isinstance(v, dict): is_same_dict(v, d1[k]) else: assert d1[k] == d2[k]"
            },
            {
                "url": 5822,
                "code": "def isarray(array, test, dim=2): if dim > 1: return all(isarray(array[i], test, dim - 1) for i in range(len(array))) return all(test(i) for i in array)"
            },
            {
                "url": 4037,
                "code": "def compare(string1, string2): if len(string1) != len(string2): return False result = True for c1, c2 in izip(string1, string2): result &= c1 == c2 return result"
            }
        ],
        "url": 180
    },
    {
        "nl_input": "python round down numpy",
        "code_input": [
            {
                "url": 1487,
                "code": "def round_array(array_in): if isinstance(array_in, ndarray): return np.round(array_in).astype(int) else: return int(np.round(array_in))"
            },
            {
                "url": 4489,
                "code": "def round_float(f, digits, rounding=ROUND_HALF_UP): return Decimal(str(f)).quantize(Decimal(10) ** (-1 * digits), rounding=rounding)"
            },
            {
                "url": 321,
                "code": "def round_to_float(number, precision): rounded = Decimal(str(floor((number + precision / 2) // precision)) ) * Decimal(str(precision)) return float(rounded)"
            },
            {
                "url": 60,
                "code": "def round_to_int(number, precision): precision = int(precision) rounded = (int(number) + precision / 2) // precision * precision return rounded"
            },
            {
                "url": 2579,
                "code": "def py3round(number): if abs(round(number) - number) == 0.5: return int(2.0 * round(number / 2.0)) return int(round(number))"
            },
            {
                "url": 323,
                "code": "def intround(value): return int(decimal.Decimal.from_float( value).to_integral_value(decimal.ROUND_HALF_EVEN))"
            },
            {
                "url": 1062,
                "code": "def get_rounded(self, digits): result = self.copy() result.round(digits) return result"
            },
            {
                "url": 1060,
                "code": "def round_to_n(x, n): return round(x, -int(np.floor(np.log10(x))) + (n - 1))"
            },
            {
                "url": 5566,
                "code": "def proper_round(n): return int(n) + (n / abs(n)) * int(abs(n - int(n)) >= 0.5) if n != 0 else 0"
            },
            {
                "url": 2071,
                "code": "def print_matrix(X, decimals=1): for row in np.round(X, decimals=decimals): print(row)"
            },
            {
                "url": 2300,
                "code": "def specialRound(number, rounding): temp = 0 if rounding == 0: temp = number else: temp = round(number, rounding) if temp % 1 == 0: return int(temp) else: return float(temp)"
            },
            {
                "url": 658,
                "code": "def round_to_x_digits(number, digits): return round(number * math.pow(10, digits)) / math.pow(10, digits)"
            },
            {
                "url": 3814,
                "code": "def round_sig(x, sig): return round(x, sig - int(floor(log10(abs(x)))) - 1)"
            },
            {
                "url": 3545,
                "code": "def ceil_nearest(x, dx=1): precision = get_sig_digits(dx) return round(math.ceil(float(x) / dx) * dx, precision)"
            },
            {
                "url": 2309,
                "code": "def price_rounding(price, decimals=2): try: exponent = D('.' + decimals * '0') except InvalidOperation: # Currencies with no decimal places, ex. JPY, HUF exponent = D() return price.quantize(exponent, rounding=ROUND_UP)"
            }
        ],
        "url": 1487
    },
    {
        "nl_input": "python pywin32 screenshoot refresh",
        "code_input": [
            {
                "url": 4699,
                "code": "def win32_refresh_window(cls): # Get console handle handle = windll.kernel32.GetConsoleWindow() RDW_INVALIDATE = 0x0001 windll.user32.RedrawWindow(handle, None, None, c_uint(RDW_INVALIDATE))"
            },
            {
                "url": 1913,
                "code": "def update_screen(self): self.clock.tick(self.FPS) pygame.display.update()"
            },
            {
                "url": 5706,
                "code": "def MoveWindow(handle: int, x: int, y: int, width: int, height: int, repaint: int = 1) -> bool: return bool(ctypes.windll.user32.MoveWindow(ctypes.c_void_p(handle), x, y, width, height, repaint))"
            },
            {
                "url": 5049,
                "code": "def screen_to_client(self, x, y): return tuple( win32.ScreenToClient( self.get_handle(), (x, y) ) )"
            },
            {
                "url": 1808,
                "code": "def clear(): if sys.platform.startswith(\"win\"): call(\"cls\", shell=True) else: call(\"clear\", shell=True)"
            },
            {
                "url": 3427,
                "code": "def get_active_window(): active_win = None default = wnck.screen_get_default() while gtk.events_pending(): gtk.main_iteration(False) window_list = default.get_windows() if len(window_list) == 0: print \"No Windows Found\" for win in window_list: if win.is_active(): active_win = win.get_name() return active_win"
            },
            {
                "url": 1592,
                "code": "def title(msg): if sys.platform.startswith(\"win\"): ctypes.windll.kernel32.SetConsoleTitleW(tounicode(msg))"
            },
            {
                "url": 5878,
                "code": "def SwitchToThisWindow(handle: int) -> None: ctypes.windll.user32.SwitchToThisWindow(ctypes.c_void_p(handle), 1)"
            },
            {
                "url": 76,
                "code": "def reloader_thread(softexit=False): while RUN_RELOADER: if code_changed(): # force reload if softexit: sys.exit(3) else: os._exit(3) time.sleep(1)"
            },
            {
                "url": 4812,
                "code": "def fillScreen(self, color=None): md.fill_rect(self.set, 0, 0, self.width, self.height, color)"
            },
            {
                "url": 2795,
                "code": "def display(self): w, h = self.session.window_size() return Display(w*self.scale, h*self.scale)"
            },
            {
                "url": 3051,
                "code": "def set_cursor(self, x, y): curses.curs_set(1) self.screen.move(y, x)"
            },
            {
                "url": 5527,
                "code": "def update(self): if not self.canvas: return for visual in self.canvas.visuals: self.update_program(visual.program) self.canvas.update()"
            },
            {
                "url": 1924,
                "code": "def OnMove(self, event): # Store window position in config position = self.main_window.GetScreenPositionTuple() config[\"window_position\"] = repr(position)"
            },
            {
                "url": 5358,
                "code": "def screen(self, width, height, colorDepth): screenEvent = ScreenEvent() screenEvent.width.value = width screenEvent.height.value = height screenEvent.colorDepth.value = colorDepth self.rec(screenEvent)"
            }
        ],
        "url": 4699
    },
    {
        "nl_input": "get largest date from a list python",
        "code_input": [
            {
                "url": 4978,
                "code": "def _latest_date(self, query, datetime_field_name): return list( query.aggregate(django.db.models.Max(datetime_field_name)).values() )[0]"
            },
            {
                "url": 812,
                "code": "def mostCommonItem(lst): # This elegant solution from: http://stackoverflow.com/a/1518632/1760218 lst = [l for l in lst if l] if lst: return max(set(lst), key=lst.count) else: return None"
            },
            {
                "url": 2004,
                "code": "def _most_common(iterable): data = Counter(iterable) return max(data, key=data.__getitem__)"
            },
            {
                "url": 958,
                "code": "def newest_file(file_iterable): return max(file_iterable, key=lambda fname: os.path.getmtime(fname))"
            },
            {
                "url": 1427,
                "code": "def get_max(qs, field): max_field = '%s__max' % field num = qs.aggregate(Max(field))[max_field] return num if num else 0"
            },
            {
                "url": 5631,
                "code": "def most_frequent(lst): lst = lst[:] highest_freq = 0 most_freq = None for val in unique(lst): if lst.count(val) > highest_freq: most_freq = val highest_freq = lst.count(val) return most_freq"
            },
            {
                "url": 3369,
                "code": "def get_date_field(datetimes, field): return np.array([getattr(date, field) for date in datetimes])"
            },
            {
                "url": 99,
                "code": "def mean_date(dt_list): dt_list_sort = sorted(dt_list) dt_list_sort_rel = [dt - dt_list_sort[0] for dt in dt_list_sort] avg_timedelta = sum(dt_list_sort_rel, timedelta())/len(dt_list_sort_rel) return dt_list_sort[0] + avg_timedelta"
            },
            {
                "url": 2020,
                "code": "def get_date(date): if type(date) is str: return datetime.strptime(date, '%Y-%m-%d').date() else: return date"
            },
            {
                "url": 4215,
                "code": "def max_values(args): return Interval(max(x.low for x in args), max(x.high for x in args))"
            },
            {
                "url": 1983,
                "code": "def argmax(l,f=None): if f: l = [f(i) for i in l] return max(enumerate(l), key=lambda x:x[1])[0]"
            },
            {
                "url": 4571,
                "code": "def find_largest_contig(contig_lengths_dict): # Initialise the dictionary longest_contig_dict = dict() for file_name, contig_lengths in contig_lengths_dict.items(): # As the list is sorted in descending order, the largest contig is the first entry in the list longest_contig_dict[file_name] = contig_lengths[0] return longest_contig_dict"
            },
            {
                "url": 2874,
                "code": "def median_date(dt_list): #dt_list_sort = sorted(dt_list) idx = len(dt_list)/2 if len(dt_list) % 2 == 0: md = mean_date([dt_list[idx-1], dt_list[idx]]) else: md = dt_list[idx] return md"
            },
            {
                "url": 573,
                "code": "def dates_in_range(start_date, end_date): return [ start_date + timedelta(n) for n in range(int((end_date - start_date).days)) ]"
            },
            {
                "url": 3820,
                "code": "def date(start, end): stime = date_to_timestamp(start) etime = date_to_timestamp(end) ptime = stime + random.random() * (etime - stime) return datetime.date.fromtimestamp(ptime)"
            }
        ],
        "url": 4978
    },
    {
        "nl_input": "python lock no blocking",
        "code_input": [
            {
                "url": 739,
                "code": "def lock(self, block=True): self._locked = True return self._lock.acquire(block)"
            },
            {
                "url": 2778,
                "code": "def lock_file(f, block=False): try: flags = fcntl.LOCK_EX if not block: flags |= fcntl.LOCK_NB fcntl.flock(f.fileno(), flags) except IOError as e: if e.errno in (errno.EACCES, errno.EAGAIN): raise SystemExit(\"ERROR: %s is locked by another process.\" % f.name) raise"
            },
            {
                "url": 5017,
                "code": "def assert_lock(fname): if not set_lock(fname): logger.error('File {} is already locked. Terminating.'.format(fname)) sys.exit()"
            },
            {
                "url": 4982,
                "code": "def Unlock(fd, path): try: fcntl.flock(fd, fcntl.LOCK_UN | fcntl.LOCK_NB) except IOError as e: if e.errno == errno.EWOULDBLOCK: raise IOError('Exception unlocking %s. Locked by another process.' % path) else: raise IOError('Exception unlocking %s. %s.' % (path, str(e)))"
            },
            {
                "url": 4640,
                "code": "def __enter__(self): self.fd = open(self.filename, 'a') fcntl.lockf(self.fd, fcntl.LOCK_EX) return self.fd"
            },
            {
                "url": 5144,
                "code": "def acquire_nix(lock_file): # pragma: no cover fd = os.open(lock_file, OPEN_MODE) try: fcntl.flock(fd, fcntl.LOCK_EX | fcntl.LOCK_NB) except (IOError, OSError): os.close(fd) else: return fd"
            },
            {
                "url": 4881,
                "code": "async def acquire_async(self): r = self.acquire(blocking=False) while not r: await asyncio.sleep(.01) r = self.acquire(blocking=False)"
            },
            {
                "url": 5660,
                "code": "def release_lock(): get_lock.n_lock -= 1 assert get_lock.n_lock >= 0 # Only really release lock once all lock requests have ended. if get_lock.lock_is_enabled and get_lock.n_lock == 0: get_lock.start_time = None get_lock.unlocker.unlock()"
            },
            {
                "url": 3105,
                "code": "def blocking(func, *args, **kwargs): pool = get_io_pool() fut = pool.submit(func, *args, **kwargs) return fut.result()"
            },
            {
                "url": 2288,
                "code": "def once(func): lock = threading.Lock() def new_func(*args, **kwargs): if new_func.called: return with lock: if new_func.called: return rv = func(*args, **kwargs) new_func.called = True return rv new_func = update_wrapper(new_func, func) new_func.called = False return new_func"
            },
            {
                "url": 987,
                "code": "def acquire_node(self, node): try: return node.set(self.resource, self.lock_key, nx=True, px=self.ttl) except (redis.exceptions.ConnectionError, redis.exceptions.TimeoutError): return False"
            },
            {
                "url": 155,
                "code": "def get(self): with self._mutex: entry = self._queue.pop() del self._block_map[entry[2]] return entry[2]"
            },
            {
                "url": 835,
                "code": "def _synced(method, self, args, kwargs): with self._lock: return method(*args, **kwargs)"
            },
            {
                "url": 3246,
                "code": "def synchronized(obj): if hasattr(obj, 'synchronizable_condition'): return obj.synchronizable_condition elif callable(obj): @functools.wraps(obj) def wrapper(self, *args, **kwargs): with self.synchronizable_condition: return obj(self, *args, **kwargs) return wrapper else: raise TypeError('expected Synchronizable instance or callable to decorate')"
            },
            {
                "url": 2727,
                "code": "def setblocking(fd, blocking): if not fcntl: warnings.warn('setblocking() not supported on Windows') flags = fcntl.fcntl(fd, fcntl.F_GETFL) if blocking: flags |= os.O_NONBLOCK else: flags &= ~os.O_NONBLOCK fcntl.fcntl(fd, fcntl.F_SETFL, flags)"
            }
        ],
        "url": 739
    },
    {
        "nl_input": "delete item from a set python",
        "code_input": [
            {
                "url": 1114,
                "code": "def discard(self, element): try: i = int(element) set.discard(self, i) except ValueError: pass"
            },
            {
                "url": 4062,
                "code": "def __delitem__(self, key): index, value = self._dict.pop(key) key2, value2 = self._list.pop(index) assert key == key2 assert value is value2 self._fix_indices_after_delete(index)"
            },
            {
                "url": 4874,
                "code": "def __delitem__ (self, key): self._keys.remove(key) super(ListDict, self).__delitem__(key)"
            },
            {
                "url": 1019,
                "code": "def pop(self, index=-1): value = self._list.pop(index) del self._dict[value] return value"
            },
            {
                "url": 1015,
                "code": "def rm_keys_from_dict(d, keys): # Loop for each key given for key in keys: # Is the key in the dictionary? if key in d: try: d.pop(key, None) except KeyError: # Not concerned with an error. Keep going. pass return d"
            },
            {
                "url": 185,
                "code": "def _remove_dict_keys_with_value(dict_, val): return {k: v for k, v in dict_.items() if v is not val}"
            },
            {
                "url": 2569,
                "code": "def _delete_keys(dct, keys): c = deepcopy(dct) assert isinstance(keys, list) for k in keys: c.pop(k) return c"
            },
            {
                "url": 3146,
                "code": "def pop (self, key): if key in self._keys: self._keys.remove(key) super(ListDict, self).pop(key)"
            },
            {
                "url": 2777,
                "code": "def remove(self, key): item = self.item_finder.pop(key) item[-1] = None self.removed_count += 1"
            },
            {
                "url": 3147,
                "code": "def isolate_element(self, x): members = list(self.members(x)) self.delete_set(x) self.union(*(v for v in members if v != x))"
            },
            {
                "url": 4422,
                "code": "def DeleteIndex(self, index): to_remove = None for i in self.Items: if i.index == index: to_remove = i if to_remove: self.Items.remove(to_remove)"
            },
            {
                "url": 3073,
                "code": "def delete(self, row): i = self._get_key_index(row) del self.keys[i]"
            },
            {
                "url": 2281,
                "code": "def _remove_none_values(dictionary): return list(map(dictionary.pop, [i for i in dictionary if dictionary[i] is None]))"
            },
            {
                "url": 5594,
                "code": "def dictlist_wipe_key(dict_list: Iterable[Dict], key: str) -> None: for d in dict_list: d.pop(key, None)"
            },
            {
                "url": 833,
                "code": "def __delitem__(self, key): del self._variables[key] self._coord_names.discard(key)"
            }
        ],
        "url": 5741
    },
    {
        "nl_input": "how to make a sentence into underscores with python",
        "code_input": [
            {
                "url": 2591,
                "code": "def camel_to_underscore(string): string = FIRST_CAP_RE.sub(r'\\1_\\2', string) return ALL_CAP_RE.sub(r'\\1_\\2', string).lower()"
            },
            {
                "url": 718,
                "code": "def camel_case_from_underscores(string): components = string.split('_') string = '' for component in components: string += component[0].upper() + component[1:] return string"
            },
            {
                "url": 5595,
                "code": "def lower_camel_case_from_underscores(string): components = string.split('_') string = components[0] for component in components[1:]: string += component[0].upper() + component[1:] return string"
            },
            {
                "url": 5526,
                "code": "def python(string: str): return underscore(singularize(string) if Naming._pluralize(string) else string)"
            },
            {
                "url": 2571,
                "code": "def camelcase_underscore(name): s1 = re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', name) return re.sub('([a-z0-9])([A-Z])', r'\\1_\\2', s1).lower()"
            },
            {
                "url": 1254,
                "code": "def _make_sentence(txt): #Make sure first letter is capitalized txt = txt.strip(' ') txt = txt[0].upper() + txt[1:] + '.' return txt"
            },
            {
                "url": 3499,
                "code": "def camel_to_under(name): s1 = re.sub(\"(.)([A-Z][a-z]+)\", r\"\\1_\\2\", name) return re.sub(\"([a-z0-9])([A-Z])\", r\"\\1_\\2\", s1).lower()"
            },
            {
                "url": 3683,
                "code": "def to_camel(s): # r'(?!^)_([a-zA-Z]) original regex wasn't process first groups return re.sub(r'_([a-zA-Z])', lambda m: m.group(1).upper(), '_' + s)"
            },
            {
                "url": 1625,
                "code": "def to_capitalized_camel_case(snake_case_string): parts = snake_case_string.split('_') return ''.join([i.title() for i in parts])"
            },
            {
                "url": 83,
                "code": "def underscore(text): return UNDERSCORE[1].sub(r'\\1_\\2', UNDERSCORE[0].sub(r'\\1_\\2', text)).lower()"
            },
            {
                "url": 5767,
                "code": "def camel_to_snake_case(string): s = _1.sub(r'\\1_\\2', string) return _2.sub(r'\\1_\\2', s).lower()"
            },
            {
                "url": 5422,
                "code": "def parse_case_snake_to_camel(snake, upper_first=True): snake = snake.split('_') first_part = snake[0] if upper_first: first_part = first_part.title() return first_part + ''.join(word.title() for word in snake[1:])"
            },
            {
                "url": 5818,
                "code": "def fmt_camel(name): words = split_words(name) assert len(words) > 0 first = words.pop(0).lower() return first + ''.join([word.capitalize() for word in words])"
            },
            {
                "url": 902,
                "code": "def to_camel_case(snake_case_string): parts = snake_case_string.lstrip('_').split('_') return parts[0] + ''.join([i.title() for i in parts[1:]])"
            },
            {
                "url": 525,
                "code": "def to_camel_case(text): split = text.split('_') return split[0] + \"\".join(x.title() for x in split[1:])"
            }
        ],
        "url": 358
    },
    {
        "nl_input": "python timestamp remove timezone",
        "code_input": [
            {
                "url": 1946,
                "code": "def normalize_time(timestamp): offset = timestamp.utcoffset() if offset is None: return timestamp return timestamp.replace(tzinfo=None) - offset"
            },
            {
                "url": 2199,
                "code": "def clean_time(time_string): # Get a timezone-aware datetime object from the string time = dateutil.parser.parse(time_string) if not settings.USE_TZ: # If timezone support is not active, convert the time to UTC and # remove the timezone field time = time.astimezone(timezone.utc).replace(tzinfo=None) return time"
            },
            {
                "url": 127,
                "code": "def parse_timestamp(timestamp): dt = dateutil.parser.parse(timestamp) return dt.astimezone(dateutil.tz.tzutc())"
            },
            {
                "url": 6030,
                "code": "def timestamp_with_tzinfo(dt): utc = tzutc() if dt.tzinfo: dt = dt.astimezone(utc).replace(tzinfo=None) return dt.isoformat() + 'Z'"
            },
            {
                "url": 117,
                "code": "def datetime_to_timezone(date, tz=\"UTC\"): if not date.tzinfo: date = date.replace(tzinfo=timezone(get_timezone())) return date.astimezone(timezone(tz))"
            },
            {
                "url": 1639,
                "code": "def timestamp_to_datetime(cls, time_stamp, localized=True): ret = datetime.datetime.utcfromtimestamp(time_stamp) if localized: ret = localize(ret, pytz.utc) return ret"
            },
            {
                "url": 1706,
                "code": "def timestamp_from_datetime(dt): try: utc_dt = dt.astimezone(pytz.utc) except ValueError: utc_dt = dt.replace(tzinfo=pytz.utc) return timegm(utc_dt.timetuple())"
            },
            {
                "url": 1621,
                "code": "def unixtime_to_datetime(ut): dt = datetime.datetime.utcfromtimestamp(ut) dt = dt.replace(tzinfo=tz.tzutc()) return dt"
            },
            {
                "url": 5515,
                "code": "def convert_timezone(obj, timezone): if timezone is None: return obj.replace(tzinfo=None) return pytz.timezone(timezone).localize(obj)"
            },
            {
                "url": 1892,
                "code": "def format_timestamp(timestamp): tz_info = tz.tzutc() return datetime.fromtimestamp(timestamp, tz=tz_info).strftime(\"%Y-%m-%dT%H:%M:%S.000Z\")"
            },
            {
                "url": 5062,
                "code": "def utcfromtimestamp(cls, timestamp): obj = datetime.datetime.utcfromtimestamp(timestamp) obj = pytz.utc.localize(obj) return cls(obj)"
            },
            {
                "url": 3998,
                "code": "def _strptime(self, time_str): if time_str: # Parse UTC string into naive datetime, then add timezone dt = datetime.strptime(time_str, __timeformat__) return dt.replace(tzinfo=UTC()) return None"
            },
            {
                "url": 1159,
                "code": "def datetime_from_timestamp(timestamp, content): return set_date_tzinfo( datetime.fromtimestamp(timestamp), tz_name=content.settings.get('TIMEZONE', None))"
            },
            {
                "url": 377,
                "code": "def convert_timestamp(timestamp): datetime = dt.datetime.utcfromtimestamp(timestamp/1000.) return np.datetime64(datetime.replace(tzinfo=None))"
            },
            {
                "url": 129,
                "code": "def fromtimestamp(cls, timestamp): d = cls.utcfromtimestamp(timestamp) return d.astimezone(localtz())"
            }
        ],
        "url": 1581
    },
    {
        "nl_input": "python sanic change all object id to string",
        "code_input": [
            {
                "url": 4302,
                "code": "def generate_id(self, obj): object_type = type(obj).__name__.lower() return '{}_{}'.format(object_type, self.get_object_id(obj))"
            },
            {
                "url": 2987,
                "code": "def pythonise(id, encoding='ascii'): replace = {'-': '_', ':': '_', '/': '_'} func = lambda id, pair: id.replace(pair[0], pair[1]) id = reduce(func, replace.iteritems(), id) id = '_%s' % id if id[0] in string.digits else id return id.encode(encoding)"
            },
            {
                "url": 2806,
                "code": "def to_str(obj): if not isinstance(obj, str) and PY3 and isinstance(obj, bytes): obj = obj.decode('utf-8') return obj if isinstance(obj, string_types) else str(obj)"
            },
            {
                "url": 2355,
                "code": "def generate_id(): # TODO: Use six.string_type to Py3 compat try: return unicode(uuid1()).replace(u\"-\", u\"\") except NameError: return str(uuid1()).replace(u\"-\", u\"\")"
            },
            {
                "url": 3343,
                "code": "def slugify(string): string = re.sub('[^\\w .-]', '', string) string = string.replace(\" \", \"-\") return string"
            },
            {
                "url": 5541,
                "code": "def string(value) -> str: return system_json.dumps(Json(value).safe_object(), ensure_ascii=False)"
            },
            {
                "url": 1121,
                "code": "def check_str(obj): if isinstance(obj, str): return obj if isinstance(obj, float): return str(int(obj)) else: return str(obj)"
            },
            {
                "url": 3353,
                "code": "def _clean_name(self, prefix, obj): return '{}{}_{}'.format(prefix, self._uid(), ''.join(c for c in obj.name if c.isalnum()))"
            },
            {
                "url": 4911,
                "code": "def identifierify(name): name = name.lower() name = re.sub('[^a-z0-9]', '_', name) return name"
            },
            {
                "url": 5526,
                "code": "def python(string: str): return underscore(singularize(string) if Naming._pluralize(string) else string)"
            },
            {
                "url": 865,
                "code": "def json_datetime_serial(obj): if isinstance(obj, (datetime, date)): serial = obj.isoformat() return serial if ObjectId is not None and isinstance(obj, ObjectId): # TODO: try to use bson.json_util instead return str(obj) raise TypeError(\"Type not serializable\")"
            },
            {
                "url": 1117,
                "code": "def normalise_string(string): string = (string.strip()).lower() return re.sub(r'\\W+', '_', string)"
            },
            {
                "url": 3386,
                "code": "def setobjattr(obj, key, value): try: setattr(obj, key, int(value)) except ValueError: try: setattr(obj, key, float(value)) except ValueError: # string if not number try: setattr(obj, key, str(value)) except UnicodeEncodeError: setattr(obj, key, value)"
            },
            {
                "url": 738,
                "code": "def to_identifier(s): if s.startswith('GPS'): s = 'Gps' + s[3:] return ''.join([i.capitalize() for i in s.split('_')]) if '_' in s else s"
            },
            {
                "url": 1439,
                "code": "def seq_to_str(obj, sep=\",\"): if isinstance(obj, string_classes): return obj elif isinstance(obj, (list, tuple)): return sep.join([str(x) for x in obj]) else: return str(obj)"
            }
        ],
        "url": 4302
    },
    {
        "nl_input": "python mock mark a test as expected failure",
        "code_input": [
            {
                "url": 4220,
                "code": "def assert_called(_mock_self): self = _mock_self if self.call_count == 0: msg = (\"Expected '%s' to have been called.\" % self._mock_name or 'mock') raise AssertionError(msg)"
            },
            {
                "url": 2124,
                "code": "def assert_any_call(self, *args, **kwargs): kall = call(*args, **kwargs) if kall not in self.call_args_list: expected_string = self._format_mock_call_signature(args, kwargs) raise AssertionError( '%s call not found' % expected_string )"
            },
            {
                "url": 4268,
                "code": "def assert_called_once(_mock_self): self = _mock_self if not self.call_count == 1: msg = (\"Expected '%s' to have been called once. Called %s times.\" % (self._mock_name or 'mock', self.call_count)) raise AssertionError(msg)"
            },
            {
                "url": 5222,
                "code": "def __call__(self, actual_value, expect): self._expect = expect if self.expected_value is NO_ARG: return self.asserts(actual_value) return self.asserts(actual_value, self.expected_value)"
            },
            {
                "url": 1307,
                "code": "def assert_is_not(expected, actual, message=None, extra=None): assert expected is not actual, _assert_fail_message( message, expected, actual, \"is\", extra )"
            },
            {
                "url": 3920,
                "code": "def api_test(method='GET', **response_kwargs): method = method.lower() def api_test_factory(fn): @functools.wraps(fn) @mock.patch('requests.{}'.format(method)) def execute_test(method_func, *args, **kwargs): method_func.return_value = MockResponse(**response_kwargs) expected_url, response = fn(*args, **kwargs) method_func.assert_called_once() assert_valid_api_call(method_func, expected_url) assert isinstance(response, JSONAPIParser) assert response.json_data is method_func.return_value.data return execute_test return api_test_factory"
            },
            {
                "url": 1619,
                "code": "def test_kwargs_are_optional(self): with patch(\"sys.exit\") as mock_exit: cli = MicroCLITestCase.T(\"script_name f3\".split()).run() # kwargs are optional mock_exit.assert_called_with(4)"
            },
            {
                "url": 1493,
                "code": "def test(): # pragma: no cover import pytest import os pytest.main([os.path.dirname(os.path.abspath(__file__))])"
            },
            {
                "url": 1375,
                "code": "def mock_decorator(*args, **kwargs): def _called_decorator(dec_func): @wraps(dec_func) def _decorator(*args, **kwargs): return dec_func() return _decorator return _called_decorator"
            },
            {
                "url": 1260,
                "code": "def retry_test(func): success = False ex = Exception(\"Unknown\") for i in six.moves.range(3): try: result = func() except Exception as e: time.sleep(1) ex = e else: success = True break if not success: raise ex assert success return result"
            },
            {
                "url": 118,
                "code": "def test(*args): subprocess.call([\"py.test-2.7\"] + list(args)) subprocess.call([\"py.test-3.4\"] + list(args))"
            },
            {
                "url": 4372,
                "code": "def raises_regex(self, expected_exception, expected_regexp): return unittest_case.assertRaisesRegexp(expected_exception, expected_regexp, self._orig_subject, *self._args, **self._kwargs)"
            },
            {
                "url": 6184,
                "code": "def assert_raises(ex_type, func, *args, **kwargs): r try: func(*args, **kwargs) except Exception as ex: assert isinstance(ex, ex_type), ( 'Raised %r but type should have been %r' % (ex, ex_type)) return True else: raise AssertionError('No error was raised')"
            },
            {
                "url": 4218,
                "code": "def __setitem__(self, _ignored, return_value): self.mock.return_value = return_value self.mock.side_effect = None"
            },
            {
                "url": 6088,
                "code": "def assert_or_raise(stmt: bool, exception: Exception, *exception_args, **exception_kwargs) -> None: if not stmt: raise exception(*exception_args, **exception_kwargs)"
            }
        ],
        "url": 4220
    },
    {
        "nl_input": "python get current users desktop",
        "code_input": [
            {
                "url": 4922,
                "code": "def get_current_desktop(self): desktop = ctypes.c_long(0) _libxdo.xdo_get_current_desktop(self._xdo, ctypes.byref(desktop)) return desktop.value"
            },
            {
                "url": 965,
                "code": "def get_user_name(): if sys.platform == 'win32': #user = os.getenv('USERPROFILE') user = os.getenv('USERNAME') else: user = os.getenv('LOGNAME') return user"
            },
            {
                "url": 2932,
                "code": "def user_exists(username): try: pwd.getpwnam(username) user_exists = True except KeyError: user_exists = False return user_exists"
            },
            {
                "url": 245,
                "code": "def _is_root(): import os import ctypes try: return os.geteuid() == 0 except AttributeError: return ctypes.windll.shell32.IsUserAnAdmin() != 0 return False"
            },
            {
                "url": 3237,
                "code": "def load_logged_in_user(): user_id = session.get(\"user_id\") g.user = User.query.get(user_id) if user_id is not None else None"
            },
            {
                "url": 2734,
                "code": "def get_screen_resolution(self): widget = QDesktopWidget() geometry = widget.availableGeometry(widget.primaryScreen()) return geometry.width(), geometry.height()"
            },
            {
                "url": 668,
                "code": "def get_python(): if sys.platform == 'win32': python = path.join(VE_ROOT, 'Scripts', 'python.exe') else: python = path.join(VE_ROOT, 'bin', 'python') return python"
            },
            {
                "url": 5994,
                "code": "def local_machine_uuid(): result = subprocess.check_output( 'hal-get-property --udi ' '/org/freedesktop/Hal/devices/computer ' '--key system.hardware.uuid'.split() ).strip() return uuid.UUID(hex=result)"
            },
            {
                "url": 416,
                "code": "def me(self): return self.guild.me if self.guild is not None else self.bot.user"
            },
            {
                "url": 4387,
                "code": "def setAsApplication(myappid): if os.name == 'nt': import ctypes ctypes.windll.shell32.SetCurrentProcessExplicitAppUserModelID(myappid)"
            },
            {
                "url": 963,
                "code": "def get_system_uid(): try: if os.name == 'nt': return get_nt_system_uid() if sys.platform == 'darwin': return get_osx_system_uid() except Exception: return get_mac_uid() else: return get_mac_uid()"
            },
            {
                "url": 4174,
                "code": "def getWindowPID(self, hwnd): pid = ctypes.c_ulong() ctypes.windll.user32.GetWindowThreadProcessId(hwnd, ctypes.byref(pid)) return int(pid.value)"
            },
            {
                "url": 1029,
                "code": "def copy_user_agent_from_driver(self): selenium_user_agent = self.driver.execute_script(\"return navigator.userAgent;\") self.headers.update({\"user-agent\": selenium_user_agent})"
            },
            {
                "url": 3427,
                "code": "def get_active_window(): active_win = None default = wnck.screen_get_default() while gtk.events_pending(): gtk.main_iteration(False) window_list = default.get_windows() if len(window_list) == 0: print \"No Windows Found\" for win in window_list: if win.is_active(): active_win = win.get_name() return active_win"
            },
            {
                "url": 595,
                "code": "async def sysinfo(dev: Device): click.echo(await dev.get_system_info()) click.echo(await dev.get_interface_information())"
            }
        ],
        "url": 4922
    },
    {
        "nl_input": "python connect to redis in other docker container",
        "code_input": [
            {
                "url": 4711,
                "code": "def connect(self): self.client = redis.Redis( host=self.host, port=self.port, password=self.password)"
            },
            {
                "url": 5420,
                "code": "def get_connection(self, host, port, db): return redis.StrictRedis( host=host, port=port, db=db, decode_responses=True )"
            },
            {
                "url": 2168,
                "code": "def __connect(): global redis_instance if use_tcp_socket: redis_instance = redis.StrictRedis(host=hostname, port=port) else: redis_instance = redis.StrictRedis(unix_socket_path=unix_socket)"
            },
            {
                "url": 2564,
                "code": "def from_url(url, db=None, **kwargs): from redis.client import Redis return Redis.from_url(url, db, **kwargs)"
            },
            {
                "url": 24,
                "code": "def connect_mysql(host, port, user, password, database): return pymysql.connect( host=host, port=port, user=user, passwd=password, db=database )"
            },
            {
                "url": 985,
                "code": "def exit(self): self.pubsub.unsubscribe() self.client.connection_pool.disconnect() logger.info(\"Connection to Redis closed\")"
            },
            {
                "url": 5229,
                "code": "def connect_rds(aws_access_key_id=None, aws_secret_access_key=None, **kwargs): from boto.rds import RDSConnection return RDSConnection(aws_access_key_id, aws_secret_access_key, **kwargs)"
            },
            {
                "url": 3450,
                "code": "def connect(*args, **kwargs): global __CONNECTION if __CONNECTION is None: __CONNECTION = Connection(*args, **kwargs) return __CONNECTION"
            },
            {
                "url": 3776,
                "code": "def get(self, key): value = redis_conn.get(key) if value is not None: value = pickle.loads(value) return value"
            },
            {
                "url": 4705,
                "code": "def attach_to_container(self, container_id): sock = self._docker.containers.get(container_id).attach_socket(params={ 'stdin': 1, 'stdout': 1, 'stderr': 0, 'stream': 1, }) # fix a problem with docker-py; we must keep a reference of sock at every time return FixDockerSocket(sock)"
            },
            {
                "url": 350,
                "code": "def connect(host, port, username, password): # Instantiate ftplib client session = ftplib.FTP() # Connect to host without auth session.connect(host, port) # Authenticate connection session.login(username, password) return session"
            },
            {
                "url": 1266,
                "code": "def get_pg_connection(host, user, port, password, database, ssl={}): return psycopg2.connect(host=host, user=user, port=port, password=password, dbname=database, sslmode=ssl.get('sslmode', None), sslcert=ssl.get('sslcert', None), sslkey=ssl.get('sslkey', None), sslrootcert=ssl.get('sslrootcert', None), )"
            },
            {
                "url": 5738,
                "code": "def interact(self, container: Container) -> None: cmd = \"/bin/bash -c 'source /.environment && /bin/bash'\" cmd = \"docker exec -it {} {}\".format(container.id, cmd) subprocess.call(cmd, shell=True)"
            },
            {
                "url": 5424,
                "code": "def connect(self): self.socket = socket.create_connection(self.address, self.timeout)"
            },
            {
                "url": 846,
                "code": "def start_connect(self): Log.debug(\"In start_connect() of %s\" % self._get_classname()) # TODO: specify buffer size, exception handling self.create_socket(socket.AF_INET, socket.SOCK_STREAM) # when ready, handle_connect is called self._connecting = True self.connect(self.endpoint)"
            }
        ],
        "url": 2168
    },
    {
        "nl_input": "python subplot second y axis",
        "code_input": [
            {
                "url": 5262,
                "code": "def activate_subplot(numPlot): # see http://www.mail-archive.com/matplotlib-users@lists.sourceforge.net/msg07156.html from pylab import gcf, axes numPlot -= 1 # index is 0-based, plots are 1-based return axes(gcf().get_axes()[numPlot])"
            },
            {
                "url": 2426,
                "code": "def show_yticklabels(self, row, column): subplot = self.get_subplot_at(row, column) subplot.show_yticklabels()"
            },
            {
                "url": 790,
                "code": "def set_ylimits(self, row, column, min=None, max=None): subplot = self.get_subplot_at(row, column) subplot.set_ylimits(min, max)"
            },
            {
                "url": 3693,
                "code": "def plot3d_init(fignum): from mpl_toolkits.mplot3d import Axes3D fig = plt.figure(fignum) ax = fig.add_subplot(111, projection='3d') return ax"
            },
            {
                "url": 944,
                "code": "def show_xticklabels(self, row, column): subplot = self.get_subplot_at(row, column) subplot.show_xticklabels()"
            },
            {
                "url": 2368,
                "code": "def set_axis_options(self, row, column, text): subplot = self.get_subplot_at(row, column) subplot.set_axis_options(text)"
            },
            {
                "url": 3455,
                "code": "def set_xlimits(self, row, column, min=None, max=None): subplot = self.get_subplot_at(row, column) subplot.set_xlimits(min, max)"
            },
            {
                "url": 1352,
                "code": "def add_plot(x, y, xl, yl, fig, ax, LATEX=False, linestyle=None, **kwargs): if LATEX: xl_data = xl[1] # NOQA yl_data = yl[1] else: xl_data = xl[0] # NOQA yl_data = yl[0] for idx in range(len(y)): ax.plot(x, y[idx], label=yl_data[idx], linestyle=linestyle) ax.legend(loc='upper right') ax.set_ylim(auto=True)"
            },
            {
                "url": 1311,
                "code": "def finish_plot(): plt.legend() plt.grid(color='0.7') plt.xlabel('x') plt.ylabel('y') plt.show()"
            },
            {
                "url": 2330,
                "code": "def plot_and_save(self, **kwargs): self.fig = pyplot.figure() self.plot() self.axes = pyplot.gca() self.save_plot(self.fig, self.axes, **kwargs) pyplot.close(self.fig)"
            },
            {
                "url": 4430,
                "code": "def get_subplot_at(self, row, column): idx = row * self.columns + column return self.subplots[idx]"
            },
            {
                "url": 5402,
                "code": "def PyplotHistogram(): import numpy as np import matplotlib.pyplot as plt np.random.seed(0) n_bins = 10 x = np.random.randn(1000, 3) fig, axes = plt.subplots(nrows=2, ncols=2) ax0, ax1, ax2, ax3 = axes.flatten() colors = ['red', 'tan', 'lime'] ax0.hist(x, n_bins, normed=1, histtype='bar', color=colors, label=colors) ax0.legend(prop={'size': 10}) ax0.set_title('bars with legend') ax1.hist(x, n_bins, normed=1, histtype='bar', stacked=True) ax1.set_title('stacked bar') ax2.hist(x, n_bins, histtype='step', stacked=True, fill=False) ax2.set_title('stack step (unfilled)') # Make a multiple-histogram of data-sets with different length. x_multi = [np.random.randn(n) for n in [10000, 5000, 2000]] ax3.hist(x_multi, n_bins, histtype='bar') ax3.set_title('different sample sizes') fig.tight_layout() return fig"
            },
            {
                "url": 5291,
                "code": "def _enter_plotting(self, fontsize=9): # interactive_status = matplotlib.is_interactive() self.original_fontsize = pyplot.rcParams['font.size'] pyplot.rcParams['font.size'] = fontsize pyplot.hold(False) # opens a figure window, if non exists pyplot.ioff()"
            },
            {
                "url": 3735,
                "code": "def oplot(self, x, y, **kw): self.panel.oplot(x, y, **kw)"
            },
            {
                "url": 788,
                "code": "def clear_matplotlib_ticks(self, axis=\"both\"): ax = self.get_axes() plotting.clear_matplotlib_ticks(ax=ax, axis=axis)"
            }
        ],
        "url": 2426
    },
    {
        "nl_input": "python function to detect first element of list",
        "code_input": [
            {
                "url": 5545,
                "code": "def find_first_in_list(txt: str, str_list: [str]) -> int: # type: ignore start = len(txt) + 1 for item in str_list: if start > txt.find(item) > -1: start = txt.find(item) return start if len(txt) + 1 > start > -1 else -1"
            },
            {
                "url": 5327,
                "code": "def _find_first_of(line, substrings): starts = ((line.find(i), i) for i in substrings) found = [(i, sub) for i, sub in starts if i != -1] if found: return min(found) else: return -1, None"
            },
            {
                "url": 6018,
                "code": "def find_first(pattern: str, path: str) -> str: try: return find(pattern, path)[0] except IndexError: log.critical('''Couldn't find \"{}\" in \"{}\"''', pattern, path) raise"
            },
            {
                "url": 598,
                "code": "def findfirst(f, coll): result = list(dropwhile(f, coll)) return result[0] if result else None"
            },
            {
                "url": 192,
                "code": "def _check_elements_equal(lst): assert isinstance(lst, list), \"Input value must be a list.\" return not lst or lst.count(lst[0]) == len(lst)"
            },
            {
                "url": 2136,
                "code": "def allsame(list_, strict=True): if len(list_) == 0: return True first_item = list_[0] return list_all_eq_to(list_, first_item, strict)"
            },
            {
                "url": 1094,
                "code": "def find_first_number(ll): for nr, entry in enumerate(ll): try: float(entry) except (ValueError, TypeError) as e: pass else: return nr return None"
            },
            {
                "url": 4172,
                "code": "def find_last_sublist(list_, sublist): for i in reversed(range(len(list_) - len(sublist) + 1)): if list_[i] == sublist[0] and list_[i:i + len(sublist)] == sublist: return i return None"
            },
            {
                "url": 5341,
                "code": "def assert_single_element(iterable): it = iter(iterable) first_item = next(it) try: next(it) except StopIteration: return first_item raise ValueError(\"iterable {!r} has more than one element.\".format(iterable))"
            },
            {
                "url": 648,
                "code": "def isin(elems, line): found = False for e in elems: if e in line.lower(): found = True break return found"
            },
            {
                "url": 4959,
                "code": "def check_if_numbers_are_consecutive(list_): return all((True if second - first == 1 else False for first, second in zip(list_[:-1], list_[1:])))"
            },
            {
                "url": 2314,
                "code": "def where_is(strings, pattern, n=1, lookup_func=re.match): count = 0 for idx, item in enumerate(strings): if lookup_func(pattern, item): count += 1 if count == n: return idx return -1"
            },
            {
                "url": 1782,
                "code": "def is_list_of_list(item): if ( type(item) in (list, tuple) and len(item) and isinstance(item[0], (list, tuple)) ): return True return False"
            },
            {
                "url": 5029,
                "code": "def compare(self, first, second): if first.lower() == second.lower(): return True else: return False"
            },
            {
                "url": 2332,
                "code": "def validate_string_list(lst): if not isinstance(lst, list): raise ValueError('input %r must be a list' % lst) for x in lst: if not isinstance(x, basestring): raise ValueError('element %r in list must be a string' % x)"
            }
        ],
        "url": 5545
    },
    {
        "nl_input": "how to flip a matrix in python",
        "code_input": [
            {
                "url": 538,
                "code": "def imflip(img, direction='horizontal'): assert direction in ['horizontal', 'vertical'] if direction == 'horizontal': return np.flip(img, axis=1) else: return np.flip(img, axis=0)"
            },
            {
                "url": 540,
                "code": "def hflip(img): if not _is_pil_image(img): raise TypeError('img should be PIL Image. Got {}'.format(type(img))) return img.transpose(Image.FLIP_LEFT_RIGHT)"
            },
            {
                "url": 4838,
                "code": "def flipwritable(fn, mode=None): if os.access(fn, os.W_OK): return None old_mode = os.stat(fn).st_mode os.chmod(fn, stat.S_IWRITE | old_mode) return old_mode"
            },
            {
                "url": 4615,
                "code": "def inverse(self): invr = np.linalg.inv(self.affine_matrix) return SymmOp(invr)"
            },
            {
                "url": 1993,
                "code": "def rotateImage(image, angle): image = [list(row) for row in image] for n in range(angle % 4): image = list(zip(*image[::-1])) return image"
            },
            {
                "url": 2431,
                "code": "def _swap_rows(self, i, j): L = np.eye(3, dtype='intc') L[i, i] = 0 L[j, j] = 0 L[i, j] = 1 L[j, i] = 1 self._L.append(L.copy()) self._A = np.dot(L, self._A)"
            },
            {
                "url": 3843,
                "code": "def symmetrise(matrix, tri='upper'): if tri == 'upper': tri_fn = np.triu_indices else: tri_fn = np.tril_indices size = matrix.shape[0] matrix[tri_fn(size)[::-1]] = matrix[tri_fn(size)] return matrix"
            },
            {
                "url": 619,
                "code": "def uint32_to_uint8(cls, img): return np.flipud(img.view(dtype=np.uint8).reshape(img.shape + (4,)))"
            },
            {
                "url": 1890,
                "code": "def matrix_to_gl(matrix): matrix = np.asanyarray(matrix, dtype=np.float64) if matrix.shape != (4, 4): raise ValueError('matrix must be (4,4)!') # switch to column major and flatten to (16,) column = matrix.T.flatten() # convert to GLfloat glmatrix = (gl.GLfloat * 16)(*column) return glmatrix"
            },
            {
                "url": 5652,
                "code": "def _reshuffle(mat, shape): return np.reshape( np.transpose(np.reshape(mat, shape), (3, 1, 2, 0)), (shape[3] * shape[1], shape[0] * shape[2]))"
            },
            {
                "url": 826,
                "code": "def generate_matrices(dim = 40): positive = numpy.random.uniform(-1, 1, (dim, dim)) negative = positive + numpy.random.normal(0, 1, (dim, dim)) return positive, negative"
            },
            {
                "url": 2609,
                "code": "def rotateImage(img, angle): imgR = scipy.ndimage.rotate(img, angle, reshape=False) return imgR"
            },
            {
                "url": 3439,
                "code": "def invert(dict_): ensure_mapping(dict_) return dict_.__class__(izip(itervalues(dict_), iterkeys(dict_)))"
            },
            {
                "url": 2526,
                "code": "def trans_from_matrix(matrix): t = np.zeros((4, 4)) for i in range(4): for j in range(4): t[i, j] = matrix.GetElement(i, j) return t"
            },
            {
                "url": 2512,
                "code": "def MatrixInverse(a, adj): return np.linalg.inv(a if not adj else _adjoint(a)),"
            }
        ],
        "url": 538
    },
    {
        "nl_input": "python full name of object from global",
        "code_input": [
            {
                "url": 1933,
                "code": "def get_qualified_name(_object): module = _object.__module__ if hasattr(_object, '__name__'): _class = _object.__name__ else: _class = _object.__class__.__name__ return module + '.' + _class"
            },
            {
                "url": 354,
                "code": "def _fullname(o): return o.__module__ + \".\" + o.__name__ if o.__module__ else o.__name__"
            },
            {
                "url": 1917,
                "code": "def class_name(obj): name = obj.__name__ module = getattr(obj, '__module__') if module: name = f'{module}.{name}' return name"
            },
            {
                "url": 1888,
                "code": "def load_object_by_name(object_name): mod_name, attr = object_name.rsplit('.', 1) mod = import_module(mod_name) return getattr(mod, attr)"
            },
            {
                "url": 3157,
                "code": "def object_type_repr(obj): if obj is None: return 'None' elif obj is Ellipsis: return 'Ellipsis' if obj.__class__.__module__ == '__builtin__': name = obj.__class__.__name__ else: name = obj.__class__.__module__ + '.' + obj.__class__.__name__ return '%s object' % name"
            },
            {
                "url": 1867,
                "code": "def get_func_name(func): func_name = getattr(func, '__name__', func.__class__.__name__) module_name = func.__module__ if module_name is not None: module_name = func.__module__ return '{}.{}'.format(module_name, func_name) return func_name"
            },
            {
                "url": 2061,
                "code": "def typename(obj): if hasattr(obj, '__class__'): return getattr(obj, '__class__').__name__ else: return type(obj).__name__"
            },
            {
                "url": 6188,
                "code": "def get_caller_module(): stack = inspect.stack() assert len(stack) > 1 caller = stack[2][0] return caller.f_globals['__name__']"
            },
            {
                "url": 383,
                "code": "def get_method_name(method): name = get_object_name(method) if name.startswith(\"__\") and not name.endswith(\"__\"): name = \"_{0}{1}\".format(get_object_name(method.im_class), name) return name"
            },
            {
                "url": 2890,
                "code": "def qualified_name_import(cls): parts = qualified_name(cls).split('.') return \"from {} import {}\".format('.'.join(parts[:-1]), parts[-1])"
            },
            {
                "url": 5279,
                "code": "def load_member(fqn): modulename, member_name = split_fqn(fqn) module = __import__(modulename, globals(), locals(), member_name) return getattr(module, member_name)"
            },
            {
                "url": 3554,
                "code": "def get_function(function_name): module, basename = str(function_name).rsplit('.', 1) try: return getattr(__import__(module, fromlist=[basename]), basename) except (ImportError, AttributeError): raise FunctionNotFound(function_name)"
            },
            {
                "url": 2754,
                "code": "def str_to_class(class_name): mod_str, cls_str = class_name.rsplit('.', 1) mod = __import__(mod_str, globals(), locals(), ['']) cls = getattr(mod, cls_str) return cls"
            },
            {
                "url": 5526,
                "code": "def python(string: str): return underscore(singularize(string) if Naming._pluralize(string) else string)"
            },
            {
                "url": 3596,
                "code": "def _get_var_from_string(item): modname, varname = _split_mod_var_names(item) if modname: mod = __import__(modname, globals(), locals(), [varname], -1) return getattr(mod, varname) else: return globals()[varname]"
            }
        ],
        "url": 354
    },
    {
        "nl_input": "check if input is an integer or boolean python",
        "code_input": [
            {
                "url": 5567,
                "code": "def is_integer(value: Any) -> bool: return (isinstance(value, int) and not isinstance(value, bool)) or ( isinstance(value, float) and isfinite(value) and int(value) == value )"
            },
            {
                "url": 637,
                "code": "def is_int(value): if isinstance(value, bool): return False try: int(value) return True except (ValueError, TypeError): return False"
            },
            {
                "url": 2128,
                "code": "def is_integer(obj): if PYTHON3: return isinstance(obj, int) return isinstance(obj, (int, long))"
            },
            {
                "url": 1791,
                "code": "def is_int(string): try: a = float(string) b = int(a) except ValueError: return False else: return a == b"
            },
            {
                "url": 4975,
                "code": "def is_integer(dtype): dtype = tf.as_dtype(dtype) if hasattr(dtype, 'is_integer'): return dtype.is_integer return np.issubdtype(np.dtype(dtype), np.integer)"
            },
            {
                "url": 2437,
                "code": "def check_int(integer): if not isinstance(integer, str): return False if integer[0] in ('-', '+'): return integer[1:].isdigit() return integer.isdigit()"
            },
            {
                "url": 3356,
                "code": "def is_number(obj): return isinstance(obj, (int, float, np.int_, np.float_))"
            },
            {
                "url": 1329,
                "code": "def validate_int(value): if value and not isinstance(value, int): try: int(str(value)) except (TypeError, ValueError): raise ValidationError('not a valid number') return value"
            },
            {
                "url": 3523,
                "code": "def is_int_type(val): try: # Python 2 return isinstance(val, (int, long)) except NameError: # Python 3 return isinstance(val, int)"
            },
            {
                "url": 2675,
                "code": "def is_integer_array(val): return is_np_array(val) and issubclass(val.dtype.type, np.integer)"
            },
            {
                "url": 2429,
                "code": "def numberp(v): return (not(isinstance(v, bool)) and (isinstance(v, int) or isinstance(v, float)))"
            },
            {
                "url": 761,
                "code": "def isnumber(*args): return all(map(lambda c: isinstance(c, int) or isinstance(c, float), args))"
            },
            {
                "url": 3056,
                "code": "def is_value_type_valid_for_exact_conditions(self, value): # No need to check for bool since bool is a subclass of int if isinstance(value, string_types) or isinstance(value, (numbers.Integral, float)): return True return False"
            },
            {
                "url": 5776,
                "code": "def _isint(string): return type(string) is int or \\ (isinstance(string, _binary_type) or isinstance(string, _text_type)) and \\ _isconvertible(int, string)"
            },
            {
                "url": 289,
                "code": "def _check_for_int(x): try: y = int(x) except (OverflowError, ValueError): pass else: # There is no way in AMF0 to distinguish between integers and floats if x == x and y == x: return y return x"
            }
        ],
        "url": 5567
    },
    {
        "nl_input": "storing columns as array python",
        "code_input": [
            {
                "url": 1583,
                "code": "def dict_to_numpy_array(d): return fromarrays(d.values(), np.dtype([(str(k), v.dtype) for k, v in d.items()]))"
            },
            {
                "url": 5209,
                "code": "def to_array(self): dt = np.dtype(list(zip(self.labels, (c.dtype for c in self.columns)))) arr = np.empty_like(self.columns[0], dt) for label in self.labels: arr[label] = self[label] return arr"
            },
            {
                "url": 5746,
                "code": "def csv_to_numpy(string_like, dtype=None): # type: (str) -> np.array stream = StringIO(string_like) return np.genfromtxt(stream, dtype=dtype, delimiter=',')"
            },
            {
                "url": 1513,
                "code": "def to_dicts(recarray): for rec in recarray: yield dict(zip(recarray.dtype.names, rec.tolist()))"
            },
            {
                "url": 4776,
                "code": "def _ndarray_representer(dumper, data): mapping = [('object', data.tolist()), ('dtype', data.dtype.name)] return dumper.represent_mapping(_NUMPY_ARRAY_TAG, mapping)"
            },
            {
                "url": 2169,
                "code": "def from_array(cls, arr): return cls().with_columns([(f, arr[f]) for f in arr.dtype.names])"
            },
            {
                "url": 2619,
                "code": "def dump_nparray(self, obj, class_name=numpy_ndarray_class_name): return {\"$\" + class_name: self._json_convert(obj.tolist())}"
            },
            {
                "url": 6117,
                "code": "def numpy_to_yaml(representer: Representer, data: np.ndarray) -> Sequence[Any]: return representer.represent_sequence( \"!numpy_array\", data.tolist() )"
            },
            {
                "url": 5880,
                "code": "def array_to_npy(array_like): # type: (np.array or Iterable or int or float) -> object buffer = BytesIO() np.save(buffer, array_like) return buffer.getvalue()"
            },
            {
                "url": 9,
                "code": "def _convert_to_array(array_like, dtype): if isinstance(array_like, bytes): return np.frombuffer(array_like, dtype=dtype) return np.asarray(array_like, dtype=dtype)"
            },
            {
                "url": 1226,
                "code": "def row_to_dict(row): o = {} for colname in row.colnames: if isinstance(row[colname], np.string_) and row[colname].dtype.kind in ['S', 'U']: o[colname] = str(row[colname]) else: o[colname] = row[colname] return o"
            },
            {
                "url": 4,
                "code": "def _vector_or_scalar(x, type='row'): if isinstance(x, (list, tuple)): x = np.array(x) if isinstance(x, np.ndarray): assert x.ndim == 1 if type == 'column': x = x[:, None] return x"
            },
            {
                "url": 1870,
                "code": "def _to_array(value): if isinstance(value, (tuple, list)): return array(value) elif isinstance(value, (float, int)): return np.float64(value) else: return value"
            },
            {
                "url": 4666,
                "code": "def setdict(self, D): self.D = np.asarray(D, dtype=self.dtype)"
            },
            {
                "url": 879,
                "code": "def C_dict2array(C): return np.hstack([np.asarray(C[k]).ravel() for k in C_keys])"
            }
        ],
        "url": 5209
    },
    {
        "nl_input": "create column in python by joining columns",
        "code_input": [
            {
                "url": 793,
                "code": "def cross_join(df1, df2): if len(df1) == 0: return df2 if len(df2) == 0: return df1 # Add as lists so that the new index keeps the items in # the order that they are added together all_columns = pd.Index(list(df1.columns) + list(df2.columns)) df1['key'] = 1 df2['key'] = 1 return pd.merge(df1, df2, on='key').loc[:, all_columns]"
            },
            {
                "url": 306,
                "code": "def join_cols(cols): return \", \".join([i for i in cols]) if isinstance(cols, (list, tuple, set)) else cols"
            },
            {
                "url": 675,
                "code": "def get_join_cols(by_entry): left_cols = [] right_cols = [] for col in by_entry: if isinstance(col, str): left_cols.append(col) right_cols.append(col) else: left_cols.append(col[0]) right_cols.append(col[1]) return left_cols, right_cols"
            },
            {
                "url": 1065,
                "code": "def merge(left, right, how='inner', key=None, left_key=None, right_key=None, left_as='left', right_as='right'): return join(left, right, how, key, left_key, right_key, join_fn=make_union_join(left_as, right_as))"
            },
            {
                "url": 151,
                "code": "def _py2_and_3_joiner(sep, joinable): if ISPY3: sep = bytes(sep, DEFAULT_ENCODING) joined = sep.join(joinable) return joined.decode(DEFAULT_ENCODING) if ISPY3 else joined"
            },
            {
                "url": 677,
                "code": "def flatten_dict_join_keys(dct, join_symbol=\" \"): return dict( flatten_dict(dct, join=lambda a,b:a+join_symbol+b) )"
            },
            {
                "url": 2587,
                "code": "def join(mapping, bind, values): return [' '.join([six.text_type(v) for v in values if v is not None])]"
            },
            {
                "url": 671,
                "code": "def _join(verb): data = pd.merge(verb.x, verb.y, **verb.kwargs) # Preserve x groups if isinstance(verb.x, GroupedDataFrame): data.plydata_groups = list(verb.x.plydata_groups) return data"
            },
            {
                "url": 1478,
                "code": "def right_outer(self): self.get_collections_data() right_outer_join = self.merge_join_docs( set(self.collections_data['right'].keys())) return right_outer_join"
            },
            {
                "url": 3910,
                "code": "def cols_str(columns): cols = \"\" for c in columns: cols = cols + wrap(c) + ', ' return cols[:-2]"
            },
            {
                "url": 160,
                "code": "def commajoin_as_strings(iterable): return _(u',').join((six.text_type(i) for i in iterable))"
            },
            {
                "url": 3550,
                "code": "def intersect(self, other): return DataFrame(self._jdf.intersect(other._jdf), self.sql_ctx)"
            },
            {
                "url": 673,
                "code": "def join_images(img_files, out_file): images = [PIL.Image.open(f) for f in img_files] joined = PIL.Image.new( 'RGB', (sum(i.size[0] for i in images), max(i.size[1] for i in images)) ) left = 0 for img in images: joined.paste(im=img, box=(left, 0)) left = left + img.size[0] joined.save(out_file)"
            },
            {
                "url": 5342,
                "code": "def _grammatical_join_filter(l, arg=None): if not arg: arg = \" and |, \" try: final_join, initial_joins = arg.split(\"|\") except ValueError: final_join = arg initial_joins = \", \" return grammatical_join(l, initial_joins, final_join)"
            },
            {
                "url": 5287,
                "code": "def add_column(filename,column,formula,force=False): columns = parse_formula(formula) logger.info(\"Running file: %s\"%filename) logger.debug(\" Reading columns: %s\"%columns) data = fitsio.read(filename,columns=columns) logger.debug(' Evaluating formula: %s'%formula) col = eval(formula) col = np.asarray(col,dtype=[(column,col.dtype)]) insert_columns(filename,col,force=force) return True"
            }
        ],
        "url": 306
    },
    {
        "nl_input": "how to remove blank lines in python file",
        "code_input": [
            {
                "url": 5725,
                "code": "def remove_blank_lines(string): return \"\\n\".join(line for line in string.split(\"\\n\") if len(line.strip()))"
            },
            {
                "url": 2422,
                "code": "def text_remove_empty_lines(text): lines = [ line.rstrip() for line in text.splitlines() if line.strip() ] return \"\\n\".join(lines)"
            },
            {
                "url": 5108,
                "code": "def fix_line_breaks(s): l = s.splitlines() x = [i.strip() for i in l] x = [i for i in x if i] # remove blank lines return \"\\n\".join(x)"
            },
            {
                "url": 1006,
                "code": "def _remove_blank(l): ret = [] for i, _ in enumerate(l): if l[i] == 0: break ret.append(l[i]) return ret"
            },
            {
                "url": 2581,
                "code": "def clean(s): lines = [l.rstrip() for l in s.split('\\n')] return '\\n'.join(lines)"
            },
            {
                "url": 1805,
                "code": "def cleanLines(source, lineSep=os.linesep): stripped = (line.strip(lineSep) for line in source) return (line for line in stripped if len(line) != 0)"
            },
            {
                "url": 4173,
                "code": "def readline( file, skip_blank=False ): while 1: line = file.readline() #print \"every line: %r\" % line if not line: return None if line[0] != '#' and not ( skip_blank and line.isspace() ): return line"
            },
            {
                "url": 6168,
                "code": "def remove_blank_spaces(syllables: List[str]) -> List[str]: cleaned = [] for syl in syllables: if syl == \" \" or syl == '': pass else: cleaned.append(syl) return cleaned"
            },
            {
                "url": 4424,
                "code": "def filter_lines_from_comments(lines): for line_nb, raw_line in enumerate(lines): clean_line = remove_comments_from_line(raw_line) if clean_line == '': continue yield line_nb, clean_line, raw_line"
            },
            {
                "url": 3342,
                "code": "def de_blank(val): ret = list(val) if type(val) == list: for idx, item in enumerate(val): if item.strip() == '': ret.remove(item) else: ret[idx] = item.strip() return ret"
            },
            {
                "url": 1664,
                "code": "def _delete_whitespace(self): while isinstance(self._lines[-1], (self._Space, self._LineBreak, self._Indent)): del self._lines[-1]"
            },
            {
                "url": 2577,
                "code": "def clean_whitespace(statement): import re # Replace linebreaks and tabs with spaces statement.text = statement.text.replace('\\n', ' ').replace('\\r', ' ').replace('\\t', ' ') # Remove any leeding or trailing whitespace statement.text = statement.text.strip() # Remove consecutive spaces statement.text = re.sub(' +', ' ', statement.text) return statement"
            },
            {
                "url": 964,
                "code": "def lines(input): for raw_line in input: line = raw_line.strip() if line and not line.startswith('#'): yield strip_comments(line)"
            },
            {
                "url": 3099,
                "code": "def get_stripped_file_lines(filename): try: lines = open(filename).readlines() except FileNotFoundError: fatal(\"Could not open file: {!r}\".format(filename)) return [line.strip() for line in lines]"
            },
            {
                "url": 4855,
                "code": "def strip_comment_marker(text): lines = [] for line in text.splitlines(): lines.append(line.lstrip('#')) text = textwrap.dedent('\\n'.join(lines)) return text"
            }
        ],
        "url": 964
    },
    {
        "nl_input": "how to know size of queue in python",
        "code_input": [
            {
                "url": 425,
                "code": "def qsize(self): self.mutex.acquire() n = self._qsize() self.mutex.release() return n"
            },
            {
                "url": 713,
                "code": "def get_size(objects): res = 0 for o in objects: try: res += _getsizeof(o) except AttributeError: print(\"IGNORING: type=%s; o=%s\" % (str(type(o)), str(o))) return res"
            },
            {
                "url": 1909,
                "code": "def size(dtype): dtype = tf.as_dtype(dtype) if hasattr(dtype, 'size'): return dtype.size return np.dtype(dtype).itemsize"
            },
            {
                "url": 949,
                "code": "def full(self): if not self.size: return False return len(self.pq) == (self.size + self.removed_count)"
            },
            {
                "url": 2050,
                "code": "def get_size(path): if os.path.isfile(path): return os.path.getsize(path) return sum(get_size(os.path.join(path, f)) for f in os.listdir(path))"
            },
            {
                "url": 1134,
                "code": "def _nbytes(buf): if isinstance(buf, memoryview): if PY3: # py3 introduces nbytes attribute return buf.nbytes else: # compute nbytes on py2 size = buf.itemsize for dim in buf.shape: size *= dim return size else: # not a memoryview, raw bytes/ py2 buffer return len(buf)"
            },
            {
                "url": 4438,
                "code": "def create(parallel): queue = {k: v for k, v in parallel.items() if k in [\"queue\", \"cores_per_job\", \"mem\"]} yield queue"
            },
            {
                "url": 6071,
                "code": "def codes_get_size(handle, key): # type: (cffi.FFI.CData, str) -> int size = ffi.new('size_t *') _codes_get_size(handle, key.encode(ENC), size) return size[0]"
            },
            {
                "url": 5555,
                "code": "def full(self): return self.maxsize and len(self.list) >= self.maxsize or False"
            },
            {
                "url": 406,
                "code": "def dequeue(self, block=True): return self.queue.get(block, self.queue_get_timeout)"
            },
            {
                "url": 3708,
                "code": "def _read_stream_for_size(stream, buf_size=65536): size = 0 while True: buf = stream.read(buf_size) size += len(buf) if not buf: break return size"
            },
            {
                "url": 3697,
                "code": "def get(self, queue_get): if isinstance(queue_get, (tuple, list)): self.result.extend(queue_get)"
            },
            {
                "url": 2921,
                "code": "def get_filesize(self, pdf): try: filesize = float(pdf.get_size()) return filesize / 1024 except (POSKeyError, TypeError): return 0"
            },
            {
                "url": 5035,
                "code": "def _calc_dir_size(path): dir_size = 0 for (root, dirs, files) in os.walk(path): for fn in files: full_fn = os.path.join(root, fn) dir_size += os.path.getsize(full_fn) return dir_size"
            },
            {
                "url": 417,
                "code": "def get_size_in_bytes(self, handle): fpath = self._fpath_from_handle(handle) return os.stat(fpath).st_size"
            }
        ],
        "url": 425
    },
    {
        "nl_input": "python substring index of",
        "code_input": [
            {
                "url": 1832,
                "code": "def get_substring_idxs(substr, string): return [match.start() for match in re.finditer(substr, string)]"
            },
            {
                "url": 2492,
                "code": "def _find(string, sub_string, start_index): result = string.find(sub_string, start_index) if result == -1: raise TokenError(\"expected '{0}'\".format(sub_string)) return result"
            },
            {
                "url": 5111,
                "code": "def subat(orig, index, replace): return \"\".join([(orig[x] if x != index else replace) for x in range(len(orig))])"
            },
            {
                "url": 5327,
                "code": "def _find_first_of(line, substrings): starts = ((line.find(i), i) for i in substrings) found = [(i, sub) for i, sub in starts if i != -1] if found: return min(found) else: return -1, None"
            },
            {
                "url": 1022,
                "code": "def subn_filter(s, find, replace, count=0): return re.gsub(find, replace, count, s)"
            },
            {
                "url": 890,
                "code": "def fsliceafter(astr, sub): findex = astr.find(sub) return astr[findex + len(sub):]"
            },
            {
                "url": 5846,
                "code": "def valid_substitution(strlen, index): values = index[0] return all([strlen > i for i in values])"
            },
            {
                "url": 2314,
                "code": "def where_is(strings, pattern, n=1, lookup_func=re.match): count = 0 for idx, item in enumerate(strings): if lookup_func(pattern, item): count += 1 if count == n: return idx return -1"
            },
            {
                "url": 3963,
                "code": "def find_all(self, string, callback): for index, output in self.iter(string): callback(index, output)"
            },
            {
                "url": 6023,
                "code": "def add_mark_at(string, index, mark): if index == -1: return string # Python can handle the case which index is out of range of given string return string[:index] + add_mark_char(string[index], mark) + string[index+1:]"
            },
            {
                "url": 5957,
                "code": "def long_substring(str_a, str_b): data = [str_a, str_b] substr = '' if len(data) > 1 and len(data[0]) > 0: for i in range(len(data[0])): for j in range(len(data[0])-i+1): if j > len(substr) and all(data[0][i:i+j] in x for x in data): substr = data[0][i:i+j] return substr.strip()"
            },
            {
                "url": 1113,
                "code": "def fmt_subst(regex, subst): return lambda text: re.sub(regex, subst, text) if text else text"
            },
            {
                "url": 5693,
                "code": "def long_substr(data): substr = '' if len(data) > 1 and len(data[0]) > 0: for i in range(len(data[0])): for j in range(len(data[0])-i+1): if j > len(substr) and all(data[0][i:i+j] in x for x in data): substr = data[0][i:i+j] elif len(data) == 1: substr = data[0] return substr"
            },
            {
                "url": 4996,
                "code": "def finditer(self, string, pos=0, endpos=sys.maxint): scanner = self.scanner(string, pos, endpos) return iter(scanner.search, None)"
            },
            {
                "url": 2660,
                "code": "def _is_subsequence_of(self, sub, sup): return bool(re.search(\".*\".join(sub), sup))"
            }
        ],
        "url": 1832
    },
    {
        "nl_input": "comparing int to none python",
        "code_input": [
            {
                "url": 4144,
                "code": "def _none_value(self): if self.out_type == int: return 0 elif self.out_type == float: return 0.0 elif self.out_type == bool: return False elif self.out_type == six.text_type: return u''"
            },
            {
                "url": 5919,
                "code": "def is_none(string_, default='raise'): none = ['none', 'undefined', 'unknown', 'null', ''] if string_.lower() in none: return True elif not default: return False else: raise ValueError('The value \\'{}\\' cannot be mapped to none.' .format(string_))"
            },
            {
                "url": 289,
                "code": "def _check_for_int(x): try: y = int(x) except (OverflowError, ValueError): pass else: # There is no way in AMF0 to distinguish between integers and floats if x == x and y == x: return y return x"
            },
            {
                "url": 5274,
                "code": "def convert_string(string): if is_int(string): return int(string) elif is_float(string): return float(string) elif convert_bool(string)[0]: return convert_bool(string)[1] elif string == 'None': return None else: return string"
            },
            {
                "url": 6182,
                "code": "def strictly_positive_int_or_none(val): val = positive_int_or_none(val) if val is None or val > 0: return val raise ValueError('\"{}\" must be strictly positive'.format(val))"
            },
            {
                "url": 1571,
                "code": "def min_or_none(val1, val2): return min(val1, val2, key=lambda x: sys.maxint if x is None else x)"
            },
            {
                "url": 2999,
                "code": "def set_float(val): out = None if not val in (None, ''): try: out = float(val) except ValueError: return None if numpy.isnan(out): out = default return out"
            },
            {
                "url": 637,
                "code": "def is_int(value): if isinstance(value, bool): return False try: int(value) return True except (ValueError, TypeError): return False"
            },
            {
                "url": 3442,
                "code": "def _get_type(self, value): if value is None: return type(None) elif type(value) in int_types: return int elif type(value) in float_types: return float elif isinstance(value, binary_type): return binary_type else: return text_type"
            },
            {
                "url": 6171,
                "code": "def convert_to_int(x: Any, default: int = None) -> int: try: return int(x) except (TypeError, ValueError): return default"
            },
            {
                "url": 3351,
                "code": "def __convert_none_to_zero(self, ts): if not ts: return ts ts_clean = [val if val else 0 for val in ts] return ts_clean"
            },
            {
                "url": 1791,
                "code": "def is_int(string): try: a = float(string) b = int(a) except ValueError: return False else: return a == b"
            },
            {
                "url": 1329,
                "code": "def validate_int(value): if value and not isinstance(value, int): try: int(str(value)) except (TypeError, ValueError): raise ValidationError('not a valid number') return value"
            },
            {
                "url": 3579,
                "code": "def _force_float(v): try: return float(v) except Exception as exc: return float('nan') logger.warning('Failed to convert {} to float with {} error. Using 0 instead.'.format(v, exc))"
            },
            {
                "url": 208,
                "code": "def _not_none(items): if not isinstance(items, (tuple, list)): items = (items,) return all(item is not _none for item in items)"
            }
        ],
        "url": 5540
    },
    {
        "nl_input": "json to protobuf python",
        "code_input": [
            {
                "url": 2465,
                "code": "def toJson(protoObject, indent=None): # Using the internal method because this way we can reformat the JSON js = json_format.MessageToDict(protoObject, False) return json.dumps(js, indent=indent)"
            },
            {
                "url": 1059,
                "code": "def _dict_to_proto(py_dict, proto): dict_json_str = json.dumps(py_dict) return json_format.Parse(dict_json_str, proto)"
            },
            {
                "url": 1333,
                "code": "def AsPrimitiveProto(self): if self.protobuf: result = self.protobuf() result.ParseFromString(self.SerializeToString()) return result"
            },
            {
                "url": 4806,
                "code": "def MessageToDict(message, including_default_value_fields=False, preserving_proto_field_name=False): printer = _Printer(including_default_value_fields, preserving_proto_field_name) # pylint: disable=protected-access return printer._MessageToJsonObject(message)"
            },
            {
                "url": 1935,
                "code": "def object_to_json(obj, indent=2): instance_json = json.dumps(obj, indent=indent, ensure_ascii=False, cls=DjangoJSONEncoder) return instance_json"
            },
            {
                "url": 1198,
                "code": "def _serialize_json(obj, fp): json.dump(obj, fp, indent=4, default=serialize)"
            },
            {
                "url": 682,
                "code": "def dump_json(obj): return simplejson.dumps(obj, ignore_nan=True, default=json_util.default)"
            },
            {
                "url": 1758,
                "code": "def to_json(obj): i = StringIO.StringIO() w = Writer(i, encoding='UTF-8') w.write_value(obj) return i.getvalue()"
            },
            {
                "url": 2057,
                "code": "def json(body, charset='utf-8', **kwargs): return json_converter.loads(text(body, charset=charset))"
            },
            {
                "url": 4442,
                "code": "def save_json(object, handle, indent=2): obj_json = json.dumps(object, indent=indent, cls=NumpyJSONEncoder) handle.write(obj_json)"
            },
            {
                "url": 1343,
                "code": "def from_pb(cls, pb): obj = cls._from_pb(pb) obj._pb = pb return obj"
            },
            {
                "url": 2237,
                "code": "def to_json(data): return json.dumps(data, default=lambda x: x.__dict__, sort_keys=True, indent=4)"
            },
            {
                "url": 4880,
                "code": "def _convert_dict_to_json(array): return json.dumps( array, skipkeys=False, allow_nan=False, indent=None, separators=(\",\", \":\"), sort_keys=True, default=lambda o: o.__dict__, )"
            },
            {
                "url": 6236,
                "code": "def to_json(self) -> Mapping: return {str(x): str(y) for x, y in self.items()}"
            },
            {
                "url": 2059,
                "code": "def json_dumps(self, obj): return json.dumps(obj, sort_keys=True, indent=4, separators=(',', ': '))"
            }
        ],
        "url": 2465
    },
    {
        "nl_input": "how to join 2 data frames in python",
        "code_input": [
            {
                "url": 793,
                "code": "def cross_join(df1, df2): if len(df1) == 0: return df2 if len(df2) == 0: return df1 # Add as lists so that the new index keeps the items in # the order that they are added together all_columns = pd.Index(list(df1.columns) + list(df2.columns)) df1['key'] = 1 df2['key'] = 1 return pd.merge(df1, df2, on='key').loc[:, all_columns]"
            },
            {
                "url": 671,
                "code": "def _join(verb): data = pd.merge(verb.x, verb.y, **verb.kwargs) # Preserve x groups if isinstance(verb.x, GroupedDataFrame): data.plydata_groups = list(verb.x.plydata_groups) return data"
            },
            {
                "url": 3550,
                "code": "def intersect(self, other): return DataFrame(self._jdf.intersect(other._jdf), self.sql_ctx)"
            },
            {
                "url": 151,
                "code": "def _py2_and_3_joiner(sep, joinable): if ISPY3: sep = bytes(sep, DEFAULT_ENCODING) joined = sep.join(joinable) return joined.decode(DEFAULT_ENCODING) if ISPY3 else joined"
            },
            {
                "url": 2680,
                "code": "def from_df(data_frame): labels = data_frame.keys().tolist() data = data_frame.values.tolist() return SqlTable(labels, data, \"{:.3f}\", \"\\n\")"
            },
            {
                "url": 1605,
                "code": "def to_dataframe(products): try: import pandas as pd except ImportError: raise ImportError(\"to_dataframe requires the optional dependency Pandas.\") return pd.DataFrame.from_dict(products, orient='index')"
            },
            {
                "url": 1065,
                "code": "def merge(left, right, how='inner', key=None, left_key=None, right_key=None, left_as='left', right_as='right'): return join(left, right, how, key, left_key, right_key, join_fn=make_union_join(left_as, right_as))"
            },
            {
                "url": 673,
                "code": "def join_images(img_files, out_file): images = [PIL.Image.open(f) for f in img_files] joined = PIL.Image.new( 'RGB', (sum(i.size[0] for i in images), max(i.size[1] for i in images)) ) left = 0 for img in images: joined.paste(im=img, box=(left, 0)) left = left + img.size[0] joined.save(out_file)"
            },
            {
                "url": 1187,
                "code": "def column_stack_2d(data): return list(list(itt.chain.from_iterable(_)) for _ in zip(*data))"
            },
            {
                "url": 306,
                "code": "def join_cols(cols): return \", \".join([i for i in cols]) if isinstance(cols, (list, tuple, set)) else cols"
            },
            {
                "url": 677,
                "code": "def flatten_dict_join_keys(dct, join_symbol=\" \"): return dict( flatten_dict(dct, join=lambda a,b:a+join_symbol+b) )"
            },
            {
                "url": 675,
                "code": "def get_join_cols(by_entry): left_cols = [] right_cols = [] for col in by_entry: if isinstance(col, str): left_cols.append(col) right_cols.append(col) else: left_cols.append(col[0]) right_cols.append(col[1]) return left_cols, right_cols"
            },
            {
                "url": 4695,
                "code": "def _join_masks_from_masked_array(data): if not isinstance(data.mask, np.ndarray): # workaround to handle mask compressed to single value mask = np.empty(data.data.shape, dtype=np.bool) mask.fill(data.mask) return mask mask = data.mask[0].copy() for i in range(1, len(data.mask)): mask = np.logical_or(mask, data.mask[i]) return mask[np.newaxis, :, :]"
            },
            {
                "url": 1818,
                "code": "def merge_dict(data, *args): results = {} for current in (data,) + args: results.update(current) return results"
            },
            {
                "url": 160,
                "code": "def commajoin_as_strings(iterable): return _(u',').join((six.text_type(i) for i in iterable))"
            }
        ],
        "url": 793
    },
    {
        "nl_input": "how to product of a list in python",
        "code_input": [
            {
                "url": 5967,
                "code": "def product(*args, **kwargs): p = [[]] for iterable in map(tuple, args) * kwargs.get(\"repeat\", 1): p = [x + [y] for x in p for y in iterable] for p in p: yield tuple(p)"
            },
            {
                "url": 5599,
                "code": "def dotproduct(X, Y): return sum([x * y for x, y in zip(X, Y)])"
            },
            {
                "url": 1987,
                "code": "def multiply(self, number): return self.from_list([x * number for x in self.to_list()])"
            },
            {
                "url": 2844,
                "code": "def cartesian_lists(d): return [{k: v for k, v in zip(d.keys(), args)} for args in itertools.product(*d.values())]"
            },
            {
                "url": 4402,
                "code": "def visit_BinOp(self, node): args = [self.visit(arg) for arg in (node.left, node.right)] return list({frozenset.union(*x) for x in itertools.product(*args)})"
            },
            {
                "url": 1573,
                "code": "def cartesian_product(arrays, flat=True, copy=False): arrays = np.broadcast_arrays(*np.ix_(*arrays)) if flat: return tuple(arr.flatten() if copy else arr.flat for arr in arrays) return tuple(arr.copy() if copy else arr for arr in arrays)"
            },
            {
                "url": 4236,
                "code": "def sorted_product_set(array_a, array_b): return np.sort( np.concatenate( [array_a[i] * array_b for i in xrange(len(array_a))], axis=0) )[::-1]"
            },
            {
                "url": 4224,
                "code": "def combine(self, a, b): for l in (a, b): for x in l: yield x"
            },
            {
                "url": 2060,
                "code": "def _cumprod(l): ret = [1] for item in l: ret.append(ret[-1] * item) return ret"
            },
            {
                "url": 5958,
                "code": "def squash(self, a, b): return ((''.join(x) if isinstance(x, tuple) else x) for x in itertools.product(a, b))"
            },
            {
                "url": 2952,
                "code": "def combinations(l): result = [] for x in xrange(len(l) - 1): ls = l[x + 1:] for y in ls: result.append((l[x], y)) return result"
            },
            {
                "url": 75,
                "code": "def dot_product(self, other): return self.x * other.x + self.y * other.y"
            },
            {
                "url": 5655,
                "code": "def _izip(*iterables): # This izip routine is from itertools # izip('ABCD', 'xy') --> Ax By iterators = map(iter, iterables) while iterators: yield tuple(map(next, iterators))"
            },
            {
                "url": 328,
                "code": "def concat(cls, iterables): def generator(): for it in iterables: for element in it: yield element return cls(generator())"
            },
            {
                "url": 4099,
                "code": "def get_scalar_product(self, other): return self.x*other.x+self.y*other.y"
            }
        ],
        "url": 5599
    },
    {
        "nl_input": "get all dates between range datetime python",
        "code_input": [
            {
                "url": 573,
                "code": "def dates_in_range(start_date, end_date): return [ start_date + timedelta(n) for n in range(int((end_date - start_date).days)) ]"
            },
            {
                "url": 1844,
                "code": "def daterange(start_date, end_date): for n in range(int((end_date - start_date).days)): yield start_date + timedelta(n)"
            },
            {
                "url": 111,
                "code": "def daterange(start, end, delta=timedelta(days=1), lower=Interval.CLOSED, upper=Interval.OPEN): date_interval = Interval(lower=lower, lower_value=start, upper_value=end, upper=upper) current = start if start in date_interval else start + delta while current in date_interval: yield current current = current + delta"
            },
            {
                "url": 2095,
                "code": "def time_range(from_=None, to=None): # todo datetime conversion args = locals() return { k.replace('_', ''): v for k, v in args.items() }"
            },
            {
                "url": 3123,
                "code": "def get_range(self, start=None, stop=None): return self.from_iterable(self.ranges(start, stop))"
            },
            {
                "url": 3206,
                "code": "def from_years_range(start_year, end_year): start = datetime.date(start_year, 1 , 1) end = datetime.date(end_year, 12 , 31) return DateRange(start, end)"
            },
            {
                "url": 3820,
                "code": "def date(start, end): stime = date_to_timestamp(start) etime = date_to_timestamp(end) ptime = stime + random.random() * (etime - stime) return datetime.date.fromtimestamp(ptime)"
            },
            {
                "url": 3369,
                "code": "def get_date_field(datetimes, field): return np.array([getattr(date, field) for date in datetimes])"
            },
            {
                "url": 6137,
                "code": "def date_to_datetime(d): if not isinstance(d, datetime): d = datetime.combine(d, datetime.min.time()) return d"
            },
            {
                "url": 3405,
                "code": "def range(*args, interval=0): agen = from_iterable.raw(builtins.range(*args)) return time.spaceout.raw(agen, interval) if interval else agen"
            },
            {
                "url": 6045,
                "code": "def get_days_in_month(year: int, month: int) -> int: month_range = calendar.monthrange(year, month) return month_range[1]"
            },
            {
                "url": 5059,
                "code": "def _parse_ranges(ranges): for txt in ranges: if '-' in txt: low, high = txt.split('-') else: low, high = txt, txt yield int(low), int(high)"
            },
            {
                "url": 2020,
                "code": "def get_date(date): if type(date) is str: return datetime.strptime(date, '%Y-%m-%d').date() else: return date"
            },
            {
                "url": 3166,
                "code": "def _rnd_datetime(self, start, end): return self.from_utctimestamp( random.randint( int(self.to_utctimestamp(start)), int(self.to_utctimestamp(end)), ) )"
            },
            {
                "url": 2081,
                "code": "def get_dt_list(fn_list): dt_list = np.array([fn_getdatetime(fn) for fn in fn_list]) return dt_list"
            }
        ],
        "url": 573
    },
    {
        "nl_input": "python access file on remote",
        "code_input": [
            {
                "url": 4843,
                "code": "def remote_file_exists(self, url): status = requests.head(url).status_code if status != 200: raise RemoteFileDoesntExist"
            },
            {
                "url": 1848,
                "code": "def get_remote_content(filepath): with hide('running'): temp = BytesIO() get(filepath, temp) content = temp.getvalue().decode('utf-8') return content.strip()"
            },
            {
                "url": 4160,
                "code": "def download_file(save_path, file_url): r = requests.get(file_url) # create HTTP response object with open(save_path, 'wb') as f: f.write(r.content) return save_path"
            },
            {
                "url": 1975,
                "code": "def wget(url): import urllib.parse request = urllib.request.urlopen(url) filestring = request.read() return filestring"
            },
            {
                "url": 2924,
                "code": "def send_file(self, local_path, remote_path, user='root', unix_mode=None): self.enable_user(user) return self.ssh_pool.send_file(user, local_path, remote_path, unix_mode=unix_mode)"
            },
            {
                "url": 2400,
                "code": "def exists(self, filepath): if self.is_ssh(filepath): self._check_ftp() remotepath = self._get_remote(filepath) try: self.ftp.stat(remotepath) except IOError as e: if e.errno == errno.ENOENT: return False else: return True else: return os.path.exists(filepath)"
            },
            {
                "url": 1944,
                "code": "def _open_url(url): response = requests.get(url, stream=True) if response.status_code != 200: raise IOError(\"Unable to download {}, HTTP {}\".format(url, response.status_code)) return response"
            },
            {
                "url": 4668,
                "code": "def _download(url): fh = StringIO() for line in get(url): fh.write(line) fh.seek(0) return fh"
            },
            {
                "url": 5656,
                "code": "def s3_get(url: str, temp_file: IO) -> None: s3_resource = boto3.resource(\"s3\") bucket_name, s3_path = split_s3_path(url) s3_resource.Bucket(bucket_name).download_fileobj(s3_path, temp_file)"
            },
            {
                "url": 368,
                "code": "def download_file_from_bucket(self, bucket, file_path, key): with open(file_path, 'wb') as data: self.__s3.download_fileobj(bucket, key, data) return file_path"
            },
            {
                "url": 1051,
                "code": "def get_file_string(filepath): with open(os.path.abspath(filepath)) as f: return f.read()"
            },
            {
                "url": 1033,
                "code": "def download(url, encoding='utf-8'): import requests response = requests.get(url) response.encoding = encoding return response.text"
            },
            {
                "url": 874,
                "code": "def _download_py3(link, path, __hdr__): try: req = urllib.request.Request(link, headers=__hdr__) u = urllib.request.urlopen(req) except Exception as e: raise Exception(' Download failed with the error:\\n{}'.format(e)) with open(path, 'wb') as outf: for l in u: outf.write(l) u.close()"
            },
            {
                "url": 3493,
                "code": "def check_dependencies_remote(args): cmd = [args.python, '-m', 'depends', args.requirement] env = dict(PYTHONPATH=os.path.dirname(__file__)) return subprocess.check_call(cmd, env=env)"
            },
            {
                "url": 4073,
                "code": "def load_files(files): for py_file in files: LOG.debug(\"exec %s\", py_file) execfile(py_file, globals(), locals())"
            }
        ],
        "url": 1848
    },
    {
        "nl_input": "how to download txt file from internet in python",
        "code_input": [
            {
                "url": 1033,
                "code": "def download(url, encoding='utf-8'): import requests response = requests.get(url) response.encoding = encoding return response.text"
            },
            {
                "url": 1975,
                "code": "def wget(url): import urllib.parse request = urllib.request.urlopen(url) filestring = request.read() return filestring"
            },
            {
                "url": 4160,
                "code": "def download_file(save_path, file_url): r = requests.get(file_url) # create HTTP response object with open(save_path, 'wb') as f: f.write(r.content) return save_path"
            },
            {
                "url": 4668,
                "code": "def _download(url): fh = StringIO() for line in get(url): fh.write(line) fh.seek(0) return fh"
            },
            {
                "url": 1944,
                "code": "def _open_url(url): response = requests.get(url, stream=True) if response.status_code != 200: raise IOError(\"Unable to download {}, HTTP {}\".format(url, response.status_code)) return response"
            },
            {
                "url": 874,
                "code": "def _download_py3(link, path, __hdr__): try: req = urllib.request.Request(link, headers=__hdr__) u = urllib.request.urlopen(req) except Exception as e: raise Exception(' Download failed with the error:\\n{}'.format(e)) with open(path, 'wb') as outf: for l in u: outf.write(l) u.close()"
            },
            {
                "url": 2307,
                "code": "def download_sdk(url): r = requests.get(url) r.raise_for_status() return StringIO(r.content)"
            },
            {
                "url": 5383,
                "code": "def download_url(url, filename, headers): ensure_dirs(filename) response = requests.get(url, headers=headers, stream=True) if response.status_code == 200: with open(filename, 'wb') as f: for chunk in response.iter_content(16 * 1024): f.write(chunk)"
            },
            {
                "url": 980,
                "code": "def url_read_text(url, verbose=True): r data = url_read(url, verbose) text = data.decode('utf8') return text"
            },
            {
                "url": 1410,
                "code": "def get(url): response = urllib.request.urlopen(url) data = response.read() data = data.decode(\"utf-8\") data = json.loads(data) return data"
            },
            {
                "url": 1871,
                "code": "def url_to_image(url): r = requests.get(url) image = StringIO(r.content) return image"
            },
            {
                "url": 5656,
                "code": "def s3_get(url: str, temp_file: IO) -> None: s3_resource = boto3.resource(\"s3\") bucket_name, s3_path = split_s3_path(url) s3_resource.Bucket(bucket_name).download_fileobj(s3_path, temp_file)"
            },
            {
                "url": 368,
                "code": "def download_file_from_bucket(self, bucket, file_path, key): with open(file_path, 'wb') as data: self.__s3.download_fileobj(bucket, key, data) return file_path"
            },
            {
                "url": 4235,
                "code": "def get_dates_link(url): urllib.request.urlretrieve(url, \"temp.txt\") dates = get_dates_file(\"temp.txt\") os.remove(\"temp.txt\") return dates"
            },
            {
                "url": 1976,
                "code": "def _read_text(self, filename): with io.open(filename, 'rt', encoding='utf-8') as f: return f.read()"
            }
        ],
        "url": 4235
    },
    {
        "nl_input": "stopwords list remove python",
        "code_input": [
            {
                "url": 1153,
                "code": "def _removeStopwords(text_list): output_list = [] for word in text_list: if word.lower() not in _stopwords: output_list.append(word) return output_list"
            },
            {
                "url": 85,
                "code": "def get_stoplist(language): file_path = os.path.join(\"stoplists\", \"%s.txt\" % language) try: stopwords = pkgutil.get_data(\"justext\", file_path) except IOError: raise ValueError( \"Stoplist for language '%s' is missing. \" \"Please use function 'get_stoplists' for complete list of stoplists \" \"and feel free to contribute by your own stoplist.\" % language ) return frozenset(w.decode(\"utf8\").lower() for w in stopwords.splitlines())"
            },
            {
                "url": 844,
                "code": "def wordify(text): stopset = set(nltk.corpus.stopwords.words('english')) tokens = nltk.WordPunctTokenizer().tokenize(text) return [w for w in tokens if w not in stopset]"
            },
            {
                "url": 4788,
                "code": "def clean_text_by_sentences(text, language=\"english\", additional_stopwords=None): init_textcleanner(language, additional_stopwords) original_sentences = split_sentences(text) filtered_sentences = filter_words(original_sentences) return merge_syntactic_units(original_sentences, filtered_sentences)"
            },
            {
                "url": 3082,
                "code": "def tokenize_words(self, text): return [ self.strip_punctuation(word) for word in text.split(' ') if self.strip_punctuation(word) ]"
            },
            {
                "url": 1838,
                "code": "def unpunctuate(s, *, char_blacklist=string.punctuation): # remove punctuation s = \"\".join(c for c in s if c not in char_blacklist) # remove consecutive spaces return \" \".join(filter(None, s.split(\" \")))"
            },
            {
                "url": 5168,
                "code": "def preprocess_french(trans, fr_nlp, remove_brackets_content=True): if remove_brackets_content: trans = pangloss.remove_content_in_brackets(trans, \"[]\") # Not sure why I have to split and rejoin, but that fixes a Spacy token # error. trans = fr_nlp(\" \".join(trans.split()[:])) #trans = fr_nlp(trans) trans = \" \".join([token.lower_ for token in trans if not token.is_punct]) return trans"
            },
            {
                "url": 3766,
                "code": "def highlight_words(string, keywords, cls_name='highlighted'): if not keywords: return string if not string: return '' include, exclude = get_text_tokenizer(keywords) highlighted = highlight_text(include, string, cls_name, words=True) return highlighted"
            },
            {
                "url": 1546,
                "code": "def split_into_words(s): s = re.sub(r\"\\W+\", \" \", s) s = re.sub(r\"[_0-9]+\", \" \", s) return s.split()"
            },
            {
                "url": 2208,
                "code": "def remove_punctuation(text, exceptions=[]): all_but = [ r'\\w', r'\\s' ] all_but.extend(exceptions) pattern = '[^{}]'.format(''.join(all_but)) return re.sub(pattern, '', text)"
            },
            {
                "url": 2339,
                "code": "def sanitize_word(s): s = re.sub('[^\\w-]+', '_', s) s = re.sub('__+', '_', s) return s.strip('_')"
            },
            {
                "url": 510,
                "code": "def _remove_keywords(d): return { k:v for k, v in iteritems(d) if k not in RESERVED }"
            },
            {
                "url": 885,
                "code": "def extract_keywords_from_text(self, text): sentences = nltk.tokenize.sent_tokenize(text) self.extract_keywords_from_sentences(sentences)"
            },
            {
                "url": 2261,
                "code": "def extract_words(lines): for line in lines: for word in re.findall(r\"\\w+\", line): yield word"
            },
            {
                "url": 5594,
                "code": "def dictlist_wipe_key(dict_list: Iterable[Dict], key: str) -> None: for d in dict_list: d.pop(key, None)"
            }
        ],
        "url": 1153
    },
    {
        "nl_input": "limit on open file handles in python",
        "code_input": [
            {
                "url": 2901,
                "code": "def _increase_file_handle_limit(): logging.info('Increasing file handle limit to {}'.format(constants.FILE_HANDLE_LIMIT)) resource.setrlimit(resource.RLIMIT_NOFILE, (constants.FILE_HANDLE_LIMIT, resource.RLIM_INFINITY))"
            },
            {
                "url": 3485,
                "code": "def _open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None, *, loop=None, executor=None): if loop is None: loop = asyncio.get_event_loop() cb = partial(sync_open, file, mode=mode, buffering=buffering, encoding=encoding, errors=errors, newline=newline, closefd=closefd, opener=opener) f = yield from loop.run_in_executor(executor, cb) return wrap(f, loop=loop, executor=executor)"
            },
            {
                "url": 1796,
                "code": "def open_file(file, mode): if hasattr(file, \"read\"): return file if hasattr(file, \"open\"): return file.open(mode) return open(file, mode)"
            },
            {
                "url": 4698,
                "code": "def fopen(name, mode='r', buffering=-1): f = _fopen(name, mode, buffering) return _FileObjectThreadWithContext(f, mode, buffering)"
            },
            {
                "url": 4899,
                "code": "def open(name=None, fileobj=None, closefd=True): return Guesser().open(name=name, fileobj=fileobj, closefd=closefd)"
            },
            {
                "url": 564,
                "code": "def fopenat(base_fd, path): return os.fdopen(openat(base_fd, path, os.O_RDONLY), 'rb')"
            },
            {
                "url": 4640,
                "code": "def __enter__(self): self.fd = open(self.filename, 'a') fcntl.lockf(self.fd, fcntl.LOCK_EX) return self.fd"
            },
            {
                "url": 1063,
                "code": "def open_with_encoding(filename, encoding, mode='r'): return io.open(filename, mode=mode, encoding=encoding, newline='')"
            },
            {
                "url": 4948,
                "code": "def open_hdf5(filename, mode='r'): if isinstance(filename, (h5py.Group, h5py.Dataset)): return filename if isinstance(filename, FILE_LIKE): return h5py.File(filename.name, mode) return h5py.File(filename, mode)"
            },
            {
                "url": 5407,
                "code": "def bin_open(fname: str): if fname.endswith(\".gz\"): return gzip.open(fname, \"rb\") return open(fname, \"rb\")"
            },
            {
                "url": 6263,
                "code": "def copen(filepath, flag='r', encoding=None): if encoding is None: encoding = locale.getdefaultlocale()[1] return codecs.open(filepath, flag, encoding)"
            },
            {
                "url": 1220,
                "code": "def _unzip_handle(handle): if isinstance(handle, basestring): handle = _gzip_open_filename(handle) else: handle = _gzip_open_handle(handle) return handle"
            },
            {
                "url": 4073,
                "code": "def load_files(files): for py_file in files: LOG.debug(\"exec %s\", py_file) execfile(py_file, globals(), locals())"
            },
            {
                "url": 3835,
                "code": "def open(self, flag=\"c\"): return shelve.open(os.path.join(gettempdir(), self.index), flag=flag, protocol=2)"
            },
            {
                "url": 2073,
                "code": "def open01(x, limit=1.e-6): try: return np.array([min(max(y, limit), 1. - limit) for y in x]) except TypeError: return min(max(x, limit), 1. - limit)"
            }
        ],
        "url": 2901
    },
    {
        "nl_input": "determine the longest sentence in corpus in nlp python ocde",
        "code_input": [
            {
                "url": 5519,
                "code": "def split_long_sentence(sentence, words_per_line): words = sentence.split(' ') split_sentence = '' for i in range(len(words)): split_sentence = split_sentence + words[i] if (i+1) % words_per_line == 0: split_sentence = split_sentence + '\\n' elif i != len(words) - 1: split_sentence = split_sentence + \" \" return split_sentence"
            },
            {
                "url": 6222,
                "code": "def enumerate_chunks (phrase, spacy_nlp): if (len(phrase) > 1): found = False text = \" \".join([rl.text for rl in phrase]) doc = spacy_nlp(text.strip(), parse=True) for np in doc.noun_chunks: if np.text != text: found = True yield np.text, find_chunk(phrase, np.text.split(\" \")) if not found and all([rl.pos[0] != \"v\" for rl in phrase]): yield text, phrase"
            },
            {
                "url": 5989,
                "code": "def get_longest_line_length(text): lines = text.split(\"\\n\") length = 0 for i in range(len(lines)): if len(lines[i]) > length: length = len(lines[i]) return length"
            },
            {
                "url": 4788,
                "code": "def clean_text_by_sentences(text, language=\"english\", additional_stopwords=None): init_textcleanner(language, additional_stopwords) original_sentences = split_sentences(text) filtered_sentences = filter_words(original_sentences) return merge_syntactic_units(original_sentences, filtered_sentences)"
            },
            {
                "url": 844,
                "code": "def wordify(text): stopset = set(nltk.corpus.stopwords.words('english')) tokens = nltk.WordPunctTokenizer().tokenize(text) return [w for w in tokens if w not in stopset]"
            },
            {
                "url": 4207,
                "code": "def _begins_with_one_of(sentence, parts_of_speech): doc = nlp(sentence) if doc[0].tag_ in parts_of_speech: return True return False"
            },
            {
                "url": 4746,
                "code": "def get_least_distinct_words(vocab, topic_word_distrib, doc_topic_distrib, doc_lengths, n=None): return _words_by_distinctiveness_score(vocab, topic_word_distrib, doc_topic_distrib, doc_lengths, n, least_to_most=True)"
            },
            {
                "url": 4410,
                "code": "def word_matches(s1, s2, n=3): return __matches(s1, s2, word_ngrams, n=n)"
            },
            {
                "url": 885,
                "code": "def extract_keywords_from_text(self, text): sentences = nltk.tokenize.sent_tokenize(text) self.extract_keywords_from_sentences(sentences)"
            },
            {
                "url": 2290,
                "code": "def _generate_phrases(self, sentences): phrase_list = set() # Create contender phrases from sentences. for sentence in sentences: word_list = [word.lower() for word in wordpunct_tokenize(sentence)] phrase_list.update(self._get_phrase_list_from_words(word_list)) return phrase_list"
            },
            {
                "url": 3274,
                "code": "def lemmatize(self, text, best_guess=True, return_frequencies=False): if isinstance(text, str): tokens = wordpunct_tokenize(text) elif isinstance(text, list): tokens= text else: raise TypeError(\"lemmatize only works with strings or lists of string tokens.\") return [self._lemmatize_token(token, best_guess, return_frequencies) for token in tokens]"
            },
            {
                "url": 5810,
                "code": "def _prm_get_longest_stringsize(string_list): maxlength = 1 for stringar in string_list: if isinstance(stringar, np.ndarray): if stringar.ndim > 0: for string in stringar.ravel(): maxlength = max(len(string), maxlength) else: maxlength = max(len(stringar.tolist()), maxlength) else: maxlength = max(len(stringar), maxlength) # Make the string Col longer than needed in order to allow later on slightly larger strings return int(maxlength * 1.5)"
            },
            {
                "url": 50,
                "code": "def count(lines): words = [w for l in lines for w in l.strip().split()] return Counter(words)"
            },
            {
                "url": 1292,
                "code": "def split_into_sentences(s): s = re.sub(r\"\\s+\", \" \", s) s = re.sub(r\"[\\\\.\\\\?\\\\!]\", \"\\n\", s) return s.split(\"\\n\")"
            },
            {
                "url": 5548,
                "code": "def batch_split_sentences(self, texts: List[str]) -> List[List[str]]: return [self.split_sentences(text) for text in texts]"
            }
        ],
        "url": 3106
    },
    {
        "nl_input": "python deterministic dictionary printing",
        "code_input": [
            {
                "url": 2228,
                "code": "def printdict(adict): dlist = list(adict.keys()) dlist.sort() for i in range(0, len(dlist)): print(dlist[i], adict[dlist[i]])"
            },
            {
                "url": 1391,
                "code": "def pretty_dict_string(d, indent=0): s = '' for key, value in sorted(d.items()): s += ' ' * indent + str(key) if isinstance(value, dict): s += '\\n' + pretty_dict_string(value, indent+1) else: s += '=' + str(value) + '\\n' return s"
            },
            {
                "url": 5879,
                "code": "def pretty_dict(d): return '{%s}' % ', '.join('%r: %r' % (k, v) for k, v in sorted(d.items(), key=repr))"
            },
            {
                "url": 684,
                "code": "def pretty_dict_str(d, indent=2): b = StringIO() write_pretty_dict_str(b, d, indent=indent) return b.getvalue()"
            },
            {
                "url": 2227,
                "code": "def prettyprint(d): print(json.dumps(d, sort_keys=True, indent=4, separators=(\",\" , \": \")))"
            },
            {
                "url": 2904,
                "code": "def Print(self): for val, prob in sorted(self.d.iteritems()): print(val, prob)"
            },
            {
                "url": 920,
                "code": "def pprint_for_ordereddict(): od_saved = OrderedDict.__repr__ try: OrderedDict.__repr__ = dict.__repr__ yield finally: OrderedDict.__repr__ = od_saved"
            },
            {
                "url": 191,
                "code": "def dict_to_querystring(dictionary): s = u\"\" for d in dictionary.keys(): s = unicode.format(u\"{0}{1}={2}&\", s, d, dictionary[d]) return s[:-1]"
            },
            {
                "url": 4666,
                "code": "def setdict(self, D): self.D = np.asarray(D, dtype=self.dtype)"
            },
            {
                "url": 72,
                "code": "def _attrprint(d, delimiter=', '): return delimiter.join(('\"%s\"=\"%s\"' % item) for item in sorted(d.items()))"
            },
            {
                "url": 4627,
                "code": "def pprint(j, no_pretty): if not no_pretty: click.echo( json.dumps(j, cls=PotionJSONEncoder, sort_keys=True, indent=4, separators=(\",\", \": \")) ) else: click.echo(j)"
            },
            {
                "url": 1059,
                "code": "def _dict_to_proto(py_dict, proto): dict_json_str = json.dumps(py_dict) return json_format.Parse(dict_json_str, proto)"
            },
            {
                "url": 2685,
                "code": "def str_dict(some_dict): return {str(k): str(v) for k, v in some_dict.items()}"
            },
            {
                "url": 51,
                "code": "def dictapply(d, fn): for k, v in d.items(): if isinstance(v, dict): v = dictapply(v, fn) else: d[k] = fn(v) return d"
            },
            {
                "url": 4880,
                "code": "def _convert_dict_to_json(array): return json.dumps( array, skipkeys=False, allow_nan=False, indent=None, separators=(\",\", \":\"), sort_keys=True, default=lambda o: o.__dict__, )"
            }
        ],
        "url": 920
    },
    {
        "nl_input": "remove namespace from xml tag python",
        "code_input": [
            {
                "url": 2580,
                "code": "def strip_xml_namespace(root): try: root.tag = root.tag.split('}')[1] except IndexError: pass for element in root.getchildren(): strip_xml_namespace(element)"
            },
            {
                "url": 3747,
                "code": "def _strip_namespace(self, xml): p = re.compile(b\"xmlns=*[\\\"\\\"][^\\\"\\\"]*[\\\"\\\"]\") allmatches = p.finditer(xml) for match in allmatches: xml = xml.replace(match.group(), b\"\") return xml"
            },
            {
                "url": 6072,
                "code": "def remove_namespaces(root): for elem in root.getiterator(): if not hasattr(elem.tag, 'find'): continue i = elem.tag.find('}') if i >= 0: elem.tag = elem.tag[i + 1:] objectify.deannotate(root, cleanup_namespaces=True)"
            },
            {
                "url": 3151,
                "code": "def strip_html(string, keep_tag_content=False): r = HTML_TAG_ONLY_RE if keep_tag_content else HTML_RE return r.sub('', string)"
            },
            {
                "url": 1271,
                "code": "def GetAttributeNs(self, localName, namespaceURI): ret = libxml2mod.xmlTextReaderGetAttributeNs(self._o, localName, namespaceURI) return ret"
            },
            {
                "url": 5570,
                "code": "def recClearTag(element): children = element.getchildren() if len(children) > 0: for child in children: recClearTag(child) element.tag = clearTag(element.tag)"
            },
            {
                "url": 5459,
                "code": "def element_to_string(element, include_declaration=True, encoding=DEFAULT_ENCODING, method='xml'): if isinstance(element, ElementTree): element = element.getroot() elif not isinstance(element, ElementType): element = get_element(element) if element is None: return u'' element_as_string = tostring(element, encoding, method).decode(encoding=encoding) if include_declaration: return element_as_string else: return strip_xml_declaration(element_as_string)"
            },
            {
                "url": 3309,
                "code": "def xml_str_to_dict(s): xml = minidom.parseString(s) return pythonzimbra.tools.xmlserializer.dom_to_dict(xml.firstChild)"
            },
            {
                "url": 1443,
                "code": "def _RemoveIllegalXMLCharacters(self, xml_string): if not isinstance(xml_string, py2to3.STRING_TYPES): return xml_string return self._ILLEGAL_XML_RE.sub('\\ufffd', xml_string)"
            },
            {
                "url": 2520,
                "code": "def cleanup_nodes(doc): for node in doc.documentElement.childNodes: if node.nodeType == Node.TEXT_NODE and node.nodeValue.isspace(): doc.documentElement.removeChild(node) return doc"
            },
            {
                "url": 2994,
                "code": "def pretty_xml(data): parsed_string = minidom.parseString(data.decode('utf-8')) return parsed_string.toprettyxml(indent='\\t', encoding='utf-8')"
            },
            {
                "url": 1766,
                "code": "def iterparse(source, tag, clear=False, events=None): for event, elem in ElementTree.iterparse(source, events=events): if elem.tag == tag: yield elem if clear: elem.clear()"
            },
            {
                "url": 476,
                "code": "def __get_xml_text(root): txt = \"\" for e in root.childNodes: if (e.nodeType == e.TEXT_NODE): txt += e.data return txt"
            },
            {
                "url": 3916,
                "code": "def copy_of_xml_element(elem): copyElem = ElementTree.Element(elem.tag, elem.attrib) for child in elem: copyElem.append(child) return copyElem"
            },
            {
                "url": 3792,
                "code": "def do_striptags(value): if hasattr(value, '__html__'): value = value.__html__() return Markup(unicode(value)).striptags()"
            }
        ],
        "url": 2580
    },
    {
        "nl_input": "fill is null with other columns python",
        "code_input": [
            {
                "url": 1801,
                "code": "def fill_nulls(self, col: str): n = [None, \"\"] try: self.df[col] = self.df[col].replace(n, nan) except Exception as e: self.err(e)"
            },
            {
                "url": 6165,
                "code": "def fix_missing(df, col, name, na_dict): if is_numeric_dtype(col): if pd.isnull(col).sum() or (name in na_dict): df[name+'_na'] = pd.isnull(col) filler = na_dict[name] if name in na_dict else col.median() df[name] = col.fillna(filler) na_dict[name] = filler return na_dict"
            },
            {
                "url": 5659,
                "code": "def is_not_null(df: DataFrame, col_name: str) -> bool: if ( isinstance(df, pd.DataFrame) and col_name in df.columns and df[col_name].notnull().any() ): return True else: return False"
            },
            {
                "url": 5021,
                "code": "def count_nulls(self, field): try: n = self.df[field].isnull().sum() except KeyError: self.warning(\"Can not find column\", field) return except Exception as e: self.err(e, \"Can not count nulls\") return self.ok(\"Found\", n, \"nulls in column\", field)"
            },
            {
                "url": 292,
                "code": "def _maybe_fill(arr, fill_value=np.nan): if _isna_compat(arr, fill_value): arr.fill(fill_value) return arr"
            },
            {
                "url": 2333,
                "code": "def clean_df(df, fill_nan=True, drop_empty_columns=True): if fill_nan: df = df.fillna(value=np.nan) if drop_empty_columns: df = df.dropna(axis=1, how='all') return df.sort_index()"
            },
            {
                "url": 889,
                "code": "def clean_dataframe(df): df = df.fillna(method='ffill') df = df.fillna(0.0) return df"
            },
            {
                "url": 4722,
                "code": "def fillna(series_or_arr, missing_value=0.0): if pandas.notnull(missing_value): if isinstance(series_or_arr, (numpy.ndarray)): series_or_arr[numpy.isnan(series_or_arr)] = missing_value else: series_or_arr.fillna(missing_value, inplace=True) return series_or_arr"
            },
            {
                "url": 5807,
                "code": "def inject_nulls(data: Mapping, field_names) -> dict: record = dict() for field in field_names: record[field] = data.get(field, None) return record"
            },
            {
                "url": 5888,
                "code": "def warn_if_nans_exist(X): null_count = count_rows_with_nans(X) total = len(X) percent = 100 * null_count / total if null_count > 0: warning_message = \\ 'Warning! Found {} rows of {} ({:0.2f}%) with nan values. Only ' \\ 'complete rows will be plotted.'.format(null_count, total, percent) warnings.warn(warning_message, DataWarning)"
            },
            {
                "url": 1025,
                "code": "def _replace_nan(a, val): mask = isnull(a) return where_method(val, mask, a), mask"
            },
            {
                "url": 6089,
                "code": "def columns_equal(a: Column, b: Column) -> bool: return ( a.name == b.name and column_types_equal(a.type, b.type) and a.nullable == b.nullable )"
            },
            {
                "url": 5399,
                "code": "def table_nan_locs(table): ans = [] for rownum, row in enumerate(table): try: if pd.isnull(row).any(): colnums = pd.isnull(row).nonzero()[0] ans += [(rownum, colnum) for colnum in colnums] except AttributeError: # table is really just a sequence of scalars if pd.isnull(row): ans += [(rownum, 0)] return ans"
            },
            {
                "url": 2964,
                "code": "def _replace_none(self, aDict): for k, v in aDict.items(): if v is None: aDict[k] = 'none'"
            },
            {
                "url": 5616,
                "code": "def clean_column_names(df: DataFrame) -> DataFrame: f = df.copy() f.columns = [col.strip() for col in f.columns] return f"
            }
        ],
        "url": 889
    },
    {
        "nl_input": "python async input from gui",
        "code_input": [
            {
                "url": 975,
                "code": "async def async_input(prompt): print(prompt, end='', flush=True) return (await loop.run_in_executor(None, sys.stdin.readline)).rstrip()"
            },
            {
                "url": 6170,
                "code": "def input(prompt=\"\"): string = stdin_decode(raw_input(prompt)) caller_frame = sys._getframe(1) globals = caller_frame.f_globals locals = caller_frame.f_locals return eval(string, globals, locals)"
            },
            {
                "url": 705,
                "code": "def _stdin_(p): _v = sys.version[0] return input(p) if _v is '3' else raw_input(p)"
            },
            {
                "url": 973,
                "code": "def _read_stdin(): line = sys.stdin.readline() while line: yield line line = sys.stdin.readline()"
            },
            {
                "url": 63,
                "code": "def string_input(prompt=''): v = sys.version[0] if v == '3': return input(prompt) else: return raw_input(prompt)"
            },
            {
                "url": 2559,
                "code": "def standard_input(): with click.get_text_stream(\"stdin\") as stdin: while stdin.readable(): line = stdin.readline() if line: yield line.strip().encode(\"utf-8\")"
            },
            {
                "url": 5728,
                "code": "async def async_run(self) -> None: self.main_task = self.loop.create_task(self.main()) await self.main_task"
            },
            {
                "url": 1098,
                "code": "async def readline(self): future = asyncio.Future() data_available = False while True: if not data_available: if not self.my_serial.inWaiting(): await asyncio.sleep(self.sleep_tune) else: data_available = True data = self.my_serial.readline() future.set_result(data) else: if not future.done(): await asyncio.sleep(self.sleep_tune) else: return future.result()"
            },
            {
                "url": 5360,
                "code": "def wait_run_in_executor(func, *args, **kwargs): loop = asyncio.get_event_loop() future = loop.run_in_executor(None, functools.partial(func, *args, **kwargs)) yield from asyncio.wait([future]) return future.result()"
            },
            {
                "url": 2521,
                "code": "def _run_asyncio(loop, zmq_context): try: asyncio.set_event_loop(loop) loop.run_forever() except: pass finally: loop.close() zmq_context.destroy(1000)"
            },
            {
                "url": 5939,
                "code": "async def stdout(self) -> AsyncGenerator[str, None]: await self.wait_running() async for line in self._subprocess.stdout: # type: ignore yield line"
            },
            {
                "url": 1989,
                "code": "def read_stdin(): if sys.stdin.isatty() and sys.stdout.isatty(): print('\\nReading from stdin until end of file (Ctrl + D)...') return sys.stdin.read()"
            },
            {
                "url": 2623,
                "code": "async def wait_and_quit(loop): from pylp.lib.tasks import running if running: await asyncio.wait(map(lambda runner: runner.future, running))"
            },
            {
                "url": 504,
                "code": "def __init__(self, encoding='utf-8'): super(StdinInputReader, self).__init__(sys.stdin, encoding=encoding)"
            },
            {
                "url": 3844,
                "code": "def main(): time.sleep(1) with Input() as input_generator: for e in input_generator: print(repr(e))"
            }
        ],
        "url": 975
    },
    {
        "nl_input": "how to identify the index of an element of a set in python",
        "code_input": [
            {
                "url": 6214,
                "code": "def index(self, item): for i, x in enumerate(self.iter()): if x == item: return i return None"
            },
            {
                "url": 2031,
                "code": "def index(self, elem): return _coconut.len(self._iter) - self._iter.index(elem) - 1"
            },
            {
                "url": 2075,
                "code": "def index(m, val): mm = np.array(m) idx_tuple = np.where(mm == val) idx = idx_tuple[0].tolist() return idx"
            },
            {
                "url": 3021,
                "code": "def elem_find(self, field, value): if isinstance(value, (int, float, str)): value = [value] f = list(self.__dict__[field]) uid = np.vectorize(f.index)(value) return self.get_idx(uid)"
            },
            {
                "url": 456,
                "code": "def get_list_index(lst, index_or_name): if isinstance(index_or_name, six.integer_types): return index_or_name return lst.index(index_or_name)"
            },
            {
                "url": 1114,
                "code": "def discard(self, element): try: i = int(element) set.discard(self, i) except ValueError: pass"
            },
            {
                "url": 567,
                "code": "def _ensure_element(tup, elem): try: return tup, tup.index(elem) except ValueError: return tuple(chain(tup, (elem,))), len(tup)"
            },
            {
                "url": 5619,
                "code": "def _duplicates(list_): item_indices = {} for i, item in enumerate(list_): try: item_indices[item].append(i) except KeyError: # First time seen item_indices[item] = [i] return item_indices"
            },
            {
                "url": 2444,
                "code": "def is_in(self, search_list, pair): index = -1 for nr, i in enumerate(search_list): if(np.all(i == pair)): return nr return index"
            },
            {
                "url": 4613,
                "code": "def get_index_nested(x, i): for ind in range(len(x)): if i == x[ind]: return ind return -1"
            },
            {
                "url": 2966,
                "code": "def _get_item_position(self, idx): start = 0 if idx == 0 else self._index[idx - 1] + 1 end = self._index[idx] return start, end"
            },
            {
                "url": 2626,
                "code": "def add(self, value): if value not in self._set: self._set.add(value) self._list.add(value)"
            },
            {
                "url": 5952,
                "code": "def find_index(segmentation, stroke_id): for i, symbol in enumerate(segmentation): for sid in symbol: if sid == stroke_id: return i return -1"
            },
            {
                "url": 2314,
                "code": "def where_is(strings, pattern, n=1, lookup_func=re.match): count = 0 for idx, item in enumerate(strings): if lookup_func(pattern, item): count += 1 if count == n: return idx return -1"
            },
            {
                "url": 1757,
                "code": "def items(iterable): if hasattr(iterable, 'iteritems'): return (p for p in iterable.iteritems()) elif hasattr(iterable, 'items'): return (p for p in iterable.items()) else: return (p for p in enumerate(iterable))"
            }
        ],
        "url": 1272
    },
    {
        "nl_input": "python 3 print object string",
        "code_input": [
            {
                "url": 1942,
                "code": "def _get_pretty_string(obj): sio = StringIO() pprint.pprint(obj, stream=sio) return sio.getvalue()"
            },
            {
                "url": 2806,
                "code": "def to_str(obj): if not isinstance(obj, str) and PY3 and isinstance(obj, bytes): obj = obj.decode('utf-8') return obj if isinstance(obj, string_types) else str(obj)"
            },
            {
                "url": 926,
                "code": "def pretty(obj, verbose=False, max_width=79, newline='\\n'): stream = StringIO() printer = RepresentationPrinter(stream, verbose, max_width, newline) printer.pretty(obj) printer.flush() return stream.getvalue()"
            },
            {
                "url": 2225,
                "code": "def pprint(obj, verbose=False, max_width=79, newline='\\n'): printer = RepresentationPrinter(sys.stdout, verbose, max_width, newline) printer.pretty(obj) printer.flush() sys.stdout.write(newline) sys.stdout.flush()"
            },
            {
                "url": 31,
                "code": "def pformat(object, indent=1, width=80, depth=None): return PrettyPrinter(indent=indent, width=width, depth=depth).pformat(object)"
            },
            {
                "url": 2227,
                "code": "def prettyprint(d): print(json.dumps(d, sort_keys=True, indent=4, separators=(\",\" , \": \")))"
            },
            {
                "url": 4627,
                "code": "def pprint(j, no_pretty): if not no_pretty: click.echo( json.dumps(j, cls=PotionJSONEncoder, sort_keys=True, indent=4, separators=(\",\", \": \")) ) else: click.echo(j)"
            },
            {
                "url": 2230,
                "code": "def pprint(o, stream=None, indent=1, width=80, depth=None): printer = PrettyPrinter( stream=stream, indent=indent, width=width, depth=depth) printer.pprint(o)"
            },
            {
                "url": 925,
                "code": "def py(self, output): import pprint pprint.pprint(output, stream=self.outfile)"
            },
            {
                "url": 3339,
                "code": "def print(cls, *args, **kwargs): # pylint: disable=protected-access with _shared._PRINT_LOCK: print(*args, **kwargs) _sys.stdout.flush()"
            },
            {
                "url": 5918,
                "code": "def fprint(expr, print_ascii=False): r if print_ascii: pprint(expr, use_unicode=False, num_columns=120) else: return expr"
            },
            {
                "url": 684,
                "code": "def pretty_dict_str(d, indent=2): b = StringIO() write_pretty_dict_str(b, d, indent=indent) return b.getvalue()"
            },
            {
                "url": 3736,
                "code": "def pprint(self, stream=None, indent=1, width=80, depth=None): pp.pprint(to_literal(self), stream, indent, width, depth)"
            },
            {
                "url": 2538,
                "code": "def to_string(s, encoding='utf-8'): if six.PY2: return s.encode(encoding) if isinstance(s, bytes): return s.decode(encoding) return s"
            },
            {
                "url": 3965,
                "code": "def Dump(obj): text = yaml.safe_dump(obj, default_flow_style=False, allow_unicode=True) if compatibility.PY2: text = text.decode(\"utf-8\") return text"
            }
        ],
        "url": 1942
    },
    {
        "nl_input": "python get most recent file containing string",
        "code_input": [
            {
                "url": 958,
                "code": "def newest_file(file_iterable): return max(file_iterable, key=lambda fname: os.path.getmtime(fname))"
            },
            {
                "url": 1637,
                "code": "def last_modified_date(filename): mtime = os.path.getmtime(filename) dt = datetime.datetime.utcfromtimestamp(mtime) return dt.replace(tzinfo=pytz.utc)"
            },
            {
                "url": 704,
                "code": "def get_last_modified_timestamp(self): cmd = \"find . -print0 | xargs -0 stat -f '%T@ %p' | sort -n | tail -1 | cut -f2- -d' '\" ps = subprocess.Popen(cmd,shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT) output = ps.communicate()[0] print output"
            },
            {
                "url": 5673,
                "code": "def grep(pattern, filename): try: # for line in file # if line matches pattern: # return line return next((L for L in open(filename) if L.find(pattern) >= 0)) except StopIteration: return ''"
            },
            {
                "url": 5690,
                "code": "def has_changed (filename): key = os.path.abspath(filename) mtime = get_mtime(key) if key not in _mtime_cache: _mtime_cache[key] = mtime return True return mtime > _mtime_cache[key]"
            },
            {
                "url": 1975,
                "code": "def wget(url): import urllib.parse request = urllib.request.urlopen(url) filestring = request.read() return filestring"
            },
            {
                "url": 1051,
                "code": "def get_file_string(filepath): with open(os.path.abspath(filepath)) as f: return f.read()"
            },
            {
                "url": 5631,
                "code": "def most_frequent(lst): lst = lst[:] highest_freq = 0 most_freq = None for val in unique(lst): if lst.count(val) > highest_freq: most_freq = val highest_freq = lst.count(val) return most_freq"
            },
            {
                "url": 1863,
                "code": "def dir_modtime(dpath): return max(os.path.getmtime(d) for d, _, _ in os.walk(dpath))"
            },
            {
                "url": 3577,
                "code": "def get_creation_datetime(filepath): if platform.system() == 'Windows': return datetime.fromtimestamp(os.path.getctime(filepath)) else: stat = os.stat(filepath) try: return datetime.fromtimestamp(stat.st_birthtime) except AttributeError: # We're probably on Linux. No easy way to get creation dates here, # so we'll settle for when its content was last modified. return None"
            },
            {
                "url": 5840,
                "code": "def sort_by_modified(files_or_folders: list) -> list: return sorted(files_or_folders, key=os.path.getmtime, reverse=True)"
            },
            {
                "url": 4571,
                "code": "def find_largest_contig(contig_lengths_dict): # Initialise the dictionary longest_contig_dict = dict() for file_name, contig_lengths in contig_lengths_dict.items(): # As the list is sorted in descending order, the largest contig is the first entry in the list longest_contig_dict[file_name] = contig_lengths[0] return longest_contig_dict"
            },
            {
                "url": 4978,
                "code": "def _latest_date(self, query, datetime_field_name): return list( query.aggregate(django.db.models.Max(datetime_field_name)).values() )[0]"
            },
            {
                "url": 2452,
                "code": "def fileModifiedTimestamp(fname): modifiedTime=os.path.getmtime(fname) stamp=time.strftime('%Y-%m-%d', time.localtime(modifiedTime)) return stamp"
            },
            {
                "url": 2004,
                "code": "def _most_common(iterable): data = Counter(iterable) return max(data, key=data.__getitem__)"
            }
        ],
        "url": 958
    },
    {
        "nl_input": "python sqlite3 delete doesn't delete records",
        "code_input": [
            {
                "url": 5503,
                "code": "def wipe(self): query = \"DELETE FROM {}\".format(self.__tablename__) connection = sqlite3.connect(self.sqlite_file) cursor = connection.cursor() cursor.execute(query) connection.commit()"
            },
            {
                "url": 5959,
                "code": "def wipe_table(self, table: str) -> int: sql = \"DELETE FROM \" + self.delimit(table) return self.db_exec(sql)"
            },
            {
                "url": 938,
                "code": "def clear_table(dbconn, table_name): cur = dbconn.cursor() cur.execute(\"DELETE FROM '{name}'\".format(name=table_name)) dbconn.commit()"
            },
            {
                "url": 5384,
                "code": "def destroy(self): with self._db_conn() as conn: for table_name in self._tables: conn.execute('DROP TABLE IF EXISTS %s' % table_name) return self"
            },
            {
                "url": 1950,
                "code": "def wipe(self): keys = list(self.keys()).copy() for key in keys: self.delete(key)"
            },
            {
                "url": 5107,
                "code": "def truncate_table(self, tablename): self.get(tablename).remove() self.db.commit()"
            },
            {
                "url": 3059,
                "code": "def drop_all_tables(self): for table_name in self.table_names(): self.execute_sql(\"DROP TABLE %s\" % table_name) self.connection.commit()"
            },
            {
                "url": 4747,
                "code": "def delete(self, key_name): self.db.remove(Query().name == key_name) return self.get(key_name) == {}"
            },
            {
                "url": 209,
                "code": "def delete_all_from_db(): # The models.CASCADE property is set on all ForeignKey fields, so tables can # be deleted in any order without breaking constraints. for model in django.apps.apps.get_models(): model.objects.all().delete()"
            },
            {
                "url": 3073,
                "code": "def delete(self, row): i = self._get_key_index(row) del self.keys[i]"
            },
            {
                "url": 264,
                "code": "def cleanup(self, app): if hasattr(self.database.obj, 'close_all'): self.database.close_all()"
            },
            {
                "url": 6069,
                "code": "def drop_column(self, tablename: str, fieldname: str) -> int: sql = \"ALTER TABLE {} DROP COLUMN {}\".format(tablename, fieldname) log.info(sql) return self.db_exec_literal(sql)"
            },
            {
                "url": 5041,
                "code": "def __del__(self): if self._delete_file: try: os.remove(self.name) except (OSError, IOError): pass"
            },
            {
                "url": 4062,
                "code": "def __delitem__(self, key): index, value = self._dict.pop(key) key2, value2 = self._list.pop(index) assert key == key2 assert value is value2 self._fix_indices_after_delete(index)"
            },
            {
                "url": 2569,
                "code": "def _delete_keys(dct, keys): c = deepcopy(dct) assert isinstance(keys, list) for k in keys: c.pop(k) return c"
            }
        ],
        "url": 5107
    },
    {
        "nl_input": "python apply function to iterator",
        "code_input": [
            {
                "url": 2498,
                "code": "def map(cls, iterable, func, *a, **kw): return cls(func(x, *a, **kw) for x in iterable)"
            },
            {
                "url": 325,
                "code": "def _accumulate(sequence, func): iterator = iter(sequence) total = next(iterator) yield total for element in iterator: total = func(total, element) yield total"
            },
            {
                "url": 4964,
                "code": "def apply(self, func, args=(), kwds=dict()): return self.apply_async(func, args, kwds).get()"
            },
            {
                "url": 3694,
                "code": "def apply(self, func, workers=1, job_size=10000): if workers == 1: for lines in self.iter_chunks(job_size): yield func(lines) else: with ProcessPoolExecutor(max_workers=workers) as executor: for result in executor.map(func, self.iter_chunks(job_size)): yield result"
            },
            {
                "url": 51,
                "code": "def dictapply(d, fn): for k, v in d.items(): if isinstance(v, dict): v = dictapply(v, fn) else: d[k] = fn(v) return d"
            },
            {
                "url": 5886,
                "code": "def reduce(function, initval=None): if initval is None: return lambda s: __builtin__.reduce(function, s) else: return lambda s: __builtin__.reduce(function, s, initval)"
            },
            {
                "url": 1714,
                "code": "def generator_to_list(fn): def wrapper(*args, **kw): return list(fn(*args, **kw)) return wrapper"
            },
            {
                "url": 5579,
                "code": "def mmap(func, iterable): if sys.version_info[0] > 2: return [i for i in map(func, iterable)] else: return map(func, iterable)"
            },
            {
                "url": 4204,
                "code": "def _varargs_to_iterable_method(func): def wrapped(self, iterable, **kwargs): return func(self, *iterable, **kwargs) return wrapped"
            },
            {
                "url": 506,
                "code": "def apply(f, obj, *args, **kwargs): return vectorize(f)(obj, *args, **kwargs)"
            },
            {
                "url": 5655,
                "code": "def _izip(*iterables): # This izip routine is from itertools # izip('ABCD', 'xy') --> Ax By iterators = map(iter, iterables) while iterators: yield tuple(map(next, iterators))"
            },
            {
                "url": 5835,
                "code": "def __iter__(self): def generator(): for i, obj in enumerate(self._sequence): if i >= self._limit: break yield obj raise StopIteration return generator"
            },
            {
                "url": 4016,
                "code": "def pool_args(function, sequence, kwargs): return zip(itertools.repeat(function), sequence, itertools.repeat(kwargs))"
            },
            {
                "url": 3695,
                "code": "def multiprocess_mapping(func, iterable): if os.name == 'nt': # In Windows there is no fork. return list(map(func, iterable)) try: p = multiprocessing.Pool() return_data = list(p.imap(func, iterable)) p.close() p.join() return return_data except OSError: return list(map(func, iterable))"
            },
            {
                "url": 5615,
                "code": "def iterate_items(dictish): if hasattr(dictish, 'iteritems'): return dictish.iteritems() if hasattr(dictish, 'items'): return dictish.items() return dictish"
            }
        ],
        "url": 3963
    },
    {
        "nl_input": "use python next to iterate through",
        "code_input": [
            {
                "url": 2755,
                "code": "def next(self): # I'm pretty sure this is the completely wrong way to go about this, but # oh well, this works. if not hasattr(self, '_iter'): self._iter = self.readrow_as_dict() return self._iter.next()"
            },
            {
                "url": 5561,
                "code": "def __next__(self): self.current += 1 if self.current > self.total: raise StopIteration else: return self.iterable[self.current - 1]"
            },
            {
                "url": 1137,
                "code": "def skip(self, n): try: self._iter_object.skip(n) except AttributeError: for i in range(0, n): self.next()"
            },
            {
                "url": 1973,
                "code": "def iterate(obj): global next, Iteration next = next Iteration = Iteration total = len(obj) if isinstance(obj, Sized) else None iterator = iter(obj) first = True last = False i = 0 try: value = next(iterator) except StopIteration: return while True: try: next_value = next(iterator) except StopIteration: last = True yield Iteration(first, last, i, total, value) if last: return value = next_value i += 1 first = False"
            },
            {
                "url": 1630,
                "code": "def peekiter(iterable): it = iter(iterable) one = next(it) def gen(): \"\"\"Generator that returns first and proxy other items from source\"\"\" yield one while True: yield next(it) return (one, gen())"
            },
            {
                "url": 4999,
                "code": "def next(self): _LOGGER.debug(\"reading next\") if self.closed: _LOGGER.debug(\"stream is closed\") raise StopIteration() line = self.readline() if not line: _LOGGER.debug(\"nothing more to read\") raise StopIteration() return line"
            },
            {
                "url": 5615,
                "code": "def iterate_items(dictish): if hasattr(dictish, 'iteritems'): return dictish.iteritems() if hasattr(dictish, 'items'): return dictish.items() return dictish"
            },
            {
                "url": 579,
                "code": "def next (self): # File-like object. result = self.readline() if result == self._empty_buffer: raise StopIteration return result"
            },
            {
                "url": 3090,
                "code": "def autopage(self): while self.items: yield from self.items self.items = self.fetch_next()"
            },
            {
                "url": 3109,
                "code": "def __call__(self, _): if self.iter % self.step == 0: print(self.fmt.format(self.iter), **self.kwargs) self.iter += 1"
            },
            {
                "url": 5835,
                "code": "def __iter__(self): def generator(): for i, obj in enumerate(self._sequence): if i >= self._limit: break yield obj raise StopIteration return generator"
            },
            {
                "url": 36,
                "code": "def do_next(self, args): self._do_print_from_last_cmd = True self._interp.step_over() return True"
            },
            {
                "url": 5721,
                "code": "def butlast(iterable): iterable = iter(iterable) try: first = next(iterable) except StopIteration: return for second in iterable: yield first first = second"
            },
            {
                "url": 5252,
                "code": "def fromiterable(cls, itr): x, y, z = itr return cls(x, y, z)"
            },
            {
                "url": 1590,
                "code": "def __next__(self): # Retrieve the row, thereby incrementing the line number: row = super(UnicodeReaderWithLineNumber, self).__next__() return self.lineno + 1, row"
            }
        ],
        "url": 1968
    },
    {
        "nl_input": "how to print all the variables in an object python",
        "code_input": [
            {
                "url": 2223,
                "code": "def print_param_values(self_): self = self_.self for name,val in self.param.get_param_values(): print('%s.%s = %s' % (self.name,name,val))"
            },
            {
                "url": 2570,
                "code": "def var_dump(*obs): i = 0 for x in obs: str = var_dump_output(x, 0, ' ', '\\n', True) print (str.strip()) #dump(x, 0, i, '', object) i += 1"
            },
            {
                "url": 1697,
                "code": "def format_vars(args): variables = [] for key, value in args.items(): if value: variables += ['{0}={1}'.format(key, value)] return variables"
            },
            {
                "url": 4526,
                "code": "def get_object_as_string(obj): if isinstance(obj, str): return obj if isinstance(obj, list): return '\\r\\n\\;'.join([get_object_as_string(item) for item in obj]) attrs = vars(obj) as_string = ', '.join(\"%s: %s\" % item for item in attrs.items()) return as_string"
            },
            {
                "url": 1942,
                "code": "def _get_pretty_string(obj): sio = StringIO() pprint.pprint(obj, stream=sio) return sio.getvalue()"
            },
            {
                "url": 1553,
                "code": "def print_env_info(key, out=sys.stderr): value = os.getenv(key) if value is not None: print(key, \"=\", repr(value), file=out)"
            },
            {
                "url": 3654,
                "code": "def vars_(self): return [x for x in self[self.current_scope].values() if x.class_ == CLASS.var]"
            },
            {
                "url": 4601,
                "code": "def get_variables(args): variables_dict = {} if args.variables: for var in args.variables: words = var.split('=') variables_dict[words[0]] = words[1] return variables_dict"
            },
            {
                "url": 1793,
                "code": "def getvariable(name): import inspect fr = inspect.currentframe() try: while fr: fr = fr.f_back vars = fr.f_locals if name in vars: return vars[name] except: pass return None"
            },
            {
                "url": 2611,
                "code": "def print_statements(self): for i, stmt in enumerate(self.statements): print(\"%s: %s\" % (i, stmt))"
            },
            {
                "url": 2904,
                "code": "def Print(self): for val, prob in sorted(self.d.iteritems()): print(val, prob)"
            },
            {
                "url": 3339,
                "code": "def print(cls, *args, **kwargs): # pylint: disable=protected-access with _shared._PRINT_LOCK: print(*args, **kwargs) _sys.stdout.flush()"
            },
            {
                "url": 5837,
                "code": "def format_repr(obj, attributes) -> str: attribute_repr = ', '.join(('{}={}'.format(attr, repr(getattr(obj, attr))) for attr in attributes)) return \"{0}({1})\".format(obj.__class__.__qualname__, attribute_repr)"
            },
            {
                "url": 925,
                "code": "def py(self, output): import pprint pprint.pprint(output, stream=self.outfile)"
            },
            {
                "url": 926,
                "code": "def pretty(obj, verbose=False, max_width=79, newline='\\n'): stream = StringIO() printer = RepresentationPrinter(stream, verbose, max_width, newline) printer.pretty(obj) printer.flush() return stream.getvalue()"
            }
        ],
        "url": 2570
    },
    {
        "nl_input": "how to determine the index interval for given range of array python",
        "code_input": [
            {
                "url": 3123,
                "code": "def get_range(self, start=None, stop=None): return self.from_iterable(self.ranges(start, stop))"
            },
            {
                "url": 1495,
                "code": "def array(self): return np.arange(self.start, self.stop, self.step)"
            },
            {
                "url": 3405,
                "code": "def range(*args, interval=0): agen = from_iterable.raw(builtins.range(*args)) return time.spaceout.raw(agen, interval) if interval else agen"
            },
            {
                "url": 5059,
                "code": "def _parse_ranges(ranges): for txt in ranges: if '-' in txt: low, high = txt.split('-') else: low, high = txt, txt yield int(low), int(high)"
            },
            {
                "url": 68,
                "code": "def _xxrange(self, start, end, step_count): _step = (end - start) / float(step_count) return (start + (i * _step) for i in xrange(int(step_count)))"
            },
            {
                "url": 6230,
                "code": "def ranges_to_set(lst): return set(itertools.chain(*(range(x[0], x[1]+1) for x in lst)))"
            },
            {
                "url": 140,
                "code": "def _interval_to_bound_points(array): array_boundaries = np.array([x.left for x in array]) array_boundaries = np.concatenate( (array_boundaries, np.array([array[-1].right]))) return array_boundaries"
            },
            {
                "url": 111,
                "code": "def daterange(start, end, delta=timedelta(days=1), lower=Interval.CLOSED, upper=Interval.OPEN): date_interval = Interval(lower=lower, lower_value=start, upper_value=end, upper=upper) current = start if start in date_interval else start + delta while current in date_interval: yield current current = current + delta"
            },
            {
                "url": 1844,
                "code": "def daterange(start_date, end_date): for n in range(int((end_date - start_date).days)): yield start_date + timedelta(n)"
            },
            {
                "url": 2095,
                "code": "def time_range(from_=None, to=None): # todo datetime conversion args = locals() return { k.replace('_', ''): v for k, v in args.items() }"
            },
            {
                "url": 4176,
                "code": "def _index_range(self, version, symbol, from_version=None, **kwargs): from_index = None if from_version: from_index = from_version['up_to'] return from_index, None"
            },
            {
                "url": 5936,
                "code": "def set_range(self, min_val, max_val): if min_val > max_val: max_val, min_val = min_val, max_val self.values = (((self.values * 1.0 - self.values.min()) / (self.values.max() - self.values.min())) * (max_val - min_val) + min_val)"
            },
            {
                "url": 5073,
                "code": "def to_linspace(self): num = int((self.stop-self.start)/(self.step)) return Linspace(self.start, self.stop-self.step, num)"
            },
            {
                "url": 3124,
                "code": "def LinSpace(start, stop, num): return np.linspace(start, stop, num=num, dtype=np.float32),"
            },
            {
                "url": 6063,
                "code": "def _infer_interval_breaks(coord): coord = np.asarray(coord) deltas = 0.5 * (coord[1:] - coord[:-1]) first = coord[0] - deltas[0] last = coord[-1] + deltas[-1] return np.r_[[first], coord[:-1] + deltas, [last]]"
            }
        ],
        "url": 6063
    },
    {
        "nl_input": "python print numpy array with string",
        "code_input": [
            {
                "url": 3500,
                "code": "def ndarr2str(arr, encoding='ascii'): # be fast, don't check - just assume 'arr' is a numpy array - the tostring # call will fail anyway if not retval = arr.tostring() # would rather check \"if isinstance(retval, bytes)\", but support 2.5. # could rm the if PY3K check, but it makes this faster on 2.x. if PY3K and not isinstance(retval, str): return retval.decode(encoding) else: # is str return retval"
            },
            {
                "url": 5651,
                "code": "def array2string(arr: numpy.ndarray) -> str: shape = str(arr.shape)[1:-1] if shape.endswith(\",\"): shape = shape[:-1] return numpy.array2string(arr, threshold=11) + \"%s[%s]\" % (arr.dtype, shape)"
            },
            {
                "url": 4510,
                "code": "def np2str(value): if hasattr(value, 'dtype') and \\ issubclass(value.dtype.type, (np.string_, np.object_)) and value.size == 1: value = np.asscalar(value) if not isinstance(value, str): # python 3 - was scalar numpy array of bytes # otherwise python 2 - scalar numpy array of 'str' value = value.decode() return value else: raise ValueError(\"Array is not a string type or is larger than 1\")"
            },
            {
                "url": 5880,
                "code": "def array_to_npy(array_like): # type: (np.array or Iterable or int or float) -> object buffer = BytesIO() np.save(buffer, array_like) return buffer.getvalue()"
            },
            {
                "url": 2619,
                "code": "def dump_nparray(self, obj, class_name=numpy_ndarray_class_name): return {\"$\" + class_name: self._json_convert(obj.tolist())}"
            },
            {
                "url": 5746,
                "code": "def csv_to_numpy(string_like, dtype=None): # type: (str) -> np.array stream = StringIO(string_like) return np.genfromtxt(stream, dtype=dtype, delimiter=',')"
            },
            {
                "url": 12,
                "code": "def _array2cstr(arr): out = StringIO() np.save(out, arr) return b64encode(out.getvalue())"
            },
            {
                "url": 1583,
                "code": "def dict_to_numpy_array(d): return fromarrays(d.values(), np.dtype([(str(k), v.dtype) for k, v in d.items()]))"
            },
            {
                "url": 9,
                "code": "def _convert_to_array(array_like, dtype): if isinstance(array_like, bytes): return np.frombuffer(array_like, dtype=dtype) return np.asarray(array_like, dtype=dtype)"
            },
            {
                "url": 6117,
                "code": "def numpy_to_yaml(representer: Representer, data: np.ndarray) -> Sequence[Any]: return representer.represent_sequence( \"!numpy_array\", data.tolist() )"
            },
            {
                "url": 4776,
                "code": "def _ndarray_representer(dumper, data): mapping = [('object', data.tolist()), ('dtype', data.dtype.name)] return dumper.represent_mapping(_NUMPY_ARRAY_TAG, mapping)"
            },
            {
                "url": 5152,
                "code": "def _parse_array(self, tensor_proto): try: from onnx.numpy_helper import to_array except ImportError as e: raise ImportError(\"Unable to import onnx which is required {}\".format(e)) np_array = to_array(tensor_proto).reshape(tuple(tensor_proto.dims)) return mx.nd.array(np_array)"
            },
            {
                "url": 3072,
                "code": "def _numpy_bytes_to_char(arr): # ensure the array is contiguous arr = np.array(arr, copy=False, order='C', dtype=np.string_) return arr.reshape(arr.shape + (1,)).view('S1')"
            },
            {
                "url": 126,
                "code": "def convert_array(array): out = io.BytesIO(array) out.seek(0) return np.load(out)"
            },
            {
                "url": 56,
                "code": "def _numpy_char_to_bytes(arr): # based on: http://stackoverflow.com/a/10984878/809705 arr = np.array(arr, copy=False, order='C') dtype = 'S' + str(arr.shape[-1]) return arr.view(dtype).reshape(arr.shape[:-1])"
            }
        ],
        "url": 5651
    },
    {
        "nl_input": "python assert value is of type",
        "code_input": [
            {
                "url": 1519,
                "code": "def _assert_is_type(name, value, value_type): if not isinstance(value, value_type): if type(value_type) is tuple: types = ', '.join(t.__name__ for t in value_type) raise ValueError('{0} must be one of ({1})'.format(name, types)) else: raise ValueError('{0} must be {1}' .format(name, value_type.__name__))"
            },
            {
                "url": 3975,
                "code": "def assert_is_instance(value, types, message=None, extra=None): assert isinstance(value, types), _assert_fail_message( message, value, types, \"is not an instance of\", extra )"
            },
            {
                "url": 768,
                "code": "def is_type(value): if isinstance(value, type): return issubclass(value, Type) return isinstance(value, Type)"
            },
            {
                "url": 2376,
                "code": "def validate_type(self, type_): if type_ is not None and type_ not in self.types_set: raise ValueError('Invalid type for %s:%s' % (self.__class__, type_))"
            },
            {
                "url": 285,
                "code": "def make_kind_check(python_types, numpy_kind): def check(value): if hasattr(value, 'dtype'): return value.dtype.kind == numpy_kind return isinstance(value, python_types) return check"
            },
            {
                "url": 2678,
                "code": "def test_value(self, value): if not isinstance(value, float): raise ValueError('expected float value: ' + str(type(value)))"
            },
            {
                "url": 1297,
                "code": "def istype(obj, check): if isinstance(check, tuple): for cls in check: if type(obj) is cls: return True return False else: return type(obj) is check"
            },
            {
                "url": 4573,
                "code": "def test_value(self, value): if not isinstance(value, int): raise ValueError('expected int value: ' + str(type(value)))"
            },
            {
                "url": 6184,
                "code": "def assert_raises(ex_type, func, *args, **kwargs): r try: func(*args, **kwargs) except Exception as ex: assert isinstance(ex, ex_type), ( 'Raised %r but type should have been %r' % (ex, ex_type)) return True else: raise AssertionError('No error was raised')"
            },
            {
                "url": 5222,
                "code": "def __call__(self, actual_value, expect): self._expect = expect if self.expected_value is NO_ARG: return self.asserts(actual_value) return self.asserts(actual_value, self.expected_value)"
            },
            {
                "url": 1307,
                "code": "def assert_is_not(expected, actual, message=None, extra=None): assert expected is not actual, _assert_fail_message( message, expected, actual, \"is\", extra )"
            },
            {
                "url": 4350,
                "code": "def assert_valid_input(cls, tag): # Fail on unexpected types. if not cls.is_tag(tag): raise TypeError(\"Expected a BeautifulSoup 'Tag', but instead recieved type {}\".format(type(tag)))"
            },
            {
                "url": 4862,
                "code": "def is_instance_or_subclass(val, class_): try: return issubclass(val, class_) except TypeError: return isinstance(val, class_)"
            },
            {
                "url": 2141,
                "code": "def isstring(value): classes = (str, bytes) if pyutils.PY3 else basestring # noqa: F821 return isinstance(value, classes)"
            },
            {
                "url": 2584,
                "code": "def validate_string(option, value): if isinstance(value, string_type): return value raise TypeError(\"Wrong type for %s, value must be \" \"an instance of %s\" % (option, string_type.__name__))"
            }
        ],
        "url": 1519
    },
    {
        "nl_input": "python multiproccessing map with multiple inputs",
        "code_input": [
            {
                "url": 3695,
                "code": "def multiprocess_mapping(func, iterable): if os.name == 'nt': # In Windows there is no fork. return list(map(func, iterable)) try: p = multiprocessing.Pool() return_data = list(p.imap(func, iterable)) p.close() p.join() return return_data except OSError: return list(map(func, iterable))"
            },
            {
                "url": 5579,
                "code": "def mmap(func, iterable): if sys.version_info[0] > 2: return [i for i in map(func, iterable)] else: return map(func, iterable)"
            },
            {
                "url": 1761,
                "code": "def parallel(processes, threads): pool = multithread(threads) pool.map(run_process, processes) pool.close() pool.join()"
            },
            {
                "url": 4815,
                "code": "def iparallel_progbar(mapper, iterable, nprocs=None, starmap=False, flatmap=False, shuffle=False, verbose=True, verbose_flatmap=None, max_cache=-1, **kwargs): results = _parallel_progbar_launch(mapper, iterable, nprocs, starmap, flatmap, shuffle, verbose, verbose_flatmap, max_cache, **kwargs) return (x for i, x in results)"
            },
            {
                "url": 2498,
                "code": "def map(cls, iterable, func, *a, **kw): return cls(func(x, *a, **kw) for x in iterable)"
            },
            {
                "url": 5635,
                "code": "async def parallel_results(future_map: Sequence[Tuple]) -> Dict: ctx_methods = OrderedDict(future_map) fs = list(ctx_methods.values()) results = await asyncio.gather(*fs) results = { key: results[idx] for idx, key in enumerate(ctx_methods.keys()) } return results"
            },
            {
                "url": 3694,
                "code": "def apply(self, func, workers=1, job_size=10000): if workers == 1: for lines in self.iter_chunks(job_size): yield func(lines) else: with ProcessPoolExecutor(max_workers=workers) as executor: for result in executor.map(func, self.iter_chunks(job_size)): yield result"
            },
            {
                "url": 3979,
                "code": "async def smap(source, func, *more_sources): if more_sources: source = zip(source, *more_sources) async with streamcontext(source) as streamer: async for item in streamer: yield func(*item) if more_sources else func(item)"
            },
            {
                "url": 891,
                "code": "def map_wrap(f): @functools.wraps(f) def wrapper(*args, **kwargs): return f(*args, **kwargs) return wrapper"
            },
            {
                "url": 914,
                "code": "def asyncStarCmap(asyncCallable, iterable): results = [] yield coopStar(asyncCallable, results.append, iterable) returnValue(results)"
            },
            {
                "url": 263,
                "code": "def exec_function(ast, globals_map): locals_map = globals_map exec ast in globals_map, locals_map return locals_map"
            },
            {
                "url": 3813,
                "code": "def _run_parallel_process_with_profiling(self, start_path, stop_path, queue, filename): runctx('Engine._run_parallel_process(self, start_path, stop_path, queue)', globals(), locals(), filename)"
            },
            {
                "url": 3398,
                "code": "def batch(input_iter, batch_size=32): input_iter = iter(input_iter) next_ = list(itertools.islice(input_iter, batch_size)) while next_: yield next_ next_ = list(itertools.islice(input_iter, batch_size))"
            },
            {
                "url": 4016,
                "code": "def pool_args(function, sequence, kwargs): return zip(itertools.repeat(function), sequence, itertools.repeat(kwargs))"
            },
            {
                "url": 1066,
                "code": "async def result_processor(tasks): output = {} for task in tasks: num, res = await task output[num] = res return output"
            }
        ],
        "url": 3696
    },
    {
        "nl_input": "python add suffix to filename",
        "code_input": [
            {
                "url": 2100,
                "code": "def add_suffix(fullname, suffix): name, ext = os.path.splitext(fullname) return name + '_' + suffix + ext"
            },
            {
                "url": 701,
                "code": "def filename_addstring(filename, text): fn, ext = os.path.splitext(filename) return fn + text + ext"
            },
            {
                "url": 4465,
                "code": "def slugify_filename(filename): name, ext = os.path.splitext(filename) slugified = get_slugified_name(name) return slugified + ext"
            },
            {
                "url": 6048,
                "code": "def get_file_extension(filename): filename_x = filename.split('.') if len(filename_x) > 1: if filename_x[-1].strip() is not '': return filename_x[-1] return None"
            },
            {
                "url": 6154,
                "code": "def _extension(modpath: str) -> setuptools.Extension: return setuptools.Extension(modpath, [modpath.replace(\".\", \"/\") + \".py\"])"
            },
            {
                "url": 2888,
                "code": "def remove_ext(fname): bn = os.path.basename(fname) return os.path.splitext(bn)[0]"
            },
            {
                "url": 2860,
                "code": "def timestamp_filename(basename, ext=None): dt = datetime.now().strftime('%Y%m%d-%H%M%S-%f') if ext: return '%s-%s.%s' % (basename, dt, ext) return '%s-%s' % (basename, dt)"
            },
            {
                "url": 5825,
                "code": "def infer_format(filename:str) -> str: _, ext = os.path.splitext(filename) return ext"
            },
            {
                "url": 2058,
                "code": "def get_abi3_suffix(): for suffix, _, _ in (s for s in imp.get_suffixes() if s[2] == imp.C_EXTENSION): if '.abi3' in suffix: # Unix return suffix elif suffix == '.pyd': # Windows return suffix"
            },
            {
                "url": 1489,
                "code": "def lower_ext(abspath): fname, ext = os.path.splitext(abspath) return fname + ext.lower()"
            },
            {
                "url": 2343,
                "code": "def splitext_no_dot(filename): name, ext = os.path.splitext(filename) ext = ext.lower() return name, ext.strip('.')"
            },
            {
                "url": 5347,
                "code": "def append_text(self, txt): with open(self.fullname, \"a\") as myfile: myfile.write(txt)"
            },
            {
                "url": 2862,
                "code": "def get_incomplete_path(filename): random_suffix = \"\".join( random.choice(string.ascii_uppercase + string.digits) for _ in range(6)) return filename + \".incomplete\" + random_suffix"
            },
            {
                "url": 3470,
                "code": "def _increment_numeric_suffix(s): if re.match(r\".*\\d+$\", s): return re.sub(r\"\\d+$\", lambda n: str(int(n.group(0)) + 1), s) return s + \"_2\""
            },
            {
                "url": 4956,
                "code": "def extend_with(func): if not func.__name__ in ArgParseInator._plugins: ArgParseInator._plugins[func.__name__] = func"
            }
        ],
        "url": 2100
    },
    {
        "nl_input": "best way to deal with pagination in python",
        "code_input": [
            {
                "url": 4271,
                "code": "def paginate(self, request, offset=0, limit=None): return self.collection.offset(offset).limit(limit), self.collection.count()"
            },
            {
                "url": 2603,
                "code": "def _iter_response(self, url, params=None): if params is None: params = {} params['page_number'] = 1 # Last page lists itself as next page while True: response = self._request(url, params) for item in response['result_data']: yield item # Last page lists itself as next page if response['service_meta']['next_page_number'] == params['page_number']: break params['page_number'] += 1"
            },
            {
                "url": 2037,
                "code": "def end_index(self): return ((self.number - 1) * self.paginator.per_page + len(self.object_list))"
            },
            {
                "url": 616,
                "code": "def end_index(self): paginator = self.paginator # Special case for the last page because there can be orphans. if self.number == paginator.num_pages: return paginator.count return (self.number - 1) * paginator.per_page + paginator.first_page"
            },
            {
                "url": 2708,
                "code": "def items(self, limit=0): i = ItemIterator(self.iterator) i.limit = limit return i"
            },
            {
                "url": 3090,
                "code": "def autopage(self): while self.items: yield from self.items self.items = self.fetch_next()"
            },
            {
                "url": 5835,
                "code": "def __iter__(self): def generator(): for i, obj in enumerate(self._sequence): if i >= self._limit: break yield obj raise StopIteration return generator"
            },
            {
                "url": 5561,
                "code": "def __next__(self): self.current += 1 if self.current > self.total: raise StopIteration else: return self.iterable[self.current - 1]"
            },
            {
                "url": 1973,
                "code": "def iterate(obj): global next, Iteration next = next Iteration = Iteration total = len(obj) if isinstance(obj, Sized) else None iterator = iter(obj) first = True last = False i = 0 try: value = next(iterator) except StopIteration: return while True: try: next_value = next(iterator) except StopIteration: last = True yield Iteration(first, last, i, total, value) if last: return value = next_value i += 1 first = False"
            },
            {
                "url": 313,
                "code": "def flatpages_link_list(request): from django.contrib.flatpages.models import FlatPage link_list = [(page.title, page.url) for page in FlatPage.objects.all()] return render_to_link_list(link_list)"
            },
            {
                "url": 3398,
                "code": "def batch(input_iter, batch_size=32): input_iter = iter(input_iter) next_ = list(itertools.islice(input_iter, batch_size)) while next_: yield next_ next_ = list(itertools.islice(input_iter, batch_size))"
            },
            {
                "url": 3594,
                "code": "def chunked_list(_list, _chunk_size=50): for i in range(0, len(_list), _chunk_size): yield _list[i:i + _chunk_size]"
            },
            {
                "url": 1503,
                "code": "def get_duckduckgo_links(limit, params, headers): resp = s.get('https://duckduckgo.com/html', params = params, headers = headers) links = scrape_links(resp.content, engine = 'd') return links[:limit]"
            },
            {
                "url": 3487,
                "code": "def accel_prev(self, *args): if self.get_notebook().get_current_page() == 0: self.get_notebook().set_current_page(self.get_notebook().get_n_pages() - 1) else: self.get_notebook().prev_page() return True"
            },
            {
                "url": 2371,
                "code": "def chunks(iterable, chunk): for i in range(0, len(iterable), chunk): yield iterable[i:i + chunk]"
            }
        ],
        "url": 4271
    },
    {
        "nl_input": "finding factors in python and return list",
        "code_input": [
            {
                "url": 580,
                "code": "def _factor_generator(n): p = prime_factors(n) factors = {} for p1 in p: try: factors[p1] += 1 except KeyError: factors[p1] = 1 return factors"
            },
            {
                "url": 6090,
                "code": "def factors(n): return set(reduce(list.__add__, ([i, n // i] for i in range(1, int(n ** 0.5) + 1) if n % i == 0)))"
            },
            {
                "url": 529,
                "code": "def getPrimeFactors(n): lo = [1] n2 = n // 2 k = 2 for k in range(2, n2 + 1): if (n // k)*k == n: lo.append(k) return lo + [n, ]"
            },
            {
                "url": 5904,
                "code": "def factorial(n, mod=None): if not (isinstance(n, int) and n >= 0): raise ValueError(\"'n' must be a non-negative integer.\") if mod is not None and not (isinstance(mod, int) and mod > 0): raise ValueError(\"'mod' must be a positive integer\") result = 1 if n == 0: return 1 for i in range(2, n+1): result *= i if mod: result %= mod return result"
            },
            {
                "url": 3527,
                "code": "def computeFactorial(n): sleep_walk(10) ret = 1 for i in range(n): ret = ret * (i + 1) return ret"
            },
            {
                "url": 1987,
                "code": "def multiply(self, number): return self.from_list([x * number for x in self.to_list()])"
            },
            {
                "url": 4962,
                "code": "def parse_float(float_str): factor = __get_factor(float_str) if factor != 1: float_str = float_str[:-1] try: return float(float_str.replace(',', '')) * factor except ValueError: return None"
            },
            {
                "url": 4556,
                "code": "def EvalPoissonPmf(k, lam): # don't use the scipy function (yet). for lam=0 it returns NaN; # should be 0.0 # return scipy.stats.poisson.pmf(k, lam) return lam ** k * math.exp(-lam) / math.factorial(k)"
            },
            {
                "url": 3947,
                "code": "def EvalBinomialPmf(k, n, p): return scipy.stats.binom.pmf(k, n, p)"
            },
            {
                "url": 5946,
                "code": "def fib(n): assert n > 0 a, b = 1, 1 for i in range(n - 1): a, b = b, a + b return a"
            },
            {
                "url": 5885,
                "code": "def interpolate(f1: float, f2: float, factor: float) -> float: return f1 + (f2 - f1) * factor"
            },
            {
                "url": 652,
                "code": "def make_qs(n, m=None): try: import sympy except ImportError: raise ImportError(\"This function requires sympy. Please install it.\") if m is None: syms = sympy.symbols(\" \".join(f\"q{i}\" for i in range(n))) if isinstance(syms, tuple): return syms else: return (syms,) syms = sympy.symbols(\" \".join(f\"q{i}\" for i in range(n, m))) if isinstance(syms, tuple): return syms else: return (syms,)"
            },
            {
                "url": 5926,
                "code": "def is_prime(n): if n % 2 == 0 and n > 2: return False return all(n % i for i in range(3, int(math.sqrt(n)) + 1, 2))"
            },
            {
                "url": 3765,
                "code": "def SampleSum(dists, n): pmf = MakePmfFromList(RandomSum(dists) for i in xrange(n)) return pmf"
            },
            {
                "url": 4320,
                "code": "def functions(self): return [v for v in self.globals.values() if isinstance(v, values.Function)]"
            }
        ],
        "url": 6090
    },
    {
        "nl_input": "best way to read xml in python",
        "code_input": [
            {
                "url": 3309,
                "code": "def xml_str_to_dict(s): xml = minidom.parseString(s) return pythonzimbra.tools.xmlserializer.dom_to_dict(xml.firstChild)"
            },
            {
                "url": 2994,
                "code": "def pretty_xml(data): parsed_string = minidom.parseString(data.decode('utf-8')) return parsed_string.toprettyxml(indent='\\t', encoding='utf-8')"
            },
            {
                "url": 4291,
                "code": "def xml(cls, res, *args, **kwargs): return parse_xml(res.text, *args, **kwargs)"
            },
            {
                "url": 3347,
                "code": "def pp_xml(body): pretty = xml.dom.minidom.parseString(body) return pretty.toprettyxml(indent=\" \")"
            },
            {
                "url": 89,
                "code": "def xmltreefromfile(filename): try: return ElementTree.parse(filename, ElementTree.XMLParser(collect_ids=False)) except TypeError: return ElementTree.parse(filename, ElementTree.XMLParser())"
            },
            {
                "url": 1677,
                "code": "def from_file(cls, file_path, validate=True): return xmlmap.load_xmlobject_from_file(file_path, xmlclass=cls, validate=validate)"
            },
            {
                "url": 3701,
                "code": "def str_is_well_formed(xml_str): try: str_to_etree(xml_str) except xml.etree.ElementTree.ParseError: return False else: return True"
            },
            {
                "url": 1825,
                "code": "def are_equal_xml(a_xml, b_xml): a_dom = xml.dom.minidom.parseString(a_xml) b_dom = xml.dom.minidom.parseString(b_xml) return are_equal_elements(a_dom.documentElement, b_dom.documentElement)"
            },
            {
                "url": 476,
                "code": "def __get_xml_text(root): txt = \"\" for e in root.childNodes: if (e.nodeType == e.TEXT_NODE): txt += e.data return txt"
            },
            {
                "url": 3311,
                "code": "def validate(self, xml_input): parsed_xml = etree.parse(self._handle_xml(xml_input)) try: return self.xmlschema.validate(parsed_xml) except AttributeError: raise CannotValidate('Set XSD to validate the XML')"
            },
            {
                "url": 2695,
                "code": "def parse(self, data, mimetype): encoding = mimetype.params.get('charset') or 'utf-8' return json.loads(data.decode(encoding))"
            },
            {
                "url": 2063,
                "code": "def prettify(elem): rough_string = ET.tostring(elem, 'utf-8') reparsed = minidom.parseString(rough_string) return reparsed.toprettyxml(indent=\"\\t\")"
            },
            {
                "url": 4866,
                "code": "def loads(string): f = StringIO.StringIO(string) marshaller = JavaObjectUnmarshaller(f) marshaller.add_transformer(DefaultObjectTransformer()) return marshaller.readObject()"
            },
            {
                "url": 3497,
                "code": "def read_string(cls, string): if PY3 and not isinstance(string, byte_types): string = string.encode() return cls.decode(string)"
            },
            {
                "url": 1059,
                "code": "def _dict_to_proto(py_dict, proto): dict_json_str = json.dumps(py_dict) return json_format.Parse(dict_json_str, proto)"
            }
        ],
        "url": 89
    },
    {
        "nl_input": "how to put a string in a yaml file python",
        "code_input": [
            {
                "url": 4401,
                "code": "def write_dict_to_yaml(dictionary, path, **kwargs): with open(path, 'w') as f: yaml.dump(dictionary, f, indent=4, **kwargs)"
            },
            {
                "url": 1353,
                "code": "def load_yaml_file(file_path: str): with codecs.open(file_path, 'r') as f: return yaml.safe_load(f)"
            },
            {
                "url": 1096,
                "code": "def load_yaml(filepath): with open(filepath) as f: txt = f.read() return yaml.load(txt)"
            },
            {
                "url": 6141,
                "code": "def load_yaml(file): if hasattr(yaml, \"full_load\"): return yaml.full_load(file) else: return yaml.load(file)"
            },
            {
                "url": 1247,
                "code": "def generate_write_yaml_to_file(file_name): def write_yaml(config): with open(file_name, 'w+') as fh: fh.write(yaml.dump(config)) return write_yaml"
            },
            {
                "url": 4299,
                "code": "def generate_yaml_file(filename, contents): with open(filename, 'w') as file: file.write(yaml.dump(contents, default_flow_style=False))"
            },
            {
                "url": 1355,
                "code": "def yaml_to_param(obj, name): return from_pyvalue(u\"yaml:%s\" % name, unicode(yaml.dump(obj)))"
            },
            {
                "url": 3305,
                "code": "def serialize_yaml_tofile(filename, resource): stream = file(filename, \"w\") yaml.dump(resource, stream, default_flow_style=False)"
            },
            {
                "url": 3965,
                "code": "def Dump(obj): text = yaml.safe_dump(obj, default_flow_style=False, allow_unicode=True) if compatibility.PY2: text = text.decode(\"utf-8\") return text"
            },
            {
                "url": 735,
                "code": "def _include_yaml(loader, node): return load_yaml(os.path.join(os.path.dirname(loader.name), node.value))"
            },
            {
                "url": 3458,
                "code": "def Parse(text): precondition.AssertType(text, Text) if compatibility.PY2: text = text.encode(\"utf-8\") return yaml.safe_load(text)"
            },
            {
                "url": 1351,
                "code": "def safe_dump(data, stream=None, **kwds): return yaml.dump(data, stream=stream, Dumper=ODYD, **kwds)"
            },
            {
                "url": 982,
                "code": "def _parse_config(config_file_path): config_file = open(config_file_path, 'r') config = yaml.load(config_file) config_file.close() return config"
            },
            {
                "url": 6002,
                "code": "def load_yaml(yaml_file: str) -> Any: with open(yaml_file, 'r') as file: return ruamel.yaml.load(file, ruamel.yaml.RoundTripLoader)"
            },
            {
                "url": 3335,
                "code": "def getYamlDocument(filePath): with open(filePath) as stream: doc = yaml.load(stream) return doc"
            }
        ],
        "url": 4299
    },
    {
        "nl_input": "python move cursor to secific line",
        "code_input": [
            {
                "url": 814,
                "code": "def _go_to_line(editor, line): b = editor.application.current_buffer b.cursor_position = b.document.translate_row_col_to_index(max(0, int(line) - 1), 0)"
            },
            {
                "url": 818,
                "code": "def go_to_line(self, line): cursor = self.textCursor() cursor.setPosition(self.document().findBlockByNumber(line - 1).position()) self.setTextCursor(cursor) return True"
            },
            {
                "url": 3051,
                "code": "def set_cursor(self, x, y): curses.curs_set(1) self.screen.move(y, x)"
            },
            {
                "url": 3191,
                "code": "def update_cursor_position(self, line, index): value = 'Line {}, Col {}'.format(line + 1, index + 1) self.set_value(value)"
            },
            {
                "url": 363,
                "code": "def move_to(self, ypos, xpos): # the screen's co-ordinates are 1 based, but the command is 0 based xpos -= 1 ypos -= 1 self.exec_command(\"MoveCursor({0}, {1})\".format(ypos, xpos).encode(\"ascii\"))"
            },
            {
                "url": 2456,
                "code": "def set_cursor_position(self, position): position = self.get_position(position) cursor = self.textCursor() cursor.setPosition(position) self.setTextCursor(cursor) self.ensureCursorVisible()"
            },
            {
                "url": 4739,
                "code": "def move(self, x, y): self._cursor = self._normalizePoint(x, y)"
            },
            {
                "url": 428,
                "code": "def go_to_new_line(self): self.stdkey_end(False, False) self.insert_text(self.get_line_separator())"
            },
            {
                "url": 2388,
                "code": "def step_next_line(self): self._eol.append(self.position) self._lineno += 1 self._col_offset = 0"
            },
            {
                "url": 4231,
                "code": "def remove_last_line(self): editor = self._editor text_cursor = editor.textCursor() text_cursor.movePosition(text_cursor.End, text_cursor.MoveAnchor) text_cursor.select(text_cursor.LineUnderCursor) text_cursor.removeSelectedText() text_cursor.deletePreviousChar() editor.setTextCursor(text_cursor)"
            },
            {
                "url": 5795,
                "code": "def _cursorLeft(self): if self.cursorPos > 0: self.cursorPos -= 1 sys.stdout.write(console.CURSOR_LEFT) sys.stdout.flush()"
            },
            {
                "url": 5814,
                "code": "def auto_up(self, count=1, go_to_start_of_line_if_history_changes=False): if self.complete_state: self.complete_previous(count=count) elif self.document.cursor_position_row > 0: self.cursor_up(count=count) elif not self.selection_state: self.history_backward(count=count) # Go to the start of the line? if go_to_start_of_line_if_history_changes: self.cursor_position += self.document.get_start_of_line_position()"
            },
            {
                "url": 3812,
                "code": "def ensure_newline(self): DECTCEM_SHOW = '\\033[?25h' # show cursor AT_END = DECTCEM_SHOW + '\\n' if not self._cursor_at_newline: self.write(AT_END) self._cursor_at_newline = True"
            },
            {
                "url": 2241,
                "code": "def translate_index_to_position(self, index): # Find start of this line. row, row_index = self._find_line_start_index(index) col = index - row_index return row, col"
            },
            {
                "url": 783,
                "code": "def erase_lines(n=1): for _ in range(n): print(codes.cursor[\"up\"], end=\"\") print(codes.cursor[\"eol\"], end=\"\")"
            }
        ],
        "url": 814
    },
    {
        "nl_input": "token to id python",
        "code_input": [
            {
                "url": 6012,
                "code": "def strids2ids(tokens: Iterable[str]) -> List[int]: return list(map(int, tokens))"
            },
            {
                "url": 2987,
                "code": "def pythonise(id, encoding='ascii'): replace = {'-': '_', ':': '_', '/': '_'} func = lambda id, pair: id.replace(pair[0], pair[1]) id = reduce(func, replace.iteritems(), id) id = '_%s' % id if id[0] in string.digits else id return id.encode(encoding)"
            },
            {
                "url": 3094,
                "code": "def word_to_id(self, word): if word in self.vocab: return self.vocab[word] else: return self.unk_id"
            },
            {
                "url": 3842,
                "code": "def _return_comma_list(self, l): if isinstance(l, (text_type, int)): return l if not isinstance(l, list): raise TypeError(l, ' should be a list of integers, \\ not {0}'.format(type(l))) str_ids = ','.join(str(i) for i in l) return str_ids"
            },
            {
                "url": 167,
                "code": "def is_identifier(string): matched = PYTHON_IDENTIFIER_RE.match(string) return bool(matched) and not keyword.iskeyword(string)"
            },
            {
                "url": 5451,
                "code": "def generate_user_token(self, user, salt=None): return self.token_serializer.dumps(str(user.id), salt=salt)"
            },
            {
                "url": 4516,
                "code": "def token(name): def wrap(f): tokenizers.append((name, f)) return f return wrap"
            },
            {
                "url": 855,
                "code": "def tokenize(string): for match in TOKENS_REGEX.finditer(string): yield Token(match.lastgroup, match.group().strip(), match.span())"
            },
            {
                "url": 1081,
                "code": "def string_to_identity(identity_str): m = _identity_regexp.match(identity_str) result = m.groupdict() log.debug('parsed identity: %s', result) return {k: v for k, v in result.items() if v}"
            },
            {
                "url": 6106,
                "code": "def get_tokens(line: str) -> Iterator[str]: for token in line.rstrip().split(): if len(token) > 0: yield token"
            },
            {
                "url": 2355,
                "code": "def generate_id(): # TODO: Use six.string_type to Py3 compat try: return unicode(uuid1()).replace(u\"-\", u\"\") except NameError: return str(uuid1()).replace(u\"-\", u\"\")"
            },
            {
                "url": 70,
                "code": "def _get_random_id(): symbols = string.ascii_uppercase + string.ascii_lowercase + string.digits return ''.join(random.choice(symbols) for _ in range(15))"
            },
            {
                "url": 2920,
                "code": "def _from_list_dict(cls, list_dic): return cls({_convert_id(dic[cls.CHAMP_ID]): dict(dic) for dic in list_dic})"
            },
            {
                "url": 4227,
                "code": "def _unique_id(self, prefix): _id = self._id_gen self._id_gen += 1 return prefix + str(_id)"
            },
            {
                "url": 4595,
                "code": "def _initialize_id(self): self.id = str(self.db.incr(self._key['id']))"
            }
        ],
        "url": 6012
    },
    {
        "nl_input": "python urlparse get domain",
        "code_input": [
            {
                "url": 5798,
                "code": "def get_domain(url): parse_result = urlparse(url) domain = \"{schema}://{netloc}\".format( schema=parse_result.scheme, netloc=parse_result.netloc) return domain"
            },
            {
                "url": 3341,
                "code": "def parse_domain(url): domain_match = lib.DOMAIN_REGEX.match(url) if domain_match: return domain_match.group()"
            },
            {
                "url": 5694,
                "code": "def url_host(url: str) -> str: from urllib.parse import urlparse res = urlparse(url) return res.netloc.split(':')[0] if res.netloc else ''"
            },
            {
                "url": 1449,
                "code": "def strip_querystring(url): p = six.moves.urllib.parse.urlparse(url) return p.scheme + \"://\" + p.netloc + p.path"
            },
            {
                "url": 5155,
                "code": "def fetch(self): api = self.doapi_manager return api._domain(api.request(self.url)[\"domain\"])"
            },
            {
                "url": 1199,
                "code": "def is_valid_url(url): pieces = urlparse(url) return all([pieces.scheme, pieces.netloc])"
            },
            {
                "url": 1660,
                "code": "def clean_url(url): parsed = urlparse(url.strip()) reconstructed = ParseResult( parsed.scheme, parsed.netloc, parsed.path, params='', query='', fragment='') return reconstructed.geturl()"
            },
            {
                "url": 3718,
                "code": "def parse_host_port (host_port): host, port = urllib.splitport(host_port.strip()) if port is not None: if urlutil.is_numeric_port(port): port = int(port) return host, port"
            },
            {
                "url": 4108,
                "code": "def get_site_name(request): urlparts = request.urlparts return ':'.join([urlparts.hostname, str(urlparts.port)])"
            },
            {
                "url": 1054,
                "code": "def parse_s3_url(url): bucket = '' path = '' if url: result = urlparse(url) bucket = result.netloc path = result.path.strip('/') return bucket, path"
            },
            {
                "url": 4581,
                "code": "def get_querystring(uri): parts = urlparse.urlsplit(uri) return urlparse.parse_qs(parts.query)"
            },
            {
                "url": 4153,
                "code": "def top_level(url, fix_protocol=True): ext = tld.get_tld(url, fix_protocol=fix_protocol) toplevel = '.'.join(urlparse(url).netloc.split('.')[-2:]).split( ext)[0] + ext return toplevel"
            },
            {
                "url": 1149,
                "code": "def _config_win32_domain(self, domain): # we call str() on domain to convert it from unicode to ascii self.domain = dns.name.from_text(str(domain))"
            },
            {
                "url": 1975,
                "code": "def wget(url): import urllib.parse request = urllib.request.urlopen(url) filestring = request.read() return filestring"
            },
            {
                "url": 1309,
                "code": "def guess_url(url): if url.lower().startswith(\"www.\"): # syntactic sugar return \"http://%s\" % url elif url.lower().startswith(\"ftp.\"): # syntactic sugar return \"ftp://%s\" % url return url"
            }
        ],
        "url": 5798
    },
    {
        "nl_input": "python turn a string into a number",
        "code_input": [
            {
                "url": 4197,
                "code": "def str_to_num(str_value): str_value = str(str_value) try: return int(str_value) except ValueError: return float(str_value)"
            },
            {
                "url": 40,
                "code": "def get_number(s, cast=int): import string d = \"\".join(x for x in str(s) if x in string.digits) return cast(d)"
            },
            {
                "url": 3791,
                "code": "def cast_int(x): try: x = int(x) except ValueError: try: x = x.strip() except AttributeError as e: logger_misc.warn(\"parse_str: AttributeError: String not number or word, {}, {}\".format(x, e)) return x"
            },
            {
                "url": 3425,
                "code": "def default_number_converter(number_str): is_int = (number_str.startswith('-') and number_str[1:].isdigit()) or number_str.isdigit() # FIXME: this handles a wider range of numbers than allowed by the json standard, # etc.: float('nan') and float('inf'). But is this a problem? return int(number_str) if is_int else float(number_str)"
            },
            {
                "url": 5067,
                "code": "def find_number(regex, s): result = find_string(regex, s) if result is None: return None return int(result)"
            },
            {
                "url": 5603,
                "code": "def try_cast_int(s): try: temp = re.findall('\\d', str(s)) temp = ''.join(temp) return int(temp) except: return s"
            },
            {
                "url": 1329,
                "code": "def validate_int(value): if value and not isinstance(value, int): try: int(str(value)) except (TypeError, ValueError): raise ValidationError('not a valid number') return value"
            },
            {
                "url": 5274,
                "code": "def convert_string(string): if is_int(string): return int(string) elif is_float(string): return float(string) elif convert_bool(string)[0]: return convert_bool(string)[1] elif string == 'None': return None else: return string"
            },
            {
                "url": 1860,
                "code": "def str2int(string_with_int): return int(\"\".join([char for char in string_with_int if char in string.digits]) or 0)"
            },
            {
                "url": 483,
                "code": "def _convert_to_float_if_possible(s): try: ret = float(s) except (ValueError, TypeError): ret = s return ret"
            },
            {
                "url": 2828,
                "code": "def get_numbers(s): result = map(int, re.findall(r'[0-9]+', unicode(s))) return result + [1] * (2 - len(result))"
            },
            {
                "url": 308,
                "code": "def type_converter(text): if text.isdigit(): return int(text), int try: return float(text), float except ValueError: return text, STRING_TYPE"
            },
            {
                "url": 5836,
                "code": "def clean_int(x) -> int: try: return int(x) except ValueError: raise forms.ValidationError( \"Cannot convert to integer: {}\".format(repr(x)))"
            },
            {
                "url": 894,
                "code": "def safe_int_conv(number): try: return int(np.array(number).astype(int, casting='safe')) except TypeError: raise ValueError('cannot safely convert {} to integer'.format(number))"
            },
            {
                "url": 5643,
                "code": "def strings_to_integers(strings: Iterable[str]) -> Iterable[int]: return strings_to_(strings, lambda x: int(float(x)))"
            }
        ],
        "url": 40
    },
    {
        "nl_input": "python check if all are type string in a column",
        "code_input": [
            {
                "url": 2126,
                "code": "def all_strings(arr): if not isinstance([], list): raise TypeError(\"non-list value found where list is expected\") return all(isinstance(x, str) for x in arr)"
            },
            {
                "url": 2332,
                "code": "def validate_string_list(lst): if not isinstance(lst, list): raise ValueError('input %r must be a list' % lst) for x in lst: if not isinstance(x, basestring): raise ValueError('element %r in list must be a string' % x)"
            },
            {
                "url": 1789,
                "code": "def is_string(obj): if PYTHON3: str_type = (bytes, str) else: str_type = (bytes, str, unicode) return isinstance(obj, str_type)"
            },
            {
                "url": 530,
                "code": "def _isstring(dtype): return dtype.type == numpy.unicode_ or dtype.type == numpy.string_"
            },
            {
                "url": 2414,
                "code": "def validate_stringlist(s): if isinstance(s, six.string_types): return [six.text_type(v.strip()) for v in s.split(',') if v.strip()] else: try: return list(map(validate_str, s)) except TypeError as e: raise ValueError(e.message)"
            },
            {
                "url": 243,
                "code": "def is_string(val): try: basestring except NameError: return isinstance(val, str) return isinstance(val, basestring)"
            },
            {
                "url": 2141,
                "code": "def isstring(value): classes = (str, bytes) if pyutils.PY3 else basestring # noqa: F821 return isinstance(value, classes)"
            },
            {
                "url": 5597,
                "code": "def is_sqlatype_string(coltype: Union[TypeEngine, VisitableType]) -> bool: coltype = _coltype_to_typeengine(coltype) return isinstance(coltype, sqltypes.String)"
            },
            {
                "url": 4009,
                "code": "def str_check(*args, func=None): func = func or inspect.stack()[2][3] for var in args: if not isinstance(var, (str, collections.UserString, collections.abc.Sequence)): name = type(var).__name__ raise StringError( f'Function {func} expected str, {name} got instead.')"
            },
            {
                "url": 2584,
                "code": "def validate_string(option, value): if isinstance(value, string_type): return value raise TypeError(\"Wrong type for %s, value must be \" \"an instance of %s\" % (option, string_type.__name__))"
            },
            {
                "url": 6152,
                "code": "def is_string_dtype(arr_or_dtype): # TODO: gh-15585: consider making the checks stricter. def condition(dtype): return dtype.kind in ('O', 'S', 'U') and not is_period_dtype(dtype) return _is_dtype(arr_or_dtype, condition)"
            },
            {
                "url": 590,
                "code": "def isString(s): try: return isinstance(s, unicode) or isinstance(s, basestring) except NameError: return isinstance(s, str)"
            },
            {
                "url": 5589,
                "code": "def is_unicode(string): str_type = str(type(string)) if str_type.find('str') > 0 or str_type.find('unicode') > 0: return True return False"
            },
            {
                "url": 2014,
                "code": "def chkstr(s, v): if type(s) != str: raise TypeError(\"{var} must be str\".format(var=v)) if not s: raise ValueError(\"{var} cannot be empty\".format(var=v))"
            },
            {
                "url": 1858,
                "code": "def _get_str_columns(sf): return [name for name in sf.column_names() if sf[name].dtype == str]"
            }
        ],
        "url": 5597
    },
    {
        "nl_input": "bin means python numpy",
        "code_input": [
            {
                "url": 521,
                "code": "def val_to_bin(edges, x): ibin = np.digitize(np.array(x, ndmin=1), edges) - 1 return ibin"
            },
            {
                "url": 4059,
                "code": "def to_bin(data, width): data_str = bin(data & (2**width-1))[2:].zfill(width) return [int(x) for x in tuple(data_str)]"
            },
            {
                "url": 2036,
                "code": "def bin_to_int(string): if isinstance(string, str): return struct.unpack(\"b\", string)[0] else: return struct.unpack(\"b\", bytes([string]))[0]"
            },
            {
                "url": 1898,
                "code": "def intToBin(i): # devide in two parts (bytes) i1 = i % 256 i2 = int(i / 256) # make string (little endian) return chr(i1) + chr(i2)"
            },
            {
                "url": 93,
                "code": "def intToBin(i): # divide in two parts (bytes) i1 = i % 256 i2 = int(i / 256) # make string (little endian) return i.to_bytes(2, byteorder='little')"
            },
            {
                "url": 3880,
                "code": "def Binary(x): if isinstance(x, text_type) and not (JYTHON or IRONPYTHON): return x.encode() return bytes(x)"
            },
            {
                "url": 2549,
                "code": "def read_numpy(fd, byte_order, dtype, count): return numpy.fromfile(fd, byte_order+dtype[-1], count)"
            },
            {
                "url": 4629,
                "code": "def _increment(arr, indices): arr = _as_array(arr) indices = _as_array(indices) bbins = np.bincount(indices) arr[:len(bbins)] += bbins return arr"
            },
            {
                "url": 3066,
                "code": "def vals2bins(vals,res=100): # flatten if list of lists if any(isinstance(el, list) for el in vals): vals = list(itertools.chain(*vals)) return list(np.digitize(vals, np.linspace(np.min(vals), np.max(vals)+1, res+1)) - 1)"
            },
            {
                "url": 1985,
                "code": "def binSearch(arr, val): i = bisect_left(arr, val) if i != len(arr) and arr[i] == val: return i return -1"
            },
            {
                "url": 1540,
                "code": "def get_bin_indices(self, values): return tuple([self.get_axis_bin_index(values[ax_i], ax_i) for ax_i in range(self.dimensions)])"
            },
            {
                "url": 3163,
                "code": "def inverseHistogram(hist, bin_range): data = hist.astype(float) / np.min(hist[np.nonzero(hist)]) new_data = np.empty(shape=np.sum(data, dtype=int)) i = 0 xvals = np.linspace(bin_range[0], bin_range[1], len(data)) for d, x in zip(data, xvals): new_data[i:i + d] = x i += int(d) return new_data"
            },
            {
                "url": 1542,
                "code": "def Bernstein(n, k): coeff = binom(n, k) def _bpoly(x): return coeff * x ** k * (1 - x) ** (n - k) return _bpoly"
            },
            {
                "url": 5791,
                "code": "def shape(self) -> Tuple[int, ...]: return tuple(bins.bin_count for bins in self._binnings)"
            },
            {
                "url": 5975,
                "code": "def get_bin_edges_from_axis(axis) -> np.ndarray: # Don't include over- or underflow bins bins = range(1, axis.GetNbins() + 1) # Bin edges bin_edges = np.empty(len(bins) + 1) bin_edges[:-1] = [axis.GetBinLowEdge(i) for i in bins] bin_edges[-1] = axis.GetBinUpEdge(axis.GetNbins()) return bin_edges"
            }
        ],
        "url": 521
    },
    {
        "nl_input": "python boto3 delete key from s3",
        "code_input": [
            {
                "url": 1455,
                "code": "def remove_file_from_s3(awsclient, bucket, key): client_s3 = awsclient.get_client('s3') response = client_s3.delete_object(Bucket=bucket, Key=key)"
            },
            {
                "url": 4304,
                "code": "def delete_s3_bucket(client, resource): if dbconfig.get('enable_delete_s3_buckets', NS_AUDITOR_REQUIRED_TAGS, False): client.delete_bucket(Bucket=resource.id) return ActionStatus.SUCCEED, resource.metrics()"
            },
            {
                "url": 4441,
                "code": "def get_key(self, key, bucket_name=None): if not bucket_name: (bucket_name, key) = self.parse_s3_url(key) obj = self.get_resource_type('s3').Object(bucket_name, key) obj.load() return obj"
            },
            {
                "url": 5656,
                "code": "def s3_get(url: str, temp_file: IO) -> None: s3_resource = boto3.resource(\"s3\") bucket_name, s3_path = split_s3_path(url) s3_resource.Bucket(bucket_name).download_fileobj(s3_path, temp_file)"
            },
            {
                "url": 4243,
                "code": "def delete(self): self._client.remove_object(self._instance, self._bucket, self.name)"
            },
            {
                "url": 4020,
                "code": "def s3_connect(bucket_name, s3_access_key_id, s3_secret_key): conn = connect_s3(s3_access_key_id, s3_secret_key) try: return conn.get_bucket(bucket_name) except S3ResponseError as e: if e.status == 403: raise Exception(\"Bad Amazon S3 credentials.\") raise"
            },
            {
                "url": 2612,
                "code": "def download_file(bucket_name, path, target, sagemaker_session): path = path.lstrip('/') boto_session = sagemaker_session.boto_session s3 = boto_session.resource('s3') bucket = s3.Bucket(bucket_name) bucket.download_file(path, target)"
            },
            {
                "url": 1312,
                "code": "def s3(ctx, bucket_name, data_file, region): if not ctx.data_file: ctx.data_file = data_file if not ctx.bucket_name: ctx.bucket_name = bucket_name if not ctx.region: ctx.region = region ctx.type = 's3'"
            },
            {
                "url": 2335,
                "code": "def delete_entry(self, key): pipe = self.client.pipeline() pipe.srem(self.keys_container, key) pipe.delete(key) pipe.execute()"
            },
            {
                "url": 4470,
                "code": "def delete_item(self, item): try: self.dynamodb_client.delete_item(**item) except botocore.exceptions.ClientError as error: handle_constraint_violation(error)"
            },
            {
                "url": 4472,
                "code": "def sync_s3(self): bucket, key = self.open_s3() for directory in self.DIRECTORIES: for root, dirs, files in os.walk(directory): self.upload_s3((bucket, key, self.AWS_BUCKET_NAME, directory), root, files, dirs)"
            },
            {
                "url": 5786,
                "code": "def clean_all_buckets(self): bucket_keys = self.redis_object.keys(pattern='nearpy_*') if len(bucket_keys) > 0: self.redis_object.delete(*bucket_keys)"
            },
            {
                "url": 368,
                "code": "def download_file_from_bucket(self, bucket, file_path, key): with open(file_path, 'wb') as data: self.__s3.download_fileobj(bucket, key, data) return file_path"
            },
            {
                "url": 1054,
                "code": "def parse_s3_url(url): bucket = '' path = '' if url: result = urlparse(url) bucket = result.netloc path = result.path.strip('/') return bucket, path"
            },
            {
                "url": 4747,
                "code": "def delete(self, key_name): self.db.remove(Query().name == key_name) return self.get(key_name) == {}"
            }
        ],
        "url": 1455
    },
    {
        "nl_input": "random walk steps python",
        "code_input": [
            {
                "url": 4569,
                "code": "def random_int(self, min=0, max=9999, step=1): return self.generator.random.randrange(min, max + 1, step)"
            },
            {
                "url": 1400,
                "code": "def runiform(lower, upper, size=None): return np.random.uniform(lower, upper, size)"
            },
            {
                "url": 68,
                "code": "def _xxrange(self, start, end, step_count): _step = (end - start) / float(step_count) return (start + (i * _step) for i in xrange(int(step_count)))"
            },
            {
                "url": 3733,
                "code": "def random_numbers(n): return ''.join(random.SystemRandom().choice(string.digits) for _ in range(n))"
            },
            {
                "url": 1369,
                "code": "def simulate(self): min_ = (-sys.maxsize - 1) if self._min is None else self._min max_ = sys.maxsize if self._max is None else self._max return random.randint(min_, max_)"
            },
            {
                "url": 4979,
                "code": "def _random_x(self): return (tuple(random.random() for _ in range(self.fmodel.dim_x)),)"
            },
            {
                "url": 3109,
                "code": "def __call__(self, _): if self.iter % self.step == 0: print(self.fmt.format(self.iter), **self.kwargs) self.iter += 1"
            },
            {
                "url": 1495,
                "code": "def array(self): return np.arange(self.start, self.stop, self.step)"
            },
            {
                "url": 3527,
                "code": "def computeFactorial(n): sleep_walk(10) ret = 1 for i in range(n): ret = ret * (i + 1) return ret"
            },
            {
                "url": 4669,
                "code": "def new_random_state(seed=None, fully_random=False): if seed is None: if not fully_random: # sample manually a seed instead of just RandomState(), # because the latter one # is way slower. seed = CURRENT_RANDOM_STATE.randint(SEED_MIN_VALUE, SEED_MAX_VALUE, 1)[0] return np.random.RandomState(seed)"
            },
            {
                "url": 3113,
                "code": "def __call__(self, _): if self.iter % self.step == 0: self.pbar.update(self.step) self.iter += 1"
            },
            {
                "url": 4830,
                "code": "def RandomShuffle(a, seed): if seed: np.random.seed(seed) r = a.copy() np.random.shuffle(r) return r,"
            },
            {
                "url": 3765,
                "code": "def SampleSum(dists, n): pmf = MakePmfFromList(RandomSum(dists) for i in xrange(n)) return pmf"
            },
            {
                "url": 1202,
                "code": "def random_int(maximum_value): if maximum_value == 0: return 0 elif maximum_value == 1: return random_bits(1) bits = math.floor(math.log2(maximum_value)) result = random_bits(bits) + random_int(maximum_value - ((2 ** bits) - 1)) return result"
            },
            {
                "url": 955,
                "code": "def rnormal(mu, tau, size=None): return np.random.normal(mu, 1. / np.sqrt(tau), size)"
            }
        ],
        "url": 5912
    },
    {
        "nl_input": "python delete objects inside of objects",
        "code_input": [
            {
                "url": 2569,
                "code": "def _delete_keys(dct, keys): c = deepcopy(dct) assert isinstance(keys, list) for k in keys: c.pop(k) return c"
            },
            {
                "url": 1103,
                "code": "def _removeTags(tags, objects): for t in tags: for o in objects: o.tags.remove(t) return True"
            },
            {
                "url": 1015,
                "code": "def rm_keys_from_dict(d, keys): # Loop for each key given for key in keys: # Is the key in the dictionary? if key in d: try: d.pop(key, None) except KeyError: # Not concerned with an error. Keep going. pass return d"
            },
            {
                "url": 1950,
                "code": "def wipe(self): keys = list(self.keys()).copy() for key in keys: self.delete(key)"
            },
            {
                "url": 4874,
                "code": "def __delitem__ (self, key): self._keys.remove(key) super(ListDict, self).__delitem__(key)"
            },
            {
                "url": 4062,
                "code": "def __delitem__(self, key): index, value = self._dict.pop(key) key2, value2 = self._list.pop(index) assert key == key2 assert value is value2 self._fix_indices_after_delete(index)"
            },
            {
                "url": 3146,
                "code": "def pop (self, key): if key in self._keys: self._keys.remove(key) super(ListDict, self).pop(key)"
            },
            {
                "url": 185,
                "code": "def _remove_dict_keys_with_value(dict_, val): return {k: v for k, v in dict_.items() if v is not val}"
            },
            {
                "url": 5266,
                "code": "def del_object_from_parent(self): if self.parent: self.parent.objects.pop(self.ref)"
            },
            {
                "url": 1720,
                "code": "def delete(self, name): obj = self._get_object(name) if obj: return self.driver.delete_object(obj)"
            },
            {
                "url": 5594,
                "code": "def dictlist_wipe_key(dict_list: Iterable[Dict], key: str) -> None: for d in dict_list: d.pop(key, None)"
            },
            {
                "url": 145,
                "code": "def delete_all_eggs(self): path_to_delete = os.path.join(self.egg_directory, \"lib\", \"python\") if os.path.exists(path_to_delete): shutil.rmtree(path_to_delete)"
            },
            {
                "url": 1017,
                "code": "def purge_dict(idict): odict = {} for key, val in idict.items(): if is_null(val): continue odict[key] = val return odict"
            },
            {
                "url": 2335,
                "code": "def delete_entry(self, key): pipe = self.client.pipeline() pipe.srem(self.keys_container, key) pipe.delete(key) pipe.execute()"
            },
            {
                "url": 2281,
                "code": "def _remove_none_values(dictionary): return list(map(dictionary.pop, [i for i in dictionary if dictionary[i] is None]))"
            }
        ],
        "url": 1103
    },
    {
        "nl_input": "truncate seconds from a timestamp in python code",
        "code_input": [
            {
                "url": 3242,
                "code": "def RoundToSeconds(cls, timestamp): leftovers = timestamp % definitions.MICROSECONDS_PER_SECOND scrubbed = timestamp - leftovers rounded = round(float(leftovers) / definitions.MICROSECONDS_PER_SECOND) return int(scrubbed + rounded * definitions.MICROSECONDS_PER_SECOND)"
            },
            {
                "url": 1704,
                "code": "def from_timestamp(microsecond_timestamp): # Create datetime without losing precision from floating point (yes, this # is actually needed): return datetime.datetime.fromtimestamp( microsecond_timestamp // 1000000, datetime.timezone.utc ).replace(microsecond=(microsecond_timestamp % 1000000))"
            },
            {
                "url": 1263,
                "code": "def timestamp_to_datetime(timestamp): from datetime import datetime, timedelta obj = datetime.fromtimestamp(timestamp[0]) return obj + timedelta(microseconds=int(timestamp[1]))"
            },
            {
                "url": 377,
                "code": "def convert_timestamp(timestamp): datetime = dt.datetime.utcfromtimestamp(timestamp/1000.) return np.datetime64(datetime.replace(tzinfo=None))"
            },
            {
                "url": 2766,
                "code": "def datetime_to_timestamp(dt): delta = dt - datetime.utcfromtimestamp(0) return delta.seconds + delta.days * 24 * 3600"
            },
            {
                "url": 2239,
                "code": "def time_string(seconds): s = int(round(seconds)) # round to nearest second h, s = divmod(s, 3600) # get hours and remainder m, s = divmod(s, 60) # split remainder into minutes and seconds return \"%2i:%02i:%02i\" % (h, m, s)"
            },
            {
                "url": 1373,
                "code": "def date_to_timestamp(date): date_tuple = date.timetuple() timestamp = calendar.timegm(date_tuple) * 1000 return timestamp"
            },
            {
                "url": 119,
                "code": "def ToDatetime(self): return datetime.utcfromtimestamp( self.seconds + self.nanos / float(_NANOS_PER_SECOND))"
            },
            {
                "url": 929,
                "code": "def timestamp_to_microseconds(timestamp): timestamp_str = datetime.datetime.strptime(timestamp, ISO_DATETIME_REGEX) epoch_time_secs = calendar.timegm(timestamp_str.timetuple()) epoch_time_mus = epoch_time_secs * 1e6 + timestamp_str.microsecond return epoch_time_mus"
            },
            {
                "url": 127,
                "code": "def parse_timestamp(timestamp): dt = dateutil.parser.parse(timestamp) return dt.astimezone(dateutil.tz.tzutc())"
            },
            {
                "url": 3544,
                "code": "def Timestamp(year, month, day, hour, minute, second): return datetime.datetime(year, month, day, hour, minute, second)"
            },
            {
                "url": 6127,
                "code": "def clip_to_seconds(m: Union[int, pd.Series]) -> Union[int, pd.Series]: return m // pd.Timedelta(1, unit='s').value"
            },
            {
                "url": 115,
                "code": "def datetime_to_ms(dt): seconds = calendar.timegm(dt.utctimetuple()) return seconds * 1000 + int(dt.microsecond / 1000)"
            },
            {
                "url": 1259,
                "code": "def ms_to_datetime(ms): dt = datetime.datetime.utcfromtimestamp(ms / 1000) return dt.replace(microsecond=(ms % 1000) * 1000).replace(tzinfo=pytz.utc)"
            },
            {
                "url": 3961,
                "code": "def __round_time(self, dt): round_to = self._resolution.total_seconds() seconds = (dt - dt.min).seconds rounding = (seconds + round_to / 2) // round_to * round_to return dt + timedelta(0, rounding - seconds, -dt.microsecond)"
            }
        ],
        "url": 3242
    },
    {
        "nl_input": "python json load unorde",
        "code_input": [
            {
                "url": 5016,
                "code": "def load(cls, fp, **kwargs): json_obj = json.load(fp, **kwargs) return parse(cls, json_obj)"
            },
            {
                "url": 2062,
                "code": "def json_decode(data): if isinstance(data, six.binary_type): data = data.decode('utf-8') return json.loads(data)"
            },
            {
                "url": 3889,
                "code": "def load_jsonf(fpath, encoding): with codecs.open(fpath, encoding=encoding) as f: return json.load(f)"
            },
            {
                "url": 1409,
                "code": "def _loadfilepath(self, filepath, **kwargs): with open(filepath, \"r\") as f: data = json.load(f, **kwargs) return data"
            },
            {
                "url": 977,
                "code": "def open_json(file_name): with open(file_name, \"r\") as json_data: data = json.load(json_data) return data"
            },
            {
                "url": 3131,
                "code": "def _read_json_file(self, json_file): self.log.debug(\"Reading '%s' JSON file...\" % json_file) with open(json_file, 'r') as f: return json.load(f, object_pairs_hook=OrderedDict)"
            },
            {
                "url": 157,
                "code": "def from_json(cls, json_str): d = json.loads(json_str) return cls.from_dict(d)"
            },
            {
                "url": 2552,
                "code": "def load_from_file(cls, file_path: str): with open(file_path, \"r\") as f: data = json.load(f) item = cls.decode(data=data) return item"
            },
            {
                "url": 4188,
                "code": "def json_get_data(filename): with open(filename) as fp: json_data = json.load(fp) return json_data return False"
            },
            {
                "url": 3659,
                "code": "def from_file(filename): f = open(filename, 'r') j = json.load(f) f.close() return from_dict(j)"
            },
            {
                "url": 1300,
                "code": "def read_json(location): location = ensure_path(location) with location.open('r', encoding='utf8') as f: return ujson.load(f)"
            },
            {
                "url": 2057,
                "code": "def json(body, charset='utf-8', **kwargs): return json_converter.loads(text(body, charset=charset))"
            },
            {
                "url": 5288,
                "code": "def from_json(cls, json_doc): try: d = json.load(json_doc) except AttributeError: # catch the read() error d = json.loads(json_doc) return cls.from_dict(d)"
            },
            {
                "url": 5563,
                "code": "def from_file(file_path) -> dict: with io.open(file_path, 'r', encoding='utf-8') as json_stream: return Json.parse(json_stream, True)"
            },
            {
                "url": 3011,
                "code": "def load(cls, fname): with open(fname) as f: return Config(**json.load(f))"
            }
        ],
        "url": 1300
    },
    {
        "nl_input": "python yaml expected single document",
        "code_input": [
            {
                "url": 6141,
                "code": "def load_yaml(file): if hasattr(yaml, \"full_load\"): return yaml.full_load(file) else: return yaml.load(file)"
            },
            {
                "url": 3335,
                "code": "def getYamlDocument(filePath): with open(filePath) as stream: doc = yaml.load(stream) return doc"
            },
            {
                "url": 1353,
                "code": "def load_yaml_file(file_path: str): with codecs.open(file_path, 'r') as f: return yaml.safe_load(f)"
            },
            {
                "url": 1096,
                "code": "def load_yaml(filepath): with open(filepath) as f: txt = f.read() return yaml.load(txt)"
            },
            {
                "url": 229,
                "code": "def print_yaml(o): print(yaml.dump(o, default_flow_style=False, indent=4, encoding='utf-8'))"
            },
            {
                "url": 3458,
                "code": "def Parse(text): precondition.AssertType(text, Text) if compatibility.PY2: text = text.encode(\"utf-8\") return yaml.safe_load(text)"
            },
            {
                "url": 1355,
                "code": "def yaml_to_param(obj, name): return from_pyvalue(u\"yaml:%s\" % name, unicode(yaml.dump(obj)))"
            },
            {
                "url": 6002,
                "code": "def load_yaml(yaml_file: str) -> Any: with open(yaml_file, 'r') as file: return ruamel.yaml.load(file, ruamel.yaml.RoundTripLoader)"
            },
            {
                "url": 3922,
                "code": "def _ParseYamlFromFile(filedesc): content = filedesc.read() return yaml.Parse(content) or collections.OrderedDict()"
            },
            {
                "url": 735,
                "code": "def _include_yaml(loader, node): return load_yaml(os.path.join(os.path.dirname(loader.name), node.value))"
            },
            {
                "url": 380,
                "code": "def cli(yamlfile, format, context): print(JSONLDGenerator(yamlfile, format).serialize(context=context))"
            },
            {
                "url": 4299,
                "code": "def generate_yaml_file(filename, contents): with open(filename, 'w') as file: file.write(yaml.dump(contents, default_flow_style=False))"
            },
            {
                "url": 3965,
                "code": "def Dump(obj): text = yaml.safe_dump(obj, default_flow_style=False, allow_unicode=True) if compatibility.PY2: text = text.decode(\"utf-8\") return text"
            },
            {
                "url": 5462,
                "code": "def ParseMany(text): precondition.AssertType(text, Text) if compatibility.PY2: text = text.encode(\"utf-8\") return list(yaml.safe_load_all(text))"
            },
            {
                "url": 3305,
                "code": "def serialize_yaml_tofile(filename, resource): stream = file(filename, \"w\") yaml.dump(resource, stream, default_flow_style=False)"
            }
        ],
        "url": 1355
    },
    {
        "nl_input": "python filter object at",
        "code_input": [
            {
                "url": 4104,
                "code": "def __init__(self): super(FilterObject, self).__init__() self._filter_expression = None self._matcher = None"
            },
            {
                "url": 1722,
                "code": "def filter(self, obj, *args, **kwargs): for _, _, func in self._filter_order: obj = func(obj, *args, **kwargs) if obj is None: return None return obj"
            },
            {
                "url": 4102,
                "code": "def __init__(self, function): super(filter, self).__init__() self.function = function"
            },
            {
                "url": 5176,
                "code": "def apply(filter): def decorator(callable): return lambda *args, **kwargs: filter(callable(*args, **kwargs)) return decorator"
            },
            {
                "url": 1815,
                "code": "def filter(self, f, operator=\"and\"): if self._filtered: self._filter_dsl.filter(f) else: self._build_filtered_query(f, operator) return self"
            },
            {
                "url": 4480,
                "code": "def filter(self, func): return self.__class__( [ i for i in self.res if func(*i) ], name='filtered %s'%self.listname)"
            },
            {
                "url": 295,
                "code": "def filter_(stream_spec, filter_name, *args, **kwargs): return filter(stream_spec, filter_name, *args, **kwargs)"
            },
            {
                "url": 1889,
                "code": "def __get__(self, obj, objtype): import functools return functools.partial(self.__call__, obj)"
            },
            {
                "url": 6078,
                "code": "def filter_float(n: Node, query: str) -> float: return _scalariter2item(n, query, float)"
            },
            {
                "url": 177,
                "code": "def filter_dict(d, keys): return {k: v for k, v in d.items() if k in keys}"
            },
            {
                "url": 2312,
                "code": "def __get__(self, obj, objtype): if not self.is_method: self.is_method = True return functools.partial(self.__call__, obj)"
            },
            {
                "url": 1002,
                "code": "def filter_dict_by_key(d, keys): return {k: v for k, v in d.items() if k in keys}"
            },
            {
                "url": 5007,
                "code": "def query(self, base, filterstr, attrlist=None): return self.conn.search_s(base, ldap.SCOPE_SUBTREE, filterstr, attrlist)"
            },
            {
                "url": 364,
                "code": "def dict_from_object(obj: object): # If object is a dict instance, no need to convert. return (obj if isinstance(obj, dict) else {attr: getattr(obj, attr) for attr in dir(obj) if not attr.startswith('_')})"
            },
            {
                "url": 3532,
                "code": "def apply_filters(df, filters): idx = pd.Series([True]*df.shape[0]) for k, v in list(filters.items()): if k not in df.columns: continue idx &= (df[k] == v) return df.loc[idx]"
            }
        ],
        "url": 4102
    },
    {
        "nl_input": "python nonetype object has no attributte",
        "code_input": [
            {
                "url": 4144,
                "code": "def _none_value(self): if self.out_type == int: return 0 elif self.out_type == float: return 0.0 elif self.out_type == bool: return False elif self.out_type == six.text_type: return u''"
            },
            {
                "url": 3312,
                "code": "def is_empty(self): non_type_attributes = [attr for attr in self.node.attrib.keys() if attr != 'type'] return len(self.node) == 0 and len(non_type_attributes) == 0 \\ and not self.node.text and not self.node.tail"
            },
            {
                "url": 3157,
                "code": "def object_type_repr(obj): if obj is None: return 'None' elif obj is Ellipsis: return 'Ellipsis' if obj.__class__.__module__ == '__builtin__': name = obj.__class__.__name__ else: name = obj.__class__.__module__ + '.' + obj.__class__.__name__ return '%s object' % name"
            },
            {
                "url": 2822,
                "code": "def __getattribute__(self, attr): if (attr not in object.__getattribute__(self, '__dict__') and attr not in Etree.__dict__): return object.__getattribute__(self._etree, attr) return object.__getattribute__(self, attr)"
            },
            {
                "url": 5919,
                "code": "def is_none(string_, default='raise'): none = ['none', 'undefined', 'unknown', 'null', ''] if string_.lower() in none: return True elif not default: return False else: raise ValueError('The value \\'{}\\' cannot be mapped to none.' .format(string_))"
            },
            {
                "url": 1710,
                "code": "def update_dict(obj, dict, attributes): for attribute in attributes: if hasattr(obj, attribute) and getattr(obj, attribute) is not None: dict[attribute] = getattr(obj, attribute)"
            },
            {
                "url": 1889,
                "code": "def __get__(self, obj, objtype): import functools return functools.partial(self.__call__, obj)"
            },
            {
                "url": 5331,
                "code": "def static_get_type_attr(t, name): for type_ in t.mro(): try: return vars(type_)[name] except KeyError: pass raise AttributeError(name)"
            },
            {
                "url": 691,
                "code": "def _unjsonify(x, isattributes=False): if isattributes: obj = json.loads(x) return dict_class(obj) return json.loads(x)"
            },
            {
                "url": 2964,
                "code": "def _replace_none(self, aDict): for k, v in aDict.items(): if v is None: aDict[k] = 'none'"
            },
            {
                "url": 2673,
                "code": "def is_all_field_none(self): if self._type_ is not None: return False if self._value is not None: return False if self._name is not None: return False return True"
            },
            {
                "url": 2312,
                "code": "def __get__(self, obj, objtype): if not self.is_method: self.is_method = True return functools.partial(self.__call__, obj)"
            },
            {
                "url": 4364,
                "code": "def fval(self, instance): try: val = instance.__dict__[self.instance_field_name] except KeyError as e: #raise AttributeError(str(e)) val = None return val"
            },
            {
                "url": 61,
                "code": "def create_object(cls, members): obj = cls.__new__(cls) obj.__dict__ = members return obj"
            },
            {
                "url": 628,
                "code": "def value(self): if self._prop.fget is None: raise AttributeError('Unable to read attribute') return self._prop.fget(self._obj)"
            }
        ],
        "url": 94
    },
    {
        "nl_input": "python tkinter how to create scrollable canvas",
        "code_input": [
            {
                "url": 3619,
                "code": "def __grid_widgets(self): scrollbar_column = 0 if self.__compound is tk.LEFT else 2 self._canvas.grid(row=0, column=1, sticky=\"nswe\") self._scrollbar.grid(row=0, column=scrollbar_column, sticky=\"ns\")"
            },
            {
                "url": 2648,
                "code": "def set_scrollregion(self, event=None): self.canvas.configure(scrollregion=self.canvas.bbox('all'))"
            },
            {
                "url": 1083,
                "code": "def _set_scroll_v(self, *args): self._canvas_categories.yview(*args) self._canvas_scroll.yview(*args)"
            },
            {
                "url": 4010,
                "code": "def set_scrollbars_cb(self, w, tf): scrollbars = 'on' if tf else 'off' self.t_.set(scrollbars=scrollbars)"
            },
            {
                "url": 2585,
                "code": "def __init__(self, master=None, compound=tk.RIGHT, autohidescrollbar=True, **kwargs): ttk.Frame.__init__(self, master) self.columnconfigure(1, weight=1) self.rowconfigure(0, weight=1) self.listbox = tk.Listbox(self, **kwargs) if autohidescrollbar: self.scrollbar = AutoHideScrollbar(self, orient=tk.VERTICAL, command=self.listbox.yview) else: self.scrollbar = ttk.Scrollbar(self, orient=tk.VERTICAL, command=self.listbox.yview) self.config_listbox(yscrollcommand=self.scrollbar.set) if compound is not tk.LEFT and compound is not tk.RIGHT: raise ValueError(\"Invalid compound value passed: {0}\".format(compound)) self.__compound = compound self._grid_widgets()"
            },
            {
                "url": 2751,
                "code": "def build_gui(self, container): vbox = Widgets.VBox() vbox.set_border_width(0) w = Viewers.GingaViewerWidget(viewer=self) vbox.add_widget(w, stretch=1) # need to put this in an hbox with an expanding label or the # browser wants to resize the canvas, distorting it hbox = Widgets.HBox() hbox.add_widget(vbox, stretch=0) hbox.add_widget(Widgets.Label(''), stretch=1) container.set_widget(hbox)"
            },
            {
                "url": 5123,
                "code": "def _grid_widgets(self): scrollbar_column = 0 if self.__compound is tk.LEFT else 2 self.listbox.grid(row=0, column=1, sticky=\"nswe\") self.scrollbar.grid(row=0, column=scrollbar_column, sticky=\"ns\")"
            },
            {
                "url": 4395,
                "code": "def create_widget(self): d = self.declaration button_type = UIButton.UIButtonTypeSystem if d.flat else UIButton.UIButtonTypeRoundedRect self.widget = UIButton(buttonWithType=button_type)"
            },
            {
                "url": 4905,
                "code": "def resize(self, width, height): self._buffer = QtGui.QImage(width, height, QtGui.QImage.Format_RGB32) QtGui.QWidget.resize(self, width, height)"
            },
            {
                "url": 2810,
                "code": "def _draw_lines_internal(self, coords, colour, bg): for i, (x, y) in enumerate(coords): if i == 0: self._screen.move(x, y) else: self._screen.draw(x, y, colour=colour, bg=bg, thin=True)"
            },
            {
                "url": 4125,
                "code": "def forget_canvas(canvas): cc = [c() for c in canvasses if c() is not None] while canvas in cc: cc.remove(canvas) canvasses[:] = [weakref.ref(c) for c in cc]"
            },
            {
                "url": 5291,
                "code": "def _enter_plotting(self, fontsize=9): # interactive_status = matplotlib.is_interactive() self.original_fontsize = pyplot.rcParams['font.size'] pyplot.rcParams['font.size'] = fontsize pyplot.hold(False) # opens a figure window, if non exists pyplot.ioff()"
            },
            {
                "url": 3193,
                "code": "def scroll_element_into_view(self): x = self.web_element.location['x'] y = self.web_element.location['y'] self.driver.execute_script('window.scrollTo({0}, {1})'.format(x, y)) return self"
            },
            {
                "url": 4618,
                "code": "def widget(self, f): return self.cls(f, self.opts, **self.kwargs)"
            },
            {
                "url": 5358,
                "code": "def screen(self, width, height, colorDepth): screenEvent = ScreenEvent() screenEvent.width.value = width screenEvent.height.value = height screenEvent.colorDepth.value = colorDepth self.rec(screenEvent)"
            }
        ],
        "url": 1083
    },
    {
        "nl_input": "geojson to topojson python",
        "code_input": [
            {
                "url": 4600,
                "code": "def to_topojson(self): topojson = self.topojson topojson[\"objects\"][\"points\"] = { \"type\": \"GeometryCollection\", \"geometries\": [point.to_topojson() for point in self.points.all()], } return json.dumps(topojson)"
            },
            {
                "url": 682,
                "code": "def dump_json(obj): return simplejson.dumps(obj, ignore_nan=True, default=json_util.default)"
            },
            {
                "url": 4042,
                "code": "def obj_to_string(obj, top=True): obj = prepare_for_json_encoding(obj) if type(obj) == six.text_type: return obj return json.dumps(obj)"
            },
            {
                "url": 6236,
                "code": "def to_json(self) -> Mapping: return {str(x): str(y) for x, y in self.items()}"
            },
            {
                "url": 2465,
                "code": "def toJson(protoObject, indent=None): # Using the internal method because this way we can reformat the JSON js = json_format.MessageToDict(protoObject, False) return json.dumps(js, indent=indent)"
            },
            {
                "url": 2670,
                "code": "def jsonify(symbol): try: # all symbols have a toJson method, try it return json.dumps(symbol.toJson(), indent=' ') except AttributeError: pass return json.dumps(symbol, indent=' ')"
            },
            {
                "url": 1059,
                "code": "def _dict_to_proto(py_dict, proto): dict_json_str = json.dumps(py_dict) return json_format.Parse(dict_json_str, proto)"
            },
            {
                "url": 1758,
                "code": "def to_json(obj): i = StringIO.StringIO() w = Writer(i, encoding='UTF-8') w.write_value(obj) return i.getvalue()"
            },
            {
                "url": 2237,
                "code": "def to_json(data): return json.dumps(data, default=lambda x: x.__dict__, sort_keys=True, indent=4)"
            },
            {
                "url": 4442,
                "code": "def save_json(object, handle, indent=2): obj_json = json.dumps(object, indent=indent, cls=NumpyJSONEncoder) handle.write(obj_json)"
            },
            {
                "url": 1935,
                "code": "def object_to_json(obj, indent=2): instance_json = json.dumps(obj, indent=indent, ensure_ascii=False, cls=DjangoJSONEncoder) return instance_json"
            },
            {
                "url": 1198,
                "code": "def _serialize_json(obj, fp): json.dump(obj, fp, indent=4, default=serialize)"
            },
            {
                "url": 4120,
                "code": "def object_to_json(obj): if isinstance(obj, (datetime.datetime, datetime.date, datetime.time)): return obj.isoformat() return str(obj)"
            },
            {
                "url": 4796,
                "code": "def json_pretty_dump(obj, filename): with open(filename, \"wt\") as fh: json.dump(obj, fh, indent=4, sort_keys=4)"
            },
            {
                "url": 4968,
                "code": "def mongoqs_to_json(qs, fields=None): l = list(qs.as_pymongo()) for element in l: element.pop('_cls') # use DjangoJSONEncoder for transform date data type to datetime json_qs = json.dumps(l, indent=2, ensure_ascii=False, cls=DjangoJSONEncoder) return json_qs"
            }
        ],
        "url": 4600
    },
    {
        "nl_input": "python get png image dimensions",
        "code_input": [
            {
                "url": 1861,
                "code": "def get_image_dimension(self, url): w_h = (None, None) try: if url.startswith('//'): url = 'http:' + url data = requests.get(url).content im = Image.open(BytesIO(data)) w_h = im.size except Exception: logger.warning(\"Error getting image size {}\".format(url), exc_info=True) return w_h"
            },
            {
                "url": 5568,
                "code": "def getDimensionForImage(filename, maxsize): try: from PIL import Image except ImportError: return None img = Image.open(filename) width, height = img.size if width > maxsize[0] or height > maxsize[1]: img.thumbnail(maxsize) out.info(\"Downscaled display size from %s to %s\" % ((width, height), img.size)) return img.size"
            },
            {
                "url": 4784,
                "code": "def get_img_data(f, maxsize = (1200, 850), first = False): img = Image.open(f) img.thumbnail(maxsize) if first: # tkinter is inactive the first time bio = io.BytesIO() img.save(bio, format = \"PNG\") del img return bio.getvalue() return ImageTk.PhotoImage(img)"
            },
            {
                "url": 1142,
                "code": "def resize_image(self, data, size): from machina.core.compat import PILImage as Image image = Image.open(BytesIO(data)) # Resize! image.thumbnail(size, Image.ANTIALIAS) string = BytesIO() image.save(string, format='PNG') return string.getvalue()"
            },
            {
                "url": 2021,
                "code": "def get_shape(img): if hasattr(img, 'shape'): shape = img.shape else: shape = img.get_data().shape return shape"
            },
            {
                "url": 6050,
                "code": "def _width_is_big_enough(image, width): if width > image.size[0]: raise ImageSizeError(image.size[0], width)"
            },
            {
                "url": 2018,
                "code": "def resize(self, size): return Image(self.pil_image.resize(size, PIL.Image.ANTIALIAS))"
            },
            {
                "url": 1871,
                "code": "def url_to_image(url): r = requests.get(url) image = StringIO(r.content) return image"
            },
            {
                "url": 1269,
                "code": "def resize_image_to_fit_width(image, dest_w): scale_factor = dest_w / image.size[0] dest_h = image.size[1] * scale_factor scaled_image = image.resize((int(dest_w), int(dest_h)), PIL.Image.ANTIALIAS) return scaled_image"
            },
            {
                "url": 3081,
                "code": "def get_image(self, source): buf = StringIO(source.read()) return Image.open(buf)"
            },
            {
                "url": 5421,
                "code": "def file_to_png(fp): import PIL.Image # pylint: disable=import-error with io.BytesIO() as dest: PIL.Image.open(fp).save(dest, \"PNG\", optimize=True) return dest.getvalue()"
            },
            {
                "url": 5817,
                "code": "def calculate_dimensions(image, long_side, short_side): if image.width >= image.height: return '{0}x{1}'.format(long_side, short_side) return '{0}x{1}'.format(short_side, long_side)"
            },
            {
                "url": 4823,
                "code": "def resize(self): resized_size = self.get_resized_size() if not resized_size: return self.image = self.image.resize(resized_size, Image.ANTIALIAS)"
            },
            {
                "url": 3209,
                "code": "def display_pil_image(im): from IPython.core import display b = BytesIO() im.save(b, format='png') data = b.getvalue() ip_img = display.Image(data=data, format='png', embed=True) return ip_img._repr_png_()"
            },
            {
                "url": 2547,
                "code": "def url_to_image(url, flag=cv2.IMREAD_COLOR): resp = urlopen(url) image = np.asarray(bytearray(resp.read()), dtype=\"uint8\") image = cv2.imdecode(image, flag) return image"
            }
        ],
        "url": 5568
    },
    {
        "nl_input": "python flask separate functions get and post",
        "code_input": [
            {
                "url": 310,
                "code": "def handleFlaskPostRequest(flaskRequest, endpoint): if flaskRequest.method == \"POST\": return handleHttpPost(flaskRequest, endpoint) elif flaskRequest.method == \"OPTIONS\": return handleHttpOptions() else: raise exceptions.MethodNotAllowedException()"
            },
            {
                "url": 3384,
                "code": "def POST(self, *args, **kwargs): return self._handle_api(self.API_POST, args, kwargs)"
            },
            {
                "url": 1047,
                "code": "def requests_post(url, data=None, json=None, **kwargs): return requests_request('post', url, data=data, json=json, **kwargs)"
            },
            {
                "url": 1069,
                "code": "def make_post_request(self, url, auth, json_payload): response = requests.post(url, auth=auth, json=json_payload) return response.json()"
            },
            {
                "url": 2840,
                "code": "def getFlaskResponse(responseString, httpStatus=200): return flask.Response(responseString, status=httpStatus, mimetype=MIMETYPE)"
            },
            {
                "url": 2269,
                "code": "def _post(self, url, params, uploads=None): self._call(self.POST, url, params, uploads)"
            },
            {
                "url": 5813,
                "code": "def post(self, endpoint: str, **kwargs) -> dict: return self._request('POST', endpoint, **kwargs)"
            },
            {
                "url": 3162,
                "code": "def send_post(self, url, data, remove_header=None): return self.send_request(method=\"post\", url=url, data=data, remove_header=remove_header)"
            },
            {
                "url": 597,
                "code": "def post_object_async(self, path, **kwds): return self.do_request_async(self.api_url + path, 'POST', **kwds)"
            },
            {
                "url": 2676,
                "code": "def can_route(self, endpoint, method=None, **kwargs): view = flask.current_app.view_functions.get(endpoint) if not view: endpoint, args = flask._request_ctx.top.match(endpoint) view = flask.current_app.view_functions.get(endpoint) if not view: return False return self.can('http.' + (method or 'GET').lower(), view, **kwargs)"
            },
            {
                "url": 1421,
                "code": "def redirect(view=None, url=None, **kwargs): if view: if url: kwargs[\"url\"] = url url = flask.url_for(view, **kwargs) current_context.exit(flask.redirect(url))"
            },
            {
                "url": 307,
                "code": "def parse_form(self, req, name, field): return core.get_value(req.POST, name, field)"
            },
            {
                "url": 1027,
                "code": "def http_request_json(*args, **kwargs): ret, status = http_request(*args, **kwargs) return json.loads(ret), status"
            },
            {
                "url": 3156,
                "code": "def pretty_print_post(req): print(('{}\\n{}\\n{}\\n\\n{}'.format( '-----------START-----------', req.method + ' ' + req.url, '\\n'.join('{}: {}'.format(k, v) for k, v in list(req.headers.items())), req.body, )))"
            },
            {
                "url": 6225,
                "code": "def run_web(self, flask, host='127.0.0.1', port=5000, **options): # type: (Zsl, str, int, **Any)->None return flask.run( host=flask.config.get('FLASK_HOST', host), port=flask.config.get('FLASK_PORT', port), debug=flask.config.get('DEBUG', False), **options )"
            }
        ],
        "url": 310
    },
    {
        "nl_input": "return year from date python",
        "code_input": [
            {
                "url": 5670,
                "code": "def year(date): try: fmt = '%m/%d/%Y' return datetime.strptime(date, fmt).timetuple().tm_year except ValueError: return 0"
            },
            {
                "url": 3491,
                "code": "def today(year=None): return datetime.date(int(year), _date.month, _date.day) if year else _date"
            },
            {
                "url": 2020,
                "code": "def get_date(date): if type(date) is str: return datetime.strptime(date, '%Y-%m-%d').date() else: return date"
            },
            {
                "url": 5854,
                "code": "def _parse_date(string: str) -> datetime.date: return datetime.datetime.strptime(string, '%Y-%m-%d').date()"
            },
            {
                "url": 176,
                "code": "def int_to_date(date): year = date // 10**4 month = date % 10**4 // 10**2 day = date % 10**2 return datetime.date(year, month, day)"
            },
            {
                "url": 1700,
                "code": "def string_to_date(value): if isinstance(value, datetime.date): return value return dateutil.parser.parse(value).date()"
            },
            {
                "url": 888,
                "code": "def parse_date(s): if isinstance(s, (datetime.datetime, datetime.date)): return s try: from dateutil.parser import parse except ImportError: parse = lambda d: datetime.datetime.strptime(d, \"%Y-%m-%d\") return parse(s)"
            },
            {
                "url": 5316,
                "code": "def get_year_start(day=None): day = add_timezone(day or datetime.date.today()) return day.replace(month=1).replace(day=1)"
            },
            {
                "url": 5950,
                "code": "def iso_string_to_python_datetime( isostring: str) -> Optional[datetime.datetime]: if not isostring: return None # if you parse() an empty string, you get today's date return dateutil.parser.parse(isostring)"
            },
            {
                "url": 2523,
                "code": "def _parse(self, date_str, format='%Y-%m-%d'): rv = pd.to_datetime(date_str, format=format) if hasattr(rv, 'to_pydatetime'): rv = rv.to_pydatetime() return rv"
            },
            {
                "url": 107,
                "code": "def parse(self, s): return datetime.datetime.strptime(s, self.date_format).date()"
            },
            {
                "url": 125,
                "code": "def _convert_date_to_dict(field_date): return {DAY: field_date.day, MONTH: field_date.month, YEAR: field_date.year}"
            },
            {
                "url": 571,
                "code": "def _read_date_from_string(str1): full_date = [int(x) for x in str1.split('/')] return datetime.date(full_date[0], full_date[1], full_date[2])"
            },
            {
                "url": 3206,
                "code": "def from_years_range(start_year, end_year): start = datetime.date(start_year, 1 , 1) end = datetime.date(end_year, 12 , 31) return DateRange(start, end)"
            },
            {
                "url": 2044,
                "code": "def gday_of_year(self): return (self.date - dt.date(self.date.year, 1, 1)).days"
            }
        ],
        "url": 5670
    },
    {
        "nl_input": "how to get all modes python",
        "code_input": [
            {
                "url": 3498,
                "code": "def get_python(self): if self.multiselect: return super(MultiSelectField, self).get_python() return self._get()"
            },
            {
                "url": 5046,
                "code": "def __iter__(self): return iter([v for k, v in sorted(self._modes.items())])"
            },
            {
                "url": 668,
                "code": "def get_python(): if sys.platform == 'win32': python = path.join(VE_ROOT, 'Scripts', 'python.exe') else: python = path.join(VE_ROOT, 'bin', 'python') return python"
            },
            {
                "url": 1268,
                "code": "def get_python_dict(scala_map): python_dict = {} keys = get_python_list(scala_map.keys().toList()) for key in keys: python_dict[key] = scala_map.apply(key) return python_dict"
            },
            {
                "url": 4458,
                "code": "def _split_python(python): python = _preprocess(python) if not python: return [] lexer = PythonSplitLexer() lexer.read(python) return lexer.chunks"
            },
            {
                "url": 2385,
                "code": "def get_py_source(file): try: response = None pysource = \"\" if regexp_py.search(file) is None: response = {\"error\": \"Only Python source files are allowed. (*.py)\"} else: with open(file, 'r') as pyfile: pysource = pyfile.read() response = {\"data\": pysource} except Exception as e: response = {\"error\": str(e)} finally: return response"
            },
            {
                "url": 2324,
                "code": "def setup_detect_python2(): if None in [RTs._rt_py2_detect, RTs._rtp_py2_detect]: RTs._rt_py2_detect = RefactoringTool(py2_detect_fixers) RTs._rtp_py2_detect = RefactoringTool(py2_detect_fixers, {'print_function': True})"
            },
            {
                "url": 523,
                "code": "def _get_compiled_ext(): for ext, mode, typ in imp.get_suffixes(): if typ == imp.PY_COMPILED: return ext"
            },
            {
                "url": 569,
                "code": "def to_python(self, value): if value is None: return value if isinstance(value, self.enum): return value return self.enum[value]"
            },
            {
                "url": 727,
                "code": "def get_all_attributes(klass_or_instance): pairs = list() for attr, value in inspect.getmembers( klass_or_instance, lambda x: not inspect.isroutine(x)): if not (attr.startswith(\"__\") or attr.endswith(\"__\")): pairs.append((attr, value)) return pairs"
            },
            {
                "url": 90,
                "code": "def _dictfetchall(self, cursor): columns = [col[0] for col in cursor.description] return [ dict(zip(columns, row)) for row in cursor.fetchall() ]"
            },
            {
                "url": 311,
                "code": "def python_mime(fn): @wraps(fn) def python_mime_decorator(*args, **kwargs): response.content_type = \"text/x-python\" return fn(*args, **kwargs) return python_mime_decorator"
            },
            {
                "url": 2245,
                "code": "def get_all_items(obj): if hasattr(obj, 'getlist'): items = [] for key in obj: for value in obj.getlist(key): items.append((key, value)) return items else: return obj.items()"
            },
            {
                "url": 4320,
                "code": "def functions(self): return [v for v in self.globals.values() if isinstance(v, values.Function)]"
            },
            {
                "url": 88,
                "code": "def dictfetchall(cursor): desc = cursor.description return [dict(zip([col[0] for col in desc], row)) for row in cursor.fetchall()]"
            }
        ],
        "url": 5046
    },
    {
        "nl_input": "integer and returns a random bitstring of size python",
        "code_input": [
            {
                "url": 1202,
                "code": "def random_int(maximum_value): if maximum_value == 0: return 0 elif maximum_value == 1: return random_bits(1) bits = math.floor(math.log2(maximum_value)) result = random_bits(bits) + random_int(maximum_value - ((2 ** bits) - 1)) return result"
            },
            {
                "url": 4569,
                "code": "def random_int(self, min=0, max=9999, step=1): return self.generator.random.randrange(min, max + 1, step)"
            },
            {
                "url": 3733,
                "code": "def random_numbers(n): return ''.join(random.SystemRandom().choice(string.digits) for _ in range(n))"
            },
            {
                "url": 3763,
                "code": "def gen_random_string(str_len): return ''.join( random.choice(string.ascii_letters + string.digits) for _ in range(str_len))"
            },
            {
                "url": 4270,
                "code": "def generate_random_string(chars=7): return u\"\".join(random.sample(string.ascii_letters * 2 + string.digits, chars))"
            },
            {
                "url": 276,
                "code": "def random_str(size=10): return ''.join(random.choice(string.ascii_lowercase) for _ in range(size))"
            },
            {
                "url": 2530,
                "code": "def random_id(size=8, chars=string.ascii_letters + string.digits): return ''.join(random.choice(chars) for _ in range(size))"
            },
            {
                "url": 5717,
                "code": "def binary(length): num = randint(1, 999999) mask = '0' * length return (mask + ''.join([str(num >> i & 1) for i in range(7, -1, -1)]))[-length:]"
            },
            {
                "url": 2250,
                "code": "def rndstr(size=16): _basech = string.ascii_letters + string.digits return \"\".join([rnd.choice(_basech) for _ in range(size)])"
            },
            {
                "url": 2861,
                "code": "def random_id(length): def char(): \"\"\"Generate single random char\"\"\" return random.choice(string.ascii_letters + string.digits) return \"\".join(char() for _ in range(length))"
            },
            {
                "url": 2864,
                "code": "def generate_random_id(size=6, chars=string.ascii_uppercase + string.digits): return \"\".join(random.choice(chars) for x in range(size))"
            },
            {
                "url": 5452,
                "code": "def random_string(string_length=10): random = str(uuid.uuid4()) # Convert UUID format to a Python string. random = random.upper() # Make all characters uppercase. random = random.replace(\"-\", \"\") # Remove the UUID '-'. return random[0:string_length]"
            },
            {
                "url": 937,
                "code": "def qrandom(n): import quantumrandom return np.concatenate([ quantumrandom.get_data(data_type='uint16', array_length=1024) for i in range(int(np.ceil(n/1024.0))) ])[:n]"
            },
            {
                "url": 3228,
                "code": "def get_random_id(length): alphabet = string.ascii_uppercase + string.ascii_lowercase + string.digits return ''.join(random.choice(alphabet) for _ in range(length))"
            },
            {
                "url": 70,
                "code": "def _get_random_id(): symbols = string.ascii_uppercase + string.ascii_lowercase + string.digits return ''.join(random.choice(symbols) for _ in range(15))"
            }
        ],
        "url": 5717
    },
    {
        "nl_input": "how to get the encoding of a file python",
        "code_input": [
            {
                "url": 408,
                "code": "def get_best_encoding(stream): rv = getattr(stream, 'encoding', None) or sys.getdefaultencoding() if is_ascii_encoding(rv): return 'utf-8' return rv"
            },
            {
                "url": 244,
                "code": "def read_from_file(file_path, encoding=\"utf-8\"): with codecs.open(file_path, \"r\", encoding) as f: return f.read()"
            },
            {
                "url": 970,
                "code": "def read_string_from_file(path, encoding=\"utf8\"): with codecs.open(path, \"rb\", encoding=encoding) as f: value = f.read() return value"
            },
            {
                "url": 1148,
                "code": "def getdefaultencoding(): enc = get_stream_enc(sys.stdin) if not enc or enc=='ascii': try: # There are reports of getpreferredencoding raising errors # in some cases, which may well be fixed, but let's be conservative here. enc = locale.getpreferredencoding() except Exception: pass return enc or sys.getdefaultencoding()"
            },
            {
                "url": 4262,
                "code": "def detect(filename, include_confidence=False): f = open(filename) detection = chardet.detect(f.read()) f.close() encoding = detection.get('encoding') confidence = detection.get('confidence') if include_confidence: return (encoding, confidence) return encoding"
            },
            {
                "url": 1063,
                "code": "def open_with_encoding(filename, encoding, mode='r'): return io.open(filename, mode=mode, encoding=encoding, newline='')"
            },
            {
                "url": 6263,
                "code": "def copen(filepath, flag='r', encoding=None): if encoding is None: encoding = locale.getdefaultlocale()[1] return codecs.open(filepath, flag, encoding)"
            },
            {
                "url": 2235,
                "code": "def get_encoding(binary): try: from chardet import detect except ImportError: LOGGER.error(\"Please install the 'chardet' module\") sys.exit(1) encoding = detect(binary).get('encoding') return 'iso-8859-1' if encoding == 'CP949' else encoding"
            },
            {
                "url": 4159,
                "code": "def _file_type(self, field): type = mimetypes.guess_type(self._files[field])[0] return type.encode(\"utf-8\") if isinstance(type, unicode) else str(type)"
            },
            {
                "url": 1033,
                "code": "def download(url, encoding='utf-8'): import requests response = requests.get(url) response.encoding = encoding return response.text"
            },
            {
                "url": 2538,
                "code": "def to_string(s, encoding='utf-8'): if six.PY2: return s.encode(encoding) if isinstance(s, bytes): return s.decode(encoding) return s"
            },
            {
                "url": 3426,
                "code": "def _open_text(fname, **kwargs): if PY3: kwargs.setdefault('encoding', ENCODING) kwargs.setdefault('errors', ENCODING_ERRS) return open(fname, \"rt\", **kwargs)"
            },
            {
                "url": 4691,
                "code": "def write_to_file(file_path, contents, encoding=\"utf-8\"): with codecs.open(file_path, \"w\", encoding) as f: f.write(contents)"
            },
            {
                "url": 1799,
                "code": "def read(filename): return codecs.open(os.path.join(__DIR__, filename), 'r').read()"
            },
            {
                "url": 3326,
                "code": "def bytes_to_str(s, encoding='utf-8'): if six.PY3 and isinstance(s, bytes): return s.decode(encoding) return s"
            }
        ],
        "url": 4685
    },
    {
        "nl_input": "python connect to aws rds",
        "code_input": [
            {
                "url": 5229,
                "code": "def connect_rds(aws_access_key_id=None, aws_secret_access_key=None, **kwargs): from boto.rds import RDSConnection return RDSConnection(aws_access_key_id, aws_secret_access_key, **kwargs)"
            },
            {
                "url": 4020,
                "code": "def s3_connect(bucket_name, s3_access_key_id, s3_secret_key): conn = connect_s3(s3_access_key_id, s3_secret_key) try: return conn.get_bucket(bucket_name) except S3ResponseError as e: if e.status == 403: raise Exception(\"Bad Amazon S3 credentials.\") raise"
            },
            {
                "url": 3980,
                "code": "def list_rds(region, filter_by_kwargs): conn = boto.rds.connect_to_region(region) instances = conn.get_all_dbinstances() return lookup(instances, filter_by=filter_by_kwargs)"
            },
            {
                "url": 2631,
                "code": "def create_aws_lambda(ctx, bucket, region_name, aws_access_key_id, aws_secret_access_key): from canari.commands.create_aws_lambda import create_aws_lambda create_aws_lambda(ctx.project, bucket, region_name, aws_access_key_id, aws_secret_access_key)"
            },
            {
                "url": 4711,
                "code": "def connect(self): self.client = redis.Redis( host=self.host, port=self.port, password=self.password)"
            },
            {
                "url": 24,
                "code": "def connect_mysql(host, port, user, password, database): return pymysql.connect( host=host, port=port, user=user, passwd=password, db=database )"
            },
            {
                "url": 2637,
                "code": "def get_boto_session( region, aws_access_key_id=None, aws_secret_access_key=None, aws_session_token=None ): return boto3.session.Session( region_name=region, aws_secret_access_key=aws_secret_access_key, aws_access_key_id=aws_access_key_id, aws_session_token=aws_session_token )"
            },
            {
                "url": 5420,
                "code": "def get_connection(self, host, port, db): return redis.StrictRedis( host=host, port=port, db=db, decode_responses=True )"
            },
            {
                "url": 2168,
                "code": "def __connect(): global redis_instance if use_tcp_socket: redis_instance = redis.StrictRedis(host=hostname, port=port) else: redis_instance = redis.StrictRedis(unix_socket_path=unix_socket)"
            },
            {
                "url": 5897,
                "code": "def connect_to_database_odbc_access(self, dsn: str, autocommit: bool = True) -> None: self.connect(engine=ENGINE_ACCESS, interface=INTERFACE_ODBC, dsn=dsn, autocommit=autocommit)"
            },
            {
                "url": 1266,
                "code": "def get_pg_connection(host, user, port, password, database, ssl={}): return psycopg2.connect(host=host, user=user, port=port, password=password, dbname=database, sslmode=ssl.get('sslmode', None), sslcert=ssl.get('sslcert', None), sslkey=ssl.get('sslkey', None), sslrootcert=ssl.get('sslrootcert', None), )"
            },
            {
                "url": 80,
                "code": "def _aws_get_instance_by_tag(region, name, tag, raw): client = boto3.session.Session().client('ec2', region) matching_reservations = client.describe_instances(Filters=[{'Name': tag, 'Values': [name]}]).get('Reservations', []) instances = [] [[instances.append(_aws_instance_from_dict(region, instance, raw)) # pylint: disable=expression-not-assigned for instance in reservation.get('Instances')] for reservation in matching_reservations if reservation] return instances"
            },
            {
                "url": 2697,
                "code": "def get_conn(self): conn = self.get_connection(self.cloudant_conn_id) self._validate_connection(conn) cloudant_session = cloudant(user=conn.login, passwd=conn.password, account=conn.host) return cloudant_session"
            },
            {
                "url": 2733,
                "code": "def connect(*args, **kwargs): kwargs['cursor_factory'] = TraceCursor conn = pg_connect(*args, **kwargs) return conn"
            },
            {
                "url": 5095,
                "code": "def _connect(self, servers): self._do_connect(servers.split(' ')) self._verify_connection(verbose=True)"
            }
        ],
        "url": 5229
    },
    {
        "nl_input": "python cv2 check if image is empty",
        "code_input": [
            {
                "url": 369,
                "code": "def imdecode(image_path): import os assert os.path.exists(image_path), image_path + ' not found' im = cv2.imread(image_path) return im"
            },
            {
                "url": 2547,
                "code": "def url_to_image(url, flag=cv2.IMREAD_COLOR): resp = urlopen(url) image = np.asarray(bytearray(resp.read()), dtype=\"uint8\") image = cv2.imdecode(image, flag) return image"
            },
            {
                "url": 188,
                "code": "def is_image_file_valid(file_path_name): # Image.verify is only implemented for PNG images, and it only verifies # the CRC checksum in the image. The only way to check from within # Pillow is to load the image in a try/except and check the error. If # as much info as possible is from the image is needed, # ``ImageFile.LOAD_TRUNCATED_IMAGES=True`` needs to bet set and it # will attempt to parse as much as possible. try: with Image.open(file_path_name) as image: image.load() except IOError: return False return True"
            },
            {
                "url": 4647,
                "code": "def read_image(filepath): im_bytes = tf.io.read_file(filepath) im = tf.image.decode_image(im_bytes, channels=CHANNELS) im = tf.image.convert_image_dtype(im, tf.float32) return im"
            },
            {
                "url": 872,
                "code": "def read_img(path): img = cv2.resize(cv2.imread(path, 0), (80, 30)).astype(np.float32) / 255 img = np.expand_dims(img.transpose(1, 0), 0) return img"
            },
            {
                "url": 1871,
                "code": "def url_to_image(url): r = requests.get(url) image = StringIO(r.content) return image"
            },
            {
                "url": 4799,
                "code": "def clearImg(self): self.img.setImage(np.array([[0]])) self.img.image = None"
            },
            {
                "url": 4784,
                "code": "def get_img_data(f, maxsize = (1200, 850), first = False): img = Image.open(f) img.thumbnail(maxsize) if first: # tkinter is inactive the first time bio = io.BytesIO() img.save(bio, format = \"PNG\") del img return bio.getvalue() return ImageTk.PhotoImage(img)"
            },
            {
                "url": 2948,
                "code": "def is_empty(self): if(((self.channels == []) and (not self.shape == (0, 0))) or ((not self.channels == []) and (self.shape == (0, 0)))): raise RuntimeError(\"Channels-shape mismatch.\") return self.channels == [] and self.shape == (0, 0)"
            },
            {
                "url": 2390,
                "code": "def _is_image_sequenced(image): try: image.seek(1) image.seek(0) result = True except EOFError: result = False return result"
            },
            {
                "url": 3323,
                "code": "def isemptyfile(filepath): exists = os.path.exists(safepath(filepath)) if exists: filesize = os.path.getsize(safepath(filepath)) return filesize == 0 else: return False"
            },
            {
                "url": 1089,
                "code": "def numpy(self): # load GDCM's image reading functionality image_reader = gdcm.ImageReader() image_reader.SetFileName(self.fname) if not image_reader.Read(): raise IOError(\"Could not read DICOM image\") pixel_array = self._gdcm_to_numpy(image_reader.GetImage()) return pixel_array"
            },
            {
                "url": 2937,
                "code": "def clear(self): self._imgobj = None try: # See if there is an image on the canvas self.canvas.delete_object_by_tag(self._canvas_img_tag) self.redraw() except KeyError: pass"
            },
            {
                "url": 6050,
                "code": "def _width_is_big_enough(image, width): if width > image.size[0]: raise ImageSizeError(image.size[0], width)"
            },
            {
                "url": 2978,
                "code": "def check_color(cls, raw_image): # sum(img.convert(\"L\").getextrema()) in (0, 2) extrema = raw_image.convert(\"L\").getextrema() if extrema == (255, 255): # all white raise cls.MonoImageException"
            }
        ],
        "url": 2948
    },
    {
        "nl_input": "how to hide a window using a button in python",
        "code_input": [
            {
                "url": 2791,
                "code": "def reject(self): if self.hideWindow(): self.hideWindow().show() self.close() self.deleteLater()"
            },
            {
                "url": 3119,
                "code": "def hide(self): if not HidePrevention(self.window).may_hide(): return self.hidden = True self.get_widget('window-root').unstick() self.window.hide()"
            },
            {
                "url": 3270,
                "code": "def hide(self): self.tk.withdraw() self._visible = False if self._modal: self.tk.grab_release()"
            },
            {
                "url": 999,
                "code": "def alert(text='', title='', button=OK_TEXT, root=None, timeout=None): assert TKINTER_IMPORT_SUCCEEDED, 'Tkinter is required for pymsgbox' return _buttonbox(msg=text, title=title, choices=[str(button)], root=root, timeout=timeout)"
            },
            {
                "url": 1192,
                "code": "def stop_button_click_handler(self): self.stop_button.setDisabled(True) # Interrupt computations or stop debugging if not self.shellwidget._reading: self.interrupt_kernel() else: self.shellwidget.write_to_stdin('exit')"
            },
            {
                "url": 141,
                "code": "def closing_plugin(self, cancelable=False): self.dialog_manager.close_all() self.shell.exit_interpreter() return True"
            },
            {
                "url": 5878,
                "code": "def SwitchToThisWindow(handle: int) -> None: ctypes.windll.user32.SwitchToThisWindow(ctypes.c_void_p(handle), 1)"
            },
            {
                "url": 4200,
                "code": "def closeEvent(self, event): logger.debug(\"closeEvent\") self.argosApplication.saveSettingsIfNeeded() self.finalize() self.argosApplication.removeMainWindow(self) event.accept() logger.debug(\"closeEvent accepted\")"
            },
            {
                "url": 786,
                "code": "def raise_figure_window(f=0): if _fun.is_a_number(f): f = _pylab.figure(f) f.canvas.manager.window.raise_()"
            },
            {
                "url": 859,
                "code": "def quit(self): self.script.LOG.warn(\"Abort due to user choice!\") sys.exit(self.QUIT_RC)"
            },
            {
                "url": 4694,
                "code": "def hidden_cursor(): if sys.stdout.isatty(): _LOGGER.debug('Hiding cursor.') print('\\x1B[?25l', end='') sys.stdout.flush() try: yield finally: if sys.stdout.isatty(): _LOGGER.debug('Showing cursor.') print('\\n\\x1B[?25h', end='') sys.stdout.flush()"
            },
            {
                "url": 4872,
                "code": "def set_attached_console_visible(state): flag = {True: SW_SHOW, False: SW_HIDE} return bool(ShowWindow(console_window_handle, flag[state]))"
            },
            {
                "url": 142,
                "code": "def test(): from spyder.utils.qthelpers import qapplication app = qapplication() dlg = ProjectDialog(None) dlg.show() sys.exit(app.exec_())"
            },
            {
                "url": 2722,
                "code": "def quit(self): logger.debug(\"ArgosApplication.quit called\") assert len(self.mainWindows) == 0, \\ \"Bug: still {} windows present at application quit!\".format(len(self.mainWindows)) self.qApplication.quit()"
            },
            {
                "url": 1341,
                "code": "def close_other_windows(self): main_window_handle = self.current_window_handle for window_handle in self.window_handles: if window_handle == main_window_handle: continue self.switch_to_window(window_handle) self.close() self.switch_to_window(main_window_handle)"
            }
        ],
        "url": 3119
    },
    {
        "nl_input": "python marshmallow validation schema from parent",
        "code_input": [
            {
                "url": 6156,
                "code": "def validate(request: Union[Dict, List], schema: dict) -> Union[Dict, List]: jsonschema_validate(request, schema) return request"
            },
            {
                "url": 687,
                "code": "def validate(raw_schema, target=None, **kwargs): schema = schema_validator(raw_schema, **kwargs) if target is not None: validate_object(target, schema=schema, **kwargs)"
            },
            {
                "url": 4707,
                "code": "def validate(schema, data, owner=None): schema._validate(data=data, owner=owner)"
            },
            {
                "url": 5004,
                "code": "def _validate(data, schema, ac_schema_safe=True, **options): try: jsonschema.validate(data, schema, **options) except (jsonschema.ValidationError, jsonschema.SchemaError, Exception) as exc: if ac_schema_safe: return (False, str(exc)) # Validation was failed. raise return (True, '')"
            },
            {
                "url": 1302,
                "code": "def load_schema(schema_path): with open(schema_path, 'r') as schema_file: schema = simplejson.load(schema_file) resolver = RefResolver('', '', schema.get('models', {})) return build_request_to_validator_map(schema, resolver)"
            },
            {
                "url": 1641,
                "code": "def validate(datum, schema, field=None, raise_errors=True): record_type = extract_record_type(schema) result = None validator = VALIDATORS.get(record_type) if validator: result = validator(datum, schema=schema, parent_ns=field, raise_errors=raise_errors) elif record_type in SCHEMA_DEFS: result = validate(datum, schema=SCHEMA_DEFS[record_type], field=field, raise_errors=raise_errors) else: raise UnknownType(record_type) if raise_errors and result is False: raise ValidationError(ValidationErrorData(datum, schema, field)) return result"
            },
            {
                "url": 1646,
                "code": "def SchemaValidate(self, xsd): ret = libxml2mod.xmlTextReaderSchemaValidate(self._o, xsd) return ret"
            },
            {
                "url": 1679,
                "code": "def schemaValidateFile(self, filename, options): ret = libxml2mod.xmlSchemaValidateFile(self._o, filename, options) return ret"
            },
            {
                "url": 5130,
                "code": "def timestamping_validate(data, schema): jsonschema.validate(data, schema) data['timestamp'] = str(time.time())"
            },
            {
                "url": 5530,
                "code": "def main(source): if source is None: click.echo( \"You need to supply a file or url to a schema to a swagger schema, for\" \"the validator to work.\" ) return 1 try: load(source) click.echo(\"Validation passed\") return 0 except ValidationError as e: raise click.ClickException(str(e))"
            },
            {
                "url": 5344,
                "code": "def validate(payload, schema): v = jsonschema.Draft4Validator( schema, format_checker=jsonschema.FormatChecker()) error_list = [] for error in v.iter_errors(payload): message = error.message location = '/' + '/'.join([str(c) for c in error.absolute_path]) error_list.append(message + ' at ' + location) return error_list"
            },
            {
                "url": 3456,
                "code": "def schemaParse(self): ret = libxml2mod.xmlSchemaParse(self._o) if ret is None:raise parserError('xmlSchemaParse() failed') __tmp = Schema(_obj=ret) return __tmp"
            },
            {
                "url": 2866,
                "code": "def get_ref_dict(self, schema): schema_key = make_schema_key(schema) ref_schema = build_reference( \"schema\", self.openapi_version.major, self.refs[schema_key] ) if getattr(schema, \"many\", False): return {\"type\": \"array\", \"items\": ref_schema} return ref_schema"
            },
            {
                "url": 3311,
                "code": "def validate(self, xml_input): parsed_xml = etree.parse(self._handle_xml(xml_input)) try: return self.xmlschema.validate(parsed_xml) except AttributeError: raise CannotValidate('Set XSD to validate the XML')"
            },
            {
                "url": 4106,
                "code": "def handle_request_parsing_error(err, req, schema, error_status_code, error_headers): abort(error_status_code, errors=err.messages)"
            }
        ],
        "url": 4707
    },
    {
        "nl_input": "fillna with string for specific columnin python",
        "code_input": [
            {
                "url": 6165,
                "code": "def fix_missing(df, col, name, na_dict): if is_numeric_dtype(col): if pd.isnull(col).sum() or (name in na_dict): df[name+'_na'] = pd.isnull(col) filler = na_dict[name] if name in na_dict else col.median() df[name] = col.fillna(filler) na_dict[name] = filler return na_dict"
            },
            {
                "url": 1462,
                "code": "def stringify_col(df, col_name): df = df.copy() df[col_name] = df[col_name].fillna(\"\") df[col_name] = df[col_name].astype(str) return df"
            },
            {
                "url": 1801,
                "code": "def fill_nulls(self, col: str): n = [None, \"\"] try: self.df[col] = self.df[col].replace(n, nan) except Exception as e: self.err(e)"
            },
            {
                "url": 4722,
                "code": "def fillna(series_or_arr, missing_value=0.0): if pandas.notnull(missing_value): if isinstance(series_or_arr, (numpy.ndarray)): series_or_arr[numpy.isnan(series_or_arr)] = missing_value else: series_or_arr.fillna(missing_value, inplace=True) return series_or_arr"
            },
            {
                "url": 889,
                "code": "def clean_dataframe(df): df = df.fillna(method='ffill') df = df.fillna(0.0) return df"
            },
            {
                "url": 2333,
                "code": "def clean_df(df, fill_nan=True, drop_empty_columns=True): if fill_nan: df = df.fillna(value=np.nan) if drop_empty_columns: df = df.dropna(axis=1, how='all') return df.sort_index()"
            },
            {
                "url": 1858,
                "code": "def _get_str_columns(sf): return [name for name in sf.column_names() if sf[name].dtype == str]"
            },
            {
                "url": 877,
                "code": "def _drop_str_columns(df): str_columns = filter(lambda pair: pair[1].char == 'S', df._gather_dtypes().items()) str_column_names = list(map(lambda pair: pair[0], str_columns)) return df.drop(str_column_names)"
            },
            {
                "url": 5616,
                "code": "def clean_column_names(df: DataFrame) -> DataFrame: f = df.copy() f.columns = [col.strip() for col in f.columns] return f"
            },
            {
                "url": 292,
                "code": "def _maybe_fill(arr, fill_value=np.nan): if _isna_compat(arr, fill_value): arr.fill(fill_value) return arr"
            },
            {
                "url": 3512,
                "code": "def convert_str_to_datetime(df, *, column: str, format: str): df[column] = pd.to_datetime(df[column], format=format) return df"
            },
            {
                "url": 5659,
                "code": "def is_not_null(df: DataFrame, col_name: str) -> bool: if ( isinstance(df, pd.DataFrame) and col_name in df.columns and df[col_name].notnull().any() ): return True else: return False"
            },
            {
                "url": 4957,
                "code": "def _transform_col(self, x, i): return x.fillna(NAN_INT).map(self.label_encoders[i]).fillna(0)"
            },
            {
                "url": 1437,
                "code": "def strip_columns(tab): for colname in tab.colnames: if tab[colname].dtype.kind in ['S', 'U']: tab[colname] = np.core.defchararray.strip(tab[colname])"
            },
            {
                "url": 4809,
                "code": "def columnclean(column): cleanedcolumn = str(column) \\ .replace('%', 'percent') \\ .replace('(', '_') \\ .replace(')', '') \\ .replace('As', 'Adenosines') \\ .replace('Cs', 'Cytosines') \\ .replace('Gs', 'Guanines') \\ .replace('Ts', 'Thymines') \\ .replace('Ns', 'Unknowns') \\ .replace('index', 'adapterIndex') return cleanedcolumn"
            }
        ],
        "url": 1462
    },
    {
        "nl_input": "how to separate list elements by white space python",
        "code_input": [
            {
                "url": 1146,
                "code": "def split_strings_in_list_retain_spaces(orig_list): temp_list = list() for line in orig_list: line_split = __re.split(r'(\\s+)', line) temp_list.append(line_split) return temp_list"
            },
            {
                "url": 5700,
                "code": "def list_to_str(list, separator=','): list = [str(x) for x in list] return separator.join(list)"
            },
            {
                "url": 5723,
                "code": "def _str_to_list(value, separator): value_list = [item.strip() for item in value.split(separator)] value_list_sanitized = builtins.list(filter(None, value_list)) if len(value_list_sanitized) > 0: return value_list_sanitized else: raise ValueError('Invalid list variable.')"
            },
            {
                "url": 5571,
                "code": "def split(text: str) -> List[str]: return [word for word in SEPARATOR.split(text) if word.strip(' \\t')]"
            },
            {
                "url": 2481,
                "code": "def split_elements(value): l = [v.strip() for v in value.split(',')] if len(l) == 1: l = value.split() return l"
            },
            {
                "url": 2880,
                "code": "def string_to_list(string, sep=\",\", filter_empty=False): return [value.strip() for value in string.split(sep) if (not filter_empty or value)]"
            },
            {
                "url": 3417,
                "code": "def list2string (inlist,delimit=' '): stringlist = [makestr(_) for _ in inlist] return string.join(stringlist,delimit)"
            },
            {
                "url": 3278,
                "code": "def comma_delimited_to_list(list_param): if isinstance(list_param, list): return list_param if isinstance(list_param, str): return list_param.split(',') else: return []"
            },
            {
                "url": 6146,
                "code": "def space_list(line: str) -> List[int]: spaces = [] for idx, car in enumerate(list(line)): if car == \" \": spaces.append(idx) return spaces"
            },
            {
                "url": 5698,
                "code": "def multi_split(s, split): # type: (S, Iterable[S]) -> List[S] for r in split: s = s.replace(r, \"|\") return [i for i in s.split(\"|\") if len(i) > 0]"
            },
            {
                "url": 2418,
                "code": "def _str_to_list(s): _list = s.split(\",\") return list(map(lambda i: i.lstrip(), _list))"
            },
            {
                "url": 372,
                "code": "def split(s): l = [_split(x) for x in _SPLIT_RE.split(s)] return [item for sublist in l for item in sublist]"
            },
            {
                "url": 392,
                "code": "def _split_comma_separated(string): return set(text.strip() for text in string.split(',') if text.strip())"
            },
            {
                "url": 2133,
                "code": "def split_multiline(value): return [element for element in (line.strip() for line in value.split('\\n')) if element]"
            },
            {
                "url": 721,
                "code": "def dedupe_list(l): result = [] for el in l: if el not in result: result.append(el) return result"
            }
        ],
        "url": 1146
    },
    {
        "nl_input": "how to default value in python",
        "code_input": [
            {
                "url": 4324,
                "code": "def set_default(self_,param_name,value): cls = self_.cls setattr(cls,param_name,value)"
            },
            {
                "url": 4190,
                "code": "def param (self, param, kwargs, default_value=False): if param in kwargs: value= kwargs[param] del kwargs[param] else: value= default_value setattr (self, param, value)"
            },
            {
                "url": 1500,
                "code": "def setdefault(obj, field, default): setattr(obj, field, getattr(obj, field, default))"
            },
            {
                "url": 2369,
                "code": "def set_default(self, key, value): k = self._real_key(key.lower()) self._defaults[k] = value"
            },
            {
                "url": 6209,
                "code": "def setdefault(self, name: str, default: Any=None) -> Any: return self.__dict__.setdefault(name, default)"
            },
            {
                "url": 4450,
                "code": "def set_default(self, section, option, default): if not self.parser.has_option(section, option): self.parser.set(section, option, default)"
            },
            {
                "url": 1514,
                "code": "def set_if_empty(self, param, default): if not self.has(param): self.set(param, default)"
            },
            {
                "url": 1432,
                "code": "def arg_default(*args, **kwargs): parser = argparse.ArgumentParser() parser.add_argument(*args, **kwargs) args = vars(parser.parse_args([])) _, default = args.popitem() return default"
            },
            {
                "url": 3846,
                "code": "def setDictDefaults (d, defaults): for key, val in defaults.items(): d.setdefault(key, val) return d"
            },
            {
                "url": 4952,
                "code": "def normalize_field(self, value): if self.default is not None: if value is None or value == '': value = self.default return value"
            },
            {
                "url": 4452,
                "code": "def args_update(self): for key, value in self._config_data.items(): setattr(self._default_args, key, value)"
            },
            {
                "url": 2999,
                "code": "def set_float(val): out = None if not val in (None, ''): try: out = float(val) except ValueError: return None if numpy.isnan(out): out = default return out"
            },
            {
                "url": 5436,
                "code": "def select_default(self): if self._default is None: if not self._set_option_by_index(0): utils.error_format(self.description + \"\\n\" + \"Unable to select default option as the Combo is empty\") else: if not self._set_option(self._default): utils.error_format( self.description + \"\\n\" + \"Unable to select default option as it doesnt exist in the Combo\")"
            },
            {
                "url": 187,
                "code": "def setdefaults(dct, defaults): for key in defaults: dct.setdefault(key, defaults[key]) return dct"
            },
            {
                "url": 1711,
                "code": "def _default(self, obj): return obj.__dict__ if isinstance(obj, JsonObj) else json.JSONDecoder().decode(obj)"
            }
        ],
        "url": 2494
    },
    {
        "nl_input": "python dict keys lowercase",
        "code_input": [
            {
                "url": 5951,
                "code": "def get_case_insensitive_dict_key(d: Dict, k: str) -> Optional[str]: for key in d.keys(): if k.lower() == key.lower(): return key return None"
            },
            {
                "url": 173,
                "code": "def keys_to_snake_case(camel_case_dict): return dict((to_snake_case(key), value) for (key, value) in camel_case_dict.items())"
            },
            {
                "url": 5588,
                "code": "def lowercase_chars(string: any) -> str: return ''.join([c if c.islower() else '' for c in str(string)])"
            },
            {
                "url": 4719,
                "code": "def dict_keys_without_hyphens(a_dict): return dict( (key.replace('-', '_'), val) for key, val in a_dict.items())"
            },
            {
                "url": 5449,
                "code": "def _keys_to_camel_case(self, obj): return dict((to_camel_case(key), value) for (key, value) in obj.items())"
            },
            {
                "url": 4490,
                "code": "def contains_case_insensitive(adict, akey): for key in adict: if key.lower() == akey.lower(): return True return False"
            },
            {
                "url": 5614,
                "code": "def _lower(string): if not string: return \"\" new_string = [string[0].lower()] for char in string[1:]: if char.isupper(): new_string.append(\"_\") new_string.append(char.lower()) return \"\".join(new_string)"
            },
            {
                "url": 5595,
                "code": "def lower_camel_case_from_underscores(string): components = string.split('_') string = components[0] for component in components[1:]: string += component[0].upper() + component[1:] return string"
            },
            {
                "url": 4677,
                "code": "def camelcase2list(s, lower=False): s = re.findall(r'([A-Z][a-z0-9]+)', s) return [w.lower() for w in s] if lower else s"
            },
            {
                "url": 3244,
                "code": "def camelcase(string): string = re.sub(r\"^[\\-_\\.]\", '', str(string)) if not string: return string return lowercase(string[0]) + re.sub(r\"[\\-_\\.\\s]([a-z])\", lambda matched: uppercase(matched.group(1)), string[1:])"
            },
            {
                "url": 5592,
                "code": "def gen_lower(x: Iterable[str]) -> Generator[str, None, None]: for string in x: yield string.lower()"
            },
            {
                "url": 725,
                "code": "def downcaseTokens(s,l,t): return [ tt.lower() for tt in map(_ustr,t) ]"
            },
            {
                "url": 2392,
                "code": "def __contains__ (self, key): assert isinstance(key, basestring) return dict.__contains__(self, key.lower())"
            },
            {
                "url": 718,
                "code": "def camel_case_from_underscores(string): components = string.split('_') string = '' for component in components: string += component[0].upper() + component[1:] return string"
            },
            {
                "url": 3022,
                "code": "def camel_case(self, snake_case): components = snake_case.split('_') return components[0] + \"\".join(x.title() for x in components[1:])"
            }
        ],
        "url": 173
    },
    {
        "nl_input": "python get index of list values that equal",
        "code_input": [
            {
                "url": 192,
                "code": "def _check_elements_equal(lst): assert isinstance(lst, list), \"Input value must be a list.\" return not lst or lst.count(lst[0]) == len(lst)"
            },
            {
                "url": 2136,
                "code": "def allsame(list_, strict=True): if len(list_) == 0: return True first_item = list_[0] return list_all_eq_to(list_, first_item, strict)"
            },
            {
                "url": 480,
                "code": "def equal(list1, list2): return [item1 == item2 for item1, item2 in broadcast_zip(list1, list2)]"
            },
            {
                "url": 6166,
                "code": "def same(*values): if not values: return True first, rest = values[0], values[1:] return all(value == first for value in rest)"
            },
            {
                "url": 456,
                "code": "def get_list_index(lst, index_or_name): if isinstance(index_or_name, six.integer_types): return index_or_name return lst.index(index_or_name)"
            },
            {
                "url": 1049,
                "code": "def uniquify_list(L): return [e for i, e in enumerate(L) if L.index(e) == i]"
            },
            {
                "url": 5584,
                "code": "def indexes_equal(a: Index, b: Index) -> bool: return str(a) == str(b)"
            },
            {
                "url": 320,
                "code": "def count_list(the_list): count = the_list.count result = [(item, count(item)) for item in set(the_list)] result.sort() return result"
            },
            {
                "url": 2444,
                "code": "def is_in(self, search_list, pair): index = -1 for nr, i in enumerate(search_list): if(np.all(i == pair)): return nr return index"
            },
            {
                "url": 2669,
                "code": "def isin(self, column, compare_list): return [x in compare_list for x in self._data[self._columns.index(column)]]"
            },
            {
                "url": 517,
                "code": "def tuple_search(t, i, v): for e in t: if e[i] == v: return e return None"
            },
            {
                "url": 2435,
                "code": "def __eq__(self, anotherset): if not isinstance(anotherset, LR0ItemSet): raise TypeError if len(self.itemlist) != len(anotherset.itemlist): return False for element in self.itemlist: if element not in anotherset.itemlist: return False return True"
            },
            {
                "url": 3381,
                "code": "def get_closest_index(myList, myNumber): closest_values_index = _np.where(self.time == take_closest(myList, myNumber))[0][0] return closest_values_index"
            },
            {
                "url": 1903,
                "code": "def unique(list): unique = []; [unique.append(x) for x in list if x not in unique] return unique"
            },
            {
                "url": 2928,
                "code": "def filter_list_by_indices(lst, indices): return [x for i, x in enumerate(lst) if i in indices]"
            }
        ],
        "url": 480
    },
    {
        "nl_input": "python requests logging not work",
        "code_input": [
            {
                "url": 3213,
                "code": "def log_request(self, code='-', size='-'): if self.server.logRequests: BaseHTTPServer.BaseHTTPRequestHandler.log_request(self, code, size)"
            },
            {
                "url": 532,
                "code": "def should_skip_logging(func): disabled = strtobool(request.headers.get(\"x-request-nolog\", \"false\")) return disabled or getattr(func, SKIP_LOGGING, False)"
            },
            {
                "url": 2308,
                "code": "def disable_insecure_request_warning(): import requests from requests.packages.urllib3.exceptions import InsecureRequestWarning requests.packages.urllib3.disable_warnings(InsecureRequestWarning)"
            },
            {
                "url": 6053,
                "code": "def _log_response(response): message = u'Received HTTP {0} response: {1}'.format( response.status_code, response.text ) if response.status_code >= 400: # pragma: no cover logger.warning(message) else: logger.debug(message)"
            },
            {
                "url": 5505,
                "code": "def stop_logging(): from . import log logger = logging.getLogger(\"gromacs\") logger.info(\"GromacsWrapper %s STOPPED logging\", get_version()) log.clear_handlers(logger)"
            },
            {
                "url": 754,
                "code": "def logger(message, level=10): logging.getLogger(__name__).log(level, str(message))"
            },
            {
                "url": 3330,
                "code": "def setup_request_sessions(self): self.req_session = requests.Session() self.req_session.headers.update(self.headers)"
            },
            {
                "url": 2301,
                "code": "def requests_request(method, url, **kwargs): session = local_sessions.session response = session.request(method=method, url=url, **kwargs) session.close() return response"
            },
            {
                "url": 5129,
                "code": "def log(self, level, msg=None, *args, **kwargs): return self._log(level, msg, args, kwargs)"
            },
            {
                "url": 4418,
                "code": "def log(logger, level, message): if logger.parent.name != 'root': logger.log(level, message) else: print(message, file=sys.stderr)"
            },
            {
                "url": 3990,
                "code": "def post_ratelimited(protocol, session, url, headers, data, allow_redirects=False, stream=False): thread_id = get_ident() wait = 10 # seconds retry = 0 redirects = 0 # In Python 2, we want this to be a 'str' object so logging doesn't break (all formatting arguments are 'str'). # We activated 'unicode_literals' at the top of this file, so it would be a 'unicode' object unless we convert # to 'str' explicitly. This is a no-op for Python 3. log_msg = str('''\\ Retry: %(retry)s Waited: %(wait)s Timeout: %(timeout)s Session: %(session_id)s Thread: %(thread_id)s Auth type: %(auth)s URL: %(url)s HTTP adapter: %(adapter)s Allow redirects: %(allow_redirects)s Streaming: %(stream)s Response time: %(response_time)s Status code: %(status_code)s Request headers: %(request_headers)s Response headers: %(response_headers)s Request data: %(xml_request)s Response data: %(xml_response)s ''') log_vals = dict( retry=retry, wait=wait, timeout=protocol.TIMEOUT, session_id=session.session_id, thread_id=thread_id, auth=session.auth, url=url, adapter=session.get_adapter(url), allow_redirects=allow_redirects, stream=stream, response_time=None, status_code=None, request_headers=headers, response_headers=None, xml_request=data, xml_response=None, ) try: while True: _back_off_if_needed(protocol.credentials.back_off_until) log.debug('Session %s thread %s: retry %s timeout %s POST\\'ing to %s after %ss wait', session.session_id, thread_id, retry, protocol.TIMEOUT, url, wait) d_start = time_func() # Always create a dummy response for logging purposes, in case we fail in the following r = DummyResponse(url=url, headers={}, request_headers=headers) try: r = session.post(url=url, headers=headers, data=data, allow_redirects=False, timeout=protocol.TIMEOUT, stream=stream) except CONNECTION_ERRORS as e: log.debug('Session %s thread %s: connection error POST\\'ing to %s', session.session_id, thread_id, url) r = DummyResponse(url=url, headers={'TimeoutException': e}, request_headers=headers) finally: log_vals.update( retry=retry, wait=wait, session_id=session.session_id, url=str(r.url), response_time=time_func() - d_start, status_code=r.status_code, request_headers=r.request.headers, response_headers=r.headers, xml_response='[STREAMING]' if stream else r.content, ) log.debug(log_msg, log_vals) if _may_retry_on_error(r, protocol, wait): log.info(\"Session %s thread %s: Connection error on URL %s (code %s). Cool down %s secs\", session.session_id, thread_id, r.url, r.status_code, wait) time.sleep(wait) # Increase delay for every retry retry += 1 wait *= 2 session = protocol.renew_session(session) continue if r.status_code in (301, 302): if stream: r.close() url, redirects = _redirect_or_fail(r, redirects, allow_redirects) continue break except (RateLimitError, RedirectError) as e: log.warning(e.value) protocol.retire_session(session) raise except Exception as e: # Let higher layers handle this. Add full context for better debugging. log.error(str('%s: %s\\n%s'), e.__class__.__name__, str(e), log_msg % log_vals) protocol.retire_session(session) raise if r.status_code == 500 and r.content and is_xml(r.content): # Some genius at Microsoft thinks it's OK to send a valid SOAP response as an HTTP 500 log.debug('Got status code %s but trying to parse content anyway', r.status_code) elif r.status_code != 200: protocol.retire_session(session) try: _raise_response_errors(r, protocol, log_msg, log_vals) # Always raises an exception finally: if stream: r.close() log.debug('Session %s thread %s: Useful response from %s', session.session_id, thread_id, url) return r, session"
            },
            {
                "url": 4313,
                "code": "def set_logging_config(log_level, handlers): logging.basicConfig( format='%(asctime)s %(levelname)s:%(name)s:%(funcName)s: %(message)s', datefmt='%Y-%m-%d %H:%M:%S', level=log_level, handlers=handlers)"
            },
            {
                "url": 2496,
                "code": "def process_request(self, request, response): self.logger.info('Requested: {0} {1} {2}'.format(request.method, request.relative_uri, request.content_type))"
            },
            {
                "url": 5411,
                "code": "def handle_logging(self): configure_logging(self.get_scrapy_options()) # Disable duplicates self.__scrapy_options[\"LOG_ENABLED\"] = False # Now, after log-level is correctly set, lets log them. for msg in self.log_output: if msg[\"level\"] is \"error\": self.log.error(msg[\"msg\"]) elif msg[\"level\"] is \"info\": self.log.info(msg[\"msg\"]) elif msg[\"level\"] is \"debug\": self.log.debug(msg[\"msg\"])"
            },
            {
                "url": 2769,
                "code": "def __enter__(self): self.logger = logging.getLogger('pip.download') self.logger.addFilter(self)"
            }
        ],
        "url": 2496
    },
    {
        "nl_input": "python static files flask",
        "code_input": [
            {
                "url": 4107,
                "code": "def static_url(path, absolute=False): if os.sep != '/': path = '/'.join(path.split(os.sep)) return flask.url_for('static', filename=path, _external=absolute)"
            },
            {
                "url": 427,
                "code": "def serve_static(request, path, insecure=False, **kwargs): # Follow the same logic Django uses for determining access to the # static-serving view. if not django_settings.DEBUG and not insecure: raise ImproperlyConfigured(\"The staticfiles view can only be used in \" \"debug mode or if the --insecure \" \"option of 'runserver' is used\") if not settings.PIPELINE_ENABLED and settings.PIPELINE_COLLECTOR_ENABLED: # Collect only the requested file, in order to serve the result as # fast as possible. This won't interfere with the template tags in any # way, as those will still cause Django to collect all media. default_collector.collect(request, files=[path]) return serve(request, path, document_root=django_settings.STATIC_ROOT, **kwargs)"
            },
            {
                "url": 5290,
                "code": "def get_handler(self, *args, **options): handler = get_internal_wsgi_application() from django.contrib.staticfiles.handlers import StaticFilesHandler return StaticFilesHandler(handler)"
            },
            {
                "url": 6034,
                "code": "def collect_static() -> bool: from django.core.management import execute_from_command_line # from django.conf import settings # if not os.listdir(settings.STATIC_ROOT): wf('Collecting static files... ', False) execute_from_command_line(['./manage.py', 'collectstatic', '-c', '--noinput', '-v0']) wf('[+]\\n') return True"
            },
            {
                "url": 319,
                "code": "def default_static_path(): fdir = os.path.dirname(__file__) return os.path.abspath(os.path.join(fdir, '../assets/'))"
            },
            {
                "url": 426,
                "code": "def is_static(self, filename): if self.staticpaths is None: # We're not using static file support return False for path in self.staticpaths: if filename.startswith(path): return True return False"
            },
            {
                "url": 6225,
                "code": "def run_web(self, flask, host='127.0.0.1', port=5000, **options): # type: (Zsl, str, int, **Any)->None return flask.run( host=flask.config.get('FLASK_HOST', host), port=flask.config.get('FLASK_PORT', port), debug=flask.config.get('DEBUG', False), **options )"
            },
            {
                "url": 1813,
                "code": "def staticdir(): root = os.path.abspath(os.path.dirname(__file__)) return os.path.join(root, \"static\")"
            },
            {
                "url": 6251,
                "code": "def compatible_staticpath(path): if VERSION >= (1, 10): # Since Django 1.10, forms.Media automatically invoke static # lazily on the path if it is relative. return path try: # >= 1.4 from django.templatetags.static import static return static(path) except ImportError: pass try: # >= 1.3 return '%s/%s' % (settings.STATIC_URL.rstrip('/'), path) except AttributeError: pass try: return '%s/%s' % (settings.PAGEDOWN_URL.rstrip('/'), path) except AttributeError: pass return '%s/%s' % (settings.MEDIA_URL.rstrip('/'), path)"
            },
            {
                "url": 2404,
                "code": "def glr_path_static(): return os.path.abspath(os.path.join(os.path.dirname(__file__), '_static'))"
            },
            {
                "url": 35,
                "code": "def generate_swagger_html(swagger_static_root, swagger_json_url): tmpl = _get_template(\"swagger.html\") return tmpl.render( swagger_root=swagger_static_root, swagger_json_url=swagger_json_url )"
            },
            {
                "url": 4539,
                "code": "def static_urls_js(): if apps.is_installed('django.contrib.staticfiles'): from django.contrib.staticfiles.storage import staticfiles_storage static_base_url = staticfiles_storage.base_url else: static_base_url = PrefixNode.handle_simple(\"STATIC_URL\") transpile_base_url = urljoin(static_base_url, 'js/transpile/') return { 'static_base_url': static_base_url, 'transpile_base_url': transpile_base_url, 'version': LAST_RUN['version'] }"
            },
            {
                "url": 4073,
                "code": "def load_files(files): for py_file in files: LOG.debug(\"exec %s\", py_file) execfile(py_file, globals(), locals())"
            },
            {
                "url": 3511,
                "code": "def get_static_url(): path = getattr(settings, 'STATIC_URL', None) if not path: path = getattr(settings, 'MEDIA_URL', None) if not path: path = '/' return path"
            },
            {
                "url": 4017,
                "code": "def serve_dtool_directory(directory, port): os.chdir(directory) server_address = (\"localhost\", port) httpd = DtoolHTTPServer(server_address, DtoolHTTPRequestHandler) httpd.serve_forever()"
            }
        ],
        "url": 2404
    },
    {
        "nl_input": "rest json schema validation python",
        "code_input": [
            {
                "url": 6156,
                "code": "def validate(request: Union[Dict, List], schema: dict) -> Union[Dict, List]: jsonschema_validate(request, schema) return request"
            },
            {
                "url": 5004,
                "code": "def _validate(data, schema, ac_schema_safe=True, **options): try: jsonschema.validate(data, schema, **options) except (jsonschema.ValidationError, jsonschema.SchemaError, Exception) as exc: if ac_schema_safe: return (False, str(exc)) # Validation was failed. raise return (True, '')"
            },
            {
                "url": 687,
                "code": "def validate(raw_schema, target=None, **kwargs): schema = schema_validator(raw_schema, **kwargs) if target is not None: validate_object(target, schema=schema, **kwargs)"
            },
            {
                "url": 4707,
                "code": "def validate(schema, data, owner=None): schema._validate(data=data, owner=owner)"
            },
            {
                "url": 1646,
                "code": "def SchemaValidate(self, xsd): ret = libxml2mod.xmlTextReaderSchemaValidate(self._o, xsd) return ret"
            },
            {
                "url": 5130,
                "code": "def timestamping_validate(data, schema): jsonschema.validate(data, schema) data['timestamp'] = str(time.time())"
            },
            {
                "url": 1302,
                "code": "def load_schema(schema_path): with open(schema_path, 'r') as schema_file: schema = simplejson.load(schema_file) resolver = RefResolver('', '', schema.get('models', {})) return build_request_to_validator_map(schema, resolver)"
            },
            {
                "url": 5344,
                "code": "def validate(payload, schema): v = jsonschema.Draft4Validator( schema, format_checker=jsonschema.FormatChecker()) error_list = [] for error in v.iter_errors(payload): message = error.message location = '/' + '/'.join([str(c) for c in error.absolute_path]) error_list.append(message + ' at ' + location) return error_list"
            },
            {
                "url": 5530,
                "code": "def main(source): if source is None: click.echo( \"You need to supply a file or url to a schema to a swagger schema, for\" \"the validator to work.\" ) return 1 try: load(source) click.echo(\"Validation passed\") return 0 except ValidationError as e: raise click.ClickException(str(e))"
            },
            {
                "url": 1641,
                "code": "def validate(datum, schema, field=None, raise_errors=True): record_type = extract_record_type(schema) result = None validator = VALIDATORS.get(record_type) if validator: result = validator(datum, schema=schema, parent_ns=field, raise_errors=raise_errors) elif record_type in SCHEMA_DEFS: result = validate(datum, schema=SCHEMA_DEFS[record_type], field=field, raise_errors=raise_errors) else: raise UnknownType(record_type) if raise_errors and result is False: raise ValidationError(ValidationErrorData(datum, schema, field)) return result"
            },
            {
                "url": 1679,
                "code": "def schemaValidateFile(self, filename, options): ret = libxml2mod.xmlSchemaValidateFile(self._o, filename, options) return ret"
            },
            {
                "url": 3311,
                "code": "def validate(self, xml_input): parsed_xml = etree.parse(self._handle_xml(xml_input)) try: return self.xmlschema.validate(parsed_xml) except AttributeError: raise CannotValidate('Set XSD to validate the XML')"
            },
            {
                "url": 4381,
                "code": "def is_valid(data): return bool(data) and \\ isinstance(data, dict) and \\ bool(data.get(\"swagger\")) and \\ isinstance(data.get('paths'), dict)"
            },
            {
                "url": 2808,
                "code": "def validate(self): validator = Draft4Validator(self.SCHEMA) if not validator.is_valid(self.config): for err in validator.iter_errors(self.config): LOGGER.error(str(err.message)) validator.validate(self.config)"
            },
            {
                "url": 4995,
                "code": "def _validate_input_data(self, data, request): validator = self._get_input_validator(request) if isinstance(data, (list, tuple)): return map(validator.validate, data) else: return validator.validate(data)"
            }
        ],
        "url": 6156
    },
    {
        "nl_input": "write in bold and read in color of the print mesaage in python",
        "code_input": [
            {
                "url": 1703,
                "code": "def print_with_header(header, message, color, indent=0): print() padding = ' ' * indent print(padding + color + BOLD + header + ENDC + color + message + ENDC)"
            },
            {
                "url": 3152,
                "code": "def print_log(text, *colors): sys.stderr.write(sprint(\"{}: {}\".format(script_name, text), *colors) + \"\\n\")"
            },
            {
                "url": 1026,
                "code": "def cprint(string, fg=None, bg=None, end='\\n', target=sys.stdout): _color_manager.set_color(fg, bg) target.write(string + end) target.flush() # Needed for Python 3.x _color_manager.set_defaults()"
            },
            {
                "url": 752,
                "code": "def print_log(value_color=\"\", value_noncolor=\"\"): HEADER = '\\033[92m' ENDC = '\\033[0m' print(HEADER + value_color + ENDC + str(value_noncolor))"
            },
            {
                "url": 273,
                "code": "def printc(cls, txt, color=colors.red): print(cls.color_txt(txt, color))"
            },
            {
                "url": 5092,
                "code": "def print_message(message=None): kwargs = {'stdout': sys.stdout, 'stderr': sys.stderr, 'shell': True} return subprocess.call('echo \"{0}\"'.format(message or ''), **kwargs)"
            },
            {
                "url": 3339,
                "code": "def print(cls, *args, **kwargs): # pylint: disable=protected-access with _shared._PRINT_LOCK: print(*args, **kwargs) _sys.stdout.flush()"
            },
            {
                "url": 3864,
                "code": "def _print(self, msg, flush=False, end=\"\\n\"): if self._verbose: print2(msg, end=end, flush=flush)"
            },
            {
                "url": 1347,
                "code": "def _write_color_colorama (fp, text, color): foreground, background, style = get_win_color(color) colorama.set_console(foreground=foreground, background=background, style=style) fp.write(text) colorama.reset_console()"
            },
            {
                "url": 4298,
                "code": "def print_failure_message(message): try: import colorama print(colorama.Fore.RED + message + colorama.Fore.RESET, file=sys.stderr) except ImportError: print(message, file=sys.stderr)"
            },
            {
                "url": 1672,
                "code": "def underline(self, msg): return click.style(msg, underline=True) if self.colorize else msg"
            },
            {
                "url": 4701,
                "code": "def err(msg): click.echo(click.style(msg, fg=\"red\", bold=True))"
            },
            {
                "url": 2513,
                "code": "def _write_color_ansi (fp, text, color): fp.write(esc_ansicolor(color)) fp.write(text) fp.write(AnsiReset)"
            },
            {
                "url": 3444,
                "code": "def sprint(text, *colors): return \"\\33[{}m{content}\\33[{}m\".format(\";\".join([str(color) for color in colors]), RESET, content=text) if IS_ANSI_TERMINAL and colors else text"
            },
            {
                "url": 3030,
                "code": "def colorize(string, color, *args, **kwargs): string = string.format(*args, **kwargs) return color + string + colorama.Fore.RESET"
            }
        ],
        "url": 362
    },
    {
        "nl_input": "python type cast to bigint",
        "code_input": [
            {
                "url": 3791,
                "code": "def cast_int(x): try: x = int(x) except ValueError: try: x = x.strip() except AttributeError as e: logger_misc.warn(\"parse_str: AttributeError: String not number or word, {}, {}\".format(x, e)) return x"
            },
            {
                "url": 5603,
                "code": "def try_cast_int(s): try: temp = re.findall('\\d', str(s)) temp = ''.join(temp) return int(temp) except: return s"
            },
            {
                "url": 6171,
                "code": "def convert_to_int(x: Any, default: int = None) -> int: try: return int(x) except (TypeError, ValueError): return default"
            },
            {
                "url": 894,
                "code": "def safe_int_conv(number): try: return int(np.array(number).astype(int, casting='safe')) except TypeError: raise ValueError('cannot safely convert {} to integer'.format(number))"
            },
            {
                "url": 2494,
                "code": "def safe_int(val, default=None): try: val = int(val) except (ValueError, TypeError): val = default return val"
            },
            {
                "url": 5836,
                "code": "def clean_int(x) -> int: try: return int(x) except ValueError: raise forms.ValidationError( \"Cannot convert to integer: {}\".format(repr(x)))"
            },
            {
                "url": 40,
                "code": "def get_number(s, cast=int): import string d = \"\".join(x for x in str(s) if x in string.digits) return cast(d)"
            },
            {
                "url": 4658,
                "code": "def _cast_to_type(self, value): if isinstance(value, str) or value is None: return value return str(value)"
            },
            {
                "url": 4098,
                "code": "def get_typecast_value(self, value, type): if type == entities.Variable.Type.BOOLEAN: return value == 'true' elif type == entities.Variable.Type.INTEGER: return int(value) elif type == entities.Variable.Type.DOUBLE: return float(value) else: return value"
            },
            {
                "url": 1329,
                "code": "def validate_int(value): if value and not isinstance(value, int): try: int(str(value)) except (TypeError, ValueError): raise ValidationError('not a valid number') return value"
            },
            {
                "url": 2509,
                "code": "def convert_value(bind, value): type_name = get_type(bind) try: return typecast.cast(type_name, value) except typecast.ConverterError: return value"
            },
            {
                "url": 2128,
                "code": "def is_integer(obj): if PYTHON3: return isinstance(obj, int) return isinstance(obj, (int, long))"
            },
            {
                "url": 2036,
                "code": "def bin_to_int(string): if isinstance(string, str): return struct.unpack(\"b\", string)[0] else: return struct.unpack(\"b\", bytes([string]))[0]"
            },
            {
                "url": 5893,
                "code": "def hex_to_int(value): if version_info.major >= 3: return int.from_bytes(value, \"big\") return int(value.encode(\"hex\"), 16)"
            },
            {
                "url": 5356,
                "code": "def convert_types(cls, value): if isinstance(value, decimal.Decimal): return float(value) else: return value"
            }
        ],
        "url": 1205
    },
    {
        "nl_input": "converts matrix to pictures by python",
        "code_input": [
            {
                "url": 618,
                "code": "def get_buffer(self, data_np, header, format, output=None): if not have_pil: raise Exception(\"Install PIL to use this method\") image = PILimage.fromarray(data_np) buf = output if buf is None: buf = BytesIO() image.save(buf, format) return buf"
            },
            {
                "url": 2071,
                "code": "def print_matrix(X, decimals=1): for row in np.round(X, decimals=decimals): print(row)"
            },
            {
                "url": 1120,
                "code": "def im2mat(I): return I.reshape((I.shape[0] * I.shape[1], I.shape[2]))"
            },
            {
                "url": 3209,
                "code": "def display_pil_image(im): from IPython.core import display b = BytesIO() im.save(b, format='png') data = b.getvalue() ip_img = display.Image(data=data, format='png', embed=True) return ip_img._repr_png_()"
            },
            {
                "url": 5421,
                "code": "def file_to_png(fp): import PIL.Image # pylint: disable=import-error with io.BytesIO() as dest: PIL.Image.open(fp).save(dest, \"PNG\", optimize=True) return dest.getvalue()"
            },
            {
                "url": 1089,
                "code": "def numpy(self): # load GDCM's image reading functionality image_reader = gdcm.ImageReader() image_reader.SetFileName(self.fname) if not image_reader.Read(): raise IOError(\"Could not read DICOM image\") pixel_array = self._gdcm_to_numpy(image_reader.GetImage()) return pixel_array"
            },
            {
                "url": 1732,
                "code": "def img_encode(arr, **kwargs): sio = BytesIO() imsave(sio, arr, **kwargs) sio.seek(0) img_format = kwargs['format'] if kwargs.get('format') else 'png' img_str = base64.b64encode(sio.getvalue()).decode() return 'data:image/{};base64,{}'.format(img_format, img_str)"
            },
            {
                "url": 126,
                "code": "def convert_array(array): out = io.BytesIO(array) out.seek(0) return np.load(out)"
            },
            {
                "url": 4906,
                "code": "def _convert(self, image, output=None): with Image.open(image) as im: width, height = im.size co = CanvasObjects() co.add(CanvasImg(image, 1.0, w=width, h=height)) return WatermarkDraw(co, tempdir=self.tempdir, pagesize=(width, height)).write(output)"
            },
            {
                "url": 9,
                "code": "def _convert_to_array(array_like, dtype): if isinstance(array_like, bytes): return np.frombuffer(array_like, dtype=dtype) return np.asarray(array_like, dtype=dtype)"
            },
            {
                "url": 1890,
                "code": "def matrix_to_gl(matrix): matrix = np.asanyarray(matrix, dtype=np.float64) if matrix.shape != (4, 4): raise ValueError('matrix must be (4,4)!') # switch to column major and flatten to (16,) column = matrix.T.flatten() # convert to GLfloat glmatrix = (gl.GLfloat * 16)(*column) return glmatrix"
            },
            {
                "url": 4784,
                "code": "def get_img_data(f, maxsize = (1200, 850), first = False): img = Image.open(f) img.thumbnail(maxsize) if first: # tkinter is inactive the first time bio = io.BytesIO() img.save(bio, format = \"PNG\") del img return bio.getvalue() return ImageTk.PhotoImage(img)"
            },
            {
                "url": 1142,
                "code": "def resize_image(self, data, size): from machina.core.compat import PILImage as Image image = Image.open(BytesIO(data)) # Resize! image.thumbnail(size, Image.ANTIALIAS) string = BytesIO() image.save(string, format='PNG') return string.getvalue()"
            },
            {
                "url": 673,
                "code": "def join_images(img_files, out_file): images = [PIL.Image.open(f) for f in img_files] joined = PIL.Image.new( 'RGB', (sum(i.size[0] for i in images), max(i.size[1] for i in images)) ) left = 0 for img in images: joined.paste(im=img, box=(left, 0)) left = left + img.size[0] joined.save(out_file)"
            },
            {
                "url": 1070,
                "code": "def fig2x(figure, format): # Save svg to file like object svg_io io = StringIO() figure.savefig(io, format=format) # Rewind the file like object io.seek(0) data = io.getvalue() io.close() return data"
            }
        ],
        "url": 1120
    },
    {
        "nl_input": "python random selection from function",
        "code_input": [
            {
                "url": 4393,
                "code": "def select_random(engine, table_or_columns, limit=5): s = select(table_or_columns).order_by(func.random()).limit(limit) return engine.execute(s).fetchall()"
            },
            {
                "url": 3733,
                "code": "def random_numbers(n): return ''.join(random.SystemRandom().choice(string.digits) for _ in range(n))"
            },
            {
                "url": 1435,
                "code": "def random_choice(sequence): return random.choice(tuple(sequence) if isinstance(sequence, set) else sequence)"
            },
            {
                "url": 2010,
                "code": "def random_letters(n): return ''.join(random.SystemRandom().choice(string.ascii_letters) for _ in range(n))"
            },
            {
                "url": 4270,
                "code": "def generate_random_string(chars=7): return u\"\".join(random.sample(string.ascii_letters * 2 + string.digits, chars))"
            },
            {
                "url": 4830,
                "code": "def RandomShuffle(a, seed): if seed: np.random.seed(seed) r = a.copy() np.random.shuffle(r) return r,"
            },
            {
                "url": 3763,
                "code": "def gen_random_string(str_len): return ''.join( random.choice(string.ascii_letters + string.digits) for _ in range(str_len))"
            },
            {
                "url": 4669,
                "code": "def new_random_state(seed=None, fully_random=False): if seed is None: if not fully_random: # sample manually a seed instead of just RandomState(), # because the latter one # is way slower. seed = CURRENT_RANDOM_STATE.randint(SEED_MIN_VALUE, SEED_MAX_VALUE, 1)[0] return np.random.RandomState(seed)"
            },
            {
                "url": 1400,
                "code": "def runiform(lower, upper, size=None): return np.random.uniform(lower, upper, size)"
            },
            {
                "url": 3765,
                "code": "def SampleSum(dists, n): pmf = MakePmfFromList(RandomSum(dists) for i in xrange(n)) return pmf"
            },
            {
                "url": 2530,
                "code": "def random_id(size=8, chars=string.ascii_letters + string.digits): return ''.join(random.choice(chars) for _ in range(size))"
            },
            {
                "url": 4569,
                "code": "def random_int(self, min=0, max=9999, step=1): return self.generator.random.randrange(min, max + 1, step)"
            },
            {
                "url": 3764,
                "code": "def uniform_noise(points): return np.random.rand(1) * np.random.uniform(points, 1) \\ + random.sample([2, -2], 1)"
            },
            {
                "url": 276,
                "code": "def random_str(size=10): return ''.join(random.choice(string.ascii_lowercase) for _ in range(size))"
            },
            {
                "url": 2861,
                "code": "def random_id(length): def char(): \"\"\"Generate single random char\"\"\" return random.choice(string.ascii_letters + string.digits) return \"\".join(char() for _ in range(length))"
            }
        ],
        "url": 1398
    },
    {
        "nl_input": "python keep processpool open until tasks complete",
        "code_input": [
            {
                "url": 2623,
                "code": "async def wait_and_quit(loop): from pylp.lib.tasks import running if running: await asyncio.wait(map(lambda runner: runner.future, running))"
            },
            {
                "url": 5005,
                "code": "def wait(self, timeout=None): if not self.__running: raise RuntimeError(\"ThreadPool ain't running\") self.__queue.wait(timeout)"
            },
            {
                "url": 4341,
                "code": "def terminate(self): if self._pool is not None: self._pool.terminate() self._pool.join() self._pool = None"
            },
            {
                "url": 1761,
                "code": "def parallel(processes, threads): pool = multithread(threads) pool.map(run_process, processes) pool.close() pool.join()"
            },
            {
                "url": 550,
                "code": "def finish(): out.warn(\"Interrupted!\") for t in threads: t.stop() jobs.clear() out.warn(\"Waiting for download threads to finish.\")"
            },
            {
                "url": 3385,
                "code": "def run(*tasks: Awaitable, loop: asyncio.AbstractEventLoop=asyncio.get_event_loop()): futures = [asyncio.ensure_future(task, loop=loop) for task in tasks] return loop.run_until_complete(asyncio.gather(*futures))"
            },
            {
                "url": 4005,
                "code": "def wait_and_join(self, task): while not task.has_started: time.sleep(self._polling_time) task.thread.join()"
            },
            {
                "url": 1997,
                "code": "async def terminate(self): self.proc.terminate() await asyncio.wait_for(self.proc.wait(), self.kill_delay) if self.proc.returncode is None: self.proc.kill() await self.proc.wait() await super().terminate()"
            },
            {
                "url": 2468,
                "code": "def stop_process(self): self._process.terminate() if not self._process.waitForFinished(100): self._process.kill()"
            },
            {
                "url": 5728,
                "code": "async def async_run(self) -> None: self.main_task = self.loop.create_task(self.main()) await self.main_task"
            },
            {
                "url": 3813,
                "code": "def _run_parallel_process_with_profiling(self, start_path, stop_path, queue, filename): runctx('Engine._run_parallel_process(self, start_path, stop_path, queue)', globals(), locals(), filename)"
            },
            {
                "url": 2942,
                "code": "def wait_until_exit(self): [t.join() for t in self.threads] self.threads = list()"
            },
            {
                "url": 4659,
                "code": "def stop(self, timeout=None): self.stopping = True for process in list(self.processes): self.stop_process(process, timeout=timeout)"
            },
            {
                "url": 785,
                "code": "def terminate(self): for t in self._threads: t.quit() self._thread = [] self._workers = []"
            },
            {
                "url": 5360,
                "code": "def wait_run_in_executor(func, *args, **kwargs): loop = asyncio.get_event_loop() future = loop.run_in_executor(None, functools.partial(func, *args, **kwargs)) yield from asyncio.wait([future]) return future.result()"
            }
        ],
        "url": 5005
    },
    {
        "nl_input": "running a def a specified amount of time python 3",
        "code_input": [
            {
                "url": 4326,
                "code": "def run_test(func, fobj): gc.disable() try: begin = time.time() func(fobj) end = time.time() finally: gc.enable() return end - begin"
            },
            {
                "url": 6136,
                "code": "def timeit (func, log, limit): def newfunc (*args, **kwargs): \"\"\"Execute function and print execution time.\"\"\" t = time.time() res = func(*args, **kwargs) duration = time.time() - t if duration > limit: print(func.__name__, \"took %0.2f seconds\" % duration, file=log) print(args, file=log) print(kwargs, file=log) return res return update_func_meta(newfunc, func)"
            },
            {
                "url": 6005,
                "code": "def run_time() -> timedelta: delta = start_time if start_time else datetime.utcnow() return datetime.utcnow() - delta"
            },
            {
                "url": 1491,
                "code": "def __call__(self, func, *args, **kwargs): return self.run(func, *args, **kwargs)"
            },
            {
                "url": 2582,
                "code": "def time_func(func, name, *args, **kwargs): tic = time.time() out = func(*args, **kwargs) toc = time.time() print('%s took %0.2f seconds' % (name, toc - tic)) return out"
            },
            {
                "url": 717,
                "code": "def time(func, *args, **kwargs): start_time = time_module.time() func(*args, **kwargs) end_time = time_module.time() return end_time - start_time"
            },
            {
                "url": 2007,
                "code": "def speedtest(func, *args, **kwargs): n = 100 start = time.time() for i in range(n): func(*args,**kwargs) end = time.time() return (end-start)/n"
            },
            {
                "url": 959,
                "code": "def timeit(output): b = time.time() yield print output, 'time used: %.3fs' % (time.time()-b)"
            },
            {
                "url": 5785,
                "code": "def timeit(func, *args, **kwargs): start_time = time.time() res = func(*args, **kwargs) timing = time.time() - start_time return res, timing"
            },
            {
                "url": 3208,
                "code": "def timed_call(func, *args, log_level='DEBUG', **kwargs): start = time() r = func(*args, **kwargs) t = time() - start log(log_level, \"Call to '{}' took {:0.6f}s\".format(func.__name__, t)) return r"
            },
            {
                "url": 2206,
                "code": "def test3(): import time p = MVisionProcess() p.start() time.sleep(5) p.stop()"
            },
            {
                "url": 477,
                "code": "def runcode(code): for line in code: print('# '+line) exec(line,globals()) print('# return ans') return ans"
            },
            {
                "url": 5404,
                "code": "def print_result_from_timeit(stmt='pass', setup='pass', number=1000000): units = [\"s\", \"ms\", \"us\", \"ns\"] duration = timeit(stmt, setup, number=int(number)) avg_duration = duration / float(number) thousands = int(math.floor(math.log(avg_duration, 1000))) print(\"Total time: %fs. Average run: %.3f%s.\" % ( duration, avg_duration * (1000 ** -thousands), units[-thousands]))"
            },
            {
                "url": 4367,
                "code": "def run_func(self, func_path, *func_args, **kwargs): if not self.started: raise ValueError('Session not started, use start()') nargout = kwargs.pop('nargout', 1) func_args += tuple(item for pair in zip(kwargs.keys(), kwargs.values()) for item in pair) dname = os.path.dirname(func_path) fname = os.path.basename(func_path) func_name, ext = os.path.splitext(fname) if ext and not ext == '.m': raise TypeError('Need to give path to .m file') return self._json_response(cmd='eval', func_name=func_name, func_args=func_args or '', dname=dname, nargout=nargout)"
            },
            {
                "url": 118,
                "code": "def test(*args): subprocess.call([\"py.test-2.7\"] + list(args)) subprocess.call([\"py.test-3.4\"] + list(args))"
            }
        ],
        "url": 2450
    },
    {
        "nl_input": "python str to dateal time",
        "code_input": [
            {
                "url": 1700,
                "code": "def string_to_date(value): if isinstance(value, datetime.date): return value return dateutil.parser.parse(value).date()"
            },
            {
                "url": 5854,
                "code": "def _parse_date(string: str) -> datetime.date: return datetime.datetime.strptime(string, '%Y-%m-%d').date()"
            },
            {
                "url": 888,
                "code": "def parse_date(s): if isinstance(s, (datetime.datetime, datetime.date)): return s try: from dateutil.parser import parse except ImportError: parse = lambda d: datetime.datetime.strptime(d, \"%Y-%m-%d\") return parse(s)"
            },
            {
                "url": 2523,
                "code": "def _parse(self, date_str, format='%Y-%m-%d'): rv = pd.to_datetime(date_str, format=format) if hasattr(rv, 'to_pydatetime'): rv = rv.to_pydatetime() return rv"
            },
            {
                "url": 5950,
                "code": "def iso_string_to_python_datetime( isostring: str) -> Optional[datetime.datetime]: if not isostring: return None # if you parse() an empty string, you get today's date return dateutil.parser.parse(isostring)"
            },
            {
                "url": 2020,
                "code": "def get_date(date): if type(date) is str: return datetime.strptime(date, '%Y-%m-%d').date() else: return date"
            },
            {
                "url": 107,
                "code": "def parse(self, s): return datetime.datetime.strptime(s, self.date_format).date()"
            },
            {
                "url": 1195,
                "code": "def _validate_date_str(str_): if not str_: return None # Convert to datetime so we can validate it's a real date that exists then # convert it back to the string. try: date = datetime.strptime(str_, DATE_FMT) except ValueError: msg = 'Invalid date format, should be YYYY-MM-DD' raise argparse.ArgumentTypeError(msg) return date.strftime(DATE_FMT)"
            },
            {
                "url": 4288,
                "code": "def stringToDate(fmt=\"%Y-%m-%d\"): import time import datetime def conv_func(s): return datetime.date(*time.strptime(s,fmt)[:3]) return conv_func"
            },
            {
                "url": 886,
                "code": "def deserialize_date(string): try: from dateutil.parser import parse return parse(string).date() except ImportError: return string"
            },
            {
                "url": 154,
                "code": "def _datetime_to_date(arg): _arg = parse(arg) if isinstance(_arg, datetime.datetime): _arg = _arg.date() return _arg"
            },
            {
                "url": 4752,
                "code": "def _date_to_json(value): if isinstance(value, datetime.date): value = value.isoformat() return value"
            },
            {
                "url": 2664,
                "code": "def convert_time_string(date_str): dt, _, _ = date_str.partition(\".\") dt = datetime.strptime(dt, \"%Y-%m-%dT%H:%M:%S\") return dt"
            },
            {
                "url": 2764,
                "code": "def _converter(self, value): if not isinstance(value, datetime.date): raise TypeError('{0} is not valid date'.format(value)) return value"
            },
            {
                "url": 2763,
                "code": "def parse_datetime(dt_str, format): t = time.strptime(dt_str, format) return datetime(t[0], t[1], t[2], t[3], t[4], t[5], t[6], pytz.UTC)"
            }
        ],
        "url": 5606
    },
    {
        "nl_input": "python check if file is executable",
        "code_input": [
            {
                "url": 2939,
                "code": "def is_executable(path): return os.path.isfile(path) and os.access(path, os.X_OK)"
            },
            {
                "url": 2147,
                "code": "def is_exe(fpath): return os.path.isfile(fpath) and os.access(fpath, os.X_OK)"
            },
            {
                "url": 2077,
                "code": "def executable_exists(executable): for directory in os.getenv(\"PATH\").split(\":\"): if os.path.exists(os.path.join(directory, executable)): return True return False"
            },
            {
                "url": 2959,
                "code": "def _file_exists(path, filename): return os.path.isfile(os.path.join(path, filename))"
            },
            {
                "url": 341,
                "code": "def make_executable(script_path): status = os.stat(script_path) os.chmod(script_path, status.st_mode | stat.S_IEXEC)"
            },
            {
                "url": 5808,
                "code": "def valid_file(path: str) -> bool: path = Path(path).expanduser() log.debug(\"checking if %s is a valid file\", path) return path.exists() and path.is_file()"
            },
            {
                "url": 3032,
                "code": "def set_executable(filename): st = os.stat(filename) os.chmod(filename, st.st_mode | stat.S_IEXEC)"
            },
            {
                "url": 2209,
                "code": "def is_file(path): try: return path.expanduser().absolute().is_file() except AttributeError: return os.path.isfile(os.path.abspath(os.path.expanduser(str(path))))"
            },
            {
                "url": 239,
                "code": "def _pip_exists(self): return os.path.isfile(os.path.join(self.path, 'bin', 'pip'))"
            },
            {
                "url": 2931,
                "code": "def is_valid_file(parser, arg): arg = os.path.abspath(arg) if not os.path.exists(arg): parser.error(\"The file %s does not exist!\" % arg) else: return arg"
            },
            {
                "url": 4496,
                "code": "def is_valid_file(parser,arg): if not os.path.exists(arg): parser.error(\"File %s not found\"%arg) else: return arg"
            },
            {
                "url": 5731,
                "code": "def file_exists(fname): try: return fname and os.path.exists(fname) and os.path.getsize(fname) > 0 except OSError: return False"
            },
            {
                "url": 5533,
                "code": "def is_file_exists_error(e): if six.PY3: return isinstance(e, FileExistsError) # noqa: F821 else: return isinstance(e, OSError) and e.errno == 17"
            },
            {
                "url": 2011,
                "code": "def _file_and_exists(val, input_files): return ((os.path.exists(val) and os.path.isfile(val)) or val in input_files)"
            },
            {
                "url": 770,
                "code": "def check_filename(filename): if not isinstance(filename, str): raise TypeError(\"filename must be a string\") if regex.path.linux.filename.search(filename): return True return False"
            }
        ],
        "url": 2939
    },
    {
        "nl_input": "python how to check the queue lenght",
        "code_input": [
            {
                "url": 1955,
                "code": "def check_length(value, length): _length = len(value) if _length != length: raise ValueError(\"length must be %d, not %d\" % \\ (length, _length))"
            },
            {
                "url": 4382,
                "code": "def _check_list_len(row, length): if len(row) != length: raise Exception( \"row length does not match expected length of \" + str(length) + \"\\nrow: \" + str(row))"
            },
            {
                "url": 2303,
                "code": "def check_type_and_size_of_param_list(param_list, expected_length): try: assert isinstance(param_list, list) assert len(param_list) == expected_length except AssertionError: msg = \"param_list must be a list containing {} elements.\" raise ValueError(msg.format(expected_length)) return None"
            },
            {
                "url": 5934,
                "code": "def check_lengths(*arrays): lengths = [len(array) for array in arrays] if len(np.unique(lengths)) > 1: raise ValueError('Inconsistent data lengths: {}'.format(lengths))"
            },
            {
                "url": 2399,
                "code": "def get_type_len(self): # Check types and set type/len self.get_sql() return self.type, self.len, self.len_decimal"
            },
            {
                "url": 192,
                "code": "def _check_elements_equal(lst): assert isinstance(lst, list), \"Input value must be a list.\" return not lst or lst.count(lst[0]) == len(lst)"
            },
            {
                "url": 3224,
                "code": "def split_len(s, length): return [s[i:i+length] for i in range(0, len(s), length)]"
            },
            {
                "url": 5759,
                "code": "def check_consistent_length(*arrays): uniques = np.unique([_num_samples(X) for X in arrays if X is not None]) if len(uniques) > 1: raise ValueError(\"Found arrays with inconsistent numbers of samples: %s\" % str(uniques))"
            },
            {
                "url": 2772,
                "code": "def __len__(self): length = 0 for typ, siz, _ in self.format: length += siz return length"
            },
            {
                "url": 6213,
                "code": "def input_validate_str(string, name, max_len=None, exact_len=None): if type(string) is not str: raise pyhsm.exception.YHSM_WrongInputType(name, str, type(string)) if max_len != None and len(string) > max_len: raise pyhsm.exception.YHSM_InputTooLong(name, max_len, len(string)) if exact_len != None and len(string) != exact_len: raise pyhsm.exception.YHSM_WrongInputSize(name, exact_len, len(string)) return string"
            },
            {
                "url": 5810,
                "code": "def _prm_get_longest_stringsize(string_list): maxlength = 1 for stringar in string_list: if isinstance(stringar, np.ndarray): if stringar.ndim > 0: for string in stringar.ravel(): maxlength = max(len(string), maxlength) else: maxlength = max(len(stringar.tolist()), maxlength) else: maxlength = max(len(stringar), maxlength) # Make the string Col longer than needed in order to allow later on slightly larger strings return int(maxlength * 1.5)"
            },
            {
                "url": 5555,
                "code": "def full(self): return self.maxsize and len(self.list) >= self.maxsize or False"
            },
            {
                "url": 5989,
                "code": "def get_longest_line_length(text): lines = text.split(\"\\n\") length = 0 for i in range(len(lines)): if len(lines[i]) > length: length = len(lines[i]) return length"
            },
            {
                "url": 6205,
                "code": "def pad(a, desiredlength): if len(a) >= desiredlength: return a islist = isinstance(a, list) a = np.array(a) diff = desiredlength - len(a) shape = list(a.shape) shape[0] = diff padded = np.concatenate([a, np.zeros(shape, dtype=a.dtype)]) return padded.tolist() if islist else padded"
            },
            {
                "url": 6070,
                "code": "def _check_limit(self): # First compress self._compress() # Then check the max size if len(self._store) >= self._max_size: self._store.popitem(last=False)"
            }
        ],
        "url": 5555
    },
    {
        "nl_input": "query server objects ldap in python",
        "code_input": [
            {
                "url": 5007,
                "code": "def query(self, base, filterstr, attrlist=None): return self.conn.search_s(base, ldap.SCOPE_SUBTREE, filterstr, attrlist)"
            },
            {
                "url": 5470,
                "code": "def search(self, filterstr, attrlist): return self._paged_search_ext_s(self.settings.BASE, ldap.SCOPE_SUBTREE, filterstr=filterstr, attrlist=attrlist, page_size=self.settings.PAGE_SIZE)"
            },
            {
                "url": 5009,
                "code": "def get_groups(self, username): username = ldap.filter.escape_filter_chars(self._byte_p2(username)) userdn = self._get_user(username, NO_ATTR) searchfilter = self.group_filter_tmpl % { 'userdn': userdn, 'username': username } groups = self._search(searchfilter, NO_ATTR, self.groupdn) ret = [] for entry in groups: ret.append(self._uni(entry[0])) return ret"
            },
            {
                "url": 1234,
                "code": "def members(self, uid=\"*\", objects=False): entries = self.search(uid='*') if objects: return self.memberObjects(entries) result = [] for entry in entries: result.append(entry[1]) return result"
            },
            {
                "url": 3645,
                "code": "def compare(self, dn, attr, value): return self.connection.compare_s(dn, attr, value) == 1"
            },
            {
                "url": 4447,
                "code": "def server(request): return direct_to_template( request, 'server/index.html', {'user_url': getViewURL(request, idPage), 'server_xrds_url': getViewURL(request, idpXrds), })"
            },
            {
                "url": 3848,
                "code": "def value_to_python(self, value): if not isinstance(value, bytes): raise tldap.exceptions.ValidationError(\"should be a bytes\") value = value.decode(\"utf_8\") return value"
            },
            {
                "url": 5460,
                "code": "def _Open(self, hostname, port): try: self._xmlrpc_server = SimpleXMLRPCServer.SimpleXMLRPCServer( (hostname, port), logRequests=False, allow_none=True) except SocketServer.socket.error as exception: logger.warning(( 'Unable to bind a RPC server on {0:s}:{1:d} with error: ' '{2!s}').format(hostname, port, exception)) return False self._xmlrpc_server.register_function( self._callback, self._RPC_FUNCTION_NAME) return True"
            },
            {
                "url": 4052,
                "code": "def _windowsLdmodTargets(target, source, env, for_signature): return _dllTargets(target, source, env, for_signature, 'LDMODULE')"
            },
            {
                "url": 3980,
                "code": "def list_rds(region, filter_by_kwargs): conn = boto.rds.connect_to_region(region) instances = conn.get_all_dbinstances() return lookup(instances, filter_by=filter_by_kwargs)"
            },
            {
                "url": 2374,
                "code": "def cached_query(qs, timeout=None): cache_key = generate_cache_key(qs) return get_cached(cache_key, list, args=(qs,), timeout=None)"
            },
            {
                "url": 3036,
                "code": "def server(port): args = ['python', 'manage.py', 'runserver'] if port: args.append(port) run.main(args)"
            },
            {
                "url": 1291,
                "code": "def test_python_java_rt(): sub_env = {'PYTHONPATH': _build_dir()} log.info('Executing Python unit tests (against Java runtime classes)...') return jpyutil._execute_python_scripts(python_java_rt_tests, env=sub_env)"
            },
            {
                "url": 1815,
                "code": "def filter(self, f, operator=\"and\"): if self._filtered: self._filter_dsl.filter(f) else: self._build_filtered_query(f, operator) return self"
            },
            {
                "url": 3421,
                "code": "def querySQL(self, sql, args=()): if self.debug: result = timeinto(self.queryTimes, self._queryandfetch, sql, args) else: result = self._queryandfetch(sql, args) return result"
            }
        ],
        "url": 5470
    },
    {
        "nl_input": "python docx document section different page",
        "code_input": [
            {
                "url": 2588,
                "code": "def _replace_docstring_header(paragraph): # Replace Markdown headers in docstrings with light headers in bold. paragraph = re.sub(_docstring_header_pattern, r'*\\1*', paragraph, ) paragraph = re.sub(_docstring_parameters_pattern, r'\\n* `\\1` (\\2)\\n', paragraph, ) return paragraph"
            },
            {
                "url": 1938,
                "code": "def fill_document(doc): with doc.create(Section('A section')): doc.append('Some regular text and some ') doc.append(italic('italic text. ')) with doc.create(Subsection('A subsection')): doc.append('Also some crazy characters: $&#{}')"
            },
            {
                "url": 1209,
                "code": "def doc_to_html(doc, doc_format=\"ROBOT\"): from robot.libdocpkg.htmlwriter import DocToHtml return DocToHtml(doc_format)(doc)"
            },
            {
                "url": 242,
                "code": "def copy(doc, dest, src): return Target(doc).copy(dest, src).document"
            },
            {
                "url": 3948,
                "code": "def format_docstring(*args, **kwargs): def decorator(func): func.__doc__ = getdoc(func).format(*args, **kwargs) return func return decorator"
            },
            {
                "url": 215,
                "code": "def see_doc(obj_with_doc): def decorator(fn): fn.__doc__ = obj_with_doc.__doc__ return fn return decorator"
            },
            {
                "url": 5415,
                "code": "def process_docstring(app, what, name, obj, options, lines): result_lines = lines if app.config.napoleon_numpy_docstring: docstring = ExtendedNumpyDocstring( result_lines, app.config, app, what, name, obj, options) result_lines = docstring.lines() if app.config.napoleon_google_docstring: docstring = ExtendedGoogleDocstring( result_lines, app.config, app, what, name, obj, options) result_lines = docstring.lines() lines[:] = result_lines[:]"
            },
            {
                "url": 2033,
                "code": "def main(filename): # Prepare font. font_family = 'arial' font = Font(font_family, bold=True) if not font: raise RuntimeError('No font found for %r' % font_family) # Initialize PDF document on a stream. with Document('output.pdf') as document: # Initialize a new page and begin its context. with document.Page() as ctx: # Open the image to embed. with Image(filename) as embed: # Set the media box for the page to the same as the # image to embed. ctx.box = embed.box # Embed the image. ctx.embed(embed) # Write some text. ctx.add(Text('Hello World', font, size=14, x=100, y=60))"
            },
            {
                "url": 3866,
                "code": "def write_document(doc, fnm): with codecs.open(fnm, 'wb', 'ascii') as f: f.write(json.dumps(doc, indent=2))"
            },
            {
                "url": 1580,
                "code": "def build_docs(directory): os.chdir(directory) process = subprocess.Popen([\"make\", \"html\"], cwd=directory) process.communicate()"
            },
            {
                "url": 5714,
                "code": "def _generate(self): doc_count = 0 for fp in self.all_files: for doc in self._get_docs_for_path(fp): yield doc doc_count += 1 if doc_count >= self.max_docs: return"
            },
            {
                "url": 5390,
                "code": "def get_callable_documentation(the_callable): return wrap_text_in_a_box( title=get_callable_signature_as_string(the_callable), body=(getattr(the_callable, '__doc__') or 'No documentation').replace( '\\n', '\\n\\n'), style='ascii_double')"
            },
            {
                "url": 3514,
                "code": "def format_doc_text(text): return '\\n'.join( textwrap.fill(line, width=99, initial_indent=' ', subsequent_indent=' ') for line in inspect.cleandoc(text).splitlines())"
            },
            {
                "url": 3534,
                "code": "def docannotate(func): func = annotated(func) func.metadata.load_from_doc = True if func.decorated: return func func.decorated = True return decorate(func, _check_and_execute)"
            },
            {
                "url": 2824,
                "code": "def add_element_to_doc(doc, tag, value): element = doc.find(\".//%s\" % tag) if element is None: element = etree.SubElement(doc, tag) element.text = value"
            }
        ],
        "url": 1938
    },
    {
        "nl_input": "write a json object to file python",
        "code_input": [
            {
                "url": 6027,
                "code": "def _write_json(obj, path): # type: (object, str) -> None with open(path, 'w') as f: json.dump(obj, f)"
            },
            {
                "url": 4442,
                "code": "def save_json(object, handle, indent=2): obj_json = json.dumps(object, indent=indent, cls=NumpyJSONEncoder) handle.write(obj_json)"
            },
            {
                "url": 1758,
                "code": "def to_json(obj): i = StringIO.StringIO() w = Writer(i, encoding='UTF-8') w.write_value(obj) return i.getvalue()"
            },
            {
                "url": 1198,
                "code": "def _serialize_json(obj, fp): json.dump(obj, fp, indent=4, default=serialize)"
            },
            {
                "url": 1344,
                "code": "def _write_json(file, contents): with open(file, 'w') as f: return json.dump(contents, f, indent=2, sort_keys=True)"
            },
            {
                "url": 4796,
                "code": "def json_pretty_dump(obj, filename): with open(filename, \"wt\") as fh: json.dump(obj, fh, indent=4, sort_keys=4)"
            },
            {
                "url": 682,
                "code": "def dump_json(obj): return simplejson.dumps(obj, ignore_nan=True, default=json_util.default)"
            },
            {
                "url": 1935,
                "code": "def object_to_json(obj, indent=2): instance_json = json.dumps(obj, indent=indent, ensure_ascii=False, cls=DjangoJSONEncoder) return instance_json"
            },
            {
                "url": 686,
                "code": "def save(self, fname): with open(fname, 'wb') as f: json.dump(self, f)"
            },
            {
                "url": 2465,
                "code": "def toJson(protoObject, indent=None): # Using the internal method because this way we can reformat the JSON js = json_format.MessageToDict(protoObject, False) return json.dumps(js, indent=indent)"
            },
            {
                "url": 2059,
                "code": "def json_dumps(self, obj): return json.dumps(obj, sort_keys=True, indent=4, separators=(',', ': '))"
            },
            {
                "url": 4691,
                "code": "def write_to_file(file_path, contents, encoding=\"utf-8\"): with codecs.open(file_path, \"w\", encoding) as f: f.write(contents)"
            },
            {
                "url": 3866,
                "code": "def write_document(doc, fnm): with codecs.open(fnm, 'wb', 'ascii') as f: f.write(json.dumps(doc, indent=2))"
            },
            {
                "url": 4503,
                "code": "def WriteToPath(obj, filepath): with io.open(filepath, mode=\"w\", encoding=\"utf-8\") as filedesc: WriteToFile(obj, filedesc)"
            },
            {
                "url": 4401,
                "code": "def write_dict_to_yaml(dictionary, path, **kwargs): with open(path, 'w') as f: yaml.dump(dictionary, f, indent=4, **kwargs)"
            }
        ],
        "url": 1198
    },
    {
        "nl_input": "how to compute the minimum value of a tensor in python",
        "code_input": [
            {
                "url": 805,
                "code": "def fn_min(self, a, axis=None): return numpy.nanmin(self._to_ndarray(a), axis=axis)"
            },
            {
                "url": 1571,
                "code": "def min_or_none(val1, val2): return min(val1, val2, key=lambda x: sys.maxint if x is None else x)"
            },
            {
                "url": 1507,
                "code": "def Min(a, axis, keep_dims): return np.amin(a, axis=axis if not isinstance(axis, np.ndarray) else tuple(axis), keepdims=keep_dims),"
            },
            {
                "url": 2979,
                "code": "def findMin(arr): out = np.zeros(shape=arr.shape, dtype=bool) _calcMin(arr, out) return out"
            },
            {
                "url": 5578,
                "code": "def last_location_of_minimum(x): x = np.asarray(x) return 1.0 - np.argmin(x[::-1]) / len(x) if len(x) > 0 else np.NaN"
            },
            {
                "url": 5663,
                "code": "def min(self): res = self._qexec(\"min(%s)\" % self._name) if len(res) > 0: self._min = res[0][0] return self._min"
            },
            {
                "url": 806,
                "code": "def min_values(args): return Interval(min(x.low for x in args), min(x.high for x in args))"
            },
            {
                "url": 344,
                "code": "def index_nearest(value, array): a = (array-value)**2 return index(a.min(), a)"
            },
            {
                "url": 2517,
                "code": "def SegmentMin(a, ids): func = lambda idxs: np.amin(a[idxs], axis=0) return seg_map(func, a, ids),"
            },
            {
                "url": 1983,
                "code": "def argmax(l,f=None): if f: l = [f(i) for i in l] return max(enumerate(l), key=lambda x:x[1])[0]"
            },
            {
                "url": 258,
                "code": "def normalize(x, min_value, max_value): x = (x - min_value) / (max_value - min_value) return clip(x, 0, 1)"
            },
            {
                "url": 5037,
                "code": "def index_nearest(array, value): idx = (np.abs(array-value)).argmin() return idx"
            },
            {
                "url": 2019,
                "code": "def min_max_normalize(img): min_img = img.min() max_img = img.max() return (img - min_img) / (max_img - min_img)"
            },
            {
                "url": 3872,
                "code": "def argmax(attrs, inputs, proto_obj): axis = attrs.get('axis', 0) keepdims = attrs.get('keepdims', 1) argmax_op = symbol.argmax(inputs[0], axis=axis, keepdims=keepdims) # onnx argmax operator always expects int64 as output type cast_attrs = {'dtype': 'int64'} return 'cast', cast_attrs, argmax_op"
            },
            {
                "url": 5605,
                "code": "def rank(tensor: BKTensor) -> int: if isinstance(tensor, np.ndarray): return len(tensor.shape) return len(tensor[0].size())"
            }
        ],
        "url": 5578
    },
    {
        "nl_input": "python unittest how to assert 2 lists are almost equal",
        "code_input": [
            {
                "url": 5851,
                "code": "def assert_equal(first, second, msg_fmt=\"{msg}\"): if isinstance(first, dict) and isinstance(second, dict): assert_dict_equal(first, second, msg_fmt) elif not first == second: msg = \"{!r} != {!r}\".format(first, second) fail(msg_fmt.format(msg=msg, first=first, second=second))"
            },
            {
                "url": 480,
                "code": "def equal(list1, list2): return [item1 == item2 for item1, item2 in broadcast_zip(list1, list2)]"
            },
            {
                "url": 2136,
                "code": "def allsame(list_, strict=True): if len(list_) == 0: return True first_item = list_[0] return list_all_eq_to(list_, first_item, strict)"
            },
            {
                "url": 5224,
                "code": "def assert_looks_like(first, second, msg=None): first = _re.sub(\"\\s+\", \" \", first.strip()) second = _re.sub(\"\\s+\", \" \", second.strip()) if first != second: raise AssertionError(msg or \"%r does not look like %r\" % (first, second))"
            },
            {
                "url": 2085,
                "code": "def _float_almost_equal(float1, float2, places=7): if round(abs(float2 - float1), places) == 0: return True return False"
            },
            {
                "url": 2161,
                "code": "def equal(obj1, obj2): Comparable.log(obj1, obj2, '==') equality = obj1.equality(obj2) Comparable.log(obj1, obj2, '==', result=equality) return equality"
            },
            {
                "url": 869,
                "code": "def is_equal_strings_ignore_case(first, second): if first and second: return first.upper() == second.upper() else: return not (first or second)"
            },
            {
                "url": 2621,
                "code": "def expect_all(a, b): assert all(_a == _b for _a, _b in zip_longest(a, b))"
            },
            {
                "url": 192,
                "code": "def _check_elements_equal(lst): assert isinstance(lst, list), \"Input value must be a list.\" return not lst or lst.count(lst[0]) == len(lst)"
            },
            {
                "url": 1307,
                "code": "def assert_is_not(expected, actual, message=None, extra=None): assert expected is not actual, _assert_fail_message( message, expected, actual, \"is\", extra )"
            },
            {
                "url": 6233,
                "code": "def assert_in(first, second, msg_fmt=\"{msg}\"): if first not in second: msg = \"{!r} not in {!r}\".format(first, second) fail(msg_fmt.format(msg=msg, first=first, second=second))"
            },
            {
                "url": 287,
                "code": "def all_equal(arg1,arg2): if all(hasattr(el, '_infinitely_iterable') for el in [arg1,arg2]): return arg1==arg2 try: return all(a1 == a2 for a1, a2 in zip(arg1, arg2)) except TypeError: return arg1==arg2"
            },
            {
                "url": 5584,
                "code": "def indexes_equal(a: Index, b: Index) -> bool: return str(a) == str(b)"
            },
            {
                "url": 69,
                "code": "def assert_exactly_one_true(bool_list): assert isinstance(bool_list, list) counter = 0 for item in bool_list: if item: counter += 1 return counter == 1"
            },
            {
                "url": 5222,
                "code": "def __call__(self, actual_value, expect): self._expect = expect if self.expected_value is NO_ARG: return self.asserts(actual_value) return self.asserts(actual_value, self.expected_value)"
            }
        ],
        "url": 2621
    },
    {
        "nl_input": "how to check if 2 inputs are equal in python assert equal",
        "code_input": [
            {
                "url": 869,
                "code": "def is_equal_strings_ignore_case(first, second): if first and second: return first.upper() == second.upper() else: return not (first or second)"
            },
            {
                "url": 5851,
                "code": "def assert_equal(first, second, msg_fmt=\"{msg}\"): if isinstance(first, dict) and isinstance(second, dict): assert_dict_equal(first, second, msg_fmt) elif not first == second: msg = \"{!r} != {!r}\".format(first, second) fail(msg_fmt.format(msg=msg, first=first, second=second))"
            },
            {
                "url": 480,
                "code": "def equal(list1, list2): return [item1 == item2 for item1, item2 in broadcast_zip(list1, list2)]"
            },
            {
                "url": 287,
                "code": "def all_equal(arg1,arg2): if all(hasattr(el, '_infinitely_iterable') for el in [arg1,arg2]): return arg1==arg2 try: return all(a1 == a2 for a1, a2 in zip(arg1, arg2)) except TypeError: return arg1==arg2"
            },
            {
                "url": 2161,
                "code": "def equal(obj1, obj2): Comparable.log(obj1, obj2, '==') equality = obj1.equality(obj2) Comparable.log(obj1, obj2, '==', result=equality) return equality"
            },
            {
                "url": 180,
                "code": "def numpy_aware_eq(a, b): if isinstance(a, np.ndarray) or isinstance(b, np.ndarray): return np.array_equal(a, b) if ((isinstance(a, Iterable) and isinstance(b, Iterable)) and not isinstance(a, str) and not isinstance(b, str)): if len(a) != len(b): return False return all(numpy_aware_eq(x, y) for x, y in zip(a, b)) return a == b"
            },
            {
                "url": 192,
                "code": "def _check_elements_equal(lst): assert isinstance(lst, list), \"Input value must be a list.\" return not lst or lst.count(lst[0]) == len(lst)"
            },
            {
                "url": 5584,
                "code": "def indexes_equal(a: Index, b: Index) -> bool: return str(a) == str(b)"
            },
            {
                "url": 2136,
                "code": "def allsame(list_, strict=True): if len(list_) == 0: return True first_item = list_[0] return list_all_eq_to(list_, first_item, strict)"
            },
            {
                "url": 412,
                "code": "def eqstr(a, b): return bool(libspice.eqstr_c(stypes.stringToCharP(a), stypes.stringToCharP(b)))"
            },
            {
                "url": 4840,
                "code": "def equal(x, y): x = BigFloat._implicit_convert(x) y = BigFloat._implicit_convert(y) return mpfr.mpfr_equal_p(x, y)"
            },
            {
                "url": 4037,
                "code": "def compare(string1, string2): if len(string1) != len(string2): return False result = True for c1, c2 in izip(string1, string2): result &= c1 == c2 return result"
            },
            {
                "url": 2085,
                "code": "def _float_almost_equal(float1, float2, places=7): if round(abs(float2 - float1), places) == 0: return True return False"
            },
            {
                "url": 6166,
                "code": "def same(*values): if not values: return True first, rest = values[0], values[1:] return all(value == first for value in rest)"
            },
            {
                "url": 1825,
                "code": "def are_equal_xml(a_xml, b_xml): a_dom = xml.dom.minidom.parseString(a_xml) b_dom = xml.dom.minidom.parseString(b_xml) return are_equal_elements(a_dom.documentElement, b_dom.documentElement)"
            }
        ],
        "url": 2621
    },
    {
        "nl_input": "python loop through proxies request",
        "code_input": [
            {
                "url": 3847,
                "code": "def set_proxy(proxy_url, transport_proxy=None): global proxy, PYPI_URL PYPI_URL = proxy_url proxy = xmlrpc.ServerProxy( proxy_url, transport=RequestsTransport(proxy_url.startswith('https://')), allow_none=True)"
            },
            {
                "url": 5065,
                "code": "def _GetProxies(self): # Detect proxies from the OS environment. result = client_utils.FindProxies() # Also try to connect directly if all proxies fail. result.append(\"\") # Also try all proxies configured in the config system. result.extend(config.CONFIG[\"Client.proxy_servers\"]) return result"
            },
            {
                "url": 2684,
                "code": "def dispatch(self, request, *args, **kwargs): self.request = DownstreamRequest(request) self.args = args self.kwargs = kwargs self._verify_config() self.middleware = MiddlewareSet(self.proxy_middleware) return self.proxy()"
            },
            {
                "url": 2519,
                "code": "def _prepare_proxy(self, conn): conn.set_tunnel(self._proxy_host, self.port, self.proxy_headers) conn.connect()"
            },
            {
                "url": 3973,
                "code": "def setup(self, proxystr='', prompting=True): self.prompting = prompting proxy = self.get_proxy(proxystr) if proxy: proxy_support = urllib2.ProxyHandler({\"http\": proxy, \"ftp\": proxy}) opener = urllib2.build_opener(proxy_support, urllib2.CacheFTPHandler) urllib2.install_opener(opener)"
            },
            {
                "url": 3390,
                "code": "def enable_proxy(self, host, port): self.proxy = [host, _number(port)] self.proxy_enabled = True"
            },
            {
                "url": 3164,
                "code": "async def set_http_proxy(cls, url: typing.Optional[str]): await cls.set_config(\"http_proxy\", \"\" if url is None else url)"
            },
            {
                "url": 577,
                "code": "def Proxy(f): def Wrapped(self, *args): return getattr(self, f)(*args) return Wrapped"
            },
            {
                "url": 5055,
                "code": "def _async_requests(urls): session = FuturesSession(max_workers=30) futures = [ session.get(url) for url in urls ] return [ future.result() for future in futures ]"
            },
            {
                "url": 2301,
                "code": "def requests_request(method, url, **kwargs): session = local_sessions.session response = session.request(method=method, url=url, **kwargs) session.close() return response"
            },
            {
                "url": 3428,
                "code": "def _is_valid_url(self, url): try: r = requests.head(url, proxies=self.proxy_servers) value = r.status_code in [200] except Exception as error: logger.error(str(error)) value = False return value"
            },
            {
                "url": 3330,
                "code": "def setup_request_sessions(self): self.req_session = requests.Session() self.req_session.headers.update(self.headers)"
            },
            {
                "url": 4293,
                "code": "def request(method, url, **kwargs): retries = kwargs.pop('retries', None) with Session(retries=retries) as session: return session.request(method=method, url=url, **kwargs)"
            },
            {
                "url": 1630,
                "code": "def peekiter(iterable): it = iter(iterable) one = next(it) def gen(): \"\"\"Generator that returns first and proxy other items from source\"\"\" yield one while True: yield next(it) return (one, gen())"
            },
            {
                "url": 6007,
                "code": "def _RetryRequest(self, timeout=None, **request_args): while True: try: now = time.time() if not timeout: timeout = config.CONFIG[\"Client.http_timeout\"] result = requests.request(**request_args) # By default requests doesn't raise on HTTP error codes. result.raise_for_status() # Requests does not always raise an exception when an incorrect response # is received. This fixes that behaviour. if not result.ok: raise requests.RequestException(response=result) return time.time() - now, result # Catch any exceptions that dont have a code (e.g. socket.error). except IOError as e: self.consecutive_connection_errors += 1 # Request failed. If we connected successfully before we attempt a few # connections before we determine that it really failed. This might # happen if the front end is loaded and returns a few throttling 500 # messages. if self.active_base_url is not None: # Propagate 406 immediately without retrying, as 406 is a valid # response that indicates a need for enrollment. response = getattr(e, \"response\", None) if getattr(response, \"status_code\", None) == 406: raise if self.consecutive_connection_errors >= self.retry_error_limit: # We tried several times but this really did not work, just fail it. logging.info( \"Too many connection errors to %s, retrying another URL\", self.active_base_url) self.active_base_url = None raise e # Back off hard to allow the front end to recover. logging.debug( \"Unable to connect to frontend. Backing off %s seconds.\", self.error_poll_min) self.Wait(self.error_poll_min) # We never previously connected, maybe the URL/proxy is wrong? Just fail # right away to allow callers to try a different URL. else: raise e"
            }
        ],
        "url": 934
    },
    {
        "nl_input": "python loess with gaussian kernel",
        "code_input": [
            {
                "url": 6200,
                "code": "def kernel(self, spread=1): # TODO: use self.kernel_type to choose function def gaussian(data, pixel): return mvn.pdf(data, mean=pixel, cov=spread) return gaussian"
            },
            {
                "url": 5069,
                "code": "def gaussian_kernel(gstd): Nc = np.ceil(gstd*3)*2+1 x = np.linspace(-(Nc-1)/2,(Nc-1)/2,Nc,endpoint=True) g = np.exp(-.5*((x/gstd)**2)) g = g/np.sum(g) return g"
            },
            {
                "url": 374,
                "code": "def smooth_gaussian(image, sigma=1): return scipy.ndimage.filters.gaussian_filter(image, sigma=sigma, mode=\"nearest\")"
            },
            {
                "url": 3083,
                "code": "def GaussianBlur(X, ksize_width, ksize_height, sigma_x, sigma_y): return image_transform( X, cv2.GaussianBlur, ksize=(ksize_width, ksize_height), sigmaX=sigma_x, sigmaY=sigma_y )"
            },
            {
                "url": 376,
                "code": "def EvalGaussianPdf(x, mu, sigma): return scipy.stats.norm.pdf(x, mu, sigma)"
            },
            {
                "url": 316,
                "code": "def convolve_gaussian_2d(image, gaussian_kernel_1d): result = scipy.ndimage.filters.correlate1d( image, gaussian_kernel_1d, axis=0) result = scipy.ndimage.filters.correlate1d( result, gaussian_kernel_1d, axis=1) return result"
            },
            {
                "url": 5281,
                "code": "def compute_ssim(image1, image2, gaussian_kernel_sigma=1.5, gaussian_kernel_width=11): gaussian_kernel_1d = get_gaussian_kernel( gaussian_kernel_width, gaussian_kernel_sigma) return SSIM(image1, gaussian_kernel_1d).ssim_value(image2)"
            },
            {
                "url": 4556,
                "code": "def EvalPoissonPmf(k, lam): # don't use the scipy function (yet). for lam=0 it returns NaN; # should be 0.0 # return scipy.stats.poisson.pmf(k, lam) return lam ** k * math.exp(-lam) / math.factorial(k)"
            },
            {
                "url": 2935,
                "code": "def Gaussian(x, a, x0, sigma, y0): return a * np.exp(-(x - x0) ** 2 / (2 * sigma ** 2)) + y0"
            },
            {
                "url": 5668,
                "code": "def _gaussian_function(self, datalength: int, values: np.ndarray, height: int, index: int) -> np.ndarray: return height * np.exp(-(1 / (self.spread_number * datalength)) * (values - ((datalength / self.function_number) * index)) ** 2)"
            },
            {
                "url": 1591,
                "code": "def gaussian_variogram_model(m, d): psill = float(m[0]) range_ = float(m[1]) nugget = float(m[2]) return psill * (1. - np.exp(-d**2./(range_*4./7.)**2.)) + nugget"
            },
            {
                "url": 4967,
                "code": "def gaussian_kernel(sigma, truncate=4.0): sigma = float(sigma) radius = int(truncate * sigma + 0.5) x, y = np.mgrid[-radius:radius + 1, -radius:radius + 1] sigma = sigma ** 2 k = 2 * np.exp(-0.5 * (x ** 2 + y ** 2) / sigma) k = k / np.sum(k) return k"
            },
            {
                "url": 4234,
                "code": "def fit_gaussian(samples, ddof=0): if len(samples.shape) == 1: return np.mean(samples), np.std(samples, ddof=ddof) return np.mean(samples, axis=1), np.std(samples, axis=1, ddof=ddof)"
            },
            {
                "url": 1610,
                "code": "def Gaussian(x, mu, sig): return sympy.exp(-(x - mu)**2/(2*sig**2))/sympy.sqrt(2*sympy.pi*sig**2)"
            },
            {
                "url": 4080,
                "code": "def gauss_box_model(x, amplitude=1.0, mean=0.0, stddev=1.0, hpix=0.5): z = (x - mean) / stddev z2 = z + hpix / stddev z1 = z - hpix / stddev return amplitude * (norm.cdf(z2) - norm.cdf(z1))"
            }
        ],
        "url": 741
    },
    {
        "nl_input": "greatest common divisor function in python",
        "code_input": [
            {
                "url": 302,
                "code": "def _gcd_array(X): greatest_common_divisor = 0.0 for x in X: greatest_common_divisor = _gcd(greatest_common_divisor, x) return greatest_common_divisor"
            },
            {
                "url": 5816,
                "code": "def gcd_float(numbers, tol=1e-8): def pair_gcd_tol(a, b): \"\"\"Calculate the Greatest Common Divisor of a and b. Unless b==0, the result will have the same sign as b (so that when b is divided by it, the result comes out positive). \"\"\" while b > tol: a, b = b, a % b return a n = numbers[0] for i in numbers: n = pair_gcd_tol(n, i) return n"
            },
            {
                "url": 4593,
                "code": "def most_even(number, group): count, rest = divmod(number, group) counts = zip_longest([count] * group, [1] * rest, fillvalue=0) chunks = [sum(one) for one in counts] logging.debug('chunks: %s', chunks) return chunks"
            },
            {
                "url": 2004,
                "code": "def _most_common(iterable): data = Counter(iterable) return max(data, key=data.__getitem__)"
            },
            {
                "url": 1277,
                "code": "def generic_div(a, b): logger.debug('Called generic_div({}, {})'.format(a, b)) return a / b"
            },
            {
                "url": 809,
                "code": "def most_common(items): counts = {} for i in items: counts.setdefault(i, 0) counts[i] += 1 return max(six.iteritems(counts), key=operator.itemgetter(1))"
            },
            {
                "url": 6079,
                "code": "def lcm(num1, num2): if num1 > num2: bigger = num1 else: bigger = num2 while True: if bigger % num1 == 0 and bigger % num2 == 0: return bigger bigger += 1"
            },
            {
                "url": 5904,
                "code": "def factorial(n, mod=None): if not (isinstance(n, int) and n >= 0): raise ValueError(\"'n' must be a non-negative integer.\") if mod is not None and not (isinstance(mod, int) and mod > 0): raise ValueError(\"'mod' must be a positive integer\") result = 1 if n == 0: return 1 for i in range(2, n+1): result *= i if mod: result %= mod return result"
            },
            {
                "url": 3816,
                "code": "def _power(ctx, number, power): return decimal_pow(conversions.to_decimal(number, ctx), conversions.to_decimal(power, ctx))"
            },
            {
                "url": 5604,
                "code": "def most_significant_bit(lst: np.ndarray) -> int: return np.argwhere(np.asarray(lst) == 1)[0][0]"
            },
            {
                "url": 812,
                "code": "def mostCommonItem(lst): # This elegant solution from: http://stackoverflow.com/a/1518632/1760218 lst = [l for l in lst if l] if lst: return max(set(lst), key=lst.count) else: return None"
            },
            {
                "url": 3545,
                "code": "def ceil_nearest(x, dx=1): precision = get_sig_digits(dx) return round(math.ceil(float(x) / dx) * dx, precision)"
            },
            {
                "url": 4756,
                "code": "def mod(value, arg): try: return valid_numeric(value) % valid_numeric(arg) except (ValueError, TypeError): try: return value % arg except Exception: return ''"
            },
            {
                "url": 5631,
                "code": "def most_frequent(lst): lst = lst[:] highest_freq = 0 most_freq = None for val in unique(lst): if lst.count(val) > highest_freq: most_freq = val highest_freq = lst.count(val) return most_freq"
            },
            {
                "url": 3609,
                "code": "def find_ge(a, x): i = bs.bisect_left(a, x) if i != len(a): return i raise ValueError"
            }
        ],
        "url": 5816
    },
    {
        "nl_input": "how to clear up memory python",
        "code_input": [
            {
                "url": 145,
                "code": "def delete_all_eggs(self): path_to_delete = os.path.join(self.egg_directory, \"lib\", \"python\") if os.path.exists(path_to_delete): shutil.rmtree(path_to_delete)"
            },
            {
                "url": 2279,
                "code": "def clean(): run('rm -rf build/') run('rm -rf dist/') run('rm -rf puzzle.egg-info') run('find . -name __pycache__ -delete') run('find . -name *.pyc -delete') run('find . -name *.pyo -delete') run('find . -name *~ -delete') log.info('cleaned up')"
            },
            {
                "url": 1950,
                "code": "def wipe(self): keys = list(self.keys()).copy() for key in keys: self.delete(key)"
            },
            {
                "url": 2576,
                "code": "def clean_py_files(path): for dirname, subdirlist, filelist in os.walk(path): for f in filelist: if f.endswith('py'): os.remove(os.path.join(dirname, f))"
            },
            {
                "url": 4126,
                "code": "def clean(dry_run='n'): file_patterns = ['*.pyc', '*.pyo', '*~'] dir_patterns = ['__pycache__'] recursive_pattern_delete(project_paths.root, file_patterns, dir_patterns, dry_run=bool(dry_run.lower() == 'y'))"
            },
            {
                "url": 2894,
                "code": "def cleanup(self): for file in glob.glob(self.basename + '*'): os.unlink(file)"
            },
            {
                "url": 5594,
                "code": "def dictlist_wipe_key(dict_list: Iterable[Dict], key: str) -> None: for d in dict_list: d.pop(key, None)"
            },
            {
                "url": 1808,
                "code": "def clear(): if sys.platform.startswith(\"win\"): call(\"cls\", shell=True) else: call(\"clear\", shell=True)"
            },
            {
                "url": 5786,
                "code": "def clean_all_buckets(self): bucket_keys = self.redis_object.keys(pattern='nearpy_*') if len(bucket_keys) > 0: self.redis_object.delete(*bucket_keys)"
            },
            {
                "url": 3795,
                "code": "def cleanup(self): for instance in self.context: del(instance) for plugin in self.plugins: del(plugin)"
            },
            {
                "url": 6021,
                "code": "def _cleanup(path: str) -> None: if os.path.isdir(path): shutil.rmtree(path)"
            },
            {
                "url": 1680,
                "code": "def clear_globals_reload_modules(self): self.code_array.clear_globals() self.code_array.reload_modules() # Clear result cache self.code_array.result_cache.clear()"
            },
            {
                "url": 1684,
                "code": "def cleanup_lib(self): if not self.using_openmp: #this if statement is necessary because shared libraries that use #OpenMP will core dump when unloaded, this is a well-known issue with OpenMP logging.debug('unloading shared library') _ctypes.dlclose(self.lib._handle)"
            },
            {
                "url": 776,
                "code": "def clean_all(self, args): self.clean_dists(args) self.clean_builds(args) self.clean_download_cache(args)"
            },
            {
                "url": 1015,
                "code": "def rm_keys_from_dict(d, keys): # Loop for each key given for key in keys: # Is the key in the dictionary? if key in d: try: d.pop(key, None) except KeyError: # Not concerned with an error. Keep going. pass return d"
            }
        ],
        "url": 254
    },
    {
        "nl_input": "get eucliedan distance between two vectors python",
        "code_input": [
            {
                "url": 4554,
                "code": "def _euclidean_dist(vector_a, vector_b): dist = 0 for (x, y) in zip(vector_a, vector_b): dist += (x-y)*(x-y) return math.sqrt(dist)"
            },
            {
                "url": 466,
                "code": "def vector_distance(a, b): a = np.array(a) b = np.array(b) return np.linalg.norm(a - b)"
            },
            {
                "url": 2719,
                "code": "def distance(vec1, vec2): if isinstance(vec1, Vector2) \\ and isinstance(vec2, Vector2): dist_vec = vec2 - vec1 return dist_vec.length() else: raise TypeError(\"vec1 and vec2 must be Vector2's\")"
            },
            {
                "url": 300,
                "code": "def euclidean(x, y): result = 0.0 for i in range(x.shape[0]): result += (x[i] - y[i]) ** 2 return np.sqrt(result)"
            },
            {
                "url": 206,
                "code": "def get_distance_between_two_points(self, one, two): dx = one.x - two.x dy = one.y - two.y return math.sqrt(dx * dx + dy * dy)"
            },
            {
                "url": 1828,
                "code": "def _manhattan_distance(vec_a, vec_b): if len(vec_a) != len(vec_b): raise ValueError('len(vec_a) must equal len(vec_b)') return sum(map(lambda a, b: abs(a - b), vec_a, vec_b))"
            },
            {
                "url": 5458,
                "code": "def path_distance(points): vecs = np.diff(points, axis=0)[:, :3] d2 = [np.dot(p, p) for p in vecs] return np.sum(np.sqrt(d2))"
            },
            {
                "url": 299,
                "code": "def _tf_squared_euclidean(X, Y): return tf.reduce_sum(tf.pow(tf.subtract(X, Y), 2), axis=1)"
            },
            {
                "url": 2856,
                "code": "def get_distance_matrix(x): square = nd.sum(x ** 2.0, axis=1, keepdims=True) distance_square = square + square.transpose() - (2.0 * nd.dot(x, x.transpose())) return nd.sqrt(distance_square)"
            },
            {
                "url": 468,
                "code": "def euclidean(c1, c2): diffs = ((i - j) for i, j in zip(c1, c2)) return sum(x * x for x in diffs)"
            },
            {
                "url": 4335,
                "code": "def get_distance(F, x): n = x.shape[0] square = F.sum(x ** 2.0, axis=1, keepdims=True) distance_square = square + square.transpose() - (2.0 * F.dot(x, x.transpose())) # Adding identity to make sqrt work. return F.sqrt(distance_square + F.array(np.identity(n)))"
            },
            {
                "url": 4066,
                "code": "def _distance(coord1, coord2): xdist = coord1[0] - coord2[0] ydist = coord1[1] - coord2[1] return sqrt(xdist*xdist + ydist*ydist)"
            },
            {
                "url": 708,
                "code": "def levenshtein_distance_metric(a, b): return (levenshtein_distance(a, b) / (2.0 * max(len(a), len(b), 1)))"
            },
            {
                "url": 2702,
                "code": "def dist(x1, x2, axis=0): return np.linalg.norm(x2 - x1, axis=axis)"
            },
            {
                "url": 1665,
                "code": "def angle_between_vectors(x, y): dp = dot_product(x, y) if dp == 0: return 0 xm = magnitude(x) ym = magnitude(y) return math.acos(dp / (xm*ym)) * (180. / math.pi)"
            }
        ],
        "url": 466
    },
    {
        "nl_input": "python interactive shell color",
        "code_input": [
            {
                "url": 1347,
                "code": "def _write_color_colorama (fp, text, color): foreground, background, style = get_win_color(color) colorama.set_console(foreground=foreground, background=background, style=style) fp.write(text) colorama.reset_console()"
            },
            {
                "url": 1026,
                "code": "def cprint(string, fg=None, bg=None, end='\\n', target=sys.stdout): _color_manager.set_color(fg, bg) target.write(string + end) target.flush() # Needed for Python 3.x _color_manager.set_defaults()"
            },
            {
                "url": 3030,
                "code": "def colorize(string, color, *args, **kwargs): string = string.format(*args, **kwargs) return color + string + colorama.Fore.RESET"
            },
            {
                "url": 1227,
                "code": "def color_string(color, string): if not color_available: return string return color + string + colorama.Fore.RESET"
            },
            {
                "url": 2513,
                "code": "def _write_color_ansi (fp, text, color): fp.write(esc_ansicolor(color)) fp.write(text) fp.write(AnsiReset)"
            },
            {
                "url": 4997,
                "code": "def set(cls, color): sys.stdout.write(cls.colors.get(color, cls.colors['RESET']))"
            },
            {
                "url": 3444,
                "code": "def sprint(text, *colors): return \"\\33[{}m{content}\\33[{}m\".format(\";\".join([str(color) for color in colors]), RESET, content=text) if IS_ANSI_TERMINAL and colors else text"
            },
            {
                "url": 5905,
                "code": "def ResetConsoleColor() -> bool: if sys.stdout: sys.stdout.flush() bool(ctypes.windll.kernel32.SetConsoleTextAttribute(_ConsoleOutputHandle, _DefaultConsoleColor))"
            },
            {
                "url": 1018,
                "code": "def set_color(self, fg=None, bg=None, intensify=False, target=sys.stdout): raise NotImplementedError"
            },
            {
                "url": 2234,
                "code": "def ansi(color, text): code = COLOR_CODES[color] return '\\033[1;{0}m{1}{2}'.format(code, text, RESET_TERM)"
            },
            {
                "url": 5117,
                "code": "def colorize(txt, fg=None, bg=None): setting = '' setting += _SET_FG.format(fg) if fg else '' setting += _SET_BG.format(bg) if bg else '' return setting + str(txt) + _STYLE_RESET"
            },
            {
                "url": 883,
                "code": "def write_color(string, name, style='normal', when='auto'): write(color(string, name, style, when))"
            },
            {
                "url": 2370,
                "code": "def stringc(text, color): if has_colors: text = str(text) return \"\\033[\"+codeCodes[color]+\"m\"+text+\"\\033[0m\" else: return text"
            },
            {
                "url": 3152,
                "code": "def print_log(text, *colors): sys.stderr.write(sprint(\"{}: {}\".format(script_name, text), *colors) + \"\\n\")"
            },
            {
                "url": 161,
                "code": "def supports_color(): unsupported_platform = (sys.platform in ('win32', 'Pocket PC')) # isatty is not always implemented, #6223. is_a_tty = hasattr(sys.stdout, 'isatty') and sys.stdout.isatty() if unsupported_platform or not is_a_tty: return False return True"
            }
        ],
        "url": 1007
    },
    {
        "nl_input": "passing a range of values python years",
        "code_input": [
            {
                "url": 2789,
                "code": "def growthfromrange(rangegrowth, startdate, enddate): _yrs = (pd.Timestamp(enddate) - pd.Timestamp(startdate)).total_seconds() /\\ dt.timedelta(365.25).total_seconds() return yrlygrowth(rangegrowth, _yrs)"
            },
            {
                "url": 3206,
                "code": "def from_years_range(start_year, end_year): start = datetime.date(start_year, 1 , 1) end = datetime.date(end_year, 12 , 31) return DateRange(start, end)"
            },
            {
                "url": 1844,
                "code": "def daterange(start_date, end_date): for n in range(int((end_date - start_date).days)): yield start_date + timedelta(n)"
            },
            {
                "url": 573,
                "code": "def dates_in_range(start_date, end_date): return [ start_date + timedelta(n) for n in range(int((end_date - start_date).days)) ]"
            },
            {
                "url": 111,
                "code": "def daterange(start, end, delta=timedelta(days=1), lower=Interval.CLOSED, upper=Interval.OPEN): date_interval = Interval(lower=lower, lower_value=start, upper_value=end, upper=upper) current = start if start in date_interval else start + delta while current in date_interval: yield current current = current + delta"
            },
            {
                "url": 2095,
                "code": "def time_range(from_=None, to=None): # todo datetime conversion args = locals() return { k.replace('_', ''): v for k, v in args.items() }"
            },
            {
                "url": 6045,
                "code": "def get_days_in_month(year: int, month: int) -> int: month_range = calendar.monthrange(year, month) return month_range[1]"
            },
            {
                "url": 3405,
                "code": "def range(*args, interval=0): agen = from_iterable.raw(builtins.range(*args)) return time.spaceout.raw(agen, interval) if interval else agen"
            },
            {
                "url": 2756,
                "code": "def move_datetime_year(dt, direction, num_shifts): delta = relativedelta(years=+num_shifts) return _move_datetime(dt, direction, delta)"
            },
            {
                "url": 5670,
                "code": "def year(date): try: fmt = '%m/%d/%Y' return datetime.strptime(date, fmt).timetuple().tm_year except ValueError: return 0"
            },
            {
                "url": 5936,
                "code": "def set_range(self, min_val, max_val): if min_val > max_val: max_val, min_val = min_val, max_val self.values = (((self.values * 1.0 - self.values.min()) / (self.values.max() - self.values.min())) * (max_val - min_val) + min_val)"
            },
            {
                "url": 3123,
                "code": "def get_range(self, start=None, stop=None): return self.from_iterable(self.ranges(start, stop))"
            },
            {
                "url": 68,
                "code": "def _xxrange(self, start, end, step_count): _step = (end - start) / float(step_count) return (start + (i * _step) for i in xrange(int(step_count)))"
            },
            {
                "url": 3820,
                "code": "def date(start, end): stime = date_to_timestamp(start) etime = date_to_timestamp(end) ptime = stime + random.random() * (etime - stime) return datetime.date.fromtimestamp(ptime)"
            },
            {
                "url": 5316,
                "code": "def get_year_start(day=None): day = add_timezone(day or datetime.date.today()) return day.replace(month=1).replace(day=1)"
            }
        ],
        "url": 3206
    },
    {
        "nl_input": "python yaml for each key value",
        "code_input": [
            {
                "url": 1355,
                "code": "def yaml_to_param(obj, name): return from_pyvalue(u\"yaml:%s\" % name, unicode(yaml.dump(obj)))"
            },
            {
                "url": 4401,
                "code": "def write_dict_to_yaml(dictionary, path, **kwargs): with open(path, 'w') as f: yaml.dump(dictionary, f, indent=4, **kwargs)"
            },
            {
                "url": 6141,
                "code": "def load_yaml(file): if hasattr(yaml, \"full_load\"): return yaml.full_load(file) else: return yaml.load(file)"
            },
            {
                "url": 1357,
                "code": "def yaml(self): return ordered_dump(OrderedDict(self), Dumper=yaml.SafeDumper, default_flow_style=False)"
            },
            {
                "url": 1353,
                "code": "def load_yaml_file(file_path: str): with codecs.open(file_path, 'r') as f: return yaml.safe_load(f)"
            },
            {
                "url": 5462,
                "code": "def ParseMany(text): precondition.AssertType(text, Text) if compatibility.PY2: text = text.encode(\"utf-8\") return list(yaml.safe_load_all(text))"
            },
            {
                "url": 735,
                "code": "def _include_yaml(loader, node): return load_yaml(os.path.join(os.path.dirname(loader.name), node.value))"
            },
            {
                "url": 1096,
                "code": "def load_yaml(filepath): with open(filepath) as f: txt = f.read() return yaml.load(txt)"
            },
            {
                "url": 229,
                "code": "def print_yaml(o): print(yaml.dump(o, default_flow_style=False, indent=4, encoding='utf-8'))"
            },
            {
                "url": 4299,
                "code": "def generate_yaml_file(filename, contents): with open(filename, 'w') as file: file.write(yaml.dump(contents, default_flow_style=False))"
            },
            {
                "url": 3965,
                "code": "def Dump(obj): text = yaml.safe_dump(obj, default_flow_style=False, allow_unicode=True) if compatibility.PY2: text = text.decode(\"utf-8\") return text"
            },
            {
                "url": 2566,
                "code": "def ordered_yaml_dump(data, stream=None, Dumper=None, **kwds): Dumper = Dumper or yaml.Dumper class OrderedDumper(Dumper): pass def _dict_representer(dumper, data): return dumper.represent_mapping( yaml.resolver.BaseResolver.DEFAULT_MAPPING_TAG, data.items()) OrderedDumper.add_representer(OrderedDict, _dict_representer) return yaml.dump(data, stream, OrderedDumper, **kwds)"
            },
            {
                "url": 4275,
                "code": "def convert_to_yaml( name, value, indentation, indexOfColon, show_multi_line_character): strings = [] if isinstance(value, list): # special case for single item lists: if len(value) == 1 \\ and isinstance(value[0], str): # value = [\"string\"] should not be converted to # name: # - string # but to \"name: string\" instead value = value[0] elif len(value) == 1 \\ and isinstance(value[0], list) \\ and len(value[0]) == 1 \\ and isinstance(value[0][0], str): # same applies to value = [[\"string\"]] value = value[0][0] if isinstance(value, str): strings.append(\"%s%s%s: %s\" % ( ' ' * indentation, name, ' ' * (indexOfColon-len(name)), indent_multiline_string(value, indentation+4, show_multi_line_character))) elif isinstance(value, list): strings.append(\"%s%s%s: \" % ( ' ' * indentation, name, ' ' * (indexOfColon-len(name)))) for outer in value: # special case for single item sublists if isinstance(outer, list) \\ and len(outer) == 1 \\ and isinstance(outer[0], str): # outer = [\"string\"] should not be converted to # - # - string # but to \"- string\" instead outer = outer[0] if isinstance(outer, str): strings.append(\"%s- %s\" % ( ' ' * (indentation+4), indent_multiline_string( outer, indentation+8, show_multi_line_character))) elif isinstance(outer, list): strings.append(\"%s- \" % (' ' * (indentation+4))) for inner in outer: if isinstance(inner, str): strings.append(\"%s- %s\" % ( ' ' * (indentation+8), indent_multiline_string( inner, indentation+12, show_multi_line_character))) return strings"
            },
            {
                "url": 6002,
                "code": "def load_yaml(yaml_file: str) -> Any: with open(yaml_file, 'r') as file: return ruamel.yaml.load(file, ruamel.yaml.RoundTripLoader)"
            },
            {
                "url": 380,
                "code": "def cli(yamlfile, format, context): print(JSONLDGenerator(yamlfile, format).serialize(context=context))"
            }
        ],
        "url": 1351
    },
    {
        "nl_input": "python test if value is ctypes array",
        "code_input": [
            {
                "url": 1885,
                "code": "def c_array(ctype, values): if isinstance(values, np.ndarray) and values.dtype.itemsize == ctypes.sizeof(ctype): return (ctype * len(values)).from_buffer_copy(values) return (ctype * len(values))(*values)"
            },
            {
                "url": 285,
                "code": "def make_kind_check(python_types, numpy_kind): def check(value): if hasattr(value, 'dtype'): return value.dtype.kind == numpy_kind return isinstance(value, python_types) return check"
            },
            {
                "url": 79,
                "code": "def cint32_array_to_numpy(cptr, length): if isinstance(cptr, ctypes.POINTER(ctypes.c_int32)): return np.fromiter(cptr, dtype=np.int32, count=length) else: raise RuntimeError('Expected int pointer')"
            },
            {
                "url": 84,
                "code": "def cint8_array_to_numpy(cptr, length): if isinstance(cptr, ctypes.POINTER(ctypes.c_int8)): return np.fromiter(cptr, dtype=np.int8, count=length) else: raise RuntimeError('Expected int pointer')"
            },
            {
                "url": 82,
                "code": "def cfloat32_array_to_numpy(cptr, length): if isinstance(cptr, ctypes.POINTER(ctypes.c_float)): return np.fromiter(cptr, dtype=np.float32, count=length) else: raise RuntimeError('Expected float pointer')"
            },
            {
                "url": 64,
                "code": "def cfloat64_array_to_numpy(cptr, length): if isinstance(cptr, ctypes.POINTER(ctypes.c_double)): return np.fromiter(cptr, dtype=np.float64, count=length) else: raise RuntimeError('Expected double pointer')"
            },
            {
                "url": 5116,
                "code": "def is_array(type_): nake_type = remove_alias(type_) nake_type = remove_reference(nake_type) nake_type = remove_cv(nake_type) return isinstance(nake_type, cpptypes.array_t)"
            },
            {
                "url": 2305,
                "code": "def is_float_array(val): return is_np_array(val) and issubclass(val.dtype.type, np.floating)"
            },
            {
                "url": 2675,
                "code": "def is_integer_array(val): return is_np_array(val) and issubclass(val.dtype.type, np.integer)"
            },
            {
                "url": 1870,
                "code": "def _to_array(value): if isinstance(value, (tuple, list)): return array(value) elif isinstance(value, (float, int)): return np.float64(value) else: return value"
            },
            {
                "url": 655,
                "code": "def is_float_array(l): r if isinstance(l, np.ndarray): if l.dtype.kind == 'f': return True return False"
            },
            {
                "url": 530,
                "code": "def _isstring(dtype): return dtype.type == numpy.unicode_ or dtype.type == numpy.string_"
            },
            {
                "url": 9,
                "code": "def _convert_to_array(array_like, dtype): if isinstance(array_like, bytes): return np.frombuffer(array_like, dtype=dtype) return np.asarray(array_like, dtype=dtype)"
            },
            {
                "url": 858,
                "code": "def contains_all(self, array): dtype = getattr(array, 'dtype', None) if dtype is None: dtype = np.result_type(*array) return is_real_dtype(dtype)"
            },
            {
                "url": 1659,
                "code": "def get_ctype(rtype, cfunc, *args): val_p = backend.ffi.new(rtype) args = args + (val_p,) cfunc(*args) return val_p[0]"
            }
        ],
        "url": 5116
    },
    {
        "nl_input": "function return apply async python",
        "code_input": [
            {
                "url": 4964,
                "code": "def apply(self, func, args=(), kwds=dict()): return self.apply_async(func, args, kwds).get()"
            },
            {
                "url": 2776,
                "code": "def runcoro(async_function): future = _asyncio.run_coroutine_threadsafe(async_function, client.loop) result = future.result() return result"
            },
            {
                "url": 112,
                "code": "async def _thread_coro(self, *args): return await self._loop.run_in_executor( self._executor, self._function, *args)"
            },
            {
                "url": 5360,
                "code": "def wait_run_in_executor(func, *args, **kwargs): loop = asyncio.get_event_loop() future = loop.run_in_executor(None, functools.partial(func, *args, **kwargs)) yield from asyncio.wait([future]) return future.result()"
            },
            {
                "url": 2736,
                "code": "def submit(self, fn, *args, **kwargs): corofn = asyncio.coroutine(lambda: fn(*args, **kwargs)) return run_coroutine_threadsafe(corofn(), self.loop)"
            },
            {
                "url": 3694,
                "code": "def apply(self, func, workers=1, job_size=10000): if workers == 1: for lines in self.iter_chunks(job_size): yield func(lines) else: with ProcessPoolExecutor(max_workers=workers) as executor: for result in executor.map(func, self.iter_chunks(job_size)): yield result"
            },
            {
                "url": 3976,
                "code": "def delegate(self, fn, *args, **kwargs): callback = functools.partial(fn, *args, **kwargs) coro = self.loop.run_in_executor(self.subexecutor, callback) return asyncio.ensure_future(coro)"
            },
            {
                "url": 318,
                "code": "def asynchronous(function, event): thread = Thread(target=synchronous, args=(function, event)) thread.daemon = True thread.start()"
            },
            {
                "url": 1943,
                "code": "def action(self): self.return_value = self.function(*self.args, **self.kwargs)"
            },
            {
                "url": 3977,
                "code": "def run_task(func): def _wrapped(*a, **k): loop = asyncio.get_event_loop() return loop.run_until_complete(func(*a, **k)) return _wrapped"
            },
            {
                "url": 5681,
                "code": "def _run_sync(self, method: Callable, *args, **kwargs) -> Any: if self.loop.is_running(): raise RuntimeError(\"Event loop is already running.\") if not self.is_connected: self.loop.run_until_complete(self.connect()) task = asyncio.Task(method(*args, **kwargs), loop=self.loop) result = self.loop.run_until_complete(task) self.loop.run_until_complete(self.quit()) return result"
            },
            {
                "url": 1491,
                "code": "def __call__(self, func, *args, **kwargs): return self.run(func, *args, **kwargs)"
            },
            {
                "url": 5728,
                "code": "async def async_run(self) -> None: self.main_task = self.loop.create_task(self.main()) await self.main_task"
            },
            {
                "url": 914,
                "code": "def asyncStarCmap(asyncCallable, iterable): results = [] yield coopStar(asyncCallable, results.append, iterable) returnValue(results)"
            },
            {
                "url": 3105,
                "code": "def blocking(func, *args, **kwargs): pool = get_io_pool() fut = pool.submit(func, *args, **kwargs) return fut.result()"
            }
        ],
        "url": 4964
    },
    {
        "nl_input": "reload device program code in python",
        "code_input": [
            {
                "url": 3830,
                "code": "def restart_program(): python = sys.executable os.execl(python, python, * sys.argv)"
            },
            {
                "url": 4804,
                "code": "def reload(self, save_config=True): if save_config: self.device.send(\"copy running-config startup-config\") self.device(\"reload\", wait_for_string=\"This command will reboot the system\") self.device.ctrl.sendline(\"y\")"
            },
            {
                "url": 4457,
                "code": "def _load_autoreload_magic(self): from IPython.core.getipython import get_ipython try: get_ipython().run_line_magic('reload_ext', 'autoreload') get_ipython().run_line_magic('autoreload', '2') except Exception: pass"
            },
            {
                "url": 76,
                "code": "def reloader_thread(softexit=False): while RUN_RELOADER: if code_changed(): # force reload if softexit: sys.exit(3) else: os._exit(3) time.sleep(1)"
            },
            {
                "url": 1167,
                "code": "def restart(self, reset=False): # Get start path to use in restart script spyder_start_directory = get_module_path('spyder') restart_script = osp.join(spyder_start_directory, 'app', 'restart.py') # Get any initial argument passed when spyder was started # Note: Variables defined in bootstrap.py and spyder/app/start.py env = os.environ.copy() bootstrap_args = env.pop('SPYDER_BOOTSTRAP_ARGS', None) spyder_args = env.pop('SPYDER_ARGS') # Get current process and python running spyder pid = os.getpid() python = sys.executable # Check if started with bootstrap.py if bootstrap_args is not None: spyder_args = bootstrap_args is_bootstrap = True else: is_bootstrap = False # Pass variables as environment variables (str) to restarter subprocess env['SPYDER_ARGS'] = spyder_args env['SPYDER_PID'] = str(pid) env['SPYDER_IS_BOOTSTRAP'] = str(is_bootstrap) env['SPYDER_RESET'] = str(reset) if DEV: if os.name == 'nt': env['PYTHONPATH'] = ';'.join(sys.path) else: env['PYTHONPATH'] = ':'.join(sys.path) # Build the command and popen arguments depending on the OS if os.name == 'nt': # Hide flashing command prompt startupinfo = subprocess.STARTUPINFO() startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW shell = False else: startupinfo = None shell = True command = '\"{0}\" \"{1}\"' command = command.format(python, restart_script) try: if self.closing(True): subprocess.Popen(command, shell=shell, env=env, startupinfo=startupinfo) self.console.quit() except Exception as error: # If there is an error with subprocess, Spyder should not quit and # the error can be inspected in the internal console print(error) # spyder: test-skip print(command)"
            },
            {
                "url": 5323,
                "code": "def _reload(self, force=False): self._config_map = dict() self._registered_env_keys = set() self.__reload_sources(force) self.__load_environment_keys() self.verify() self._clear_memoization()"
            },
            {
                "url": 6216,
                "code": "def autoreload(self, parameter_s=''): r if parameter_s == '': self._reloader.check(True) elif parameter_s == '0': self._reloader.enabled = False elif parameter_s == '1': self._reloader.check_all = False self._reloader.enabled = True elif parameter_s == '2': self._reloader.check_all = True self._reloader.enabled = True"
            },
            {
                "url": 4073,
                "code": "def load_files(files): for py_file in files: LOG.debug(\"exec %s\", py_file) execfile(py_file, globals(), locals())"
            },
            {
                "url": 2786,
                "code": "def install_rpm_py(): python_path = sys.executable cmd = '{0} install.py'.format(python_path) exit_status = os.system(cmd) if exit_status != 0: raise Exception('Command failed: {0}'.format(cmd))"
            },
            {
                "url": 2324,
                "code": "def setup_detect_python2(): if None in [RTs._rt_py2_detect, RTs._rtp_py2_detect]: RTs._rt_py2_detect = RefactoringTool(py2_detect_fixers) RTs._rtp_py2_detect = RefactoringTool(py2_detect_fixers, {'print_function': True})"
            },
            {
                "url": 2293,
                "code": "def do_restart(self, line): self.application.master.Restart(opendnp3.RestartType.COLD, restart_callback)"
            },
            {
                "url": 1680,
                "code": "def clear_globals_reload_modules(self): self.code_array.clear_globals() self.code_array.reload_modules() # Clear result cache self.code_array.result_cache.clear()"
            },
            {
                "url": 1122,
                "code": "async def restart(request): def wait_and_restart(): log.info('Restarting server') sleep(1) os.system('kill 1') Thread(target=wait_and_restart).start() return web.json_response({\"message\": \"restarting\"})"
            },
            {
                "url": 2899,
                "code": "def update(self, params): dev_info = self.json_state.get('deviceInfo') dev_info.update({k: params[k] for k in params if dev_info.get(k)})"
            },
            {
                "url": 6187,
                "code": "def check_python_version(): # Required due to multiple with statements on one line req_version = (2, 7) cur_version = sys.version_info if cur_version >= req_version: print(\"Python version... %sOK%s (found %s, requires %s)\" % (Bcolors.OKGREEN, Bcolors.ENDC, str(platform.python_version()), str(req_version[0]) + \".\" + str(req_version[1]))) else: print(\"Python version... %sFAIL%s (found %s, requires %s)\" % (Bcolors.FAIL, Bcolors.ENDC, str(cur_version), str(req_version)))"
            }
        ],
        "url": 4804
    },
    {
        "nl_input": "split string into n parts python",
        "code_input": [
            {
                "url": 424,
                "code": "def _split_str(s, n): length = len(s) return [s[i:i + n] for i in range(0, length, n)]"
            },
            {
                "url": 5205,
                "code": "def split_string(text, chars_per_string): return [text[i:i + chars_per_string] for i in range(0, len(text), chars_per_string)]"
            },
            {
                "url": 1545,
                "code": "def _split(string, splitters): part = '' for character in string: if character in splitters: yield part part = '' else: part += character yield part"
            },
            {
                "url": 2914,
                "code": "def split_every(iterable, n): # TODO: Remove this, or make it return a generator. i = iter(iterable) piece = list(islice(i, n)) while piece: yield piece piece = list(islice(i, n))"
            },
            {
                "url": 372,
                "code": "def split(s): l = [_split(x) for x in _SPLIT_RE.split(s)] return [item for sublist in l for item in sublist]"
            },
            {
                "url": 3224,
                "code": "def split_len(s, length): return [s[i:i+length] for i in range(0, len(s), length)]"
            },
            {
                "url": 5698,
                "code": "def multi_split(s, split): # type: (S, Iterable[S]) -> List[S] for r in split: s = s.replace(r, \"|\") return [i for i in s.split(\"|\") if len(i) > 0]"
            },
            {
                "url": 4729,
                "code": "def _chunks(l, n): for i in xrange(0, len(l), n): yield l[i:i+n]"
            },
            {
                "url": 3850,
                "code": "def _split(value): if isinstance(value, str): # iterable, but not meant for splitting return value, value try: invalue, outvalue = value except TypeError: invalue = outvalue = value except ValueError: raise ValueError(\"Only single values and pairs are allowed\") return invalue, outvalue"
            },
            {
                "url": 4340,
                "code": "def schunk(string, size): return [string[i:i+size] for i in range(0, len(string), size)]"
            },
            {
                "url": 3255,
                "code": "def chunks(iterable, n): for i in range(0, len(iterable), n): yield iterable[i:i + n]"
            },
            {
                "url": 4458,
                "code": "def _split_python(python): python = _preprocess(python) if not python: return [] lexer = PythonSplitLexer() lexer.read(python) return lexer.chunks"
            },
            {
                "url": 1292,
                "code": "def split_into_sentences(s): s = re.sub(r\"\\s+\", \" \", s) s = re.sub(r\"[\\\\.\\\\?\\\\!]\", \"\\n\", s) return s.split(\"\\n\")"
            },
            {
                "url": 4930,
                "code": "def splitBy(data, num): return [data[i:i + num] for i in range(0, len(data), num)]"
            },
            {
                "url": 3368,
                "code": "def partition_all(n, iterable): it = iter(iterable) while True: chunk = list(itertools.islice(it, n)) if not chunk: break yield chunk"
            }
        ],
        "url": 424
    },
    {
        "nl_input": "python get object as dict",
        "code_input": [
            {
                "url": 364,
                "code": "def dict_from_object(obj: object): # If object is a dict instance, no need to convert. return (obj if isinstance(obj, dict) else {attr: getattr(obj, attr) for attr in dir(obj) if not attr.startswith('_')})"
            },
            {
                "url": 2202,
                "code": "def get_dict_for_attrs(obj, attrs): data = {} for attr in attrs: data[attr] = getattr(obj, attr) return data"
            },
            {
                "url": 1318,
                "code": "def fromDict(cls, _dict): obj = cls() obj.__dict__.update(_dict) return obj"
            },
            {
                "url": 1849,
                "code": "def object_as_dict(obj): return {c.key: getattr(obj, c.key) for c in inspect(obj).mapper.column_attrs}"
            },
            {
                "url": 1059,
                "code": "def _dict_to_proto(py_dict, proto): dict_json_str = json.dumps(py_dict) return json_format.Parse(dict_json_str, proto)"
            },
            {
                "url": 5529,
                "code": "def _zeep_to_dict(cls, obj): res = serialize_object(obj) res = cls._get_non_empty_dict(res) return res"
            },
            {
                "url": 1480,
                "code": "def to_dict(dictish): if hasattr(dictish, 'iterkeys'): m = dictish.iterkeys elif hasattr(dictish, 'keys'): m = dictish.keys else: raise ValueError(dictish) return dict((k, dictish[k]) for k in m())"
            },
            {
                "url": 191,
                "code": "def dict_to_querystring(dictionary): s = u\"\" for d in dictionary.keys(): s = unicode.format(u\"{0}{1}={2}&\", s, d, dictionary[d]) return s[:-1]"
            },
            {
                "url": 1268,
                "code": "def get_python_dict(scala_map): python_dict = {} keys = get_python_list(scala_map.keys().toList()) for key in keys: python_dict[key] = scala_map.apply(key) return python_dict"
            },
            {
                "url": 650,
                "code": "def conv_dict(self): return dict(integer=self.integer, real=self.real, no_type=self.no_type)"
            },
            {
                "url": 3978,
                "code": "def safe_repr(obj): name = getattr(obj, '__name__', getattr(obj.__class__, '__name__')) if name == 'ndict': name = 'dict' return name or repr(obj)"
            },
            {
                "url": 3775,
                "code": "def as_dict(self): dicts = [x.as_dict for x in self.children] return {'{0} {1}'.format(self.name, self.value): dicts}"
            },
            {
                "url": 1583,
                "code": "def dict_to_numpy_array(d): return fromarrays(d.values(), np.dtype([(str(k), v.dtype) for k, v in d.items()]))"
            },
            {
                "url": 1843,
                "code": "def list2dict(lst): dic = {} for k,v in lst: dic[k] = v return dic"
            },
            {
                "url": 5507,
                "code": "def as_dict(self): attrs = vars(self) return {key: attrs[key] for key in attrs if not key.startswith('_')}"
            }
        ],
        "url": 650
    },
    {
        "nl_input": "selecting a range of 2d elements from a numpy array gives empty array in python 3",
        "code_input": [
            {
                "url": 5850,
                "code": "def _create_empty_array(self, frames, always_2d, dtype): import numpy as np if always_2d or self.channels > 1: shape = frames, self.channels else: shape = frames, return np.empty(shape, dtype, order='C')"
            },
            {
                "url": 3783,
                "code": "def select_from_array(cls, array, identifier): base_array = np.zeros(array.shape) array_coords = np.where(array == identifier) base_array[array_coords] = 1 return cls(base_array)"
            },
            {
                "url": 3199,
                "code": "def _split_arrs(array_2d, slices): if len(array_2d) == 0: return np.empty(0, dtype=np.object) rtn = np.empty(len(slices) + 1, dtype=np.object) start = 0 for i, s in enumerate(slices): rtn[i] = array_2d[start:s] start = s rtn[-1] = array_2d[start:] return rtn"
            },
            {
                "url": 3823,
                "code": "def _indexes(arr): myarr = np.array(arr) if myarr.ndim == 1: return list(range(len(myarr))) elif myarr.ndim == 2: return tuple(itertools.product(list(range(arr.shape[0])), list(range(arr.shape[1])))) else: raise NotImplementedError('Only supporting arrays of dimension 1 and 2 as yet.')"
            },
            {
                "url": 2938,
                "code": "def make_2d(ary): dim_0, *_ = np.atleast_1d(ary).shape return ary.reshape(dim_0, -1, order=\"F\")"
            },
            {
                "url": 2735,
                "code": "def from_tuple(tup): if len(tup) not in (2, 3): raise ValueError( 'tuple must contain 2 or 3 elements, not: %d (%r' % ( len(tup), tup, ), ) return range(*tup)"
            },
            {
                "url": 1495,
                "code": "def array(self): return np.arange(self.start, self.stop, self.step)"
            },
            {
                "url": 59,
                "code": "def one_hot(x, size, dtype=np.float32): return np.array(x[..., np.newaxis] == np.arange(size), dtype)"
            },
            {
                "url": 2387,
                "code": "def toArray(self): arr = np.zeros((self.size,), dtype=np.float64) arr[self.indices] = self.values return arr"
            },
            {
                "url": 5650,
                "code": "def genfirstvalues(cursor: Cursor, arraysize: int = 1000) \\ -> Generator[Any, None, None]: return (row[0] for row in genrows(cursor, arraysize))"
            },
            {
                "url": 5815,
                "code": "def to_0d_array(value: Any) -> np.ndarray: if np.isscalar(value) or (isinstance(value, np.ndarray) and value.ndim == 0): return np.array(value) else: return to_0d_object_array(value)"
            },
            {
                "url": 1885,
                "code": "def c_array(ctype, values): if isinstance(values, np.ndarray) and values.dtype.itemsize == ctypes.sizeof(ctype): return (ctype * len(values)).from_buffer_copy(values) return (ctype * len(values))(*values)"
            },
            {
                "url": 1583,
                "code": "def dict_to_numpy_array(d): return fromarrays(d.values(), np.dtype([(str(k), v.dtype) for k, v in d.items()]))"
            },
            {
                "url": 84,
                "code": "def cint8_array_to_numpy(cptr, length): if isinstance(cptr, ctypes.POINTER(ctypes.c_int8)): return np.fromiter(cptr, dtype=np.int8, count=length) else: raise RuntimeError('Expected int pointer')"
            },
            {
                "url": 2753,
                "code": "def get_2D_samples_gauss(n, m, sigma, random_state=None): return make_2D_samples_gauss(n, m, sigma, random_state=None)"
            }
        ],
        "url": 5815
    },
    {
        "nl_input": "python read tokens from line",
        "code_input": [
            {
                "url": 6106,
                "code": "def get_tokens(line: str) -> Iterator[str]: for token in line.rstrip().split(): if len(token) > 0: yield token"
            },
            {
                "url": 5230,
                "code": "def read(self): for line in self.io.read(): with self.parse_line(line) as j: yield j"
            },
            {
                "url": 2461,
                "code": "def listified_tokenizer(source): io_obj = io.StringIO(source) return [list(a) for a in tokenize.generate_tokens(io_obj.readline)]"
            },
            {
                "url": 973,
                "code": "def _read_stdin(): line = sys.stdin.readline() while line: yield line line = sys.stdin.readline()"
            },
            {
                "url": 2261,
                "code": "def extract_words(lines): for line in lines: for word in re.findall(r\"\\w+\", line): yield word"
            },
            {
                "url": 855,
                "code": "def tokenize(string): for match in TOKENS_REGEX.finditer(string): yield Token(match.lastgroup, match.group().strip(), match.span())"
            },
            {
                "url": 964,
                "code": "def lines(input): for raw_line in input: line = raw_line.strip() if line and not line.startswith('#'): yield strip_comments(line)"
            },
            {
                "url": 4173,
                "code": "def readline( file, skip_blank=False ): while 1: line = file.readline() #print \"every line: %r\" % line if not line: return None if line[0] != '#' and not ( skip_blank and line.isspace() ): return line"
            },
            {
                "url": 34,
                "code": "def advance_one_line(self): current_line = self._current_token.line_number while current_line == self._current_token.line_number: self._current_token = ConfigParser.Token(*next(self._token_generator))"
            },
            {
                "url": 5582,
                "code": "def iter_lines(file_like: Iterable[str]) -> Generator[str, None, None]: for line in file_like: line = line.rstrip('\\r\\n') if line: yield line"
            },
            {
                "url": 1576,
                "code": "def tokenize_list(self, text): return [self.get_record_token(record) for record in self.analyze(text)]"
            },
            {
                "url": 3107,
                "code": "def _next_token(self, skipws=True): self._token = next(self._tokens).group(0) return self._next_token() if skipws and self._token.isspace() else self._token"
            },
            {
                "url": 636,
                "code": "def get_lines(handle, line): for i, l in enumerate(handle): if i == line: return l"
            },
            {
                "url": 4455,
                "code": "def tokenize(self, s): return [s[start:end] for start, end in self.span_tokenize(s)]"
            },
            {
                "url": 4292,
                "code": "def load_from_file(cls, filename_prefix): filename = cls._filename(filename_prefix) lines, _ = cls._read_lines_from_file(filename) # Strip wrapping single quotes vocab_list = [line[1:-1] for line in lines] return cls(vocab_list=vocab_list)"
            }
        ],
        "url": 6106
    },
    {
        "nl_input": "write data into fits file python",
        "code_input": [
            {
                "url": 4351,
                "code": "def write_fits(data, header, file_name): hdu = fits.PrimaryHDU(data) hdu.header = header hdulist = fits.HDUList([hdu]) hdulist.writeto(file_name, overwrite=True) logging.info(\"Wrote {0}\".format(file_name)) return"
            },
            {
                "url": 1138,
                "code": "def write_fits(self, fitsfile): tab = self.create_table() hdu_data = fits.table_to_hdu(tab) hdus = [fits.PrimaryHDU(), hdu_data] fits_utils.write_hdus(hdus, fitsfile)"
            },
            {
                "url": 301,
                "code": "def create_table_from_fits(fitsfile, hduname, colnames=None): if colnames is None: return Table.read(fitsfile, hduname) cols = [] with fits.open(fitsfile, memmap=True) as h: for k in colnames: data = h[hduname].data.field(k) cols += [Column(name=k, data=data)] return Table(cols)"
            },
            {
                "url": 4691,
                "code": "def write_to_file(file_path, contents, encoding=\"utf-8\"): with codecs.open(file_path, \"w\", encoding) as f: f.write(contents)"
            },
            {
                "url": 2511,
                "code": "def write_str2file(pathname, astr): fname = pathname fhandle = open(fname, 'wb') fhandle.write(astr) fhandle.close()"
            },
            {
                "url": 5287,
                "code": "def add_column(filename,column,formula,force=False): columns = parse_formula(formula) logger.info(\"Running file: %s\"%filename) logger.debug(\" Reading columns: %s\"%columns) data = fitsio.read(filename,columns=columns) logger.debug(' Evaluating formula: %s'%formula) col = eval(formula) col = np.asarray(col,dtype=[(column,col.dtype)]) insert_columns(filename,col,force=force) return True"
            },
            {
                "url": 5623,
                "code": "def write_text(filename: str, text: str) -> None: with open(filename, 'w') as f: # type: TextIO print(text, file=f)"
            },
            {
                "url": 1258,
                "code": "def write_file(filename, content): print 'Generating {0}'.format(filename) with open(filename, 'wb') as out_f: out_f.write(content)"
            },
            {
                "url": 1080,
                "code": "def write_wav(path, samples, sr=16000): max_value = np.abs(np.iinfo(np.int16).min) data = (samples * max_value).astype(np.int16) scipy.io.wavfile.write(path, sr, data)"
            },
            {
                "url": 1904,
                "code": "def readwav(filename): from scipy.io.wavfile import read as readwav samplerate, signal = readwav(filename) return signal, samplerate"
            },
            {
                "url": 5146,
                "code": "def write_string(value, buff, byteorder='big'): data = value.encode('utf-8') write_numeric(USHORT, len(data), buff, byteorder) buff.write(data)"
            },
            {
                "url": 3915,
                "code": "def save_hdf(self,filename,path=''): self.dataframe.to_hdf(filename,'{}/df'.format(path))"
            },
            {
                "url": 974,
                "code": "def save_excel(self, fd): from pylon.io.excel import ExcelWriter ExcelWriter(self).write(fd)"
            },
            {
                "url": 873,
                "code": "def file_to_str(fname): data = None # rU = read with Universal line terminator with open(fname, 'rU') as fd: data = fd.read() return data"
            },
            {
                "url": 925,
                "code": "def py(self, output): import pprint pprint.pprint(output, stream=self.outfile)"
            }
        ],
        "url": 1138
    },
    {
        "nl_input": "python print string with visible ansi codes",
        "code_input": [
            {
                "url": 1026,
                "code": "def cprint(string, fg=None, bg=None, end='\\n', target=sys.stdout): _color_manager.set_color(fg, bg) target.write(string + end) target.flush() # Needed for Python 3.x _color_manager.set_defaults()"
            },
            {
                "url": 3152,
                "code": "def print_log(text, *colors): sys.stderr.write(sprint(\"{}: {}\".format(script_name, text), *colors) + \"\\n\")"
            },
            {
                "url": 5918,
                "code": "def fprint(expr, print_ascii=False): r if print_ascii: pprint(expr, use_unicode=False, num_columns=120) else: return expr"
            },
            {
                "url": 2513,
                "code": "def _write_color_ansi (fp, text, color): fp.write(esc_ansicolor(color)) fp.write(text) fp.write(AnsiReset)"
            },
            {
                "url": 3444,
                "code": "def sprint(text, *colors): return \"\\33[{}m{content}\\33[{}m\".format(\";\".join([str(color) for color in colors]), RESET, content=text) if IS_ANSI_TERMINAL and colors else text"
            },
            {
                "url": 752,
                "code": "def print_log(value_color=\"\", value_noncolor=\"\"): HEADER = '\\033[92m' ENDC = '\\033[0m' print(HEADER + value_color + ENDC + str(value_noncolor))"
            },
            {
                "url": 273,
                "code": "def printc(cls, txt, color=colors.red): print(cls.color_txt(txt, color))"
            },
            {
                "url": 5092,
                "code": "def print_message(message=None): kwargs = {'stdout': sys.stdout, 'stderr': sys.stderr, 'shell': True} return subprocess.call('echo \"{0}\"'.format(message or ''), **kwargs)"
            },
            {
                "url": 2370,
                "code": "def stringc(text, color): if has_colors: text = str(text) return \"\\033[\"+codeCodes[color]+\"m\"+text+\"\\033[0m\" else: return text"
            },
            {
                "url": 3339,
                "code": "def print(cls, *args, **kwargs): # pylint: disable=protected-access with _shared._PRINT_LOCK: print(*args, **kwargs) _sys.stdout.flush()"
            },
            {
                "url": 3746,
                "code": "def imp_print(self, text, end): sys.stdout.write((text + end).encode(\"utf-8\"))"
            },
            {
                "url": 1078,
                "code": "def _screen(self, s, newline=False): if self.verbose: if newline: print(s) else: print(s, end=' ')"
            },
            {
                "url": 2234,
                "code": "def ansi(color, text): code = COLOR_CODES[color] return '\\033[1;{0}m{1}{2}'.format(code, text, RESET_TERM)"
            },
            {
                "url": 1227,
                "code": "def color_string(color, string): if not color_available: return string return color + string + colorama.Fore.RESET"
            },
            {
                "url": 3864,
                "code": "def _print(self, msg, flush=False, end=\"\\n\"): if self._verbose: print2(msg, end=end, flush=flush)"
            }
        ],
        "url": 2234
    },
    {
        "nl_input": "python check if value in enum",
        "code_input": [
            {
                "url": 5241,
                "code": "def validate(self, val): if val in self.values: return True, None else: return False, \"'%s' is not in enum: %s\" % (val, str(self.values))"
            },
            {
                "url": 569,
                "code": "def to_python(self, value): if value is None: return value if isinstance(value, self.enum): return value return self.enum[value]"
            },
            {
                "url": 1654,
                "code": "def check(self, var): if not isinstance(var, _str_type): return False return _enum_mangle(var) in self._consts"
            },
            {
                "url": 3324,
                "code": "def is_enum_type(type_): return isinstance(type_, type) and issubclass(type_, tuple(_get_types(Types.ENUM)))"
            },
            {
                "url": 756,
                "code": "def isin(value, values): for i, v in enumerate(value): if v not in np.array(values)[:, i]: return False return True"
            },
            {
                "url": 4012,
                "code": "def _lookup_enum_in_ns(namespace, value): for attribute in dir(namespace): if getattr(namespace, attribute) == value: return attribute"
            },
            {
                "url": 2804,
                "code": "def from_string(cls, string): # find enum value for attr in dir(cls): value = getattr(cls, attr) if value == string: return value # if not found, log warning and return the value passed in logger.warning(\"{} is not a valid enum value for {}.\".format(string, cls.__name__)) return string"
            },
            {
                "url": 5210,
                "code": "def _check_valid(key, val, valid): if val not in valid: raise ValueError('%s must be one of %s, not \"%s\"' % (key, valid, val))"
            },
            {
                "url": 5812,
                "code": "def has_value(cls, value: int) -> bool: return any(value == item.value for item in cls)"
            },
            {
                "url": 2916,
                "code": "def Value(self, name): if name in self._enum_type.values_by_name: return self._enum_type.values_by_name[name].number raise ValueError('Enum %s has no value defined for name %s' % ( self._enum_type.name, name))"
            },
            {
                "url": 4573,
                "code": "def test_value(self, value): if not isinstance(value, int): raise ValueError('expected int value: ' + str(type(value)))"
            },
            {
                "url": 285,
                "code": "def make_kind_check(python_types, numpy_kind): def check(value): if hasattr(value, 'dtype'): return value.dtype.kind == numpy_kind return isinstance(value, python_types) return check"
            },
            {
                "url": 1650,
                "code": "def is_valid_variable_name(string_to_check): try: parse('{} = None'.format(string_to_check)) return True except (SyntaxError, ValueError, TypeError): return False"
            },
            {
                "url": 648,
                "code": "def isin(elems, line): found = False for e in elems: if e in line.lower(): found = True break return found"
            },
            {
                "url": 471,
                "code": "def EnumValueName(self, enum, value): return self.enum_types_by_name[enum].values_by_number[value].name"
            }
        ],
        "url": 5812
    },
    {
        "nl_input": "python sqlite table names in database",
        "code_input": [
            {
                "url": 716,
                "code": "def get_table_names(connection): cursor = connection.cursor() cursor.execute(\"SELECT name FROM sqlite_master WHERE type == 'table'\") return [name for (name,) in cursor]"
            },
            {
                "url": 950,
                "code": "def get_tablenames(cur): cur.execute(\"SELECT name FROM sqlite_master WHERE type='table'\") tablename_list_ = cur.fetchall() tablename_list = [str(tablename[0]) for tablename in tablename_list_ ] return tablename_list"
            },
            {
                "url": 4614,
                "code": "def get_table_list(dbconn): cur = dbconn.cursor() cur.execute(\"SELECT name FROM sqlite_master WHERE type='table';\") try: return [item[0] for item in cur.fetchall()] except IndexError: return get_table_list(dbconn)"
            },
            {
                "url": 2535,
                "code": "def column_names(self, table): table_info = self.execute( u'PRAGMA table_info(%s)' % quote(table)) return (column['name'] for column in table_info)"
            },
            {
                "url": 5861,
                "code": "def has_table(self, name): return len(self.sql(\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\", parameters=(name,), asrecarray=False, cache=False)) > 0"
            },
            {
                "url": 5802,
                "code": "def get_table_names_from_metadata(metadata: MetaData) -> List[str]: return [table.name for table in metadata.tables.values()]"
            },
            {
                "url": 5106,
                "code": "def table_exists(cursor, tablename, schema='public'): query = cursor.execute(query, (schema, tablename)) res = cursor.fetchone()[0] return res"
            },
            {
                "url": 5550,
                "code": "def get_column_names(engine: Engine, tablename: str) -> List[str]: return [info.name for info in gen_columns_info(engine, tablename)]"
            },
            {
                "url": 277,
                "code": "def get_table_columns(dbconn, tablename): cur = dbconn.cursor() cur.execute(\"PRAGMA table_info('%s');\" % tablename) info = cur.fetchall() cols = [(i[1], i[2]) for i in info] return cols"
            },
            {
                "url": 913,
                "code": "def get_column_keys_and_names(table): ins = inspect(table) return ((k, c.name) for k, c in ins.mapper.c.items())"
            },
            {
                "url": 4131,
                "code": "def _columns_for_table(table_name): return {cname: col for (tname, cname), col in _COLUMNS.items() if tname == table_name}"
            },
            {
                "url": 3139,
                "code": "def extract_table_names(query): # a good old fashioned regex. turns out this worked better than actually parsing the code tables_blocks = re.findall(r'(?:FROM|JOIN)\\s+(\\w+(?:\\s*,\\s*\\w+)*)', query, re.IGNORECASE) tables = [tbl for block in tables_blocks for tbl in re.findall(r'\\w+', block)] return set(tables)"
            },
            {
                "url": 3059,
                "code": "def drop_all_tables(self): for table_name in self.table_names(): self.execute_sql(\"DROP TABLE %s\" % table_name) self.connection.commit()"
            },
            {
                "url": 4013,
                "code": "def getConnectionStats(self): cur = self._conn.cursor() cur.execute(\"\"\"SELECT datname,numbackends FROM pg_stat_database;\"\"\") rows = cur.fetchall() if rows: return dict(rows) else: return {}"
            },
            {
                "url": 2688,
                "code": "def _tableExists(self, tableName): cursor=_conn.execute(.format(tableName)) exists = cursor.fetchone() is not None cursor.close() return exists"
            }
        ],
        "url": 716
    },
    {
        "nl_input": "how to remove all element from a python dictionary",
        "code_input": [
            {
                "url": 185,
                "code": "def _remove_dict_keys_with_value(dict_, val): return {k: v for k, v in dict_.items() if v is not val}"
            },
            {
                "url": 1015,
                "code": "def rm_keys_from_dict(d, keys): # Loop for each key given for key in keys: # Is the key in the dictionary? if key in d: try: d.pop(key, None) except KeyError: # Not concerned with an error. Keep going. pass return d"
            },
            {
                "url": 2281,
                "code": "def _remove_none_values(dictionary): return list(map(dictionary.pop, [i for i in dictionary if dictionary[i] is None]))"
            },
            {
                "url": 5594,
                "code": "def dictlist_wipe_key(dict_list: Iterable[Dict], key: str) -> None: for d in dict_list: d.pop(key, None)"
            },
            {
                "url": 2205,
                "code": "def clean_dict_keys(d): new_d = {} for (k, v) in d.iteritems(): new_d[str(k)] = v return new_d"
            },
            {
                "url": 2569,
                "code": "def _delete_keys(dct, keys): c = deepcopy(dct) assert isinstance(keys, list) for k in keys: c.pop(k) return c"
            },
            {
                "url": 4874,
                "code": "def __delitem__ (self, key): self._keys.remove(key) super(ListDict, self).__delitem__(key)"
            },
            {
                "url": 3146,
                "code": "def pop (self, key): if key in self._keys: self._keys.remove(key) super(ListDict, self).pop(key)"
            },
            {
                "url": 4062,
                "code": "def __delitem__(self, key): index, value = self._dict.pop(key) key2, value2 = self._list.pop(index) assert key == key2 assert value is value2 self._fix_indices_after_delete(index)"
            },
            {
                "url": 695,
                "code": "def _clean_dict(target_dict, whitelist=None): assert isinstance(target_dict, dict) return { ustr(k).strip(): ustr(v).strip() for k, v in target_dict.items() if v not in (None, Ellipsis, [], (), \"\") and (not whitelist or k in whitelist) }"
            },
            {
                "url": 1017,
                "code": "def purge_dict(idict): odict = {} for key, val in idict.items(): if is_null(val): continue odict[key] = val return odict"
            },
            {
                "url": 3553,
                "code": "def remove_from_string(string, values): for v in values: string = string.replace(v, '') return string"
            },
            {
                "url": 4719,
                "code": "def dict_keys_without_hyphens(a_dict): return dict( (key.replace('-', '_'), val) for key, val in a_dict.items())"
            },
            {
                "url": 1950,
                "code": "def wipe(self): keys = list(self.keys()).copy() for key in keys: self.delete(key)"
            },
            {
                "url": 1019,
                "code": "def pop(self, index=-1): value = self._list.pop(index) del self._dict[value] return value"
            }
        ],
        "url": 5748
    },
    {
        "nl_input": "python parse query string from url",
        "code_input": [
            {
                "url": 4581,
                "code": "def get_querystring(uri): parts = urlparse.urlsplit(uri) return urlparse.parse_qs(parts.query)"
            },
            {
                "url": 2201,
                "code": "def parse_query_string(query): result = {} qparts = query.split('&') for item in qparts: key, value = item.split('=') key = key.strip() value = value.strip() result[key] = unquote_plus(value) return result"
            },
            {
                "url": 1449,
                "code": "def strip_querystring(url): p = six.moves.urllib.parse.urlparse(url) return p.scheme + \"://\" + p.netloc + p.path"
            },
            {
                "url": 1315,
                "code": "def get_url_args(url): url_data = urllib.parse.urlparse(url) arg_dict = urllib.parse.parse_qs(url_data.query) return arg_dict"
            },
            {
                "url": 1747,
                "code": "def parse_code(url): result = urlparse(url) query = parse_qs(result.query) return query['code']"
            },
            {
                "url": 601,
                "code": "def parse_querystring(self, req, name, field): return core.get_value(req.args, name, field)"
            },
            {
                "url": 1660,
                "code": "def clean_url(url): parsed = urlparse(url.strip()) reconstructed = ParseResult( parsed.scheme, parsed.netloc, parsed.path, params='', query='', fragment='') return reconstructed.geturl()"
            },
            {
                "url": 2540,
                "code": "def urlencoded(body, charset='ascii', **kwargs): return parse_query_string(text(body, charset=charset), False)"
            },
            {
                "url": 5172,
                "code": "def add_params_to_url(url, params): url_parts = list(urlparse.urlparse(url)) # get url parts query = dict(urlparse.parse_qsl(url_parts[4])) # get url query query.update(params) # add new params url_parts[4] = urlencode(query) return urlparse.urlunparse(url_parts)"
            },
            {
                "url": 191,
                "code": "def dict_to_querystring(dictionary): s = u\"\" for d in dictionary.keys(): s = unicode.format(u\"{0}{1}={2}&\", s, d, dictionary[d]) return s[:-1]"
            },
            {
                "url": 2871,
                "code": "def filter_query_string(query): return '&'.join([q for q in query.split('&') if not (q.startswith('_k=') or q.startswith('_e=') or q.startswith('_s'))])"
            },
            {
                "url": 548,
                "code": "def url_encode(url): if isinstance(url, text_type): url = url.encode('utf8') return quote(url, ':/%?&=')"
            },
            {
                "url": 4628,
                "code": "def append_query_parameter(url, parameters, ignore_if_exists=True): if ignore_if_exists: for key in parameters.keys(): if key + \"=\" in url: del parameters[key] parameters_str = \"&\".join(k + \"=\" + v for k, v in parameters.items()) append_token = \"&\" if \"?\" in url else \"?\" return url + append_token + parameters_str"
            },
            {
                "url": 5443,
                "code": "def uri_to_iri_parts(path, query, fragment): r path = url_unquote(path, '%/;?') query = url_unquote(query, '%;/?:@&=+,$#') fragment = url_unquote(fragment, '%;/?:@&=+,$#') return path, query, fragment"
            },
            {
                "url": 3033,
                "code": "def create_search_url(self): url = '?' for key, value in self.arguments.items(): url += '%s=%s&' % (quote_plus(key), quote_plus(value)) self.url = url[:-1] return self.url"
            }
        ],
        "url": 2201
    },
    {
        "nl_input": "python remove element set",
        "code_input": [
            {
                "url": 1114,
                "code": "def discard(self, element): try: i = int(element) set.discard(self, i) except ValueError: pass"
            },
            {
                "url": 5741,
                "code": "def remove_once(gset, elem): remove = getattr(gset, 'remove', None) if remove is not None: remove(elem) else: del gset[elem] return elem"
            },
            {
                "url": 5165,
                "code": "def remove_element(self, e): if e.label is not None: self.elementdict.pop(e.label) self.elementlist.remove(e)"
            },
            {
                "url": 3147,
                "code": "def isolate_element(self, x): members = list(self.members(x)) self.delete_set(x) self.union(*(v for v in members if v != x))"
            },
            {
                "url": 185,
                "code": "def _remove_dict_keys_with_value(dict_, val): return {k: v for k, v in dict_.items() if v is not val}"
            },
            {
                "url": 837,
                "code": "def remove_elements(target, indices): copied = list(target) for index in reversed(indices): del copied[index] return copied"
            },
            {
                "url": 3553,
                "code": "def remove_from_string(string, values): for v in values: string = string.replace(v, '') return string"
            },
            {
                "url": 278,
                "code": "def remove_duplicates(lst): dset = set() return [l for l in lst if l not in dset and not dset.add(l)]"
            },
            {
                "url": 4062,
                "code": "def __delitem__(self, key): index, value = self._dict.pop(key) key2, value2 = self._list.pop(index) assert key == key2 assert value is value2 self._fix_indices_after_delete(index)"
            },
            {
                "url": 1019,
                "code": "def pop(self, index=-1): value = self._list.pop(index) del self._dict[value] return value"
            },
            {
                "url": 4874,
                "code": "def __delitem__ (self, key): self._keys.remove(key) super(ListDict, self).__delitem__(key)"
            },
            {
                "url": 2281,
                "code": "def _remove_none_values(dictionary): return list(map(dictionary.pop, [i for i in dictionary if dictionary[i] is None]))"
            },
            {
                "url": 4214,
                "code": "def remove(self, entry): try: list = self.cache[entry.key] list.remove(entry) except: pass"
            },
            {
                "url": 4422,
                "code": "def DeleteIndex(self, index): to_remove = None for i in self.Items: if i.index == index: to_remove = i if to_remove: self.Items.remove(to_remove)"
            },
            {
                "url": 2777,
                "code": "def remove(self, key): item = self.item_finder.pop(key) item[-1] = None self.removed_count += 1"
            }
        ],
        "url": 3147
    },
    {
        "nl_input": "manhattan distance in python using longitude and latitude",
        "code_input": [
            {
                "url": 3298,
                "code": "def manhattan_distance_numpy(object1, object2): return numpy.sum(numpy.absolute(object1 - object2), axis=1).T"
            },
            {
                "url": 1828,
                "code": "def _manhattan_distance(vec_a, vec_b): if len(vec_a) != len(vec_b): raise ValueError('len(vec_a) must equal len(vec_b)') return sum(map(lambda a, b: abs(a - b), vec_a, vec_b))"
            },
            {
                "url": 2853,
                "code": "def manhattan(h1, h2): # # 7 us @array, 31 us @list \\w 100 bins r h1, h2 = __prepare_histogram(h1, h2) return scipy.sum(scipy.absolute(h1 - h2))"
            },
            {
                "url": 102,
                "code": "def _calculate_distance(latlon1, latlon2): lat1, lon1 = latlon1 lat2, lon2 = latlon2 dlon = lon2 - lon1 dlat = lat2 - lat1 R = 6371 # radius of the earth in kilometers a = np.sin(dlat / 2)**2 + np.cos(lat1) * np.cos(lat2) * (np.sin(dlon / 2))**2 c = 2 * np.pi * R * np.arctan2(np.sqrt(a), np.sqrt(1 - a)) / 180 return c"
            },
            {
                "url": 1740,
                "code": "def Distance(lat1, lon1, lat2, lon2): az12, az21, dist = wgs84_geod.inv(lon1, lat1, lon2, lat2) return az21, dist"
            },
            {
                "url": 4066,
                "code": "def _distance(coord1, coord2): xdist = coord1[0] - coord2[0] ydist = coord1[1] - coord2[1] return sqrt(xdist*xdist + ydist*ydist)"
            },
            {
                "url": 828,
                "code": "def compute(args): x, y, params = args return x, y, mandelbrot(x, y, params)"
            },
            {
                "url": 206,
                "code": "def get_distance_between_two_points(self, one, two): dx = one.x - two.x dy = one.y - two.y return math.sqrt(dx * dx + dy * dy)"
            },
            {
                "url": 104,
                "code": "def direct2dDistance(self, point): if not isinstance(point, MapPoint): return 0.0 return ((self.x-point.x)**2 + (self.y-point.y)**2)**(0.5) # simple distance formula"
            },
            {
                "url": 4554,
                "code": "def _euclidean_dist(vector_a, vector_b): dist = 0 for (x, y) in zip(vector_a, vector_b): dist += (x-y)*(x-y) return math.sqrt(dist)"
            },
            {
                "url": 4335,
                "code": "def get_distance(F, x): n = x.shape[0] square = F.sum(x ** 2.0, axis=1, keepdims=True) distance_square = square + square.transpose() - (2.0 * F.dot(x, x.transpose())) # Adding identity to make sqrt work. return F.sqrt(distance_square + F.array(np.identity(n)))"
            },
            {
                "url": 708,
                "code": "def levenshtein_distance_metric(a, b): return (levenshtein_distance(a, b) / (2.0 * max(len(a), len(b), 1)))"
            },
            {
                "url": 2719,
                "code": "def distance(vec1, vec2): if isinstance(vec1, Vector2) \\ and isinstance(vec2, Vector2): dist_vec = vec2 - vec1 return dist_vec.length() else: raise TypeError(\"vec1 and vec2 must be Vector2's\")"
            },
            {
                "url": 2856,
                "code": "def get_distance_matrix(x): square = nd.sum(x ** 2.0, axis=1, keepdims=True) distance_square = square + square.transpose() - (2.0 * nd.dot(x, x.transpose())) return nd.sqrt(distance_square)"
            },
            {
                "url": 4142,
                "code": "def distance_matrix(trains1, trains2, cos, tau): return dissimilarity_matrix(trains1, trains2, cos, tau, \"distance\")"
            }
        ],
        "url": 1828
    },
    {
        "nl_input": "how to read from a file to a list python",
        "code_input": [
            {
                "url": 3132,
                "code": "def get_list_from_file(file_name): with open(file_name, mode='r', encoding='utf-8') as f1: lst = f1.readlines() return lst"
            },
            {
                "url": 3280,
                "code": "def readCommaList(fileList): names=fileList.split(',') fileList=[] for item in names: fileList.append(item) return fileList"
            },
            {
                "url": 1837,
                "code": "def to_list(var): if var is None: return [] if isinstance(var, str): var = var.split('\\n') elif not isinstance(var, list): try: var = list(var) except TypeError: raise ValueError(\"{} cannot be converted to the list.\".format(var)) return var"
            },
            {
                "url": 2742,
                "code": "def csvtolist(inputstr): reader = csv.reader([inputstr], skipinitialspace=True) output = [] for r in reader: output += r return output"
            },
            {
                "url": 3278,
                "code": "def comma_delimited_to_list(list_param): if isinstance(list_param, list): return list_param if isinstance(list_param, str): return list_param.split(',') else: return []"
            },
            {
                "url": 4825,
                "code": "def list_to_csv(my_list, csv_file): if PY3: csv_handler = open(csv_file, 'w', newline='') else: csv_handler = open(csv_file, 'wb') try: writer = csv.writer(csv_handler, delimiter=',', quoting=csv.QUOTE_ALL) writer.writerows(my_list) finally: csv_handler.close()"
            },
            {
                "url": 5611,
                "code": "def read_set_from_file(filename: str) -> Set[str]: collection = set() with open(filename, 'r') as file_: for line in file_: collection.add(line.rstrip()) return collection"
            },
            {
                "url": 77,
                "code": "def list_to_csv(value): if isinstance(value, (list, tuple, set)): value = \",\".join(value) return value"
            },
            {
                "url": 5723,
                "code": "def _str_to_list(value, separator): value_list = [item.strip() for item in value.split(separator)] value_list_sanitized = builtins.list(filter(None, value_list)) if len(value_list_sanitized) > 0: return value_list_sanitized else: raise ValueError('Invalid list variable.')"
            },
            {
                "url": 57,
                "code": "def csv_to_dicts(file, header=None): with open(file) as csvfile: return [row for row in csv.DictReader(csvfile, fieldnames=header)]"
            },
            {
                "url": 3411,
                "code": "def toList(variable, types=(basestring, int, float, )): if isinstance(variable, types): return [variable] else: return variable"
            },
            {
                "url": 4497,
                "code": "def isCommaList(inputFilelist): if isinstance(inputFilelist, int) or isinstance(inputFilelist, np.int32): ilist = str(inputFilelist) else: ilist = inputFilelist if \",\" in ilist: return True return False"
            },
            {
                "url": 5700,
                "code": "def list_to_str(list, separator=','): list = [str(x) for x in list] return separator.join(list)"
            },
            {
                "url": 2418,
                "code": "def _str_to_list(s): _list = s.split(\",\") return list(map(lambda i: i.lstrip(), _list))"
            },
            {
                "url": 3417,
                "code": "def list2string (inlist,delimit=' '): stringlist = [makestr(_) for _ in inlist] return string.join(stringlist,delimit)"
            }
        ],
        "url": 3132
    },
    {
        "nl_input": "dynamically update value in dictionary python",
        "code_input": [
            {
                "url": 1710,
                "code": "def update_dict(obj, dict, attributes): for attribute in attributes: if hasattr(obj, attribute) and getattr(obj, attribute) is not None: dict[attribute] = getattr(obj, attribute)"
            },
            {
                "url": 3690,
                "code": "def update(self, dictionary=None, **kwargs): if not dictionary == None: kwargs.update(dictionary) for k in list(kwargs.keys()): self[k] = kwargs[k]"
            },
            {
                "url": 1224,
                "code": "def copy_and_update(dictionary, update): newdict = dictionary.copy() newdict.update(update) return newdict"
            },
            {
                "url": 2847,
                "code": "def update(self, **kwargs): for key, value in kwargs.items(): setattr(self, key, value)"
            },
            {
                "url": 181,
                "code": "def update(self, other_dict): for key, value in iter_multi_items(other_dict): MultiDict.add(self, key, value)"
            },
            {
                "url": 2125,
                "code": "def update(self, *args, **kwargs): super(DictProxy, self).update(*args, **kwargs) return self"
            },
            {
                "url": 179,
                "code": "def dict_update_newkeys(dict_, dict2): for key, val in six.iteritems(dict2): if key not in dict_: dict_[key] = val"
            },
            {
                "url": 2790,
                "code": "def recursively_update(d, d2): for k, v in d2.items(): if k in d: if isinstance(v, dict): recursively_update(d[k], v) continue d[k] = v"
            },
            {
                "url": 6132,
                "code": "def dictlist_replace(dict_list: Iterable[Dict], key: str, value: Any) -> None: for d in dict_list: d[key] = value"
            },
            {
                "url": 4883,
                "code": "def update(dct, dct_merge): for key, value in dct_merge.items(): if key in dct and isinstance(dct[key], dict): dct[key] = update(dct[key], value) else: dct[key] = value return dct"
            },
            {
                "url": 6075,
                "code": "def update_kwargs(kwargs, **keyvalues): for key, value in keyvalues.items(): if key not in kwargs: kwargs[key] = value"
            },
            {
                "url": 51,
                "code": "def dictapply(d, fn): for k, v in d.items(): if isinstance(v, dict): v = dictapply(v, fn) else: d[k] = fn(v) return d"
            },
            {
                "url": 5848,
                "code": "def dict_of_sets_add(dictionary, key, value): # type: (DictUpperBound, Any, Any) -> None set_objs = dictionary.get(key, set()) set_objs.add(value) dictionary[key] = set_objs"
            },
            {
                "url": 1318,
                "code": "def fromDict(cls, _dict): obj = cls() obj.__dict__.update(_dict) return obj"
            },
            {
                "url": 4666,
                "code": "def setdict(self, D): self.D = np.asarray(D, dtype=self.dtype)"
            }
        ],
        "url": 2899
    },
    {
        "nl_input": "python replace string from right",
        "code_input": [
            {
                "url": 5625,
                "code": "def right_replace(string, old, new, count=1): if not string: return string return new.join(string.rsplit(old, count))"
            },
            {
                "url": 3181,
                "code": "def replace(s, replace): for r in replace: s = s.replace(*r) return s"
            },
            {
                "url": 5988,
                "code": "def replace(s, old, new, maxreplace=-1): return s.replace(old, new, maxreplace)"
            },
            {
                "url": 5699,
                "code": "def replace_in_list(stringlist: Iterable[str], replacedict: Dict[str, str]) -> List[str]: newlist = [] for fromstring in stringlist: newlist.append(multiple_replace(fromstring, replacedict)) return newlist"
            },
            {
                "url": 5928,
                "code": "def multiple_replace(string, replacements): # type: (str, Dict[str,str]) -> str pattern = re.compile(\"|\".join([re.escape(k) for k in sorted(replacements, key=len, reverse=True)]), flags=re.DOTALL) return pattern.sub(lambda x: replacements[x.group(0)], string)"
            },
            {
                "url": 5865,
                "code": "def replaceStrs(s, *args): r if args == (): return s mapping = dict((frm, to) for frm, to in args) return re.sub(\"|\".join(map(re.escape, mapping.keys())), lambda match:mapping[match.group(0)], s)"
            },
            {
                "url": 1210,
                "code": "def replace(scope, strings, source, dest): return [s.replace(source[0], dest[0]) for s in strings]"
            },
            {
                "url": 5076,
                "code": "def list_replace(subject_list, replacement, string): for s in subject_list: string = string.replace(s, replacement) return string"
            },
            {
                "url": 5111,
                "code": "def subat(orig, index, replace): return \"\".join([(orig[x] if x != index else replace) for x in range(len(orig))])"
            },
            {
                "url": 4308,
                "code": "def _replace(self, data, replacements): for find, repl in replacements: data = data.replace(find, repl) return data"
            },
            {
                "url": 5061,
                "code": "def replace(self, text): for (pattern, repl) in self.patterns: text = re.subn(pattern, repl, text)[0] return text"
            },
            {
                "url": 5637,
                "code": "def __replace_all(repls: dict, input: str) -> str: return re.sub('|'.join(re.escape(key) for key in repls.keys()), lambda k: repls[k.group(0)], input)"
            },
            {
                "url": 656,
                "code": "def myreplace(astr, thefind, thereplace): alist = astr.split(thefind) new_s = alist.split(thereplace) return new_s"
            },
            {
                "url": 3362,
                "code": "def replace_list(items, match, replacement): return [replace(item, match, replacement) for item in items]"
            },
            {
                "url": 1022,
                "code": "def subn_filter(s, find, replace, count=0): return re.gsub(find, replace, count, s)"
            }
        ],
        "url": 5625
    },
    {
        "nl_input": "how to check if a path is writeable python",
        "code_input": [
            {
                "url": 651,
                "code": "def _writable_dir(path): return os.path.isdir(path) and os.access(path, os.W_OK)"
            },
            {
                "url": 1644,
                "code": "def is_readable_dir(path): return os.path.isdir(path) and os.access(path, os.R_OK) and os.access(path, os.X_OK)"
            },
            {
                "url": 4492,
                "code": "def readable(path): try: st = os.stat(path) return 0 != st.st_mode & READABLE_MASK except os.error: return None return True"
            },
            {
                "url": 2445,
                "code": "def is_readable(filename): return os.path.isfile(filename) and os.access(filename, os.R_OK)"
            },
            {
                "url": 2939,
                "code": "def is_executable(path): return os.path.isfile(path) and os.access(path, os.X_OK)"
            },
            {
                "url": 5788,
                "code": "def writable_stream(handle): if isinstance(handle, io.IOBase) and sys.version_info >= (3, 5): return handle.writable() try: handle.write(b'') except (io.UnsupportedOperation, IOError): return False else: return True"
            },
            {
                "url": 3186,
                "code": "def is_writable_by_others(filename): mode = os.stat(filename)[stat.ST_MODE] return mode & stat.S_IWOTH"
            },
            {
                "url": 5808,
                "code": "def valid_file(path: str) -> bool: path = Path(path).expanduser() log.debug(\"checking if %s is a valid file\", path) return path.exists() and path.is_file()"
            },
            {
                "url": 214,
                "code": "def _is_path(s): if isinstance(s, string_types): try: return op.exists(s) except (OSError, ValueError): return False else: return False"
            },
            {
                "url": 3432,
                "code": "def make_writeable(filename): if not os.access(filename, os.W_OK): st = os.stat(filename) new_permissions = stat.S_IMODE(st.st_mode) | stat.S_IWUSR os.chmod(filename, new_permissions)"
            },
            {
                "url": 4361,
                "code": "def is_filelike(ob): if hasattr(ob, 'read') and callable(ob.read): return True if hasattr(ob, 'write') and callable(ob.write): return True return False"
            },
            {
                "url": 2147,
                "code": "def is_exe(fpath): return os.path.isfile(fpath) and os.access(fpath, os.X_OK)"
            },
            {
                "url": 653,
                "code": "def isdir(path, **kwargs): import os.path return os.path.isdir(path, **kwargs)"
            },
            {
                "url": 4294,
                "code": "def make_file_readable (filename): if not os.path.islink(filename): util.set_mode(filename, stat.S_IRUSR)"
            },
            {
                "url": 561,
                "code": "def make_file_read_only(file_path): old_permissions = os.stat(file_path).st_mode os.chmod(file_path, old_permissions & ~WRITE_PERMISSIONS)"
            }
        ],
        "url": 651
    },
    {
        "nl_input": "get attribute type in python",
        "code_input": [
            {
                "url": 5331,
                "code": "def static_get_type_attr(t, name): for type_ in t.mro(): try: return vars(type_)[name] except KeyError: pass raise AttributeError(name)"
            },
            {
                "url": 921,
                "code": "def getTypeStr(_type): r if isinstance(_type, CustomType): return str(_type) if hasattr(_type, '__name__'): return _type.__name__ return ''"
            },
            {
                "url": 2597,
                "code": "def get_attr(self, method_name): return self.attrs.get(method_name) or self.get_callable_attr(method_name)"
            },
            {
                "url": 1339,
                "code": "def get_type(self): item_type = self.xmlnode.prop(\"type\") if not item_type: item_type = \"?\" return item_type.decode(\"utf-8\")"
            },
            {
                "url": 2822,
                "code": "def __getattribute__(self, attr): if (attr not in object.__getattribute__(self, '__dict__') and attr not in Etree.__dict__): return object.__getattribute__(self._etree, attr) return object.__getattribute__(self, attr)"
            },
            {
                "url": 6248,
                "code": "def attr_names(cls) -> List[str]: return [k for k, v in cls.attr_types().items()]"
            },
            {
                "url": 986,
                "code": "def get_var_type(self, name): name = create_string_buffer(name) type_ = create_string_buffer(MAXSTRLEN) self.library.get_var_type.argtypes = [c_char_p, c_char_p] self.library.get_var_type(name, type_) return type_.value"
            },
            {
                "url": 3442,
                "code": "def _get_type(self, value): if value is None: return type(None) elif type(value) in int_types: return int elif type(value) in float_types: return float elif isinstance(value, binary_type): return binary_type else: return text_type"
            },
            {
                "url": 1693,
                "code": "def _getTypename(self, defn): return 'REAL' if defn.type.float or 'TIME' in defn.type.name or defn.dntoeu else 'INTEGER'"
            },
            {
                "url": 534,
                "code": "def is_builtin_type(tp): return hasattr(__builtins__, tp.__name__) and tp is getattr(__builtins__, tp.__name__)"
            },
            {
                "url": 614,
                "code": "def datatype(dbtype, description, cursor): dt = cursor.db.introspection.get_field_type(dbtype, description) if type(dt) is tuple: return dt[0] else: return dt"
            },
            {
                "url": 2061,
                "code": "def typename(obj): if hasattr(obj, '__class__'): return getattr(obj, '__class__').__name__ else: return type(obj).__name__"
            },
            {
                "url": 768,
                "code": "def is_type(value): if isinstance(value, type): return issubclass(value, Type) return isinstance(value, Type)"
            },
            {
                "url": 628,
                "code": "def value(self): if self._prop.fget is None: raise AttributeError('Unable to read attribute') return self._prop.fget(self._obj)"
            },
            {
                "url": 1522,
                "code": "def get_attribute_name_id(attr): return attr.value.id if isinstance(attr.value, ast.Name) else None"
            }
        ],
        "url": 1522
    },
    {
        "nl_input": "get fields of object python",
        "code_input": [
            {
                "url": 2240,
                "code": "def fields(self): return (self.attributes.values() + self.lists.values() + self.references.values())"
            },
            {
                "url": 3597,
                "code": "def struct2dict(struct): return {x: getattr(struct, x) for x in dict(struct._fields_).keys()}"
            },
            {
                "url": 2215,
                "code": "def _basic_field_data(field, obj): value = field.value_from_object(obj) return {Field.TYPE: FieldType.VAL, Field.VALUE: value}"
            },
            {
                "url": 2238,
                "code": "def getfield(f): if isinstance(f, list): return [getfield(x) for x in f] else: return f.value"
            },
            {
                "url": 2202,
                "code": "def get_dict_for_attrs(obj, attrs): data = {} for attr in attrs: data[attr] = getattr(obj, attr) return data"
            },
            {
                "url": 150,
                "code": "def dictify(a_named_tuple): return dict((s, getattr(a_named_tuple, s)) for s in a_named_tuple._fields)"
            },
            {
                "url": 4572,
                "code": "def get_field_by_name(self, name): for f in self.fields: if f.get_name() == name: return f return None"
            },
            {
                "url": 3498,
                "code": "def get_python(self): if self.multiselect: return super(MultiSelectField, self).get_python() return self._get()"
            },
            {
                "url": 2252,
                "code": "def get_object_attrs(obj): attrs = [k for k in dir(obj) if not k.startswith('__')] if not attrs: attrs = dir(obj) return attrs"
            },
            {
                "url": 3188,
                "code": "def _summarize_object_type(model): # the fields for the service's model model_fields = {field.name: field for field in list(model.fields())} # summarize the model return { 'fields': [{ 'name': key, 'type': type(convert_peewee_field(value)).__name__ } for key, value in model_fields.items() ] }"
            },
            {
                "url": 1849,
                "code": "def object_as_dict(obj): return {c.key: getattr(obj, c.key) for c in inspect(obj).mapper.column_attrs}"
            },
            {
                "url": 5803,
                "code": "def dtypes(self): return [(str(f.name), f.dataType.simpleString()) for f in self.schema.fields]"
            },
            {
                "url": 227,
                "code": "def isnamedtuple(obj): return isinstance(obj, tuple) \\ and hasattr(obj, \"_fields\") \\ and hasattr(obj, \"_asdict\") \\ and callable(obj._asdict)"
            },
            {
                "url": 3369,
                "code": "def get_date_field(datetimes, field): return np.array([getattr(date, field) for date in datetimes])"
            },
            {
                "url": 727,
                "code": "def get_all_attributes(klass_or_instance): pairs = list() for attr, value in inspect.getmembers( klass_or_instance, lambda x: not inspect.isroutine(x)): if not (attr.startswith(\"__\") or attr.endswith(\"__\")): pairs.append((attr, value)) return pairs"
            }
        ],
        "url": 1849
    },
    {
        "nl_input": "how to fetch one value from one row from mysql query in python",
        "code_input": [
            {
                "url": 5806,
                "code": "def fetchvalue(self, sql: str, *args) -> Optional[Any]: row = self.fetchone(sql, *args) if row is None: return None return row[0]"
            },
            {
                "url": 1281,
                "code": "def query_fetch_one(self, query, values): self.cursor.execute(query, values) retval = self.cursor.fetchone() self.__close_db() return retval"
            },
            {
                "url": 5702,
                "code": "def fetchallfirstvalues(self, sql: str, *args) -> List[Any]: rows = self.fetchall(sql, *args) return [row[0] for row in rows]"
            },
            {
                "url": 5937,
                "code": "def execute_sql(self, query): c = self.con.cursor() c.execute(query) result = [] if c.rowcount > 0: try: result = c.fetchall() except psycopg2.ProgrammingError: pass return result"
            },
            {
                "url": 2990,
                "code": "def query_proc_row(procname, args=(), factory=None): for row in query_proc(procname, args, factory): return row return None"
            },
            {
                "url": 5650,
                "code": "def genfirstvalues(cursor: Cursor, arraysize: int = 1000) \\ -> Generator[Any, None, None]: return (row[0] for row in genrows(cursor, arraysize))"
            },
            {
                "url": 3421,
                "code": "def querySQL(self, sql, args=()): if self.debug: result = timeinto(self.queryTimes, self._queryandfetch, sql, args) else: result = self._queryandfetch(sql, args) return result"
            },
            {
                "url": 5901,
                "code": "async def fetchall(self) -> Iterable[sqlite3.Row]: return await self._execute(self._cursor.fetchall)"
            },
            {
                "url": 5304,
                "code": "def fetch(table, cols=\"*\", where=(), group=\"\", order=(), limit=(), **kwargs): return select(table, cols, where, group, order, limit, **kwargs).fetchall()"
            },
            {
                "url": 3506,
                "code": "def get_single_value(d): assert len(d) == 1, 'Single-item dict must have just one item, not %d.' % len(d) return next(six.itervalues(d))"
            },
            {
                "url": 5565,
                "code": "async def executemany(self, sql: str, parameters: Iterable[Iterable[Any]]) -> None: await self._execute(self._cursor.executemany, sql, parameters)"
            },
            {
                "url": 4609,
                "code": "def count_rows(self, table, cols='*'): query = 'SELECT COUNT({0}) FROM {1}'.format(join_cols(cols), wrap(table)) result = self.fetch(query) return result if result is not None else 0"
            },
            {
                "url": 587,
                "code": "def get_last_row(dbconn, tablename, n=1, uuid=None): return fetch(dbconn, tablename, n, uuid, end=True)"
            },
            {
                "url": 5954,
                "code": "def execute(cur, *args): stmt = args[0] if len(args) > 1: stmt = stmt.replace('%', '%%').replace('?', '%r') print(stmt % (args[1])) return cur.execute(*args)"
            },
            {
                "url": 1506,
                "code": "def get_last(self, table=None): if table is None: table = self.main_table query = 'SELECT * FROM \"%s\" ORDER BY ROWID DESC LIMIT 1;' % table return self.own_cursor.execute(query).fetchone()"
            }
        ],
        "url": 5806
    },
    {
        "nl_input": "python flask routes add",
        "code_input": [
            {
                "url": 3536,
                "code": "def add_url_rule(self, route, endpoint, handler): self.app.add_url_rule(route, endpoint, handler)"
            },
            {
                "url": 4475,
                "code": "def add_swagger(app, json_route, html_route): app.router.add_route('GET', json_route, create_swagger_json_handler(app)) add_swagger_api_route(app, html_route, json_route)"
            },
            {
                "url": 2676,
                "code": "def can_route(self, endpoint, method=None, **kwargs): view = flask.current_app.view_functions.get(endpoint) if not view: endpoint, args = flask._request_ctx.top.match(endpoint) view = flask.current_app.view_functions.get(endpoint) if not view: return False return self.can('http.' + (method or 'GET').lower(), view, **kwargs)"
            },
            {
                "url": 1918,
                "code": "def initialize_api(flask_app): if not flask_restplus: return api = flask_restplus.Api(version=\"1.0\", title=\"My Example API\") api.add_resource(HelloWorld, \"/hello\") blueprint = flask.Blueprint(\"api\", __name__, url_prefix=\"/api\") api.init_app(blueprint) flask_app.register_blueprint(blueprint)"
            },
            {
                "url": 310,
                "code": "def handleFlaskPostRequest(flaskRequest, endpoint): if flaskRequest.method == \"POST\": return handleHttpPost(flaskRequest, endpoint) elif flaskRequest.method == \"OPTIONS\": return handleHttpOptions() else: raise exceptions.MethodNotAllowedException()"
            },
            {
                "url": 1421,
                "code": "def redirect(view=None, url=None, **kwargs): if view: if url: kwargs[\"url\"] = url url = flask.url_for(view, **kwargs) current_context.exit(flask.redirect(url))"
            },
            {
                "url": 6225,
                "code": "def run_web(self, flask, host='127.0.0.1', port=5000, **options): # type: (Zsl, str, int, **Any)->None return flask.run( host=flask.config.get('FLASK_HOST', host), port=flask.config.get('FLASK_PORT', port), debug=flask.config.get('DEBUG', False), **options )"
            },
            {
                "url": 4109,
                "code": "def jsonify(resource): response = flask.jsonify(resource.to_dict()) response = add_link_headers(response, resource.links()) return response"
            },
            {
                "url": 4553,
                "code": "def _has_fr_route(self): # 404's, 405's, which might not have a url_rule if self._should_use_fr_error_handler(): return True # for all other errors, just check if FR dispatched the route if not request.url_rule: return False return self.owns_endpoint(request.url_rule.endpoint)"
            },
            {
                "url": 4071,
                "code": "def register(self, target): for rule, options in self.url_rules: target.add_url_rule(rule, self.name, self.dispatch_request, **options)"
            },
            {
                "url": 3982,
                "code": "def get_url(self, routename, **kargs): return '/' + self.routes.build(routename, **kargs).split(';', 1)[1]"
            },
            {
                "url": 5172,
                "code": "def add_params_to_url(url, params): url_parts = list(urlparse.urlparse(url)) # get url parts query = dict(urlparse.parse_qsl(url_parts[4])) # get url query query.update(params) # add new params url_parts[4] = urlencode(query) return urlparse.urlunparse(url_parts)"
            },
            {
                "url": 4107,
                "code": "def static_url(path, absolute=False): if os.sep != '/': path = '/'.join(path.split(os.sep)) return flask.url_for('static', filename=path, _external=absolute)"
            },
            {
                "url": 4535,
                "code": "def url(viewname, *args, **kwargs): return reverse(viewname, args=args, kwargs=kwargs)"
            },
            {
                "url": 1900,
                "code": "def extra_funcs(*funcs): def extra_funcs_decorator(real_func): def wrapper(*args, **kwargs): return real_func(*args, **kwargs) wrapper.extra_funcs = list(funcs) wrapper.source = inspect.getsource(real_func) wrapper.name = real_func.__name__ return wrapper return extra_funcs_decorator"
            }
        ],
        "url": 3536
    },
    {
        "nl_input": "define function arg type and default values python",
        "code_input": [
            {
                "url": 1432,
                "code": "def arg_default(*args, **kwargs): parser = argparse.ArgumentParser() parser.add_argument(*args, **kwargs) args = vars(parser.parse_args([])) _, default = args.popitem() return default"
            },
            {
                "url": 139,
                "code": "def get_default_args(func): args, varargs, keywords, defaults = getargspec_no_self(func) return dict(zip(args[-len(defaults):], defaults))"
            },
            {
                "url": 3599,
                "code": "def _py_ex_argtype(executable): result = [] for p in executable.ordered_parameters: atypes = p.argtypes if atypes is not None: result.extend(p.argtypes) else: print((\"No argtypes for: {}\".format(p.definition()))) if type(executable).__name__ == \"Function\": result.extend(executable.argtypes) return result"
            },
            {
                "url": 4452,
                "code": "def args_update(self): for key, value in self._config_data.items(): setattr(self._default_args, key, value)"
            },
            {
                "url": 4324,
                "code": "def set_default(self_,param_name,value): cls = self_.cls setattr(cls,param_name,value)"
            },
            {
                "url": 4190,
                "code": "def param (self, param, kwargs, default_value=False): if param in kwargs: value= kwargs[param] del kwargs[param] else: value= default_value setattr (self, param, value)"
            },
            {
                "url": 3954,
                "code": "def get_args(method_or_func): try: # Python 3.0+ args = list(inspect.signature(method_or_func).parameters.keys()) except AttributeError: # Python 2.7 args = inspect.getargspec(method_or_func).args return args"
            },
            {
                "url": 2067,
                "code": "def make_lambda(call): empty_args = ast.arguments(args=[], vararg=None, kwarg=None, defaults=[]) return ast.Lambda(args=empty_args, body=call)"
            },
            {
                "url": 2846,
                "code": "def arguments_as_dict(cls, *args, **kwargs): all_args = (None, ) + args return inspect.getcallargs(cls.run, *all_args, **kwargs)"
            },
            {
                "url": 6022,
                "code": "def default_parser() -> argparse.ArgumentParser: parser = argparse.ArgumentParser( prog=CONSOLE_SCRIPT, formatter_class=argparse.ArgumentDefaultsHelpFormatter, ) build_parser(parser) return parser"
            },
            {
                "url": 2086,
                "code": "def getFunction(self): return functionFactory( self.code, self.name, self.defaults, self.globals, self.imports, )"
            },
            {
                "url": 5363,
                "code": "def with_defaults(method, nparams, defaults=None): args = [None] * nparams if not defaults else defaults + max(nparams - len(defaults), 0) * [None] return method(*args)"
            },
            {
                "url": 3284,
                "code": "def _correct_args(func, kwargs): args = inspect.getargspec(func)[0] return [kwargs[arg] for arg in args] + kwargs['__args']"
            },
            {
                "url": 3283,
                "code": "def parsed_args(): parser = argparse.ArgumentParser(description=, epilog=\"\") parser.add_argument('command',nargs='*', help=\"Name of the function to run with arguments\") args = parser.parse_args() return (args, parser)"
            },
            {
                "url": 3846,
                "code": "def setDictDefaults (d, defaults): for key, val in defaults.items(): d.setdefault(key, val) return d"
            }
        ],
        "url": 139
    },
    {
        "nl_input": "python image shape detect",
        "code_input": [
            {
                "url": 2021,
                "code": "def get_shape(img): if hasattr(img, 'shape'): shape = img.shape else: shape = img.get_data().shape return shape"
            },
            {
                "url": 6050,
                "code": "def _width_is_big_enough(image, width): if width > image.size[0]: raise ImageSizeError(image.size[0], width)"
            },
            {
                "url": 1861,
                "code": "def get_image_dimension(self, url): w_h = (None, None) try: if url.startswith('//'): url = 'http:' + url data = requests.get(url).content im = Image.open(BytesIO(data)) w_h = im.size except Exception: logger.warning(\"Error getting image size {}\".format(url), exc_info=True) return w_h"
            },
            {
                "url": 205,
                "code": "def is_same_shape(self, other_im, check_channels=False): if self.height == other_im.height and self.width == other_im.width: if check_channels and self.channels != other_im.channels: return False return True return False"
            },
            {
                "url": 4738,
                "code": "def get_shape_mask(self, shape_obj): wd, ht = self.get_size() yi = np.mgrid[:ht].reshape(-1, 1) xi = np.mgrid[:wd].reshape(1, -1) pts = np.asarray((xi, yi)).T contains = shape_obj.contains_pts(pts) return contains"
            },
            {
                "url": 1269,
                "code": "def resize_image_to_fit_width(image, dest_w): scale_factor = dest_w / image.size[0] dest_h = image.size[1] * scale_factor scaled_image = image.resize((int(dest_w), int(dest_h)), PIL.Image.ANTIALIAS) return scaled_image"
            },
            {
                "url": 5568,
                "code": "def getDimensionForImage(filename, maxsize): try: from PIL import Image except ImportError: return None img = Image.open(filename) width, height = img.size if width > maxsize[0] or height > maxsize[1]: img.thumbnail(maxsize) out.info(\"Downscaled display size from %s to %s\" % ((width, height), img.size)) return img.size"
            },
            {
                "url": 1404,
                "code": "def shape(self): if not self.data: return (0, 0) return (len(self.data), len(self.dimensions))"
            },
            {
                "url": 1466,
                "code": "def resize_by_area(img, size): return tf.to_int64( tf.image.resize_images(img, [size, size], tf.image.ResizeMethod.AREA))"
            },
            {
                "url": 2018,
                "code": "def resize(self, size): return Image(self.pil_image.resize(size, PIL.Image.ANTIALIAS))"
            },
            {
                "url": 4823,
                "code": "def resize(self): resized_size = self.get_resized_size() if not resized_size: return self.image = self.image.resize(resized_size, Image.ANTIALIAS)"
            },
            {
                "url": 6179,
                "code": "def _validate_image_rank(self, img_array): if img_array.ndim == 1 or img_array.ndim > 3: msg = \"{0}D imagery is not allowed.\".format(img_array.ndim) raise IOError(msg)"
            },
            {
                "url": 3899,
                "code": "def decode_example(self, example): img = tf.image.decode_image( example, channels=self._shape[-1], dtype=tf.uint8) img.set_shape(self._shape) return img"
            },
            {
                "url": 5817,
                "code": "def calculate_dimensions(image, long_side, short_side): if image.width >= image.height: return '{0}x{1}'.format(long_side, short_side) return '{0}x{1}'.format(short_side, long_side)"
            },
            {
                "url": 2609,
                "code": "def rotateImage(img, angle): imgR = scipy.ndimage.rotate(img, angle, reshape=False) return imgR"
            }
        ],
        "url": 2021
    },
    {
        "nl_input": "what can iterators be iterated only once in python",
        "code_input": [
            {
                "url": 1630,
                "code": "def peekiter(iterable): it = iter(iterable) one = next(it) def gen(): \"\"\"Generator that returns first and proxy other items from source\"\"\" yield one while True: yield next(it) return (one, gen())"
            },
            {
                "url": 1973,
                "code": "def iterate(obj): global next, Iteration next = next Iteration = Iteration total = len(obj) if isinstance(obj, Sized) else None iterator = iter(obj) first = True last = False i = 0 try: value = next(iterator) except StopIteration: return while True: try: next_value = next(iterator) except StopIteration: last = True yield Iteration(first, last, i, total, value) if last: return value = next_value i += 1 first = False"
            },
            {
                "url": 5341,
                "code": "def assert_single_element(iterable): it = iter(iterable) first_item = next(it) try: next(it) except StopIteration: return first_item raise ValueError(\"iterable {!r} has more than one element.\".format(iterable))"
            },
            {
                "url": 5615,
                "code": "def iterate_items(dictish): if hasattr(dictish, 'iteritems'): return dictish.iteritems() if hasattr(dictish, 'items'): return dictish.items() return dictish"
            },
            {
                "url": 5835,
                "code": "def __iter__(self): def generator(): for i, obj in enumerate(self._sequence): if i >= self._limit: break yield obj raise StopIteration return generator"
            },
            {
                "url": 5252,
                "code": "def fromiterable(cls, itr): x, y, z = itr return cls(x, y, z)"
            },
            {
                "url": 1757,
                "code": "def items(iterable): if hasattr(iterable, 'iteritems'): return (p for p in iterable.iteritems()) elif hasattr(iterable, 'items'): return (p for p in iterable.items()) else: return (p for p in enumerate(iterable))"
            },
            {
                "url": 5721,
                "code": "def butlast(iterable): iterable = iter(iterable) try: first = next(iterable) except StopIteration: return for second in iterable: yield first first = second"
            },
            {
                "url": 570,
                "code": "def force_iterable(f): def wrapper(*args, **kwargs): r = f(*args, **kwargs) if hasattr(r, '__iter__'): return r else: return [r] return wrapper"
            },
            {
                "url": 4591,
                "code": "def unique(iterable): seen = set() for item in iterable: if item not in seen: seen.add(item) yield item"
            },
            {
                "url": 699,
                "code": "def iter_with_last(iterable): # Ensure it's an iterator and get the first field iterable = iter(iterable) prev = next(iterable) for item in iterable: # Lag by one item so I know I'm not at the end yield False, prev prev = item # Last item yield True, prev"
            },
            {
                "url": 2638,
                "code": "def ibatch(iterable, size): source = iter(iterable) while True: batch = itertools.islice(source, size) yield itertools.chain([next(batch)], batch)"
            },
            {
                "url": 3730,
                "code": "def flatten( iterables ): for it in iterables: if isinstance(it, str): yield it else: for element in it: yield element"
            },
            {
                "url": 4337,
                "code": "def chunks(iterable, size=1): iterator = iter(iterable) for element in iterator: yield chain([element], islice(iterator, size - 1))"
            },
            {
                "url": 5655,
                "code": "def _izip(*iterables): # This izip routine is from itertools # izip('ABCD', 'xy') --> Ax By iterators = map(iter, iterables) while iterators: yield tuple(map(next, iterators))"
            }
        ],
        "url": 2052
    },
    {
        "nl_input": "remove all characters in string in python",
        "code_input": [
            {
                "url": 839,
                "code": "def remove_bad(string): remove = [':', ',', '(', ')', ' ', '|', ';', '\\''] for c in remove: string = string.replace(c, '_') return string"
            },
            {
                "url": 1217,
                "code": "def drop_bad_characters(text): # Strip all non-ascii and non-printable characters text = ''.join([c for c in text if c in ALLOWED_CHARS]) return text"
            },
            {
                "url": 3553,
                "code": "def remove_from_string(string, values): for v in values: string = string.replace(v, '') return string"
            },
            {
                "url": 4904,
                "code": "def remove_unsafe_chars(text): if isinstance(text, six.string_types): text = UNSAFE_RE.sub('', text) return text"
            },
            {
                "url": 1651,
                "code": "def _clean_str(self, s): return s.translate(str.maketrans('', '', punctuation)).replace('\\u200b', \" \").strip().lower()"
            },
            {
                "url": 1838,
                "code": "def unpunctuate(s, *, char_blacklist=string.punctuation): # remove punctuation s = \"\".join(c for c in s if c not in char_blacklist) # remove consecutive spaces return \" \".join(filter(None, s.split(\" \")))"
            },
            {
                "url": 1443,
                "code": "def _RemoveIllegalXMLCharacters(self, xml_string): if not isinstance(xml_string, py2to3.STRING_TYPES): return xml_string return self._ILLEGAL_XML_RE.sub('\\ufffd', xml_string)"
            },
            {
                "url": 4585,
                "code": "def remove_accent_string(string): return utils.join([add_accent_char(c, Accent.NONE) for c in string])"
            },
            {
                "url": 5486,
                "code": "def preprocess(string): string = unicode(string, encoding=\"utf-8\") # convert diacritics to simpler forms string = regex1.sub(lambda x: accents[x.group()], string) # remove all rest of the unwanted characters return regex2.sub('', string).encode('utf-8')"
            },
            {
                "url": 2573,
                "code": "def clean(self, text): return ''.join([c for c in text if c in self.alphabet])"
            },
            {
                "url": 3796,
                "code": "def clean_strings(iterable): retval = [] for val in iterable: try: retval.append(val.strip()) except(AttributeError): retval.append(val) return retval"
            },
            {
                "url": 3935,
                "code": "def _remove_nonascii(self, df): df_copy = df.copy(deep=True) for col in df_copy.columns: if (df_copy[col].dtype == np.dtype('O')): df_copy[col] = df[col].apply( lambda x: re.sub(r'[^\\x00-\\x7f]', r'', x) if isinstance(x, six.string_types) else x) return df_copy"
            },
            {
                "url": 1117,
                "code": "def normalise_string(string): string = (string.strip()).lower() return re.sub(r'\\W+', '_', string)"
            },
            {
                "url": 3346,
                "code": "def strip_accents(string): return u''.join( (character for character in unicodedata.normalize('NFD', string) if unicodedata.category(character) != 'Mn'))"
            },
            {
                "url": 1354,
                "code": "def safe_unicode(string): if not PY3: uni = string.replace(u'\\u2019', \"'\") return uni.encode('utf-8') return string"
            }
        ],
        "url": 1217
    },
    {
        "nl_input": "python circle in a square bitmap array",
        "code_input": [
            {
                "url": 2951,
                "code": "def circles_pycairo(width, height, color): cairo_color = color / rgb(255, 255, 255) surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, width, height) ctx = cairo.Context(surface) # draw a circle in the center ctx.new_path() ctx.set_source_rgb(cairo_color.red, cairo_color.green, cairo_color.blue) ctx.arc(width / 2, height / 2, width / 2, 0, 2 * pi) ctx.fill() surface.write_to_png('circles.png')"
            },
            {
                "url": 5259,
                "code": "def round_corner(radius, fill): corner = Image.new('L', (radius, radius), 0) # (0, 0, 0, 0)) draw = ImageDraw.Draw(corner) draw.pieslice((0, 0, radius * 2, radius * 2), 180, 270, fill=fill) return corner"
            },
            {
                "url": 4850,
                "code": "def getBitmap(self): return PlatformManager.getBitmapFromRect(self.x, self.y, self.w, self.h)"
            },
            {
                "url": 3568,
                "code": "def border(self): border_array = self.bitmap - self.inner.bitmap return Region(border_array)"
            },
            {
                "url": 1716,
                "code": "def Square(x, a, b, c): return a * x ** 2 + b * x + c"
            },
            {
                "url": 4663,
                "code": "def new(self, size, fill): return Image(PIL.Image.new(\"RGB\", size, fill))"
            },
            {
                "url": 1016,
                "code": "def create_ellipse(width,height,angle): angle = angle / 180.0 * np.pi thetas = np.linspace(0,2*np.pi,200) a = width / 2.0 b = height / 2.0 x = a*np.cos(thetas)*np.cos(angle) - b*np.sin(thetas)*np.sin(angle) y = a*np.cos(thetas)*np.sin(angle) + b*np.sin(thetas)*np.cos(angle) z = np.zeros(thetas.shape) return np.vstack((x,y,z)).T"
            },
            {
                "url": 1518,
                "code": "def setPixel(self, x, y, color): return _fitz.Pixmap_setPixel(self, x, y, color)"
            },
            {
                "url": 1241,
                "code": "def is_square_matrix(mat): mat = np.array(mat) if mat.ndim != 2: return False shape = mat.shape return shape[0] == shape[1]"
            },
            {
                "url": 2082,
                "code": "def poke_array(self, store, name, elemtype, elements, container, visited, _stack): raise NotImplementedError"
            },
            {
                "url": 1993,
                "code": "def rotateImage(image, angle): image = [list(row) for row in image] for n in range(angle % 4): image = list(zip(*image[::-1])) return image"
            },
            {
                "url": 613,
                "code": "def crop_box(im, box=False, **kwargs): if box: im = im.crop(box) return im"
            },
            {
                "url": 827,
                "code": "def qr(self,text): qr_code = qrcode.QRCode(version=4, box_size=4, border=1) qr_code.add_data(text) qr_code.make(fit=True) qr_img = qr_code.make_image() im = qr_img._img.convert(\"RGB\") # Convert the RGB image in printable image self._convert_image(im)"
            },
            {
                "url": 1487,
                "code": "def round_array(array_in): if isinstance(array_in, ndarray): return np.round(array_in).astype(int) else: return int(np.round(array_in))"
            },
            {
                "url": 5849,
                "code": "def arcball_map_to_sphere(point, center, radius): v0 = (point[0] - center[0]) / radius v1 = (center[1] - point[1]) / radius n = v0*v0 + v1*v1 if n > 1.0: # position outside of sphere n = math.sqrt(n) return numpy.array([v0/n, v1/n, 0.0]) else: return numpy.array([v0, v1, math.sqrt(1.0 - n)])"
            }
        ],
        "url": 4850
    },
    {
        "nl_input": "location of maya python exe",
        "code_input": [
            {
                "url": 4771,
                "code": "def setup_environment(): osinter = ostool.get_interface() pypath = osinter.get_maya_envpath() for p in sys.path: pypath = os.pathsep.join((pypath, p)) os.environ['PYTHONPATH'] = pypath"
            },
            {
                "url": 5826,
                "code": "def _find_conda(): if 'CONDA_EXE' in os.environ: conda = os.environ['CONDA_EXE'] else: conda = util.which('conda') return conda"
            },
            {
                "url": 668,
                "code": "def get_python(): if sys.platform == 'win32': python = path.join(VE_ROOT, 'Scripts', 'python.exe') else: python = path.join(VE_ROOT, 'bin', 'python') return python"
            },
            {
                "url": 1156,
                "code": "def _python_rpath(self): # Windows virtualenv installation installs pip to the [Ss]cripts # folder. Here's a simple check to support: if sys.platform == 'win32': return os.path.join('Scripts', 'python.exe') return os.path.join('bin', 'python')"
            },
            {
                "url": 5082,
                "code": "def home_lib(home): if hasattr(sys, 'pypy_version_info'): lib = 'site-packages' else: lib = os.path.join('lib', 'python') return os.path.join(home, lib)"
            },
            {
                "url": 1289,
                "code": "def get_java_path(): java_home = os.environ.get(\"JAVA_HOME\") return os.path.join(java_home, BIN_DIR, \"java\")"
            },
            {
                "url": 2786,
                "code": "def install_rpm_py(): python_path = sys.executable cmd = '{0} install.py'.format(python_path) exit_status = os.system(cmd) if exit_status != 0: raise Exception('Command failed: {0}'.format(cmd))"
            },
            {
                "url": 2077,
                "code": "def executable_exists(executable): for directory in os.getenv(\"PATH\").split(\":\"): if os.path.exists(os.path.join(directory, executable)): return True return False"
            },
            {
                "url": 6255,
                "code": "def require(executable: str, explanation: str = \"\") -> None: assert shutil.which(executable), \"Need {!r} on the PATH.{}\".format( executable, \"\\n\" + explanation if explanation else \"\")"
            },
            {
                "url": 1617,
                "code": "def inside_softimage(): try: import maya return False except ImportError: pass try: from win32com.client import Dispatch as disp disp('XSI.Application') return True except: return False"
            },
            {
                "url": 2280,
                "code": "def check_version(): if sys.version_info[0:3] == PYTHON_VERSION_INFO[0:3]: return sys.exit( ansi.error() + ' your virtual env points to the wrong python version. ' 'This is likely because you used a python installer that clobbered ' 'the system installation, which breaks virtualenv creation. ' 'To fix, check this symlink, and delete the installation of python ' 'that it is brokenly pointing to, then delete the virtual env itself ' 'and rerun lore install: ' + os.linesep + os.linesep + BIN_PYTHON + os.linesep )"
            },
            {
                "url": 1154,
                "code": "def GetPythonLibraryDirectoryPath(): path = sysconfig.get_python_lib(True) _, _, path = path.rpartition(sysconfig.PREFIX) if path.startswith(os.sep): path = path[1:] return path"
            },
            {
                "url": 341,
                "code": "def make_executable(script_path): status = os.stat(script_path) os.chmod(script_path, status.st_mode | stat.S_IEXEC)"
            },
            {
                "url": 1916,
                "code": "def getScriptLocation(): location = os.path.abspath(\"./\") if __file__.rfind(\"/\") != -1: location = __file__[:__file__.rfind(\"/\")] return location"
            },
            {
                "url": 1746,
                "code": "def import_js(path, lib_name, globals): with codecs.open(path_as_local(path), \"r\", \"utf-8\") as f: js = f.read() e = EvalJs() e.execute(js) var = e.context['var'] globals[lib_name] = var.to_python()"
            }
        ],
        "url": 4771
    },
    {
        "nl_input": "how to make letters uppercase in python skipping spaces",
        "code_input": [
            {
                "url": 5661,
                "code": "def uppercase_chars(string: any) -> str: return ''.join([c if c.isupper() else '' for c in str(string)])"
            },
            {
                "url": 5588,
                "code": "def lowercase_chars(string: any) -> str: return ''.join([c if c.islower() else '' for c in str(string)])"
            },
            {
                "url": 5614,
                "code": "def _lower(string): if not string: return \"\" new_string = [string[0].lower()] for char in string[1:]: if char.isupper(): new_string.append(\"_\") new_string.append(char.lower()) return \"\".join(new_string)"
            },
            {
                "url": 3327,
                "code": "def clean(some_string, uppercase=False): if uppercase: return some_string.strip().upper() else: return some_string.strip().lower()"
            },
            {
                "url": 718,
                "code": "def camel_case_from_underscores(string): components = string.split('_') string = '' for component in components: string += component[0].upper() + component[1:] return string"
            },
            {
                "url": 5981,
                "code": "def capitalize(string): if not string: return string if len(string) == 1: return string.upper() return string[0].upper() + string[1:].lower()"
            },
            {
                "url": 3244,
                "code": "def camelcase(string): string = re.sub(r\"^[\\-_\\.]\", '', str(string)) if not string: return string return lowercase(string[0]) + re.sub(r\"[\\-_\\.\\s]([a-z])\", lambda matched: uppercase(matched.group(1)), string[1:])"
            },
            {
                "url": 5595,
                "code": "def lower_camel_case_from_underscores(string): components = string.split('_') string = components[0] for component in components[1:]: string += component[0].upper() + component[1:] return string"
            },
            {
                "url": 878,
                "code": "def upcaseTokens(s,l,t): return [ tt.upper() for tt in map(_ustr,t) ]"
            },
            {
                "url": 2591,
                "code": "def camel_to_underscore(string): string = FIRST_CAP_RE.sub(r'\\1_\\2', string) return ALL_CAP_RE.sub(r'\\1_\\2', string).lower()"
            },
            {
                "url": 1254,
                "code": "def _make_sentence(txt): #Make sure first letter is capitalized txt = txt.strip(' ') txt = txt[0].upper() + txt[1:] + '.' return txt"
            },
            {
                "url": 124,
                "code": "def to_pascal_case(s): return re.sub(r'(?!^)_([a-zA-Z])', lambda m: m.group(1).upper(), s.capitalize())"
            },
            {
                "url": 4677,
                "code": "def camelcase2list(s, lower=False): s = re.findall(r'([A-Z][a-z0-9]+)', s) return [w.lower() for w in s] if lower else s"
            },
            {
                "url": 2571,
                "code": "def camelcase_underscore(name): s1 = re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', name) return re.sub('([a-z0-9])([A-Z])', r'\\1_\\2', s1).lower()"
            },
            {
                "url": 1566,
                "code": "def _to_lower_alpha_only(s): s = re.sub(r'\\n', ' ', s.lower()) return re.sub(r'[^a-z\\s]', '', s)"
            }
        ],
        "url": 5661
    },
    {
        "nl_input": "python delete element from set",
        "code_input": [
            {
                "url": 1114,
                "code": "def discard(self, element): try: i = int(element) set.discard(self, i) except ValueError: pass"
            },
            {
                "url": 5741,
                "code": "def remove_once(gset, elem): remove = getattr(gset, 'remove', None) if remove is not None: remove(elem) else: del gset[elem] return elem"
            },
            {
                "url": 4062,
                "code": "def __delitem__(self, key): index, value = self._dict.pop(key) key2, value2 = self._list.pop(index) assert key == key2 assert value is value2 self._fix_indices_after_delete(index)"
            },
            {
                "url": 4874,
                "code": "def __delitem__ (self, key): self._keys.remove(key) super(ListDict, self).__delitem__(key)"
            },
            {
                "url": 3147,
                "code": "def isolate_element(self, x): members = list(self.members(x)) self.delete_set(x) self.union(*(v for v in members if v != x))"
            },
            {
                "url": 5165,
                "code": "def remove_element(self, e): if e.label is not None: self.elementdict.pop(e.label) self.elementlist.remove(e)"
            },
            {
                "url": 1019,
                "code": "def pop(self, index=-1): value = self._list.pop(index) del self._dict[value] return value"
            },
            {
                "url": 278,
                "code": "def remove_duplicates(lst): dset = set() return [l for l in lst if l not in dset and not dset.add(l)]"
            },
            {
                "url": 1950,
                "code": "def wipe(self): keys = list(self.keys()).copy() for key in keys: self.delete(key)"
            },
            {
                "url": 3073,
                "code": "def delete(self, row): i = self._get_key_index(row) del self.keys[i]"
            },
            {
                "url": 3146,
                "code": "def pop (self, key): if key in self._keys: self._keys.remove(key) super(ListDict, self).pop(key)"
            },
            {
                "url": 2569,
                "code": "def _delete_keys(dct, keys): c = deepcopy(dct) assert isinstance(keys, list) for k in keys: c.pop(k) return c"
            },
            {
                "url": 4422,
                "code": "def DeleteIndex(self, index): to_remove = None for i in self.Items: if i.index == index: to_remove = i if to_remove: self.Items.remove(to_remove)"
            },
            {
                "url": 2335,
                "code": "def delete_entry(self, key): pipe = self.client.pipeline() pipe.srem(self.keys_container, key) pipe.delete(key) pipe.execute()"
            },
            {
                "url": 1015,
                "code": "def rm_keys_from_dict(d, keys): # Loop for each key given for key in keys: # Is the key in the dictionary? if key in d: try: d.pop(key, None) except KeyError: # Not concerned with an error. Keep going. pass return d"
            }
        ],
        "url": 5741
    },
    {
        "nl_input": "python get current git branch",
        "code_input": [
            {
                "url": 2885,
                "code": "def get_current_branch(): cmd = [\"git\", \"rev-parse\", \"--abbrev-ref\", \"HEAD\"] output = subprocess.check_output(cmd, stderr=subprocess.STDOUT) return output.strip().decode(\"utf-8\")"
            },
            {
                "url": 1869,
                "code": "def get_git_branch(git_path='git'): branch_match = call((git_path, 'rev-parse', '--symbolic-full-name', 'HEAD')) if branch_match == \"HEAD\": return None else: return os.path.basename(branch_match)"
            },
            {
                "url": 1932,
                "code": "def branches(self): result = self.git(self.default + ['branch', '-a', '--no-color']) return [l.strip(' *\\n') for l in result.split('\\n') if l.strip(' *\\n')]"
            },
            {
                "url": 2666,
                "code": "def is_git_repo(): cmd = \"git\", \"rev-parse\", \"--git-dir\" try: subprocess.run(cmd, stdout=subprocess.DEVNULL, check=True) return True except subprocess.CalledProcessError: return False"
            },
            {
                "url": 6051,
                "code": "def branches(): # type: () -> List[str] out = shell.run( 'git branch', capture=True, never_pretend=True ).stdout.strip() return [x.strip('* \\t\\n') for x in out.splitlines()]"
            },
            {
                "url": 632,
                "code": "def check_git(): try: with open(os.devnull, \"wb\") as devnull: subprocess.check_call([\"git\", \"--version\"], stdout=devnull, stderr=devnull) except: raise RuntimeError(\"Please make sure git is installed and on your path.\")"
            },
            {
                "url": 421,
                "code": "def get_last_commit(git_path=None): if git_path is None: git_path = GIT_PATH line = get_last_commit_line(git_path) revision_id = line.split()[1] return revision_id"
            },
            {
                "url": 4425,
                "code": "def mkhead(repo, path): return git.Head(repo, git.Head.to_full_path(path))"
            },
            {
                "url": 3564,
                "code": "def get_last_commit_line(git_path=None): if git_path is None: git_path = GIT_PATH output = check_output([git_path, \"log\", \"--pretty=format:'%ad %h %s'\", \"--date=short\", \"-n1\"]) return output.strip()[1:-1]"
            },
            {
                "url": 5593,
                "code": "def last_commit(self) -> Tuple: from libs.repos import git return git.get_last_commit(repo_path=self.path)"
            },
            {
                "url": 5575,
                "code": "def get_versions(reporev=True): import sys import platform import qtpy import qtpy.QtCore revision = None if reporev: from spyder.utils import vcs revision, branch = vcs.get_git_revision(os.path.dirname(__dir__)) if not sys.platform == 'darwin': # To avoid a crash with our Mac app system = platform.system() else: system = 'Darwin' return { 'spyder': __version__, 'python': platform.python_version(), # \"2.7.3\" 'bitness': 64 if sys.maxsize > 2**32 else 32, 'qt': qtpy.QtCore.__version__, 'qt_api': qtpy.API_NAME, # PyQt5 'qt_api_ver': qtpy.PYQT_VERSION, 'system': system, # Linux, Windows, ... 'release': platform.release(), # XP, 10.6, 2.2.0, etc. 'revision': revision, # '9fdf926eccce' }"
            },
            {
                "url": 2068,
                "code": "def is_changed(): executed, changed_lines = execute_git('status --porcelain', output=False) merge_not_finished = mod_path.exists('.git/MERGE_HEAD') return changed_lines.strip() or merge_not_finished"
            },
            {
                "url": 4078,
                "code": "def install_plugin(username, repo): print(\"Installing plugin from \" + username + \"/\" + repo) pip.main(['install', '-U', \"git+git://github.com/\" + username + \"/\" + repo + \".git\"])"
            },
            {
                "url": 3189,
                "code": "def fetch_hg_push_log(repo_name, repo_url): newrelic.agent.add_custom_parameter(\"repo_name\", repo_name) process = HgPushlogProcess() process.run(repo_url + '/json-pushes/?full=1&version=2', repo_name)"
            },
            {
                "url": 6202,
                "code": "def _get_latest_version(): url = 'https://api.github.com/repos/{}/releases/latest'.format(constants.DUSTY_GITHUB_PATH) conn = urllib.urlopen(url) if conn.getcode() >= 300: raise RuntimeError('GitHub api returned code {}; can\\'t determine latest version. Aborting'.format(conn.getcode())) json_data = conn.read() return json.loads(json_data)['tag_name']"
            }
        ],
        "url": 421
    },
    {
        "nl_input": "how to make a restart button using python",
        "code_input": [
            {
                "url": 3830,
                "code": "def restart_program(): python = sys.executable os.execl(python, python, * sys.argv)"
            },
            {
                "url": 1167,
                "code": "def restart(self, reset=False): # Get start path to use in restart script spyder_start_directory = get_module_path('spyder') restart_script = osp.join(spyder_start_directory, 'app', 'restart.py') # Get any initial argument passed when spyder was started # Note: Variables defined in bootstrap.py and spyder/app/start.py env = os.environ.copy() bootstrap_args = env.pop('SPYDER_BOOTSTRAP_ARGS', None) spyder_args = env.pop('SPYDER_ARGS') # Get current process and python running spyder pid = os.getpid() python = sys.executable # Check if started with bootstrap.py if bootstrap_args is not None: spyder_args = bootstrap_args is_bootstrap = True else: is_bootstrap = False # Pass variables as environment variables (str) to restarter subprocess env['SPYDER_ARGS'] = spyder_args env['SPYDER_PID'] = str(pid) env['SPYDER_IS_BOOTSTRAP'] = str(is_bootstrap) env['SPYDER_RESET'] = str(reset) if DEV: if os.name == 'nt': env['PYTHONPATH'] = ';'.join(sys.path) else: env['PYTHONPATH'] = ':'.join(sys.path) # Build the command and popen arguments depending on the OS if os.name == 'nt': # Hide flashing command prompt startupinfo = subprocess.STARTUPINFO() startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW shell = False else: startupinfo = None shell = True command = '\"{0}\" \"{1}\"' command = command.format(python, restart_script) try: if self.closing(True): subprocess.Popen(command, shell=shell, env=env, startupinfo=startupinfo) self.console.quit() except Exception as error: # If there is an error with subprocess, Spyder should not quit and # the error can be inspected in the internal console print(error) # spyder: test-skip print(command)"
            },
            {
                "url": 1122,
                "code": "async def restart(request): def wait_and_restart(): log.info('Restarting server') sleep(1) os.system('kill 1') Thread(target=wait_and_restart).start() return web.json_response({\"message\": \"restarting\"})"
            },
            {
                "url": 2293,
                "code": "def do_restart(self, line): self.application.master.Restart(opendnp3.RestartType.COLD, restart_callback)"
            },
            {
                "url": 5077,
                "code": "def do_restart(self, line): self.bot._frame = 0 self.bot._namespace.clear() self.bot._namespace.update(self.bot._initial_namespace)"
            },
            {
                "url": 4804,
                "code": "def reload(self, save_config=True): if save_config: self.device.send(\"copy running-config startup-config\") self.device(\"reload\", wait_for_string=\"This command will reboot the system\") self.device.ctrl.sendline(\"y\")"
            },
            {
                "url": 1192,
                "code": "def stop_button_click_handler(self): self.stop_button.setDisabled(True) # Interrupt computations or stop debugging if not self.shellwidget._reading: self.interrupt_kernel() else: self.shellwidget.write_to_stdin('exit')"
            },
            {
                "url": 2786,
                "code": "def install_rpm_py(): python_path = sys.executable cmd = '{0} install.py'.format(python_path) exit_status = os.system(cmd) if exit_status != 0: raise Exception('Command failed: {0}'.format(cmd))"
            },
            {
                "url": 5109,
                "code": "def do_quit(self, arg): for name, fh in self._backup: setattr(sys, name, fh) self.console.writeline('*** Aborting program ***\\n') self.console.flush() self.console.close() WebPdb.active_instance = None return Pdb.do_quit(self, arg)"
            },
            {
                "url": 4339,
                "code": "def pause(msg=\"Press Enter to Continue...\"): print('\\n' + Fore.YELLOW + msg + Fore.RESET, end='') input()"
            },
            {
                "url": 4063,
                "code": "def restore_button_state(self): self.parent.pbnNext.setEnabled(self.next_button_state) self.parent.pbnBack.setEnabled(self.back_button_state)"
            },
            {
                "url": 859,
                "code": "def quit(self): self.script.LOG.warn(\"Abort due to user choice!\") sys.exit(self.QUIT_RC)"
            },
            {
                "url": 76,
                "code": "def reloader_thread(softexit=False): while RUN_RELOADER: if code_changed(): # force reload if softexit: sys.exit(3) else: os._exit(3) time.sleep(1)"
            },
            {
                "url": 4533,
                "code": "def launch_server(): print(os.path.dirname(os.path.abspath(__file__))) cur_dir = os.getcwd() path = os.path.dirname(os.path.abspath(__file__)) run = True os.chdir(path) os.system('python manage.py runserver --nostatic') os.chdir(cur_dir)"
            },
            {
                "url": 4457,
                "code": "def _load_autoreload_magic(self): from IPython.core.getipython import get_ipython try: get_ipython().run_line_magic('reload_ext', 'autoreload') get_ipython().run_line_magic('autoreload', '2') except Exception: pass"
            }
        ],
        "url": 2293
    },
    {
        "nl_input": "tracing python code execution",
        "code_input": [
            {
                "url": 900,
                "code": "def set_trace(): # https://github.com/nose-devs/nose/blob/master/nose/tools/nontrivial.py pdb.Pdb(stdout=sys.__stdout__).set_trace(sys._getframe().f_back)"
            },
            {
                "url": 899,
                "code": "def debug_on_error(type, value, tb): traceback.print_exc(type, value, tb) print() pdb.pm()"
            },
            {
                "url": 477,
                "code": "def runcode(code): for line in code: print('# '+line) exec(line,globals()) print('# return ans') return ans"
            },
            {
                "url": 4023,
                "code": "def _trace_full (frame, event, arg): if event == \"line\": _trace_line(frame, event, arg) else: _trace(frame, event, arg) return _trace_full"
            },
            {
                "url": 2799,
                "code": "def __run(self): sys.settrace(self.globaltrace) self.__run_backup() self.run = self.__run_backup"
            },
            {
                "url": 924,
                "code": "def print_trace(self): traceback.print_exc() for tb in self.tracebacks: print tb, print ''"
            },
            {
                "url": 586,
                "code": "def debug_src(src, pm=False, globs=None): testsrc = script_from_examples(src) debug_script(testsrc, pm, globs)"
            },
            {
                "url": 2590,
                "code": "def from_traceback(cls, tb): while tb.tb_next: tb = tb.tb_next return cls(tb.tb_frame.f_code, current_offset=tb.tb_lasti)"
            },
            {
                "url": 1291,
                "code": "def test_python_java_rt(): sub_env = {'PYTHONPATH': _build_dir()} log.info('Executing Python unit tests (against Java runtime classes)...') return jpyutil._execute_python_scripts(python_java_rt_tests, env=sub_env)"
            },
            {
                "url": 676,
                "code": "def IPYTHON_MAIN(): import pkg_resources runner_frame = inspect.getouterframes(inspect.currentframe())[-2] return ( getattr(runner_frame, \"function\", None) == pkg_resources.load_entry_point(\"ipython\", \"console_scripts\", \"ipython\").__name__ )"
            },
            {
                "url": 2274,
                "code": "def seq(): current_frame = inspect.currentframe().f_back trace_string = \"\" while current_frame.f_back: trace_string = trace_string + current_frame.f_back.f_code.co_name current_frame = current_frame.f_back return counter.get_from_trace(trace_string)"
            },
            {
                "url": 3744,
                "code": "def debug(ftn, txt): if debug_p: sys.stdout.write(\"{0}.{1}:{2}\\n\".format(modname, ftn, txt)) sys.stdout.flush()"
            },
            {
                "url": 1415,
                "code": "def get_code(module): fp = open(module.path) try: return compile(fp.read(), str(module.name), 'exec') finally: fp.close()"
            },
            {
                "url": 4941,
                "code": "def _extract_traceback(start): tb = sys.exc_info()[2] for i in range(start): tb = tb.tb_next return _parse_traceback(tb)"
            },
            {
                "url": 4529,
                "code": "def code(self): return compile(self.source(), self.full_path, 'exec', flags=0, dont_inherit=True)"
            }
        ],
        "url": 2799
    },
    {
        "nl_input": "delete pyc files from python script",
        "code_input": [
            {
                "url": 2576,
                "code": "def clean_py_files(path): for dirname, subdirlist, filelist in os.walk(path): for f in filelist: if f.endswith('py'): os.remove(os.path.join(dirname, f))"
            },
            {
                "url": 4126,
                "code": "def clean(dry_run='n'): file_patterns = ['*.pyc', '*.pyo', '*~'] dir_patterns = ['__pycache__'] recursive_pattern_delete(project_paths.root, file_patterns, dir_patterns, dry_run=bool(dry_run.lower() == 'y'))"
            },
            {
                "url": 2279,
                "code": "def clean(): run('rm -rf build/') run('rm -rf dist/') run('rm -rf puzzle.egg-info') run('find . -name __pycache__ -delete') run('find . -name *.pyc -delete') run('find . -name *.pyo -delete') run('find . -name *~ -delete') log.info('cleaned up')"
            },
            {
                "url": 145,
                "code": "def delete_all_eggs(self): path_to_delete = os.path.join(self.egg_directory, \"lib\", \"python\") if os.path.exists(path_to_delete): shutil.rmtree(path_to_delete)"
            },
            {
                "url": 4073,
                "code": "def load_files(files): for py_file in files: LOG.debug(\"exec %s\", py_file) execfile(py_file, globals(), locals())"
            },
            {
                "url": 836,
                "code": "def _delete_local(self, filename): if os.path.exists(filename): os.remove(filename)"
            },
            {
                "url": 2894,
                "code": "def cleanup(self): for file in glob.glob(self.basename + '*'): os.unlink(file)"
            },
            {
                "url": 4368,
                "code": "def search_script_directory(self, path): for subdir, dirs, files in os.walk(path): for file_name in files: if file_name.endswith(\".py\"): self.search_script_file(subdir, file_name)"
            },
            {
                "url": 5041,
                "code": "def __del__(self): if self._delete_file: try: os.remove(self.name) except (OSError, IOError): pass"
            },
            {
                "url": 2188,
                "code": "def safe_delete(filename): try: os.unlink(filename) except OSError as e: if e.errno != errno.ENOENT: raise"
            },
            {
                "url": 4963,
                "code": "def cli(ctx, project_dir): exit_code = SCons(project_dir).clean() ctx.exit(exit_code)"
            },
            {
                "url": 4103,
                "code": "def make_code_from_py(filename): # Open the source file. try: source_file = open_source(filename) except IOError: raise NoSource(\"No file to run: %r\" % filename) try: source = source_file.read() finally: source_file.close() # We have the source. `compile` still needs the last line to be clean, # so make sure it is, then compile a code object from it. if not source or source[-1] != '\\n': source += '\\n' code = compile(source, filename, \"exec\") return code"
            },
            {
                "url": 6021,
                "code": "def _cleanup(path: str) -> None: if os.path.isdir(path): shutil.rmtree(path)"
            },
            {
                "url": 668,
                "code": "def get_python(): if sys.platform == 'win32': python = path.join(VE_ROOT, 'Scripts', 'python.exe') else: python = path.join(VE_ROOT, 'bin', 'python') return python"
            },
            {
                "url": 211,
                "code": "def delete(build_folder): if _meta_.del_build in [\"on\", \"ON\"] and os.path.exists(build_folder): shutil.rmtree(build_folder)"
            }
        ],
        "url": 4126
    },
    {
        "nl_input": "sleep holding up python",
        "code_input": [
            {
                "url": 3815,
                "code": "def sleep(self, time): try: task = asyncio.ensure_future(self.core.sleep(time)) self.loop.run_until_complete(task) except asyncio.CancelledError: pass except RuntimeError: pass"
            },
            {
                "url": 645,
                "code": "def main(idle): while True: LOG.debug(\"Sleeping for {0} seconds.\".format(idle)) time.sleep(idle)"
            },
            {
                "url": 2623,
                "code": "async def wait_and_quit(loop): from pylp.lib.tasks import running if running: await asyncio.wait(map(lambda runner: runner.future, running))"
            },
            {
                "url": 5360,
                "code": "def wait_run_in_executor(func, *args, **kwargs): loop = asyncio.get_event_loop() future = loop.run_in_executor(None, functools.partial(func, *args, **kwargs)) yield from asyncio.wait([future]) return future.result()"
            },
            {
                "url": 4005,
                "code": "def wait_and_join(self, task): while not task.has_started: time.sleep(self._polling_time) task.thread.join()"
            },
            {
                "url": 5728,
                "code": "async def async_run(self) -> None: self.main_task = self.loop.create_task(self.main()) await self.main_task"
            },
            {
                "url": 6011,
                "code": "def wait_for_shutdown_signal( self, please_stop=False, # ASSIGN SIGNAL TO STOP EARLY allow_exit=False, # ALLOW \"exit\" COMMAND ON CONSOLE TO ALSO STOP THE APP wait_forever=True # IGNORE CHILD THREADS, NEVER EXIT. False => IF NO CHILD THREADS LEFT, THEN EXIT ): self_thread = Thread.current() if self_thread != MAIN_THREAD or self_thread != self: Log.error(\"Only the main thread can sleep forever (waiting for KeyboardInterrupt)\") if isinstance(please_stop, Signal): # MUTUAL SIGNALING MAKES THESE TWO EFFECTIVELY THE SAME SIGNAL self.please_stop.on_go(please_stop.go) please_stop.on_go(self.please_stop.go) else: please_stop = self.please_stop if not wait_forever: # TRIGGER SIGNAL WHEN ALL CHILDREN THEADS ARE DONE with self_thread.child_lock: pending = copy(self_thread.children) children_done = AndSignals(please_stop, len(pending)) children_done.signal.on_go(self.please_stop.go) for p in pending: p.stopped.on_go(children_done.done) try: if allow_exit: _wait_for_exit(please_stop) else: _wait_for_interrupt(please_stop) except KeyboardInterrupt as _: Log.alert(\"SIGINT Detected! Stopping...\") except SystemExit as _: Log.alert(\"SIGTERM Detected! Stopping...\") finally: self.stop()"
            },
            {
                "url": 5005,
                "code": "def wait(self, timeout=None): if not self.__running: raise RuntimeError(\"ThreadPool ain't running\") self.__queue.wait(timeout)"
            },
            {
                "url": 4881,
                "code": "async def acquire_async(self): r = self.acquire(blocking=False) while not r: await asyncio.sleep(.01) r = self.acquire(blocking=False)"
            },
            {
                "url": 3844,
                "code": "def main(): time.sleep(1) with Input() as input_generator: for e in input_generator: print(repr(e))"
            },
            {
                "url": 318,
                "code": "def asynchronous(function, event): thread = Thread(target=synchronous, args=(function, event)) thread.daemon = True thread.start()"
            },
            {
                "url": 1223,
                "code": "def _wait_for_response(self): while not self.server.response_code: time.sleep(2) time.sleep(5) self.server.shutdown()"
            },
            {
                "url": 1122,
                "code": "async def restart(request): def wait_and_restart(): log.info('Restarting server') sleep(1) os.system('kill 1') Thread(target=wait_and_restart).start() return web.json_response({\"message\": \"restarting\"})"
            },
            {
                "url": 709,
                "code": "def wait_until_exit(self): if self._timeout is None: raise Exception(\"Thread will never exit. Use stop or specify timeout when starting it!\") self._thread.join() self.stop()"
            },
            {
                "url": 112,
                "code": "async def _thread_coro(self, *args): return await self._loop.run_in_executor( self._executor, self._function, *args)"
            }
        ],
        "url": 2206
    },
    {
        "nl_input": "traversal in tree in python",
        "code_input": [
            {
                "url": 4876,
                "code": "def map_tree(visitor, tree): newn = [map_tree(visitor, node) for node in tree.nodes] return visitor(tree, newn)"
            },
            {
                "url": 1282,
                "code": "def walk_tree(root): yield root for child in root.children: for el in walk_tree(child): yield el"
            },
            {
                "url": 4966,
                "code": "def to_tree(self): tree = TreeLibTree() for node in self: tree.create_node(node, node.node_id, parent=node.parent) return tree"
            },
            {
                "url": 4914,
                "code": "def load(cls, tree_path): with open(tree_path) as f: tree_dict = json.load(f) return cls.from_dict(tree_dict)"
            },
            {
                "url": 5626,
                "code": "def debugTreePrint(node,pfx=\"->\"): print pfx,node.item for c in node.children: debugTreePrint(c,\" \"+pfx)"
            },
            {
                "url": 1595,
                "code": "def print_tree(self, indent=2): config.LOGGER.info(\"{indent}{data}\".format(indent=\" \" * indent, data=str(self))) for child in self.children: child.print_tree(indent + 1)"
            },
            {
                "url": 1537,
                "code": "def as_tree(context): tree = _build_tree(context, 2, 1) if type(tree) == dict: tree = [tree] return Response(content_type='application/json', body=json.dumps(tree))"
            },
            {
                "url": 5339,
                "code": "def __iter__(self): for node in chain(*imap(iter, self.children)): yield node yield self"
            },
            {
                "url": 4427,
                "code": "def draw_tree(t, df, size=10, ratio=0.6, precision=0): s=export_graphviz(t, out_file=None, feature_names=df.columns, filled=True, special_characters=True, rotate=True, precision=precision) IPython.display.display(graphviz.Source(re.sub('Tree {', f'Tree {{ size={size}; ratio={ratio}', s)))"
            },
            {
                "url": 3110,
                "code": "def print_bintree(tree, indent=' '): for n in sorted(tree.keys()): print \"%s%s\" % (indent * depth(n,tree), n)"
            },
            {
                "url": 3414,
                "code": "def empty_tree(input_list): for item in input_list: if not isinstance(item, list) or not empty_tree(item): return False return True"
            },
            {
                "url": 3939,
                "code": "def dfs_recursive(graph, node, seen): seen[node] = True for neighbor in graph[node]: if not seen[neighbor]: dfs_recursive(graph, neighbor, seen)"
            },
            {
                "url": 680,
                "code": "def traverse_setter(obj, attribute, value): obj.traverse(lambda x: setattr(x, attribute, value))"
            },
            {
                "url": 4201,
                "code": "def get_tree_type(tree): tree_type = tree.label() assert tree_type in SUBTREE_TYPES, \"tree_type: {}\".format(tree_type) return tree_type"
            },
            {
                "url": 6163,
                "code": "def pruning(self, X, y, cost_mat): self.tree_.tree_pruned = copy.deepcopy(self.tree_.tree) if self.tree_.n_nodes > 0: self._pruning(X, y, cost_mat) nodes_pruned = self._nodes(self.tree_.tree_pruned) self.tree_.n_nodes_pruned = len(nodes_pruned)"
            }
        ],
        "url": 1282
    },
    {
        "nl_input": "timing a function call python",
        "code_input": [
            {
                "url": 3208,
                "code": "def timed_call(func, *args, log_level='DEBUG', **kwargs): start = time() r = func(*args, **kwargs) t = time() - start log(log_level, \"Call to '{}' took {:0.6f}s\".format(func.__name__, t)) return r"
            },
            {
                "url": 1781,
                "code": "def timedcall(executable_function, *args): time_start = time.clock(); result = executable_function(*args); time_end = time.clock(); return (time_end - time_start, result);"
            },
            {
                "url": 5785,
                "code": "def timeit(func, *args, **kwargs): start_time = time.time() res = func(*args, **kwargs) timing = time.time() - start_time return res, timing"
            },
            {
                "url": 717,
                "code": "def time(func, *args, **kwargs): start_time = time_module.time() func(*args, **kwargs) end_time = time_module.time() return end_time - start_time"
            },
            {
                "url": 2582,
                "code": "def time_func(func, name, *args, **kwargs): tic = time.time() out = func(*args, **kwargs) toc = time.time() print('%s took %0.2f seconds' % (name, toc - tic)) return out"
            },
            {
                "url": 5271,
                "code": "def timeit(self, metric, func, *args, **kwargs): return metrics.timeit(metric, func, *args, **kwargs)"
            },
            {
                "url": 6136,
                "code": "def timeit (func, log, limit): def newfunc (*args, **kwargs): \"\"\"Execute function and print execution time.\"\"\" t = time.time() res = func(*args, **kwargs) duration = time.time() - t if duration > limit: print(func.__name__, \"took %0.2f seconds\" % duration, file=log) print(args, file=log) print(kwargs, file=log) return res return update_func_meta(newfunc, func)"
            },
            {
                "url": 4375,
                "code": "def timeit(method): def timed(*args, **kw): time_start = time.time() result = method(*args, **kw) time_end = time.time() print('timeit: %r %2.2f sec (%r, %r) ' % (method.__name__, time_end-time_start, str(args)[:20], kw)) return result return timed"
            },
            {
                "url": 710,
                "code": "def timed (log=sys.stderr, limit=2.0): return lambda func: timeit(func, log, limit)"
            },
            {
                "url": 1323,
                "code": "def set(self, f): self.stop() self._create_timer(f) self.start()"
            },
            {
                "url": 1491,
                "code": "def __call__(self, func, *args, **kwargs): return self.run(func, *args, **kwargs)"
            },
            {
                "url": 4326,
                "code": "def run_test(func, fobj): gc.disable() try: begin = time.time() func(fobj) end = time.time() finally: gc.enable() return end - begin"
            },
            {
                "url": 5404,
                "code": "def print_result_from_timeit(stmt='pass', setup='pass', number=1000000): units = [\"s\", \"ms\", \"us\", \"ns\"] duration = timeit(stmt, setup, number=int(number)) avg_duration = duration / float(number) thousands = int(math.floor(math.log(avg_duration, 1000))) print(\"Total time: %fs. Average run: %.3f%s.\" % ( duration, avg_duration * (1000 ** -thousands), units[-thousands]))"
            },
            {
                "url": 959,
                "code": "def timeit(output): b = time.time() yield print output, 'time used: %.3fs' % (time.time()-b)"
            },
            {
                "url": 6005,
                "code": "def run_time() -> timedelta: delta = start_time if start_time else datetime.utcnow() return datetime.utcnow() - delta"
            }
        ],
        "url": 5785
    },
    {
        "nl_input": "python how to stop playsound",
        "code_input": [
            {
                "url": 4166,
                "code": "def stop(self): if self.isPlaying is True: self._execute(\"stop\") self._changePlayingState(False)"
            },
            {
                "url": 4453,
                "code": "def toggle_pause(self): self.controller.playing = not self.controller.playing self.music.toggle_pause()"
            },
            {
                "url": 3993,
                "code": "def stop(self): logger.debug(\"Stopping playback\") # Stop the clock self.clock.stop() # Set plauyer status to ready self.status = READY"
            },
            {
                "url": 910,
                "code": "def pause(self): mixer.music.pause() self.pause_time = self.get_time() self.paused = True"
            },
            {
                "url": 2499,
                "code": "def OnTogglePlay(self, event): if self.player.get_state() == vlc.State.Playing: self.player.pause() else: self.player.play() event.Skip()"
            },
            {
                "url": 3660,
                "code": "def pause(): if not settings.platformCompatible(): return False (output, error) = subprocess.Popen([\"osascript\", \"-e\", PAUSE], stdout=subprocess.PIPE).communicate()"
            },
            {
                "url": 1192,
                "code": "def stop_button_click_handler(self): self.stop_button.setDisabled(True) # Interrupt computations or stop debugging if not self.shellwidget._reading: self.interrupt_kernel() else: self.shellwidget.write_to_stdin('exit')"
            },
            {
                "url": 3234,
                "code": "def stop(self, reason=None): self.logger.info('stopping') self.loop.stop(pyev.EVBREAK_ALL)"
            },
            {
                "url": 1164,
                "code": "def stopwatch_now(): if six.PY2: now = time.time() else: now = time.monotonic() return now"
            },
            {
                "url": 4082,
                "code": "async def vc_check(ctx: commands.Context): # pylint: disable=unused-argument if not discord.voice_client.has_nacl: raise commands.CheckFailure(\"voice cannot be used because PyNaCl is not loaded\") if not discord.opus.is_loaded(): raise commands.CheckFailure(\"voice cannot be used because libopus is not loaded\") return True"
            },
            {
                "url": 3185,
                "code": "def stop_server(self): self.stop = True while self.task_count: time.sleep(END_RESP) self.terminate = True"
            },
            {
                "url": 3830,
                "code": "def restart_program(): python = sys.executable os.execl(python, python, * sys.argv)"
            },
            {
                "url": 3859,
                "code": "def nothread_quit(self, arg): self.debugger.core.stop() self.debugger.core.execution_status = 'Quit command' raise Mexcept.DebuggerQuit"
            },
            {
                "url": 5710,
                "code": "def stop(self) -> None: if self._stop and not self._posted_kork: self._stop() self._stop = None"
            },
            {
                "url": 1143,
                "code": "def stop(self, dummy_signum=None, dummy_frame=None): logging.info('Shutting down ...') self.socket.close() sys.exit(0)"
            }
        ],
        "url": 4166
    },
    {
        "nl_input": "python change dictioinary values in place",
        "code_input": [
            {
                "url": 6132,
                "code": "def dictlist_replace(dict_list: Iterable[Dict], key: str, value: Any) -> None: for d in dict_list: d[key] = value"
            },
            {
                "url": 179,
                "code": "def dict_update_newkeys(dict_, dict2): for key, val in six.iteritems(dict2): if key not in dict_: dict_[key] = val"
            },
            {
                "url": 5543,
                "code": "def dictlist_convert_to_float(dict_list: Iterable[Dict], key: str) -> None: for d in dict_list: try: d[key] = float(d[key]) except ValueError: d[key] = None"
            },
            {
                "url": 5594,
                "code": "def dictlist_wipe_key(dict_list: Iterable[Dict], key: str) -> None: for d in dict_list: d.pop(key, None)"
            },
            {
                "url": 5699,
                "code": "def replace_in_list(stringlist: Iterable[str], replacedict: Dict[str, str]) -> List[str]: newlist = [] for fromstring in stringlist: newlist.append(multiple_replace(fromstring, replacedict)) return newlist"
            },
            {
                "url": 2842,
                "code": "def replace_nones(dict_or_list): def replace_none_in_value(value): if isinstance(value, basestring) and value.lower() == \"none\": return None return value items = dict_or_list.iteritems() if isinstance(dict_or_list, dict) else enumerate(dict_or_list) for accessor, value in items: if isinstance(value, (dict, list)): replace_nones(value) else: dict_or_list[accessor] = replace_none_in_value(value)"
            },
            {
                "url": 3359,
                "code": "def _convert(tup, dictlist): di = {} for a, b in tup: di.setdefault(a, []).append(b) for key, val in di.items(): dictlist.append((key, val)) return dictlist"
            },
            {
                "url": 51,
                "code": "def dictapply(d, fn): for k, v in d.items(): if isinstance(v, dict): v = dictapply(v, fn) else: d[k] = fn(v) return d"
            },
            {
                "url": 1224,
                "code": "def copy_and_update(dictionary, update): newdict = dictionary.copy() newdict.update(update) return newdict"
            },
            {
                "url": 2205,
                "code": "def clean_dict_keys(d): new_d = {} for (k, v) in d.iteritems(): new_d[str(k)] = v return new_d"
            },
            {
                "url": 181,
                "code": "def update(self, other_dict): for key, value in iter_multi_items(other_dict): MultiDict.add(self, key, value)"
            },
            {
                "url": 2964,
                "code": "def _replace_none(self, aDict): for k, v in aDict.items(): if v is None: aDict[k] = 'none'"
            },
            {
                "url": 185,
                "code": "def _remove_dict_keys_with_value(dict_, val): return {k: v for k, v in dict_.items() if v is not val}"
            },
            {
                "url": 1843,
                "code": "def list2dict(lst): dic = {} for k,v in lst: dic[k] = v return dic"
            },
            {
                "url": 5891,
                "code": "def inverted_dict_of_lists(d): new_dict = {} for (old_key, old_value_list) in viewitems(dict(d)): for new_key in listify(old_value_list): new_dict[new_key] = old_key return new_dict"
            }
        ],
        "url": 6132
    },
    {
        "nl_input": "can i pass instance method as variable python",
        "code_input": [
            {
                "url": 4608,
                "code": "def _normalize_instancemethod(instance_method): if not hasattr(instance_method, 'im_self'): return instance_method def _func(*args, **kwargs): return instance_method(*args, **kwargs) _func.__name__ = repr(instance_method) return _func"
            },
            {
                "url": 2312,
                "code": "def __get__(self, obj, objtype): if not self.is_method: self.is_method = True return functools.partial(self.__call__, obj)"
            },
            {
                "url": 1321,
                "code": "def static_method(cls, f): setattr(cls, f.__name__, staticmethod(f)) return f"
            },
            {
                "url": 1470,
                "code": "def __is_bound_method(method): if not(hasattr(method, \"__func__\") and hasattr(method, \"__self__\")): return False # Bound methods have a __self__ attribute pointing to the owner instance return six.get_method_self(method) is not None"
            },
            {
                "url": 5023,
                "code": "def instance_name(string): invalid = ':/@' if set(string).intersection(invalid): msg = 'Invalid instance name {}'.format(string) raise argparse.ArgumentTypeError(msg) return string"
            },
            {
                "url": 635,
                "code": "def method(func): attr = abc.abstractmethod(func) attr.__imethod__ = True return attr"
            },
            {
                "url": 3061,
                "code": "def _method_scope(input_layer, name): global _in_method_scope # pylint: disable=protected-access with input_layer.g.as_default(), \\ scopes.var_and_name_scope( None if _in_method_scope else input_layer._scope), \\ scopes.var_and_name_scope((name, None)) as (scope, var_scope): was_in_method_scope = _in_method_scope yield scope, var_scope _in_method_scope = was_in_method_scope"
            },
            {
                "url": 4603,
                "code": "def _normalize(obj): if isinstance(obj, list): return [_normalize(item) for item in obj] elif isinstance(obj, dict): return {k: _normalize(v) for k, v in obj.items() if v is not None} elif hasattr(obj, 'to_python'): return obj.to_python() return obj"
            },
            {
                "url": 5544,
                "code": "def method_caller(method_name, *args, **kwargs): def call_method(target): func = getattr(target, method_name) return func(*args, **kwargs) return call_method"
            },
            {
                "url": 4473,
                "code": "def __call__(self, obj, *arg, **kw): bound_method = self._manager.__get__(obj, obj.__class__) return bound_method(*arg, **kw)"
            },
            {
                "url": 4204,
                "code": "def _varargs_to_iterable_method(func): def wrapped(self, iterable, **kwargs): return func(self, *iterable, **kwargs) return wrapped"
            },
            {
                "url": 1186,
                "code": "def _update_staticmethod(self, oldsm, newsm): # While we can't modify the staticmethod object itself (it has no # mutable attributes), we *can* extract the underlying function # (by calling __get__(), which returns it) and update it in-place. # We don't have the class available to pass to __get__() but any # object except None will do. self._update(None, None, oldsm.__get__(0), newsm.__get__(0))"
            },
            {
                "url": 5189,
                "code": "def __getattr__(self, *args, **kwargs): return xmlrpc.client._Method(self.__request, *args, **kwargs)"
            },
            {
                "url": 820,
                "code": "def singleton(class_): instances = {} def get_instance(*args, **kwargs): if class_ not in instances: instances[class_] = class_(*args, **kwargs) return instances[class_] return get_instance"
            },
            {
                "url": 5483,
                "code": "def get_class_method(cls_or_inst, method_name): cls = cls_or_inst if isinstance(cls_or_inst, type) else cls_or_inst.__class__ meth = getattr(cls, method_name, None) if isinstance(meth, property): meth = meth.fget elif isinstance(meth, cached_property): meth = meth.func return meth"
            }
        ],
        "url": 4536
    },
    {
        "nl_input": "pickle python read entiere file",
        "code_input": [
            {
                "url": 3100,
                "code": "def unpickle(pickle_file): pickle = None with open(pickle_file, \"rb\") as pickle_f: pickle = dill.load(pickle_f) if not pickle: LOG.error(\"Could not load python object from file\") return pickle"
            },
            {
                "url": 1754,
                "code": "def unpickle_file(picklefile, **kwargs): with open(picklefile, 'rb') as f: return pickle.load(f, **kwargs)"
            },
            {
                "url": 1055,
                "code": "def pickle_load(fname): assert type(fname) is str and os.path.exists(fname) print(\"loaded\",fname) return pickle.load(open(fname,\"rb\"))"
            },
            {
                "url": 4549,
                "code": "def load(cls,filename): filename = cls.correct_file_extension(filename) with open(filename,'rb') as f: return pickle.load(f)"
            },
            {
                "url": 1668,
                "code": "def pickle_data(data, picklefile): with open(picklefile, 'wb') as f: pickle.dump(data, f, protocol=2)"
            },
            {
                "url": 4265,
                "code": "def load(filename): path, name = os.path.split(filename) path = path or '.' with util.indir(path): return pickle.load(open(name, 'rb'))"
            },
            {
                "url": 4715,
                "code": "def read_raw(data_path): with open(data_path, 'rb') as f: data = pickle.load(f) return data"
            },
            {
                "url": 2487,
                "code": "def load(self, filename='classifier.dump'): ifile = open(filename, 'r+') self.classifier = pickle.load(ifile) ifile.close()"
            },
            {
                "url": 588,
                "code": "def save(self, fname: str): with open(fname, \"wb\") as fp: pickle.dump(self, fp)"
            },
            {
                "url": 2389,
                "code": "def read_sphinx_environment(pth): with open(pth, 'rb') as fo: env = pickle.load(fo) return env"
            },
            {
                "url": 1135,
                "code": "def save(variable, filename): fileObj = open(filename, 'wb') pickle.dump(variable, fileObj) fileObj.close()"
            },
            {
                "url": 1140,
                "code": "def pickle_save(thing,fname): pickle.dump(thing, open(fname,\"wb\"),pickle.HIGHEST_PROTOCOL) return thing"
            },
            {
                "url": 3019,
                "code": "def load(self, path): with io.open(path, 'rb') as fin: self.weights = pickle.load(fin)"
            },
            {
                "url": 244,
                "code": "def read_from_file(file_path, encoding=\"utf-8\"): with codecs.open(file_path, \"r\", encoding) as f: return f.read()"
            },
            {
                "url": 3015,
                "code": "def load(filename): if not os.path.exists(filename): LOG.error(\"load object - File '%s' does not exist.\", filename) return None obj = None with open(filename, 'rb') as obj_file: obj = dill.load(obj_file) return obj"
            }
        ],
        "url": 4715
    },
    {
        "nl_input": "should there be equal no of columns to concanate two df python",
        "code_input": [
            {
                "url": 793,
                "code": "def cross_join(df1, df2): if len(df1) == 0: return df2 if len(df2) == 0: return df1 # Add as lists so that the new index keeps the items in # the order that they are added together all_columns = pd.Index(list(df1.columns) + list(df2.columns)) df1['key'] = 1 df2['key'] = 1 return pd.merge(df1, df2, on='key').loc[:, all_columns]"
            },
            {
                "url": 3550,
                "code": "def intersect(self, other): return DataFrame(self._jdf.intersect(other._jdf), self.sql_ctx)"
            },
            {
                "url": 4086,
                "code": "def duplicated_rows(df, col_name): _check_cols(df, [col_name]) dups = df[pd.notnull(df[col_name]) & df.duplicated(subset=[col_name])] return dups"
            },
            {
                "url": 671,
                "code": "def _join(verb): data = pd.merge(verb.x, verb.y, **verb.kwargs) # Preserve x groups if isinstance(verb.x, GroupedDataFrame): data.plydata_groups = list(verb.x.plydata_groups) return data"
            },
            {
                "url": 306,
                "code": "def join_cols(cols): return \", \".join([i for i in cols]) if isinstance(cols, (list, tuple, set)) else cols"
            },
            {
                "url": 1065,
                "code": "def merge(left, right, how='inner', key=None, left_key=None, right_key=None, left_as='left', right_as='right'): return join(left, right, how, key, left_key, right_key, join_fn=make_union_join(left_as, right_as))"
            },
            {
                "url": 675,
                "code": "def get_join_cols(by_entry): left_cols = [] right_cols = [] for col in by_entry: if isinstance(col, str): left_cols.append(col) right_cols.append(col) else: left_cols.append(col[0]) right_cols.append(col[1]) return left_cols, right_cols"
            },
            {
                "url": 5659,
                "code": "def is_not_null(df: DataFrame, col_name: str) -> bool: if ( isinstance(df, pd.DataFrame) and col_name in df.columns and df[col_name].notnull().any() ): return True else: return False"
            },
            {
                "url": 2333,
                "code": "def clean_df(df, fill_nan=True, drop_empty_columns=True): if fill_nan: df = df.fillna(value=np.nan) if drop_empty_columns: df = df.dropna(axis=1, how='all') return df.sort_index()"
            },
            {
                "url": 6089,
                "code": "def columns_equal(a: Column, b: Column) -> bool: return ( a.name == b.name and column_types_equal(a.type, b.type) and a.nullable == b.nullable )"
            },
            {
                "url": 2583,
                "code": "def get_unique_indices(df, axis=1): return dict(zip(df.columns.names, dif.columns.levels))"
            },
            {
                "url": 2705,
                "code": "def _make_index(df, cols=META_IDX): return pd.MultiIndex.from_tuples( pd.unique(list(zip(*[df[col] for col in cols]))), names=tuple(cols))"
            },
            {
                "url": 2717,
                "code": "def correlation(df, rowvar=False): # Create a correlation matrix for all correlations # of the columns (filled with na for all values) df = df.copy() maskv = np.ma.masked_where(np.isnan(df.values), df.values) cdf = np.ma.corrcoef(maskv, rowvar=False) cdf = pd.DataFrame(np.array(cdf)) cdf.columns = df.columns cdf.index = df.columns cdf = cdf.sort_index(level=0, axis=1) cdf = cdf.sort_index(level=0) return cdf"
            },
            {
                "url": 5376,
                "code": "def dcounts(self): print(\"WARNING: Distinct value count for all tables can take a long time...\", file=sys.stderr) sys.stderr.flush() data = [] for t in self.tables(): for c in t.columns(): data.append([t.name(), c.name(), c.dcount(), t.size(), c.dcount() / float(t.size())]) df = pd.DataFrame(data, columns=[\"table\", \"column\", \"distinct\", \"size\", \"fraction\"]) return df"
            },
            {
                "url": 5616,
                "code": "def clean_column_names(df: DataFrame) -> DataFrame: f = df.copy() f.columns = [col.strip() for col in f.columns] return f"
            }
        ],
        "url": 793
    },
    {
        "nl_input": "python flatten deep nested list",
        "code_input": [
            {
                "url": 5705,
                "code": "def flatten_list(l: List[list]) -> list: return [v for inner_l in l for v in inner_l]"
            },
            {
                "url": 5658,
                "code": "def flatten_list(x: List[Any]) -> List[Any]: # noqa return [item for sublist in x for item in sublist]"
            },
            {
                "url": 1816,
                "code": "def flatten(nested): flat_return = list() def __inner_flat(nested,flat): for i in nested: __inner_flat(i, flat) if isinstance(i, list) else flat.append(i) return flat __inner_flat(nested,flat_return) return flat_return"
            },
            {
                "url": 566,
                "code": "def flatten(l, types=(list, float)): l = [item if isinstance(item, types) else [item] for item in l] return [item for sublist in l for item in sublist]"
            },
            {
                "url": 664,
                "code": "def flatten(l): return sum(map(flatten, l), []) \\ if isinstance(l, list) or isinstance(l, tuple) else [l]"
            },
            {
                "url": 1014,
                "code": "def flatten_list(l): return list(chain.from_iterable(repeat(x,1) if isinstance(x,str) else x for x in l))"
            },
            {
                "url": 536,
                "code": "def flat_list(lst): if isinstance(lst, list): for item in lst: for i in flat_list(item): yield i else: yield lst"
            },
            {
                "url": 4892,
                "code": "def flat_list(input_list): r x = input_list if isinstance(x, list): return [a for i in x for a in flat_list(i)] else: return [x]"
            },
            {
                "url": 1819,
                "code": "def flatten(nested, containers=(list, tuple)): for item in nested: if hasattr(item, \"next\") or isinstance(item, containers): for subitem in flatten(item): yield subitem else: yield item"
            },
            {
                "url": 1822,
                "code": "def flatten(lis): new_lis = [] for item in lis: if isinstance(item, collections.Sequence) and not isinstance(item, basestring): new_lis.extend(flatten(item)) else: new_lis.append(item) return new_lis"
            },
            {
                "url": 1820,
                "code": "def flatten_array(grid): grid = [grid[i][j] for i in range(len(grid)) for j in range(len(grid[i]))] while type(grid[0]) is list: grid = flatten_array(grid) return grid"
            },
            {
                "url": 3730,
                "code": "def flatten( iterables ): for it in iterables: if isinstance(it, str): yield it else: for element in it: yield element"
            },
            {
                "url": 2865,
                "code": "def nest(thing): tfutil = util.get_module('tensorflow.python.util') if tfutil: return tfutil.nest.flatten(thing) else: return [thing]"
            },
            {
                "url": 2819,
                "code": "def flat(l): newl = [] for i in range(len(l)): for j in range(len(l[i])): newl.append(l[i][j]) return newl"
            },
            {
                "url": 5724,
                "code": "def flatten_multidict(multidict): return dict([(key, value if len(value) > 1 else value[0]) for (key, value) in multidict.iterlists()])"
            }
        ],
        "url": 1816
    },
    {
        "nl_input": "how to show a variable amount of precision in python string format",
        "code_input": [
            {
                "url": 769,
                "code": "def _strvar(a, prec='{:G}'): r return ' '.join([prec.format(i) for i in np.atleast_1d(a)])"
            },
            {
                "url": 1201,
                "code": "def format_float(value): # not used string = \"{:g}\".format(value).replace(\"e+\", \"e\") string = re.sub(\"e(-?)0*(\\d+)\", r\"e\\1\\2\", string) return string"
            },
            {
                "url": 4260,
                "code": "def print_float(self, value, decimal_digits=2, justify_right=True): format_string = '{{0:0.{0}F}}'.format(decimal_digits) self.print_number_str(format_string.format(value), justify_right)"
            },
            {
                "url": 1128,
                "code": "def _saferound(value, decimal_places): try: f = float(value) except ValueError: return '' format = '%%.%df' % decimal_places return format % f"
            },
            {
                "url": 3610,
                "code": "def fixed(ctx, number, decimals=2, no_commas=False): value = _round(ctx, number, decimals) format_str = '{:f}' if no_commas else '{:,f}' return format_str.format(value)"
            },
            {
                "url": 321,
                "code": "def round_to_float(number, precision): rounded = Decimal(str(floor((number + precision / 2) // precision)) ) * Decimal(str(precision)) return float(rounded)"
            },
            {
                "url": 5053,
                "code": "def PythonPercentFormat(format_str): if format_str.startswith('printf '): fmt = format_str[len('printf '):] return lambda value: fmt % value else: return None"
            },
            {
                "url": 2634,
                "code": "def show_approx(self, numfmt='%.3g'): return ', '.join([('%s: ' + numfmt) % (v, p) for (v, p) in sorted(self.prob.items())])"
            },
            {
                "url": 6157,
                "code": "def format_exp_floats(decimals): threshold = 10 ** 5 return ( lambda n: \"{:.{prec}e}\".format(n, prec=decimals) if n > threshold else \"{:4.{prec}f}\".format(n, prec=decimals) )"
            },
            {
                "url": 4489,
                "code": "def round_float(f, digits, rounding=ROUND_HALF_UP): return Decimal(str(f)).quantize(Decimal(10) ** (-1 * digits), rounding=rounding)"
            },
            {
                "url": 6258,
                "code": "def trim_decimals(s, precision=-3): encoded = s.encode('ascii', 'ignore') str_val = \"\" if six.PY3: str_val = str(encoded, encoding='ascii', errors='ignore')[:precision] else: # If precision is 0, this must be handled seperately if precision == 0: str_val = str(encoded) else: str_val = str(encoded)[:precision] if len(str_val) > 0: return float(str_val) else: return 0"
            },
            {
                "url": 1840,
                "code": "def get_decimal_quantum(precision): assert isinstance(precision, (int, decimal.Decimal)) return decimal.Decimal(10) ** (-precision)"
            },
            {
                "url": 1697,
                "code": "def format_vars(args): variables = [] for key, value in args.items(): if value: variables += ['{0}={1}'.format(key, value)] return variables"
            },
            {
                "url": 4728,
                "code": "def set_sig_figs(n=4): u.default_format = '.' + str(n) + 'g' pd.options.display.float_format = ('{:,.' + str(n) + '}').format"
            },
            {
                "url": 4962,
                "code": "def parse_float(float_str): factor = __get_factor(float_str) if factor != 1: float_str = float_str[:-1] try: return float(float_str.replace(',', '')) * factor except ValueError: return None"
            }
        ],
        "url": 1446
    },
    {
        "nl_input": "python array get element by index with default",
        "code_input": [
            {
                "url": 719,
                "code": "def list_get(l, idx, default=None): try: if l[idx]: return l[idx] else: return default except IndexError: return default"
            },
            {
                "url": 6041,
                "code": "def _get_or_default(mylist, i, default=None): if i >= len(mylist): return default else : return mylist[i]"
            },
            {
                "url": 456,
                "code": "def get_list_index(lst, index_or_name): if isinstance(index_or_name, six.integer_types): return index_or_name return lst.index(index_or_name)"
            },
            {
                "url": 4882,
                "code": "def dict_pop_or(d, key, default=None): val = default with suppress(KeyError): val = d.pop(key) return val"
            },
            {
                "url": 3268,
                "code": "def _get(self, pos): res = None, None if pos is not None: try: res = self[pos], pos except (IndexError, KeyError): pass return res"
            },
            {
                "url": 1019,
                "code": "def pop(self, index=-1): value = self._list.pop(index) del self._dict[value] return value"
            },
            {
                "url": 1500,
                "code": "def setdefault(obj, field, default): setattr(obj, field, getattr(obj, field, default))"
            },
            {
                "url": 2593,
                "code": "def get_value(key, obj, default=missing): if isinstance(key, int): return _get_value_for_key(key, obj, default) return _get_value_for_keys(key.split('.'), obj, default)"
            },
            {
                "url": 6209,
                "code": "def setdefault(self, name: str, default: Any=None) -> Any: return self.__dict__.setdefault(name, default)"
            },
            {
                "url": 2925,
                "code": "def _fill_array_from_list(the_list, the_array): for i, val in enumerate(the_list): the_array[i] = val return the_array"
            },
            {
                "url": 1912,
                "code": "def __getitem__(self, index): row, col = index return self.rows[row][col]"
            },
            {
                "url": 605,
                "code": "def file_or_default(path, default, function = None): try: result = file_get_contents(path) if function != None: return function(result) return result except IOError as e: if e.errno == errno.ENOENT: return default raise"
            },
            {
                "url": 6214,
                "code": "def index(self, item): for i, x in enumerate(self.iter()): if x == item: return i return None"
            },
            {
                "url": 3637,
                "code": "def _nth(arr, n): try: return arr.iloc[n] except (KeyError, IndexError): return np.nan"
            },
            {
                "url": 567,
                "code": "def _ensure_element(tup, elem): try: return tup, tup.index(elem) except ValueError: return tuple(chain(tup, (elem,))), len(tup)"
            }
        ],
        "url": 719
    },
    {
        "nl_input": "check if string is int in python",
        "code_input": [
            {
                "url": 1791,
                "code": "def is_int(string): try: a = float(string) b = int(a) except ValueError: return False else: return a == b"
            },
            {
                "url": 5776,
                "code": "def _isint(string): return type(string) is int or \\ (isinstance(string, _binary_type) or isinstance(string, _text_type)) and \\ _isconvertible(int, string)"
            },
            {
                "url": 2128,
                "code": "def is_integer(obj): if PYTHON3: return isinstance(obj, int) return isinstance(obj, (int, long))"
            },
            {
                "url": 637,
                "code": "def is_int(value): if isinstance(value, bool): return False try: int(value) return True except (ValueError, TypeError): return False"
            },
            {
                "url": 2437,
                "code": "def check_int(integer): if not isinstance(integer, str): return False if integer[0] in ('-', '+'): return integer[1:].isdigit() return integer.isdigit()"
            },
            {
                "url": 1329,
                "code": "def validate_int(value): if value and not isinstance(value, int): try: int(str(value)) except (TypeError, ValueError): raise ValidationError('not a valid number') return value"
            },
            {
                "url": 3523,
                "code": "def is_int_type(val): try: # Python 2 return isinstance(val, (int, long)) except NameError: # Python 3 return isinstance(val, int)"
            },
            {
                "url": 5567,
                "code": "def is_integer(value: Any) -> bool: return (isinstance(value, int) and not isinstance(value, bool)) or ( isinstance(value, float) and isfinite(value) and int(value) == value )"
            },
            {
                "url": 4573,
                "code": "def test_value(self, value): if not isinstance(value, int): raise ValueError('expected int value: ' + str(type(value)))"
            },
            {
                "url": 1860,
                "code": "def str2int(string_with_int): return int(\"\".join([char for char in string_with_int if char in string.digits]) or 0)"
            },
            {
                "url": 4975,
                "code": "def is_integer(dtype): dtype = tf.as_dtype(dtype) if hasattr(dtype, 'is_integer'): return dtype.is_integer return np.issubdtype(np.dtype(dtype), np.integer)"
            },
            {
                "url": 1121,
                "code": "def check_str(obj): if isinstance(obj, str): return obj if isinstance(obj, float): return str(int(obj)) else: return str(obj)"
            },
            {
                "url": 1789,
                "code": "def is_string(obj): if PYTHON3: str_type = (bytes, str) else: str_type = (bytes, str, unicode) return isinstance(obj, str_type)"
            },
            {
                "url": 3356,
                "code": "def is_number(obj): return isinstance(obj, (int, float, np.int_, np.float_))"
            },
            {
                "url": 5836,
                "code": "def clean_int(x) -> int: try: return int(x) except ValueError: raise forms.ValidationError( \"Cannot convert to integer: {}\".format(repr(x)))"
            }
        ],
        "url": 5776
    },
    {
        "nl_input": "how to change numpy array to list in python",
        "code_input": [
            {
                "url": 5549,
                "code": "def listify(a): if a is None: return [] elif not isinstance(a, (tuple, list, np.ndarray)): return [a] return list(a)"
            },
            {
                "url": 1837,
                "code": "def to_list(var): if var is None: return [] if isinstance(var, str): var = var.split('\\n') elif not isinstance(var, list): try: var = list(var) except TypeError: raise ValueError(\"{} cannot be converted to the list.\".format(var)) return var"
            },
            {
                "url": 3411,
                "code": "def toList(variable, types=(basestring, int, float, )): if isinstance(variable, types): return [variable] else: return variable"
            },
            {
                "url": 1870,
                "code": "def _to_array(value): if isinstance(value, (tuple, list)): return array(value) elif isinstance(value, (float, int)): return np.float64(value) else: return value"
            },
            {
                "url": 6117,
                "code": "def numpy_to_yaml(representer: Representer, data: np.ndarray) -> Sequence[Any]: return representer.represent_sequence( \"!numpy_array\", data.tolist() )"
            },
            {
                "url": 2925,
                "code": "def _fill_array_from_list(the_list, the_array): for i, val in enumerate(the_list): the_array[i] = val return the_array"
            },
            {
                "url": 6037,
                "code": "def ensure_list(iterable: Iterable[A]) -> List[A]: if isinstance(iterable, list): return iterable else: return list(iterable)"
            },
            {
                "url": 3787,
                "code": "def _listify(collection): new_list = [] for index in range(len(collection)): new_list.append(collection[index]) return new_list"
            },
            {
                "url": 5880,
                "code": "def array_to_npy(array_like): # type: (np.array or Iterable or int or float) -> object buffer = BytesIO() np.save(buffer, array_like) return buffer.getvalue()"
            },
            {
                "url": 2466,
                "code": "def toListInt(value): if TypeConverters._can_convert_to_list(value): value = TypeConverters.toList(value) if all(map(lambda v: TypeConverters._is_integer(v), value)): return [int(v) for v in value] raise TypeError(\"Could not convert %s to list of ints\" % value)"
            },
            {
                "url": 5723,
                "code": "def _str_to_list(value, separator): value_list = [item.strip() for item in value.split(separator)] value_list_sanitized = builtins.list(filter(None, value_list)) if len(value_list_sanitized) > 0: return value_list_sanitized else: raise ValueError('Invalid list variable.')"
            },
            {
                "url": 2814,
                "code": "def shape_list(l,shape,dtype): return np.array(l, dtype=dtype).reshape(shape)"
            },
            {
                "url": 1583,
                "code": "def dict_to_numpy_array(d): return fromarrays(d.values(), np.dtype([(str(k), v.dtype) for k, v in d.items()]))"
            },
            {
                "url": 5543,
                "code": "def dictlist_convert_to_float(dict_list: Iterable[Dict], key: str) -> None: for d in dict_list: try: d[key] = float(d[key]) except ValueError: d[key] = None"
            },
            {
                "url": 9,
                "code": "def _convert_to_array(array_like, dtype): if isinstance(array_like, bytes): return np.frombuffer(array_like, dtype=dtype) return np.asarray(array_like, dtype=dtype)"
            }
        ],
        "url": 856
    },
    {
        "nl_input": "read a file into a set python",
        "code_input": [
            {
                "url": 5611,
                "code": "def read_set_from_file(filename: str) -> Set[str]: collection = set() with open(filename, 'r') as file_: for line in file_: collection.add(line.rstrip()) return collection"
            },
            {
                "url": 1116,
                "code": "def load_file(self, filename): with open(filename, 'r') as sourcefile: self.set_string(sourcefile.read())"
            },
            {
                "url": 244,
                "code": "def read_from_file(file_path, encoding=\"utf-8\"): with codecs.open(file_path, \"r\", encoding) as f: return f.read()"
            },
            {
                "url": 3132,
                "code": "def get_list_from_file(file_name): with open(file_name, mode='r', encoding='utf-8') as f1: lst = f1.readlines() return lst"
            },
            {
                "url": 970,
                "code": "def read_string_from_file(path, encoding=\"utf8\"): with codecs.open(path, \"rb\", encoding=encoding) as f: value = f.read() return value"
            },
            {
                "url": 873,
                "code": "def file_to_str(fname): data = None # rU = read with Universal line terminator with open(fname, 'rU') as fd: data = fd.read() return data"
            },
            {
                "url": 2833,
                "code": "def file_read(filename): fobj = open(filename,'r'); source = fobj.read(); fobj.close() return source"
            },
            {
                "url": 392,
                "code": "def _split_comma_separated(string): return set(text.strip() for text in string.split(',') if text.strip())"
            },
            {
                "url": 2956,
                "code": "def read_dict_from_file(file_path): with open(file_path) as file: lines = file.read().splitlines() obj = {} for line in lines: key, value = line.split(':', maxsplit=1) obj[key] = eval(value) return obj"
            },
            {
                "url": 1976,
                "code": "def _read_text(self, filename): with io.open(filename, 'rt', encoding='utf-8') as f: return f.read()"
            },
            {
                "url": 4073,
                "code": "def load_files(files): for py_file in files: LOG.debug(\"exec %s\", py_file) execfile(py_file, globals(), locals())"
            },
            {
                "url": 3184,
                "code": "def str_from_file(path): with open(path) as f: s = f.read().strip() return s"
            },
            {
                "url": 3371,
                "code": "def convert_args_to_sets(f): @wraps(f) def wrapper(*args, **kwargs): args = (setify(x) for x in args) return f(*args, **kwargs) return wrapper"
            },
            {
                "url": 5830,
                "code": "def pset(iterable=(), pre_size=8): if not iterable: return _EMPTY_PSET return PSet._from_iterable(iterable, pre_size=pre_size)"
            },
            {
                "url": 5848,
                "code": "def dict_of_sets_add(dictionary, key, value): # type: (DictUpperBound, Any, Any) -> None set_objs = dictionary.get(key, set()) set_objs.add(value) dictionary[key] = set_objs"
            }
        ],
        "url": 5611
    },
    {
        "nl_input": "python round float to int",
        "code_input": [
            {
                "url": 60,
                "code": "def round_to_int(number, precision): precision = int(precision) rounded = (int(number) + precision / 2) // precision * precision return rounded"
            },
            {
                "url": 321,
                "code": "def round_to_float(number, precision): rounded = Decimal(str(floor((number + precision / 2) // precision)) ) * Decimal(str(precision)) return float(rounded)"
            },
            {
                "url": 4489,
                "code": "def round_float(f, digits, rounding=ROUND_HALF_UP): return Decimal(str(f)).quantize(Decimal(10) ** (-1 * digits), rounding=rounding)"
            },
            {
                "url": 323,
                "code": "def intround(value): return int(decimal.Decimal.from_float( value).to_integral_value(decimal.ROUND_HALF_EVEN))"
            },
            {
                "url": 2579,
                "code": "def py3round(number): if abs(round(number) - number) == 0.5: return int(2.0 * round(number / 2.0)) return int(round(number))"
            },
            {
                "url": 1487,
                "code": "def round_array(array_in): if isinstance(array_in, ndarray): return np.round(array_in).astype(int) else: return int(np.round(array_in))"
            },
            {
                "url": 2300,
                "code": "def specialRound(number, rounding): temp = 0 if rounding == 0: temp = number else: temp = round(number, rounding) if temp % 1 == 0: return int(temp) else: return float(temp)"
            },
            {
                "url": 1062,
                "code": "def get_rounded(self, digits): result = self.copy() result.round(digits) return result"
            },
            {
                "url": 5566,
                "code": "def proper_round(n): return int(n) + (n / abs(n)) * int(abs(n - int(n)) >= 0.5) if n != 0 else 0"
            },
            {
                "url": 2001,
                "code": "def to_percentage(number, rounding=2): number = float(number) * 100 number_as_int = int(number) rounded = round(number, rounding) return '{}%'.format(number_as_int if number_as_int == rounded else rounded)"
            },
            {
                "url": 658,
                "code": "def round_to_x_digits(number, digits): return round(number * math.pow(10, digits)) / math.pow(10, digits)"
            },
            {
                "url": 1060,
                "code": "def round_to_n(x, n): return round(x, -int(np.floor(np.log10(x))) + (n - 1))"
            },
            {
                "url": 4260,
                "code": "def print_float(self, value, decimal_digits=2, justify_right=True): format_string = '{{0:0.{0}F}}'.format(decimal_digits) self.print_number_str(format_string.format(value), justify_right)"
            },
            {
                "url": 2792,
                "code": "def robust_int(v): if isinstance(v, int): return v if isinstance(v, float): return int(v) v = str(v).replace(',', '') if not v: return None return int(v)"
            },
            {
                "url": 2120,
                "code": "def _tofloat(obj): if \"inf\" in obj.lower().strip(): return obj try: return int(obj) except ValueError: try: return float(obj) except ValueError: return obj"
            }
        ],
        "url": 323
    },
    {
        "nl_input": "how to write a parser on python",
        "code_input": [
            {
                "url": 3225,
                "code": "def __init__(self): # Root parser self.parser = argparse.ArgumentParser() # Subparsers self.subparsers = self.parser.add_subparsers() # Parser dictionary, to avoir overwriting existing parsers self.parsers = {}"
            },
            {
                "url": 6022,
                "code": "def default_parser() -> argparse.ArgumentParser: parser = argparse.ArgumentParser( prog=CONSOLE_SCRIPT, formatter_class=argparse.ArgumentDefaultsHelpFormatter, ) build_parser(parser) return parser"
            },
            {
                "url": 4619,
                "code": "def main(pargs): input_file = sys.argv[1] fp = ParseFileLineByLine(input_file) for i in fp: print(i)"
            },
            {
                "url": 1197,
                "code": "def loads(s, model=None, parser=None): with StringIO(s) as f: return load(f, model=model, parser=parser)"
            },
            {
                "url": 4681,
                "code": "def parse(self, data, lexer=None, *args, **kwargs): if lexer is None: lexer = self.lexer return self.parser.parse(data, lexer=lexer, *args, **kwargs)"
            },
            {
                "url": 5600,
                "code": "def cli_run(): parser = argparse.ArgumentParser(description='Stupidly simple code answers from StackOverflow') parser.add_argument('query', help=\"What's the problem ?\", type=str, nargs='+') parser.add_argument('-t','--tags', help='semicolon separated tags -> python;lambda') args = parser.parse_args() main(args)"
            },
            {
                "url": 3968,
                "code": "def createArgumentParser(description): parser = argparse.ArgumentParser( description=description, formatter_class=SortedHelpFormatter) return parser"
            },
            {
                "url": 4451,
                "code": "def cli_parse(parser): parser.add_argument('-n', '--samples', type=int, required=True, help='Number of Samples') return parser"
            },
            {
                "url": 3966,
                "code": "def parser(): parser = argparse.ArgumentParser() parser.add_argument('-c', '--config_paths', default=[], action='append', help='path to a configuration directory') return parser"
            },
            {
                "url": 5950,
                "code": "def iso_string_to_python_datetime( isostring: str) -> Optional[datetime.datetime]: if not isostring: return None # if you parse() an empty string, you get today's date return dateutil.parser.parse(isostring)"
            },
            {
                "url": 2523,
                "code": "def _parse(self, date_str, format='%Y-%m-%d'): rv = pd.to_datetime(date_str, format=format) if hasattr(rv, 'to_pydatetime'): rv = rv.to_pydatetime() return rv"
            },
            {
                "url": 1434,
                "code": "def add_to_parser(self, parser): kwargs = self._get_kwargs() args = self._get_args() parser.add_argument(*args, **kwargs)"
            },
            {
                "url": 3458,
                "code": "def Parse(text): precondition.AssertType(text, Text) if compatibility.PY2: text = text.encode(\"utf-8\") return yaml.safe_load(text)"
            },
            {
                "url": 2600,
                "code": "def sub(name, func,**kwarg): sp = subparsers.add_parser(name, **kwarg) sp.set_defaults(func=func) sp.arg = sp.add_argument return sp"
            },
            {
                "url": 4223,
                "code": "def beautify(string, *args, **kwargs): parser = Parser(args, kwargs) return parser.beautify(string)"
            }
        ],
        "url": 3225
    },
    {
        "nl_input": "python dict with keys no value",
        "code_input": [
            {
                "url": 185,
                "code": "def _remove_dict_keys_with_value(dict_, val): return {k: v for k, v in dict_.items() if v is not val}"
            },
            {
                "url": 2205,
                "code": "def clean_dict_keys(d): new_d = {} for (k, v) in d.iteritems(): new_d[str(k)] = v return new_d"
            },
            {
                "url": 2281,
                "code": "def _remove_none_values(dictionary): return list(map(dictionary.pop, [i for i in dictionary if dictionary[i] is None]))"
            },
            {
                "url": 1015,
                "code": "def rm_keys_from_dict(d, keys): # Loop for each key given for key in keys: # Is the key in the dictionary? if key in d: try: d.pop(key, None) except KeyError: # Not concerned with an error. Keep going. pass return d"
            },
            {
                "url": 4719,
                "code": "def dict_keys_without_hyphens(a_dict): return dict( (key.replace('-', '_'), val) for key, val in a_dict.items())"
            },
            {
                "url": 5594,
                "code": "def dictlist_wipe_key(dict_list: Iterable[Dict], key: str) -> None: for d in dict_list: d.pop(key, None)"
            },
            {
                "url": 177,
                "code": "def filter_dict(d, keys): return {k: v for k, v in d.items() if k in keys}"
            },
            {
                "url": 1002,
                "code": "def filter_dict_by_key(d, keys): return {k: v for k, v in d.items() if k in keys}"
            },
            {
                "url": 4024,
                "code": "def _remove_empty_items(d, required): new_dict = {} for k, v in d.items(): if k in required: new_dict[k] = v elif isinstance(v, int) or v: # \"if v\" would suppress emitting int(0) new_dict[k] = v return new_dict"
            },
            {
                "url": 695,
                "code": "def _clean_dict(target_dict, whitelist=None): assert isinstance(target_dict, dict) return { ustr(k).strip(): ustr(v).strip() for k, v in target_dict.items() if v not in (None, Ellipsis, [], (), \"\") and (not whitelist or k in whitelist) }"
            },
            {
                "url": 2685,
                "code": "def str_dict(some_dict): return {str(k): str(v) for k, v in some_dict.items()}"
            },
            {
                "url": 193,
                "code": "def nonull_dict(self): return {k: v for k, v in six.iteritems(self.dict) if v and k != '_codes'}"
            },
            {
                "url": 179,
                "code": "def dict_update_newkeys(dict_, dict2): for key, val in six.iteritems(dict2): if key not in dict_: dict_[key] = val"
            },
            {
                "url": 1017,
                "code": "def purge_dict(idict): odict = {} for key, val in idict.items(): if is_null(val): continue odict[key] = val return odict"
            },
            {
                "url": 6132,
                "code": "def dictlist_replace(dict_list: Iterable[Dict], key: str, value: Any) -> None: for d in dict_list: d[key] = value"
            }
        ],
        "url": 193
    },
    {
        "nl_input": "how to remove blank lines from a text file in python",
        "code_input": [
            {
                "url": 5725,
                "code": "def remove_blank_lines(string): return \"\\n\".join(line for line in string.split(\"\\n\") if len(line.strip()))"
            },
            {
                "url": 2422,
                "code": "def text_remove_empty_lines(text): lines = [ line.rstrip() for line in text.splitlines() if line.strip() ] return \"\\n\".join(lines)"
            },
            {
                "url": 5108,
                "code": "def fix_line_breaks(s): l = s.splitlines() x = [i.strip() for i in l] x = [i for i in x if i] # remove blank lines return \"\\n\".join(x)"
            },
            {
                "url": 2581,
                "code": "def clean(s): lines = [l.rstrip() for l in s.split('\\n')] return '\\n'.join(lines)"
            },
            {
                "url": 1006,
                "code": "def _remove_blank(l): ret = [] for i, _ in enumerate(l): if l[i] == 0: break ret.append(l[i]) return ret"
            },
            {
                "url": 1805,
                "code": "def cleanLines(source, lineSep=os.linesep): stripped = (line.strip(lineSep) for line in source) return (line for line in stripped if len(line) != 0)"
            },
            {
                "url": 4173,
                "code": "def readline( file, skip_blank=False ): while 1: line = file.readline() #print \"every line: %r\" % line if not line: return None if line[0] != '#' and not ( skip_blank and line.isspace() ): return line"
            },
            {
                "url": 3099,
                "code": "def get_stripped_file_lines(filename): try: lines = open(filename).readlines() except FileNotFoundError: fatal(\"Could not open file: {!r}\".format(filename)) return [line.strip() for line in lines]"
            },
            {
                "url": 4424,
                "code": "def filter_lines_from_comments(lines): for line_nb, raw_line in enumerate(lines): clean_line = remove_comments_from_line(raw_line) if clean_line == '': continue yield line_nb, clean_line, raw_line"
            },
            {
                "url": 964,
                "code": "def lines(input): for raw_line in input: line = raw_line.strip() if line and not line.startswith('#'): yield strip_comments(line)"
            },
            {
                "url": 4855,
                "code": "def strip_comment_marker(text): lines = [] for line in text.splitlines(): lines.append(line.lstrip('#')) text = textwrap.dedent('\\n'.join(lines)) return text"
            },
            {
                "url": 6168,
                "code": "def remove_blank_spaces(syllables: List[str]) -> List[str]: cleaned = [] for syl in syllables: if syl == \" \" or syl == '': pass else: cleaned.append(syl) return cleaned"
            },
            {
                "url": 3342,
                "code": "def de_blank(val): ret = list(val) if type(val) == list: for idx, item in enumerate(val): if item.strip() == '': ret.remove(item) else: ret[idx] = item.strip() return ret"
            },
            {
                "url": 2577,
                "code": "def clean_whitespace(statement): import re # Replace linebreaks and tabs with spaces statement.text = statement.text.replace('\\n', ' ').replace('\\r', ' ').replace('\\t', ' ') # Remove any leeding or trailing whitespace statement.text = statement.text.strip() # Remove consecutive spaces statement.text = re.sub(' +', ' ', statement.text) return statement"
            },
            {
                "url": 3946,
                "code": "def strip_line(line, sep=os.linesep): try: return line.strip(sep) except TypeError: return line.decode('utf-8').strip(sep)"
            }
        ],
        "url": 3099
    },
    {
        "nl_input": "how to hash a binary file in python",
        "code_input": [
            {
                "url": 5855,
                "code": "def hash_file(fileobj): hasher = hashlib.md5() buf = fileobj.read(65536) while len(buf) > 0: hasher.update(buf) buf = fileobj.read(65536) return hasher.hexdigest()"
            },
            {
                "url": 5995,
                "code": "def _hash_the_file(hasher, filename): BUF_SIZE = 65536 with open(filename, 'rb') as f: buf = f.read(BUF_SIZE) while len(buf) > 0: hasher.update(buf) buf = f.read(BUF_SIZE) return hasher"
            },
            {
                "url": 5153,
                "code": "def filehash(path): with open(path, \"rU\") as f: return md5(py3compat.str_to_bytes(f.read())).hexdigest()"
            },
            {
                "url": 499,
                "code": "def md5_hash_file(fh): md5 = hashlib.md5() while True: data = fh.read(8192) if not data: break md5.update(data) return md5.hexdigest()"
            },
            {
                "url": 3435,
                "code": "def file_md5sum(filename): hash_md5 = hashlib.md5() with open(filename, 'rb') as f: for chunk in iter(lambda: f.read(1024 * 4), b''): hash_md5.update(chunk) return hash_md5.hexdigest()"
            },
            {
                "url": 3336,
                "code": "def generate_hash(filepath): fr = FileReader(filepath) data = fr.read_bin() return _calculate_sha256(data)"
            },
            {
                "url": 1881,
                "code": "def get_file_md5sum(path): with open(path, 'rb') as fh: h = str(hashlib.md5(fh.read()).hexdigest()) return h"
            },
            {
                "url": 582,
                "code": "def get_md5_for_file(file): md5 = hashlib.md5() while True: data = file.read(md5.block_size) if not data: break md5.update(data) return md5.hexdigest()"
            },
            {
                "url": 6044,
                "code": "def checksum(path): hasher = hashlib.sha1() with open(path, 'rb') as stream: buf = stream.read(BLOCKSIZE) while len(buf) > 0: hasher.update(buf) buf = stream.read(BLOCKSIZE) return hasher.hexdigest()"
            },
            {
                "url": 3204,
                "code": "def _sha1_for_file(filename): with open(filename, \"rb\") as fileobj: contents = fileobj.read() return hashlib.sha1(contents).hexdigest()"
            },
            {
                "url": 4902,
                "code": "def update_hash(cls, filelike, digest): block_size = digest.block_size * 1024 for chunk in iter(lambda: filelike.read(block_size), b''): digest.update(chunk)"
            },
            {
                "url": 4951,
                "code": "def _get_file_sha1(file): bits = file.read() file.seek(0) h = hashlib.new('sha1', bits).hexdigest() return h"
            },
            {
                "url": 1193,
                "code": "def md5_string(s): m = hashlib.md5() m.update(s) return str(m.hexdigest())"
            },
            {
                "url": 175,
                "code": "def dict_hash(dct): dct_s = json.dumps(dct, sort_keys=True) try: m = md5(dct_s) except TypeError: m = md5(dct_s.encode()) return m.hexdigest()"
            },
            {
                "url": 505,
                "code": "def _add_hash(source): source = '\\n'.join('# ' + line.rstrip() for line in source.splitlines()) return source"
            }
        ],
        "url": 3336
    },
    {
        "nl_input": "python get function keyword names",
        "code_input": [
            {
                "url": 3562,
                "code": "def parse_func_kwarg_keys(func, with_vals=False): sourcecode = get_func_sourcecode(func, strip_docstr=True, strip_comments=True) kwkeys = parse_kwarg_keys(sourcecode, with_vals=with_vals) #ut.get_func_kwargs TODO return kwkeys"
            },
            {
                "url": 5134,
                "code": "def _get_context(argspec, kwargs): if argspec.keywords is not None: return kwargs return dict((arg, kwargs[arg]) for arg in argspec.args if arg in kwargs)"
            },
            {
                "url": 3954,
                "code": "def get_args(method_or_func): try: # Python 3.0+ args = list(inspect.signature(method_or_func).parameters.keys()) except AttributeError: # Python 2.7 args = inspect.getargspec(method_or_func).args return args"
            },
            {
                "url": 1867,
                "code": "def get_func_name(func): func_name = getattr(func, '__name__', func.__class__.__name__) module_name = func.__module__ if module_name is not None: module_name = func.__module__ return '{}.{}'.format(module_name, func_name) return func_name"
            },
            {
                "url": 139,
                "code": "def get_default_args(func): args, varargs, keywords, defaults = getargspec_no_self(func) return dict(zip(args[-len(defaults):], defaults))"
            },
            {
                "url": 1762,
                "code": "def _kw(keywords): r = {} for k, v in keywords: r[k] = v return r"
            },
            {
                "url": 631,
                "code": "def get_func_posargs_name(f): sigparams = inspect.signature(f).parameters for p in sigparams: if sigparams[p].kind == inspect.Parameter.VAR_POSITIONAL: return sigparams[p].name return None"
            },
            {
                "url": 6221,
                "code": "def get_all_args(fn) -> list: sig = inspect.signature(fn) return list(sig.parameters)"
            },
            {
                "url": 3554,
                "code": "def get_function(function_name): module, basename = str(function_name).rsplit('.', 1) try: return getattr(__import__(module, fromlist=[basename]), basename) except (ImportError, AttributeError): raise FunctionNotFound(function_name)"
            },
            {
                "url": 2086,
                "code": "def getFunction(self): return functionFactory( self.code, self.name, self.defaults, self.globals, self.imports, )"
            },
            {
                "url": 1834,
                "code": "def short_description(func): doc = inspect.getdoc(func) if doc is not None: doc = inspect.cleandoc(doc) lines = doc.splitlines() return lines[0] return \"\""
            },
            {
                "url": 1181,
                "code": "def get_function_class(function_name): if function_name in _known_functions: return _known_functions[function_name] else: raise UnknownFunction(\"Function %s is not known. Known functions are: %s\" % (function_name, \",\".join(_known_functions.keys())))"
            },
            {
                "url": 5526,
                "code": "def python(string: str): return underscore(singularize(string) if Naming._pluralize(string) else string)"
            },
            {
                "url": 1900,
                "code": "def extra_funcs(*funcs): def extra_funcs_decorator(real_func): def wrapper(*args, **kwargs): return real_func(*args, **kwargs) wrapper.extra_funcs = list(funcs) wrapper.source = inspect.getsource(real_func) wrapper.name = real_func.__name__ return wrapper return extra_funcs_decorator"
            },
            {
                "url": 2846,
                "code": "def arguments_as_dict(cls, *args, **kwargs): all_args = (None, ) + args return inspect.getcallargs(cls.run, *all_args, **kwargs)"
            }
        ],
        "url": 3562
    },
    {
        "nl_input": "iterate through words in text file python",
        "code_input": [
            {
                "url": 4409,
                "code": "def count_words(file): c = Counter() with open(file, 'r') as f: for l in f: words = l.strip().split() c.update(words) return c"
            },
            {
                "url": 2261,
                "code": "def extract_words(lines): for line in lines: for word in re.findall(r\"\\w+\", line): yield word"
            },
            {
                "url": 45,
                "code": "def wordfreq(text, is_filename=False): if is_filename: with open(text) as f: text = f.read() freqs = {} for word in text.split(): lword = word.lower() freqs[lword] = freqs.get(lword, 0) + 1 return freqs"
            },
            {
                "url": 50,
                "code": "def count(lines): words = [w for l in lines for w in l.strip().split()] return Counter(words)"
            },
            {
                "url": 5838,
                "code": "def _read_words(filename): with tf.gfile.GFile(filename, \"r\") as f: if sys.version_info[0] >= 3: return f.read().replace(\"\\n\", \" %s \" % EOS).split() else: return f.read().decode(\"utf-8\").replace(\"\\n\", \" %s \" % EOS).split()"
            },
            {
                "url": 1546,
                "code": "def split_into_words(s): s = re.sub(r\"\\W+\", \" \", s) s = re.sub(r\"[_0-9]+\", \" \", s) return s.split()"
            },
            {
                "url": 6222,
                "code": "def enumerate_chunks (phrase, spacy_nlp): if (len(phrase) > 1): found = False text = \" \".join([rl.text for rl in phrase]) doc = spacy_nlp(text.strip(), parse=True) for np in doc.noun_chunks: if np.text != text: found = True yield np.text, find_chunk(phrase, np.text.split(\" \")) if not found and all([rl.pos[0] != \"v\" for rl in phrase]): yield text, phrase"
            },
            {
                "url": 3082,
                "code": "def tokenize_words(self, text): return [ self.strip_punctuation(word) for word in text.split(' ') if self.strip_punctuation(word) ]"
            },
            {
                "url": 885,
                "code": "def extract_keywords_from_text(self, text): sentences = nltk.tokenize.sent_tokenize(text) self.extract_keywords_from_sentences(sentences)"
            },
            {
                "url": 844,
                "code": "def wordify(text): stopset = set(nltk.corpus.stopwords.words('english')) tokens = nltk.WordPunctTokenizer().tokenize(text) return [w for w in tokens if w not in stopset]"
            },
            {
                "url": 2704,
                "code": "def counter_from_str(self, string): string_list = [chars for chars in string if chars not in self.punctuation] string_joined = ''.join(string_list) tokens = self.punkt.word_tokenize(string_joined) return Counter(tokens)"
            },
            {
                "url": 712,
                "code": "def txt_line_iterator(path): with tf.gfile.Open(path) as f: for line in f: yield line.strip()"
            },
            {
                "url": 5571,
                "code": "def split(text: str) -> List[str]: return [word for word in SEPARATOR.split(text) if word.strip(' \\t')]"
            },
            {
                "url": 3766,
                "code": "def highlight_words(string, keywords, cls_name='highlighted'): if not keywords: return string if not string: return '' include, exclude = get_text_tokenizer(keywords) highlighted = highlight_text(include, string, cls_name, words=True) return highlighted"
            },
            {
                "url": 4410,
                "code": "def word_matches(s1, s2, n=3): return __matches(s1, s2, word_ngrams, n=n)"
            }
        ],
        "url": 2261
    },
    {
        "nl_input": "python make a put request to restful endpoint",
        "code_input": [
            {
                "url": 6123,
                "code": "def put(self, endpoint: str, **kwargs) -> dict: return self._request('PUT', endpoint, **kwargs)"
            },
            {
                "url": 3802,
                "code": "def rest_put_stream(self, url, stream, headers=None, session=None, verify=True, cert=None): res = session.put(url, headers=headers, data=stream, verify=verify, cert=cert) return res.text, res.status_code"
            },
            {
                "url": 5813,
                "code": "def post(self, endpoint: str, **kwargs) -> dict: return self._request('POST', endpoint, **kwargs)"
            },
            {
                "url": 5922,
                "code": "def _request(self, method: str, endpoint: str, params: dict = None, data: dict = None, headers: dict = None) -> dict:"
            },
            {
                "url": 1047,
                "code": "def requests_post(url, data=None, json=None, **kwargs): return requests_request('post', url, data=data, json=json, **kwargs)"
            },
            {
                "url": 5719,
                "code": "def delete(self, endpoint: str, **kwargs) -> dict: return self._request('DELETE', endpoint, **kwargs)"
            },
            {
                "url": 5042,
                "code": "def request(self, method, url, body=None, headers={}): self._send_request(method, url, body, headers)"
            },
            {
                "url": 597,
                "code": "def post_object_async(self, path, **kwds): return self.do_request_async(self.api_url + path, 'POST', **kwds)"
            },
            {
                "url": 3345,
                "code": "def _request(self, data): return requests.post(self.endpoint, data=data.encode(\"ascii\")).content"
            },
            {
                "url": 1069,
                "code": "def make_post_request(self, url, auth, json_payload): response = requests.post(url, auth=auth, json=json_payload) return response.json()"
            },
            {
                "url": 2269,
                "code": "def _post(self, url, params, uploads=None): self._call(self.POST, url, params, uploads)"
            },
            {
                "url": 3162,
                "code": "def send_post(self, url, data, remove_header=None): return self.send_request(method=\"post\", url=url, data=data, remove_header=remove_header)"
            },
            {
                "url": 3384,
                "code": "def POST(self, *args, **kwargs): return self._handle_api(self.API_POST, args, kwargs)"
            },
            {
                "url": 4192,
                "code": "def put(self, entity): actual_entity = _normalize_entity(entity) if actual_entity is None: return self.ndb_put(entity) self.puts.append(actual_entity)"
            },
            {
                "url": 2301,
                "code": "def requests_request(method, url, **kwargs): session = local_sessions.session response = session.request(method=method, url=url, **kwargs) session.close() return response"
            }
        ],
        "url": 6123
    },
    {
        "nl_input": "python get the id of the current thread",
        "code_input": [
            {
                "url": 2525,
                "code": "def threadid(self): current = self.thread.ident main = get_main_thread() if main is None: return current else: return current if current != main.ident else None"
            },
            {
                "url": 2963,
                "code": "def get_current_frames(): return dict( (thread_id, {'frame': thread2list(frame), 'time': None}) for thread_id, frame in sys._current_frames().items() )"
            },
            {
                "url": 2775,
                "code": "def pop(): pid = os.getpid() thread = threading.current_thread() Wdb._instances.pop((pid, thread))"
            },
            {
                "url": 112,
                "code": "async def _thread_coro(self, *args): return await self._loop.run_in_executor( self._executor, self._function, *args)"
            },
            {
                "url": 4174,
                "code": "def getWindowPID(self, hwnd): pid = ctypes.c_ulong() ctypes.windll.user32.GetWindowThreadProcessId(hwnd, ctypes.byref(pid)) return int(pid.value)"
            },
            {
                "url": 2448,
                "code": "def start(self): if not self._is_running: self._do_run = True self._thread.start() return self"
            },
            {
                "url": 318,
                "code": "def asynchronous(function, event): thread = Thread(target=synchronous, args=(function, event)) thread.daemon = True thread.start()"
            },
            {
                "url": 1793,
                "code": "def getvariable(name): import inspect fr = inspect.currentframe() try: while fr: fr = fr.f_back vars = fr.f_locals if name in vars: return vars[name] except: pass return None"
            },
            {
                "url": 5720,
                "code": "def is_running(process_id: int) -> bool: pstr = str(process_id) encoding = sys.getdefaultencoding() s = subprocess.Popen([\"ps\", \"-p\", pstr], stdout=subprocess.PIPE) for line in s.stdout: strline = line.decode(encoding) if pstr in strline: return True return False"
            },
            {
                "url": 3859,
                "code": "def nothread_quit(self, arg): self.debugger.core.stop() self.debugger.core.execution_status = 'Quit command' raise Mexcept.DebuggerQuit"
            },
            {
                "url": 4156,
                "code": "def caller_locals(): import inspect frame = inspect.currentframe() try: return frame.f_back.f_back.f_locals finally: del frame"
            },
            {
                "url": 2940,
                "code": "def run (self): try: self.run_checked() except KeyboardInterrupt: thread.interrupt_main() except Exception: self.internal_error()"
            },
            {
                "url": 5430,
                "code": "def remove_stopped_threads (self): self.threads = [t for t in self.threads if t.is_alive()]"
            },
            {
                "url": 5306,
                "code": "def current_timestamp(): now = datetime.utcnow() timestamp = now.isoformat()[0:19] + 'Z' debug(\"generated timestamp: {now}\".format(now=timestamp)) return timestamp"
            },
            {
                "url": 335,
                "code": "def generate_unique_host_id(): host = \".\".join(reversed(socket.gethostname().split(\".\"))) pid = os.getpid() return \"%s.%d\" % (host, pid)"
            }
        ],
        "url": 2525
    },
    {
        "nl_input": "python function returning a list of all entities is called",
        "code_input": [
            {
                "url": 2850,
                "code": "def filtany(entities, **kw): ret = set() for k,v in kw.items(): for entity in entities: if getattr(entity, k)() == v: ret.add(entity) return ret"
            },
            {
                "url": 555,
                "code": "def _generate_key_map(entity_list, key, entity_class): key_map = {} for obj in entity_list: key_map[obj[key]] = entity_class(**obj) return key_map"
            },
            {
                "url": 3212,
                "code": "def unescape_all(string): def escape_single(matchobj): return _unicode_for_entity_with_name(matchobj.group(1)) return entities.sub(escape_single, string)"
            },
            {
                "url": 4239,
                "code": "def iterlists(self): for key, values in dict.iteritems(self): yield key, list(values)"
            },
            {
                "url": 2245,
                "code": "def get_all_items(obj): if hasattr(obj, 'getlist'): items = [] for key in obj: for value in obj.getlist(key): items.append((key, value)) return items else: return obj.items()"
            },
            {
                "url": 5644,
                "code": "def _(f, x): return {k: v for k, v in x.items() if f(k, v)}"
            },
            {
                "url": 1714,
                "code": "def generator_to_list(fn): def wrapper(*args, **kw): return list(fn(*args, **kw)) return wrapper"
            },
            {
                "url": 2498,
                "code": "def map(cls, iterable, func, *a, **kw): return cls(func(x, *a, **kw) for x in iterable)"
            },
            {
                "url": 2157,
                "code": "def _get_non_empty_list(cls, iter): res = [] for value in iter: if hasattr(value, 'items'): value = cls._get_non_empty_dict(value) or None if value is not None: res.append(value) return res"
            },
            {
                "url": 570,
                "code": "def force_iterable(f): def wrapper(*args, **kwargs): r = f(*args, **kwargs) if hasattr(r, '__iter__'): return r else: return [r] return wrapper"
            },
            {
                "url": 5901,
                "code": "async def fetchall(self) -> Iterable[sqlite3.Row]: return await self._execute(self._cursor.fetchall)"
            },
            {
                "url": 4320,
                "code": "def functions(self): return [v for v in self.globals.values() if isinstance(v, values.Function)]"
            },
            {
                "url": 2529,
                "code": "def iteritems(data, **kwargs): return iter(data.items(**kwargs)) if IS_PY3 else data.iteritems(**kwargs)"
            },
            {
                "url": 727,
                "code": "def get_all_attributes(klass_or_instance): pairs = list() for attr, value in inspect.getmembers( klass_or_instance, lambda x: not inspect.isroutine(x)): if not (attr.startswith(\"__\") or attr.endswith(\"__\")): pairs.append((attr, value)) return pairs"
            },
            {
                "url": 3695,
                "code": "def multiprocess_mapping(func, iterable): if os.name == 'nt': # In Windows there is no fork. return list(map(func, iterable)) try: p = multiprocessing.Pool() return_data = list(p.imap(func, iterable)) p.close() p.join() return return_data except OSError: return list(map(func, iterable))"
            }
        ],
        "url": 2850
    },
    {
        "nl_input": "how to flat a list of list python",
        "code_input": [
            {
                "url": 536,
                "code": "def flat_list(lst): if isinstance(lst, list): for item in lst: for i in flat_list(item): yield i else: yield lst"
            },
            {
                "url": 4892,
                "code": "def flat_list(input_list): r x = input_list if isinstance(x, list): return [a for i in x for a in flat_list(i)] else: return [x]"
            },
            {
                "url": 5705,
                "code": "def flatten_list(l: List[list]) -> list: return [v for inner_l in l for v in inner_l]"
            },
            {
                "url": 5658,
                "code": "def flatten_list(x: List[Any]) -> List[Any]: # noqa return [item for sublist in x for item in sublist]"
            },
            {
                "url": 566,
                "code": "def flatten(l, types=(list, float)): l = [item if isinstance(item, types) else [item] for item in l] return [item for sublist in l for item in sublist]"
            },
            {
                "url": 1816,
                "code": "def flatten(nested): flat_return = list() def __inner_flat(nested,flat): for i in nested: __inner_flat(i, flat) if isinstance(i, list) else flat.append(i) return flat __inner_flat(nested,flat_return) return flat_return"
            },
            {
                "url": 1014,
                "code": "def flatten_list(l): return list(chain.from_iterable(repeat(x,1) if isinstance(x,str) else x for x in l))"
            },
            {
                "url": 664,
                "code": "def flatten(l): return sum(map(flatten, l), []) \\ if isinstance(l, list) or isinstance(l, tuple) else [l]"
            },
            {
                "url": 2819,
                "code": "def flat(l): newl = [] for i in range(len(l)): for j in range(len(l[i])): newl.append(l[i][j]) return newl"
            },
            {
                "url": 3730,
                "code": "def flatten( iterables ): for it in iterables: if isinstance(it, str): yield it else: for element in it: yield element"
            },
            {
                "url": 1822,
                "code": "def flatten(lis): new_lis = [] for item in lis: if isinstance(item, collections.Sequence) and not isinstance(item, basestring): new_lis.extend(flatten(item)) else: new_lis.append(item) return new_lis"
            },
            {
                "url": 1819,
                "code": "def flatten(nested, containers=(list, tuple)): for item in nested: if hasattr(item, \"next\") or isinstance(item, containers): for subitem in flatten(item): yield subitem else: yield item"
            },
            {
                "url": 1820,
                "code": "def flatten_array(grid): grid = [grid[i][j] for i in range(len(grid)) for j in range(len(grid[i]))] while type(grid[0]) is list: grid = flatten_array(grid) return grid"
            },
            {
                "url": 3278,
                "code": "def comma_delimited_to_list(list_param): if isinstance(list_param, list): return list_param if isinstance(list_param, str): return list_param.split(',') else: return []"
            },
            {
                "url": 1367,
                "code": "def list_of_lists_to_dict(l): d = {} for key, val in l: d.setdefault(key, []).append(val) return d"
            }
        ],
        "url": 5658
    },
    {
        "nl_input": "python read yaml to numpy",
        "code_input": [
            {
                "url": 6117,
                "code": "def numpy_to_yaml(representer: Representer, data: np.ndarray) -> Sequence[Any]: return representer.represent_sequence( \"!numpy_array\", data.tolist() )"
            },
            {
                "url": 1096,
                "code": "def load_yaml(filepath): with open(filepath) as f: txt = f.read() return yaml.load(txt)"
            },
            {
                "url": 1353,
                "code": "def load_yaml_file(file_path: str): with codecs.open(file_path, 'r') as f: return yaml.safe_load(f)"
            },
            {
                "url": 2549,
                "code": "def read_numpy(fd, byte_order, dtype, count): return numpy.fromfile(fd, byte_order+dtype[-1], count)"
            },
            {
                "url": 6141,
                "code": "def load_yaml(file): if hasattr(yaml, \"full_load\"): return yaml.full_load(file) else: return yaml.load(file)"
            },
            {
                "url": 5152,
                "code": "def _parse_array(self, tensor_proto): try: from onnx.numpy_helper import to_array except ImportError as e: raise ImportError(\"Unable to import onnx which is required {}\".format(e)) np_array = to_array(tensor_proto).reshape(tuple(tensor_proto.dims)) return mx.nd.array(np_array)"
            },
            {
                "url": 6002,
                "code": "def load_yaml(yaml_file: str) -> Any: with open(yaml_file, 'r') as file: return ruamel.yaml.load(file, ruamel.yaml.RoundTripLoader)"
            },
            {
                "url": 5746,
                "code": "def csv_to_numpy(string_like, dtype=None): # type: (str) -> np.array stream = StringIO(string_like) return np.genfromtxt(stream, dtype=dtype, delimiter=',')"
            },
            {
                "url": 666,
                "code": "def read_array(path, mmap_mode=None): file_ext = op.splitext(path)[1] if file_ext == '.npy': return np.load(path, mmap_mode=mmap_mode) raise NotImplementedError(\"The file extension `{}` \".format(file_ext) + \"is not currently supported.\")"
            },
            {
                "url": 1355,
                "code": "def yaml_to_param(obj, name): return from_pyvalue(u\"yaml:%s\" % name, unicode(yaml.dump(obj)))"
            },
            {
                "url": 3335,
                "code": "def getYamlDocument(filePath): with open(filePath) as stream: doc = yaml.load(stream) return doc"
            },
            {
                "url": 1089,
                "code": "def numpy(self): # load GDCM's image reading functionality image_reader = gdcm.ImageReader() image_reader.SetFileName(self.fname) if not image_reader.Read(): raise IOError(\"Could not read DICOM image\") pixel_array = self._gdcm_to_numpy(image_reader.GetImage()) return pixel_array"
            },
            {
                "url": 4134,
                "code": "def read_corpus(file_name): with io.open(file_name, encoding='utf-8') as data_file: return yaml.load(data_file)"
            },
            {
                "url": 3936,
                "code": "def read_numpy(fh, byteorder, dtype, count, offsetsize): dtype = 'b' if dtype[-1] == 's' else byteorder+dtype[-1] return fh.read_array(dtype, count)"
            },
            {
                "url": 231,
                "code": "def deserialize_ndarray_npy(d): with io.BytesIO() as f: f.write(json.loads(d['npy']).encode('latin-1')) f.seek(0) return np.load(f)"
            }
        ],
        "url": 6117
    },
    {
        "nl_input": "discord python get user from id string",
        "code_input": [
            {
                "url": 620,
                "code": "def get_user_by_id(self, id): return self.db_adapter.get_object(self.UserClass, id=id)"
            },
            {
                "url": 3237,
                "code": "def load_logged_in_user(): user_id = session.get(\"user_id\") g.user = User.query.get(user_id) if user_id is not None else None"
            },
            {
                "url": 5298,
                "code": "def get_chat_member(self, user_id): return self.bot.api_call( \"getChatMember\", chat_id=str(self.id), user_id=str(user_id) )"
            },
            {
                "url": 2906,
                "code": "def get_user_id_from_email(self, email): accts = self.get_all_user_accounts() for acct in accts: if acct['email'] == email: return acct['id'] return None"
            },
            {
                "url": 416,
                "code": "def me(self): return self.guild.me if self.guild is not None else self.bot.user"
            },
            {
                "url": 2197,
                "code": "def user_parse(data): _user = data.get('response', {}).get('user', {}) yield 'id', _user.get('name') yield 'username', _user.get('name') yield 'link', _user.get('blogs', [{}])[0].get('url')"
            },
            {
                "url": 2785,
                "code": "def retrieve_by_id(self, id_): items_with_id = [item for item in self if item.id == int(id_)] if len(items_with_id) == 1: return items_with_id[0].retrieve()"
            },
            {
                "url": 2932,
                "code": "def user_exists(username): try: pwd.getpwnam(username) user_exists = True except KeyError: user_exists = False return user_exists"
            },
            {
                "url": 391,
                "code": "def get_obj(ref): oid = int(ref) return server.id2ref.get(oid) or server.id2obj[oid]"
            },
            {
                "url": 965,
                "code": "def get_user_name(): if sys.platform == 'win32': #user = os.getenv('USERPROFILE') user = os.getenv('USERNAME') else: user = os.getenv('LOGNAME') return user"
            },
            {
                "url": 6133,
                "code": "def get_account_id_by_fullname(self, fullname: str) -> str: account = self.get_by_fullname(fullname) return account.guid"
            },
            {
                "url": 5451,
                "code": "def generate_user_token(self, user, salt=None): return self.token_serializer.dumps(str(user.id), salt=salt)"
            },
            {
                "url": 4655,
                "code": "def find_one_by_id(self, _id): document = (yield self.collection.find_one({\"_id\": ObjectId(_id)})) raise Return(self._obj_cursor_to_dictionary(document))"
            },
            {
                "url": 3048,
                "code": "def json_obj_to_cursor(self, json): cursor = json_util.loads(json) if \"id\" in json: cursor[\"_id\"] = ObjectId(cursor[\"id\"]) del cursor[\"id\"] return cursor"
            },
            {
                "url": 1041,
                "code": "def get_auth(): import getpass user = input(\"User Name: \") # noqa pswd = getpass.getpass('Password: ') return Github(user, pswd)"
            }
        ],
        "url": 620
    },
    {
        "nl_input": "list of arbitrary objects to counts in python",
        "code_input": [
            {
                "url": 5768,
                "code": "def count(args): counts = defaultdict(int) for arg in args: for item in arg: counts[item] = counts[item] + 1 return counts"
            },
            {
                "url": 320,
                "code": "def count_list(the_list): count = the_list.count result = [(item, count(item)) for item in set(the_list)] result.sort() return result"
            },
            {
                "url": 1284,
                "code": "def __iter__(self): for value, count in self.counts(): for _ in range(count): yield value"
            },
            {
                "url": 1367,
                "code": "def list_of_lists_to_dict(l): d = {} for key, val in l: d.setdefault(key, []).append(val) return d"
            },
            {
                "url": 2220,
                "code": "def counter(items): results = {} for item in items: results[item] = results.get(item, 0) + 1 return results"
            },
            {
                "url": 431,
                "code": "def unique_list_dicts(dlist, key): return list(dict((val[key], val) for val in dlist).values())"
            },
            {
                "url": 50,
                "code": "def count(lines): words = [w for l in lines for w in l.strip().split()] return Counter(words)"
            },
            {
                "url": 4239,
                "code": "def iterlists(self): for key, values in dict.iteritems(self): yield key, list(values)"
            },
            {
                "url": 6032,
                "code": "def duplicates(coll): return list(set(x for x in coll if coll.count(x) > 1))"
            },
            {
                "url": 3655,
                "code": "def deduplicate(list_object): new = [] for item in list_object: if item not in new: new.append(item) return new"
            },
            {
                "url": 824,
                "code": "def count_generator(generator, memory_efficient=True): if memory_efficient: counter = 0 for _ in generator: counter += 1 return counter else: return len(list(generator))"
            },
            {
                "url": 596,
                "code": "def count_(self): try: num = len(self.df.index) except Exception as e: self.err(e, \"Can not count data\") return return num"
            },
            {
                "url": 2466,
                "code": "def toListInt(value): if TypeConverters._can_convert_to_list(value): value = TypeConverters.toList(value) if all(map(lambda v: TypeConverters._is_integer(v), value)): return [int(v) for v in value] raise TypeError(\"Could not convert %s to list of ints\" % value)"
            },
            {
                "url": 5680,
                "code": "def count(self, elem): return self._left_list.count(elem) + self._right_list.count(elem)"
            },
            {
                "url": 714,
                "code": "def distinct(xs): # don't use collections.OrderedDict because we do support Python 2.6 seen = set() return [x for x in xs if x not in seen and not seen.add(x)]"
            }
        ],
        "url": 5768
    },
    {
        "nl_input": "how to know queue size in python",
        "code_input": [
            {
                "url": 425,
                "code": "def qsize(self): self.mutex.acquire() n = self._qsize() self.mutex.release() return n"
            },
            {
                "url": 949,
                "code": "def full(self): if not self.size: return False return len(self.pq) == (self.size + self.removed_count)"
            },
            {
                "url": 4438,
                "code": "def create(parallel): queue = {k: v for k, v in parallel.items() if k in [\"queue\", \"cores_per_job\", \"mem\"]} yield queue"
            },
            {
                "url": 5555,
                "code": "def full(self): return self.maxsize and len(self.list) >= self.maxsize or False"
            },
            {
                "url": 406,
                "code": "def dequeue(self, block=True): return self.queue.get(block, self.queue_get_timeout)"
            },
            {
                "url": 3697,
                "code": "def get(self, queue_get): if isinstance(queue_get, (tuple, list)): self.result.extend(queue_get)"
            },
            {
                "url": 1909,
                "code": "def size(dtype): dtype = tf.as_dtype(dtype) if hasattr(dtype, 'size'): return dtype.size return np.dtype(dtype).itemsize"
            },
            {
                "url": 713,
                "code": "def get_size(objects): res = 0 for o in objects: try: res += _getsizeof(o) except AttributeError: print(\"IGNORING: type=%s; o=%s\" % (str(type(o)), str(o))) return res"
            },
            {
                "url": 2698,
                "code": "def push(self, el): count = next(self.counter) heapq.heappush(self._queue, (el, count))"
            },
            {
                "url": 2586,
                "code": "def pop_all(self): with self.lock: output = list(self.queue) self.queue.clear() return output"
            },
            {
                "url": 3546,
                "code": "def get_item_from_queue(Q, timeout=0.01): try: item = Q.get(True, 0.01) except Queue.Empty: return None return item"
            },
            {
                "url": 5005,
                "code": "def wait(self, timeout=None): if not self.__running: raise RuntimeError(\"ThreadPool ain't running\") self.__queue.wait(timeout)"
            },
            {
                "url": 1134,
                "code": "def _nbytes(buf): if isinstance(buf, memoryview): if PY3: # py3 introduces nbytes attribute return buf.nbytes else: # compute nbytes on py2 size = buf.itemsize for dim in buf.shape: size *= dim return size else: # not a memoryview, raw bytes/ py2 buffer return len(buf)"
            },
            {
                "url": 2050,
                "code": "def get_size(path): if os.path.isfile(path): return os.path.getsize(path) return sum(get_size(os.path.join(path, f)) for f in os.listdir(path))"
            },
            {
                "url": 4751,
                "code": "def stop(self): with self.lock: for dummy in self.threads: self.queue.put(None)"
            }
        ],
        "url": 425
    },
    {
        "nl_input": "impute missing values in python",
        "code_input": [
            {
                "url": 3840,
                "code": "def impute_data(self,x): imp = Imputer(missing_values='NaN', strategy='mean', axis=0) return imp.fit_transform(x)"
            },
            {
                "url": 6165,
                "code": "def fix_missing(df, col, name, na_dict): if is_numeric_dtype(col): if pd.isnull(col).sum() or (name in na_dict): df[name+'_na'] = pd.isnull(col) filler = na_dict[name] if name in na_dict else col.median() df[name] = col.fillna(filler) na_dict[name] = filler return na_dict"
            },
            {
                "url": 4722,
                "code": "def fillna(series_or_arr, missing_value=0.0): if pandas.notnull(missing_value): if isinstance(series_or_arr, (numpy.ndarray)): series_or_arr[numpy.isnan(series_or_arr)] = missing_value else: series_or_arr.fillna(missing_value, inplace=True) return series_or_arr"
            },
            {
                "url": 889,
                "code": "def clean_dataframe(df): df = df.fillna(method='ffill') df = df.fillna(0.0) return df"
            },
            {
                "url": 1801,
                "code": "def fill_nulls(self, col: str): n = [None, \"\"] try: self.df[col] = self.df[col].replace(n, nan) except Exception as e: self.err(e)"
            },
            {
                "url": 1803,
                "code": "def inpaint(self): import inpaint filled = inpaint.replace_nans(np.ma.filled(self.raster_data, np.NAN).astype(np.float32), 3, 0.01, 2) self.raster_data = np.ma.masked_invalid(filled)"
            },
            {
                "url": 4485,
                "code": "def convert_from_missing_indexer_tuple(indexer, axes): def get_indexer(_i, _idx): return (axes[_i].get_loc(_idx['key']) if isinstance(_idx, dict) else _idx) return tuple(get_indexer(_i, _idx) for _i, _idx in enumerate(indexer))"
            },
            {
                "url": 2333,
                "code": "def clean_df(df, fill_nan=True, drop_empty_columns=True): if fill_nan: df = df.fillna(value=np.nan) if drop_empty_columns: df = df.dropna(axis=1, how='all') return df.sort_index()"
            },
            {
                "url": 4024,
                "code": "def _remove_empty_items(d, required): new_dict = {} for k, v in d.items(): if k in required: new_dict[k] = v elif isinstance(v, int) or v: # \"if v\" would suppress emitting int(0) new_dict[k] = v return new_dict"
            },
            {
                "url": 292,
                "code": "def _maybe_fill(arr, fill_value=np.nan): if _isna_compat(arr, fill_value): arr.fill(fill_value) return arr"
            },
            {
                "url": 2500,
                "code": "def clean_with_zeros(self,x): x[~np.any(np.isnan(x) | np.isinf(x),axis=1)] = 0 return x"
            },
            {
                "url": 4484,
                "code": "def _maybe_pandas_data(data, feature_names, feature_types): if not isinstance(data, DataFrame): return data, feature_names, feature_types data_dtypes = data.dtypes if not all(dtype.name in PANDAS_DTYPE_MAPPER for dtype in data_dtypes): bad_fields = [data.columns[i] for i, dtype in enumerate(data_dtypes) if dtype.name not in PANDAS_DTYPE_MAPPER] msg = \"\"\"DataFrame.dtypes for data must be int, float or bool. Did not expect the data types in fields \"\"\" raise ValueError(msg + ', '.join(bad_fields)) if feature_names is None: if isinstance(data.columns, MultiIndex): feature_names = [ ' '.join([str(x) for x in i]) for i in data.columns ] else: feature_names = data.columns.format() if feature_types is None: feature_types = [PANDAS_DTYPE_MAPPER[dtype.name] for dtype in data_dtypes] data = data.values.astype('float') return data, feature_names, feature_types"
            },
            {
                "url": 5616,
                "code": "def clean_column_names(df: DataFrame) -> DataFrame: f = df.copy() f.columns = [col.strip() for col in f.columns] return f"
            },
            {
                "url": 2964,
                "code": "def _replace_none(self, aDict): for k, v in aDict.items(): if v is None: aDict[k] = 'none'"
            },
            {
                "url": 4198,
                "code": "def _maybe_cast_to_float64(da): if da.dtype == np.float32: logging.warning('Datapoints were stored using the np.float32 datatype.' 'For accurate reduction operations using bottleneck, ' 'datapoints are being cast to the np.float64 datatype.' ' For more information see: https://github.com/pydata/' 'xarray/issues/1346') return da.astype(np.float64) else: return da"
            }
        ],
        "url": 3840
    },
    {
        "nl_input": "python dict rank by value",
        "code_input": [
            {
                "url": 4604,
                "code": "def ranks(self, key, value): return [normalize_rank(el) for el in force_list(value.get('a'))]"
            },
            {
                "url": 5999,
                "code": "def revrank_dict(dict, key=lambda t: t[1], as_tuple=False): sorted_list = sorted(dict.items(), key=key, reverse=True) return OrderedDict(sorted_list) if not as_tuple else tuple(sorted_list)"
            },
            {
                "url": 1150,
                "code": "def _dict_values_sorted_by_key(dictionary): # This should be a yield from instead. for _, value in sorted(dictionary.iteritems(), key=operator.itemgetter(0)): yield value"
            },
            {
                "url": 1172,
                "code": "def sort_dict(d, key=None, reverse=False): kv_items = [kv for kv in d.items()] # Sort kv_items according to key. if key is None: kv_items.sort(key=lambda t: t[1], reverse=reverse) else: kv_items.sort(key=key, reverse=reverse) # Build ordered dict. return collections.OrderedDict(kv_items)"
            },
            {
                "url": 2253,
                "code": "def zrank(self, name, value): with self.pipe as pipe: value = self.valueparse.encode(value) return pipe.zrank(self.redis_key(name), value)"
            },
            {
                "url": 583,
                "code": "def _rank(self, ranking, n): return nlargest(n, ranking, key=ranking.get)"
            },
            {
                "url": 3845,
                "code": "def sort_key(val): return numpy.sum((max(val)+1)**numpy.arange(len(val)-1, -1, -1)*val)"
            },
            {
                "url": 2183,
                "code": "def rank(self): r = np.empty(self.size, np.int) r[self.sorter] = np.arange(self.size) return r"
            },
            {
                "url": 5879,
                "code": "def pretty_dict(d): return '{%s}' % ', '.join('%r: %r' % (k, v) for k, v in sorted(d.items(), key=repr))"
            },
            {
                "url": 5927,
                "code": "def sortBy(self, keyfunc, ascending=True, numPartitions=None): return self.keyBy(keyfunc).sortByKey(ascending, numPartitions).values()"
            },
            {
                "url": 1529,
                "code": "def _mean_dict(dict_list): return {k: np.array([d[k] for d in dict_list]).mean() for k in dict_list[0].keys()}"
            },
            {
                "url": 4334,
                "code": "def natural_sort(list, key=lambda s:s): def get_alphanum_key_func(key): convert = lambda text: int(text) if text.isdigit() else text return lambda s: [convert(c) for c in re.split('([0-9]+)', key(s))] sort_key = get_alphanum_key_func(key) list.sort(key=sort_key)"
            },
            {
                "url": 2228,
                "code": "def printdict(adict): dlist = list(adict.keys()) dlist.sort() for i in range(0, len(dlist)): print(dlist[i], adict[dlist[i]])"
            },
            {
                "url": 3265,
                "code": "def sort_func(self, key): if key == self._KEYS.VALUE: return 'aaa' if key == self._KEYS.SOURCE: return 'zzz' return key"
            },
            {
                "url": 5685,
                "code": "def sorted_by(key: Callable[[raw_types.Qid], Any]) -> 'QubitOrder': return QubitOrder(lambda qubits: tuple(sorted(qubits, key=key)))"
            }
        ],
        "url": 5999
    },
    {
        "nl_input": "generate short unique id python",
        "code_input": [
            {
                "url": 4227,
                "code": "def _unique_id(self, prefix): _id = self._id_gen self._id_gen += 1 return prefix + str(_id)"
            },
            {
                "url": 553,
                "code": "def uniqueID(size=6, chars=string.ascii_uppercase + string.digits): return ''.join(random.choice(chars) for x in xrange(size))"
            },
            {
                "url": 3620,
                "code": "def _uniqueid(n=30): return ''.join(random.SystemRandom().choice( string.ascii_uppercase + string.ascii_lowercase) for _ in range(n))"
            },
            {
                "url": 2861,
                "code": "def random_id(length): def char(): \"\"\"Generate single random char\"\"\" return random.choice(string.ascii_letters + string.digits) return \"\".join(char() for _ in range(length))"
            },
            {
                "url": 2355,
                "code": "def generate_id(): # TODO: Use six.string_type to Py3 compat try: return unicode(uuid1()).replace(u\"-\", u\"\") except NameError: return str(uuid1()).replace(u\"-\", u\"\")"
            },
            {
                "url": 2864,
                "code": "def generate_random_id(size=6, chars=string.ascii_uppercase + string.digits): return \"\".join(random.choice(chars) for x in range(size))"
            },
            {
                "url": 335,
                "code": "def generate_unique_host_id(): host = \".\".join(reversed(socket.gethostname().split(\".\"))) pid = os.getpid() return \"%s.%d\" % (host, pid)"
            },
            {
                "url": 70,
                "code": "def _get_random_id(): symbols = string.ascii_uppercase + string.ascii_lowercase + string.digits return ''.join(random.choice(symbols) for _ in range(15))"
            },
            {
                "url": 2530,
                "code": "def random_id(size=8, chars=string.ascii_letters + string.digits): return ''.join(random.choice(chars) for _ in range(size))"
            },
            {
                "url": 3228,
                "code": "def get_random_id(length): alphabet = string.ascii_uppercase + string.ascii_lowercase + string.digits return ''.join(random.choice(alphabet) for _ in range(length))"
            },
            {
                "url": 2302,
                "code": "def unique(self, name): # Make sure the name is valid name = self.valid(name) # Make sure it's not too long name = self.trim(name) # Now make sure it's unique unique_name = name i = 2 while unique_name in self.names: unique_name = name + str(i) i += 1 self.names.add(unique_name) return unique_name"
            },
            {
                "url": 4118,
                "code": "def generate_id(self): if self.use_repeatable_ids: self.repeatable_id_counter += 1 return 'autobaked-{}'.format(self.repeatable_id_counter) else: return str(uuid4())"
            },
            {
                "url": 3370,
                "code": "def generate_hash(self, length=30): import random, string chars = string.ascii_letters + string.digits ran = random.SystemRandom().choice hash = ''.join(ran(chars) for i in range(length)) return hash"
            },
            {
                "url": 4302,
                "code": "def generate_id(self, obj): object_type = type(obj).__name__.lower() return '{}_{}'.format(object_type, self.get_object_id(obj))"
            },
            {
                "url": 5917,
                "code": "def uuid(self, version: int = None) -> str: bits = self.random.getrandbits(128) return str(uuid.UUID(int=bits, version=version))"
            }
        ],
        "url": 335
    },
    {
        "nl_input": "python numpy inverse of the matrix",
        "code_input": [
            {
                "url": 4615,
                "code": "def inverse(self): invr = np.linalg.inv(self.affine_matrix) return SymmOp(invr)"
            },
            {
                "url": 2512,
                "code": "def MatrixInverse(a, adj): return np.linalg.inv(a if not adj else _adjoint(a)),"
            },
            {
                "url": 3060,
                "code": "def Cinv(self): try: return np.linalg.inv(self.c) except np.linalg.linalg.LinAlgError: print('Warning: non-invertible noise covariance matrix c.') return np.eye(self.c.shape[0])"
            },
            {
                "url": 1948,
                "code": "def inverse_transform(self, X): X = check_array(X, copy=self.copy) X -= self.min_ X /= self.scale_ return X"
            },
            {
                "url": 5558,
                "code": "def get_pij_matrix(t, diag, A, A_inv): return A.dot(np.diag(np.exp(diag * t))).dot(A_inv)"
            },
            {
                "url": 5490,
                "code": "def inverse(d): output = {} for k, v in unwrap(d).items(): output[v] = output.get(v, []) output[v].append(k) return output"
            },
            {
                "url": 1862,
                "code": "def ident(): matrix = stypes.emptyDoubleMatrix() libspice.ident_c(matrix) return stypes.cMatrixToNumpy(matrix)"
            },
            {
                "url": 849,
                "code": "def denorm(self,arr): if type(arr) is not np.ndarray: arr = to_np(arr) if len(arr.shape)==3: arr = arr[None] return self.transform.denorm(np.rollaxis(arr,1,4))"
            },
            {
                "url": 3003,
                "code": "def normalize_matrix(matrix): abs_matrix = np.abs(matrix.copy()) return abs_matrix / abs_matrix.max()"
            },
            {
                "url": 2602,
                "code": "def similarity_transformation(rot, mat): return np.dot(rot, np.dot(mat, np.linalg.inv(rot)))"
            },
            {
                "url": 3439,
                "code": "def invert(dict_): ensure_mapping(dict_) return dict_.__class__(izip(itervalues(dict_), iterkeys(dict_)))"
            },
            {
                "url": 5730,
                "code": "def __rmatmul__(self, other): return self.T.dot(np.transpose(other)).T"
            },
            {
                "url": 3163,
                "code": "def inverseHistogram(hist, bin_range): data = hist.astype(float) / np.min(hist[np.nonzero(hist)]) new_data = np.empty(shape=np.sum(data, dtype=int)) i = 0 xvals = np.linspace(bin_range[0], bin_range[1], len(data)) for d, x in zip(data, xvals): new_data[i:i + d] = x i += int(d) return new_data"
            },
            {
                "url": 897,
                "code": "def perform_pca(A): # First subtract the mean M = (A-numpy.mean(A.T, axis=1)).T # Get eigenvectors and values of covariance matrix return numpy.linalg.eig(numpy.cov(M))"
            },
            {
                "url": 4760,
                "code": "def inverse_jacobian(self, maps): m1 = maps[parameters.mass1] m2 = maps[parameters.mass2] mchirp = conversions.mchirp_from_mass1_mass2(m1, m2) eta = conversions.eta_from_mass1_mass2(m1, m2) return -1. * mchirp / eta**(6./5)"
            }
        ],
        "url": 2512
    },
    {
        "nl_input": "python how to mix backslash and forward slashes in path",
        "code_input": [
            {
                "url": 6197,
                "code": "def normalize_pattern(pattern): if not (pattern.startswith('RE:') or pattern.startswith('!RE:')): pattern = _slashes.sub('/', pattern) if len(pattern) > 1: pattern = pattern.rstrip('/') return pattern"
            },
            {
                "url": 1288,
                "code": "def norm_slash(name): if isinstance(name, str): return name.replace('/', \"\\\\\") if not is_case_sensitive() else name else: return name.replace(b'/', b\"\\\\\") if not is_case_sensitive() else name"
            },
            {
                "url": 503,
                "code": "def __unixify(self, s): return os.path.normpath(s).replace(os.sep, \"/\")"
            },
            {
                "url": 880,
                "code": "def normalize_path(path): return os.path.normcase(os.path.realpath(os.path.expanduser(path)))"
            },
            {
                "url": 4336,
                "code": "def escapePathForShell(path): if platform.system() == 'Windows': return '\"{}\"'.format(path.replace('\"', '\"\"')) else: return shellescape.quote(path)"
            },
            {
                "url": 2295,
                "code": "def fixpath(path): return os.path.normpath(os.path.realpath(os.path.expanduser(path)))"
            },
            {
                "url": 3524,
                "code": "def expandpath(path): return os.path.expandvars(os.path.expanduser(path)).replace(\"//\", \"/\")"
            },
            {
                "url": 464,
                "code": "def _escape(s): e = s e = e.replace('\\\\', '\\\\\\\\') e = e.replace('\\n', '\\\\n') e = e.replace('\\r', '\\\\r') e = e.replace(\"'\", \"\\\\'\") e = e.replace('\"', '\\\\\"') return e"
            },
            {
                "url": 4397,
                "code": "def normalize_path(filename): return os.path.normcase(os.path.realpath(os.path.normpath(_cygwin_patch(filename))))"
            },
            {
                "url": 3819,
                "code": "def path(self): path = super(WindowsPath2, self).path if path.startswith(\"\\\\\\\\?\\\\\"): return path[4:] return path"
            },
            {
                "url": 2950,
                "code": "def insert_slash(string, every=2): return os.path.join(string[i:i+every] for i in xrange(0, len(string), every))"
            },
            {
                "url": 1436,
                "code": "def unescape(str): out = '' prev_backslash = False for char in str: if not prev_backslash and char == '\\\\': prev_backslash = True continue out += char prev_backslash = False return out"
            },
            {
                "url": 144,
                "code": "def mixedcase(path): words = path.split('_') return words[0] + ''.join(word.title() for word in words[1:])"
            },
            {
                "url": 3822,
                "code": "def fix_dashes(string): string = string.replace(u'\\u05BE', '-') string = string.replace(u'\\u1806', '-') string = string.replace(u'\\u2E3A', '-') string = string.replace(u'\\u2E3B', '-') string = unidecode(string) return re.sub(r'--+', '-', string)"
            },
            {
                "url": 3542,
                "code": "def string_format_func(s): return u\"\\\"%s\\\"\" % unicode(s).replace(u\"\\\\\", u\"\\\\\\\\\").replace(u\"\\\"\", u\"\\\\\\\"\")"
            }
        ],
        "url": 1288
    },
    {
        "nl_input": "reduce functon not defined in python",
        "code_input": [
            {
                "url": 5886,
                "code": "def reduce(function, initval=None): if initval is None: return lambda s: __builtin__.reduce(function, s) else: return lambda s: __builtin__.reduce(function, s, initval)"
            },
            {
                "url": 1578,
                "code": "def compose(*funcs): return lambda x: reduce(lambda v, f: f(v), reversed(funcs), x)"
            },
            {
                "url": 621,
                "code": "def reduce_fn(x): values = x.values if pd and isinstance(x, pd.Series) else x for v in values: if not is_nan(v): return v return np.NaN"
            },
            {
                "url": 2508,
                "code": "def reduce_json(data): return reduce(lambda x, y: int(x) + int(y), data.values())"
            },
            {
                "url": 4143,
                "code": "def save_partial(self, obj): self.save_reduce(_genpartial, (obj.func, obj.args, obj.keywords))"
            },
            {
                "url": 3964,
                "code": "def compose(func_list): def f(G, bim): for func in func_list: G, bim = func(G, bim) return G, bim return f"
            },
            {
                "url": 3793,
                "code": "def reduce_multiline(string): string = str(string) return \" \".join([item.strip() for item in string.split(\"\\n\") if item.strip()])"
            },
            {
                "url": 4912,
                "code": "def reduce_freqs(freqlist): allfreqs = np.zeros_like(freqlist[0]) for f in freqlist: allfreqs += f return allfreqs"
            },
            {
                "url": 325,
                "code": "def _accumulate(sequence, func): iterator = iter(sequence) total = next(iterator) yield total for element in iterator: total = func(total, element) yield total"
            },
            {
                "url": 2498,
                "code": "def map(cls, iterable, func, *a, **kw): return cls(func(x, *a, **kw) for x in iterable)"
            },
            {
                "url": 4964,
                "code": "def apply(self, func, args=(), kwds=dict()): return self.apply_async(func, args, kwds).get()"
            },
            {
                "url": 2056,
                "code": "def compose_all(tups): from . import ast # I weep for humanity return functools.reduce(lambda x, y: x.compose(y), map(ast.make_tuple, tups), ast.make_tuple({}))"
            },
            {
                "url": 3648,
                "code": "def on_binop(self, node): # ('left', 'op', 'right') return op2func(node.op)(self.run(node.left), self.run(node.right))"
            },
            {
                "url": 5392,
                "code": "def compose(*parameter_functions): def composed_fn(var_name, variable, phase): for fn in parameter_functions: variable = fn(var_name, variable, phase) return variable return composed_fn"
            },
            {
                "url": 4102,
                "code": "def __init__(self, function): super(filter, self).__init__() self.function = function"
            }
        ],
        "url": 3964
    },
    {
        "nl_input": "python detect key press linux",
        "code_input": [
            {
                "url": 3892,
                "code": "def keyPressEvent(self, event): self.keyboard_event(event.key(), self.keys.ACTION_PRESS, 0)"
            },
            {
                "url": 3266,
                "code": "def on_key_press(self, symbol, modifiers): self.keyboard_event(symbol, self.keys.ACTION_PRESS, modifiers)"
            },
            {
                "url": 4927,
                "code": "def on_press_key(key, callback, suppress=False): return hook_key(key, lambda e: e.event_type == KEY_UP or callback(e), suppress=suppress)"
            },
            {
                "url": 5434,
                "code": "def keyReleaseEvent(self, event): self.keyboard_event(event.key(), self.keys.ACTION_RELEASE, 0)"
            },
            {
                "url": 4161,
                "code": "def onkeyup(self, key, keycode, ctrl, shift, alt): return (key, keycode, ctrl, shift, alt)"
            },
            {
                "url": 1990,
                "code": "def read_key(suppress=False): event = read_event(suppress) return event.name or event.scan_code"
            },
            {
                "url": 1192,
                "code": "def stop_button_click_handler(self): self.stop_button.setDisabled(True) # Interrupt computations or stop debugging if not self.shellwidget._reading: self.interrupt_kernel() else: self.shellwidget.write_to_stdin('exit')"
            },
            {
                "url": 4664,
                "code": "def wheel(delta=1): location = get_position() e = Quartz.CGEventCreateMouseEvent( None, Quartz.kCGEventScrollWheel, location, Quartz.kCGMouseButtonLeft) e2 = Quartz.CGEventCreateScrollWheelEvent( None, Quartz.kCGScrollEventUnitLine, 1, delta) Quartz.CGEventPost(Quartz.kCGHIDEventTap, e) Quartz.CGEventPost(Quartz.kCGHIDEventTap, e2)"
            },
            {
                "url": 5654,
                "code": "def mouse_event(dwFlags: int, dx: int, dy: int, dwData: int, dwExtraInfo: int) -> None: ctypes.windll.user32.mouse_event(dwFlags, dx, dy, dwData, dwExtraInfo)"
            },
            {
                "url": 4129,
                "code": "def off(self): self.win.keypad(0) curses.nocbreak() curses.echo() try: curses.curs_set(1) except: pass curses.endwin()"
            },
            {
                "url": 5666,
                "code": "def _kbhit_unix() -> bool: dr, dw, de = select.select([sys.stdin], [], [], 0) return dr != []"
            },
            {
                "url": 2473,
                "code": "def onLeftDown(self, event=None): if event is None: return self.cursor_mode_action('leftdown', event=event) self.ForwardEvent(event=event.guiEvent)"
            },
            {
                "url": 5872,
                "code": "def check_key(self, key: str) -> bool: keys = self.get_keys() return key in keys"
            },
            {
                "url": 1656,
                "code": "def install_handle_input(self): self.pointer = self.get_fptr() self.hooked = ctypes.windll.user32.SetWindowsHookExA( 13, self.pointer, ctypes.windll.kernel32.GetModuleHandleW(None), 0 ) if not self.hooked: return False return True"
            },
            {
                "url": 3024,
                "code": "def buttonUp(self, button=mouse.LEFT): self._lock.acquire() mouse.release(button) self._lock.release()"
            }
        ],
        "url": 5666
    },
    {
        "nl_input": "how to generate random binary tree in python",
        "code_input": [
            {
                "url": 5871,
                "code": "def getRandomBinaryTreeLeafNode(binaryTree): if binaryTree.internal == True: if random.random() > 0.5: return getRandomBinaryTreeLeafNode(binaryTree.left) else: return getRandomBinaryTreeLeafNode(binaryTree.right) else: return binaryTree"
            },
            {
                "url": 2892,
                "code": "def cric__decision_tree(): model = sklearn.tree.DecisionTreeClassifier(random_state=0, max_depth=4) # we want to explain the raw probability outputs of the trees model.predict = lambda X: model.predict_proba(X)[:,1] return model"
            },
            {
                "url": 3496,
                "code": "def human__decision_tree(): # build data N = 1000000 M = 3 X = np.zeros((N,M)) X.shape y = np.zeros(N) X[0, 0] = 1 y[0] = 8 X[1, 1] = 1 y[1] = 8 X[2, 0:2] = 1 y[2] = 4 # fit model xor_model = sklearn.tree.DecisionTreeRegressor(max_depth=2) xor_model.fit(X, y) return xor_model"
            },
            {
                "url": 4966,
                "code": "def to_tree(self): tree = TreeLibTree() for node in self: tree.create_node(node, node.node_id, parent=node.parent) return tree"
            },
            {
                "url": 1202,
                "code": "def random_int(maximum_value): if maximum_value == 0: return 0 elif maximum_value == 1: return random_bits(1) bits = math.floor(math.log2(maximum_value)) result = random_bits(bits) + random_int(maximum_value - ((2 ** bits) - 1)) return result"
            },
            {
                "url": 5348,
                "code": "def tree_predict(x, root, proba=False, regression=False): if isinstance(root, Leaf): if proba: return root.probabilities elif regression: return root.mean else: return root.most_frequent if root.question.match(x): return tree_predict(x, root.true_branch, proba=proba, regression=regression) else: return tree_predict(x, root.false_branch, proba=proba, regression=regression)"
            },
            {
                "url": 4669,
                "code": "def new_random_state(seed=None, fully_random=False): if seed is None: if not fully_random: # sample manually a seed instead of just RandomState(), # because the latter one # is way slower. seed = CURRENT_RANDOM_STATE.randint(SEED_MIN_VALUE, SEED_MAX_VALUE, 1)[0] return np.random.RandomState(seed)"
            },
            {
                "url": 3733,
                "code": "def random_numbers(n): return ''.join(random.SystemRandom().choice(string.digits) for _ in range(n))"
            },
            {
                "url": 3334,
                "code": "def reseed_random(seed): r = random.Random(seed) random_internal_state = r.getstate() set_random_state(random_internal_state)"
            },
            {
                "url": 5207,
                "code": "def cric__lasso(): model = sklearn.linear_model.LogisticRegression(penalty=\"l1\", C=0.002) # we want to explain the raw probability outputs of the trees model.predict = lambda X: model.predict_proba(X)[:,1] return model"
            },
            {
                "url": 3763,
                "code": "def gen_random_string(str_len): return ''.join( random.choice(string.ascii_letters + string.digits) for _ in range(str_len))"
            },
            {
                "url": 4914,
                "code": "def load(cls, tree_path): with open(tree_path) as f: tree_dict = json.load(f) return cls.from_dict(tree_dict)"
            },
            {
                "url": 4830,
                "code": "def RandomShuffle(a, seed): if seed: np.random.seed(seed) r = a.copy() np.random.shuffle(r) return r,"
            },
            {
                "url": 4270,
                "code": "def generate_random_string(chars=7): return u\"\".join(random.sample(string.ascii_letters * 2 + string.digits, chars))"
            },
            {
                "url": 4393,
                "code": "def select_random(engine, table_or_columns, limit=5): s = select(table_or_columns).order_by(func.random()).limit(limit) return engine.execute(s).fetchall()"
            }
        ],
        "url": 5871
    },
    {
        "nl_input": "python get epoch milis from datetime",
        "code_input": [
            {
                "url": 4056,
                "code": "def convertDatetime(t): epoch = datetime.datetime.utcfromtimestamp(0) delta = t - epoch millis = delta.total_seconds() * 1000 return int(millis)"
            },
            {
                "url": 929,
                "code": "def timestamp_to_microseconds(timestamp): timestamp_str = datetime.datetime.strptime(timestamp, ISO_DATETIME_REGEX) epoch_time_secs = calendar.timegm(timestamp_str.timetuple()) epoch_time_mus = epoch_time_secs * 1e6 + timestamp_str.microsecond return epoch_time_mus"
            },
            {
                "url": 1259,
                "code": "def ms_to_datetime(ms): dt = datetime.datetime.utcfromtimestamp(ms / 1000) return dt.replace(microsecond=(ms % 1000) * 1000).replace(tzinfo=pytz.utc)"
            },
            {
                "url": 5780,
                "code": "def excel_datetime(timestamp, epoch=None): if epoch is None: epoch = datetime.datetime.fromordinal(693594) return epoch + datetime.timedelta(timestamp)"
            },
            {
                "url": 459,
                "code": "def _dt_to_epoch(dt): try: epoch = dt.timestamp() except AttributeError: # py2 epoch = (dt - datetime(1970, 1, 1)).total_seconds() return epoch"
            },
            {
                "url": 115,
                "code": "def datetime_to_ms(dt): seconds = calendar.timegm(dt.utctimetuple()) return seconds * 1000 + int(dt.microsecond / 1000)"
            },
            {
                "url": 5433,
                "code": "def to_unix(cls, timestamp): if not isinstance(timestamp, datetime.datetime): raise TypeError('Time.milliseconds expects a datetime object') base = time.mktime(timestamp.timetuple()) return base"
            },
            {
                "url": 6014,
                "code": "def python_utc_datetime_to_sqlite_strftime_string( value: datetime.datetime) -> str: millisec_str = str(round(value.microsecond / 1000)).zfill(3) return value.strftime(\"%Y-%m-%d %H:%M:%S\") + \".\" + millisec_str"
            },
            {
                "url": 1263,
                "code": "def timestamp_to_datetime(timestamp): from datetime import datetime, timedelta obj = datetime.fromtimestamp(timestamp[0]) return obj + timedelta(microseconds=int(timestamp[1]))"
            },
            {
                "url": 1707,
                "code": "def _DateToEpoch(date): tz_zero = datetime.datetime.utcfromtimestamp(0) diff_sec = int((date - tz_zero).total_seconds()) return diff_sec * 1000000"
            },
            {
                "url": 131,
                "code": "def datetime64_to_datetime(dt): dt64 = np.datetime64(dt) ts = (dt64 - np.datetime64('1970-01-01T00:00:00')) / np.timedelta64(1, 's') return datetime.datetime.utcfromtimestamp(ts)"
            },
            {
                "url": 1621,
                "code": "def unixtime_to_datetime(ut): dt = datetime.datetime.utcfromtimestamp(ut) dt = dt.replace(tzinfo=tz.tzutc()) return dt"
            },
            {
                "url": 2661,
                "code": "def AmericanDateToEpoch(self, date_str): try: epoch = time.strptime(date_str, \"%m/%d/%Y\") return int(calendar.timegm(epoch)) * 1000000 except ValueError: return 0"
            },
            {
                "url": 377,
                "code": "def convert_timestamp(timestamp): datetime = dt.datetime.utcfromtimestamp(timestamp/1000.) return np.datetime64(datetime.replace(tzinfo=None))"
            },
            {
                "url": 119,
                "code": "def ToDatetime(self): return datetime.utcfromtimestamp( self.seconds + self.nanos / float(_NANOS_PER_SECOND))"
            }
        ],
        "url": 459
    },
    {
        "nl_input": "python get environ user windows",
        "code_input": [
            {
                "url": 965,
                "code": "def get_user_name(): if sys.platform == 'win32': #user = os.getenv('USERPROFILE') user = os.getenv('USERNAME') else: user = os.getenv('LOGNAME') return user"
            },
            {
                "url": 2236,
                "code": "def _get_os_environ_dict(keys): return {k: os.environ.get(k, _UNDEFINED) for k in keys}"
            },
            {
                "url": 5337,
                "code": "def on_windows (): if bjam.variable(\"NT\"): return True elif bjam.variable(\"UNIX\"): uname = bjam.variable(\"JAMUNAME\") if uname and uname[0].startswith(\"CYGWIN\"): return True return False"
            },
            {
                "url": 245,
                "code": "def _is_root(): import os import ctypes try: return os.geteuid() == 0 except AttributeError: return ctypes.windll.shell32.IsUserAnAdmin() != 0 return False"
            },
            {
                "url": 668,
                "code": "def get_python(): if sys.platform == 'win32': python = path.join(VE_ROOT, 'Scripts', 'python.exe') else: python = path.join(VE_ROOT, 'bin', 'python') return python"
            },
            {
                "url": 2932,
                "code": "def user_exists(username): try: pwd.getpwnam(username) user_exists = True except KeyError: user_exists = False return user_exists"
            },
            {
                "url": 171,
                "code": "def _platform_is_windows(platform=sys.platform): matched = platform in ('cygwin', 'win32', 'win64') if matched: error_msg = \"Windows isn't supported yet\" raise OSError(error_msg) return matched"
            },
            {
                "url": 5676,
                "code": "def _environment_variables() -> Dict[str, str]: return {key: value for key, value in os.environ.items() if _is_encodable(value)}"
            },
            {
                "url": 1156,
                "code": "def _python_rpath(self): # Windows virtualenv installation installs pip to the [Ss]cripts # folder. Here's a simple check to support: if sys.platform == 'win32': return os.path.join('Scripts', 'python.exe') return os.path.join('bin', 'python')"
            },
            {
                "url": 6162,
                "code": "def get_environment_info() -> dict: data = _environ.systems.get_system_data() data['cauldron'] = _environ.package_settings.copy() return data"
            },
            {
                "url": 3427,
                "code": "def get_active_window(): active_win = None default = wnck.screen_get_default() while gtk.events_pending(): gtk.main_iteration(False) window_list = default.get_windows() if len(window_list) == 0: print \"No Windows Found\" for win in window_list: if win.is_active(): active_win = win.get_name() return active_win"
            },
            {
                "url": 3767,
                "code": "def get_env_default(self, variable, default): if variable in os.environ: env_var = os.environ[variable] else: env_var = default return env_var"
            },
            {
                "url": 4437,
                "code": "def _get_env(self, env_var): value = os.environ.get(env_var) if not value: raise ValueError('Missing environment variable:%s' % env_var) return value"
            },
            {
                "url": 4174,
                "code": "def getWindowPID(self, hwnd): pid = ctypes.c_ulong() ctypes.windll.user32.GetWindowThreadProcessId(hwnd, ctypes.byref(pid)) return int(pid.value)"
            },
            {
                "url": 6147,
                "code": "def get_property(self, name): # type: (str) -> object with self.__properties_lock: return self.__properties.get(name, os.getenv(name))"
            }
        ],
        "url": 965
    },
    {
        "nl_input": "iterator is past the end python",
        "code_input": [
            {
                "url": 5561,
                "code": "def __next__(self): self.current += 1 if self.current > self.total: raise StopIteration else: return self.iterable[self.current - 1]"
            },
            {
                "url": 699,
                "code": "def iter_with_last(iterable): # Ensure it's an iterator and get the first field iterable = iter(iterable) prev = next(iterable) for item in iterable: # Lag by one item so I know I'm not at the end yield False, prev prev = item # Last item yield True, prev"
            },
            {
                "url": 1973,
                "code": "def iterate(obj): global next, Iteration next = next Iteration = Iteration total = len(obj) if isinstance(obj, Sized) else None iterator = iter(obj) first = True last = False i = 0 try: value = next(iterator) except StopIteration: return while True: try: next_value = next(iterator) except StopIteration: last = True yield Iteration(first, last, i, total, value) if last: return value = next_value i += 1 first = False"
            },
            {
                "url": 2047,
                "code": "def stop_at(iterable, idx): for i, item in enumerate(iterable): if i == idx: return yield item"
            },
            {
                "url": 5835,
                "code": "def __iter__(self): def generator(): for i, obj in enumerate(self._sequence): if i >= self._limit: break yield obj raise StopIteration return generator"
            },
            {
                "url": 2755,
                "code": "def next(self): # I'm pretty sure this is the completely wrong way to go about this, but # oh well, this works. if not hasattr(self, '_iter'): self._iter = self.readrow_as_dict() return self._iter.next()"
            },
            {
                "url": 4999,
                "code": "def next(self): _LOGGER.debug(\"reading next\") if self.closed: _LOGGER.debug(\"stream is closed\") raise StopIteration() line = self.readline() if not line: _LOGGER.debug(\"nothing more to read\") raise StopIteration() return line"
            },
            {
                "url": 1630,
                "code": "def peekiter(iterable): it = iter(iterable) one = next(it) def gen(): \"\"\"Generator that returns first and proxy other items from source\"\"\" yield one while True: yield next(it) return (one, gen())"
            },
            {
                "url": 4996,
                "code": "def finditer(self, string, pos=0, endpos=sys.maxint): scanner = self.scanner(string, pos, endpos) return iter(scanner.search, None)"
            },
            {
                "url": 4844,
                "code": "def do_last(environment, seq): try: return next(iter(reversed(seq))) except StopIteration: return environment.undefined('No last item, sequence was empty.')"
            },
            {
                "url": 579,
                "code": "def next (self): # File-like object. result = self.readline() if result == self._empty_buffer: raise StopIteration return result"
            },
            {
                "url": 4440,
                "code": "def next(self): item = six.next(self._item_iter) result = self._item_to_value(self._parent, item) # Since we've successfully got the next value from the # iterator, we update the number of remaining. self._remaining -= 1 return result"
            },
            {
                "url": 5783,
                "code": "def enum_mark_last(iterable, start=0): it = iter(iterable) count = start try: last = next(it) except StopIteration: return for val in it: yield count, False, last last = val count += 1 yield count, True, last"
            },
            {
                "url": 2708,
                "code": "def items(self, limit=0): i = ItemIterator(self.iterator) i.limit = limit return i"
            },
            {
                "url": 2556,
                "code": "def eof(fd): b = fd.read(1) end = len(b) == 0 if not end: curpos = fd.tell() fd.seek(curpos - 1) return end"
            }
        ],
        "url": 659
    },
    {
        "nl_input": "python if file not exist then creat",
        "code_input": [
            {
                "url": 1598,
                "code": "def check_create_folder(filename): os.makedirs(os.path.dirname(filename), exist_ok=True)"
            },
            {
                "url": 2176,
                "code": "def ensure_dir_exists(directory): if directory and not os.path.exists(directory): os.makedirs(directory)"
            },
            {
                "url": 3,
                "code": "def create_path(path): import os if not os.path.exists(path): os.makedirs(path)"
            },
            {
                "url": 1255,
                "code": "def make_directory(path): if not os.path.exists(path): # concurrent writes that try to create the same dir can fail try: os.makedirs(path) except OSError as e: if e.errno == errno.EEXIST: pass else: raise e"
            },
            {
                "url": 807,
                "code": "def makedirs(path, mode=0o777, exist_ok=False): os.makedirs(path, mode, exist_ok)"
            },
            {
                "url": 3678,
                "code": "def ensure_dir(f): d = os.path.dirname(f) if not os.path.exists(d): os.makedirs(d)"
            },
            {
                "url": 2959,
                "code": "def _file_exists(path, filename): return os.path.isfile(os.path.join(path, filename))"
            },
            {
                "url": 3035,
                "code": "def makedirs(path): if not os.path.isdir(path): os.makedirs(path) return path"
            },
            {
                "url": 2163,
                "code": "def check_exists(filename, oappend=False): if op.exists(filename): if oappend: return oappend logging.error(\"`{0}` found, overwrite (Y/N)?\".format(filename)) overwrite = (raw_input() == 'Y') else: overwrite = True return overwrite"
            },
            {
                "url": 5731,
                "code": "def file_exists(fname): try: return fname and os.path.exists(fname) and os.path.getsize(fname) > 0 except OSError: return False"
            },
            {
                "url": 2931,
                "code": "def is_valid_file(parser, arg): arg = os.path.abspath(arg) if not os.path.exists(arg): parser.error(\"The file %s does not exist!\" % arg) else: return arg"
            },
            {
                "url": 4496,
                "code": "def is_valid_file(parser,arg): if not os.path.exists(arg): parser.error(\"File %s not found\"%arg) else: return arg"
            },
            {
                "url": 4916,
                "code": "def create_dir_rec(path: Path): if not path.exists(): Path.mkdir(path, parents=True, exist_ok=True)"
            },
            {
                "url": 1166,
                "code": "def file_found(filename,force): if os.path.exists(filename) and not force: logger.info(\"Found %s; skipping...\"%filename) return True else: return False"
            },
            {
                "url": 3643,
                "code": "def do_files_exist(filenames): preexisting = [tf.io.gfile.exists(f) for f in filenames] return any(preexisting)"
            }
        ],
        "url": 1598
    },
    {
        "nl_input": "python howe to tell if path passed in is absolute or relative",
        "code_input": [
            {
                "url": 5758,
                "code": "def is_relative_url(url): if url.startswith(\"#\"): return None if url.find(\"://\") > 0 or url.startswith(\"//\"): # either 'http(s)://...' or '//cdn...' and therefore absolute return False return True"
            },
            {
                "url": 2876,
                "code": "def __absolute__(self, uri): return op.abspath(op.join(self.__path__, uri))"
            },
            {
                "url": 87,
                "code": "def relative_path(path): return os.path.join(os.path.dirname(__file__), path)"
            },
            {
                "url": 692,
                "code": "def get_absolute_path(*args): directory = os.path.dirname(os.path.abspath(__file__)) return os.path.join(directory, *args)"
            },
            {
                "url": 214,
                "code": "def _is_path(s): if isinstance(s, string_types): try: return op.exists(s) except (OSError, ValueError): return False else: return False"
            },
            {
                "url": 1607,
                "code": "def is_symlink(self): try: return S_ISLNK(self.lstat().st_mode) except OSError as e: if e.errno != ENOENT: raise # Path doesn't exist return False"
            },
            {
                "url": 762,
                "code": "def relpath(path): return os.path.normpath( os.path.join(os.path.abspath(os.path.dirname(__file__)), path) )"
            },
            {
                "url": 591,
                "code": "def rel_path(filename): return os.path.join(os.getcwd(), os.path.dirname(__file__), filename)"
            },
            {
                "url": 2209,
                "code": "def is_file(path): try: return path.expanduser().absolute().is_file() except AttributeError: return os.path.isfile(os.path.abspath(os.path.expanduser(str(path))))"
            },
            {
                "url": 4107,
                "code": "def static_url(path, absolute=False): if os.sep != '/': path = '/'.join(path.split(os.sep)) return flask.url_for('static', filename=path, _external=absolute)"
            },
            {
                "url": 5154,
                "code": "def _is_target_a_directory(link, rel_target): target = os.path.join(os.path.dirname(link), rel_target) return os.path.isdir(target)"
            },
            {
                "url": 2939,
                "code": "def is_executable(path): return os.path.isfile(path) and os.access(path, os.X_OK)"
            },
            {
                "url": 3307,
                "code": "def _rel(self, path): return os.path.relpath( str(path), self._parent).replace(os.path.sep, '/')"
            },
            {
                "url": 5887,
                "code": "def _validate_authority_uri_abs_path(host, path): if len(host) > 0 and len(path) > 0 and not path.startswith(\"/\"): raise ValueError( \"Path in a URL with authority \" \"should start with a slash ('/') if set\" )"
            },
            {
                "url": 1632,
                "code": "def is_local_url(target): ref_url = urlparse(request.host_url) test_url = urlparse(urljoin(request.host_url, target)) return test_url.scheme in ('http', 'https') and \\ ref_url.netloc == test_url.netloc"
            }
        ],
        "url": 5758
    },
    {
        "nl_input": "maker a string lowercase pythong",
        "code_input": [
            {
                "url": 5588,
                "code": "def lowercase_chars(string: any) -> str: return ''.join([c if c.islower() else '' for c in str(string)])"
            },
            {
                "url": 5614,
                "code": "def _lower(string): if not string: return \"\" new_string = [string[0].lower()] for char in string[1:]: if char.isupper(): new_string.append(\"_\") new_string.append(char.lower()) return \"\".join(new_string)"
            },
            {
                "url": 5595,
                "code": "def lower_camel_case_from_underscores(string): components = string.split('_') string = components[0] for component in components[1:]: string += component[0].upper() + component[1:] return string"
            },
            {
                "url": 3244,
                "code": "def camelcase(string): string = re.sub(r\"^[\\-_\\.]\", '', str(string)) if not string: return string return lowercase(string[0]) + re.sub(r\"[\\-_\\.\\s]([a-z])\", lambda matched: uppercase(matched.group(1)), string[1:])"
            },
            {
                "url": 3327,
                "code": "def clean(some_string, uppercase=False): if uppercase: return some_string.strip().upper() else: return some_string.strip().lower()"
            },
            {
                "url": 718,
                "code": "def camel_case_from_underscores(string): components = string.split('_') string = '' for component in components: string += component[0].upper() + component[1:] return string"
            },
            {
                "url": 5592,
                "code": "def gen_lower(x: Iterable[str]) -> Generator[str, None, None]: for string in x: yield string.lower()"
            },
            {
                "url": 5767,
                "code": "def camel_to_snake_case(string): s = _1.sub(r'\\1_\\2', string) return _2.sub(r'\\1_\\2', s).lower()"
            },
            {
                "url": 5981,
                "code": "def capitalize(string): if not string: return string if len(string) == 1: return string.upper() return string[0].upper() + string[1:].lower()"
            },
            {
                "url": 1117,
                "code": "def normalise_string(string): string = (string.strip()).lower() return re.sub(r'\\W+', '_', string)"
            },
            {
                "url": 5965,
                "code": "def snake_case(a_string): partial = re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', a_string) return re.sub('([a-z0-9])([A-Z])', r'\\1_\\2', partial).lower()"
            },
            {
                "url": 725,
                "code": "def downcaseTokens(s,l,t): return [ tt.lower() for tt in map(_ustr,t) ]"
            },
            {
                "url": 5526,
                "code": "def python(string: str): return underscore(singularize(string) if Naming._pluralize(string) else string)"
            },
            {
                "url": 6176,
                "code": "def convert_camel_case_string(name: str) -> str: string = re.sub(\"(.)([A-Z][a-z]+)\", r\"\\1_\\2\", name) return re.sub(\"([a-z0-9])([A-Z])\", r\"\\1_\\2\", string).lower()"
            },
            {
                "url": 4677,
                "code": "def camelcase2list(s, lower=False): s = re.findall(r'([A-Z][a-z0-9]+)', s) return [w.lower() for w in s] if lower else s"
            }
        ],
        "url": 1763
    },
    {
        "nl_input": "python sys stdout write new line",
        "code_input": [
            {
                "url": 1028,
                "code": "def stdoutwriteline(*args): s = \"\" for i in args: s += str(i) + \" \" s = s.strip() sys.stdout.write(str(s) + \"\\n\") sys.stdout.flush() return s"
            },
            {
                "url": 1079,
                "code": "def _stdout_raw(self, s): print(s, end='', file=sys.stdout) sys.stdout.flush()"
            },
            {
                "url": 1452,
                "code": "def printOut(value, end='\\n'): sys.stdout.write(value) sys.stdout.write(end) sys.stdout.flush()"
            },
            {
                "url": 1386,
                "code": "def redirect_stdout(new_stdout): old_stdout, sys.stdout = sys.stdout, new_stdout try: yield None finally: sys.stdout = old_stdout"
            },
            {
                "url": 3858,
                "code": "def println(msg): sys.stdout.write(msg) sys.stdout.flush() sys.stdout.write('\\x08' * len(msg)) sys.stdout.flush()"
            },
            {
                "url": 2453,
                "code": "def start(self): self.streams.append(sys.stdout) sys.stdout = self.stream"
            },
            {
                "url": 1467,
                "code": "def raw_print(*args, **kw): print(*args, sep=kw.get('sep', ' '), end=kw.get('end', '\\n'), file=sys.__stdout__) sys.__stdout__.flush()"
            },
            {
                "url": 3202,
                "code": "def linebuffered_stdout(): if sys.stdout.line_buffering: return sys.stdout orig = sys.stdout new = type(orig)(orig.buffer, encoding=orig.encoding, errors=orig.errors, line_buffering=True) new.mode = orig.mode return new"
            },
            {
                "url": 5092,
                "code": "def print_message(message=None): kwargs = {'stdout': sys.stdout, 'stderr': sys.stderr, 'shell': True} return subprocess.call('echo \"{0}\"'.format(message or ''), **kwargs)"
            },
            {
                "url": 537,
                "code": "def safe_exit(output): try: sys.stdout.write(output) sys.stdout.flush() except IOError: pass"
            },
            {
                "url": 6260,
                "code": "def capture_stdout(): stdout = sys.stdout sys.stdout = six.moves.cStringIO() try: yield sys.stdout finally: sys.stdout = stdout"
            },
            {
                "url": 1037,
                "code": "def print_out(self, *lst): self.print2file(self.stdout, True, True, *lst)"
            },
            {
                "url": 1485,
                "code": "def redirect_output(fileobj): old = sys.stdout sys.stdout = fileobj try: yield fileobj finally: sys.stdout = old"
            },
            {
                "url": 5408,
                "code": "def pstd(self, *args, **kwargs): kwargs['file'] = self.out self.print(*args, **kwargs) sys.stdout.flush()"
            },
            {
                "url": 5695,
                "code": "def suppress_stdout(): save_stdout = sys.stdout sys.stdout = DevNull() yield sys.stdout = save_stdout"
            }
        ],
        "url": 3858
    },
    {
        "nl_input": "python how to create a iterable",
        "code_input": [
            {
                "url": 3950,
                "code": "def is_iterable(obj): return ( hasattr(obj, \"__iter__\") and not isinstance(obj, str) and not isinstance(obj, tuple) )"
            },
            {
                "url": 2617,
                "code": "def ensure_iterable(inst): if isinstance(inst, string_types): return [inst] elif not isinstance(inst, collections.Iterable): return [inst] else: return inst"
            },
            {
                "url": 2522,
                "code": "def _is_iterable(item): return isinstance(item, collections.Iterable) and not isinstance(item, six.string_types)"
            },
            {
                "url": 570,
                "code": "def force_iterable(f): def wrapper(*args, **kwargs): r = f(*args, **kwargs) if hasattr(r, '__iter__'): return r else: return [r] return wrapper"
            },
            {
                "url": 1640,
                "code": "def is_iterable_but_not_string(obj): return hasattr(obj, '__iter__') and not isinstance(obj, str) and not isinstance(obj, bytes)"
            },
            {
                "url": 4204,
                "code": "def _varargs_to_iterable_method(func): def wrapped(self, iterable, **kwargs): return func(self, *iterable, **kwargs) return wrapped"
            },
            {
                "url": 2976,
                "code": "def is_iterable(value): return isinstance(value, np.ndarray) or isinstance(value, list) or isinstance(value, tuple), value"
            },
            {
                "url": 5252,
                "code": "def fromiterable(cls, itr): x, y, z = itr return cls(x, y, z)"
            },
            {
                "url": 4454,
                "code": "def assert_iter(**kw): for name, value in kw.items(): if not isiter(value): raise TypeError( 'paco: {} must be an iterable object'.format(name))"
            },
            {
                "url": 6037,
                "code": "def ensure_list(iterable: Iterable[A]) -> List[A]: if isinstance(iterable, list): return iterable else: return list(iterable)"
            },
            {
                "url": 4443,
                "code": "def extend(self, iterable): return super(Collection, self).extend( self._ensure_iterable_is_valid(iterable))"
            },
            {
                "url": 4058,
                "code": "def _iterable_to_varargs_method(func): def wrapped(self, *args, **kwargs): return func(self, args, **kwargs) return wrapped"
            },
            {
                "url": 1757,
                "code": "def items(iterable): if hasattr(iterable, 'iteritems'): return (p for p in iterable.iteritems()) elif hasattr(iterable, 'items'): return (p for p in iterable.items()) else: return (p for p in enumerate(iterable))"
            },
            {
                "url": 2443,
                "code": "def is_lazy_iterable(obj): return isinstance(obj, (types.GeneratorType, collections.MappingView, six.moves.range, enumerate))"
            },
            {
                "url": 1613,
                "code": "def is_iterable_of_int(l): r if not is_iterable(l): return False return all(is_int(value) for value in l)"
            }
        ],
        "url": 570
    },
    {
        "nl_input": "how to use python function in tensorflow",
        "code_input": [
            {
                "url": 453,
                "code": "def tf2(): # Import the `tf` compat API from this file and check if it's already TF 2.0. if tf.__version__.startswith('2.'): return tf elif hasattr(tf, 'compat') and hasattr(tf.compat, 'v2'): # As a fallback, try `tensorflow.compat.v2` if it's defined. return tf.compat.v2 raise ImportError('cannot import tensorflow 2.0 API')"
            },
            {
                "url": 2865,
                "code": "def nest(thing): tfutil = util.get_module('tensorflow.python.util') if tfutil: return tfutil.nest.flatten(thing) else: return [thing]"
            },
            {
                "url": 5649,
                "code": "def astensor(array: TensorLike) -> BKTensor: tensor = tf.convert_to_tensor(value=array, dtype=CTYPE) return tensor"
            },
            {
                "url": 3251,
                "code": "def get_tensor_device(self, tensor_name): tensor = self._name_to_tensor(tensor_name) if isinstance(tensor, tf.Tensor): return tensor.device else: # mtf.Tensor return None"
            },
            {
                "url": 5152,
                "code": "def _parse_array(self, tensor_proto): try: from onnx.numpy_helper import to_array except ImportError as e: raise ImportError(\"Unable to import onnx which is required {}\".format(e)) np_array = to_array(tensor_proto).reshape(tuple(tensor_proto.dims)) return mx.nd.array(np_array)"
            },
            {
                "url": 5691,
                "code": "def fcast(value: float) -> TensorLike: newvalue = tf.cast(value, FTYPE) if DEVICE == 'gpu': newvalue = newvalue.gpu() # Why is this needed? # pragma: no cover return newvalue"
            },
            {
                "url": 2324,
                "code": "def setup_detect_python2(): if None in [RTs._rt_py2_detect, RTs._rtp_py2_detect]: RTs._rt_py2_detect = RefactoringTool(py2_detect_fixers) RTs._rtp_py2_detect = RefactoringTool(py2_detect_fixers, {'print_function': True})"
            },
            {
                "url": 2710,
                "code": "def conv2d(x_input, w_matrix): return tf.nn.conv2d(x_input, w_matrix, strides=[1, 1, 1, 1], padding='SAME')"
            },
            {
                "url": 6218,
                "code": "def inner(tensor0: BKTensor, tensor1: BKTensor) -> BKTensor: # Note: Relying on fact that vdot flattens arrays return np.vdot(tensor0, tensor1)"
            },
            {
                "url": 1246,
                "code": "def encode_dataset(dataset, vocabulary): def encode(features): return {k: vocabulary.encode_tf(v) for k, v in features.items()} return dataset.map(encode, num_parallel_calls=tf.data.experimental.AUTOTUNE)"
            },
            {
                "url": 3919,
                "code": "def transformer_tall_pretrain_lm_tpu_adafactor(): hparams = transformer_tall_pretrain_lm() update_hparams_for_tpu(hparams) hparams.max_length = 1024 # For multi-problem on TPU we need it in absolute examples. hparams.batch_size = 8 hparams.multiproblem_vocab_size = 2**16 return hparams"
            },
            {
                "url": 4349,
                "code": "def _float_feature(value): if not isinstance(value, list): value = [value] return tf.train.Feature(float_list=tf.train.FloatList(value=value))"
            },
            {
                "url": 5114,
                "code": "def run_std_server(self): config = tf.estimator.RunConfig() server = tf.train.Server( config.cluster_spec, job_name=config.task_type, task_index=config.task_id, protocol=config.protocol) server.join()"
            },
            {
                "url": 4762,
                "code": "def encode_to_shape(inputs, shape, scope): with tf.variable_scope(scope, reuse=tf.AUTO_REUSE): w, h = shape[1], shape[2] x = inputs x = tfl.flatten(x) x = tfl.dense(x, w * h, activation=None, name=\"enc_dense\") x = tf.reshape(x, (-1, w, h, 1)) return x"
            },
            {
                "url": 4346,
                "code": "def get_example_features(example): return (example.features.feature if isinstance(example, tf.train.Example) else example.context.feature)"
            }
        ],
        "url": 4349
    },
    {
        "nl_input": "python how to get range of array with positive values numpy",
        "code_input": [
            {
                "url": 1495,
                "code": "def array(self): return np.arange(self.start, self.stop, self.step)"
            },
            {
                "url": 3123,
                "code": "def get_range(self, start=None, stop=None): return self.from_iterable(self.ranges(start, stop))"
            },
            {
                "url": 3637,
                "code": "def _nth(arr, n): try: return arr.iloc[n] except (KeyError, IndexError): return np.nan"
            },
            {
                "url": 5936,
                "code": "def set_range(self, min_val, max_val): if min_val > max_val: max_val, min_val = min_val, max_val self.values = (((self.values * 1.0 - self.values.min()) / (self.values.max() - self.values.min())) * (max_val - min_val) + min_val)"
            },
            {
                "url": 140,
                "code": "def _interval_to_bound_points(array): array_boundaries = np.array([x.left for x in array]) array_boundaries = np.concatenate( (array_boundaries, np.array([array[-1].right]))) return array_boundaries"
            },
            {
                "url": 68,
                "code": "def _xxrange(self, start, end, step_count): _step = (end - start) / float(step_count) return (start + (i * _step) for i in xrange(int(step_count)))"
            },
            {
                "url": 344,
                "code": "def index_nearest(value, array): a = (array-value)**2 return index(a.min(), a)"
            },
            {
                "url": 3405,
                "code": "def range(*args, interval=0): agen = from_iterable.raw(builtins.range(*args)) return time.spaceout.raw(agen, interval) if interval else agen"
            },
            {
                "url": 3124,
                "code": "def LinSpace(start, stop, num): return np.linspace(start, stop, num=num, dtype=np.float32),"
            },
            {
                "url": 2378,
                "code": "def smooth_array(array, amount=1): if amount==0: return array # we have to store the old values in a temp array to keep the # smoothing from affecting the smoothing new_array = _n.array(array) for n in range(len(array)): new_array[n] = smooth(array, n, amount) return new_array"
            },
            {
                "url": 3936,
                "code": "def read_numpy(fh, byteorder, dtype, count, offsetsize): dtype = 'b' if dtype[-1] == 's' else byteorder+dtype[-1] return fh.read_array(dtype, count)"
            },
            {
                "url": 5059,
                "code": "def _parse_ranges(ranges): for txt in ranges: if '-' in txt: low, high = txt.split('-') else: low, high = txt, txt yield int(low), int(high)"
            },
            {
                "url": 1885,
                "code": "def c_array(ctype, values): if isinstance(values, np.ndarray) and values.dtype.itemsize == ctypes.sizeof(ctype): return (ctype * len(values)).from_buffer_copy(values) return (ctype * len(values))(*values)"
            },
            {
                "url": 5037,
                "code": "def index_nearest(array, value): idx = (np.abs(array-value)).argmin() return idx"
            },
            {
                "url": 2387,
                "code": "def toArray(self): arr = np.zeros((self.size,), dtype=np.float64) arr[self.indices] = self.values return arr"
            }
        ],
        "url": 140
    },
    {
        "nl_input": "python 3 a build string from iterable",
        "code_input": [
            {
                "url": 160,
                "code": "def commajoin_as_strings(iterable): return _(u',').join((six.text_type(i) for i in iterable))"
            },
            {
                "url": 3796,
                "code": "def clean_strings(iterable): retval = [] for val in iterable: try: retval.append(val.strip()) except(AttributeError): retval.append(val) return retval"
            },
            {
                "url": 3730,
                "code": "def flatten( iterables ): for it in iterables: if isinstance(it, str): yield it else: for element in it: yield element"
            },
            {
                "url": 151,
                "code": "def _py2_and_3_joiner(sep, joinable): if ISPY3: sep = bytes(sep, DEFAULT_ENCODING) joined = sep.join(joinable) return joined.decode(DEFAULT_ENCODING) if ISPY3 else joined"
            },
            {
                "url": 2617,
                "code": "def ensure_iterable(inst): if isinstance(inst, string_types): return [inst] elif not isinstance(inst, collections.Iterable): return [inst] else: return inst"
            },
            {
                "url": 5643,
                "code": "def strings_to_integers(strings: Iterable[str]) -> Iterable[int]: return strings_to_(strings, lambda x: int(float(x)))"
            },
            {
                "url": 1640,
                "code": "def is_iterable_but_not_string(obj): return hasattr(obj, '__iter__') and not isinstance(obj, str) and not isinstance(obj, bytes)"
            },
            {
                "url": 4204,
                "code": "def _varargs_to_iterable_method(func): def wrapped(self, iterable, **kwargs): return func(self, *iterable, **kwargs) return wrapped"
            },
            {
                "url": 3417,
                "code": "def list2string (inlist,delimit=' '): stringlist = [makestr(_) for _ in inlist] return string.join(stringlist,delimit)"
            },
            {
                "url": 328,
                "code": "def concat(cls, iterables): def generator(): for it in iterables: for element in it: yield element return cls(generator())"
            },
            {
                "url": 5252,
                "code": "def fromiterable(cls, itr): x, y, z = itr return cls(x, y, z)"
            },
            {
                "url": 570,
                "code": "def force_iterable(f): def wrapper(*args, **kwargs): r = f(*args, **kwargs) if hasattr(r, '__iter__'): return r else: return [r] return wrapper"
            },
            {
                "url": 2522,
                "code": "def _is_iterable(item): return isinstance(item, collections.Iterable) and not isinstance(item, six.string_types)"
            },
            {
                "url": 5592,
                "code": "def gen_lower(x: Iterable[str]) -> Generator[str, None, None]: for string in x: yield string.lower()"
            },
            {
                "url": 5700,
                "code": "def list_to_str(list, separator=','): list = [str(x) for x in list] return separator.join(list)"
            }
        ],
        "url": 160
    },
    {
        "nl_input": "unchecking a radio button python",
        "code_input": [
            {
                "url": 1582,
                "code": "def checkbox_uncheck(self, force_check=False): if self.get_attribute('checked'): self.click(force_click=force_check)"
            },
            {
                "url": 5187,
                "code": "def uncheck(self, locator=None, allow_label_click=None, **kwargs): self._check_with_label( \"checkbox\", False, locator=locator, allow_label_click=allow_label_click, **kwargs)"
            },
            {
                "url": 1655,
                "code": "def set_value(self, value): if value: self.setChecked(Qt.Checked) else: self.setChecked(Qt.Unchecked)"
            },
            {
                "url": 3299,
                "code": "def check_by_selector(self, selector): elem = find_element_by_jquery(world.browser, selector) if not elem.is_selected(): elem.click()"
            },
            {
                "url": 943,
                "code": "def set_value(self, value): if value: self.setCheckState(Qt.Checked) else: self.setCheckState(Qt.Unchecked)"
            },
            {
                "url": 3925,
                "code": "def changed(self, *value): if self._last_checked_value != value: self._last_checked_value = value return True return False"
            },
            {
                "url": 1192,
                "code": "def stop_button_click_handler(self): self.stop_button.setDisabled(True) # Interrupt computations or stop debugging if not self.shellwidget._reading: self.interrupt_kernel() else: self.shellwidget.write_to_stdin('exit')"
            },
            {
                "url": 917,
                "code": "def onchange(self, value): log.debug('combo box. selected %s' % value) self.select_by_value(value) return (value, )"
            },
            {
                "url": 3498,
                "code": "def get_python(self): if self.multiselect: return super(MultiSelectField, self).get_python() return self._get()"
            },
            {
                "url": 542,
                "code": "def destroy(self): if self.widget: self.set_active(False) super(AndroidBarcodeView, self).destroy()"
            },
            {
                "url": 4671,
                "code": "def click_by_selector(self, selector): # No need for separate button press step with selector style. elem = find_element_by_jquery(world.browser, selector) elem.click()"
            },
            {
                "url": 4390,
                "code": "def submit_by_selector(self, selector): elem = find_element_by_jquery(world.browser, selector) elem.submit()"
            },
            {
                "url": 6216,
                "code": "def autoreload(self, parameter_s=''): r if parameter_s == '': self._reloader.check(True) elif parameter_s == '0': self._reloader.enabled = False elif parameter_s == '1': self._reloader.check_all = False self._reloader.enabled = True elif parameter_s == '2': self._reloader.check_all = True self._reloader.enabled = True"
            },
            {
                "url": 990,
                "code": "def init_checks_registry(): mod = inspect.getmodule(register_check) for (name, function) in inspect.getmembers(mod, inspect.isfunction): register_check(function)"
            },
            {
                "url": 3383,
                "code": "def check_no_element_by_selector(self, selector): elems = find_elements_by_jquery(world.browser, selector) if elems: raise AssertionError(\"Expected no matching elements, found {}.\".format( len(elems)))"
            }
        ],
        "url": 1582
    },
    {
        "nl_input": "python expected type sized",
        "code_input": [
            {
                "url": 2303,
                "code": "def check_type_and_size_of_param_list(param_list, expected_length): try: assert isinstance(param_list, list) assert len(param_list) == expected_length except AssertionError: msg = \"param_list must be a list containing {} elements.\" raise ValueError(msg.format(expected_length)) return None"
            },
            {
                "url": 4382,
                "code": "def _check_list_len(row, length): if len(row) != length: raise Exception( \"row length does not match expected length of \" + str(length) + \"\\nrow: \" + str(row))"
            },
            {
                "url": 285,
                "code": "def make_kind_check(python_types, numpy_kind): def check(value): if hasattr(value, 'dtype'): return value.dtype.kind == numpy_kind return isinstance(value, python_types) return check"
            },
            {
                "url": 1909,
                "code": "def size(dtype): dtype = tf.as_dtype(dtype) if hasattr(dtype, 'size'): return dtype.size return np.dtype(dtype).itemsize"
            },
            {
                "url": 1319,
                "code": "def _requiredSize(shape, dtype): return math.floor(np.prod(np.asarray(shape, dtype=np.uint64)) * np.dtype(dtype).itemsize)"
            },
            {
                "url": 1519,
                "code": "def _assert_is_type(name, value, value_type): if not isinstance(value, value_type): if type(value_type) is tuple: types = ', '.join(t.__name__ for t in value_type) raise ValueError('{0} must be one of ({1})'.format(name, types)) else: raise ValueError('{0} must be {1}' .format(name, value_type.__name__))"
            },
            {
                "url": 1955,
                "code": "def check_length(value, length): _length = len(value) if _length != length: raise ValueError(\"length must be %d, not %d\" % \\ (length, _length))"
            },
            {
                "url": 2399,
                "code": "def get_type_len(self): # Check types and set type/len self.get_sql() return self.type, self.len, self.len_decimal"
            },
            {
                "url": 67,
                "code": "def assert_list(self, putative_list, expected_type=string_types, key_arg=None): return assert_list(putative_list, expected_type, key_arg=key_arg, raise_type=lambda msg: TargetDefinitionException(self, msg))"
            },
            {
                "url": 2376,
                "code": "def validate_type(self, type_): if type_ is not None and type_ not in self.types_set: raise ValueError('Invalid type for %s:%s' % (self.__class__, type_))"
            },
            {
                "url": 192,
                "code": "def _check_elements_equal(lst): assert isinstance(lst, list), \"Input value must be a list.\" return not lst or lst.count(lst[0]) == len(lst)"
            },
            {
                "url": 713,
                "code": "def get_size(objects): res = 0 for o in objects: try: res += _getsizeof(o) except AttributeError: print(\"IGNORING: type=%s; o=%s\" % (str(type(o)), str(o))) return res"
            },
            {
                "url": 4001,
                "code": "def _check_key(self, key): if not len(key) == 2: raise TypeError('invalid key: %r' % key) elif key[1] not in TYPES: raise TypeError('invalid datatype: %s' % key[1])"
            },
            {
                "url": 3975,
                "code": "def assert_is_instance(value, types, message=None, extra=None): assert isinstance(value, types), _assert_fail_message( message, value, types, \"is not an instance of\", extra )"
            },
            {
                "url": 2772,
                "code": "def __len__(self): length = 0 for typ, siz, _ in self.format: length += siz return length"
            }
        ],
        "url": 1319
    },
    {
        "nl_input": "python load csv to numpy array",
        "code_input": [
            {
                "url": 5746,
                "code": "def csv_to_numpy(string_like, dtype=None): # type: (str) -> np.array stream = StringIO(string_like) return np.genfromtxt(stream, dtype=dtype, delimiter=',')"
            },
            {
                "url": 962,
                "code": "def load_data(filename): data = pandas.read_csv(filename, header=None, delimiter='\\t', skiprows=9) return data.as_matrix()"
            },
            {
                "url": 126,
                "code": "def convert_array(array): out = io.BytesIO(array) out.seek(0) return np.load(out)"
            },
            {
                "url": 57,
                "code": "def csv_to_dicts(file, header=None): with open(file) as csvfile: return [row for row in csv.DictReader(csvfile, fieldnames=header)]"
            },
            {
                "url": 2742,
                "code": "def csvtolist(inputstr): reader = csv.reader([inputstr], skipinitialspace=True) output = [] for r in reader: output += r return output"
            },
            {
                "url": 6117,
                "code": "def numpy_to_yaml(representer: Representer, data: np.ndarray) -> Sequence[Any]: return representer.represent_sequence( \"!numpy_array\", data.tolist() )"
            },
            {
                "url": 5152,
                "code": "def _parse_array(self, tensor_proto): try: from onnx.numpy_helper import to_array except ImportError as e: raise ImportError(\"Unable to import onnx which is required {}\".format(e)) np_array = to_array(tensor_proto).reshape(tuple(tensor_proto.dims)) return mx.nd.array(np_array)"
            },
            {
                "url": 5880,
                "code": "def array_to_npy(array_like): # type: (np.array or Iterable or int or float) -> object buffer = BytesIO() np.save(buffer, array_like) return buffer.getvalue()"
            },
            {
                "url": 666,
                "code": "def read_array(path, mmap_mode=None): file_ext = op.splitext(path)[1] if file_ext == '.npy': return np.load(path, mmap_mode=mmap_mode) raise NotImplementedError(\"The file extension `{}` \".format(file_ext) + \"is not currently supported.\")"
            },
            {
                "url": 3018,
                "code": "def _openResources(self): arr = np.load(self._fileName, allow_pickle=ALLOW_PICKLE) check_is_an_array(arr) self._array = arr"
            },
            {
                "url": 304,
                "code": "def torecarray(*args, **kwargs): import numpy as np return toarray(*args, **kwargs).view(np.recarray)"
            },
            {
                "url": 2619,
                "code": "def dump_nparray(self, obj, class_name=numpy_ndarray_class_name): return {\"$\" + class_name: self._json_convert(obj.tolist())}"
            },
            {
                "url": 231,
                "code": "def deserialize_ndarray_npy(d): with io.BytesIO() as f: f.write(json.loads(d['npy']).encode('latin-1')) f.seek(0) return np.load(f)"
            },
            {
                "url": 1635,
                "code": "def get_data_table(filename): with get_file_object(filename, \"r\") as rf: return DataTable(list(csv.reader(rf)))"
            },
            {
                "url": 1583,
                "code": "def dict_to_numpy_array(d): return fromarrays(d.values(), np.dtype([(str(k), v.dtype) for k, v in d.items()]))"
            }
        ],
        "url": 5746
    },
    {
        "nl_input": "python remove element from list time complexity",
        "code_input": [
            {
                "url": 1019,
                "code": "def pop(self, index=-1): value = self._list.pop(index) del self._dict[value] return value"
            },
            {
                "url": 4214,
                "code": "def remove(self, entry): try: list = self.cache[entry.key] list.remove(entry) except: pass"
            },
            {
                "url": 3146,
                "code": "def pop (self, key): if key in self._keys: self._keys.remove(key) super(ListDict, self).pop(key)"
            },
            {
                "url": 4062,
                "code": "def __delitem__(self, key): index, value = self._dict.pop(key) key2, value2 = self._list.pop(index) assert key == key2 assert value is value2 self._fix_indices_after_delete(index)"
            },
            {
                "url": 4874,
                "code": "def __delitem__ (self, key): self._keys.remove(key) super(ListDict, self).__delitem__(key)"
            },
            {
                "url": 4278,
                "code": "def rpop(self, key): redis_list = self._get_list(key, 'RPOP') if self._encode(key) not in self.redis: return None try: value = redis_list.pop() if len(redis_list) == 0: self.delete(key) return value except (IndexError): # Redis returns nil if popping from an empty list return None"
            },
            {
                "url": 5165,
                "code": "def remove_element(self, e): if e.label is not None: self.elementdict.pop(e.label) self.elementlist.remove(e)"
            },
            {
                "url": 5594,
                "code": "def dictlist_wipe_key(dict_list: Iterable[Dict], key: str) -> None: for d in dict_list: d.pop(key, None)"
            },
            {
                "url": 2777,
                "code": "def remove(self, key): item = self.item_finder.pop(key) item[-1] = None self.removed_count += 1"
            },
            {
                "url": 837,
                "code": "def remove_elements(target, indices): copied = list(target) for index in reversed(indices): del copied[index] return copied"
            },
            {
                "url": 4422,
                "code": "def DeleteIndex(self, index): to_remove = None for i in self.Items: if i.index == index: to_remove = i if to_remove: self.Items.remove(to_remove)"
            },
            {
                "url": 1902,
                "code": "def remove(parent, idx): if isinstance(parent, dict): del parent[idx] elif isinstance(parent, list): del parent[int(idx)] else: raise JSONPathError(\"Invalid path for operation\")"
            },
            {
                "url": 2281,
                "code": "def _remove_none_values(dictionary): return list(map(dictionary.pop, [i for i in dictionary if dictionary[i] is None]))"
            },
            {
                "url": 1114,
                "code": "def discard(self, element): try: i = int(element) set.discard(self, i) except ValueError: pass"
            },
            {
                "url": 5569,
                "code": "def _rindex(mylist: Sequence[T], x: T) -> int: return len(mylist) - mylist[::-1].index(x) - 1"
            }
        ],
        "url": 837
    },
    {
        "nl_input": "python property by string name",
        "code_input": [
            {
                "url": 2898,
                "code": "def get_propety_by_name(pif, name): warn(\"This method has been deprecated in favor of get_property_by_name\") return next((x for x in pif.properties if x.name == name), None)"
            },
            {
                "url": 439,
                "code": "def get_property_by_name(pif, name): return next((x for x in pif.properties if x.name == name), None)"
            },
            {
                "url": 2980,
                "code": "def get_property(self, property_name): prop = self.find_property(property_name) if prop: return prop.get_value() return None"
            },
            {
                "url": 6147,
                "code": "def get_property(self, name): # type: (str) -> object with self.__properties_lock: return self.__properties.get(name, os.getenv(name))"
            },
            {
                "url": 3167,
                "code": "def __getattr__(self, name): try: return self.__dict__[name] except KeyError: if hasattr(self._properties,name): return getattr(self._properties, name)"
            },
            {
                "url": 2893,
                "code": "def get_properties(cls): property_names = [p for p in dir(cls) if isinstance(getattr(cls, p), property)] return property_names"
            },
            {
                "url": 4697,
                "code": "def get_property(self): scope = self def fget(self): \"\"\"Call the HasProperties _get method\"\"\" return self._get(scope.name) return property(fget=fget, doc=scope.sphinx())"
            },
            {
                "url": 6091,
                "code": "def get_property_as_float(self, name: str) -> float: return float(self.__instrument.get_property(name))"
            },
            {
                "url": 5640,
                "code": "def get_prop_value(name, props, default=None): # type: (str, Dict[str, Any], Any) -> Any if not props: return default try: return props[name] except KeyError: return default"
            },
            {
                "url": 4383,
                "code": "def getprop(self, prop_name): return self.shell( ['getprop', prop_name], timeout=DEFAULT_GETPROP_TIMEOUT_SEC).decode('utf-8').strip()"
            },
            {
                "url": 683,
                "code": "def get_property(self, filename): with open(self.filepath(filename)) as f: return f.read().strip()"
            },
            {
                "url": 5401,
                "code": "def get_param_names(cls): return [m[0] for m in inspect.getmembers(cls) \\ if type(m[1]) == property]"
            },
            {
                "url": 3608,
                "code": "def _make_proxy_property(bind_attr, attr_name): def proxy_property(self): bind = getattr(self, bind_attr) return getattr(bind, attr_name) return property(proxy_property)"
            },
            {
                "url": 5162,
                "code": "def property_as_list(self, property_name): try: res = self._a_tags[property_name] except KeyError: return [] if type(res) == list: return res else: return [res]"
            },
            {
                "url": 3153,
                "code": "def remove_property(self, key=None, value=None): for k, v in self.properties[:]: if (key is None or key == k) and (value is None or value == v): del(self.properties[self.properties.index((k, v))])"
            }
        ],
        "url": 2898
    },
    {
        "nl_input": "index of an entry in a list python",
        "code_input": [
            {
                "url": 456,
                "code": "def get_list_index(lst, index_or_name): if isinstance(index_or_name, six.integer_types): return index_or_name return lst.index(index_or_name)"
            },
            {
                "url": 6214,
                "code": "def index(self, item): for i, x in enumerate(self.iter()): if x == item: return i return None"
            },
            {
                "url": 719,
                "code": "def list_get(l, idx, default=None): try: if l[idx]: return l[idx] else: return default except IndexError: return default"
            },
            {
                "url": 5569,
                "code": "def _rindex(mylist: Sequence[T], x: T) -> int: return len(mylist) - mylist[::-1].index(x) - 1"
            },
            {
                "url": 4613,
                "code": "def get_index_nested(x, i): for ind in range(len(x)): if i == x[ind]: return ind return -1"
            },
            {
                "url": 2031,
                "code": "def index(self, elem): return _coconut.len(self._iter) - self._iter.index(elem) - 1"
            },
            {
                "url": 2075,
                "code": "def index(m, val): mm = np.array(m) idx_tuple = np.where(mm == val) idx = idx_tuple[0].tolist() return idx"
            },
            {
                "url": 6041,
                "code": "def _get_or_default(mylist, i, default=None): if i >= len(mylist): return default else : return mylist[i]"
            },
            {
                "url": 2966,
                "code": "def _get_item_position(self, idx): start = 0 if idx == 0 else self._index[idx - 1] + 1 end = self._index[idx] return start, end"
            },
            {
                "url": 1019,
                "code": "def pop(self, index=-1): value = self._list.pop(index) del self._dict[value] return value"
            },
            {
                "url": 5821,
                "code": "def getIndex(predicateFn: Callable[[T], bool], items: List[T]) -> int: try: return next(i for i, v in enumerate(items) if predicateFn(v)) except StopIteration: return -1"
            },
            {
                "url": 5545,
                "code": "def find_first_in_list(txt: str, str_list: [str]) -> int: # type: ignore start = len(txt) + 1 for item in str_list: if start > txt.find(item) > -1: start = txt.find(item) return start if len(txt) + 1 > start > -1 else -1"
            },
            {
                "url": 2928,
                "code": "def filter_list_by_indices(lst, indices): return [x for i, x in enumerate(lst) if i in indices]"
            },
            {
                "url": 320,
                "code": "def count_list(the_list): count = the_list.count result = [(item, count(item)) for item in set(the_list)] result.sort() return result"
            },
            {
                "url": 2444,
                "code": "def is_in(self, search_list, pair): index = -1 for nr, i in enumerate(search_list): if(np.all(i == pair)): return nr return index"
            }
        ],
        "url": 2444
    },
    {
        "nl_input": "python how to determine if an iterable is iterable",
        "code_input": [
            {
                "url": 2976,
                "code": "def is_iterable(value): return isinstance(value, np.ndarray) or isinstance(value, list) or isinstance(value, tuple), value"
            },
            {
                "url": 2522,
                "code": "def _is_iterable(item): return isinstance(item, collections.Iterable) and not isinstance(item, six.string_types)"
            },
            {
                "url": 3950,
                "code": "def is_iterable(obj): return ( hasattr(obj, \"__iter__\") and not isinstance(obj, str) and not isinstance(obj, tuple) )"
            },
            {
                "url": 1613,
                "code": "def is_iterable_of_int(l): r if not is_iterable(l): return False return all(is_int(value) for value in l)"
            },
            {
                "url": 1640,
                "code": "def is_iterable_but_not_string(obj): return hasattr(obj, '__iter__') and not isinstance(obj, str) and not isinstance(obj, bytes)"
            },
            {
                "url": 2617,
                "code": "def ensure_iterable(inst): if isinstance(inst, string_types): return [inst] elif not isinstance(inst, collections.Iterable): return [inst] else: return inst"
            },
            {
                "url": 5900,
                "code": "def is_iterable(etype) -> bool: return type(etype) is GenericMeta and issubclass(etype.__extra__, Iterable)"
            },
            {
                "url": 2443,
                "code": "def is_lazy_iterable(obj): return isinstance(obj, (types.GeneratorType, collections.MappingView, six.moves.range, enumerate))"
            },
            {
                "url": 4454,
                "code": "def assert_iter(**kw): for name, value in kw.items(): if not isiter(value): raise TypeError( 'paco: {} must be an iterable object'.format(name))"
            },
            {
                "url": 657,
                "code": "def is_iter_non_string(obj): if isinstance(obj, list) or isinstance(obj, tuple): return True return False"
            },
            {
                "url": 94,
                "code": "def listlike(obj): return hasattr(obj, \"__iter__\") \\ and not issubclass(type(obj), str)\\ and not issubclass(type(obj), unicode)"
            },
            {
                "url": 1757,
                "code": "def items(iterable): if hasattr(iterable, 'iteritems'): return (p for p in iterable.iteritems()) elif hasattr(iterable, 'items'): return (p for p in iterable.items()) else: return (p for p in enumerate(iterable))"
            },
            {
                "url": 2401,
                "code": "def ensure_tuple(obj): if obj is None: return tuple() if isinstance(obj, Iterable) and not isinstance(obj, six.string_types): return tuple(obj) return obj,"
            },
            {
                "url": 753,
                "code": "def is_seq(obj): if not hasattr(obj, '__iter__'): return False if isinstance(obj, basestring): return False return True"
            },
            {
                "url": 6037,
                "code": "def ensure_list(iterable: Iterable[A]) -> List[A]: if isinstance(iterable, list): return iterable else: return list(iterable)"
            }
        ],
        "url": 2522
    },
    {
        "nl_input": "python how to create date from string",
        "code_input": [
            {
                "url": 1700,
                "code": "def string_to_date(value): if isinstance(value, datetime.date): return value return dateutil.parser.parse(value).date()"
            },
            {
                "url": 5854,
                "code": "def _parse_date(string: str) -> datetime.date: return datetime.datetime.strptime(string, '%Y-%m-%d').date()"
            },
            {
                "url": 888,
                "code": "def parse_date(s): if isinstance(s, (datetime.datetime, datetime.date)): return s try: from dateutil.parser import parse except ImportError: parse = lambda d: datetime.datetime.strptime(d, \"%Y-%m-%d\") return parse(s)"
            },
            {
                "url": 4288,
                "code": "def stringToDate(fmt=\"%Y-%m-%d\"): import time import datetime def conv_func(s): return datetime.date(*time.strptime(s,fmt)[:3]) return conv_func"
            },
            {
                "url": 2020,
                "code": "def get_date(date): if type(date) is str: return datetime.strptime(date, '%Y-%m-%d').date() else: return date"
            },
            {
                "url": 5950,
                "code": "def iso_string_to_python_datetime( isostring: str) -> Optional[datetime.datetime]: if not isostring: return None # if you parse() an empty string, you get today's date return dateutil.parser.parse(isostring)"
            },
            {
                "url": 886,
                "code": "def deserialize_date(string): try: from dateutil.parser import parse return parse(string).date() except ImportError: return string"
            },
            {
                "url": 2523,
                "code": "def _parse(self, date_str, format='%Y-%m-%d'): rv = pd.to_datetime(date_str, format=format) if hasattr(rv, 'to_pydatetime'): rv = rv.to_pydatetime() return rv"
            },
            {
                "url": 1195,
                "code": "def _validate_date_str(str_): if not str_: return None # Convert to datetime so we can validate it's a real date that exists then # convert it back to the string. try: date = datetime.strptime(str_, DATE_FMT) except ValueError: msg = 'Invalid date format, should be YYYY-MM-DD' raise argparse.ArgumentTypeError(msg) return date.strftime(DATE_FMT)"
            },
            {
                "url": 107,
                "code": "def parse(self, s): return datetime.datetime.strptime(s, self.date_format).date()"
            },
            {
                "url": 571,
                "code": "def _read_date_from_string(str1): full_date = [int(x) for x in str1.split('/')] return datetime.date(full_date[0], full_date[1], full_date[2])"
            },
            {
                "url": 2764,
                "code": "def _converter(self, value): if not isinstance(value, datetime.date): raise TypeError('{0} is not valid date'.format(value)) return value"
            },
            {
                "url": 4870,
                "code": "def convert_date(date): date = convert_month(date, shorten=False) clean_string = convert_string(date) return datetime.strptime(clean_string, DATE_FMT.replace('-',''))"
            },
            {
                "url": 154,
                "code": "def _datetime_to_date(arg): _arg = parse(arg) if isinstance(_arg, datetime.datetime): _arg = _arg.date() return _arg"
            },
            {
                "url": 2664,
                "code": "def convert_time_string(date_str): dt, _, _ = date_str.partition(\".\") dt = datetime.strptime(dt, \"%Y-%m-%dT%H:%M:%S\") return dt"
            }
        ],
        "url": 5766
    },
    {
        "nl_input": "how to append a line in a file in the middle of file in python",
        "code_input": [
            {
                "url": 5347,
                "code": "def append_text(self, txt): with open(self.fullname, \"a\") as myfile: myfile.write(txt)"
            },
            {
                "url": 629,
                "code": "def prepend_line(filepath, line): with open(filepath) as f: lines = f.readlines() lines.insert(0, line) with open(filepath, 'w') as f: f.writelines(lines)"
            },
            {
                "url": 701,
                "code": "def filename_addstring(filename, text): fn, ext = os.path.splitext(filename) return fn + text + ext"
            },
            {
                "url": 1502,
                "code": "def append(self, item): print(item) super(MyList, self).append(item)"
            },
            {
                "url": 5623,
                "code": "def write_text(filename: str, text: str) -> None: with open(filename, 'w') as f: # type: TextIO print(text, file=f)"
            },
            {
                "url": 1372,
                "code": "def append_pdf(input_pdf: bytes, output_writer: PdfFileWriter): append_memory_pdf_to_writer(input_pdf=input_pdf, writer=output_writer)"
            },
            {
                "url": 5455,
                "code": "def put_text(self, key, text): with open(key, \"w\") as fh: fh.write(text)"
            },
            {
                "url": 5707,
                "code": "def is_line_in_file(filename: str, line: str) -> bool: assert \"\\n\" not in line with open(filename, \"r\") as file: for fileline in file: if fileline == line: return True return False"
            },
            {
                "url": 2601,
                "code": "def add_text_to_image(fname, txt, opFilename): ft = ImageFont.load(\"T://user//dev//src//python//_AS_LIB//timR24.pil\") #wh = ft.getsize(txt) print(\"Adding text \", txt, \" to \", fname, \" pixels wide to file \" , opFilename) im = Image.open(fname) draw = ImageDraw.Draw(im) draw.text((0, 0), txt, fill=(0, 0, 0), font=ft) del draw im.save(opFilename)"
            },
            {
                "url": 4691,
                "code": "def write_to_file(file_path, contents, encoding=\"utf-8\"): with codecs.open(file_path, \"w\", encoding) as f: f.write(contents)"
            },
            {
                "url": 428,
                "code": "def go_to_new_line(self): self.stdkey_end(False, False) self.insert_text(self.get_line_separator())"
            },
            {
                "url": 2415,
                "code": "def write_line(self, line, count=1): self.write(line) self.write_newlines(count)"
            },
            {
                "url": 2013,
                "code": "def example_write_file_to_disk_if_changed(): my_file = FileAsObj('/tmp/example_file.txt') my_file.rm(my_file.egrep('^#')) if my_file.changed: my_file.save()"
            },
            {
                "url": 3389,
                "code": "def writefile(openedfile, newcontents): openedfile.seek(0) openedfile.truncate() openedfile.write(newcontents)"
            },
            {
                "url": 4628,
                "code": "def append_query_parameter(url, parameters, ignore_if_exists=True): if ignore_if_exists: for key in parameters.keys(): if key + \"=\" in url: del parameters[key] parameters_str = \"&\".join(k + \"=\" + v for k, v in parameters.items()) append_token = \"&\" if \"?\" in url else \"?\" return url + append_token + parameters_str"
            }
        ],
        "url": 629
    },
    {
        "nl_input": "how to split a string by every character in python",
        "code_input": [
            {
                "url": 1545,
                "code": "def _split(string, splitters): part = '' for character in string: if character in splitters: yield part part = '' else: part += character yield part"
            },
            {
                "url": 5205,
                "code": "def split_string(text, chars_per_string): return [text[i:i + chars_per_string] for i in range(0, len(text), chars_per_string)]"
            },
            {
                "url": 424,
                "code": "def _split_str(s, n): length = len(s) return [s[i:i + n] for i in range(0, length, n)]"
            },
            {
                "url": 5698,
                "code": "def multi_split(s, split): # type: (S, Iterable[S]) -> List[S] for r in split: s = s.replace(r, \"|\") return [i for i in s.split(\"|\") if len(i) > 0]"
            },
            {
                "url": 4458,
                "code": "def _split_python(python): python = _preprocess(python) if not python: return [] lexer = PythonSplitLexer() lexer.read(python) return lexer.chunks"
            },
            {
                "url": 4930,
                "code": "def splitBy(data, num): return [data[i:i + num] for i in range(0, len(data), num)]"
            },
            {
                "url": 372,
                "code": "def split(s): l = [_split(x) for x in _SPLIT_RE.split(s)] return [item for sublist in l for item in sublist]"
            },
            {
                "url": 3850,
                "code": "def _split(value): if isinstance(value, str): # iterable, but not meant for splitting return value, value try: invalue, outvalue = value except TypeError: invalue = outvalue = value except ValueError: raise ValueError(\"Only single values and pairs are allowed\") return invalue, outvalue"
            },
            {
                "url": 2914,
                "code": "def split_every(iterable, n): # TODO: Remove this, or make it return a generator. i = iter(iterable) piece = list(islice(i, n)) while piece: yield piece piece = list(islice(i, n))"
            },
            {
                "url": 3224,
                "code": "def split_len(s, length): return [s[i:i+length] for i in range(0, len(s), length)]"
            },
            {
                "url": 4340,
                "code": "def schunk(string, size): return [string[i:i+size] for i in range(0, len(string), size)]"
            },
            {
                "url": 392,
                "code": "def _split_comma_separated(string): return set(text.strip() for text in string.split(',') if text.strip())"
            },
            {
                "url": 1146,
                "code": "def split_strings_in_list_retain_spaces(orig_list): temp_list = list() for line in orig_list: line_split = __re.split(r'(\\s+)', line) temp_list.append(line_split) return temp_list"
            },
            {
                "url": 5338,
                "code": "def generate_chunks(string, num_chars): for start in range(0, len(string), num_chars): yield string[start:start+num_chars]"
            },
            {
                "url": 5571,
                "code": "def split(text: str) -> List[str]: return [word for word in SEPARATOR.split(text) if word.strip(' \\t')]"
            }
        ],
        "url": 1545
    },
    {
        "nl_input": "python get index of element each time it appears in list",
        "code_input": [
            {
                "url": 456,
                "code": "def get_list_index(lst, index_or_name): if isinstance(index_or_name, six.integer_types): return index_or_name return lst.index(index_or_name)"
            },
            {
                "url": 6214,
                "code": "def index(self, item): for i, x in enumerate(self.iter()): if x == item: return i return None"
            },
            {
                "url": 719,
                "code": "def list_get(l, idx, default=None): try: if l[idx]: return l[idx] else: return default except IndexError: return default"
            },
            {
                "url": 5619,
                "code": "def _duplicates(list_): item_indices = {} for i, item in enumerate(list_): try: item_indices[item].append(i) except KeyError: # First time seen item_indices[item] = [i] return item_indices"
            },
            {
                "url": 5569,
                "code": "def _rindex(mylist: Sequence[T], x: T) -> int: return len(mylist) - mylist[::-1].index(x) - 1"
            },
            {
                "url": 2031,
                "code": "def index(self, elem): return _coconut.len(self._iter) - self._iter.index(elem) - 1"
            },
            {
                "url": 5821,
                "code": "def getIndex(predicateFn: Callable[[T], bool], items: List[T]) -> int: try: return next(i for i, v in enumerate(items) if predicateFn(v)) except StopIteration: return -1"
            },
            {
                "url": 5545,
                "code": "def find_first_in_list(txt: str, str_list: [str]) -> int: # type: ignore start = len(txt) + 1 for item in str_list: if start > txt.find(item) > -1: start = txt.find(item) return start if len(txt) + 1 > start > -1 else -1"
            },
            {
                "url": 567,
                "code": "def _ensure_element(tup, elem): try: return tup, tup.index(elem) except ValueError: return tuple(chain(tup, (elem,))), len(tup)"
            },
            {
                "url": 2444,
                "code": "def is_in(self, search_list, pair): index = -1 for nr, i in enumerate(search_list): if(np.all(i == pair)): return nr return index"
            },
            {
                "url": 2075,
                "code": "def index(m, val): mm = np.array(m) idx_tuple = np.where(mm == val) idx = idx_tuple[0].tolist() return idx"
            },
            {
                "url": 2358,
                "code": "def unique_element(ll): seen = {} result = [] for item in ll: if item in seen: continue seen[item] = 1 result.append(item) return result"
            },
            {
                "url": 192,
                "code": "def _check_elements_equal(lst): assert isinstance(lst, list), \"Input value must be a list.\" return not lst or lst.count(lst[0]) == len(lst)"
            },
            {
                "url": 4613,
                "code": "def get_index_nested(x, i): for ind in range(len(x)): if i == x[ind]: return ind return -1"
            },
            {
                "url": 3021,
                "code": "def elem_find(self, field, value): if isinstance(value, (int, float, str)): value = [value] f = list(self.__dict__[field]) uid = np.vectorize(f.index)(value) return self.get_idx(uid)"
            }
        ],
        "url": 6214
    },
    {
        "nl_input": "python how to make dot character",
        "code_input": [
            {
                "url": 2350,
                "code": "def _dotify(cls, data): return ''.join(char if char in cls.PRINTABLE_DATA else '.' for char in data)"
            },
            {
                "url": 2518,
                "code": "def save_dot(self, fd): from pylon.io import DotWriter DotWriter(self).write(fd)"
            },
            {
                "url": 5811,
                "code": "def cmd_dot(conf: Config): build_context = BuildContext(conf) populate_targets_graph(build_context, conf) if conf.output_dot_file is None: write_dot(build_context, conf, sys.stdout) else: with open(conf.output_dot_file, 'w') as out_file: write_dot(build_context, conf, out_file)"
            },
            {
                "url": 5982,
                "code": "def export_to_dot(self, filename: str = 'output') -> None: with open(filename + '.dot', 'w') as output: output.write(self.as_dot())"
            },
            {
                "url": 5070,
                "code": "def plot_dot_graph(graph, filename=None): if not plot.pygraphviz_available: logger.error(\"Pygraphviz is not installed, cannot generate graph plot!\") return if not plot.PIL_available: logger.error(\"PIL is not installed, cannot display graph plot!\") return agraph = AGraph(graph) agraph.layout(prog='dot') if filename is None: filename = tempfile.mktemp(suffix=\".png\") agraph.draw(filename) image = Image.open(filename) image.show()"
            },
            {
                "url": 875,
                "code": "def to_dotfile(self): domain = self.get_domain() filename = \"%s.dot\" % (self.__class__.__name__) nx.write_dot(domain, filename) return filename"
            },
            {
                "url": 489,
                "code": "def _text_to_graphiz(self, text): dot = Source(text, format='svg') return dot.pipe().decode('utf-8')"
            },
            {
                "url": 5284,
                "code": "def cli(yamlfile, directory, out, classname, format): DotGenerator(yamlfile, format).serialize(classname=classname, dirname=directory, filename=out)"
            },
            {
                "url": 2908,
                "code": "def graph_from_dot_file(path): fd = file(path, 'rb') data = fd.read() fd.close() return graph_from_dot_data(data)"
            },
            {
                "url": 3702,
                "code": "def to_dotfile(G: nx.DiGraph, filename: str): A = to_agraph(G) A.write(filename)"
            },
            {
                "url": 3618,
                "code": "def exit_if_missing_graphviz(self): (out, err) = utils.capture_shell(\"which dot\") if \"dot\" not in out: ui.error(c.MESSAGES[\"dot_missing\"])"
            },
            {
                "url": 1756,
                "code": "def draw(graph, fname): ag = networkx.nx_agraph.to_agraph(graph) ag.draw(fname, prog='dot')"
            },
            {
                "url": 2911,
                "code": "def depgraph_to_dotsrc(dep_graph, show_cycles, nodot, reverse): if show_cycles: dotsrc = cycles2dot(dep_graph, reverse=reverse) elif not nodot: dotsrc = dep2dot(dep_graph, reverse=reverse) else: dotsrc = None return dotsrc"
            },
            {
                "url": 4394,
                "code": "def join_field(path): output = \".\".join([f.replace(\".\", \"\\\\.\") for f in path if f != None]) return output if output else \".\""
            },
            {
                "url": 4660,
                "code": "def _intermediary_to_dot(tables, relationships): t = '\\n'.join(t.to_dot() for t in tables) r = '\\n'.join(r.to_dot() for r in relationships) return '{}\\n{}\\n{}\\n}}'.format(GRAPH_BEGINNING, t, r)"
            }
        ],
        "url": 2350
    },
    {
        "nl_input": "python heap top element",
        "code_input": [
            {
                "url": 1971,
                "code": "def _heappop_max(heap): lastelt = heap.pop() # raises appropriate IndexError if heap is empty if heap: returnitem = heap[0] heap[0] = lastelt _siftup_max(heap, 0) return returnitem return lastelt"
            },
            {
                "url": 2739,
                "code": "def heappop_max(heap): lastelt = heap.pop() # raises appropriate IndexError if heap is empty if heap: returnitem = heap[0] heap[0] = lastelt _siftup_max(heap, 0) return returnitem return lastelt"
            },
            {
                "url": 509,
                "code": "def _heappush_max(heap, item): heap.append(item) heapq._siftdown_max(heap, 0, len(heap) - 1)"
            },
            {
                "url": 508,
                "code": "def heappush_max(heap, item): heap.append(item) _siftdown_max(heap, 0, len(heap) - 1)"
            },
            {
                "url": 3422,
                "code": "def get_top_priority(self): if self.is_empty(): raise IndexError(\"Priority queue is empty.\") _, _, element = heapq.heappop(self.pq) if element in self.element_finder: del self.element_finder[element] return element"
            },
            {
                "url": 4462,
                "code": "def _heapreplace_max(heap, item): returnitem = heap[0] # raises appropriate IndexError if heap is empty heap[0] = item _siftup_max(heap, 0) return returnitem"
            },
            {
                "url": 511,
                "code": "def _heapify_max(x): n = len(x) for i in reversed(range(n//2)): _siftup_max(x, i)"
            },
            {
                "url": 2698,
                "code": "def push(self, el): count = next(self.counter) heapq.heappush(self._queue, (el, count))"
            },
            {
                "url": 2286,
                "code": "def PopTask(self): try: _, task = heapq.heappop(self._heap) except IndexError: return None self._task_identifiers.remove(task.identifier) return task"
            },
            {
                "url": 2642,
                "code": "def swap_priority(self, key1, key2): heap = self._heap position = self._position if key1 not in self or key2 not in self: raise KeyError pos1, pos2 = position[key1], position[key2] heap[pos1].key, heap[pos2].key = key2, key1 position[key1], position[key2] = pos2, pos1"
            },
            {
                "url": 4842,
                "code": "def qth_pw(self, q): return heapq.nlargest(q + 2, self._T.iteritems(), key=operator.itemgetter(1))[-1]"
            },
            {
                "url": 2725,
                "code": "def nlargest(self, n=None): if n is None: return sorted(self.counts(), key=itemgetter(1), reverse=True) else: return heapq.nlargest(n, self.counts(), key=itemgetter(1))"
            },
            {
                "url": 400,
                "code": "def pop(h): n = h.size() - 1 h.swap(0, n) down(h, 0, n) return h.pop()"
            },
            {
                "url": 5556,
                "code": "def top(self, topn=10): return [self[i] for i in argsort(list(zip(*self))[1])[::-1][:topn]]"
            },
            {
                "url": 702,
                "code": "def pop(self): if not self.empty(): val = self.stack[-1] del self.stack[-1] return val"
            }
        ],
        "url": 400
    },
    {
        "nl_input": "in python, how to print strings in different colours",
        "code_input": [
            {
                "url": 1026,
                "code": "def cprint(string, fg=None, bg=None, end='\\n', target=sys.stdout): _color_manager.set_color(fg, bg) target.write(string + end) target.flush() # Needed for Python 3.x _color_manager.set_defaults()"
            },
            {
                "url": 1227,
                "code": "def color_string(color, string): if not color_available: return string return color + string + colorama.Fore.RESET"
            },
            {
                "url": 3030,
                "code": "def colorize(string, color, *args, **kwargs): string = string.format(*args, **kwargs) return color + string + colorama.Fore.RESET"
            },
            {
                "url": 3152,
                "code": "def print_log(text, *colors): sys.stderr.write(sprint(\"{}: {}\".format(script_name, text), *colors) + \"\\n\")"
            },
            {
                "url": 2370,
                "code": "def stringc(text, color): if has_colors: text = str(text) return \"\\033[\"+codeCodes[color]+\"m\"+text+\"\\033[0m\" else: return text"
            },
            {
                "url": 273,
                "code": "def printc(cls, txt, color=colors.red): print(cls.color_txt(txt, color))"
            },
            {
                "url": 3444,
                "code": "def sprint(text, *colors): return \"\\33[{}m{content}\\33[{}m\".format(\";\".join([str(color) for color in colors]), RESET, content=text) if IS_ANSI_TERMINAL and colors else text"
            },
            {
                "url": 752,
                "code": "def print_log(value_color=\"\", value_noncolor=\"\"): HEADER = '\\033[92m' ENDC = '\\033[0m' print(HEADER + value_color + ENDC + str(value_noncolor))"
            },
            {
                "url": 1347,
                "code": "def _write_color_colorama (fp, text, color): foreground, background, style = get_win_color(color) colorama.set_console(foreground=foreground, background=background, style=style) fp.write(text) colorama.reset_console()"
            },
            {
                "url": 1018,
                "code": "def set_color(self, fg=None, bg=None, intensify=False, target=sys.stdout): raise NotImplementedError"
            },
            {
                "url": 3339,
                "code": "def print(cls, *args, **kwargs): # pylint: disable=protected-access with _shared._PRINT_LOCK: print(*args, **kwargs) _sys.stdout.flush()"
            },
            {
                "url": 883,
                "code": "def write_color(string, name, style='normal', when='auto'): write(color(string, name, style, when))"
            },
            {
                "url": 4997,
                "code": "def set(cls, color): sys.stdout.write(cls.colors.get(color, cls.colors['RESET']))"
            },
            {
                "url": 5918,
                "code": "def fprint(expr, print_ascii=False): r if print_ascii: pprint(expr, use_unicode=False, num_columns=120) else: return expr"
            },
            {
                "url": 5117,
                "code": "def colorize(txt, fg=None, bg=None): setting = '' setting += _SET_FG.format(fg) if fg else '' setting += _SET_BG.format(bg) if bg else '' return setting + str(txt) + _STYLE_RESET"
            }
        ],
        "url": 1026
    },
    {
        "nl_input": "python yield unsupported operand type(s)",
        "code_input": [
            {
                "url": 5464,
                "code": "def trap_exceptions(results, handler, exceptions=Exception): try: for result in results: yield result except exceptions as exc: for result in always_iterable(handler(exc)): yield result"
            },
            {
                "url": 3557,
                "code": "def reraise(error): if hasattr(error, \"_type_\"): six.reraise(type(error), error, error._traceback) raise error"
            },
            {
                "url": 899,
                "code": "def debug_on_error(type, value, tb): traceback.print_exc(type, value, tb) print() pdb.pm()"
            },
            {
                "url": 3219,
                "code": "def _re_raise_as(NewExc, *args, **kw): etype, val, tb = sys.exc_info() raise NewExc(*args, **kw), None, tb"
            },
            {
                "url": 6184,
                "code": "def assert_raises(ex_type, func, *args, **kwargs): r try: func(*args, **kwargs) except Exception as ex: assert isinstance(ex, ex_type), ( 'Raised %r but type should have been %r' % (ex, ex_type)) return True else: raise AssertionError('No error was raised')"
            },
            {
                "url": 2589,
                "code": "def raise_(exception=ABSENT, *args, **kwargs): if exception is ABSENT: raise else: if inspect.isclass(exception): raise exception(*args, **kwargs) else: if args or kwargs: raise TypeError(\"can't pass arguments along with \" \"exception object to raise_()\") raise exception"
            },
            {
                "url": 3728,
                "code": "def fix_call(callable, *args, **kw): try: val = callable(*args, **kw) except TypeError: exc_info = fix_type_error(None, callable, args, kw) reraise(*exc_info) return val"
            },
            {
                "url": 3410,
                "code": "def excepthook(self, except_type, exception, traceback): if except_type is DeepReferenceError: print(exception.msg) else: self.default_excepthook(except_type, exception, traceback)"
            },
            {
                "url": 1623,
                "code": "def __init__(self,operand,operator,**args): # Note that it's currently not possible to set # parameters in the superclass when creating an instance, # because **args is used by this class itself. super(UnaryOperator,self).__init__() self.operand=operand self.operator=operator self.args=args"
            },
            {
                "url": 6198,
                "code": "def _collection_literal_to_py_ast( ctx: GeneratorContext, form: Iterable[LispForm] ) -> Iterable[GeneratedPyAST]: yield from map(partial(_const_val_to_py_ast, ctx), form)"
            },
            {
                "url": 1285,
                "code": "def eintr_retry(exc_type, f, *args, **kwargs): while True: try: return f(*args, **kwargs) except exc_type as exc: if exc.errno != EINTR: raise else: break"
            },
            {
                "url": 259,
                "code": "def prepare_for_reraise(error, exc_info=None): if not hasattr(error, \"_type_\"): if exc_info is None: exc_info = sys.exc_info() error._type_ = exc_info[0] error._traceback = exc_info[2] return error"
            },
            {
                "url": 4359,
                "code": "def str_traceback(error, tb): if not isinstance(tb, types.TracebackType): return tb return ''.join(traceback.format_exception(error.__class__, error, tb))"
            },
            {
                "url": 1074,
                "code": "def format_exc(limit=None): try: etype, value, tb = sys.exc_info() return ''.join(traceback.format_exception(etype, value, tb, limit)) finally: etype = value = tb = None"
            },
            {
                "url": 1714,
                "code": "def generator_to_list(fn): def wrapper(*args, **kw): return list(fn(*args, **kw)) return wrapper"
            }
        ],
        "url": 4402
    },
    {
        "nl_input": "how to sort files by filename python",
        "code_input": [
            {
                "url": 707,
                "code": "def sort_filenames(filenames): basenames = [os.path.basename(x) for x in filenames] indexes = [i[0] for i in sorted(enumerate(basenames), key=lambda x:x[1])] return [filenames[x] for x in indexes]"
            },
            {
                "url": 5840,
                "code": "def sort_by_modified(files_or_folders: list) -> list: return sorted(files_or_folders, key=os.path.getmtime, reverse=True)"
            },
            {
                "url": 2373,
                "code": "def sort_by_name(self): super(JSSObjectList, self).sort(key=lambda k: k.name)"
            },
            {
                "url": 575,
                "code": "def sort_fn_list(fn_list): dt_list = get_dt_list(fn_list) fn_list_sort = [fn for (dt,fn) in sorted(zip(dt_list,fn_list))] return fn_list_sort"
            },
            {
                "url": 4334,
                "code": "def natural_sort(list, key=lambda s:s): def get_alphanum_key_func(key): convert = lambda text: int(text) if text.isdigit() else text return lambda s: [convert(c) for c in re.split('([0-9]+)', key(s))] sort_key = get_alphanum_key_func(key) list.sort(key=sort_key)"
            },
            {
                "url": 5927,
                "code": "def sortBy(self, keyfunc, ascending=True, numPartitions=None): return self.keyBy(keyfunc).sortByKey(ascending, numPartitions).values()"
            },
            {
                "url": 3198,
                "code": "def sort_data(x, y): xy = sorted(zip(x, y)) x, y = zip(*xy) return x, y"
            },
            {
                "url": 5770,
                "code": "def natural_sort(list_to_sort: Iterable[str]) -> List[str]: return sorted(list_to_sort, key=natural_keys)"
            },
            {
                "url": 2707,
                "code": "def _sort_lambda(sortedby='cpu_percent', sortedby_secondary='memory_percent'): ret = None if sortedby == 'io_counters': ret = _sort_io_counters elif sortedby == 'cpu_times': ret = _sort_cpu_times return ret"
            },
            {
                "url": 2375,
                "code": "def csort(objs, key): idxs = dict((obj, i) for (i, obj) in enumerate(objs)) return sorted(objs, key=lambda obj: (key(obj), idxs[obj]))"
            },
            {
                "url": 1177,
                "code": "def sort_nicely(l): convert = lambda text: int(text) if text.isdigit() else text alphanum_key = lambda key: [convert(c) for c in re.split('([0-9]+)', key)] l.sort(key=alphanum_key)"
            },
            {
                "url": 1174,
                "code": "def arglexsort(arrays): dtypes = ','.join(array.dtype.str for array in arrays) recarray = np.empty(len(arrays[0]), dtype=dtypes) for i, array in enumerate(arrays): recarray['f%s' % i] = array return recarray.argsort()"
            },
            {
                "url": 3265,
                "code": "def sort_func(self, key): if key == self._KEYS.VALUE: return 'aaa' if key == self._KEYS.SOURCE: return 'zzz' return key"
            },
            {
                "url": 5890,
                "code": "def sort_key(x): name, (r, u) = x return - len(u) + u.count('}') * 100"
            },
            {
                "url": 3607,
                "code": "def es_field_sort(fld_name): parts = fld_name.split(\".\") if \"_\" not in parts[-1]: parts[-1] = \"_\" + parts[-1] return \".\".join(parts)"
            }
        ],
        "url": 707
    },
    {
        "nl_input": "how to change the axis range in a plot in python for subplots",
        "code_input": [
            {
                "url": 3455,
                "code": "def set_xlimits(self, row, column, min=None, max=None): subplot = self.get_subplot_at(row, column) subplot.set_xlimits(min, max)"
            },
            {
                "url": 790,
                "code": "def set_ylimits(self, row, column, min=None, max=None): subplot = self.get_subplot_at(row, column) subplot.set_ylimits(min, max)"
            },
            {
                "url": 4994,
                "code": "def set_mlimits(self, row, column, min=None, max=None): subplot = self.get_subplot_at(row, column) subplot.set_mlimits(min, max)"
            },
            {
                "url": 1516,
                "code": "def set_xlimits_widgets(self, set_min=True, set_max=True): xmin, xmax = self.tab_plot.ax.get_xlim() if set_min: self.w.x_lo.set_text('{0}'.format(xmin)) if set_max: self.w.x_hi.set_text('{0}'.format(xmax))"
            },
            {
                "url": 2368,
                "code": "def set_axis_options(self, row, column, text): subplot = self.get_subplot_at(row, column) subplot.set_axis_options(text)"
            },
            {
                "url": 3028,
                "code": "def _set_axis_limits(self, which, lims, d, scale, reverse=False): setattr(self.limits, which + 'lims', lims) setattr(self.limits, 'd' + which, d) setattr(self.limits, which + 'scale', scale) if reverse: setattr(self.limits, 'reverse_' + which + '_axis', True) return"
            },
            {
                "url": 4327,
                "code": "def set_ylim(self, xlims, dx, xscale, reverse=False): self._set_axis_limits('y', xlims, dx, xscale, reverse) return"
            },
            {
                "url": 3834,
                "code": "def set_xlimits(self, min=None, max=None): self.limits['xmin'] = min self.limits['xmax'] = max"
            },
            {
                "url": 5262,
                "code": "def activate_subplot(numPlot): # see http://www.mail-archive.com/matplotlib-users@lists.sourceforge.net/msg07156.html from pylab import gcf, axes numPlot -= 1 # index is 0-based, plots are 1-based return axes(gcf().get_axes()[numPlot])"
            },
            {
                "url": 4635,
                "code": "def ylim(self, low, high): self.chart['yAxis'][0]['min'] = low self.chart['yAxis'][0]['max'] = high return self"
            },
            {
                "url": 2357,
                "code": "def setAutoRangeOn(self, axisNumber): setXYAxesAutoRangeOn(self, self.xAxisRangeCti, self.yAxisRangeCti, axisNumber)"
            },
            {
                "url": 3196,
                "code": "def ylim(self, low, high, index=1): self.layout['yaxis' + str(index)]['range'] = [low, high] return self"
            },
            {
                "url": 944,
                "code": "def show_xticklabels(self, row, column): subplot = self.get_subplot_at(row, column) subplot.show_xticklabels()"
            },
            {
                "url": 788,
                "code": "def clear_matplotlib_ticks(self, axis=\"both\"): ax = self.get_axes() plotting.clear_matplotlib_ticks(ax=ax, axis=axis)"
            },
            {
                "url": 781,
                "code": "def autozoom(self, n=None): if n==None: for p in self.plot_widgets: p.autoRange() else: self.plot_widgets[n].autoRange() return self"
            }
        ],
        "url": 3455
    },
    {
        "nl_input": "python view vector to asimuth elevation",
        "code_input": [
            {
                "url": 4093,
                "code": "def euler(self): e_xyz = transformations.euler_from_matrix(self.rotation, 'sxyz') return np.array([180.0 / np.pi * a for a in e_xyz])"
            },
            {
                "url": 3293,
                "code": "def world_to_view(v): return v.x * config.scale_x, v.y * config.scale_y"
            },
            {
                "url": 4726,
                "code": "def from_rotation_vector(rot): rot = np.array(rot, copy=False) quats = np.zeros(rot.shape[:-1]+(4,)) quats[..., 1:] = rot[...]/2 quats = as_quat_array(quats) return np.exp(quats)"
            },
            {
                "url": 3995,
                "code": "def angle_to_cartesian(lon, lat): theta = np.array(np.pi / 2. - lat) return np.vstack((np.sin(theta) * np.cos(lon), np.sin(theta) * np.sin(lon), np.cos(theta))).T"
            },
            {
                "url": 1952,
                "code": "def geodetic_to_ecef(latitude, longitude, altitude): ellip = np.sqrt(1. - earth_b ** 2 / earth_a ** 2) r_n = earth_a / np.sqrt(1. - ellip ** 2 * np.sin(np.deg2rad(latitude)) ** 2) # colatitude = 90. - latitude x = (r_n + altitude) * np.cos(np.deg2rad(latitude)) * np.cos(np.deg2rad(longitude)) y = (r_n + altitude) * np.cos(np.deg2rad(latitude)) * np.sin(np.deg2rad(longitude)) z = (r_n * (1. - ellip ** 2) + altitude) * np.sin(np.deg2rad(latitude)) return x, y, z"
            },
            {
                "url": 1665,
                "code": "def angle_between_vectors(x, y): dp = dot_product(x, y) if dp == 0: return 0 xm = magnitude(x) ym = magnitude(y) return math.acos(dp / (xm*ym)) * (180. / math.pi)"
            },
            {
                "url": 1740,
                "code": "def Distance(lat1, lon1, lat2, lon2): az12, az21, dist = wgs84_geod.inv(lon1, lat1, lon2, lat2) return az21, dist"
            },
            {
                "url": 3887,
                "code": "def xyz2lonlat(x, y, z): lon = xu.rad2deg(xu.arctan2(y, x)) lat = xu.rad2deg(xu.arctan2(z, xu.sqrt(x**2 + y**2))) return lon, lat"
            },
            {
                "url": 2960,
                "code": "def unproject(self, xy): (x, y) = xy lng = x/EARTH_RADIUS * RAD_TO_DEG lat = 2 * atan(exp(y/EARTH_RADIUS)) - pi/2 * RAD_TO_DEG return (lng, lat)"
            },
            {
                "url": 55,
                "code": "def qrot(vector, quaternion): t = 2 * np.cross(quaternion[1:], vector) v_rot = vector + quaternion[0] * t + np.cross(quaternion[1:], t) return v_rot"
            },
            {
                "url": 1563,
                "code": "def vec_angle(a, b): cosang = np.dot(a, b) sinang = fast_norm(np.cross(a, b)) return np.arctan2(sinang, cosang)"
            },
            {
                "url": 5295,
                "code": "def rotation_from_quaternion(q_wxyz): q_xyzw = np.array([q_wxyz[1], q_wxyz[2], q_wxyz[3], q_wxyz[0]]) R = transformations.quaternion_matrix(q_xyzw)[:3,:3] return R"
            },
            {
                "url": 5040,
                "code": "def earth_orientation(date): x_p, y_p, s_prime = np.deg2rad(_earth_orientation(date)) return rot3(-s_prime) @ rot2(x_p) @ rot1(y_p)"
            },
            {
                "url": 5405,
                "code": "def rotation_matrix(sigma): radians = sigma * np.pi / 180.0 r11 = np.cos(radians) r12 = -np.sin(radians) r21 = np.sin(radians) r22 = np.cos(radians) R = np.array([[r11, r12], [r21, r22]]) return R"
            },
            {
                "url": 3613,
                "code": "def _convert_latitude(self, latitude): return int((180 - (180 / pi * log(tan( pi / 4 + latitude * pi / 360)))) * (2 ** self._zoom) * self._size / 360)"
            }
        ],
        "url": 3293
    },
    {
        "nl_input": "python sort data by variable",
        "code_input": [
            {
                "url": 3198,
                "code": "def sort_data(x, y): xy = sorted(zip(x, y)) x, y = zip(*xy) return x, y"
            },
            {
                "url": 1180,
                "code": "def sort_data(data, cols): return data.sort_values(cols)[cols + ['value']].reset_index(drop=True)"
            },
            {
                "url": 2373,
                "code": "def sort_by_name(self): super(JSSObjectList, self).sort(key=lambda k: k.name)"
            },
            {
                "url": 5927,
                "code": "def sortBy(self, keyfunc, ascending=True, numPartitions=None): return self.keyBy(keyfunc).sortByKey(ascending, numPartitions).values()"
            },
            {
                "url": 2375,
                "code": "def csort(objs, key): idxs = dict((obj, i) for (i, obj) in enumerate(objs)) return sorted(objs, key=lambda obj: (key(obj), idxs[obj]))"
            },
            {
                "url": 575,
                "code": "def sort_fn_list(fn_list): dt_list = get_dt_list(fn_list) fn_list_sort = [fn for (dt,fn) in sorted(zip(dt_list,fn_list))] return fn_list_sort"
            },
            {
                "url": 4334,
                "code": "def natural_sort(list, key=lambda s:s): def get_alphanum_key_func(key): convert = lambda text: int(text) if text.isdigit() else text return lambda s: [convert(c) for c in re.split('([0-9]+)', key(s))] sort_key = get_alphanum_key_func(key) list.sort(key=sort_key)"
            },
            {
                "url": 1172,
                "code": "def sort_dict(d, key=None, reverse=False): kv_items = [kv for kv in d.items()] # Sort kv_items according to key. if key is None: kv_items.sort(key=lambda t: t[1], reverse=reverse) else: kv_items.sort(key=key, reverse=reverse) # Build ordered dict. return collections.OrderedDict(kv_items)"
            },
            {
                "url": 5770,
                "code": "def natural_sort(list_to_sort: Iterable[str]) -> List[str]: return sorted(list_to_sort, key=natural_keys)"
            },
            {
                "url": 2641,
                "code": "def unsort_vector(data, indices_of_increasing): return numpy.array([data[indices_of_increasing.index(i)] for i in range(len(data))])"
            },
            {
                "url": 1177,
                "code": "def sort_nicely(l): convert = lambda text: int(text) if text.isdigit() else text alphanum_key = lambda key: [convert(c) for c in re.split('([0-9]+)', key)] l.sort(key=alphanum_key)"
            },
            {
                "url": 2707,
                "code": "def _sort_lambda(sortedby='cpu_percent', sortedby_secondary='memory_percent'): ret = None if sortedby == 'io_counters': ret = _sort_io_counters elif sortedby == 'cpu_times': ret = _sort_cpu_times return ret"
            },
            {
                "url": 4323,
                "code": "def sortlevel(self, level=None, ascending=True, sort_remaining=None): return self.sort_values(return_indexer=True, ascending=ascending)"
            },
            {
                "url": 3265,
                "code": "def sort_func(self, key): if key == self._KEYS.VALUE: return 'aaa' if key == self._KEYS.SOURCE: return 'zzz' return key"
            },
            {
                "url": 5171,
                "code": "def sort_matrix(a,n=0): a = _n.array(a) return a[:,a[n,:].argsort()]"
            }
        ],
        "url": 3198
    },
    {
        "nl_input": "compute the middle index in list python",
        "code_input": [
            {
                "url": 4592,
                "code": "def get_median(temp_list): num = len(temp_list) temp_list.sort() print(temp_list) if num % 2 == 0: median = (temp_list[int(num/2)] + temp_list[int(num/2) - 1]) / 2 else: median = temp_list[int(num/2)] return median"
            },
            {
                "url": 526,
                "code": "def median(lst): #: http://stackoverflow.com/a/24101534 sortedLst = sorted(lst) lstLen = len(lst) index = (lstLen - 1) // 2 if (lstLen % 2): return sortedLst[index] else: return (sortedLst[index] + sortedLst[index + 1])/2.0"
            },
            {
                "url": 4909,
                "code": "def median(ls): ls = sorted(ls) return ls[int(floor(len(ls)/2.0))]"
            },
            {
                "url": 2874,
                "code": "def median_date(dt_list): #dt_list_sort = sorted(dt_list) idx = len(dt_list)/2 if len(dt_list) % 2 == 0: md = mean_date([dt_list[idx-1], dt_list[idx]]) else: md = dt_list[idx] return md"
            },
            {
                "url": 1371,
                "code": "def median(data): data.sort() num_values = len(data) half = num_values // 2 if num_values % 2: return data[half] return 0.5 * (data[half-1] + data[half])"
            },
            {
                "url": 6246,
                "code": "def median(data): if len(data) == 0: return None data = sorted(data) return float((data[len(data) // 2] + data[(len(data) - 1) // 2]) / 2.)"
            },
            {
                "url": 1979,
                "code": "def median_high(data): data = sorted(data) n = len(data) if n == 0: raise StatisticsError(\"no median for empty data\") return data[n // 2]"
            },
            {
                "url": 1278,
                "code": "def mean(inlist): sum = 0 for item in inlist: sum = sum + item return sum / float(len(inlist))"
            },
            {
                "url": 2162,
                "code": "def getMedian(numericValues): theValues = sorted(numericValues) if len(theValues) % 2 == 1: return theValues[(len(theValues) + 1) / 2 - 1] else: lower = theValues[len(theValues) / 2 - 1] upper = theValues[len(theValues) / 2] return (float(lower + upper)) / 2"
            },
            {
                "url": 5945,
                "code": "def percentile(sorted_list, percent, key=lambda x: x): if not sorted_list: return None if percent == 1: return float(sorted_list[-1]) if percent == 0: return float(sorted_list[0]) n = len(sorted_list) i = percent * n if ceil(i) == i: i = int(i) return (sorted_list[i-1] + sorted_list[i]) / 2 return float(sorted_list[ceil(i)-1])"
            },
            {
                "url": 4633,
                "code": "def _mid(string, start, end=None): if end is None: end = len(string) return string[start:start + end]"
            },
            {
                "url": 5569,
                "code": "def _rindex(mylist: Sequence[T], x: T) -> int: return len(mylist) - mylist[::-1].index(x) - 1"
            },
            {
                "url": 2957,
                "code": "def calc_list_average(l): total = 0.0 for value in l: total += value return total / len(l)"
            },
            {
                "url": 1529,
                "code": "def _mean_dict(dict_list): return {k: np.array([d[k] for d in dict_list]).mean() for k in dict_list[0].keys()}"
            },
            {
                "url": 1115,
                "code": "def median(self): mu = self.mean() ret_val = math.exp(mu) if math.isnan(ret_val): ret_val = float(\"inf\") return ret_val"
            }
        ],
        "url": 1588
    },
    {
        "nl_input": "python josn dump to file",
        "code_input": [
            {
                "url": 4796,
                "code": "def json_pretty_dump(obj, filename): with open(filename, \"wt\") as fh: json.dump(obj, fh, indent=4, sort_keys=4)"
            },
            {
                "url": 4442,
                "code": "def save_json(object, handle, indent=2): obj_json = json.dumps(object, indent=indent, cls=NumpyJSONEncoder) handle.write(obj_json)"
            },
            {
                "url": 682,
                "code": "def dump_json(obj): return simplejson.dumps(obj, ignore_nan=True, default=json_util.default)"
            },
            {
                "url": 1198,
                "code": "def _serialize_json(obj, fp): json.dump(obj, fp, indent=4, default=serialize)"
            },
            {
                "url": 2059,
                "code": "def json_dumps(self, obj): return json.dumps(obj, sort_keys=True, indent=4, separators=(',', ': '))"
            },
            {
                "url": 4627,
                "code": "def pprint(j, no_pretty): if not no_pretty: click.echo( json.dumps(j, cls=PotionJSONEncoder, sort_keys=True, indent=4, separators=(\",\", \": \")) ) else: click.echo(j)"
            },
            {
                "url": 686,
                "code": "def save(self, fname): with open(fname, 'wb') as f: json.dump(self, f)"
            },
            {
                "url": 1935,
                "code": "def object_to_json(obj, indent=2): instance_json = json.dumps(obj, indent=indent, ensure_ascii=False, cls=DjangoJSONEncoder) return instance_json"
            },
            {
                "url": 3261,
                "code": "def dumps(obj): return json.dumps(obj, indent=4, sort_keys=True, cls=CustomEncoder)"
            },
            {
                "url": 6027,
                "code": "def _write_json(obj, path): # type: (object, str) -> None with open(path, 'w') as f: json.dump(obj, f)"
            },
            {
                "url": 1344,
                "code": "def _write_json(file, contents): with open(file, 'w') as f: return json.dump(contents, f, indent=2, sort_keys=True)"
            },
            {
                "url": 3965,
                "code": "def Dump(obj): text = yaml.safe_dump(obj, default_flow_style=False, allow_unicode=True) if compatibility.PY2: text = text.decode(\"utf-8\") return text"
            },
            {
                "url": 2227,
                "code": "def prettyprint(d): print(json.dumps(d, sort_keys=True, indent=4, separators=(\",\" , \": \")))"
            },
            {
                "url": 1351,
                "code": "def safe_dump(data, stream=None, **kwds): return yaml.dump(data, stream=stream, Dumper=ODYD, **kwds)"
            },
            {
                "url": 380,
                "code": "def cli(yamlfile, format, context): print(JSONLDGenerator(yamlfile, format).serialize(context=context))"
            }
        ],
        "url": 2462
    },
    {
        "nl_input": "python remove condition apply to dict",
        "code_input": [
            {
                "url": 185,
                "code": "def _remove_dict_keys_with_value(dict_, val): return {k: v for k, v in dict_.items() if v is not val}"
            },
            {
                "url": 2281,
                "code": "def _remove_none_values(dictionary): return list(map(dictionary.pop, [i for i in dictionary if dictionary[i] is None]))"
            },
            {
                "url": 1015,
                "code": "def rm_keys_from_dict(d, keys): # Loop for each key given for key in keys: # Is the key in the dictionary? if key in d: try: d.pop(key, None) except KeyError: # Not concerned with an error. Keep going. pass return d"
            },
            {
                "url": 5594,
                "code": "def dictlist_wipe_key(dict_list: Iterable[Dict], key: str) -> None: for d in dict_list: d.pop(key, None)"
            },
            {
                "url": 695,
                "code": "def _clean_dict(target_dict, whitelist=None): assert isinstance(target_dict, dict) return { ustr(k).strip(): ustr(v).strip() for k, v in target_dict.items() if v not in (None, Ellipsis, [], (), \"\") and (not whitelist or k in whitelist) }"
            },
            {
                "url": 2205,
                "code": "def clean_dict_keys(d): new_d = {} for (k, v) in d.iteritems(): new_d[str(k)] = v return new_d"
            },
            {
                "url": 1017,
                "code": "def purge_dict(idict): odict = {} for key, val in idict.items(): if is_null(val): continue odict[key] = val return odict"
            },
            {
                "url": 2569,
                "code": "def _delete_keys(dct, keys): c = deepcopy(dct) assert isinstance(keys, list) for k in keys: c.pop(k) return c"
            },
            {
                "url": 177,
                "code": "def filter_dict(d, keys): return {k: v for k, v in d.items() if k in keys}"
            },
            {
                "url": 4062,
                "code": "def __delitem__(self, key): index, value = self._dict.pop(key) key2, value2 = self._list.pop(index) assert key == key2 assert value is value2 self._fix_indices_after_delete(index)"
            },
            {
                "url": 4024,
                "code": "def _remove_empty_items(d, required): new_dict = {} for k, v in d.items(): if k in required: new_dict[k] = v elif isinstance(v, int) or v: # \"if v\" would suppress emitting int(0) new_dict[k] = v return new_dict"
            },
            {
                "url": 1002,
                "code": "def filter_dict_by_key(d, keys): return {k: v for k, v in d.items() if k in keys}"
            },
            {
                "url": 5911,
                "code": "def __remove_method(m: lmap.Map, key: T) -> lmap.Map: return m.dissoc(key)"
            },
            {
                "url": 3153,
                "code": "def remove_property(self, key=None, value=None): for k, v in self.properties[:]: if (key is None or key == k) and (value is None or value == v): del(self.properties[self.properties.index((k, v))])"
            },
            {
                "url": 5748,
                "code": "def clean_map(obj: Mapping[Any, Any]) -> Mapping[Any, Any]: return {k: v for k, v in obj.items() if v is not None}"
            }
        ],
        "url": 185
    },
    {
        "nl_input": "python remove directory tree if no files",
        "code_input": [
            {
                "url": 1906,
                "code": "def clean_out_dir(directory): if not isinstance(directory, path): directory = path(directory) for file_path in directory.files(): file_path.remove() for dir_path in directory.dirs(): dir_path.rmtree()"
            },
            {
                "url": 1963,
                "code": "def safe_rmtree(directory): if os.path.exists(directory): shutil.rmtree(directory, True)"
            },
            {
                "url": 6021,
                "code": "def _cleanup(path: str) -> None: if os.path.isdir(path): shutil.rmtree(path)"
            },
            {
                "url": 2576,
                "code": "def clean_py_files(path): for dirname, subdirlist, filelist in os.walk(path): for f in filelist: if f.endswith('py'): os.remove(os.path.join(dirname, f))"
            },
            {
                "url": 2187,
                "code": "def remover(file_path): if os.path.isfile(file_path): os.remove(file_path) return True elif os.path.isdir(file_path): shutil.rmtree(file_path) return True else: return False"
            },
            {
                "url": 4126,
                "code": "def clean(dry_run='n'): file_patterns = ['*.pyc', '*.pyo', '*~'] dir_patterns = ['__pycache__'] recursive_pattern_delete(project_paths.root, file_patterns, dir_patterns, dry_run=bool(dry_run.lower() == 'y'))"
            },
            {
                "url": 1013,
                "code": "def rrmdir(directory): for root, dirs, files in os.walk(directory, topdown=False): for name in files: os.remove(os.path.join(root, name)) for name in dirs: os.rmdir(os.path.join(root, name)) os.rmdir(directory)"
            },
            {
                "url": 1970,
                "code": "def clean_tmpdir(path): if os.path.exists(path) and \\ os.path.isdir(path): rmtree(path)"
            },
            {
                "url": 3436,
                "code": "def _clear_dir(dirName): # If we got here, clear dir for fname in os.listdir(dirName): try: os.remove( os.path.join(dirName, fname) ) except Exception: pass try: os.rmdir(dirName) except Exception: pass"
            },
            {
                "url": 3945,
                "code": "def file_remove(self, path, filename): if os.path.isfile(path + filename): os.remove(path + filename)"
            },
            {
                "url": 2643,
                "code": "def recursively_get_files_from_directory(directory): return [ os.path.join(root, filename) for root, directories, filenames in os.walk(directory) for filename in filenames ]"
            },
            {
                "url": 145,
                "code": "def delete_all_eggs(self): path_to_delete = os.path.join(self.egg_directory, \"lib\", \"python\") if os.path.exists(path_to_delete): shutil.rmtree(path_to_delete)"
            },
            {
                "url": 1145,
                "code": "def symlink_remove(link): # https://stackoverflow.com/q/26554135/6400719 if os.path.isdir(path2str(link)) and is_windows: # this should only be on Py2.7 and windows os.rmdir(path2str(link)) else: os.unlink(path2str(link))"
            },
            {
                "url": 2894,
                "code": "def cleanup(self): for file in glob.glob(self.basename + '*'): os.unlink(file)"
            },
            {
                "url": 836,
                "code": "def _delete_local(self, filename): if os.path.exists(filename): os.remove(filename)"
            }
        ],
        "url": 1906
    },
    {
        "nl_input": "how to pop a node off a stack python",
        "code_input": [
            {
                "url": 702,
                "code": "def pop(self): if not self.empty(): val = self.stack[-1] del self.stack[-1] return val"
            },
            {
                "url": 3149,
                "code": "def __pop_top_frame(self): popped = self.__stack.pop() if self.__stack: self.__stack[-1].process_subframe(popped)"
            },
            {
                "url": 400,
                "code": "def pop(h): n = h.size() - 1 h.swap(0, n) down(h, 0, n) return h.pop()"
            },
            {
                "url": 3403,
                "code": "def stack_push(self, thing): # increment sp sp = self.regs.sp + self.arch.stack_change self.regs.sp = sp return self.memory.store(sp, thing, endness=self.arch.memory_endness)"
            },
            {
                "url": 1019,
                "code": "def pop(self, index=-1): value = self._list.pop(index) del self._dict[value] return value"
            },
            {
                "url": 2088,
                "code": "def _get_or_create_stack(name): stack = getattr(_LOCAL_STACKS, name, None) if stack is None: stack = [] setattr(_LOCAL_STACKS, name, stack) return stack"
            },
            {
                "url": 1971,
                "code": "def _heappop_max(heap): lastelt = heap.pop() # raises appropriate IndexError if heap is empty if heap: returnitem = heap[0] heap[0] = lastelt _siftup_max(heap, 0) return returnitem return lastelt"
            },
            {
                "url": 2739,
                "code": "def heappop_max(heap): lastelt = heap.pop() # raises appropriate IndexError if heap is empty if heap: returnitem = heap[0] heap[0] = lastelt _siftup_max(heap, 0) return returnitem return lastelt"
            },
            {
                "url": 4278,
                "code": "def rpop(self, key): redis_list = self._get_list(key, 'RPOP') if self._encode(key) not in self.redis: return None try: value = redis_list.pop() if len(redis_list) == 0: self.delete(key) return value except (IndexError): # Redis returns nil if popping from an empty list return None"
            },
            {
                "url": 4802,
                "code": "def stack_as_string(): if sys.version_info.major == 3: stack = io.StringIO() else: stack = io.BytesIO() traceback.print_stack(file=stack) stack.seek(0) stack = stack.read() return stack"
            },
            {
                "url": 2082,
                "code": "def poke_array(self, store, name, elemtype, elements, container, visited, _stack): raise NotImplementedError"
            },
            {
                "url": 47,
                "code": "def push(h, x): h.push(x) up(h, h.size()-1)"
            },
            {
                "url": 2286,
                "code": "def PopTask(self): try: _, task = heapq.heappop(self._heap) except IndexError: return None self._task_identifiers.remove(task.identifier) return task"
            },
            {
                "url": 2586,
                "code": "def pop_all(self): with self.lock: output = list(self.queue) self.queue.clear() return output"
            },
            {
                "url": 2562,
                "code": "def multi_pop(d, *args): retval = {} for key in args: if key in d: retval[key] = d.pop(key) return retval"
            }
        ],
        "url": 47
    },
    {
        "nl_input": "python open file with exclusive access permissions",
        "code_input": [
            {
                "url": 1796,
                "code": "def open_file(file, mode): if hasattr(file, \"read\"): return file if hasattr(file, \"open\"): return file.open(mode) return open(file, mode)"
            },
            {
                "url": 4640,
                "code": "def __enter__(self): self.fd = open(self.filename, 'a') fcntl.lockf(self.fd, fcntl.LOCK_EX) return self.fd"
            },
            {
                "url": 561,
                "code": "def make_file_read_only(file_path): old_permissions = os.stat(file_path).st_mode os.chmod(file_path, old_permissions & ~WRITE_PERMISSIONS)"
            },
            {
                "url": 2778,
                "code": "def lock_file(f, block=False): try: flags = fcntl.LOCK_EX if not block: flags |= fcntl.LOCK_NB fcntl.flock(f.fileno(), flags) except IOError as e: if e.errno in (errno.EACCES, errno.EAGAIN): raise SystemExit(\"ERROR: %s is locked by another process.\" % f.name) raise"
            },
            {
                "url": 564,
                "code": "def fopenat(base_fd, path): return os.fdopen(openat(base_fd, path, os.O_RDONLY), 'rb')"
            },
            {
                "url": 3485,
                "code": "def _open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None, *, loop=None, executor=None): if loop is None: loop = asyncio.get_event_loop() cb = partial(sync_open, file, mode=mode, buffering=buffering, encoding=encoding, errors=errors, newline=newline, closefd=closefd, opener=opener) f = yield from loop.run_in_executor(executor, cb) return wrap(f, loop=loop, executor=executor)"
            },
            {
                "url": 4698,
                "code": "def fopen(name, mode='r', buffering=-1): f = _fopen(name, mode, buffering) return _FileObjectThreadWithContext(f, mode, buffering)"
            },
            {
                "url": 2659,
                "code": "def add_exec_permission_to(target_file): mode = os.stat(target_file).st_mode os.chmod(target_file, mode | stat.S_IXUSR)"
            },
            {
                "url": 5144,
                "code": "def acquire_nix(lock_file): # pragma: no cover fd = os.open(lock_file, OPEN_MODE) try: fcntl.flock(fd, fcntl.LOCK_EX | fcntl.LOCK_NB) except (IOError, OSError): os.close(fd) else: return fd"
            },
            {
                "url": 1063,
                "code": "def open_with_encoding(filename, encoding, mode='r'): return io.open(filename, mode=mode, encoding=encoding, newline='')"
            },
            {
                "url": 1658,
                "code": "def chmod(f): try: os.chmod(f, S_IWRITE) # windows (cover all) except Exception as e: pass try: os.chmod(f, 0o777) # *nix except Exception as e: pass"
            },
            {
                "url": 4294,
                "code": "def make_file_readable (filename): if not os.path.islink(filename): util.set_mode(filename, stat.S_IRUSR)"
            },
            {
                "url": 2445,
                "code": "def is_readable(filename): return os.path.isfile(filename) and os.access(filename, os.R_OK)"
            },
            {
                "url": 3432,
                "code": "def make_writeable(filename): if not os.access(filename, os.W_OK): st = os.stat(filename) new_permissions = stat.S_IMODE(st.st_mode) | stat.S_IWUSR os.chmod(filename, new_permissions)"
            },
            {
                "url": 3389,
                "code": "def writefile(openedfile, newcontents): openedfile.seek(0) openedfile.truncate() openedfile.write(newcontents)"
            }
        ],
        "url": 1152
    },
    {
        "nl_input": "python gevent combine multiprocessing",
        "code_input": [
            {
                "url": 4136,
                "code": "def _gevent_patch(): try: assert gevent assert grequests except NameError: logger.warn('gevent not exist, fallback to multiprocess...') return MULTITHREAD else: monkey.patch_all() # Must patch before get_photos_info return GEVENT"
            },
            {
                "url": 4138,
                "code": "def _spawn(self, func, *args, **kwargs): gevent.spawn(func, *args, **kwargs)"
            },
            {
                "url": 4151,
                "code": "def start(self): assert not self.has_started(), \"called start() on an active GeventLoop\" self._stop_event = Event() # note that we don't use safe_greenlets.spawn because we take care of it in _loop by ourselves self._greenlet = gevent.spawn(self._loop)"
            },
            {
                "url": 1616,
                "code": "def gevent_monkey_patch_report(self): try: import gevent.socket import socket if gevent.socket.socket is socket.socket: self.log(\"gevent monkey patching is active\") return True else: self.notify_user(\"gevent monkey patching failed.\") except ImportError: self.notify_user(\"gevent is not installed, monkey patching failed.\") return False"
            },
            {
                "url": 1761,
                "code": "def parallel(processes, threads): pool = multithread(threads) pool.map(run_process, processes) pool.close() pool.join()"
            },
            {
                "url": 3695,
                "code": "def multiprocess_mapping(func, iterable): if os.name == 'nt': # In Windows there is no fork. return list(map(func, iterable)) try: p = multiprocessing.Pool() return_data = list(p.imap(func, iterable)) p.close() p.join() return return_data except OSError: return list(map(func, iterable))"
            },
            {
                "url": 492,
                "code": "def threads_init(gtk=True): # enable X11 multithreading x11.XInitThreads() if gtk: from gtk.gdk import threads_init threads_init()"
            },
            {
                "url": 112,
                "code": "async def _thread_coro(self, *args): return await self._loop.run_in_executor( self._executor, self._function, *args)"
            },
            {
                "url": 2521,
                "code": "def _run_asyncio(loop, zmq_context): try: asyncio.set_event_loop(loop) loop.run_forever() except: pass finally: loop.close() zmq_context.destroy(1000)"
            },
            {
                "url": 3385,
                "code": "def run(*tasks: Awaitable, loop: asyncio.AbstractEventLoop=asyncio.get_event_loop()): futures = [asyncio.ensure_future(task, loop=loop) for task in tasks] return loop.run_until_complete(asyncio.gather(*futures))"
            },
            {
                "url": 4765,
                "code": "def join(self): for thread in self.worker_threads: thread.join() WorkerThread.join(self)"
            },
            {
                "url": 3813,
                "code": "def _run_parallel_process_with_profiling(self, start_path, stop_path, queue, filename): runctx('Engine._run_parallel_process(self, start_path, stop_path, queue)', globals(), locals(), filename)"
            },
            {
                "url": 3694,
                "code": "def apply(self, func, workers=1, job_size=10000): if workers == 1: for lines in self.iter_chunks(job_size): yield func(lines) else: with ProcessPoolExecutor(max_workers=workers) as executor: for result in executor.map(func, self.iter_chunks(job_size)): yield result"
            },
            {
                "url": 318,
                "code": "def asynchronous(function, event): thread = Thread(target=synchronous, args=(function, event)) thread.daemon = True thread.start()"
            },
            {
                "url": 312,
                "code": "def _spawn_kafka_consumer_thread(self): self.logger.debug(\"Spawn kafka consumer thread\"\"\") self._consumer_thread = Thread(target=self._consumer_loop) self._consumer_thread.setDaemon(True) self._consumer_thread.start()"
            }
        ],
        "url": 478
    },
    {
        "nl_input": "create copy that doesn't alter original python",
        "code_input": [
            {
                "url": 1395,
                "code": "def copy(obj): def copy(self): from copy import deepcopy return deepcopy(self) obj.copy = copy return obj"
            },
            {
                "url": 3658,
                "code": "def __deepcopy__(self, memo): # noinspection PyArgumentList return self.__class__( **{key: deepcopy(getattr(self, key), memo) for key in self.keys} )"
            },
            {
                "url": 5244,
                "code": "def clone(src, **kwargs): obj = object.__new__(type(src)) obj.__dict__.update(src.__dict__) obj.__dict__.update(kwargs) return obj"
            },
            {
                "url": 562,
                "code": "def copy(self): result = NocaseDict() result._data = self._data.copy() # pylint: disable=protected-access return result"
            },
            {
                "url": 2285,
                "code": "def __copy__(self): return self.__class__.load(self.dump(), context=self.context)"
            },
            {
                "url": 5283,
                "code": "def copy(self): return self.__class__(self.operations.copy(), self.collection, self.document)"
            },
            {
                "url": 3824,
                "code": "def copy(self): result = self.space.element() result.assign(self) return result"
            },
            {
                "url": 1959,
                "code": "def copy(string, **kwargs): window = Tk() window.withdraw() window.clipboard_clear() window.clipboard_append(string) window.destroy() return"
            },
            {
                "url": 1224,
                "code": "def copy_and_update(dictionary, update): newdict = dictionary.copy() newdict.update(update) return newdict"
            },
            {
                "url": 1929,
                "code": "def copy(self): return self.__class__(field_type=self.get_field_type(), data=self.export_data())"
            },
            {
                "url": 2738,
                "code": "def clone_with_copy(src_path, dest_path): log.info('Cloning directory tree %s to %s', src_path, dest_path) shutil.copytree(src_path, dest_path)"
            },
            {
                "url": 4060,
                "code": "def __deepcopy__(self, memo): return type(self)(value=self._value, enum_ref=self.enum_ref)"
            },
            {
                "url": 698,
                "code": "def copy_no_perm(src, dst): shutil.copy(src, dst) perm = os.stat(dst).st_mode shutil.copystat(src, dst) os.chmod(dst, perm)"
            },
            {
                "url": 997,
                "code": "def _makes_clone(_func, *args, **kw): self = args[0]._clone() _func(self, *args[1:], **kw) return self"
            },
            {
                "url": 242,
                "code": "def copy(doc, dest, src): return Target(doc).copy(dest, src).document"
            }
        ],
        "url": 1395
    },
    {
        "nl_input": "remove trailing whitespace in python",
        "code_input": [
            {
                "url": 2577,
                "code": "def clean_whitespace(statement): import re # Replace linebreaks and tabs with spaces statement.text = statement.text.replace('\\n', ' ').replace('\\r', ' ').replace('\\t', ' ') # Remove any leeding or trailing whitespace statement.text = statement.text.strip() # Remove consecutive spaces statement.text = re.sub(' +', ' ', statement.text) return statement"
            },
            {
                "url": 366,
                "code": "def strip_spaces(s): return u\" \".join([c for c in s.split(u' ') if c])"
            },
            {
                "url": 3447,
                "code": "def clean_whitespace(string, compact=False): for a, b in (('\\r\\n', '\\n'), ('\\r', '\\n'), ('\\n\\n', '\\n'), ('\\t', ' '), (' ', ' ')): string = string.replace(a, b) if compact: for a, b in (('\\n', ' '), ('[ ', '['), (' ', ' '), (' ', ' '), (' ', ' ')): string = string.replace(a, b) return string.strip()"
            },
            {
                "url": 3891,
                "code": "def _trim(self, somestr): tmp = RE_LSPACES.sub(\"\", somestr) tmp = RE_TSPACES.sub(\"\", tmp) return str(tmp)"
            },
            {
                "url": 5725,
                "code": "def remove_blank_lines(string): return \"\\n\".join(line for line in string.split(\"\\n\") if len(line.strip()))"
            },
            {
                "url": 1664,
                "code": "def _delete_whitespace(self): while isinstance(self._lines[-1], (self._Space, self._LineBreak, self._Indent)): del self._lines[-1]"
            },
            {
                "url": 2581,
                "code": "def clean(s): lines = [l.rstrip() for l in s.split('\\n')] return '\\n'.join(lines)"
            },
            {
                "url": 603,
                "code": "def strip_spaces(x): x = x.replace(b' ', b'') x = x.replace(b'\\t', b'') return x"
            },
            {
                "url": 2422,
                "code": "def text_remove_empty_lines(text): lines = [ line.rstrip() for line in text.splitlines() if line.strip() ] return \"\\n\".join(lines)"
            },
            {
                "url": 5108,
                "code": "def fix_line_breaks(s): l = s.splitlines() x = [i.strip() for i in l] x = [i for i in x if i] # remove blank lines return \"\\n\".join(x)"
            },
            {
                "url": 2423,
                "code": "def strip_spaces(value, sep=None, join=True): value = value.strip() value = [v.strip() for v in value.split(sep)] join_sep = sep or ' ' return join_sep.join(value) if join else value"
            },
            {
                "url": 1004,
                "code": "def handle_whitespace(text): r text = re_retab.sub(sub_retab, text) text = re_whitespace.sub('', text).strip() return text"
            },
            {
                "url": 6168,
                "code": "def remove_blank_spaces(syllables: List[str]) -> List[str]: cleaned = [] for syl in syllables: if syl == \" \" or syl == '': pass else: cleaned.append(syl) return cleaned"
            },
            {
                "url": 1696,
                "code": "def remove_trailing_string(content, trailing): if content.endswith(trailing) and content != trailing: return content[:-len(trailing)] return content"
            },
            {
                "url": 2393,
                "code": "def reindent(s, numspaces): leading_space = numspaces * ' ' lines = [leading_space + line.strip()for line in s.splitlines()] return '\\n'.join(lines)"
            }
        ],
        "url": 2581
    },
    {
        "nl_input": "python default menuitem select",
        "code_input": [
            {
                "url": 5436,
                "code": "def select_default(self): if self._default is None: if not self._set_option_by_index(0): utils.error_format(self.description + \"\\n\" + \"Unable to select default option as the Combo is empty\") else: if not self._set_option(self._default): utils.error_format( self.description + \"\\n\" + \"Unable to select default option as it doesnt exist in the Combo\")"
            },
            {
                "url": 2337,
                "code": "def _selectItem(self, index): self._selectedIndex = index self.setCurrentIndex(self.model().createIndex(index, 0))"
            },
            {
                "url": 3498,
                "code": "def get_python(self): if self.multiselect: return super(MultiSelectField, self).get_python() return self._get()"
            },
            {
                "url": 279,
                "code": "def _on_select(self, *args): if callable(self.__callback): self.__callback(self.selection)"
            },
            {
                "url": 917,
                "code": "def onchange(self, value): log.debug('combo box. selected %s' % value) self.select_by_value(value) return (value, )"
            },
            {
                "url": 3504,
                "code": "def ask_folder(message='Select folder.', default='', title=''): return backend_api.opendialog(\"ask_folder\", dict(message=message, default=default, title=title))"
            },
            {
                "url": 3785,
                "code": "def separator(self, menu=None): self.gui.get_menu(menu or self.menu).addSeparator()"
            },
            {
                "url": 3358,
                "code": "def _updateItemComboBoxIndex(self, item, column, num): item._combobox_current_index[column] = num item._combobox_current_value[column] = item._combobox_option_list[column][num][0]"
            },
            {
                "url": 2869,
                "code": "def OnContextMenu(self, event): self.grid.PopupMenu(self.grid.contextmenu) event.Skip()"
            },
            {
                "url": 3632,
                "code": "def input(self, prompt, default=None, show_default=True): return click.prompt(prompt, default=default, show_default=show_default)"
            },
            {
                "url": 1432,
                "code": "def arg_default(*args, **kwargs): parser = argparse.ArgumentParser() parser.add_argument(*args, **kwargs) args = vars(parser.parse_args([])) _, default = args.popitem() return default"
            },
            {
                "url": 4769,
                "code": "def update_menu(self): self.menu.clear() add_actions(self.menu, self.create_context_menu_actions())"
            },
            {
                "url": 6041,
                "code": "def _get_or_default(mylist, i, default=None): if i >= len(mylist): return default else : return mylist[i]"
            },
            {
                "url": 5393,
                "code": "def contextMenuEvent(self, event): self.menu.popup(event.globalPos()) event.accept()"
            },
            {
                "url": 5028,
                "code": "def contextMenuEvent(self, event): self.update_menu() self.menu.popup(event.globalPos())"
            }
        ],
        "url": 3498
    },
    {
        "nl_input": "get sort indexes in a list python",
        "code_input": [
            {
                "url": 2034,
                "code": "def _index_ordering(redshift_list): redshift_list = np.array(redshift_list) sort_index = np.argsort(redshift_list) return sort_index"
            },
            {
                "url": 5770,
                "code": "def natural_sort(list_to_sort: Iterable[str]) -> List[str]: return sorted(list_to_sort, key=natural_keys)"
            },
            {
                "url": 4334,
                "code": "def natural_sort(list, key=lambda s:s): def get_alphanum_key_func(key): convert = lambda text: int(text) if text.isdigit() else text return lambda s: [convert(c) for c in re.split('([0-9]+)', key(s))] sort_key = get_alphanum_key_func(key) list.sort(key=sort_key)"
            },
            {
                "url": 953,
                "code": "def sorted_index(values, x): i = bisect_left(values, x) j = bisect_right(values, x) return values[i:j].index(x) + i"
            },
            {
                "url": 575,
                "code": "def sort_fn_list(fn_list): dt_list = get_dt_list(fn_list) fn_list_sort = [fn for (dt,fn) in sorted(zip(dt_list,fn_list))] return fn_list_sort"
            },
            {
                "url": 604,
                "code": "def argsort_indices(a, axis=-1): a = np.asarray(a) ind = list(np.ix_(*[np.arange(d) for d in a.shape])) ind[axis] = a.argsort(axis) return tuple(ind)"
            },
            {
                "url": 2375,
                "code": "def csort(objs, key): idxs = dict((obj, i) for (i, obj) in enumerate(objs)) return sorted(objs, key=lambda obj: (key(obj), idxs[obj]))"
            },
            {
                "url": 1174,
                "code": "def arglexsort(arrays): dtypes = ','.join(array.dtype.str for array in arrays) recarray = np.empty(len(arrays[0]), dtype=dtypes) for i, array in enumerate(arrays): recarray['f%s' % i] = array return recarray.argsort()"
            },
            {
                "url": 356,
                "code": "def issorted(list_, op=operator.le): return all(op(list_[ix], list_[ix + 1]) for ix in range(len(list_) - 1))"
            },
            {
                "url": 5484,
                "code": "def naturalsortkey(s): return [int(part) if part.isdigit() else part for part in re.split('([0-9]+)', s)]"
            },
            {
                "url": 320,
                "code": "def count_list(the_list): count = the_list.count result = [(item, count(item)) for item in set(the_list)] result.sort() return result"
            },
            {
                "url": 4323,
                "code": "def sortlevel(self, level=None, ascending=True, sort_remaining=None): return self.sort_values(return_indexer=True, ascending=ascending)"
            },
            {
                "url": 1177,
                "code": "def sort_nicely(l): convert = lambda text: int(text) if text.isdigit() else text alphanum_key = lambda key: [convert(c) for c in re.split('([0-9]+)', key)] l.sort(key=alphanum_key)"
            },
            {
                "url": 1172,
                "code": "def sort_dict(d, key=None, reverse=False): kv_items = [kv for kv in d.items()] # Sort kv_items according to key. if key is None: kv_items.sort(key=lambda t: t[1], reverse=reverse) else: kv_items.sort(key=key, reverse=reverse) # Build ordered dict. return collections.OrderedDict(kv_items)"
            },
            {
                "url": 479,
                "code": "def get_order(self, codes): return sorted(codes, key=lambda e: [self.ev2idx.get(e)])"
            }
        ],
        "url": 2034
    },
    {
        "nl_input": "how to start a new line in python gui",
        "code_input": [
            {
                "url": 428,
                "code": "def go_to_new_line(self): self.stdkey_end(False, False) self.insert_text(self.get_line_separator())"
            },
            {
                "url": 86,
                "code": "def add_str(window, line_num, str): try: window.addstr(line_num, 0, str) except curses.error: pass"
            },
            {
                "url": 3812,
                "code": "def ensure_newline(self): DECTCEM_SHOW = '\\033[?25h' # show cursor AT_END = DECTCEM_SHOW + '\\n' if not self._cursor_at_newline: self.write(AT_END) self._cursor_at_newline = True"
            },
            {
                "url": 814,
                "code": "def _go_to_line(editor, line): b = editor.application.current_buffer b.cursor_position = b.document.translate_row_col_to_index(max(0, int(line) - 1), 0)"
            },
            {
                "url": 818,
                "code": "def go_to_line(self, line): cursor = self.textCursor() cursor.setPosition(self.document().findBlockByNumber(line - 1).position()) self.setTextCursor(cursor) return True"
            },
            {
                "url": 3051,
                "code": "def set_cursor(self, x, y): curses.curs_set(1) self.screen.move(y, x)"
            },
            {
                "url": 972,
                "code": "def page_guiref(arg_s=None): from IPython.core import page page.page(gui_reference, auto_html=True)"
            },
            {
                "url": 624,
                "code": "def end_block(self): self.current_indent -= 1 # If we did not add a new line automatically yet, now it's the time! if not self.auto_added_line: self.writeln() self.auto_added_line = True"
            },
            {
                "url": 1028,
                "code": "def stdoutwriteline(*args): s = \"\" for i in args: s += str(i) + \" \" s = s.strip() sys.stdout.write(str(s) + \"\\n\") sys.stdout.flush() return s"
            },
            {
                "url": 2388,
                "code": "def step_next_line(self): self._eol.append(self.position) self._lineno += 1 self._col_offset = 0"
            },
            {
                "url": 898,
                "code": "def main_func(args=None): # we have to initialize a gui even if we dont need one right now. # as soon as you call maya.standalone.initialize(), a QApplication # with type Tty is created. This is the type for conosle apps. # Because i have not found a way to replace that, we just init the gui. guimain.init_gui() main.init() launcher = Launcher() parsed, unknown = launcher.parse_args(args) parsed.func(parsed, unknown)"
            },
            {
                "url": 494,
                "code": "def enable_gtk3(self, app=None): from pydev_ipython.inputhookgtk3 import create_inputhook_gtk3 self.set_inputhook(create_inputhook_gtk3(self._stdin_file)) self._current_gui = GUI_GTK"
            },
            {
                "url": 783,
                "code": "def erase_lines(n=1): for _ in range(n): print(codes.cursor[\"up\"], end=\"\") print(codes.cursor[\"eol\"], end=\"\")"
            },
            {
                "url": 34,
                "code": "def advance_one_line(self): current_line = self._current_token.line_number while current_line == self._current_token.line_number: self._current_token = ConfigParser.Token(*next(self._token_generator))"
            },
            {
                "url": 3191,
                "code": "def update_cursor_position(self, line, index): value = 'Line {}, Col {}'.format(line + 1, index + 1) self.set_value(value)"
            }
        ],
        "url": 428
    },
    {
        "nl_input": "how to get tuple of colors in image python",
        "code_input": [
            {
                "url": 399,
                "code": "def get_colors(img): w, h = img.size return [color[:3] for count, color in img.convert('RGB').getcolors(w * h)]"
            },
            {
                "url": 5980,
                "code": "def hex_color_to_tuple(hex): hex = hex[1:] length = len(hex) // 2 return tuple(int(hex[i*2:i*2+2], 16) for i in range(length))"
            },
            {
                "url": 2017,
                "code": "def _get_background_color(self): color = self.cell_attributes[self.key][\"bgcolor\"] return tuple(c / 255.0 for c in color_pack2rgb(color))"
            },
            {
                "url": 1551,
                "code": "def rgba_bytes_tuple(self, x): return tuple(int(u*255.9999) for u in self.rgba_floats_tuple(x))"
            },
            {
                "url": 5961,
                "code": "def GetAllPixelColors(self) -> ctypes.Array: return self.GetPixelColorsOfRect(0, 0, self.Width, self.Height)"
            },
            {
                "url": 2930,
                "code": "def get_average_color(colors): c = reduce(color_reducer, colors) total = len(colors) return tuple(v / total for v in c)"
            },
            {
                "url": 5307,
                "code": "def hex_to_rgb(h): h = h.lstrip('#') return tuple(int(h[i:i+2], 16)/255. for i in (0, 2 ,4))"
            },
            {
                "url": 782,
                "code": "def color_to_hex(color): if color is None or colorConverter.to_rgba(color)[3] == 0: return 'none' else: rgb = colorConverter.to_rgb(color) return '#{0:02X}{1:02X}{2:02X}'.format(*(int(255 * c) for c in rgb))"
            },
            {
                "url": 4663,
                "code": "def new(self, size, fill): return Image(PIL.Image.new(\"RGB\", size, fill))"
            },
            {
                "url": 3725,
                "code": "def _value_to_color(value, cmap): cm = plt.get_cmap(cmap) rgba = cm(value) return [int(round(255*v)) for v in rgba[0:3]]"
            },
            {
                "url": 4493,
                "code": "def imagemagick(color_count, img, magick_command): flags = [\"-resize\", \"25%\", \"-colors\", str(color_count), \"-unique-colors\", \"txt:-\"] img += \"[0]\" return subprocess.check_output([*magick_command, img, *flags]).splitlines()"
            },
            {
                "url": 3510,
                "code": "def name2rgb(hue): r, g, b = colorsys.hsv_to_rgb(hue / 360.0, .8, .7) return tuple(int(x * 256) for x in [r, g, b])"
            },
            {
                "url": 1567,
                "code": "def color_func(func_name): if str(func_name).isdigit(): return term_color(int(func_name)) return globals()[func_name]"
            },
            {
                "url": 1939,
                "code": "def hex_to_hsv(color): color = normalize(color) color = color[1:] # color=tuple(ord(c)/255.0 for c in color.decode('hex')) color = (int(color[0:2], base=16) / 255.0, int(color[2:4], base=16) / 255.0, int(color[4:6], base=16) / 255.0) return colorsys.rgb_to_hsv(*color)"
            },
            {
                "url": 2325,
                "code": "def copy_image_on_background(image, color=WHITE): background = Image.new(\"RGB\", image.size, color) background.paste(image, mask=image.split()[3]) return background"
            }
        ],
        "url": 1551
    },
    {
        "nl_input": "make datetime aware python",
        "code_input": [
            {
                "url": 1262,
                "code": "def make_aware(dt): return dt if dt.tzinfo else dt.replace(tzinfo=timezone.utc)"
            },
            {
                "url": 5173,
                "code": "def make_aware(value, timezone): if hasattr(timezone, 'localize') and value not in (datetime.datetime.min, datetime.datetime.max): # available for pytz time zones return timezone.localize(value, is_dst=None) else: # may be wrong around DST changes return value.replace(tzinfo=timezone)"
            },
            {
                "url": 3998,
                "code": "def _strptime(self, time_str): if time_str: # Parse UTC string into naive datetime, then add timezone dt = datetime.strptime(time_str, __timeformat__) return dt.replace(tzinfo=UTC()) return None"
            },
            {
                "url": 117,
                "code": "def datetime_to_timezone(date, tz=\"UTC\"): if not date.tzinfo: date = date.replace(tzinfo=timezone(get_timezone())) return date.astimezone(timezone(tz))"
            },
            {
                "url": 2801,
                "code": "def __to_localdatetime(val): try: dt = datetime.strptime(val, __DATE_FORMAT) dt = pytz.timezone(__TIMEZONE).localize(dt) return dt except (ValueError, TypeError): return None"
            },
            {
                "url": 2199,
                "code": "def clean_time(time_string): # Get a timezone-aware datetime object from the string time = dateutil.parser.parse(time_string) if not settings.USE_TZ: # If timezone support is not active, convert the time to UTC and # remove the timezone field time = time.astimezone(timezone.utc).replace(tzinfo=None) return time"
            },
            {
                "url": 1639,
                "code": "def timestamp_to_datetime(cls, time_stamp, localized=True): ret = datetime.datetime.utcfromtimestamp(time_stamp) if localized: ret = localize(ret, pytz.utc) return ret"
            },
            {
                "url": 121,
                "code": "def localize(dt): if dt.tzinfo is UTC: return (dt + LOCAL_UTC_OFFSET).replace(tzinfo=None) # No TZ info so not going to assume anything, return as-is. return dt"
            },
            {
                "url": 1894,
                "code": "def convert_2_utc(self, datetime_, timezone): datetime_ = self.tz_mapper[timezone].localize(datetime_) return datetime_.astimezone(pytz.UTC)"
            },
            {
                "url": 1384,
                "code": "def now(timezone=None): d = datetime.datetime.utcnow() if not timezone: return d return to_timezone(d, timezone).replace(tzinfo=None)"
            },
            {
                "url": 758,
                "code": "def get_naive(dt): if not dt.tzinfo: return dt if hasattr(dt, \"asdatetime\"): return dt.asdatetime() return dt.replace(tzinfo=None)"
            },
            {
                "url": 5515,
                "code": "def convert_timezone(obj, timezone): if timezone is None: return obj.replace(tzinfo=None) return pytz.timezone(timezone).localize(obj)"
            },
            {
                "url": 2768,
                "code": "def to_pydatetime(self): dt = datetime.datetime.combine(self._date.to_pydate(), self._time.to_pytime()) from .tz import FixedOffsetTimezone return dt.replace(tzinfo=_utc).astimezone(FixedOffsetTimezone(self._offset))"
            },
            {
                "url": 1621,
                "code": "def unixtime_to_datetime(ut): dt = datetime.datetime.utcfromtimestamp(ut) dt = dt.replace(tzinfo=tz.tzutc()) return dt"
            },
            {
                "url": 5950,
                "code": "def iso_string_to_python_datetime( isostring: str) -> Optional[datetime.datetime]: if not isostring: return None # if you parse() an empty string, you get today's date return dateutil.parser.parse(isostring)"
            }
        ],
        "url": 1753
    },
    {
        "nl_input": "python dict drop empty",
        "code_input": [
            {
                "url": 5594,
                "code": "def dictlist_wipe_key(dict_list: Iterable[Dict], key: str) -> None: for d in dict_list: d.pop(key, None)"
            },
            {
                "url": 185,
                "code": "def _remove_dict_keys_with_value(dict_, val): return {k: v for k, v in dict_.items() if v is not val}"
            },
            {
                "url": 2205,
                "code": "def clean_dict_keys(d): new_d = {} for (k, v) in d.iteritems(): new_d[str(k)] = v return new_d"
            },
            {
                "url": 4024,
                "code": "def _remove_empty_items(d, required): new_dict = {} for k, v in d.items(): if k in required: new_dict[k] = v elif isinstance(v, int) or v: # \"if v\" would suppress emitting int(0) new_dict[k] = v return new_dict"
            },
            {
                "url": 695,
                "code": "def _clean_dict(target_dict, whitelist=None): assert isinstance(target_dict, dict) return { ustr(k).strip(): ustr(v).strip() for k, v in target_dict.items() if v not in (None, Ellipsis, [], (), \"\") and (not whitelist or k in whitelist) }"
            },
            {
                "url": 2281,
                "code": "def _remove_none_values(dictionary): return list(map(dictionary.pop, [i for i in dictionary if dictionary[i] is None]))"
            },
            {
                "url": 1015,
                "code": "def rm_keys_from_dict(d, keys): # Loop for each key given for key in keys: # Is the key in the dictionary? if key in d: try: d.pop(key, None) except KeyError: # Not concerned with an error. Keep going. pass return d"
            },
            {
                "url": 1795,
                "code": "def check_empty_dict(GET_dict): empty = True for k, v in GET_dict.items(): # Don't disable on p(age) or 'all' GET param if v and k != 'p' and k != 'all': empty = False return empty"
            },
            {
                "url": 1017,
                "code": "def purge_dict(idict): odict = {} for key, val in idict.items(): if is_null(val): continue odict[key] = val return odict"
            },
            {
                "url": 6132,
                "code": "def dictlist_replace(dict_list: Iterable[Dict], key: str, value: Any) -> None: for d in dict_list: d[key] = value"
            },
            {
                "url": 4719,
                "code": "def dict_keys_without_hyphens(a_dict): return dict( (key.replace('-', '_'), val) for key, val in a_dict.items())"
            },
            {
                "url": 177,
                "code": "def filter_dict(d, keys): return {k: v for k, v in d.items() if k in keys}"
            },
            {
                "url": 4670,
                "code": "def _strip_empty_keys(self, params): keys = [k for k, v in params.items() if v == ''] for key in keys: del params[key]"
            },
            {
                "url": 2569,
                "code": "def _delete_keys(dct, keys): c = deepcopy(dct) assert isinstance(keys, list) for k in keys: c.pop(k) return c"
            },
            {
                "url": 179,
                "code": "def dict_update_newkeys(dict_, dict2): for key, val in six.iteritems(dict2): if key not in dict_: dict_[key] = val"
            }
        ],
        "url": 1017
    },
    {
        "nl_input": "python pretty print without sort",
        "code_input": [
            {
                "url": 2227,
                "code": "def prettyprint(d): print(json.dumps(d, sort_keys=True, indent=4, separators=(\",\" , \": \")))"
            },
            {
                "url": 5879,
                "code": "def pretty_dict(d): return '{%s}' % ', '.join('%r: %r' % (k, v) for k, v in sorted(d.items(), key=repr))"
            },
            {
                "url": 4627,
                "code": "def pprint(j, no_pretty): if not no_pretty: click.echo( json.dumps(j, cls=PotionJSONEncoder, sort_keys=True, indent=4, separators=(\",\", \": \")) ) else: click.echo(j)"
            },
            {
                "url": 1391,
                "code": "def pretty_dict_string(d, indent=0): s = '' for key, value in sorted(d.items()): s += ' ' * indent + str(key) if isinstance(value, dict): s += '\\n' + pretty_dict_string(value, indent+1) else: s += '=' + str(value) + '\\n' return s"
            },
            {
                "url": 4796,
                "code": "def json_pretty_dump(obj, filename): with open(filename, \"wt\") as fh: json.dump(obj, fh, indent=4, sort_keys=4)"
            },
            {
                "url": 684,
                "code": "def pretty_dict_str(d, indent=2): b = StringIO() write_pretty_dict_str(b, d, indent=indent) return b.getvalue()"
            },
            {
                "url": 2228,
                "code": "def printdict(adict): dlist = list(adict.keys()) dlist.sort() for i in range(0, len(dlist)): print(dlist[i], adict[dlist[i]])"
            },
            {
                "url": 72,
                "code": "def _attrprint(d, delimiter=', '): return delimiter.join(('\"%s\"=\"%s\"' % item) for item in sorted(d.items()))"
            },
            {
                "url": 1942,
                "code": "def _get_pretty_string(obj): sio = StringIO() pprint.pprint(obj, stream=sio) return sio.getvalue()"
            },
            {
                "url": 2904,
                "code": "def Print(self): for val, prob in sorted(self.d.iteritems()): print(val, prob)"
            },
            {
                "url": 3890,
                "code": "def pprint(self, ind): pp = pprint.PrettyPrinter(indent=ind) pp.pprint(self.tree)"
            },
            {
                "url": 2230,
                "code": "def pprint(o, stream=None, indent=1, width=80, depth=None): printer = PrettyPrinter( stream=stream, indent=indent, width=width, depth=depth) printer.pprint(o)"
            },
            {
                "url": 31,
                "code": "def pformat(object, indent=1, width=80, depth=None): return PrettyPrinter(indent=indent, width=width, depth=depth).pformat(object)"
            },
            {
                "url": 2059,
                "code": "def json_dumps(self, obj): return json.dumps(obj, sort_keys=True, indent=4, separators=(',', ': '))"
            },
            {
                "url": 923,
                "code": "def pformat(o, indent=1, width=80, depth=None): return PrettyPrinter(indent=indent, width=width, depth=depth).pformat(o)"
            }
        ],
        "url": 2225
    },
    {
        "nl_input": "python check if interactive",
        "code_input": [
            {
                "url": 3513,
                "code": "def is_interactive(self): # The Python interpreter sets sys.flags correctly, so use them! if sys.flags.interactive: return True # IPython does not set sys.flags when -i is specified, so first # check it if it is already imported. if '__IPYTHON__' not in dir(six.moves.builtins): return False # Then we check the application singleton and determine based on # a variable it sets. try: from IPython.config.application import Application as App return App.initialized() and App.instance().interact except (ImportError, AttributeError): return False"
            },
            {
                "url": 2779,
                "code": "def determine_interactive(self): try: if not sys.stdout.isatty() or os.getpgrp() != os.tcgetpgrp(sys.stdout.fileno()): self.interactive = 0 return False except Exception: self.interactive = 0 return False if self.interactive == 0: return False return True"
            },
            {
                "url": 133,
                "code": "def isInteractive(): if sys.stdout.isatty() and os.name != 'nt': #Hopefully everything but ms supports '\\r' try: import threading except ImportError: return False else: return True else: return False"
            },
            {
                "url": 6055,
                "code": "def _in_qtconsole() -> bool: try: from IPython import get_ipython try: from ipykernel.zmqshell import ZMQInteractiveShell shell_object = ZMQInteractiveShell except ImportError: from IPython.kernel.zmq import zmqshell shell_object = zmqshell.ZMQInteractiveShell return isinstance(get_ipython(), shell_object) except Exception: return False"
            },
            {
                "url": 676,
                "code": "def IPYTHON_MAIN(): import pkg_resources runner_frame = inspect.getouterframes(inspect.currentframe())[-2] return ( getattr(runner_frame, \"function\", None) == pkg_resources.load_entry_point(\"ipython\", \"console_scripts\", \"ipython\").__name__ )"
            },
            {
                "url": 6187,
                "code": "def check_python_version(): # Required due to multiple with statements on one line req_version = (2, 7) cur_version = sys.version_info if cur_version >= req_version: print(\"Python version... %sOK%s (found %s, requires %s)\" % (Bcolors.OKGREEN, Bcolors.ENDC, str(platform.python_version()), str(req_version[0]) + \".\" + str(req_version[1]))) else: print(\"Python version... %sFAIL%s (found %s, requires %s)\" % (Bcolors.FAIL, Bcolors.ENDC, str(cur_version), str(req_version)))"
            },
            {
                "url": 4749,
                "code": "def show_intro(self): from IPython.core.usage import interactive_usage self.main.help.show_rich_text(interactive_usage)"
            },
            {
                "url": 5738,
                "code": "def interact(self, container: Container) -> None: cmd = \"/bin/bash -c 'source /.environment && /bin/bash'\" cmd = \"docker exec -it {} {}\".format(container.id, cmd) subprocess.call(cmd, shell=True)"
            },
            {
                "url": 202,
                "code": "def is_defined(self, objtxt, force_import=False): return self.interpreter.is_defined(objtxt, force_import)"
            },
            {
                "url": 1085,
                "code": "def stdin_readable(): if not WINDOWS: try: return bool(select([sys.stdin], [], [], 0)[0]) except Exception: logger.log_exc() try: return not sys.stdin.isatty() except Exception: logger.log_exc() return False"
            },
            {
                "url": 2087,
                "code": "def is_text(obj, name=None): try: # python2 ans = isinstance(obj, basestring) except NameError: # python3 ans = isinstance(obj, str) if name: print(\"is_text: (%s) %s = %s\" % (ans, name, obj.__class__), file=sys.stderr) return ans"
            },
            {
                "url": 2029,
                "code": "def intty(cls): # XXX: temporary hack until we can detect if we are in a pipe or not return True if hasattr(sys.stdout, 'isatty') and sys.stdout.isatty(): return True return False"
            },
            {
                "url": 2845,
                "code": "def iiscgi(application): try: from wsgiref.handlers import IISCGIHandler except ImportError: print(\"Python 3.2 or newer is required.\") if not __debug__: warnings.warn(\"Interactive debugging and other persistence-based processes will not work.\") IISCGIHandler().run(application)"
            },
            {
                "url": 1297,
                "code": "def istype(obj, check): if isinstance(check, tuple): for cls in check: if type(obj) is cls: return True return False else: return type(obj) is check"
            },
            {
                "url": 5751,
                "code": "def validate_django_compatible_with_python(): python_version = sys.version[:5] django_version = django.get_version() if sys.version_info == (2, 7) and django_version >= \"2\": click.BadArgumentUsage(\"Please install Django v1.11 for Python {}, or switch to Python >= v3.4\".format(python_version))"
            }
        ],
        "url": 2779
    },
    {
        "nl_input": "python pid determine existence",
        "code_input": [
            {
                "url": 528,
                "code": "def pid_exists(pid): try: os.kill(pid, 0) except OSError as exc: return exc.errno == errno.EPERM else: return True"
            },
            {
                "url": 4121,
                "code": "def get_pid_list(): pids = [int(x) for x in os.listdir('/proc') if x.isdigit()] return pids"
            },
            {
                "url": 2244,
                "code": "def stop(pid): if psutil.pid_exists(pid): try: p = psutil.Process(pid) p.kill() except Exception: pass"
            },
            {
                "url": 915,
                "code": "def _psutil_kill_pid(pid): try: parent = Process(pid) for child in parent.children(recursive=True): child.kill() parent.kill() except NoSuchProcess: return"
            },
            {
                "url": 5720,
                "code": "def is_running(process_id: int) -> bool: pstr = str(process_id) encoding = sys.getdefaultencoding() s = subprocess.Popen([\"ps\", \"-p\", pstr], stdout=subprocess.PIPE) for line in s.stdout: strline = line.decode(encoding) if pstr in strline: return True return False"
            },
            {
                "url": 5489,
                "code": "def write_pid_file(): pidfile = os.path.basename(sys.argv[0])[:-3] + '.pid' # strip .py, add .pid with open(pidfile, 'w') as fh: fh.write(\"%d\\n\" % os.getpid()) fh.close()"
            },
            {
                "url": 239,
                "code": "def _pip_exists(self): return os.path.isfile(os.path.join(self.path, 'bin', 'pip'))"
            },
            {
                "url": 4376,
                "code": "async def stop(self): # negate pid so that signals apply to process group pgid = -self.process.pid try: os.kill(pgid, signal.SIGTERM) await asyncio.sleep(1) os.kill(pgid, signal.SIGKILL) except (OSError, ProcessLookupError): return"
            },
            {
                "url": 2327,
                "code": "def kill_mprocess(process): if process and proc_alive(process): process.terminate() process.communicate() return not proc_alive(process)"
            },
            {
                "url": 2728,
                "code": "def process_kill(pid, sig=None): sig = sig or signal.SIGTERM os.kill(pid, sig)"
            },
            {
                "url": 2515,
                "code": "def _write_pidfile(pidfile): pid = str(os.getpid()) handle = open(pidfile, 'w') try: handle.write(\"%s\\n\" % pid) finally: handle.close()"
            },
            {
                "url": 1306,
                "code": "def kill_process_children(pid): if sys.platform == \"darwin\": kill_process_children_osx(pid) elif sys.platform == \"linux\": kill_process_children_unix(pid) else: pass"
            },
            {
                "url": 5026,
                "code": "def db_exists(): logger.info(\"Checking to see if %s already exists\", repr(DB[\"NAME\"])) try: # Hide stderr since it is confusing here psql(\"\", stderr=subprocess.STDOUT) except subprocess.CalledProcessError: return False return True"
            },
            {
                "url": 1086,
                "code": "def execute_in_background(self): # http://stackoverflow.com/questions/1605520 args = shlex.split(self.cmd) p = Popen(args) return p.pid"
            },
            {
                "url": 2932,
                "code": "def user_exists(username): try: pwd.getpwnam(username) user_exists = True except KeyError: user_exists = False return user_exists"
            }
        ],
        "url": 528
    },
    {
        "nl_input": "python pymongo insert without duplicatte",
        "code_input": [
            {
                "url": 4267,
                "code": "def insert_one(self, mongo_collection, doc, mongo_db=None, **kwargs): collection = self.get_collection(mongo_collection, mongo_db=mongo_db) return collection.insert_one(doc, **kwargs)"
            },
            {
                "url": 4406,
                "code": "def upsert_single(db, collection, object, match_params=None): return str(db[collection].update_one(match_params, {\"$set\": object}, upsert=True).upserted_id)"
            },
            {
                "url": 6120,
                "code": "def upsert_multi(db, collection, object, match_params=None): if isinstance(object, list) and len(object) > 0: return str(db[collection].insert_many(object).inserted_ids) elif isinstance(object, dict): return str(db[collection].update_many(match_params, {\"$set\": object}, upsert=False).upserted_id)"
            },
            {
                "url": 2395,
                "code": "def insert_many(self, items): return SessionContext.session.execute( self.insert(values=[ to_dict(item, self.c) for item in items ]), ).rowcount"
            },
            {
                "url": 3211,
                "code": "def update_one(self, query, doc): if self.table is None: self.build_table() if u\"$set\" in doc: doc = doc[u\"$set\"] allcond = self.parse_query(query) try: result = self.table.update(doc, allcond) except: # TODO: check table.update result # check what pymongo does in that case result = None return UpdateResult(raw_result=result)"
            },
            {
                "url": 1378,
                "code": "def find_one(self, query): mongo_response = yield self.collection.find_one(query) raise Return(self._obj_cursor_to_dictionary(mongo_response))"
            },
            {
                "url": 4586,
                "code": "def replace_one(self, replacement): self.__bulk.add_replace(self.__selector, replacement, upsert=True, collation=self.__collation)"
            },
            {
                "url": 4655,
                "code": "def find_one_by_id(self, _id): document = (yield self.collection.find_one({\"_id\": ObjectId(_id)})) raise Return(self._obj_cursor_to_dictionary(document))"
            },
            {
                "url": 4942,
                "code": "def __call__(self, *args, **kwargs): kwargs[\"mongokat_collection\"] = self return self.document_class(*args, **kwargs)"
            },
            {
                "url": 5034,
                "code": "def write(self, value): self.get_collection().update_one( {'_id': self._document_id}, {'$set': {self._path: value}}, upsert=True )"
            },
            {
                "url": 3691,
                "code": "def create_cursor(self, name=None): return Cursor(self.client_connection, self.connection, self.djongo_connection)"
            },
            {
                "url": 5283,
                "code": "def copy(self): return self.__class__(self.operations.copy(), self.collection, self.document)"
            },
            {
                "url": 3517,
                "code": "def delete_collection(mongo_uri, database_name, collection_name): client = pymongo.MongoClient(mongo_uri) db = client[database_name] db.drop_collection(collection_name)"
            },
            {
                "url": 3314,
                "code": "def ensure_index(self, key, unique=False): return self.collection.ensure_index(key, unique=unique)"
            },
            {
                "url": 4968,
                "code": "def mongoqs_to_json(qs, fields=None): l = list(qs.as_pymongo()) for element in l: element.pop('_cls') # use DjangoJSONEncoder for transform date data type to datetime json_qs = json.dumps(l, indent=2, ensure_ascii=False, cls=DjangoJSONEncoder) return json_qs"
            }
        ],
        "url": 4267
    },
    {
        "nl_input": "how to read json files with multiple object python",
        "code_input": [
            {
                "url": 3131,
                "code": "def _read_json_file(self, json_file): self.log.debug(\"Reading '%s' JSON file...\" % json_file) with open(json_file, 'r') as f: return json.load(f, object_pairs_hook=OrderedDict)"
            },
            {
                "url": 977,
                "code": "def open_json(file_name): with open(file_name, \"r\") as json_data: data = json.load(json_data) return data"
            },
            {
                "url": 5563,
                "code": "def from_file(file_path) -> dict: with io.open(file_path, 'r', encoding='utf-8') as json_stream: return Json.parse(json_stream, True)"
            },
            {
                "url": 4188,
                "code": "def json_get_data(filename): with open(filename) as fp: json_data = json.load(fp) return json_data return False"
            },
            {
                "url": 3659,
                "code": "def from_file(filename): f = open(filename, 'r') j = json.load(f) f.close() return from_dict(j)"
            },
            {
                "url": 1300,
                "code": "def read_json(location): location = ensure_path(location) with location.open('r', encoding='utf8') as f: return ujson.load(f)"
            },
            {
                "url": 983,
                "code": "def json_iter (path): with open(path, 'r') as f: for line in f.readlines(): yield json.loads(line)"
            },
            {
                "url": 3889,
                "code": "def load_jsonf(fpath, encoding): with codecs.open(fpath, encoding=encoding) as f: return json.load(f)"
            },
            {
                "url": 5016,
                "code": "def load(cls, fp, **kwargs): json_obj = json.load(fp, **kwargs) return parse(cls, json_obj)"
            },
            {
                "url": 4442,
                "code": "def save_json(object, handle, indent=2): obj_json = json.dumps(object, indent=indent, cls=NumpyJSONEncoder) handle.write(obj_json)"
            },
            {
                "url": 2956,
                "code": "def read_dict_from_file(file_path): with open(file_path) as file: lines = file.read().splitlines() obj = {} for line in lines: key, value = line.split(':', maxsplit=1) obj[key] = eval(value) return obj"
            },
            {
                "url": 3944,
                "code": "def parse_json(filename): # Regular expression for comments comment_re = re.compile( '(^)?[^\\S\\n]*/(?:\\*(.*?)\\*/[^\\S\\n]*|/[^\\n]*)($)?', re.DOTALL | re.MULTILINE ) with open(filename) as f: content = ''.join(f.readlines()) ## Looking for comments match = comment_re.search(content) while match: # single line comment content = content[:match.start()] + content[match.end():] match = comment_re.search(content) # Return json file return json.loads(content)"
            },
            {
                "url": 1409,
                "code": "def _loadfilepath(self, filepath, **kwargs): with open(filepath, \"r\") as f: data = json.load(f, **kwargs) return data"
            },
            {
                "url": 2552,
                "code": "def load_from_file(cls, file_path: str): with open(file_path, \"r\") as f: data = json.load(f) item = cls.decode(data=data) return item"
            },
            {
                "url": 3015,
                "code": "def load(filename): if not os.path.exists(filename): LOG.error(\"load object - File '%s' does not exist.\", filename) return None obj = None with open(filename, 'rb') as obj_file: obj = dill.load(obj_file) return obj"
            }
        ],
        "url": 3131
    },
    {
        "nl_input": "python discord leave voice channel",
        "code_input": [
            {
                "url": 1923,
                "code": "async def join(self, ctx, *, channel: discord.VoiceChannel): if ctx.voice_client is not None: return await ctx.voice_client.move_to(channel) await channel.connect()"
            },
            {
                "url": 4531,
                "code": "async def connect(self): await self.node.join_voice_channel(self.channel.guild.id, self.channel.id)"
            },
            {
                "url": 3788,
                "code": "def log_leave(event, nick, channel): if channel not in pmxbot.config.log_channels: return ParticipantLogger.store.log(nick, channel, event.type)"
            },
            {
                "url": 4821,
                "code": "async def unignore_all(self, ctx): channels = [c for c in ctx.message.server.channels if c.type is discord.ChannelType.text] await ctx.invoke(self.unignore, *channels)"
            },
            {
                "url": 4082,
                "code": "async def vc_check(ctx: commands.Context): # pylint: disable=unused-argument if not discord.voice_client.has_nacl: raise commands.CheckFailure(\"voice cannot be used because PyNaCl is not loaded\") if not discord.opus.is_loaded(): raise commands.CheckFailure(\"voice cannot be used because libopus is not loaded\") return True"
            },
            {
                "url": 3288,
                "code": "def on_welcome(self, connection, event): connection.join(self.channel, key=settings.IRC_CHANNEL_KEY or \"\")"
            },
            {
                "url": 3133,
                "code": "def kick(self, channel, nick, comment=\"\"): self.send_items('KICK', channel, nick, comment and ':' + comment)"
            },
            {
                "url": 2282,
                "code": "def join(self, room): self.socket.rooms.add(self._get_room_name(room))"
            },
            {
                "url": 3567,
                "code": "async def delete(self): return await self.bot.delete_message(self.chat.id, self.message_id)"
            },
            {
                "url": 3287,
                "code": "def subscribe_to_quorum_channel(self): from dallinger.experiment_server.sockets import chat_backend self.log(\"Bot subscribing to quorum channel.\") chat_backend.subscribe(self, \"quorum\")"
            },
            {
                "url": 1925,
                "code": "def _handle_chat_name(self, data): self.room.user.nick = data self.conn.enqueue_data(\"user\", self.room.user)"
            },
            {
                "url": 3310,
                "code": "def send_notice(self, text): return self.client.api.send_notice(self.room_id, text)"
            },
            {
                "url": 1194,
                "code": "def disown(cmd): subprocess.Popen(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)"
            },
            {
                "url": 416,
                "code": "def me(self): return self.guild.me if self.guild is not None else self.bot.user"
            },
            {
                "url": 5298,
                "code": "def get_chat_member(self, user_id): return self.bot.api_call( \"getChatMember\", chat_id=str(self.id), user_id=str(user_id) )"
            }
        ],
        "url": 1923
    },
    {
        "nl_input": "python unittest make tests discoverable",
        "code_input": [
            {
                "url": 199,
                "code": "def test(): import unittest tests = unittest.TestLoader().discover('tests') unittest.TextTestRunner(verbosity=2).run(tests)"
            },
            {
                "url": 1493,
                "code": "def test(): # pragma: no cover import pytest import os pytest.main([os.path.dirname(os.path.abspath(__file__))])"
            },
            {
                "url": 1305,
                "code": "def test(): command = 'nosetests --with-coverage --cover-package=pwnurl' status = subprocess.call(shlex.split(command)) sys.exit(status)"
            },
            {
                "url": 118,
                "code": "def test(*args): subprocess.call([\"py.test-2.7\"] + list(args)) subprocess.call([\"py.test-3.4\"] + list(args))"
            },
            {
                "url": 2070,
                "code": "def run_tests(self): with _save_argv(_sys.argv[:1] + self.addopts): result_code = __import__('pytest').main() if result_code: raise SystemExit(result_code)"
            },
            {
                "url": 1291,
                "code": "def test_python_java_rt(): sub_env = {'PYTHONPATH': _build_dir()} log.info('Executing Python unit tests (against Java runtime classes)...') return jpyutil._execute_python_scripts(python_java_rt_tests, env=sub_env)"
            },
            {
                "url": 3588,
                "code": "def main(argv=sys.argv, stream=sys.stderr): args = parse_args(argv) suite = build_suite(args) runner = unittest.TextTestRunner(verbosity=args.verbose, stream=stream) result = runner.run(suite) return get_status(result)"
            },
            {
                "url": 3300,
                "code": "def autobuild_python_test(path): env = Environment(tools=[]) target = env.Command(['build/test/output/pytest.log'], [path], action=env.Action(run_pytest, \"Running python unit tests\")) env.AlwaysBuild(target)"
            },
            {
                "url": 1496,
                "code": "def test(nose_argsuments): from nose import run params = ['__main__', '-c', 'nose.ini'] params.extend(nose_argsuments) run(argv=params)"
            },
            {
                "url": 586,
                "code": "def debug_src(src, pm=False, globs=None): testsrc = script_from_examples(src) debug_script(testsrc, pm, globs)"
            },
            {
                "url": 942,
                "code": "def test(ctx, all=False, verbose=False): cmd = 'tox' if all else 'py.test' if verbose: cmd += ' -v' return ctx.run(cmd, pty=True).return_code"
            },
            {
                "url": 799,
                "code": "def coverage(): # Note: coverage options are controlled by .coveragerc file install() test_setup() sh(\"%s -m coverage run %s\" % (PYTHON, TEST_SCRIPT)) sh(\"%s -m coverage report\" % PYTHON) sh(\"%s -m coverage html\" % PYTHON) sh(\"%s -m webbrowser -t htmlcov/index.html\" % PYTHON)"
            },
            {
                "url": 142,
                "code": "def test(): from spyder.utils.qthelpers import qapplication app = qapplication() dlg = ProjectDialog(None) dlg.show() sys.exit(app.exec_())"
            },
            {
                "url": 4778,
                "code": "def coverage(ctx, opts=\"\"): return test(ctx, coverage=True, include_slow=True, opts=opts)"
            },
            {
                "url": 2475,
                "code": "def cover(session): session.interpreter = 'python3.6' session.install('coverage', 'pytest-cov') session.run('coverage', 'report', '--show-missing', '--fail-under=100') session.run('coverage', 'erase')"
            }
        ],
        "url": 199
    },
    {
        "nl_input": "multiline text send message python",
        "code_input": [
            {
                "url": 4130,
                "code": "def send_text(self, text): return self.client.api.send_message(self.room_id, text)"
            },
            {
                "url": 3367,
                "code": "async def send_message(): jar = aiohttp.CookieJar(unsafe=True) websession = aiohttp.ClientSession(cookie_jar=jar) modem = eternalegypt.Modem(hostname=sys.argv[1], websession=websession) await modem.login(password=sys.argv[2]) await modem.sms(phone=sys.argv[3], message=sys.argv[4]) await modem.logout() await websession.close()"
            },
            {
                "url": 1510,
                "code": "async def _send_plain_text(self, request: Request, stack: Stack): await self._send_text(request, stack, None)"
            },
            {
                "url": 1509,
                "code": "def send_email_message(self, recipient, subject, html_message, text_message, sender_email, sender_name): if not current_app.testing: # pragma: no cover # Prepare email message from flask_sendmail import Message message = Message( subject, recipients=[recipient], html=html_message, body=text_message) # Send email message self.mail.send(message)"
            },
            {
                "url": 39,
                "code": "def send(message, request_context=None, binary=False): if binary: return uwsgi.websocket_send_binary(message, request_context) return uwsgi.websocket_send(message, request_context)"
            },
            {
                "url": 5092,
                "code": "def print_message(message=None): kwargs = {'stdout': sys.stdout, 'stderr': sys.stderr, 'shell': True} return subprocess.call('echo \"{0}\"'.format(message or ''), **kwargs)"
            },
            {
                "url": 804,
                "code": "def _message_to_string(message, data=None): if data is None: data = _json_from_message(message) return \"Message {} from {} to {}: {}\".format( message.namespace, message.source_id, message.destination_id, data)"
            },
            {
                "url": 4742,
                "code": "def send(self, *args, **kwargs): self.write(*args, **kwargs) self.flush()"
            },
            {
                "url": 5084,
                "code": "def _send(self, data): if not self._sock: self.connect() self._do_send(data)"
            },
            {
                "url": 2867,
                "code": "def text_response(self, contents, code=200, headers={}): return Response(contents, status=code, headers={ 'Content-Type': 'text/plain' })"
            },
            {
                "url": 3751,
                "code": "def message_from_string(s, *args, **kws): from future.backports.email.parser import Parser return Parser(*args, **kws).parsestr(s)"
            },
            {
                "url": 3310,
                "code": "def send_notice(self, text): return self.client.api.send_notice(self.room_id, text)"
            },
            {
                "url": 2341,
                "code": "def send(r, stream=False): r.send(stream=stream) return r.response"
            },
            {
                "url": 2622,
                "code": "async def repeat(ctx, times: int, content='repeating...'): for i in range(times): await ctx.send(content)"
            },
            {
                "url": 5517,
                "code": "def codebox(msg=\"\", title=\" \", text=\"\"): return tb.textbox(msg, title, text, codebox=1)"
            }
        ],
        "url": 1510
    },
    {
        "nl_input": "extract integers from string in python",
        "code_input": [
            {
                "url": 5643,
                "code": "def strings_to_integers(strings: Iterable[str]) -> Iterable[int]: return strings_to_(strings, lambda x: int(float(x)))"
            },
            {
                "url": 1860,
                "code": "def str2int(string_with_int): return int(\"\".join([char for char in string_with_int if char in string.digits]) or 0)"
            },
            {
                "url": 5836,
                "code": "def clean_int(x) -> int: try: return int(x) except ValueError: raise forms.ValidationError( \"Cannot convert to integer: {}\".format(repr(x)))"
            },
            {
                "url": 5192,
                "code": "def prsint(string): string = stypes.stringToCharP(string) intval = ctypes.c_int() libspice.prsint_c(string, ctypes.byref(intval)) return intval.value"
            },
            {
                "url": 2036,
                "code": "def bin_to_int(string): if isinstance(string, str): return struct.unpack(\"b\", string)[0] else: return struct.unpack(\"b\", bytes([string]))[0]"
            },
            {
                "url": 1603,
                "code": "def string_to_int( s ): result = 0 for c in s: if not isinstance(c, int): c = ord( c ) result = 256 * result + c return result"
            },
            {
                "url": 2437,
                "code": "def check_int(integer): if not isinstance(integer, str): return False if integer[0] in ('-', '+'): return integer[1:].isdigit() return integer.isdigit()"
            },
            {
                "url": 2828,
                "code": "def get_numbers(s): result = map(int, re.findall(r'[0-9]+', unicode(s))) return result + [1] * (2 - len(result))"
            },
            {
                "url": 5701,
                "code": "def convert_bytes_to_ints(in_bytes, num): dt = numpy.dtype('>i' + str(num)) return numpy.frombuffer(in_bytes, dt)"
            },
            {
                "url": 5669,
                "code": "def _parse_tuple_string(argument): if isinstance(argument, str): return tuple(int(p.strip()) for p in argument.split(',')) return argument"
            },
            {
                "url": 4197,
                "code": "def str_to_num(str_value): str_value = str(str_value) try: return int(str_value) except ValueError: return float(str_value)"
            },
            {
                "url": 2466,
                "code": "def toListInt(value): if TypeConverters._can_convert_to_list(value): value = TypeConverters.toList(value) if all(map(lambda v: TypeConverters._is_integer(v), value)): return [int(v) for v in value] raise TypeError(\"Could not convert %s to list of ints\" % value)"
            },
            {
                "url": 3842,
                "code": "def _return_comma_list(self, l): if isinstance(l, (text_type, int)): return l if not isinstance(l, list): raise TypeError(l, ' should be a list of integers, \\ not {0}'.format(type(l))) str_ids = ','.join(str(i) for i in l) return str_ids"
            },
            {
                "url": 40,
                "code": "def get_number(s, cast=int): import string d = \"\".join(x for x in str(s) if x in string.digits) return cast(d)"
            },
            {
                "url": 3791,
                "code": "def cast_int(x): try: x = int(x) except ValueError: try: x = x.strip() except AttributeError as e: logger_misc.warn(\"parse_str: AttributeError: String not number or word, {}, {}\".format(x, e)) return x"
            }
        ],
        "url": 2828
    },
    {
        "nl_input": "python take a string after the title",
        "code_input": [
            {
                "url": 4355,
                "code": "def _format_title_string(self, title_string): return self._title_string_format_text_tag(title_string.replace(self.icy_tokkens[0], self.icy_title_prefix))"
            },
            {
                "url": 6240,
                "code": "def titleize(text): if len(text) == 0: # if empty string, return it return text else: text = text.lower() # lower all char # delete redundant empty space chunks = [chunk[0].upper() + chunk[1:] for chunk in text.split(\" \") if len(chunk) >= 1] return \" \".join(chunks)"
            },
            {
                "url": 3996,
                "code": "def get_title(soup): if soup.title: return soup.title.string if soup.h1: return soup.h1.string return ''"
            },
            {
                "url": 5984,
                "code": "def fix_title_capitalization(title): if re.search(\"[A-Z]\", title) and re.search(\"[a-z]\", title): return title word_list = re.split(' +', title) final = [word_list[0].capitalize()] for word in word_list[1:]: if word.upper() in COMMON_ACRONYMS: final.append(word.upper()) elif len(word) > 3: final.append(word.capitalize()) else: final.append(word.lower()) return \" \".join(final)"
            },
            {
                "url": 3790,
                "code": "def guess_title(basename): base, _ = os.path.splitext(basename) return re.sub(r'[ _-]+', r' ', base).title()"
            },
            {
                "url": 902,
                "code": "def to_camel_case(snake_case_string): parts = snake_case_string.lstrip('_').split('_') return parts[0] + ''.join([i.title() for i in parts[1:]])"
            },
            {
                "url": 5526,
                "code": "def python(string: str): return underscore(singularize(string) if Naming._pluralize(string) else string)"
            },
            {
                "url": 525,
                "code": "def to_camel_case(text): split = text.split('_') return split[0] + \"\".join(x.title() for x in split[1:])"
            },
            {
                "url": 1625,
                "code": "def to_capitalized_camel_case(snake_case_string): parts = snake_case_string.split('_') return ''.join([i.title() for i in parts])"
            },
            {
                "url": 1592,
                "code": "def title(msg): if sys.platform.startswith(\"win\"): ctypes.windll.kernel32.SetConsoleTitleW(tounicode(msg))"
            },
            {
                "url": 1731,
                "code": "def getFileDialogTitle(msg, title): if msg and title: return \"%s - %s\" % (title, msg) if msg and not title: return str(msg) if title and not msg: return str(title) return None"
            },
            {
                "url": 5614,
                "code": "def _lower(string): if not string: return \"\" new_string = [string[0].lower()] for char in string[1:]: if char.isupper(): new_string.append(\"_\") new_string.append(char.lower()) return \"\".join(new_string)"
            },
            {
                "url": 5981,
                "code": "def capitalize(string): if not string: return string if len(string) == 1: return string.upper() return string[0].upper() + string[1:].lower()"
            },
            {
                "url": 1254,
                "code": "def _make_sentence(txt): #Make sure first letter is capitalized txt = txt.strip(' ') txt = txt[0].upper() + txt[1:] + '.' return txt"
            },
            {
                "url": 3022,
                "code": "def camel_case(self, snake_case): components = snake_case.split('_') return components[0] + \"\".join(x.title() for x in components[1:])"
            }
        ],
        "url": 4355
    },
    {
        "nl_input": "how to randomly select rows in ndarray in python",
        "code_input": [
            {
                "url": 4393,
                "code": "def select_random(engine, table_or_columns, limit=5): s = select(table_or_columns).order_by(func.random()).limit(limit) return engine.execute(s).fetchall()"
            },
            {
                "url": 4830,
                "code": "def RandomShuffle(a, seed): if seed: np.random.seed(seed) r = a.copy() np.random.shuffle(r) return r,"
            },
            {
                "url": 3733,
                "code": "def random_numbers(n): return ''.join(random.SystemRandom().choice(string.digits) for _ in range(n))"
            },
            {
                "url": 1129,
                "code": "def _shuffle(data, idx): shuffle_data = [] for idx_k, idx_v in data: shuffle_data.append((idx_k, mx.ndarray.array(idx_v.asnumpy()[idx], idx_v.context))) return shuffle_data"
            },
            {
                "url": 4669,
                "code": "def new_random_state(seed=None, fully_random=False): if seed is None: if not fully_random: # sample manually a seed instead of just RandomState(), # because the latter one # is way slower. seed = CURRENT_RANDOM_STATE.randint(SEED_MIN_VALUE, SEED_MAX_VALUE, 1)[0] return np.random.RandomState(seed)"
            },
            {
                "url": 1435,
                "code": "def random_choice(sequence): return random.choice(tuple(sequence) if isinstance(sequence, set) else sequence)"
            },
            {
                "url": 2782,
                "code": "def bootstrap_indexes(data, n_samples=10000): for _ in xrange(n_samples): yield randint(data.shape[0], size=(data.shape[0],))"
            },
            {
                "url": 2749,
                "code": "def sp_rand(m,n,a): if m == 0 or n == 0: return spmatrix([], [], [], (m,n)) nnz = min(max(0, int(round(a*m*n))), m*n) nz = matrix(random.sample(range(m*n), nnz), tc='i') return spmatrix(normal(nnz,1), nz%m, matrix([int(ii) for ii in nz/m]), (m,n))"
            },
            {
                "url": 3764,
                "code": "def uniform_noise(points): return np.random.rand(1) * np.random.uniform(points, 1) \\ + random.sample([2, -2], 1)"
            },
            {
                "url": 3765,
                "code": "def SampleSum(dists, n): pmf = MakePmfFromList(RandomSum(dists) for i in xrange(n)) return pmf"
            },
            {
                "url": 2010,
                "code": "def random_letters(n): return ''.join(random.SystemRandom().choice(string.ascii_letters) for _ in range(n))"
            },
            {
                "url": 4270,
                "code": "def generate_random_string(chars=7): return u\"\".join(random.sample(string.ascii_letters * 2 + string.digits, chars))"
            },
            {
                "url": 1400,
                "code": "def runiform(lower, upper, size=None): return np.random.uniform(lower, upper, size)"
            },
            {
                "url": 2328,
                "code": "def get_randomized_guid_sample(self, item_count): dataset = self.get_whitelist() random.shuffle(dataset) return dataset[:item_count]"
            },
            {
                "url": 794,
                "code": "def downsample(array, k): length = array.shape[0] indices = random.sample(xrange(length), k) return array[indices]"
            }
        ],
        "url": 794
    },
    {
        "nl_input": "how to open a file with a path in python",
        "code_input": [
            {
                "url": 1796,
                "code": "def open_file(file, mode): if hasattr(file, \"read\"): return file if hasattr(file, \"open\"): return file.open(mode) return open(file, mode)"
            },
            {
                "url": 244,
                "code": "def read_from_file(file_path, encoding=\"utf-8\"): with codecs.open(file_path, \"r\", encoding) as f: return f.read()"
            },
            {
                "url": 970,
                "code": "def read_string_from_file(path, encoding=\"utf8\"): with codecs.open(path, \"rb\", encoding=encoding) as f: value = f.read() return value"
            },
            {
                "url": 1627,
                "code": "def read(*args): return io.open(os.path.join(HERE, *args), encoding=\"utf-8\").read()"
            },
            {
                "url": 5968,
                "code": "def file_or_stdin() -> Callable: def parse(path): if path is None or path == \"-\": return sys.stdin else: return data_io.smart_open(path) return parse"
            },
            {
                "url": 1799,
                "code": "def read(filename): return codecs.open(os.path.join(__DIR__, filename), 'r').read()"
            },
            {
                "url": 1063,
                "code": "def open_with_encoding(filename, encoding, mode='r'): return io.open(filename, mode=mode, encoding=encoding, newline='')"
            },
            {
                "url": 1051,
                "code": "def get_file_string(filepath): with open(os.path.abspath(filepath)) as f: return f.read()"
            },
            {
                "url": 4691,
                "code": "def write_to_file(file_path, contents, encoding=\"utf-8\"): with codecs.open(file_path, \"w\", encoding) as f: f.write(contents)"
            },
            {
                "url": 605,
                "code": "def file_or_default(path, default, function = None): try: result = file_get_contents(path) if function != None: return function(result) return result except IOError as e: if e.errno == errno.ENOENT: return default raise"
            },
            {
                "url": 2833,
                "code": "def file_read(filename): fobj = open(filename,'r'); source = fobj.read(); fobj.close() return source"
            },
            {
                "url": 1353,
                "code": "def load_yaml_file(file_path: str): with codecs.open(file_path, 'r') as f: return yaml.safe_load(f)"
            },
            {
                "url": 977,
                "code": "def open_json(file_name): with open(file_name, \"r\") as json_data: data = json.load(json_data) return data"
            },
            {
                "url": 1116,
                "code": "def load_file(self, filename): with open(filename, 'r') as sourcefile: self.set_string(sourcefile.read())"
            },
            {
                "url": 3485,
                "code": "def _open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None, *, loop=None, executor=None): if loop is None: loop = asyncio.get_event_loop() cb = partial(sync_open, file, mode=mode, buffering=buffering, encoding=encoding, errors=errors, newline=newline, closefd=closefd, opener=opener) f = yield from loop.run_in_executor(executor, cb) return wrap(f, loop=loop, executor=executor)"
            }
        ],
        "url": 1051
    },
    {
        "nl_input": "python count distance between two vectors",
        "code_input": [
            {
                "url": 2719,
                "code": "def distance(vec1, vec2): if isinstance(vec1, Vector2) \\ and isinstance(vec2, Vector2): dist_vec = vec2 - vec1 return dist_vec.length() else: raise TypeError(\"vec1 and vec2 must be Vector2's\")"
            },
            {
                "url": 466,
                "code": "def vector_distance(a, b): a = np.array(a) b = np.array(b) return np.linalg.norm(a - b)"
            },
            {
                "url": 4554,
                "code": "def _euclidean_dist(vector_a, vector_b): dist = 0 for (x, y) in zip(vector_a, vector_b): dist += (x-y)*(x-y) return math.sqrt(dist)"
            },
            {
                "url": 5458,
                "code": "def path_distance(points): vecs = np.diff(points, axis=0)[:, :3] d2 = [np.dot(p, p) for p in vecs] return np.sum(np.sqrt(d2))"
            },
            {
                "url": 1828,
                "code": "def _manhattan_distance(vec_a, vec_b): if len(vec_a) != len(vec_b): raise ValueError('len(vec_a) must equal len(vec_b)') return sum(map(lambda a, b: abs(a - b), vec_a, vec_b))"
            },
            {
                "url": 2856,
                "code": "def get_distance_matrix(x): square = nd.sum(x ** 2.0, axis=1, keepdims=True) distance_square = square + square.transpose() - (2.0 * nd.dot(x, x.transpose())) return nd.sqrt(distance_square)"
            },
            {
                "url": 206,
                "code": "def get_distance_between_two_points(self, one, two): dx = one.x - two.x dy = one.y - two.y return math.sqrt(dx * dx + dy * dy)"
            },
            {
                "url": 4335,
                "code": "def get_distance(F, x): n = x.shape[0] square = F.sum(x ** 2.0, axis=1, keepdims=True) distance_square = square + square.transpose() - (2.0 * F.dot(x, x.transpose())) # Adding identity to make sqrt work. return F.sqrt(distance_square + F.array(np.identity(n)))"
            },
            {
                "url": 300,
                "code": "def euclidean(x, y): result = 0.0 for i in range(x.shape[0]): result += (x[i] - y[i]) ** 2 return np.sqrt(result)"
            },
            {
                "url": 2702,
                "code": "def dist(x1, x2, axis=0): return np.linalg.norm(x2 - x1, axis=axis)"
            },
            {
                "url": 4066,
                "code": "def _distance(coord1, coord2): xdist = coord1[0] - coord2[0] ydist = coord1[1] - coord2[1] return sqrt(xdist*xdist + ydist*ydist)"
            },
            {
                "url": 1050,
                "code": "def norm_vec(vector): assert len(vector) == 3 v = np.array(vector) return v/np.sqrt(np.sum(v**2))"
            },
            {
                "url": 3298,
                "code": "def manhattan_distance_numpy(object1, object2): return numpy.sum(numpy.absolute(object1 - object2), axis=1).T"
            },
            {
                "url": 708,
                "code": "def levenshtein_distance_metric(a, b): return (levenshtein_distance(a, b) / (2.0 * max(len(a), len(b), 1)))"
            },
            {
                "url": 299,
                "code": "def _tf_squared_euclidean(X, Y): return tf.reduce_sum(tf.pow(tf.subtract(X, Y), 2), axis=1)"
            }
        ],
        "url": 2719
    },
    {
        "nl_input": "python get dimensions of list",
        "code_input": [
            {
                "url": 706,
                "code": "def get_list_dimensions(_list): if isinstance(_list, list) or isinstance(_list, tuple): return [len(_list)] + get_list_dimensions(_list[0]) return []"
            },
            {
                "url": 2080,
                "code": "def get_dimension_array(array): if all(isinstance(el, list) for el in array): result = [len(array), len(max([x for x in array], key=len,))] # elif array and isinstance(array, list): else: result = [len(array), 1] return result"
            },
            {
                "url": 423,
                "code": "def array_dim(arr): dim = [] while True: try: dim.append(len(arr)) arr = arr[0] except TypeError: return dim"
            },
            {
                "url": 1404,
                "code": "def shape(self): if not self.data: return (0, 0) return (len(self.data), len(self.dimensions))"
            },
            {
                "url": 2814,
                "code": "def shape_list(l,shape,dtype): return np.array(l, dtype=dtype).reshape(shape)"
            },
            {
                "url": 2303,
                "code": "def check_type_and_size_of_param_list(param_list, expected_length): try: assert isinstance(param_list, list) assert len(param_list) == expected_length except AssertionError: msg = \"param_list must be a list containing {} elements.\" raise ValueError(msg.format(expected_length)) return None"
            },
            {
                "url": 5810,
                "code": "def _prm_get_longest_stringsize(string_list): maxlength = 1 for stringar in string_list: if isinstance(stringar, np.ndarray): if stringar.ndim > 0: for string in stringar.ravel(): maxlength = max(len(string), maxlength) else: maxlength = max(len(stringar.tolist()), maxlength) else: maxlength = max(len(stringar), maxlength) # Make the string Col longer than needed in order to allow later on slightly larger strings return int(maxlength * 1.5)"
            },
            {
                "url": 3388,
                "code": "def dim_axis_label(dimensions, separator=', '): if not isinstance(dimensions, list): dimensions = [dimensions] return separator.join([d.pprint_label for d in dimensions])"
            },
            {
                "url": 3578,
                "code": "def get_grid_spatial_dimensions(self, variable): data = self.open_dataset(self.service).variables[variable.variable] dimensions = list(data.dimensions) return data.shape[dimensions.index(variable.x_dimension)], data.shape[dimensions.index(variable.y_dimension)]"
            },
            {
                "url": 1326,
                "code": "def get_flat_size(self): return sum( np.prod(v.get_shape().as_list()) for v in self.variables.values())"
            },
            {
                "url": 1251,
                "code": "def get_list_representation(self): if self.is_list: return self.list_or_slice else: return self[list(range(self.num_examples))]"
            },
            {
                "url": 2081,
                "code": "def get_dt_list(fn_list): dt_list = np.array([fn_getdatetime(fn) for fn in fn_list]) return dt_list"
            },
            {
                "url": 5054,
                "code": "def _last_index(x, default_dim): if x.get_shape().ndims is not None: return len(x.get_shape()) - 1 else: return default_dim"
            },
            {
                "url": 4382,
                "code": "def _check_list_len(row, length): if len(row) != length: raise Exception( \"row length does not match expected length of \" + str(length) + \"\\nrow: \" + str(row))"
            },
            {
                "url": 1861,
                "code": "def get_image_dimension(self, url): w_h = (None, None) try: if url.startswith('//'): url = 'http:' + url data = requests.get(url).content im = Image.open(BytesIO(data)) w_h = im.size except Exception: logger.warning(\"Error getting image size {}\".format(url), exc_info=True) return w_h"
            }
        ],
        "url": 2080
    },
    {
        "nl_input": "python filter lowpass minmum cutoff frequency",
        "code_input": [
            {
                "url": 1130,
                "code": "def lowPass(self, *args): return Signal(self._butter(self.samples, 'low', *args), fs=self.fs)"
            },
            {
                "url": 3867,
                "code": "def highpass(cutoff): R = thub(exp(cutoff - pi), 2) return (1 - R) / (1 + R * z ** -1)"
            },
            {
                "url": 1552,
                "code": "def fft_bandpassfilter(data, fs, lowcut, highcut): fft = np.fft.fft(data) # n = len(data) # timestep = 1.0 / fs # freq = np.fft.fftfreq(n, d=timestep) bp = fft.copy() # Zero out fft coefficients # bp[10:-10] = 0 # Normalise # bp *= real(fft.dot(fft))/real(bp.dot(bp)) bp *= fft.dot(fft) / bp.dot(bp) # must multipy by 2 to get the correct amplitude ibp = 12 * np.fft.ifft(bp) return ibp"
            },
            {
                "url": 4552,
                "code": "def local_minima(img, min_distance = 4): r # @TODO: Write a unittest for this. fits = numpy.asarray(img) minfits = minimum_filter(fits, size=min_distance) # default mode is reflect minima_mask = fits == minfits good_indices = numpy.transpose(minima_mask.nonzero()) good_fits = fits[minima_mask] order = good_fits.argsort() return good_indices[order], good_fits[order]"
            },
            {
                "url": 617,
                "code": "def filtered_image(self, im): q = np.fft.fftn(im) for k,v in self.filters: q[k] -= v return np.real(np.fft.ifftn(q))"
            },
            {
                "url": 374,
                "code": "def smooth_gaussian(image, sigma=1): return scipy.ndimage.filters.gaussian_filter(image, sigma=sigma, mode=\"nearest\")"
            },
            {
                "url": 806,
                "code": "def min_values(args): return Interval(min(x.low for x in args), min(x.high for x in args))"
            },
            {
                "url": 4102,
                "code": "def __init__(self, function): super(filter, self).__init__() self.function = function"
            },
            {
                "url": 2198,
                "code": "def clip_image(image, clip_min, clip_max): return np.minimum(np.maximum(clip_min, image), clip_max)"
            },
            {
                "url": 3516,
                "code": "def downsample_with_striding(array, factor): return array[tuple(np.s_[::f] for f in factor)]"
            },
            {
                "url": 5176,
                "code": "def apply(filter): def decorator(callable): return lambda *args, **kwargs: filter(callable(*args, **kwargs)) return decorator"
            },
            {
                "url": 4912,
                "code": "def reduce_freqs(freqlist): allfreqs = np.zeros_like(freqlist[0]) for f in freqlist: allfreqs += f return allfreqs"
            },
            {
                "url": 1878,
                "code": "def conv_block(inputs, filters, dilation_rates_and_kernel_sizes, **kwargs): return conv_block_internal(conv, inputs, filters, dilation_rates_and_kernel_sizes, **kwargs)"
            },
            {
                "url": 794,
                "code": "def downsample(array, k): length = array.shape[0] indices = random.sample(xrange(length), k) return array[indices]"
            },
            {
                "url": 3083,
                "code": "def GaussianBlur(X, ksize_width, ksize_height, sigma_x, sigma_y): return image_transform( X, cv2.GaussianBlur, ksize=(ksize_width, ksize_height), sigmaX=sigma_x, sigmaY=sigma_y )"
            }
        ],
        "url": 1552
    },
    {
        "nl_input": "python 3, seperate a string into a list at comma",
        "code_input": [
            {
                "url": 3278,
                "code": "def comma_delimited_to_list(list_param): if isinstance(list_param, list): return list_param if isinstance(list_param, str): return list_param.split(',') else: return []"
            },
            {
                "url": 5700,
                "code": "def list_to_str(list, separator=','): list = [str(x) for x in list] return separator.join(list)"
            },
            {
                "url": 3842,
                "code": "def _return_comma_list(self, l): if isinstance(l, (text_type, int)): return l if not isinstance(l, list): raise TypeError(l, ' should be a list of integers, \\ not {0}'.format(type(l))) str_ids = ','.join(str(i) for i in l) return str_ids"
            },
            {
                "url": 2880,
                "code": "def string_to_list(string, sep=\",\", filter_empty=False): return [value.strip() for value in string.split(sep) if (not filter_empty or value)]"
            },
            {
                "url": 3417,
                "code": "def list2string (inlist,delimit=' '): stringlist = [makestr(_) for _ in inlist] return string.join(stringlist,delimit)"
            },
            {
                "url": 392,
                "code": "def _split_comma_separated(string): return set(text.strip() for text in string.split(',') if text.strip())"
            },
            {
                "url": 2418,
                "code": "def _str_to_list(s): _list = s.split(\",\") return list(map(lambda i: i.lstrip(), _list))"
            },
            {
                "url": 5723,
                "code": "def _str_to_list(value, separator): value_list = [item.strip() for item in value.split(separator)] value_list_sanitized = builtins.list(filter(None, value_list)) if len(value_list_sanitized) > 0: return value_list_sanitized else: raise ValueError('Invalid list variable.')"
            },
            {
                "url": 77,
                "code": "def list_to_csv(value): if isinstance(value, (list, tuple, set)): value = \",\".join(value) return value"
            },
            {
                "url": 1110,
                "code": "def split_comma_argument(comma_sep_str): terms = [] for term in comma_sep_str.split(','): if term: terms.append(term) return terms"
            },
            {
                "url": 160,
                "code": "def commajoin_as_strings(iterable): return _(u',').join((six.text_type(i) for i in iterable))"
            },
            {
                "url": 1146,
                "code": "def split_strings_in_list_retain_spaces(orig_list): temp_list = list() for line in orig_list: line_split = __re.split(r'(\\s+)', line) temp_list.append(line_split) return temp_list"
            },
            {
                "url": 5698,
                "code": "def multi_split(s, split): # type: (S, Iterable[S]) -> List[S] for r in split: s = s.replace(r, \"|\") return [i for i in s.split(\"|\") if len(i) > 0]"
            },
            {
                "url": 1837,
                "code": "def to_list(var): if var is None: return [] if isinstance(var, str): var = var.split('\\n') elif not isinstance(var, list): try: var = list(var) except TypeError: raise ValueError(\"{} cannot be converted to the list.\".format(var)) return var"
            },
            {
                "url": 404,
                "code": "def linedelimited (inlist,delimiter): outstr = '' for item in inlist: if type(item) != StringType: item = str(item) outstr = outstr + item + delimiter outstr = outstr[0:-1] return outstr"
            }
        ],
        "url": 3278
    },
    {
        "nl_input": "how to delete an element in a python dictionary",
        "code_input": [
            {
                "url": 4062,
                "code": "def __delitem__(self, key): index, value = self._dict.pop(key) key2, value2 = self._list.pop(index) assert key == key2 assert value is value2 self._fix_indices_after_delete(index)"
            },
            {
                "url": 4874,
                "code": "def __delitem__ (self, key): self._keys.remove(key) super(ListDict, self).__delitem__(key)"
            },
            {
                "url": 1015,
                "code": "def rm_keys_from_dict(d, keys): # Loop for each key given for key in keys: # Is the key in the dictionary? if key in d: try: d.pop(key, None) except KeyError: # Not concerned with an error. Keep going. pass return d"
            },
            {
                "url": 1019,
                "code": "def pop(self, index=-1): value = self._list.pop(index) del self._dict[value] return value"
            },
            {
                "url": 3146,
                "code": "def pop (self, key): if key in self._keys: self._keys.remove(key) super(ListDict, self).pop(key)"
            },
            {
                "url": 185,
                "code": "def _remove_dict_keys_with_value(dict_, val): return {k: v for k, v in dict_.items() if v is not val}"
            },
            {
                "url": 5594,
                "code": "def dictlist_wipe_key(dict_list: Iterable[Dict], key: str) -> None: for d in dict_list: d.pop(key, None)"
            },
            {
                "url": 2569,
                "code": "def _delete_keys(dct, keys): c = deepcopy(dct) assert isinstance(keys, list) for k in keys: c.pop(k) return c"
            },
            {
                "url": 2281,
                "code": "def _remove_none_values(dictionary): return list(map(dictionary.pop, [i for i in dictionary if dictionary[i] is None]))"
            },
            {
                "url": 3073,
                "code": "def delete(self, row): i = self._get_key_index(row) del self.keys[i]"
            },
            {
                "url": 5165,
                "code": "def remove_element(self, e): if e.label is not None: self.elementdict.pop(e.label) self.elementlist.remove(e)"
            },
            {
                "url": 4882,
                "code": "def dict_pop_or(d, key, default=None): val = default with suppress(KeyError): val = d.pop(key) return val"
            },
            {
                "url": 1114,
                "code": "def discard(self, element): try: i = int(element) set.discard(self, i) except ValueError: pass"
            },
            {
                "url": 1902,
                "code": "def remove(parent, idx): if isinstance(parent, dict): del parent[idx] elif isinstance(parent, list): del parent[int(idx)] else: raise JSONPathError(\"Invalid path for operation\")"
            },
            {
                "url": 2777,
                "code": "def remove(self, key): item = self.item_finder.pop(key) item[-1] = None self.removed_count += 1"
            }
        ],
        "url": 5594
    },
    {
        "nl_input": "how know if the box was selected in checkbox in python",
        "code_input": [
            {
                "url": 1582,
                "code": "def checkbox_uncheck(self, force_check=False): if self.get_attribute('checked'): self.click(force_click=force_check)"
            },
            {
                "url": 5187,
                "code": "def uncheck(self, locator=None, allow_label_click=None, **kwargs): self._check_with_label( \"checkbox\", False, locator=locator, allow_label_click=allow_label_click, **kwargs)"
            },
            {
                "url": 917,
                "code": "def onchange(self, value): log.debug('combo box. selected %s' % value) self.select_by_value(value) return (value, )"
            },
            {
                "url": 3925,
                "code": "def changed(self, *value): if self._last_checked_value != value: self._last_checked_value = value return True return False"
            },
            {
                "url": 3299,
                "code": "def check_by_selector(self, selector): elem = find_element_by_jquery(world.browser, selector) if not elem.is_selected(): elem.click()"
            },
            {
                "url": 1655,
                "code": "def set_value(self, value): if value: self.setChecked(Qt.Checked) else: self.setChecked(Qt.Unchecked)"
            },
            {
                "url": 943,
                "code": "def set_value(self, value): if value: self.setCheckState(Qt.Checked) else: self.setCheckState(Qt.Unchecked)"
            },
            {
                "url": 3498,
                "code": "def get_python(self): if self.multiselect: return super(MultiSelectField, self).get_python() return self._get()"
            },
            {
                "url": 2160,
                "code": "def get_selected_values(self, selection): return [v for b, v in self._choices if b & selection]"
            },
            {
                "url": 5517,
                "code": "def codebox(msg=\"\", title=\" \", text=\"\"): return tb.textbox(msg, title, text, codebox=1)"
            },
            {
                "url": 279,
                "code": "def _on_select(self, *args): if callable(self.__callback): self.__callback(self.selection)"
            },
            {
                "url": 6080,
                "code": "def was_into_check(self) -> bool: king = self.king(not self.turn) return king is not None and self.is_attacked_by(self.turn, king)"
            },
            {
                "url": 194,
                "code": "def is_element_present(driver, selector, by=By.CSS_SELECTOR): try: driver.find_element(by=by, value=selector) return True except Exception: return False"
            },
            {
                "url": 3042,
                "code": "def is_clicked(self, MouseStateType): return self.previous_mouse_state.query_state(MouseStateType) and ( not self.current_mouse_state.query_state(MouseStateType))"
            },
            {
                "url": 4083,
                "code": "def parse_value(self, value): parsed = super(BoolField, self).parse_value(value) return bool(parsed) if parsed is not None else None"
            }
        ],
        "url": 1655
    },
    {
        "nl_input": "standard scalar function in python",
        "code_input": [
            {
                "url": 2142,
                "code": "async def scalar(self, query, as_tuple=False): query = self._swap_database(query) return (await scalar(query, as_tuple=as_tuple))"
            },
            {
                "url": 4099,
                "code": "def get_scalar_product(self, other): return self.x*other.x+self.y*other.y"
            },
            {
                "url": 1515,
                "code": "def is_scalar(value): return np.isscalar(value) or (isinstance(value, np.ndarray) and (len(np.squeeze(value).shape) == 0))"
            },
            {
                "url": 6078,
                "code": "def filter_float(n: Node, query: str) -> float: return _scalariter2item(n, query, float)"
            },
            {
                "url": 1245,
                "code": "def _validate_type_scalar(self, value): if isinstance( value, _int_types + (_str_type, float, date, datetime, bool) ): return True"
            },
            {
                "url": 4,
                "code": "def _vector_or_scalar(x, type='row'): if isinstance(x, (list, tuple)): x = np.array(x) if isinstance(x, np.ndarray): assert x.ndim == 1 if type == 'column': x = x[:, None] return x"
            },
            {
                "url": 4181,
                "code": "def infer_dtype_from(val, pandas_dtype=False): if is_scalar(val): return infer_dtype_from_scalar(val, pandas_dtype=pandas_dtype) return infer_dtype_from_array(val, pandas_dtype=pandas_dtype)"
            },
            {
                "url": 299,
                "code": "def _tf_squared_euclidean(X, Y): return tf.reduce_sum(tf.pow(tf.subtract(X, Y), 2), axis=1)"
            },
            {
                "url": 5217,
                "code": "def mul(a, b): def multiply(a, b): \"\"\"Multiplication\"\"\" return a * b return op_with_scalar_cast(a, b, multiply)"
            },
            {
                "url": 791,
                "code": "def _norm(self, x): return tf.sqrt(tf.reduce_sum(tf.square(x), keepdims=True, axis=-1) + 1e-7)"
            },
            {
                "url": 5886,
                "code": "def reduce(function, initval=None): if initval is None: return lambda s: __builtin__.reduce(function, s) else: return lambda s: __builtin__.reduce(function, s, initval)"
            },
            {
                "url": 6145,
                "code": "def stdev(self): return round(np.std(self.array), self.precision)\\ if len(self.array) else None"
            },
            {
                "url": 2406,
                "code": "def standard_deviation(numbers): numbers = list(numbers) if not numbers: return 0 mean = sum(numbers) / len(numbers) return (sum((n - mean) ** 2 for n in numbers) / len(numbers)) ** .5"
            },
            {
                "url": 196,
                "code": "def is_callable(*p): import symbols return all(isinstance(x, symbols.FUNCTION) for x in p)"
            },
            {
                "url": 4992,
                "code": "def _hess_two_param(self, funct, p0, p1, dl=2e-5, rts=False, **kwargs): vals0 = self.get_values(p0) vals1 = self.get_values(p1) f00 = funct(**kwargs) self.update(p0, vals0+dl) f10 = funct(**kwargs) self.update(p1, vals1+dl) f11 = funct(**kwargs) self.update(p0, vals0) f01 = funct(**kwargs) if rts: self.update(p0, vals0) self.update(p1, vals1) return (f11 - f10 - f01 + f00) / (dl**2)"
            }
        ],
        "url": 2107
    },
    {
        "nl_input": "python random gaussian distribution noise",
        "code_input": [
            {
                "url": 3764,
                "code": "def uniform_noise(points): return np.random.rand(1) * np.random.uniform(points, 1) \\ + random.sample([2, -2], 1)"
            },
            {
                "url": 639,
                "code": "def add_noise(Y, sigma): return Y + np.random.normal(0, sigma, Y.shape)"
            },
            {
                "url": 3344,
                "code": "def normal_noise(points): return np.random.rand(1) * np.random.randn(points, 1) \\ + random.sample([2, -2], 1)"
            },
            {
                "url": 2753,
                "code": "def get_2D_samples_gauss(n, m, sigma, random_state=None): return make_2D_samples_gauss(n, m, sigma, random_state=None)"
            },
            {
                "url": 5805,
                "code": "def sample_normal(mean, var, rng): ret = numpy.sqrt(var) * rng.randn(*mean.shape) + mean return ret"
            },
            {
                "url": 5842,
                "code": "def _gauss(mean: int, sigma: int) -> int: return int(random.gauss(mean, sigma))"
            },
            {
                "url": 4662,
                "code": "def gaussian_distribution(mean, stdev, num_pts=50): xstart = mean - (4.0 * stdev) xend = mean + (4.0 * stdev) x = np.linspace(xstart,xend,num_pts) y = (1.0/np.sqrt(2.0*np.pi*stdev*stdev)) * np.exp(-1.0 * ((x - mean)**2)/(2.0*stdev*stdev)) return x,y"
            },
            {
                "url": 3676,
                "code": "def gaussian_noise(x, severity=1): c = [.08, .12, 0.18, 0.26, 0.38][severity - 1] x = np.array(x) / 255. x_clip = np.clip(x + np.random.normal(size=x.shape, scale=c), 0, 1) * 255 return around_and_astype(x_clip)"
            },
            {
                "url": 955,
                "code": "def rnormal(mu, tau, size=None): return np.random.normal(mu, 1. / np.sqrt(tau), size)"
            },
            {
                "url": 376,
                "code": "def EvalGaussianPdf(x, mu, sigma): return scipy.stats.norm.pdf(x, mu, sigma)"
            },
            {
                "url": 6200,
                "code": "def kernel(self, spread=1): # TODO: use self.kernel_type to choose function def gaussian(data, pixel): return mvn.pdf(data, mean=pixel, cov=spread) return gaussian"
            },
            {
                "url": 374,
                "code": "def smooth_gaussian(image, sigma=1): return scipy.ndimage.filters.gaussian_filter(image, sigma=sigma, mode=\"nearest\")"
            },
            {
                "url": 1610,
                "code": "def Gaussian(x, mu, sig): return sympy.exp(-(x - mu)**2/(2*sig**2))/sympy.sqrt(2*sympy.pi*sig**2)"
            },
            {
                "url": 268,
                "code": "def gauss_pdf(x, mu, sigma): return 1 / np.sqrt(2 * np.pi) / sigma * np.exp(-(x - mu) ** 2 / 2. / sigma ** 2)"
            },
            {
                "url": 3765,
                "code": "def SampleSum(dists, n): pmf = MakePmfFromList(RandomSum(dists) for i in xrange(n)) return pmf"
            }
        ],
        "url": 551
    },
    {
        "nl_input": "return the number of numeric attributes in python",
        "code_input": [
            {
                "url": 4818,
                "code": "def __len__(self): return len([i for i in (set(dir(self)) - self._STANDARD_ATTRS) if i[0] != '_'])"
            },
            {
                "url": 2828,
                "code": "def get_numbers(s): result = map(int, re.findall(r'[0-9]+', unicode(s))) return result + [1] * (2 - len(result))"
            },
            {
                "url": 2262,
                "code": "def r_num(obj): if isinstance(obj, (list, tuple)): it = iter else: it = LinesIterator dataset = Dataset([Dataset.FLOAT]) return dataset.load(it(obj))"
            },
            {
                "url": 713,
                "code": "def get_size(objects): res = 0 for o in objects: try: res += _getsizeof(o) except AttributeError: print(\"IGNORING: type=%s; o=%s\" % (str(type(o)), str(o))) return res"
            },
            {
                "url": 5755,
                "code": "def numeric_part(s): m = re_numeric_part.match(s) if m: return int(m.group(1)) return None"
            },
            {
                "url": 3424,
                "code": "def is_numeric_dtype(dtype): dtype = np.dtype(dtype) return np.issubsctype(getattr(dtype, 'base', None), np.number)"
            },
            {
                "url": 2252,
                "code": "def get_object_attrs(obj): attrs = [k for k in dir(obj) if not k.startswith('__')] if not attrs: attrs = dir(obj) return attrs"
            },
            {
                "url": 6262,
                "code": "def _is_numeric(self, values): if len(values) > 0: assert isinstance(values[0], (float, int)), \\ \"values must be numbers to perform math operations. Got {}\".format( type(values[0])) return True"
            },
            {
                "url": 727,
                "code": "def get_all_attributes(klass_or_instance): pairs = list() for attr, value in inspect.getmembers( klass_or_instance, lambda x: not inspect.isroutine(x)): if not (attr.startswith(\"__\") or attr.endswith(\"__\")): pairs.append((attr, value)) return pairs"
            },
            {
                "url": 2399,
                "code": "def get_type_len(self): # Check types and set type/len self.get_sql() return self.type, self.len, self.len_decimal"
            },
            {
                "url": 2240,
                "code": "def fields(self): return (self.attributes.values() + self.lists.values() + self.references.values())"
            },
            {
                "url": 3927,
                "code": "def nlevels(self): levels = self.levels() return [len(l) for l in levels] if levels else 0"
            },
            {
                "url": 40,
                "code": "def get_number(s, cast=int): import string d = \"\".join(x for x in str(s) if x in string.digits) return cast(d)"
            },
            {
                "url": 6113,
                "code": "def to_dict(cls): return dict((item.name, item.number) for item in iter(cls))"
            },
            {
                "url": 1299,
                "code": "def _to_numeric(val): if isinstance(val, (int, float, datetime.datetime, datetime.timedelta)): return val return float(val)"
            }
        ],
        "url": 4818
    },
    {
        "nl_input": "python pil camera capture",
        "code_input": [
            {
                "url": 3731,
                "code": "def read(self): stream = BytesIO() self.cam.capture(stream, format='png') # \"Rewind\" the stream to the beginning so we can read its content stream.seek(0) return Image.open(stream)"
            },
            {
                "url": 103,
                "code": "def screen_cv2(self): pil_image = self.screen.convert('RGB') cv2_image = np.array(pil_image) pil_image.close() # Convert RGB to BGR cv2_image = cv2_image[:, :, ::-1] return cv2_image"
            },
            {
                "url": 618,
                "code": "def get_buffer(self, data_np, header, format, output=None): if not have_pil: raise Exception(\"Install PIL to use this method\") image = PILimage.fromarray(data_np) buf = output if buf is None: buf = BytesIO() image.save(buf, format) return buf"
            },
            {
                "url": 832,
                "code": "def compute_capture(args): x, y, w, h, params = args return x, y, mandelbrot_capture(x, y, w, h, params)"
            },
            {
                "url": 2547,
                "code": "def url_to_image(url, flag=cv2.IMREAD_COLOR): resp = urlopen(url) image = np.asarray(bytearray(resp.read()), dtype=\"uint8\") image = cv2.imdecode(image, flag) return image"
            },
            {
                "url": 369,
                "code": "def imdecode(image_path): import os assert os.path.exists(image_path), image_path + ' not found' im = cv2.imread(image_path) return im"
            },
            {
                "url": 3489,
                "code": "def get_capture_dimensions(capture): width = int(capture.get(cv2.CAP_PROP_FRAME_WIDTH)) height = int(capture.get(cv2.CAP_PROP_FRAME_HEIGHT)) return width, height"
            },
            {
                "url": 3209,
                "code": "def display_pil_image(im): from IPython.core import display b = BytesIO() im.save(b, format='png') data = b.getvalue() ip_img = display.Image(data=data, format='png', embed=True) return ip_img._repr_png_()"
            },
            {
                "url": 2018,
                "code": "def resize(self, size): return Image(self.pil_image.resize(size, PIL.Image.ANTIALIAS))"
            },
            {
                "url": 3081,
                "code": "def get_image(self, source): buf = StringIO(source.read()) return Image.open(buf)"
            },
            {
                "url": 1089,
                "code": "def numpy(self): # load GDCM's image reading functionality image_reader = gdcm.ImageReader() image_reader.SetFileName(self.fname) if not image_reader.Read(): raise IOError(\"Could not read DICOM image\") pixel_array = self._gdcm_to_numpy(image_reader.GetImage()) return pixel_array"
            },
            {
                "url": 4906,
                "code": "def _convert(self, image, output=None): with Image.open(image) as im: width, height = im.size co = CanvasObjects() co.add(CanvasImg(image, 1.0, w=width, h=height)) return WatermarkDraw(co, tempdir=self.tempdir, pagesize=(width, height)).write(output)"
            },
            {
                "url": 4663,
                "code": "def new(self, size, fill): return Image(PIL.Image.new(\"RGB\", size, fill))"
            },
            {
                "url": 4784,
                "code": "def get_img_data(f, maxsize = (1200, 850), first = False): img = Image.open(f) img.thumbnail(maxsize) if first: # tkinter is inactive the first time bio = io.BytesIO() img.save(bio, format = \"PNG\") del img return bio.getvalue() return ImageTk.PhotoImage(img)"
            },
            {
                "url": 5328,
                "code": "def open_as_pillow(filename): with __sys_open(filename, 'rb') as f: data = BytesIO(f.read()) return Image.open(data)"
            }
        ],
        "url": 3731
    },
    {
        "nl_input": "python flask create cookie expiration",
        "code_input": [
            {
                "url": 2657,
                "code": "def save_config_value(request, response, key, value): request.session[key] = value response.set_cookie(key, value, expires=one_year_from_now()) return response"
            },
            {
                "url": 3378,
                "code": "def _save_cookies(requests_cookiejar, filename): with open(filename, 'wb') as handle: pickle.dump(requests_cookiejar, handle)"
            },
            {
                "url": 5970,
                "code": "def cookies(self) -> Dict[str, str]: cookies = SimpleCookie() cookies.load(self.headers.get('Cookie', '')) return {key: cookie.value for key, cookie in cookies.items()}"
            },
            {
                "url": 1031,
                "code": "def save_session_to_file(self, sessionfile): pickle.dump(requests.utils.dict_from_cookiejar(self._session.cookies), sessionfile)"
            },
            {
                "url": 3111,
                "code": "def parse_cookies(self, req, name, field): return core.get_value(req.COOKIES, name, field)"
            },
            {
                "url": 42,
                "code": "def parse_cookies_str(cookies): cookie_dict = {} for record in cookies.split(\";\"): key, value = record.strip().split(\"=\", 1) cookie_dict[key] = value return cookie_dict"
            },
            {
                "url": 1809,
                "code": "def logout(cache): cache.set(flask.session['auth0_key'], None) flask.session.clear() return True"
            },
            {
                "url": 989,
                "code": "def expireat(self, key, when): expire_time = datetime.fromtimestamp(when) key = self._encode(key) if key in self.redis: self.timeouts[key] = expire_time return True return False"
            },
            {
                "url": 3809,
                "code": "def _get_data(self): cookie = self.adapter.cookies.get(self.name) return self._deserialize(cookie) if cookie else {}"
            },
            {
                "url": 1585,
                "code": "def __set_token_expired(self, value): self._token_expired = datetime.datetime.now() + datetime.timedelta(seconds=value) return"
            },
            {
                "url": 2944,
                "code": "def get_csrf_token(response): cookie_headers = [ h.decode('ascii') for h in response.headers.getlist(\"Set-Cookie\") ] if not cookie_headers: return None csrf_headers = [ h for h in cookie_headers if h.startswith(\"csrftoken=\") ] if not csrf_headers: return None match = re.match(\"csrftoken=([^ ;]+);\", csrf_headers[-1]) return match.group(1)"
            },
            {
                "url": 2346,
                "code": "def _session_set(self, key, value): self.session[self._session_key(key)] = value"
            },
            {
                "url": 6096,
                "code": "def copy_session(session: requests.Session) -> requests.Session: new = requests.Session() new.cookies = requests.utils.cookiejar_from_dict(requests.utils.dict_from_cookiejar(session.cookies)) new.headers = session.headers.copy() return new"
            },
            {
                "url": 6228,
                "code": "def session_expired(self): if not self._login_time or (datetime.datetime.now()-self._login_time).total_seconds() > 12000: return True"
            },
            {
                "url": 6100,
                "code": "def access_token(self): access_token = self.session.get(self.access_token_key) if access_token: if not self.expires_at: # user provided access_token, just return it return access_token timestamp = time.time() if self.expires_at - timestamp > 60: return access_token self.fetch_access_token() return self.session.get(self.access_token_key)"
            }
        ],
        "url": 1809
    },
    {
        "nl_input": "python sqlalchemy model *",
        "code_input": [
            {
                "url": 5417,
                "code": "def get_sql(query): sql = str(query.statement.compile(dialect=sqlite.dialect(), compile_kwargs={\"literal_binds\": True})) return sql"
            },
            {
                "url": 4328,
                "code": "def compile(expr, params=None): from ibis.sql.alchemy import to_sqlalchemy return to_sqlalchemy(expr, dialect.make_context(params=params))"
            },
            {
                "url": 315,
                "code": "def sqlmany(self, stringname, *args): if hasattr(self, 'alchemist'): return getattr(self.alchemist.many, stringname)(*args) s = self.strings[stringname] return self.connection.cursor().executemany(s, args)"
            },
            {
                "url": 4800,
                "code": "def sql(self, sql: str, *qmark_params, **named_params): statement = SingleSqlStatement(sql) return self.statement(statement).execute(*qmark_params, **named_params)"
            },
            {
                "url": 5937,
                "code": "def execute_sql(self, query): c = self.con.cursor() c.execute(query) result = [] if c.rowcount > 0: try: result = c.fetchall() except psycopg2.ProgrammingError: pass return result"
            },
            {
                "url": 5121,
                "code": "def _make_sql_params(self,kw): return ['%s=?' %k for k in kw.keys() ] for k,v in kw.iteritems(): vals.append('%s=?' %k) return vals"
            },
            {
                "url": 3549,
                "code": "def create_db(app, appbuilder): from flask_appbuilder.models.sqla import Base _appbuilder = import_application(app, appbuilder) engine = _appbuilder.get_session.get_bind(mapper=None, clause=None) Base.metadata.create_all(engine) click.echo(click.style(\"DB objects created\", fg=\"green\"))"
            },
            {
                "url": 5565,
                "code": "async def executemany(self, sql: str, parameters: Iterable[Iterable[Any]]) -> None: await self._execute(self._cursor.executemany, sql, parameters)"
            },
            {
                "url": 4786,
                "code": "def run_migration(connection, queries, engine): # Execute query with connection.cursor() as cursorMig: # Parse statements queries = parse_statements(queries, engine) for query in queries: cursorMig.execute(query) connection.commit() return True"
            },
            {
                "url": 3853,
                "code": "def callproc(self, name, params, param_types=None): if param_types: placeholders = [self.sql_writer.typecast(self.sql_writer.to_placeholder(), t) for t in param_types] else: placeholders = [self.sql_writer.to_placeholder() for p in params] # TODO: This may be Postgres specific... qs = \"select * from {0}({1});\".format(name, \", \".join(placeholders)) return self.execute(qs, params), params"
            },
            {
                "url": 5382,
                "code": "def psql(sql, show=True): out = postgres('psql -c \"%s\"' % sql) if show: print_command(sql) return out"
            },
            {
                "url": 1052,
                "code": "def _get_sql(filename): with open(os.path.join(SQL_DIR, filename), 'r') as f: return f.read()"
            },
            {
                "url": 2247,
                "code": "def execute(self, sql, params=None): # wrap in a transaction to ensure things are committed # https://github.com/smnorris/pgdata/issues/3 with self.engine.begin() as conn: result = conn.execute(sql, params) return result"
            },
            {
                "url": 5954,
                "code": "def execute(cur, *args): stmt = args[0] if len(args) > 1: stmt = stmt.replace('%', '%%').replace('?', '%r') print(stmt % (args[1])) return cur.execute(*args)"
            },
            {
                "url": 5944,
                "code": "def get_now_sql_datetime(): ## > IMPORTS ## from datetime import datetime, date, time now = datetime.now() now = now.strftime(\"%Y-%m-%dT%H:%M:%S\") return now"
            }
        ],
        "url": 3229
    },
    {
        "nl_input": "python how to move to next command in for loop",
        "code_input": [
            {
                "url": 36,
                "code": "def do_next(self, args): self._do_print_from_last_cmd = True self._interp.step_over() return True"
            },
            {
                "url": 3109,
                "code": "def __call__(self, _): if self.iter % self.step == 0: print(self.fmt.format(self.iter), **self.kwargs) self.iter += 1"
            },
            {
                "url": 3113,
                "code": "def __call__(self, _): if self.iter % self.step == 0: self.pbar.update(self.step) self.iter += 1"
            },
            {
                "url": 4999,
                "code": "def next(self): _LOGGER.debug(\"reading next\") if self.closed: _LOGGER.debug(\"stream is closed\") raise StopIteration() line = self.readline() if not line: _LOGGER.debug(\"nothing more to read\") raise StopIteration() return line"
            },
            {
                "url": 2755,
                "code": "def next(self): # I'm pretty sure this is the completely wrong way to go about this, but # oh well, this works. if not hasattr(self, '_iter'): self._iter = self.readrow_as_dict() return self._iter.next()"
            },
            {
                "url": 1973,
                "code": "def iterate(obj): global next, Iteration next = next Iteration = Iteration total = len(obj) if isinstance(obj, Sized) else None iterator = iter(obj) first = True last = False i = 0 try: value = next(iterator) except StopIteration: return while True: try: next_value = next(iterator) except StopIteration: last = True yield Iteration(first, last, i, total, value) if last: return value = next_value i += 1 first = False"
            },
            {
                "url": 5561,
                "code": "def __next__(self): self.current += 1 if self.current > self.total: raise StopIteration else: return self.iterable[self.current - 1]"
            },
            {
                "url": 1137,
                "code": "def skip(self, n): try: self._iter_object.skip(n) except AttributeError: for i in range(0, n): self.next()"
            },
            {
                "url": 3706,
                "code": "def accel_next(self, *args): if self.get_notebook().get_current_page() + 1 == self.get_notebook().get_n_pages(): self.get_notebook().set_current_page(0) else: self.get_notebook().next_page() return True"
            },
            {
                "url": 2388,
                "code": "def step_next_line(self): self._eol.append(self.position) self._lineno += 1 self._col_offset = 0"
            },
            {
                "url": 1590,
                "code": "def __next__(self): # Retrieve the row, thereby incrementing the line number: row = super(UnicodeReaderWithLineNumber, self).__next__() return self.lineno + 1, row"
            },
            {
                "url": 34,
                "code": "def advance_one_line(self): current_line = self._current_token.line_number while current_line == self._current_token.line_number: self._current_token = ConfigParser.Token(*next(self._token_generator))"
            },
            {
                "url": 579,
                "code": "def next (self): # File-like object. result = self.readline() if result == self._empty_buffer: raise StopIteration return result"
            },
            {
                "url": 3215,
                "code": "def _skip_frame(self): size = self.read_size() for i in range(size+1): line = self._f.readline() if len(line) == 0: raise StopIteration"
            },
            {
                "url": 2953,
                "code": "def _get_history_next(self): if self._has_history: ret = self._input_history.return_history(1) self.string = ret self._curs_pos = len(ret)"
            }
        ],
        "url": 36
    },
    {
        "nl_input": "python check if object is a char",
        "code_input": [
            {
                "url": 3423,
                "code": "def is_list_of_ipachars(obj): if isinstance(obj, list): for e in obj: if not isinstance(e, IPAChar): return False return True return False"
            },
            {
                "url": 1789,
                "code": "def is_string(obj): if PYTHON3: str_type = (bytes, str) else: str_type = (bytes, str, unicode) return isinstance(obj, str_type)"
            },
            {
                "url": 1121,
                "code": "def check_str(obj): if isinstance(obj, str): return obj if isinstance(obj, float): return str(int(obj)) else: return str(obj)"
            },
            {
                "url": 5589,
                "code": "def is_unicode(string): str_type = str(type(string)) if str_type.find('str') > 0 or str_type.find('unicode') > 0: return True return False"
            },
            {
                "url": 2141,
                "code": "def isstring(value): classes = (str, bytes) if pyutils.PY3 else basestring # noqa: F821 return isinstance(value, classes)"
            },
            {
                "url": 530,
                "code": "def _isstring(dtype): return dtype.type == numpy.unicode_ or dtype.type == numpy.string_"
            },
            {
                "url": 2087,
                "code": "def is_text(obj, name=None): try: # python2 ans = isinstance(obj, basestring) except NameError: # python3 ans = isinstance(obj, str) if name: print(\"is_text: (%s) %s = %s\" % (ans, name, obj.__class__), file=sys.stderr) return ans"
            },
            {
                "url": 590,
                "code": "def isString(s): try: return isinstance(s, unicode) or isinstance(s, basestring) except NameError: return isinstance(s, str)"
            },
            {
                "url": 4846,
                "code": "def ishex(obj): return isinstance(obj, str) and (len(obj) == 1) and (obj in string.hexdigits)"
            },
            {
                "url": 243,
                "code": "def is_string(val): try: basestring except NameError: return isinstance(val, str) return isinstance(val, basestring)"
            },
            {
                "url": 3356,
                "code": "def is_number(obj): return isinstance(obj, (int, float, np.int_, np.float_))"
            },
            {
                "url": 753,
                "code": "def is_seq(obj): if not hasattr(obj, '__iter__'): return False if isinstance(obj, basestring): return False return True"
            },
            {
                "url": 657,
                "code": "def is_iter_non_string(obj): if isinstance(obj, list) or isinstance(obj, tuple): return True return False"
            },
            {
                "url": 2128,
                "code": "def is_integer(obj): if PYTHON3: return isinstance(obj, int) return isinstance(obj, (int, long))"
            },
            {
                "url": 1640,
                "code": "def is_iterable_but_not_string(obj): return hasattr(obj, '__iter__') and not isinstance(obj, str) and not isinstance(obj, bytes)"
            }
        ],
        "url": 1789
    },
    {
        "nl_input": "how to achieve logarithmic complexity in python",
        "code_input": [
            {
                "url": 3142,
                "code": "def logx_linear(x, a, b): x = np.log(x) return a*x + b"
            },
            {
                "url": 2478,
                "code": "def glog(x,l = 2): return np.log((x+np.sqrt(x**2+l**2))/2)/np.log(l)"
            },
            {
                "url": 4787,
                "code": "def LogBinomialCoef(n, k): return n * log(n) - k * log(k) - (n - k) * log(n - k)"
            },
            {
                "url": 3656,
                "code": "def log(x): if isinstance(x, UncertainFunction): mcpts = np.log(x._mcpts) return UncertainFunction(mcpts) else: return np.log(x)"
            },
            {
                "url": 703,
                "code": "def interpolate_logscale_single(start, end, coefficient): return np.exp(np.log(start) + (np.log(end) - np.log(start)) * coefficient)"
            },
            {
                "url": 741,
                "code": "def lognorm(x, mu, sigma=1.0): return stats.lognorm(sigma, scale=mu).pdf(x)"
            },
            {
                "url": 3681,
                "code": "def _get_log_prior_cl_func(self): return SimpleCLFunction.from_string(''' mot_float_type _computeLogPrior(local const mot_float_type* x, void* data){ return ''' + self._log_prior_func.get_cl_function_name() + '''(x, data); } ''', dependencies=[self._log_prior_func])"
            },
            {
                "url": 1060,
                "code": "def round_to_n(x, n): return round(x, -int(np.floor(np.log10(x))) + (n - 1))"
            },
            {
                "url": 1336,
                "code": "def ln_norm(x, mu, sigma=1.0): return np.log(stats.norm(loc=mu, scale=sigma).pdf(x))"
            },
            {
                "url": 5207,
                "code": "def cric__lasso(): model = sklearn.linear_model.LogisticRegression(penalty=\"l1\", C=0.002) # we want to explain the raw probability outputs of the trees model.predict = lambda X: model.predict_proba(X)[:,1] return model"
            },
            {
                "url": 108,
                "code": "def estimate_complexity(self, x,y,z,n): num_calculations = x * y * z * n run_time = num_calculations / 100000 # a 2014 PC does about 100k calcs in a second (guess based on prior logs) return self.show_time_as_short_string(run_time)"
            },
            {
                "url": 3902,
                "code": "def plfit_lsq(x,y): n = len(x) btop = n * (log(x)*log(y)).sum() - (log(x)).sum()*(log(y)).sum() bbottom = n*(log(x)**2).sum() - (log(x).sum())**2 b = btop / bbottom a = ( log(y).sum() - b * log(x).sum() ) / n A = exp(a) return A,b"
            },
            {
                "url": 2561,
                "code": "def log_magnitude_spectrum(frames): return N.log(N.abs(N.fft.rfft(frames)).clip(1e-5, N.inf))"
            },
            {
                "url": 3675,
                "code": "def __add__(self, other): return chaospy.poly.collection.arithmetics.add(self, other)"
            },
            {
                "url": 551,
                "code": "def rlognormal(mu, tau, size=None): return np.random.lognormal(mu, np.sqrt(1. / tau), size)"
            }
        ],
        "url": 1366
    },
    {
        "nl_input": "python listbox scrollbar not tk",
        "code_input": [
            {
                "url": 5123,
                "code": "def _grid_widgets(self): scrollbar_column = 0 if self.__compound is tk.LEFT else 2 self.listbox.grid(row=0, column=1, sticky=\"nswe\") self.scrollbar.grid(row=0, column=scrollbar_column, sticky=\"ns\")"
            },
            {
                "url": 2585,
                "code": "def __init__(self, master=None, compound=tk.RIGHT, autohidescrollbar=True, **kwargs): ttk.Frame.__init__(self, master) self.columnconfigure(1, weight=1) self.rowconfigure(0, weight=1) self.listbox = tk.Listbox(self, **kwargs) if autohidescrollbar: self.scrollbar = AutoHideScrollbar(self, orient=tk.VERTICAL, command=self.listbox.yview) else: self.scrollbar = ttk.Scrollbar(self, orient=tk.VERTICAL, command=self.listbox.yview) self.config_listbox(yscrollcommand=self.scrollbar.set) if compound is not tk.LEFT and compound is not tk.RIGHT: raise ValueError(\"Invalid compound value passed: {0}\".format(compound)) self.__compound = compound self._grid_widgets()"
            },
            {
                "url": 3619,
                "code": "def __grid_widgets(self): scrollbar_column = 0 if self.__compound is tk.LEFT else 2 self._canvas.grid(row=0, column=1, sticky=\"nswe\") self._scrollbar.grid(row=0, column=scrollbar_column, sticky=\"ns\")"
            },
            {
                "url": 4010,
                "code": "def set_scrollbars_cb(self, w, tf): scrollbars = 'on' if tf else 'off' self.t_.set(scrollbars=scrollbars)"
            },
            {
                "url": 5517,
                "code": "def codebox(msg=\"\", title=\" \", text=\"\"): return tb.textbox(msg, title, text, codebox=1)"
            },
            {
                "url": 999,
                "code": "def alert(text='', title='', button=OK_TEXT, root=None, timeout=None): assert TKINTER_IMPORT_SUCCEEDED, 'Tkinter is required for pymsgbox' return _buttonbox(msg=text, title=title, choices=[str(button)], root=root, timeout=timeout)"
            },
            {
                "url": 840,
                "code": "def restore_scrollbar_position(self): scrollbar_pos = self.get_option('scrollbar_position', None) if scrollbar_pos is not None: self.explorer.treewidget.set_scrollbar_position(scrollbar_pos)"
            },
            {
                "url": 2648,
                "code": "def set_scrollregion(self, event=None): self.canvas.configure(scrollregion=self.canvas.bbox('all'))"
            },
            {
                "url": 484,
                "code": "def _top(self): # Goto top of the list self.top.body.focus_position = 2 if self.compact is False else 0 self.top.keypress(self.size, \"\")"
            },
            {
                "url": 4395,
                "code": "def create_widget(self): d = self.declaration button_type = UIButton.UIButtonTypeSystem if d.flat else UIButton.UIButtonTypeRoundedRect self.widget = UIButton(buttonWithType=button_type)"
            },
            {
                "url": 5346,
                "code": "def register_plugin(self): self.main.restore_scrollbar_position.connect( self.restore_scrollbar_position) self.main.add_dockwidget(self)"
            },
            {
                "url": 892,
                "code": "def list_formatter(handler, item, value): return u', '.join(str(v) for v in value)"
            },
            {
                "url": 2751,
                "code": "def build_gui(self, container): vbox = Widgets.VBox() vbox.set_border_width(0) w = Viewers.GingaViewerWidget(viewer=self) vbox.add_widget(w, stretch=1) # need to put this in an hbox with an expanding label or the # browser wants to resize the canvas, distorting it hbox = Widgets.HBox() hbox.add_widget(vbox, stretch=0) hbox.add_widget(Widgets.Label(''), stretch=1) container.set_widget(hbox)"
            },
            {
                "url": 4703,
                "code": "def startEdit( self ): self._originalText = self.text() self.scrollWidget().hide() self.setFocus() self.selectAll()"
            },
            {
                "url": 1541,
                "code": "def register_view(self, view): super(ListViewController, self).register_view(view) self.tree_view.connect('button_press_event', self.mouse_click)"
            }
        ],
        "url": 2585
    },
    {
        "nl_input": "identify the most common number in an array python",
        "code_input": [
            {
                "url": 809,
                "code": "def most_common(items): counts = {} for i in items: counts.setdefault(i, 0) counts[i] += 1 return max(six.iteritems(counts), key=operator.itemgetter(1))"
            },
            {
                "url": 2004,
                "code": "def _most_common(iterable): data = Counter(iterable) return max(data, key=data.__getitem__)"
            },
            {
                "url": 812,
                "code": "def mostCommonItem(lst): # This elegant solution from: http://stackoverflow.com/a/1518632/1760218 lst = [l for l in lst if l] if lst: return max(set(lst), key=lst.count) else: return None"
            },
            {
                "url": 5631,
                "code": "def most_frequent(lst): lst = lst[:] highest_freq = 0 most_freq = None for val in unique(lst): if lst.count(val) > highest_freq: most_freq = val highest_freq = lst.count(val) return most_freq"
            },
            {
                "url": 302,
                "code": "def _gcd_array(X): greatest_common_divisor = 0.0 for x in X: greatest_common_divisor = _gcd(greatest_common_divisor, x) return greatest_common_divisor"
            },
            {
                "url": 5604,
                "code": "def most_significant_bit(lst: np.ndarray) -> int: return np.argwhere(np.asarray(lst) == 1)[0][0]"
            },
            {
                "url": 5037,
                "code": "def index_nearest(array, value): idx = (np.abs(array-value)).argmin() return idx"
            },
            {
                "url": 267,
                "code": "def _findNearest(arr, value): arr = np.array(arr) # find nearest value in array idx = (abs(arr-value)).argmin() return arr[idx]"
            },
            {
                "url": 4593,
                "code": "def most_even(number, group): count, rest = divmod(number, group) counts = zip_longest([count] * group, [1] * rest, fillvalue=0) chunks = [sum(one) for one in counts] logging.debug('chunks: %s', chunks) return chunks"
            },
            {
                "url": 560,
                "code": "def find_nearest_index(arr, value): arr = np.array(arr) index = (abs(arr-value)).argmin() return index"
            },
            {
                "url": 522,
                "code": "def compare(dicts): common_members = {} common_keys = reduce(lambda x, y: x & y, map(dict.keys, dicts)) for k in common_keys: common_members[k] = list( reduce(lambda x, y: x & y, [set(d[k]) for d in dicts])) return common_members"
            },
            {
                "url": 2677,
                "code": "def best(self): b = (-1e999999, None) for k, c in iteritems(self.counts): b = max(b, (c, k)) return b[1]"
            },
            {
                "url": 4027,
                "code": "def get_common_elements(list1, list2): #result = [] #for item in list1: # if item in list2: # result.append(item) #Return list(set(list1).intersection(set(list2))) set2 = set(list2) result = [item for item in list1 if item in set2] return result"
            },
            {
                "url": 5232,
                "code": "def find_commons(lists): others = lists[1:] return [ val for val in lists[0] if is_in_all(val, others) ]"
            },
            {
                "url": 5816,
                "code": "def gcd_float(numbers, tol=1e-8): def pair_gcd_tol(a, b): \"\"\"Calculate the Greatest Common Divisor of a and b. Unless b==0, the result will have the same sign as b (so that when b is divided by it, the result comes out positive). \"\"\" while b > tol: a, b = b, a % b return a n = numbers[0] for i in numbers: n = pair_gcd_tol(n, i) return n"
            }
        ],
        "url": 5604
    },
    {
        "nl_input": "pull multiple values to make table python",
        "code_input": [
            {
                "url": 1420,
                "code": "def _format_list(result): if not result: return result if isinstance(result[0], dict): return _format_list_objects(result) table = Table(['value']) for item in result: table.add_row([iter_to_table(item)]) return table"
            },
            {
                "url": 77,
                "code": "def list_to_csv(value): if isinstance(value, (list, tuple, set)): value = \",\".join(value) return value"
            },
            {
                "url": 892,
                "code": "def list_formatter(handler, item, value): return u', '.join(str(v) for v in value)"
            },
            {
                "url": 2078,
                "code": "def values(self): values = [] for __, data in self.items(): values.append(data) return values"
            },
            {
                "url": 4239,
                "code": "def iterlists(self): for key, values in dict.iteritems(self): yield key, list(values)"
            },
            {
                "url": 2587,
                "code": "def join(mapping, bind, values): return [' '.join([six.text_type(v) for v in values if v is not None])]"
            },
            {
                "url": 4764,
                "code": "def list(self,table, **kparams): result = self.table_api_get(table, **kparams) return self.to_records(result, table)"
            },
            {
                "url": 2742,
                "code": "def csvtolist(inputstr): reader = csv.reader([inputstr], skipinitialspace=True) output = [] for r in reader: output += r return output"
            },
            {
                "url": 4706,
                "code": "def save_list(key, *values): return json.dumps({key: [_get_json(value) for value in values]})"
            },
            {
                "url": 2686,
                "code": "def to_list(self): return [[int(self.table.cell_values[0][1]), int(self.table.cell_values[0][2])], [int(self.table.cell_values[1][1]), int(self.table.cell_values[1][2])]]"
            },
            {
                "url": 5650,
                "code": "def genfirstvalues(cursor: Cursor, arraysize: int = 1000) \\ -> Generator[Any, None, None]: return (row[0] for row in genrows(cursor, arraysize))"
            },
            {
                "url": 3292,
                "code": "def print_table(*args, **kwargs): t = format_table(*args, **kwargs) click.echo(t)"
            },
            {
                "url": 3007,
                "code": "def prettifysql(sql): pretty = [] for line in sql.split('\\n'): pretty.extend([\"%s,\\n\" % x for x in line.split(',')]) return pretty"
            },
            {
                "url": 1146,
                "code": "def split_strings_in_list_retain_spaces(orig_list): temp_list = list() for line in orig_list: line_split = __re.split(r'(\\s+)', line) temp_list.append(line_split) return temp_list"
            },
            {
                "url": 3850,
                "code": "def _split(value): if isinstance(value, str): # iterable, but not meant for splitting return value, value try: invalue, outvalue = value except TypeError: invalue = outvalue = value except ValueError: raise ValueError(\"Only single values and pairs are allowed\") return invalue, outvalue"
            }
        ],
        "url": 3949
    },
    {
        "nl_input": "python adjust data to normal distribution",
        "code_input": [
            {
                "url": 1594,
                "code": "def normalize(data): data = data.astype(float) data -= data.mean() return data / data.std()"
            },
            {
                "url": 4155,
                "code": "def normalize(data): out_data = data.copy() for i, sample in enumerate(out_data): out_data[i] /= sum(out_data[i]) return out_data"
            },
            {
                "url": 2533,
                "code": "def normalize(df, style = 'mean'): if style == 'mean': df_mean,df_std = df.mean(),df.std() return (df-df_mean)/df_std elif style == 'minmax': col_min,col_max = df.min(),df.max() return (df-col_min)/(col_max-col_min) else: return style(df)"
            },
            {
                "url": 638,
                "code": "def norm(x, mu, sigma=1.0): return stats.norm(loc=mu, scale=sigma).pdf(x)"
            },
            {
                "url": 1399,
                "code": "def log_normalize(data): if sp.issparse(data): data = data.copy() data.data = np.log2(data.data + 1) return data return np.log2(data.astype(np.float64) + 1)"
            },
            {
                "url": 5805,
                "code": "def sample_normal(mean, var, rng): ret = numpy.sqrt(var) * rng.randn(*mean.shape) + mean return ret"
            },
            {
                "url": 1397,
                "code": "def _normalize(image): offset = tf.constant(MEAN_RGB, shape=[1, 1, 3]) image -= offset scale = tf.constant(STDDEV_RGB, shape=[1, 1, 3]) image /= scale return image"
            },
            {
                "url": 1336,
                "code": "def ln_norm(x, mu, sigma=1.0): return np.log(stats.norm(loc=mu, scale=sigma).pdf(x))"
            },
            {
                "url": 2532,
                "code": "def normalize(self): if self.preprocessed_data.empty: data = self.original_data else: data = self.preprocessed_data data = pd.DataFrame(preprocessing.normalize(data), columns=data.columns, index=data.index) self.preprocessed_data = data"
            },
            {
                "url": 741,
                "code": "def lognorm(x, mu, sigma=1.0): return stats.lognorm(sigma, scale=mu).pdf(x)"
            },
            {
                "url": 5632,
                "code": "def normalize(numbers): total = float(sum(numbers)) return [n / total for n in numbers]"
            },
            {
                "url": 1057,
                "code": "def plot_dist_normal(s, mu, sigma): import matplotlib.pyplot as plt count, bins, ignored = plt.hist(s, 30, normed=True) plt.plot(bins, 1/(sigma * np.sqrt(2 * np.pi)) \\ * np.exp( - (bins - mu)**2 / (2 * sigma**2) ), \\ linewidth = 2, color = 'r') plt.show()"
            },
            {
                "url": 3344,
                "code": "def normal_noise(points): return np.random.rand(1) * np.random.randn(points, 1) \\ + random.sample([2, -2], 1)"
            },
            {
                "url": 4338,
                "code": "def normalize_array(lst): np_arr = np.array(lst) x_normalized = np_arr / np_arr.max(axis=0) return list(x_normalized)"
            },
            {
                "url": 4234,
                "code": "def fit_gaussian(samples, ddof=0): if len(samples.shape) == 1: return np.mean(samples), np.std(samples, ddof=ddof) return np.mean(samples, axis=1), np.std(samples, axis=1, ddof=ddof)"
            }
        ],
        "url": 4155
    },
    {
        "nl_input": "python check if float has no floating points",
        "code_input": [
            {
                "url": 772,
                "code": "def is_float(value): return isinstance(value, float) or isinstance(value, int) or isinstance(value, np.float64), float(value)"
            },
            {
                "url": 2009,
                "code": "def clean_float(v): if v is None or not str(v).strip(): return None return float(str(v).replace(',', ''))"
            },
            {
                "url": 2305,
                "code": "def is_float_array(val): return is_np_array(val) and issubclass(val.dtype.type, np.floating)"
            },
            {
                "url": 2678,
                "code": "def test_value(self, value): if not isinstance(value, float): raise ValueError('expected float value: ' + str(type(value)))"
            },
            {
                "url": 483,
                "code": "def _convert_to_float_if_possible(s): try: ret = float(s) except (ValueError, TypeError): ret = s return ret"
            },
            {
                "url": 655,
                "code": "def is_float_array(l): r if isinstance(l, np.ndarray): if l.dtype.kind == 'f': return True return False"
            },
            {
                "url": 2999,
                "code": "def set_float(val): out = None if not val in (None, ''): try: out = float(val) except ValueError: return None if numpy.isnan(out): out = default return out"
            },
            {
                "url": 3579,
                "code": "def _force_float(v): try: return float(v) except Exception as exc: return float('nan') logger.warning('Failed to convert {} to float with {} error. Using 0 instead.'.format(v, exc))"
            },
            {
                "url": 4962,
                "code": "def parse_float(float_str): factor = __get_factor(float_str) if factor != 1: float_str = float_str[:-1] try: return float(float_str.replace(',', '')) * factor except ValueError: return None"
            },
            {
                "url": 4148,
                "code": "def ensure_dtype_float(x, default=np.float64): r if isinstance(x, np.ndarray): if x.dtype.kind == 'f': return x elif x.dtype.kind == 'i': return x.astype(default) else: raise TypeError('x is of type '+str(x.dtype)+' that cannot be converted to float') else: raise TypeError('x is not an array')"
            },
            {
                "url": 4693,
                "code": "def is_floating(self): return ( self.is_numpy_compatible and np.issubdtype(self.as_numpy_dtype, np.floating) ) or self.base_dtype == bfloat16"
            },
            {
                "url": 1791,
                "code": "def is_int(string): try: a = float(string) b = int(a) except ValueError: return False else: return a == b"
            },
            {
                "url": 2120,
                "code": "def _tofloat(obj): if \"inf\" in obj.lower().strip(): return obj try: return int(obj) except ValueError: try: return float(obj) except ValueError: return obj"
            },
            {
                "url": 2085,
                "code": "def _float_almost_equal(float1, float2, places=7): if round(abs(float2 - float1), places) == 0: return True return False"
            },
            {
                "url": 1201,
                "code": "def format_float(value): # not used string = \"{:g}\".format(value).replace(\"e+\", \"e\") string = re.sub(\"e(-?)0*(\\d+)\", r\"e\\1\\2\", string) return string"
            }
        ],
        "url": 5686
    },
    {
        "nl_input": "string remove the last blank python",
        "code_input": [
            {
                "url": 5725,
                "code": "def remove_blank_lines(string): return \"\\n\".join(line for line in string.split(\"\\n\") if len(line.strip()))"
            },
            {
                "url": 2422,
                "code": "def text_remove_empty_lines(text): lines = [ line.rstrip() for line in text.splitlines() if line.strip() ] return \"\\n\".join(lines)"
            },
            {
                "url": 1006,
                "code": "def _remove_blank(l): ret = [] for i, _ in enumerate(l): if l[i] == 0: break ret.append(l[i]) return ret"
            },
            {
                "url": 5108,
                "code": "def fix_line_breaks(s): l = s.splitlines() x = [i.strip() for i in l] x = [i for i in x if i] # remove blank lines return \"\\n\".join(x)"
            },
            {
                "url": 2581,
                "code": "def clean(s): lines = [l.rstrip() for l in s.split('\\n')] return '\\n'.join(lines)"
            },
            {
                "url": 6168,
                "code": "def remove_blank_spaces(syllables: List[str]) -> List[str]: cleaned = [] for syl in syllables: if syl == \" \" or syl == '': pass else: cleaned.append(syl) return cleaned"
            },
            {
                "url": 3891,
                "code": "def _trim(self, somestr): tmp = RE_LSPACES.sub(\"\", somestr) tmp = RE_TSPACES.sub(\"\", tmp) return str(tmp)"
            },
            {
                "url": 3180,
                "code": "def text_cleanup(data, key, last_type): if key in data and last_type == STRING_TYPE: data[key] = data[key].strip() return data"
            },
            {
                "url": 3342,
                "code": "def de_blank(val): ret = list(val) if type(val) == list: for idx, item in enumerate(val): if item.strip() == '': ret.remove(item) else: ret[idx] = item.strip() return ret"
            },
            {
                "url": 366,
                "code": "def strip_spaces(s): return u\" \".join([c for c in s.split(u' ') if c])"
            },
            {
                "url": 2577,
                "code": "def clean_whitespace(statement): import re # Replace linebreaks and tabs with spaces statement.text = statement.text.replace('\\n', ' ').replace('\\r', ' ').replace('\\t', ' ') # Remove any leeding or trailing whitespace statement.text = statement.text.strip() # Remove consecutive spaces statement.text = re.sub(' +', ' ', statement.text) return statement"
            },
            {
                "url": 1696,
                "code": "def remove_trailing_string(content, trailing): if content.endswith(trailing) and content != trailing: return content[:-len(trailing)] return content"
            },
            {
                "url": 2421,
                "code": "def _repr_strip(mystring): r = repr(mystring) if r.startswith(\"'\") and r.endswith(\"'\"): return r[1:-1] else: return r"
            },
            {
                "url": 2039,
                "code": "def get_line_ending(line): non_whitespace_index = len(line.rstrip()) - len(line) if not non_whitespace_index: return '' else: return line[non_whitespace_index:]"
            },
            {
                "url": 1805,
                "code": "def cleanLines(source, lineSep=os.linesep): stripped = (line.strip(lineSep) for line in source) return (line for line in stripped if len(line) != 0)"
            }
        ],
        "url": 5725
    },
    {
        "nl_input": "python how to display object attributes",
        "code_input": [
            {
                "url": 5837,
                "code": "def format_repr(obj, attributes) -> str: attribute_repr = ', '.join(('{}={}'.format(attr, repr(getattr(obj, attr))) for attr in attributes)) return \"{0}({1})\".format(obj.__class__.__qualname__, attribute_repr)"
            },
            {
                "url": 1533,
                "code": "def _repr(obj): vals = \", \".join(\"{}={!r}\".format( name, getattr(obj, name)) for name in obj._attribs) if vals: t = \"{}(name={}, {})\".format(obj.__class__.__name__, obj.name, vals) else: t = \"{}(name={})\".format(obj.__class__.__name__, obj.name) return t"
            },
            {
                "url": 4526,
                "code": "def get_object_as_string(obj): if isinstance(obj, str): return obj if isinstance(obj, list): return '\\r\\n\\;'.join([get_object_as_string(item) for item in obj]) attrs = vars(obj) as_string = ', '.join(\"%s: %s\" % item for item in attrs.items()) return as_string"
            },
            {
                "url": 2252,
                "code": "def get_object_attrs(obj): attrs = [k for k in dir(obj) if not k.startswith('__')] if not attrs: attrs = dir(obj) return attrs"
            },
            {
                "url": 72,
                "code": "def _attrprint(d, delimiter=', '): return delimiter.join(('\"%s\"=\"%s\"' % item) for item in sorted(d.items()))"
            },
            {
                "url": 2202,
                "code": "def get_dict_for_attrs(obj, attrs): data = {} for attr in attrs: data[attr] = getattr(obj, attr) return data"
            },
            {
                "url": 3978,
                "code": "def safe_repr(obj): name = getattr(obj, '__name__', getattr(obj.__class__, '__name__')) if name == 'ndict': name = 'dict' return name or repr(obj)"
            },
            {
                "url": 3157,
                "code": "def object_type_repr(obj): if obj is None: return 'None' elif obj is Ellipsis: return 'Ellipsis' if obj.__class__.__module__ == '__builtin__': name = obj.__class__.__name__ else: name = obj.__class__.__module__ + '.' + obj.__class__.__name__ return '%s object' % name"
            },
            {
                "url": 1942,
                "code": "def _get_pretty_string(obj): sio = StringIO() pprint.pprint(obj, stream=sio) return sio.getvalue()"
            },
            {
                "url": 926,
                "code": "def pretty(obj, verbose=False, max_width=79, newline='\\n'): stream = StringIO() printer = RepresentationPrinter(stream, verbose, max_width, newline) printer.pretty(obj) printer.flush() return stream.getvalue()"
            },
            {
                "url": 4429,
                "code": "def __repr__(self): return str(self.__class__) + '(' + ', '.join([list.__repr__(d) for d in self.data]) + ')'"
            },
            {
                "url": 1849,
                "code": "def object_as_dict(obj): return {c.key: getattr(obj, c.key) for c in inspect(obj).mapper.column_attrs}"
            },
            {
                "url": 189,
                "code": "def dict_to_html_attrs(dict_): res = ' '.join('%s=\"%s\"' % (k, v) for k, v in dict_.items()) return res"
            },
            {
                "url": 5740,
                "code": "def _short_repr(obj): stringified = pprint.saferepr(obj) if len(stringified) > 200: return '%s... (%d bytes)' % (stringified[:200], len(stringified)) return stringified"
            },
            {
                "url": 4237,
                "code": "def _tostr(self,obj): if not obj: return '' if isinstance(obj, list): return ', '.join(map(self._tostr, obj)) return str(obj)"
            }
        ],
        "url": 1533
    },
    {
        "nl_input": "determine if a list of numbers contains duplicates python",
        "code_input": [
            {
                "url": 5743,
                "code": "def find_duplicates(l: list) -> set: return set([x for x in l if l.count(x) > 1])"
            },
            {
                "url": 6032,
                "code": "def duplicates(coll): return list(set(x for x in coll if coll.count(x) > 1))"
            },
            {
                "url": 5619,
                "code": "def _duplicates(list_): item_indices = {} for i, item in enumerate(list_): try: item_indices[item].append(i) except KeyError: # First time seen item_indices[item] = [i] return item_indices"
            },
            {
                "url": 278,
                "code": "def remove_duplicates(lst): dset = set() return [l for l in lst if l not in dset and not dset.add(l)]"
            },
            {
                "url": 5709,
                "code": "def de_duplicate(items): result = [] for item in items: if item not in result: result.append(item) return result"
            },
            {
                "url": 5930,
                "code": "def _check_samples_nodups(fnames): counts = defaultdict(int) for f in fnames: for s in get_samples(f): counts[s] += 1 duplicates = [s for s, c in counts.items() if c > 1] if duplicates: raise ValueError(\"Duplicate samples found in inputs %s: %s\" % (duplicates, fnames))"
            },
            {
                "url": 1441,
                "code": "def remove_dups(seq): seen = set() seen_add = seen.add return [x for x in seq if not (x in seen or seen_add(x))]"
            },
            {
                "url": 5524,
                "code": "def remove_duplicates(seq): seen = set() seen_add = seen.add return [x for x in seq if not (x in seen or seen_add(x))]"
            },
            {
                "url": 1903,
                "code": "def unique(list): unique = []; [unique.append(x) for x in list if x not in unique] return unique"
            },
            {
                "url": 1450,
                "code": "def dedupe_list(seq): seen = set() return [x for x in seq if not (x in seen or seen.add(x))]"
            },
            {
                "url": 452,
                "code": "def dedup_list(l): dedup = set() return [ x for x in l if not (x in dedup or dedup.add(x))]"
            },
            {
                "url": 394,
                "code": "def delete_duplicates(seq): seen = set() seen_add = seen.add return [x for x in seq if not (x in seen or seen_add(x))]"
            },
            {
                "url": 6224,
                "code": "def uniqued(iterable): seen = set() add = seen.add return [i for i in iterable if i not in seen and not add(i)]"
            },
            {
                "url": 901,
                "code": "def _remove_duplicates(objects): seen, uniq = set(), [] for obj in objects: obj_id = id(obj) if obj_id in seen: continue seen.add(obj_id) uniq.append(obj) return uniq"
            },
            {
                "url": 3655,
                "code": "def deduplicate(list_object): new = [] for item in list_object: if item not in new: new.append(item) return new"
            }
        ],
        "url": 5743
    },
    {
        "nl_input": "python figure add title label size",
        "code_input": [
            {
                "url": 2820,
                "code": "def ylabelsize(self, size, index=1): self.layout['yaxis' + str(index)]['titlefont']['size'] = size return self"
            },
            {
                "url": 1009,
                "code": "def figsize(x=8, y=7., aspect=1.): # update rcparams with adjusted figsize params mpl.rcParams.update({'figure.figsize': (x*aspect, y)})"
            },
            {
                "url": 5291,
                "code": "def _enter_plotting(self, fontsize=9): # interactive_status = matplotlib.is_interactive() self.original_fontsize = pyplot.rcParams['font.size'] pyplot.rcParams['font.size'] = fontsize pyplot.hold(False) # opens a figure window, if non exists pyplot.ioff()"
            },
            {
                "url": 4900,
                "code": "def label_saves(name): plt.legend(loc=0) plt.ylim([0, 1.025]) plt.xlabel('$U/D$', fontsize=20) plt.ylabel('$Z$', fontsize=20) plt.savefig(name, dpi=300, format='png', transparent=False, bbox_inches='tight', pad_inches=0.05)"
            },
            {
                "url": 2425,
                "code": "def set_title(self, title, **kwargs): ax = self.get_axes() ax.set_title(title, **kwargs)"
            },
            {
                "url": 1352,
                "code": "def add_plot(x, y, xl, yl, fig, ax, LATEX=False, linestyle=None, **kwargs): if LATEX: xl_data = xl[1] # NOQA yl_data = yl[1] else: xl_data = xl[0] # NOQA yl_data = yl[0] for idx in range(len(y)): ax.plot(x, y[idx], label=yl_data[idx], linestyle=linestyle) ax.legend(loc='upper right') ax.set_ylim(auto=True)"
            },
            {
                "url": 1067,
                "code": "def add_text(text, x=0.01, y=0.01, axes=\"gca\", draw=True, **kwargs): if axes==\"gca\": axes = _pylab.gca() axes.text(x, y, text, transform=axes.transAxes, **kwargs) if draw: _pylab.draw()"
            },
            {
                "url": 3849,
                "code": "def show(self, title=''): self.render(title=title) if self.fig: plt.show(self.fig)"
            },
            {
                "url": 976,
                "code": "def set_font_size(self, size): if self.font.font_size == size: pass else: self.font._set_size(size)"
            },
            {
                "url": 4547,
                "code": "def create_movie(fig, update_figure, filename, title, fps=15, dpi=100): FFMpegWriter = manimation.writers['ffmpeg'] metadata = dict(title=title) writer = FFMpegWriter(fps=fps, metadata=metadata) with writer.saving(fig, filename, dpi): t = 0 while True: if update_figure(t): writer.grab_frame() t += 1 else: break"
            },
            {
                "url": 1999,
                "code": "def OnUpdateFigurePanel(self, event): if self.updating: return self.updating = True self.figure_panel.update(self.get_figure(self.code)) self.updating = False"
            },
            {
                "url": 1311,
                "code": "def finish_plot(): plt.legend() plt.grid(color='0.7') plt.xlabel('x') plt.ylabel('y') plt.show()"
            },
            {
                "url": 2601,
                "code": "def add_text_to_image(fname, txt, opFilename): ft = ImageFont.load(\"T://user//dev//src//python//_AS_LIB//timR24.pil\") #wh = ft.getsize(txt) print(\"Adding text \", txt, \" to \", fname, \" pixels wide to file \" , opFilename) im = Image.open(fname) draw = ImageDraw.Draw(im) draw.text((0, 0), txt, fill=(0, 0, 0), font=ft) del draw im.save(opFilename)"
            },
            {
                "url": 786,
                "code": "def raise_figure_window(f=0): if _fun.is_a_number(f): f = _pylab.figure(f) f.canvas.manager.window.raise_()"
            },
            {
                "url": 5697,
                "code": "def impose_legend_limit(limit=30, axes=\"gca\", **kwargs): if axes==\"gca\": axes = _pylab.gca() # make these axes current _pylab.axes(axes) # loop over all the lines_pylab. for n in range(0,len(axes.lines)): if n > limit-1 and not n==len(axes.lines)-1: axes.lines[n].set_label(\"_nolegend_\") if n == limit-1 and not n==len(axes.lines)-1: axes.lines[n].set_label(\"...\") _pylab.legend(**kwargs)"
            }
        ],
        "url": 4900
    },
    {
        "nl_input": "python networkx longest path directed acyclic graph",
        "code_input": [
            {
                "url": 5910,
                "code": "def dag_longest_path(graph, source, target): if source == target: return [source] allpaths = nx.all_simple_paths(graph, source, target) longest_path = [] for l in allpaths: if len(l) > len(longest_path): longest_path = l return longest_path"
            },
            {
                "url": 6033,
                "code": "def _dfs_cycle_detect(graph, node, path, visited_nodes): visited_nodes.add(node) for target in graph[node]: if target in path: # cycle found => return current path return path + [target] else: return _dfs_cycle_detect(graph, target, path + [target], visited_nodes) return None"
            },
            {
                "url": 4616,
                "code": "def to_networkx(graph): # import here so networkx is not always required. import networkx as nx nodes = graph[\"nodes\"].keys() edges = [[start, end] for start, ends in graph[\"links\"].items() for end in ends] g = nx.Graph() g.add_nodes_from(nodes) nx.set_node_attributes(g, dict(graph[\"nodes\"]), \"membership\") g.add_edges_from(edges) return g"
            },
            {
                "url": 1756,
                "code": "def draw(graph, fname): ag = networkx.nx_agraph.to_agraph(graph) ag.draw(fname, prog='dot')"
            },
            {
                "url": 3939,
                "code": "def dfs_recursive(graph, node, seen): seen[node] = True for neighbor in graph[node]: if not seen[neighbor]: dfs_recursive(graph, neighbor, seen)"
            },
            {
                "url": 1481,
                "code": "def shallow_reverse(g): new_g = networkx.DiGraph() new_g.add_nodes_from(g.nodes()) for src, dst, data in g.edges(data=True): new_g.add_edge(dst, src, **data) return new_g"
            },
            {
                "url": 2403,
                "code": "def _create_complete_graph(node_ids): g = nx.Graph() g.add_nodes_from(node_ids) for (i, j) in combinations(node_ids, 2): g.add_edge(i, j) return g"
            },
            {
                "url": 4856,
                "code": "def is_cyclic(graph): path = set() def visit(vertex): path.add(vertex) for neighbour in graph.get(vertex, ()): if neighbour in path or visit(neighbour): return True path.remove(vertex) return False return any(visit(v) for v in graph)"
            },
            {
                "url": 5336,
                "code": "def draw_graph(G: nx.DiGraph, filename: str): A = to_agraph(G) A.graph_attr[\"rankdir\"] = \"LR\" A.draw(filename, prog=\"dot\")"
            },
            {
                "url": 4332,
                "code": "def info(docgraph): print networkx.info(docgraph), '\\n' node_statistics(docgraph) print edge_statistics(docgraph)"
            },
            {
                "url": 4175,
                "code": "def predecessors(self, node, graph=None): if graph is None: graph = self.graph return [key for key in graph if node in graph[key]]"
            },
            {
                "url": 2911,
                "code": "def depgraph_to_dotsrc(dep_graph, show_cycles, nodot, reverse): if show_cycles: dotsrc = cycles2dot(dep_graph, reverse=reverse) elif not nodot: dotsrc = dep2dot(dep_graph, reverse=reverse) else: dotsrc = None return dotsrc"
            },
            {
                "url": 5458,
                "code": "def path_distance(points): vecs = np.diff(points, axis=0)[:, :3] d2 = [np.dot(p, p) for p in vecs] return np.sum(np.sqrt(d2))"
            },
            {
                "url": 4571,
                "code": "def find_largest_contig(contig_lengths_dict): # Initialise the dictionary longest_contig_dict = dict() for file_name, contig_lengths in contig_lengths_dict.items(): # As the list is sorted in descending order, the largest contig is the first entry in the list longest_contig_dict[file_name] = contig_lengths[0] return longest_contig_dict"
            },
            {
                "url": 5335,
                "code": "def connect(self, A, B, distance=1): self.connect1(A, B, distance) if not self.directed: self.connect1(B, A, distance)"
            }
        ],
        "url": 5910
    },
    {
        "nl_input": "how to take list as input in python seperated with spaces",
        "code_input": [
            {
                "url": 1146,
                "code": "def split_strings_in_list_retain_spaces(orig_list): temp_list = list() for line in orig_list: line_split = __re.split(r'(\\s+)', line) temp_list.append(line_split) return temp_list"
            },
            {
                "url": 5700,
                "code": "def list_to_str(list, separator=','): list = [str(x) for x in list] return separator.join(list)"
            },
            {
                "url": 5723,
                "code": "def _str_to_list(value, separator): value_list = [item.strip() for item in value.split(separator)] value_list_sanitized = builtins.list(filter(None, value_list)) if len(value_list_sanitized) > 0: return value_list_sanitized else: raise ValueError('Invalid list variable.')"
            },
            {
                "url": 3278,
                "code": "def comma_delimited_to_list(list_param): if isinstance(list_param, list): return list_param if isinstance(list_param, str): return list_param.split(',') else: return []"
            },
            {
                "url": 3417,
                "code": "def list2string (inlist,delimit=' '): stringlist = [makestr(_) for _ in inlist] return string.join(stringlist,delimit)"
            },
            {
                "url": 2418,
                "code": "def _str_to_list(s): _list = s.split(\",\") return list(map(lambda i: i.lstrip(), _list))"
            },
            {
                "url": 2880,
                "code": "def string_to_list(string, sep=\",\", filter_empty=False): return [value.strip() for value in string.split(sep) if (not filter_empty or value)]"
            },
            {
                "url": 6146,
                "code": "def space_list(line: str) -> List[int]: spaces = [] for idx, car in enumerate(list(line)): if car == \" \": spaces.append(idx) return spaces"
            },
            {
                "url": 5571,
                "code": "def split(text: str) -> List[str]: return [word for word in SEPARATOR.split(text) if word.strip(' \\t')]"
            },
            {
                "url": 5698,
                "code": "def multi_split(s, split): # type: (S, Iterable[S]) -> List[S] for r in split: s = s.replace(r, \"|\") return [i for i in s.split(\"|\") if len(i) > 0]"
            },
            {
                "url": 3842,
                "code": "def _return_comma_list(self, l): if isinstance(l, (text_type, int)): return l if not isinstance(l, list): raise TypeError(l, ' should be a list of integers, \\ not {0}'.format(type(l))) str_ids = ','.join(str(i) for i in l) return str_ids"
            },
            {
                "url": 160,
                "code": "def commajoin_as_strings(iterable): return _(u',').join((six.text_type(i) for i in iterable))"
            },
            {
                "url": 2423,
                "code": "def strip_spaces(value, sep=None, join=True): value = value.strip() value = [v.strip() for v in value.split(sep)] join_sep = sep or ' ' return join_sep.join(value) if join else value"
            },
            {
                "url": 392,
                "code": "def _split_comma_separated(string): return set(text.strip() for text in string.split(',') if text.strip())"
            },
            {
                "url": 404,
                "code": "def linedelimited (inlist,delimiter): outstr = '' for item in inlist: if type(item) != StringType: item = str(item) outstr = outstr + item + delimiter outstr = outstr[0:-1] return outstr"
            }
        ],
        "url": 5110
    },
    {
        "nl_input": "is a list in python an array",
        "code_input": [
            {
                "url": 1782,
                "code": "def is_list_of_list(item): if ( type(item) in (list, tuple) and len(item) and isinstance(item[0], (list, tuple)) ): return True return False"
            },
            {
                "url": 5549,
                "code": "def listify(a): if a is None: return [] elif not isinstance(a, (tuple, list, np.ndarray)): return [a] return list(a)"
            },
            {
                "url": 6037,
                "code": "def ensure_list(iterable: Iterable[A]) -> List[A]: if isinstance(iterable, list): return iterable else: return list(iterable)"
            },
            {
                "url": 755,
                "code": "def is_listish(obj): if isinstance(obj, (list, tuple, set)): return True return is_sequence(obj)"
            },
            {
                "url": 2976,
                "code": "def is_iterable(value): return isinstance(value, np.ndarray) or isinstance(value, list) or isinstance(value, tuple), value"
            },
            {
                "url": 2126,
                "code": "def all_strings(arr): if not isinstance([], list): raise TypeError(\"non-list value found where list is expected\") return all(isinstance(x, str) for x in arr)"
            },
            {
                "url": 2303,
                "code": "def check_type_and_size_of_param_list(param_list, expected_length): try: assert isinstance(param_list, list) assert len(param_list) == expected_length except AssertionError: msg = \"param_list must be a list containing {} elements.\" raise ValueError(msg.format(expected_length)) return None"
            },
            {
                "url": 192,
                "code": "def _check_elements_equal(lst): assert isinstance(lst, list), \"Input value must be a list.\" return not lst or lst.count(lst[0]) == len(lst)"
            },
            {
                "url": 3423,
                "code": "def is_list_of_ipachars(obj): if isinstance(obj, list): for e in obj: if not isinstance(e, IPAChar): return False return True return False"
            },
            {
                "url": 94,
                "code": "def listlike(obj): return hasattr(obj, \"__iter__\") \\ and not issubclass(type(obj), str)\\ and not issubclass(type(obj), unicode)"
            },
            {
                "url": 2332,
                "code": "def validate_string_list(lst): if not isinstance(lst, list): raise ValueError('input %r must be a list' % lst) for x in lst: if not isinstance(x, basestring): raise ValueError('element %r in list must be a string' % x)"
            },
            {
                "url": 5293,
                "code": "def list_of(cls): return lambda l: isinstance(l, list) and all(isinstance(x, cls) for x in l)"
            },
            {
                "url": 2925,
                "code": "def _fill_array_from_list(the_list, the_array): for i, val in enumerate(the_list): the_array[i] = val return the_array"
            },
            {
                "url": 655,
                "code": "def is_float_array(l): r if isinstance(l, np.ndarray): if l.dtype.kind == 'f': return True return False"
            },
            {
                "url": 1837,
                "code": "def to_list(var): if var is None: return [] if isinstance(var, str): var = var.split('\\n') elif not isinstance(var, list): try: var = list(var) except TypeError: raise ValueError(\"{} cannot be converted to the list.\".format(var)) return var"
            }
        ],
        "url": 2686
    },
    {
        "nl_input": "python cosine similarity of two vectors",
        "code_input": [
            {
                "url": 2961,
                "code": "def _cosine(a, b): return 1. * len(a & b) / (math.sqrt(len(a)) * math.sqrt(len(b)))"
            },
            {
                "url": 4142,
                "code": "def distance_matrix(trains1, trains2, cos, tau): return dissimilarity_matrix(trains1, trains2, cos, tau, \"distance\")"
            },
            {
                "url": 2602,
                "code": "def similarity_transformation(rot, mat): return np.dot(rot, np.dot(mat, np.linalg.inv(rot)))"
            },
            {
                "url": 5226,
                "code": "def __similarity(s1, s2, ngrams_fn, n=3): ngrams1, ngrams2 = set(ngrams_fn(s1, n=n)), set(ngrams_fn(s2, n=n)) matches = ngrams1.intersection(ngrams2) return 2 * len(matches) / (len(ngrams1) + len(ngrams2))"
            },
            {
                "url": 466,
                "code": "def vector_distance(a, b): a = np.array(a) b = np.array(b) return np.linalg.norm(a - b)"
            },
            {
                "url": 101,
                "code": "def similarity(self, other): if self.magnitude == 0 or other.magnitude == 0: return 0 return self.dot(other) / self.magnitude"
            },
            {
                "url": 5964,
                "code": "def similarity(word1: str, word2: str) -> float: return _MODEL.similarity(word1, word2)"
            },
            {
                "url": 4554,
                "code": "def _euclidean_dist(vector_a, vector_b): dist = 0 for (x, y) in zip(vector_a, vector_b): dist += (x-y)*(x-y) return math.sqrt(dist)"
            },
            {
                "url": 4937,
                "code": "def _jit_pairwise_distances(pos1, pos2): n1 = pos1.shape[0] n2 = pos2.shape[0] D = np.empty((n1, n2)) for i in range(n1): for j in range(n2): D[i, j] = np.sqrt(((pos1[i] - pos2[j])**2).sum()) return D"
            },
            {
                "url": 1563,
                "code": "def vec_angle(a, b): cosang = np.dot(a, b) sinang = fast_norm(np.cross(a, b)) return np.arctan2(sinang, cosang)"
            },
            {
                "url": 2856,
                "code": "def get_distance_matrix(x): square = nd.sum(x ** 2.0, axis=1, keepdims=True) distance_square = square + square.transpose() - (2.0 * nd.dot(x, x.transpose())) return nd.sqrt(distance_square)"
            },
            {
                "url": 5800,
                "code": "def tanimoto_set_similarity(x: Iterable[X], y: Iterable[X]) -> float: a, b = set(x), set(y) union = a | b if not union: return 0.0 return len(a & b) / len(union)"
            },
            {
                "url": 5379,
                "code": "def _calculate_similarity(c): ma = {} for idc in c: set1 = _get_seqs(c[idc]) [ma.update({(idc, idc2): _common(set1, _get_seqs(c[idc2]), idc, idc2)}) for idc2 in c if idc != idc2 and (idc2, idc) not in ma] # logger.debug(\"_calculate_similarity_ %s\" % ma) return ma"
            },
            {
                "url": 2719,
                "code": "def distance(vec1, vec2): if isinstance(vec1, Vector2) \\ and isinstance(vec2, Vector2): dist_vec = vec2 - vec1 return dist_vec.length() else: raise TypeError(\"vec1 and vec2 must be Vector2's\")"
            },
            {
                "url": 300,
                "code": "def euclidean(x, y): result = 0.0 for i in range(x.shape[0]): result += (x[i] - y[i]) ** 2 return np.sqrt(result)"
            }
        ],
        "url": 4513
    },
    {
        "nl_input": "how to model a sphere python",
        "code_input": [
            {
                "url": 5849,
                "code": "def arcball_map_to_sphere(point, center, radius): v0 = (point[0] - center[0]) / radius v1 = (center[1] - point[1]) / radius n = v0*v0 + v1*v1 if n > 1.0: # position outside of sphere n = math.sqrt(n) return numpy.array([v0/n, v1/n, 0.0]) else: return numpy.array([v0, v1, math.sqrt(1.0 - n)])"
            },
            {
                "url": 1008,
                "code": "def Fsphere(q, R): return 4 * np.pi / q ** 3 * (np.sin(q * R) - q * R * np.cos(q * R))"
            },
            {
                "url": 5504,
                "code": "def surface(self, zdata, **kwargs): self._configure_3d() surf = scene.SurfacePlot(z=zdata, **kwargs) self.view.add(surf) self.view.camera.set_range() return surf"
            },
            {
                "url": 2951,
                "code": "def circles_pycairo(width, height, color): cairo_color = color / rgb(255, 255, 255) surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, width, height) ctx = cairo.Context(surface) # draw a circle in the center ctx.new_path() ctx.set_source_rgb(cairo_color.red, cairo_color.green, cairo_color.blue) ctx.arc(width / 2, height / 2, width / 2, 0, 2 * pi) ctx.fill() surface.write_to_png('circles.png')"
            },
            {
                "url": 912,
                "code": "def cart2pol(x, y): theta = np.arctan2(y, x) rho = np.hypot(x, y) return theta, rho"
            },
            {
                "url": 17,
                "code": "def transform_to_3d(points,normal,z=0): d = np.cross(normal, (0, 0, 1)) M = rotation_matrix(d) transformed_points = M.dot(points.T).T + z return transformed_points"
            },
            {
                "url": 1016,
                "code": "def create_ellipse(width,height,angle): angle = angle / 180.0 * np.pi thetas = np.linspace(0,2*np.pi,200) a = width / 2.0 b = height / 2.0 x = a*np.cos(thetas)*np.cos(angle) - b*np.sin(thetas)*np.sin(angle) y = a*np.cos(thetas)*np.sin(angle) + b*np.sin(thetas)*np.cos(angle) z = np.zeros(thetas.shape) return np.vstack((x,y,z)).T"
            },
            {
                "url": 2748,
                "code": "def create_rot2d(angle): ca = math.cos(angle) sa = math.sin(angle) return np.array([[ca, -sa], [sa, ca]])"
            },
            {
                "url": 3995,
                "code": "def angle_to_cartesian(lon, lat): theta = np.array(np.pi / 2. - lat) return np.vstack((np.sin(theta) * np.cos(lon), np.sin(theta) * np.sin(lon), np.cos(theta))).T"
            },
            {
                "url": 4272,
                "code": "def _generate_plane(normal, origin): plane = vtk.vtkPlane() plane.SetNormal(normal[0], normal[1], normal[2]) plane.SetOrigin(origin[0], origin[1], origin[2]) return plane"
            },
            {
                "url": 1735,
                "code": "def bounding_box_from(points, i, i1, thr): pi = points[i] pi1 = points[i1] min_lat = min(pi.lat, pi1.lat) min_lon = min(pi.lon, pi1.lon) max_lat = max(pi.lat, pi1.lat) max_lon = max(pi.lon, pi1.lon) return min_lat-thr, min_lon-thr, max_lat+thr, max_lon+thr"
            },
            {
                "url": 347,
                "code": "def from_points(cls, list_of_lists): result = [] for l in list_of_lists: curve = [] for point in l: curve.append((point.lon, point.lat)) result.append(curve) return Polygon(result)"
            },
            {
                "url": 2960,
                "code": "def unproject(self, xy): (x, y) = xy lng = x/EARTH_RADIUS * RAD_TO_DEG lat = 2 * atan(exp(y/EARTH_RADIUS)) - pi/2 * RAD_TO_DEG return (lng, lat)"
            },
            {
                "url": 3887,
                "code": "def xyz2lonlat(x, y, z): lon = xu.rad2deg(xu.arctan2(y, x)) lat = xu.rad2deg(xu.arctan2(z, xu.sqrt(x**2 + y**2))) return lon, lat"
            },
            {
                "url": 3693,
                "code": "def plot3d_init(fignum): from mpl_toolkits.mplot3d import Axes3D fig = plt.figure(fignum) ax = fig.add_subplot(111, projection='3d') return ax"
            }
        ],
        "url": 1008
    },
    {
        "nl_input": "how to check paths in python",
        "code_input": [
            {
                "url": 214,
                "code": "def _is_path(s): if isinstance(s, string_types): try: return op.exists(s) except (OSError, ValueError): return False else: return False"
            },
            {
                "url": 1156,
                "code": "def _python_rpath(self): # Windows virtualenv installation installs pip to the [Ss]cripts # folder. Here's a simple check to support: if sys.platform == 'win32': return os.path.join('Scripts', 'python.exe') return os.path.join('bin', 'python')"
            },
            {
                "url": 239,
                "code": "def _pip_exists(self): return os.path.isfile(os.path.join(self.path, 'bin', 'pip'))"
            },
            {
                "url": 2077,
                "code": "def executable_exists(executable): for directory in os.getenv(\"PATH\").split(\":\"): if os.path.exists(os.path.join(directory, executable)): return True return False"
            },
            {
                "url": 2939,
                "code": "def is_executable(path): return os.path.isfile(path) and os.access(path, os.X_OK)"
            },
            {
                "url": 6187,
                "code": "def check_python_version(): # Required due to multiple with statements on one line req_version = (2, 7) cur_version = sys.version_info if cur_version >= req_version: print(\"Python version... %sOK%s (found %s, requires %s)\" % (Bcolors.OKGREEN, Bcolors.ENDC, str(platform.python_version()), str(req_version[0]) + \".\" + str(req_version[1]))) else: print(\"Python version... %sFAIL%s (found %s, requires %s)\" % (Bcolors.FAIL, Bcolors.ENDC, str(cur_version), str(req_version)))"
            },
            {
                "url": 5808,
                "code": "def valid_file(path: str) -> bool: path = Path(path).expanduser() log.debug(\"checking if %s is a valid file\", path) return path.exists() and path.is_file()"
            },
            {
                "url": 2280,
                "code": "def check_version(): if sys.version_info[0:3] == PYTHON_VERSION_INFO[0:3]: return sys.exit( ansi.error() + ' your virtual env points to the wrong python version. ' 'This is likely because you used a python installer that clobbered ' 'the system installation, which breaks virtualenv creation. ' 'To fix, check this symlink, and delete the installation of python ' 'that it is brokenly pointing to, then delete the virtual env itself ' 'and rerun lore install: ' + os.linesep + os.linesep + BIN_PYTHON + os.linesep )"
            },
            {
                "url": 668,
                "code": "def get_python(): if sys.platform == 'win32': python = path.join(VE_ROOT, 'Scripts', 'python.exe') else: python = path.join(VE_ROOT, 'bin', 'python') return python"
            },
            {
                "url": 2959,
                "code": "def _file_exists(path, filename): return os.path.isfile(os.path.join(path, filename))"
            },
            {
                "url": 2147,
                "code": "def is_exe(fpath): return os.path.isfile(fpath) and os.access(fpath, os.X_OK)"
            },
            {
                "url": 4496,
                "code": "def is_valid_file(parser,arg): if not os.path.exists(arg): parser.error(\"File %s not found\"%arg) else: return arg"
            },
            {
                "url": 4368,
                "code": "def search_script_directory(self, path): for subdir, dirs, files in os.walk(path): for file_name in files: if file_name.endswith(\".py\"): self.search_script_file(subdir, file_name)"
            },
            {
                "url": 2931,
                "code": "def is_valid_file(parser, arg): arg = os.path.abspath(arg) if not os.path.exists(arg): parser.error(\"The file %s does not exist!\" % arg) else: return arg"
            },
            {
                "url": 2996,
                "code": "def prepare_path(path): if type(path) == list: return os.path.join(*path) return path"
            }
        ],
        "url": 1644
    },
    {
        "nl_input": "python test truth value of list",
        "code_input": [
            {
                "url": 192,
                "code": "def _check_elements_equal(lst): assert isinstance(lst, list), \"Input value must be a list.\" return not lst or lst.count(lst[0]) == len(lst)"
            },
            {
                "url": 2136,
                "code": "def allsame(list_, strict=True): if len(list_) == 0: return True first_item = list_[0] return list_all_eq_to(list_, first_item, strict)"
            },
            {
                "url": 69,
                "code": "def assert_exactly_one_true(bool_list): assert isinstance(bool_list, list) counter = 0 for item in bool_list: if item: counter += 1 return counter == 1"
            },
            {
                "url": 2303,
                "code": "def check_type_and_size_of_param_list(param_list, expected_length): try: assert isinstance(param_list, list) assert len(param_list) == expected_length except AssertionError: msg = \"param_list must be a list containing {} elements.\" raise ValueError(msg.format(expected_length)) return None"
            },
            {
                "url": 2332,
                "code": "def validate_string_list(lst): if not isinstance(lst, list): raise ValueError('input %r must be a list' % lst) for x in lst: if not isinstance(x, basestring): raise ValueError('element %r in list must be a string' % x)"
            },
            {
                "url": 1782,
                "code": "def is_list_of_list(item): if ( type(item) in (list, tuple) and len(item) and isinstance(item[0], (list, tuple)) ): return True return False"
            },
            {
                "url": 2126,
                "code": "def all_strings(arr): if not isinstance([], list): raise TypeError(\"non-list value found where list is expected\") return all(isinstance(x, str) for x in arr)"
            },
            {
                "url": 2678,
                "code": "def test_value(self, value): if not isinstance(value, float): raise ValueError('expected float value: ' + str(type(value)))"
            },
            {
                "url": 6166,
                "code": "def same(*values): if not values: return True first, rest = values[0], values[1:] return all(value == first for value in rest)"
            },
            {
                "url": 2139,
                "code": "def build_list_type_validator(item_validator): def validate_list_of_type(value): return [item_validator(item) for item in validate_list(value)] return validate_list_of_type"
            },
            {
                "url": 480,
                "code": "def equal(list1, list2): return [item1 == item2 for item1, item2 in broadcast_zip(list1, list2)]"
            },
            {
                "url": 5293,
                "code": "def list_of(cls): return lambda l: isinstance(l, list) and all(isinstance(x, cls) for x in l)"
            },
            {
                "url": 5587,
                "code": "def obj_in_list_always(target_list, obj): for item in set(target_list): if item is not obj: return False return True"
            },
            {
                "url": 756,
                "code": "def isin(value, values): for i, v in enumerate(value): if v not in np.array(values)[:, i]: return False return True"
            },
            {
                "url": 5822,
                "code": "def isarray(array, test, dim=2): if dim > 1: return all(isarray(array[i], test, dim - 1) for i in range(len(array))) return all(test(i) for i in array)"
            }
        ],
        "url": 69
    },
    {
        "nl_input": "python string value of enum",
        "code_input": [
            {
                "url": 569,
                "code": "def to_python(self, value): if value is None: return value if isinstance(value, self.enum): return value return self.enum[value]"
            },
            {
                "url": 2804,
                "code": "def from_string(cls, string): # find enum value for attr in dir(cls): value = getattr(cls, attr) if value == string: return value # if not found, log warning and return the value passed in logger.warning(\"{} is not a valid enum value for {}.\".format(string, cls.__name__)) return string"
            },
            {
                "url": 471,
                "code": "def EnumValueName(self, enum, value): return self.enum_types_by_name[enum].values_by_number[value].name"
            },
            {
                "url": 2916,
                "code": "def Value(self, name): if name in self._enum_type.values_by_name: return self._enum_type.values_by_name[name].number raise ValueError('Enum %s has no value defined for name %s' % ( self._enum_type.name, name))"
            },
            {
                "url": 246,
                "code": "def describe_enum_value(enum_value): enum_value_descriptor = EnumValueDescriptor() enum_value_descriptor.name = six.text_type(enum_value.name) enum_value_descriptor.number = enum_value.number return enum_value_descriptor"
            },
            {
                "url": 5688,
                "code": "def dict_to_enum_fn(d: Dict[str, Any], enum_class: Type[Enum]) -> Enum: return enum_class[d['name']]"
            },
            {
                "url": 248,
                "code": "def items(self): return [(value_descriptor.name, value_descriptor.number) for value_descriptor in self._enum_type.values]"
            },
            {
                "url": 4091,
                "code": "def get_enum_from_name(self, enum_name): return next((e for e in self.enums if e.name == enum_name), None)"
            },
            {
                "url": 5679,
                "code": "def __init__(self, enum_obj: Any) -> None: if enum_obj: self.name = enum_obj self.items = ', '.join([str(i) for i in enum_obj]) else: self.items = ''"
            },
            {
                "url": 1772,
                "code": "def unpack_out(self, name): return self.parse(, enum_class=self._import_type(), value=name)[\"enum\"]"
            },
            {
                "url": 4890,
                "code": "def get_enum_documentation(class_name, module_name, enum_class_object): documentation = .format( module_name=module_name, class_name=class_name, plus='+' * len(class_name), ) if enum_class_object.__doc__ and enum_class_object.__doc__.strip(): documentation += '\\n\\n{}'.format(_clean_literals(inspect.cleandoc(enum_class_object.__doc__))) documentation += '\\n\\nConstant Values:\\n' for e in enum_class_object: documentation += '\\n- ``{}`` (``{}``)'.format(e.name, repr(e.value).lstrip('u')) return documentation"
            },
            {
                "url": 4090,
                "code": "def _dump_enum(self, e, top=''): self._print() self._print('enum {} {{'.format(e.name)) self.defines.append('{}.{}'.format(top,e.name)) self.tabs+=1 for v in e.value: self._print('{} = {};'.format(v.name, v.number)) self.tabs-=1 self._print('}')"
            },
            {
                "url": 457,
                "code": "def write_enum(fo, datum, schema): index = schema['symbols'].index(datum) write_int(fo, index)"
            },
            {
                "url": 2146,
                "code": "def _Enum(docstring, *names): enums = dict(zip(names, range(len(names)))) reverse = dict((value, key) for key, value in enums.iteritems()) enums['reverse_mapping'] = reverse enums['__doc__'] = docstring return type('Enum', (object,), enums)"
            },
            {
                "url": 5161,
                "code": "def __PrintEnumDocstringLines(self, enum_type): description = enum_type.description or '%s enum type.' % enum_type.name for line in textwrap.wrap('r')"
            }
        ],
        "url": 471
    },
    {
        "nl_input": "python create null pointer with ctypes",
        "code_input": [
            {
                "url": 1683,
                "code": "def POINTER(obj): p = ctypes.POINTER(obj) if not isinstance(p.from_param, classmethod): def from_param(cls, x): if x is None: return cls() else: return x p.from_param = classmethod(from_param) return p"
            },
            {
                "url": 4251,
                "code": "def from_pystr_to_cstr(data): if not isinstance(data, list): raise NotImplementedError pointers = (ctypes.c_char_p * len(data))() if PY3: data = [bytes(d, 'utf-8') for d in data] else: data = [d.encode('utf-8') if isinstance(d, unicode) else d # pylint: disable=undefined-variable for d in data] pointers[:] = data return pointers"
            },
            {
                "url": 2663,
                "code": "def cudaMalloc(count, ctype=None): ptr = ctypes.c_void_p() status = _libcudart.cudaMalloc(ctypes.byref(ptr), count) cudaCheckStatus(status) if ctype != None: ptr = ctypes.cast(ptr, ctypes.POINTER(ctype)) return ptr"
            },
            {
                "url": 64,
                "code": "def cfloat64_array_to_numpy(cptr, length): if isinstance(cptr, ctypes.POINTER(ctypes.c_double)): return np.fromiter(cptr, dtype=np.float64, count=length) else: raise RuntimeError('Expected double pointer')"
            },
            {
                "url": 1887,
                "code": "def pointer(self): return ctypes.cast(ctypes.pointer(ctypes.c_uint8.from_buffer(self.mapping, 0)), ctypes.c_void_p)"
            },
            {
                "url": 82,
                "code": "def cfloat32_array_to_numpy(cptr, length): if isinstance(cptr, ctypes.POINTER(ctypes.c_float)): return np.fromiter(cptr, dtype=np.float32, count=length) else: raise RuntimeError('Expected float pointer')"
            },
            {
                "url": 1885,
                "code": "def c_array(ctype, values): if isinstance(values, np.ndarray) and values.dtype.itemsize == ctypes.sizeof(ctype): return (ctype * len(values)).from_buffer_copy(values) return (ctype * len(values))(*values)"
            },
            {
                "url": 1659,
                "code": "def get_ctype(rtype, cfunc, *args): val_p = backend.ffi.new(rtype) args = args + (val_p,) cfunc(*args) return val_p[0]"
            },
            {
                "url": 79,
                "code": "def cint32_array_to_numpy(cptr, length): if isinstance(cptr, ctypes.POINTER(ctypes.c_int32)): return np.fromiter(cptr, dtype=np.int32, count=length) else: raise RuntimeError('Expected int pointer')"
            },
            {
                "url": 2972,
                "code": "def objectproxy_realaddress(obj): voidp = QROOT.TPython.ObjectProxy_AsVoidPtr(obj) return C.addressof(C.c_char.from_buffer(voidp))"
            },
            {
                "url": 4520,
                "code": "def to_bytes_or_none(value): if value == ffi.NULL: return None elif isinstance(value, ffi.CData): return ffi.string(value) else: raise ValueError('Value must be char[] or NULL')"
            },
            {
                "url": 134,
                "code": "def create_symlink(source, link_name): os_symlink = getattr(os, \"symlink\", None) if isinstance(os_symlink, collections.Callable): os_symlink(source, link_name) else: import ctypes csl = ctypes.windll.kernel32.CreateSymbolicLinkW csl.argtypes = (ctypes.c_wchar_p, ctypes.c_wchar_p, ctypes.c_uint32) csl.restype = ctypes.c_ubyte flags = 1 if os.path.isdir(source) else 0 if csl(link_name, source, flags) == 0: raise ctypes.WinError()"
            },
            {
                "url": 84,
                "code": "def cint8_array_to_numpy(cptr, length): if isinstance(cptr, ctypes.POINTER(ctypes.c_int8)): return np.fromiter(cptr, dtype=np.int8, count=length) else: raise RuntimeError('Expected int pointer')"
            },
            {
                "url": 5325,
                "code": "def get_winfunc(libname, funcname, restype=None, argtypes=(), _libcache={}): if libname not in _libcache: _libcache[libname] = windll.LoadLibrary(libname) func = getattr(_libcache[libname], funcname) func.argtypes = argtypes func.restype = restype return func"
            },
            {
                "url": 285,
                "code": "def make_kind_check(python_types, numpy_kind): def check(value): if hasattr(value, 'dtype'): return value.dtype.kind == numpy_kind return isinstance(value, python_types) return check"
            }
        ],
        "url": 1683
    },
    {
        "nl_input": "python md5 hash string",
        "code_input": [
            {
                "url": 1193,
                "code": "def md5_string(s): m = hashlib.md5() m.update(s) return str(m.hexdigest())"
            },
            {
                "url": 499,
                "code": "def md5_hash_file(fh): md5 = hashlib.md5() while True: data = fh.read(8192) if not data: break md5.update(data) return md5.hexdigest()"
            },
            {
                "url": 1881,
                "code": "def get_file_md5sum(path): with open(path, 'rb') as fh: h = str(hashlib.md5(fh.read()).hexdigest()) return h"
            },
            {
                "url": 5855,
                "code": "def hash_file(fileobj): hasher = hashlib.md5() buf = fileobj.read(65536) while len(buf) > 0: hasher.update(buf) buf = fileobj.read(65536) return hasher.hexdigest()"
            },
            {
                "url": 3435,
                "code": "def file_md5sum(filename): hash_md5 = hashlib.md5() with open(filename, 'rb') as f: for chunk in iter(lambda: f.read(1024 * 4), b''): hash_md5.update(chunk) return hash_md5.hexdigest()"
            },
            {
                "url": 582,
                "code": "def get_md5_for_file(file): md5 = hashlib.md5() while True: data = file.read(md5.block_size) if not data: break md5.update(data) return md5.hexdigest()"
            },
            {
                "url": 5153,
                "code": "def filehash(path): with open(path, \"rU\") as f: return md5(py3compat.str_to_bytes(f.read())).hexdigest()"
            },
            {
                "url": 175,
                "code": "def dict_hash(dct): dct_s = json.dumps(dct, sort_keys=True) try: m = md5(dct_s) except TypeError: m = md5(dct_s.encode()) return m.hexdigest()"
            },
            {
                "url": 3336,
                "code": "def generate_hash(filepath): fr = FileReader(filepath) data = fr.read_bin() return _calculate_sha256(data)"
            },
            {
                "url": 14,
                "code": "def _string_hash(s): h = 5381 for c in s: h = h * 33 + ord(c) return h"
            },
            {
                "url": 6044,
                "code": "def checksum(path): hasher = hashlib.sha1() with open(path, 'rb') as stream: buf = stream.read(BLOCKSIZE) while len(buf) > 0: hasher.update(buf) buf = stream.read(BLOCKSIZE) return hasher.hexdigest()"
            },
            {
                "url": 3204,
                "code": "def _sha1_for_file(filename): with open(filename, \"rb\") as fileobj: contents = fileobj.read() return hashlib.sha1(contents).hexdigest()"
            },
            {
                "url": 5995,
                "code": "def _hash_the_file(hasher, filename): BUF_SIZE = 65536 with open(filename, 'rb') as f: buf = f.read(BUF_SIZE) while len(buf) > 0: hasher.update(buf) buf = f.read(BUF_SIZE) return hasher"
            },
            {
                "url": 3205,
                "code": "def sha1(s): h = hashlib.new('sha1') h.update(s) return h.hexdigest()"
            },
            {
                "url": 4951,
                "code": "def _get_file_sha1(file): bits = file.read() file.seek(0) h = hashlib.new('sha1', bits).hexdigest() return h"
            }
        ],
        "url": 1193
    },
    {
        "nl_input": "python how to match dictionarys",
        "code_input": [
            {
                "url": 283,
                "code": "def is_same_dict(d1, d2): for k, v in d1.items(): if isinstance(v, dict): is_same_dict(v, d2[k]) else: assert d1[k] == d2[k] for k, v in d2.items(): if isinstance(v, dict): is_same_dict(v, d1[k]) else: assert d1[k] == d2[k]"
            },
            {
                "url": 522,
                "code": "def compare(dicts): common_members = {} common_keys = reduce(lambda x, y: x & y, map(dict.keys, dicts)) for k in common_keys: common_members[k] = list( reduce(lambda x, y: x & y, [set(d[k]) for d in dicts])) return common_members"
            },
            {
                "url": 5851,
                "code": "def assert_equal(first, second, msg_fmt=\"{msg}\"): if isinstance(first, dict) and isinstance(second, dict): assert_dict_equal(first, second, msg_fmt) elif not first == second: msg = \"{!r} != {!r}\".format(first, second) fail(msg_fmt.format(msg=msg, first=first, second=second))"
            },
            {
                "url": 2900,
                "code": "def compare_dict(da, db): sa = set(da.items()) sb = set(db.items()) diff = sa & sb return dict(sa - diff), dict(sb - diff)"
            },
            {
                "url": 179,
                "code": "def dict_update_newkeys(dict_, dict2): for key, val in six.iteritems(dict2): if key not in dict_: dict_[key] = val"
            },
            {
                "url": 6132,
                "code": "def dictlist_replace(dict_list: Iterable[Dict], key: str, value: Any) -> None: for d in dict_list: d[key] = value"
            },
            {
                "url": 1843,
                "code": "def list2dict(lst): dic = {} for k,v in lst: dic[k] = v return dic"
            },
            {
                "url": 2685,
                "code": "def str_dict(some_dict): return {str(k): str(v) for k, v in some_dict.items()}"
            },
            {
                "url": 1480,
                "code": "def to_dict(dictish): if hasattr(dictish, 'iterkeys'): m = dictish.iterkeys elif hasattr(dictish, 'keys'): m = dictish.keys else: raise ValueError(dictish) return dict((k, dictish[k]) for k in m())"
            },
            {
                "url": 1224,
                "code": "def copy_and_update(dictionary, update): newdict = dictionary.copy() newdict.update(update) return newdict"
            },
            {
                "url": 1583,
                "code": "def dict_to_numpy_array(d): return fromarrays(d.values(), np.dtype([(str(k), v.dtype) for k, v in d.items()]))"
            },
            {
                "url": 1529,
                "code": "def _mean_dict(dict_list): return {k: np.array([d[k] for d in dict_list]).mean() for k in dict_list[0].keys()}"
            },
            {
                "url": 1733,
                "code": "def _check_conversion(key, valid_dict): if key not in valid_dict and key not in valid_dict.values(): # Only show users the nice string values keys = [v for v in valid_dict.keys() if isinstance(v, string_types)] raise ValueError('value must be one of %s, not %s' % (keys, key)) return valid_dict[key] if key in valid_dict else key"
            },
            {
                "url": 2228,
                "code": "def printdict(adict): dlist = list(adict.keys()) dlist.sort() for i in range(0, len(dlist)): print(dlist[i], adict[dlist[i]])"
            },
            {
                "url": 3045,
                "code": "def dict_merge(set1, set2): return dict(list(set1.items()) + list(set2.items()))"
            }
        ],
        "url": 556
    },
    {
        "nl_input": "select elements from a list, then delete these elements in the original list python",
        "code_input": [
            {
                "url": 837,
                "code": "def remove_elements(target, indices): copied = list(target) for index in reversed(indices): del copied[index] return copied"
            },
            {
                "url": 721,
                "code": "def dedupe_list(l): result = [] for el in l: if el not in result: result.append(el) return result"
            },
            {
                "url": 2569,
                "code": "def _delete_keys(dct, keys): c = deepcopy(dct) assert isinstance(keys, list) for k in keys: c.pop(k) return c"
            },
            {
                "url": 4062,
                "code": "def __delitem__(self, key): index, value = self._dict.pop(key) key2, value2 = self._list.pop(index) assert key == key2 assert value is value2 self._fix_indices_after_delete(index)"
            },
            {
                "url": 278,
                "code": "def remove_duplicates(lst): dset = set() return [l for l in lst if l not in dset and not dset.add(l)]"
            },
            {
                "url": 2433,
                "code": "def purge_duplicates(list_in): _list = [] for item in list_in: if item not in _list: _list.append(item) return _list"
            },
            {
                "url": 1019,
                "code": "def pop(self, index=-1): value = self._list.pop(index) del self._dict[value] return value"
            },
            {
                "url": 1431,
                "code": "def remove_list_duplicates(lista, unique=False): result = [] allready = [] for elem in lista: if elem not in result: result.append(elem) else: allready.append(elem) if unique: for elem in allready: result = list(filter((elem).__ne__, result)) return result"
            },
            {
                "url": 452,
                "code": "def dedup_list(l): dedup = set() return [ x for x in l if not (x in dedup or dedup.add(x))]"
            },
            {
                "url": 1450,
                "code": "def dedupe_list(seq): seen = set() return [x for x in seq if not (x in seen or seen.add(x))]"
            },
            {
                "url": 1095,
                "code": "def filter_by_ids(original_list, ids_to_filter): if not ids_to_filter: return original_list return [i for i in original_list if i['id'] in ids_to_filter]"
            },
            {
                "url": 3147,
                "code": "def isolate_element(self, x): members = list(self.members(x)) self.delete_set(x) self.union(*(v for v in members if v != x))"
            },
            {
                "url": 3655,
                "code": "def deduplicate(list_object): new = [] for item in list_object: if item not in new: new.append(item) return new"
            },
            {
                "url": 2383,
                "code": "def delistify(x): if isinstance(x, list): x = [e.replace(\"'\", \"\") for e in x] return '-'.join(sorted(x)) return x"
            },
            {
                "url": 3553,
                "code": "def remove_from_string(string, values): for v in values: string = string.replace(v, '') return string"
            }
        ],
        "url": 837
    },
    {
        "nl_input": "pybool to c++ python 3",
        "code_input": [
            {
                "url": 257,
                "code": "def convertToBool(): if not OPTIONS.strictBool.value: return [] REQUIRES.add('strictbool.asm') result = [] result.append('pop af') result.append('call __NORMALIZE_BOOLEAN') result.append('push af') return result"
            },
            {
                "url": 5682,
                "code": "def to_bool(value: Any) -> bool: return bool(strtobool(value) if isinstance(value, str) else value)"
            },
            {
                "url": 6265,
                "code": "def text_to_bool(value: str) -> bool: try: return bool(strtobool(value)) except (ValueError, AttributeError): return value is not None"
            },
            {
                "url": 1387,
                "code": "def _check_and_convert_bools(self): replacements = { True: 'T', False: 'F', } for key in self.bools: if isinstance(self[key], bool): self[key] = replacements[self[key]]"
            },
            {
                "url": 397,
                "code": "def boolean(value): if isinstance(value, bool): return value if value == \"\": return False return strtobool(value)"
            },
            {
                "url": 6180,
                "code": "def _isbool(string): return isinstance(string, _bool_type) or\\ (isinstance(string, (_binary_type, _text_type)) and string in (\"True\", \"False\"))"
            },
            {
                "url": 5583,
                "code": "def strtobytes(input, encoding): py_version = sys.version_info[0] if py_version >= 3: return _strtobytes_py3(input, encoding) return _strtobytes_py2(input, encoding)"
            },
            {
                "url": 1469,
                "code": "def command_py2to3(args): from lib2to3.main import main sys.exit(main(\"lib2to3.fixes\", args=args.sources))"
            },
            {
                "url": 5453,
                "code": "def bool_str(string): if string not in BOOL_STRS: raise ValueError('Invalid boolean string: \"{}\"'.format(string)) return True if string == 'true' else False"
            },
            {
                "url": 6148,
                "code": "def to_bool(value): # type: (Any) -> bool if isinstance(value, _compat.string_types): return value.upper() in ('Y', 'YES', 'T', 'TRUE', '1', 'OK') return bool(value)"
            },
            {
                "url": 4819,
                "code": "def str2bool(value): if value.lower() in ('yes', 'true', 't', 'y', '1'): return True if value.lower() in ('no', 'false', 'f', 'n', '0'): return False if value.lower() in ('d', 'default', ''): return None raise argparse.ArgumentTypeError('Expected: (Y)es/(T)rue/(N)o/(F)alse/(D)efault')"
            },
            {
                "url": 3360,
                "code": "def _cast_boolean(value): _BOOLEANS = {'1': True, 'yes': True, 'true': True, 'on': True, '0': False, 'no': False, 'false': False, 'off': False, '': False} value = str(value) if value.lower() not in _BOOLEANS: raise ValueError('Not a boolean: %s' % value) return _BOOLEANS[value.lower()]"
            },
            {
                "url": 607,
                "code": "def strToBool(val): if isinstance(val, str): val = val.lower() return val in ['true', 'on', 'yes', True]"
            },
            {
                "url": 742,
                "code": "def autoconvert(string): for fn in (boolify, int, float): try: return fn(string) except ValueError: pass return string"
            },
            {
                "url": 2907,
                "code": "def process_bool_arg(arg): if isinstance(arg, bool): return arg elif isinstance(arg, basestring): if arg.lower() in [\"true\", \"1\"]: return True elif arg.lower() in [\"false\", \"0\"]: return False"
            }
        ],
        "url": 257
    },
    {
        "nl_input": "how to add a ? in python url",
        "code_input": [
            {
                "url": 4628,
                "code": "def append_query_parameter(url, parameters, ignore_if_exists=True): if ignore_if_exists: for key in parameters.keys(): if key + \"=\" in url: del parameters[key] parameters_str = \"&\".join(k + \"=\" + v for k, v in parameters.items()) append_token = \"&\" if \"?\" in url else \"?\" return url + append_token + parameters_str"
            },
            {
                "url": 5829,
                "code": "def url_concat(url, args): if not args: return url if url[-1] not in ('?', '&'): url += '&' if ('?' in url) else '?' return url + urllib.urlencode(args)"
            },
            {
                "url": 5172,
                "code": "def add_params_to_url(url, params): url_parts = list(urlparse.urlparse(url)) # get url parts query = dict(urlparse.parse_qsl(url_parts[4])) # get url query query.update(params) # add new params url_parts[4] = urlencode(query) return urlparse.urlunparse(url_parts)"
            },
            {
                "url": 548,
                "code": "def url_encode(url): if isinstance(url, text_type): url = url.encode('utf8') return quote(url, ':/%?&=')"
            },
            {
                "url": 3033,
                "code": "def create_search_url(self): url = '?' for key, value in self.arguments.items(): url += '%s=%s&' % (quote_plus(key), quote_plus(value)) self.url = url[:-1] return self.url"
            },
            {
                "url": 1449,
                "code": "def strip_querystring(url): p = six.moves.urllib.parse.urlparse(url) return p.scheme + \"://\" + p.netloc + p.path"
            },
            {
                "url": 6144,
                "code": "def urljoin(*args): value = \"/\".join(map(lambda x: str(x).strip('/'), args)) return \"/{}\".format(value)"
            },
            {
                "url": 191,
                "code": "def dict_to_querystring(dictionary): s = u\"\" for d in dictionary.keys(): s = unicode.format(u\"{0}{1}={2}&\", s, d, dictionary[d]) return s[:-1]"
            },
            {
                "url": 4006,
                "code": "def url_syntax_check(url): # pragma: no cover if url and isinstance(url, str): # The given URL is not empty nor None. # and # * The given URL is a string. # We silently load the configuration. load_config(True) return Check(url).is_url_valid() # We return None, there is nothing to check. return None"
            },
            {
                "url": 4581,
                "code": "def get_querystring(uri): parts = urlparse.urlsplit(uri) return urlparse.parse_qs(parts.query)"
            },
            {
                "url": 1315,
                "code": "def get_url_args(url): url_data = urllib.parse.urlparse(url) arg_dict = urllib.parse.parse_qs(url_data.query) return arg_dict"
            },
            {
                "url": 2201,
                "code": "def parse_query_string(query): result = {} qparts = query.split('&') for item in qparts: key, value = item.split('=') key = key.strip() value = value.strip() result[key] = unquote_plus(value) return result"
            },
            {
                "url": 1747,
                "code": "def parse_code(url): result = urlparse(url) query = parse_qs(result.query) return query['code']"
            },
            {
                "url": 1471,
                "code": "def clean_url(url): if not url.startswith(('http://', 'https://')): url = f'http://{url}' if not URL_RE.match(url): raise BadURLException(f'{url} is not valid') return url"
            },
            {
                "url": 5121,
                "code": "def _make_sql_params(self,kw): return ['%s=?' %k for k in kw.keys() ] for k,v in kw.iteritems(): vals.append('%s=?' %k) return vals"
            }
        ],
        "url": 4628
    },
    {
        "nl_input": "python how to check whether the process with pid exist",
        "code_input": [
            {
                "url": 528,
                "code": "def pid_exists(pid): try: os.kill(pid, 0) except OSError as exc: return exc.errno == errno.EPERM else: return True"
            },
            {
                "url": 2244,
                "code": "def stop(pid): if psutil.pid_exists(pid): try: p = psutil.Process(pid) p.kill() except Exception: pass"
            },
            {
                "url": 5720,
                "code": "def is_running(process_id: int) -> bool: pstr = str(process_id) encoding = sys.getdefaultencoding() s = subprocess.Popen([\"ps\", \"-p\", pstr], stdout=subprocess.PIPE) for line in s.stdout: strline = line.decode(encoding) if pstr in strline: return True return False"
            },
            {
                "url": 2327,
                "code": "def kill_mprocess(process): if process and proc_alive(process): process.terminate() process.communicate() return not proc_alive(process)"
            },
            {
                "url": 915,
                "code": "def _psutil_kill_pid(pid): try: parent = Process(pid) for child in parent.children(recursive=True): child.kill() parent.kill() except NoSuchProcess: return"
            },
            {
                "url": 4121,
                "code": "def get_pid_list(): pids = [int(x) for x in os.listdir('/proc') if x.isdigit()] return pids"
            },
            {
                "url": 4376,
                "code": "async def stop(self): # negate pid so that signals apply to process group pgid = -self.process.pid try: os.kill(pgid, signal.SIGTERM) await asyncio.sleep(1) os.kill(pgid, signal.SIGKILL) except (OSError, ProcessLookupError): return"
            },
            {
                "url": 2728,
                "code": "def process_kill(pid, sig=None): sig = sig or signal.SIGTERM os.kill(pid, sig)"
            },
            {
                "url": 2277,
                "code": "def kill(self): if self.process: self.process.kill() self.process.wait()"
            },
            {
                "url": 239,
                "code": "def _pip_exists(self): return os.path.isfile(os.path.join(self.path, 'bin', 'pip'))"
            },
            {
                "url": 2468,
                "code": "def stop_process(self): self._process.terminate() if not self._process.waitForFinished(100): self._process.kill()"
            },
            {
                "url": 5489,
                "code": "def write_pid_file(): pidfile = os.path.basename(sys.argv[0])[:-3] + '.pid' # strip .py, add .pid with open(pidfile, 'w') as fh: fh.write(\"%d\\n\" % os.getpid()) fh.close()"
            },
            {
                "url": 5026,
                "code": "def db_exists(): logger.info(\"Checking to see if %s already exists\", repr(DB[\"NAME\"])) try: # Hide stderr since it is confusing here psql(\"\", stderr=subprocess.STDOUT) except subprocess.CalledProcessError: return False return True"
            },
            {
                "url": 1306,
                "code": "def kill_process_children(pid): if sys.platform == \"darwin\": kill_process_children_osx(pid) elif sys.platform == \"linux\": kill_process_children_unix(pid) else: pass"
            },
            {
                "url": 1086,
                "code": "def execute_in_background(self): # http://stackoverflow.com/questions/1605520 args = shlex.split(self.cmd) p = Popen(args) return p.pid"
            }
        ],
        "url": 528
    },
    {
        "nl_input": "how to cehck if somethign is a constant python",
        "code_input": [
            {
                "url": 1184,
                "code": "def is_static(*p): return all(is_CONST(x) or is_number(x) or is_const(x) for x in p)"
            },
            {
                "url": 1654,
                "code": "def check(self, var): if not isinstance(var, _str_type): return False return _enum_mangle(var) in self._consts"
            },
            {
                "url": 285,
                "code": "def make_kind_check(python_types, numpy_kind): def check(value): if hasattr(value, 'dtype'): return value.dtype.kind == numpy_kind return isinstance(value, python_types) return check"
            },
            {
                "url": 1650,
                "code": "def is_valid_variable_name(string_to_check): try: parse('{} = None'.format(string_to_check)) return True except (SyntaxError, ValueError, TypeError): return False"
            },
            {
                "url": 2141,
                "code": "def isstring(value): classes = (str, bytes) if pyutils.PY3 else basestring # noqa: F821 return isinstance(value, classes)"
            },
            {
                "url": 4548,
                "code": "def is_symbol(string): return ( is_int(string) or is_float(string) or is_constant(string) or is_unary(string) or is_binary(string) or (string == '(') or (string == ')') )"
            },
            {
                "url": 6187,
                "code": "def check_python_version(): # Required due to multiple with statements on one line req_version = (2, 7) cur_version = sys.version_info if cur_version >= req_version: print(\"Python version... %sOK%s (found %s, requires %s)\" % (Bcolors.OKGREEN, Bcolors.ENDC, str(platform.python_version()), str(req_version[0]) + \".\" + str(req_version[1]))) else: print(\"Python version... %sFAIL%s (found %s, requires %s)\" % (Bcolors.FAIL, Bcolors.ENDC, str(cur_version), str(req_version)))"
            },
            {
                "url": 4567,
                "code": "def check_cv(self, y): y_arr = None if self.stratified: # Try to convert y to numpy for sklearn's check_cv; if conversion # doesn't work, still try. try: y_arr = to_numpy(y) except (AttributeError, TypeError): y_arr = y if self._is_float(self.cv): return self._check_cv_float() return self._check_cv_non_float(y_arr)"
            },
            {
                "url": 747,
                "code": "def is_defined(self, obj, force_import=False): from spyder_kernels.utils.dochelpers import isdefined ns = self._get_current_namespace(with_magics=True) return isdefined(obj, force_import=force_import, namespace=ns)"
            },
            {
                "url": 196,
                "code": "def is_callable(*p): import symbols return all(isinstance(x, symbols.FUNCTION) for x in p)"
            },
            {
                "url": 4137,
                "code": "def get_value(self, context): if self.value: return expressions.eval_string(self.value, context) else: # Empty input raises cryptic EOF syntax err, this more human # friendly raise ValueError('!py string expression is empty. It must be a ' 'valid python expression instead.')"
            },
            {
                "url": 218,
                "code": "def is_date(thing): # known date types date_types = (datetime.datetime, datetime.date, DateTime) return isinstance(thing, date_types)"
            },
            {
                "url": 1789,
                "code": "def is_string(obj): if PYTHON3: str_type = (bytes, str) else: str_type = (bytes, str, unicode) return isinstance(obj, str_type)"
            },
            {
                "url": 530,
                "code": "def _isstring(dtype): return dtype.type == numpy.unicode_ or dtype.type == numpy.string_"
            },
            {
                "url": 2014,
                "code": "def chkstr(s, v): if type(s) != str: raise TypeError(\"{var} must be str\".format(var=v)) if not s: raise ValueError(\"{var} cannot be empty\".format(var=v))"
            }
        ],
        "url": 1184
    },
    {
        "nl_input": "python check if variable exists in locals",
        "code_input": [
            {
                "url": 1650,
                "code": "def is_valid_variable_name(string_to_check): try: parse('{} = None'.format(string_to_check)) return True except (SyntaxError, ValueError, TypeError): return False"
            },
            {
                "url": 2356,
                "code": "def is_valid_varname(varname): if not isinstance(varname, six.string_types): return False match_obj = re.match(varname_regex, varname) valid_syntax = match_obj is not None valid_name = not keyword.iskeyword(varname) isvalid = valid_syntax and valid_name return isvalid"
            },
            {
                "url": 1793,
                "code": "def getvariable(name): import inspect fr = inspect.currentframe() try: while fr: fr = fr.f_back vars = fr.f_locals if name in vars: return vars[name] except: pass return None"
            },
            {
                "url": 6266,
                "code": "def _check_env_var(envvar: str) -> bool: if os.getenv(envvar) is None: raise KeyError( \"Required ENVVAR: {0} is not set\".format(envvar)) if not os.getenv(envvar): # test if env var is empty raise KeyError( \"Required ENVVAR: {0} is empty\".format(envvar)) return True"
            },
            {
                "url": 1884,
                "code": "def get_var(self, name): for var in self.vars: if var.name == name: return var else: raise ValueError"
            },
            {
                "url": 3885,
                "code": "def nonlocal_check(self, original, loc, tokens): return self.check_py(\"3\", \"nonlocal statement\", original, loc, tokens)"
            },
            {
                "url": 1654,
                "code": "def check(self, var): if not isinstance(var, _str_type): return False return _enum_mangle(var) in self._consts"
            },
            {
                "url": 3596,
                "code": "def _get_var_from_string(item): modname, varname = _split_mod_var_names(item) if modname: mod = __import__(modname, globals(), locals(), [varname], -1) return getattr(mod, varname) else: return globals()[varname]"
            },
            {
                "url": 2014,
                "code": "def chkstr(s, v): if type(s) != str: raise TypeError(\"{var} must be str\".format(var=v)) if not s: raise ValueError(\"{var} cannot be empty\".format(var=v))"
            },
            {
                "url": 5210,
                "code": "def _check_valid(key, val, valid): if val not in valid: raise ValueError('%s must be one of %s, not \"%s\"' % (key, valid, val))"
            },
            {
                "url": 4009,
                "code": "def str_check(*args, func=None): func = func or inspect.stack()[2][3] for var in args: if not isinstance(var, (str, collections.UserString, collections.abc.Sequence)): name = type(var).__name__ raise StringError( f'Function {func} expected str, {name} got instead.')"
            },
            {
                "url": 4578,
                "code": "def get_parent_var(name, global_ok=False, default=None, skip_frames=0): scope = get_parent_scope_from_var(name, global_ok=global_ok, skip_frames=skip_frames + 1) if not scope: return default if name in scope.locals: return scope.locals.get(name, default) return scope.globals.get(name, default)"
            },
            {
                "url": 202,
                "code": "def is_defined(self, objtxt, force_import=False): return self.interpreter.is_defined(objtxt, force_import)"
            },
            {
                "url": 1106,
                "code": "def get_var(name, factory=None): if name not in _VARS and factory is not None: _VARS[name] = factory() return _VARS.get(name)"
            },
            {
                "url": 4601,
                "code": "def get_variables(args): variables_dict = {} if args.variables: for var in args.variables: words = var.split('=') variables_dict[words[0]] = words[1] return variables_dict"
            }
        ],
        "url": 1793
    },
    {
        "nl_input": "python filter a dictionary by value",
        "code_input": [
            {
                "url": 1002,
                "code": "def filter_dict_by_key(d, keys): return {k: v for k, v in d.items() if k in keys}"
            },
            {
                "url": 177,
                "code": "def filter_dict(d, keys): return {k: v for k, v in d.items() if k in keys}"
            },
            {
                "url": 185,
                "code": "def _remove_dict_keys_with_value(dict_, val): return {k: v for k, v in dict_.items() if v is not val}"
            },
            {
                "url": 2205,
                "code": "def clean_dict_keys(d): new_d = {} for (k, v) in d.iteritems(): new_d[str(k)] = v return new_d"
            },
            {
                "url": 695,
                "code": "def _clean_dict(target_dict, whitelist=None): assert isinstance(target_dict, dict) return { ustr(k).strip(): ustr(v).strip() for k, v in target_dict.items() if v not in (None, Ellipsis, [], (), \"\") and (not whitelist or k in whitelist) }"
            },
            {
                "url": 1056,
                "code": "def get_key_by_value(dictionary, search_value): for key, value in dictionary.iteritems(): if value == search_value: return ugettext(key)"
            },
            {
                "url": 3172,
                "code": "def dict_pick(dictionary, allowed_keys): return {key: value for key, value in viewitems(dictionary) if key in allowed_keys}"
            },
            {
                "url": 51,
                "code": "def dictapply(d, fn): for k, v in d.items(): if isinstance(v, dict): v = dictapply(v, fn) else: d[k] = fn(v) return d"
            },
            {
                "url": 1150,
                "code": "def _dict_values_sorted_by_key(dictionary): # This should be a yield from instead. for _, value in sorted(dictionary.iteritems(), key=operator.itemgetter(0)): yield value"
            },
            {
                "url": 2281,
                "code": "def _remove_none_values(dictionary): return list(map(dictionary.pop, [i for i in dictionary if dictionary[i] is None]))"
            },
            {
                "url": 4480,
                "code": "def filter(self, func): return self.__class__( [ i for i in self.res if func(*i) ], name='filtered %s'%self.listname)"
            },
            {
                "url": 191,
                "code": "def dict_to_querystring(dictionary): s = u\"\" for d in dictionary.keys(): s = unicode.format(u\"{0}{1}={2}&\", s, d, dictionary[d]) return s[:-1]"
            },
            {
                "url": 1095,
                "code": "def filter_by_ids(original_list, ids_to_filter): if not ids_to_filter: return original_list return [i for i in original_list if i['id'] in ids_to_filter]"
            },
            {
                "url": 5176,
                "code": "def apply(filter): def decorator(callable): return lambda *args, **kwargs: filter(callable(*args, **kwargs)) return decorator"
            },
            {
                "url": 1015,
                "code": "def rm_keys_from_dict(d, keys): # Loop for each key given for key in keys: # Is the key in the dictionary? if key in d: try: d.pop(key, None) except KeyError: # Not concerned with an error. Keep going. pass return d"
            }
        ],
        "url": 5644
    },
    {
        "nl_input": "read json file and turn into dictionary using python",
        "code_input": [
            {
                "url": 5563,
                "code": "def from_file(file_path) -> dict: with io.open(file_path, 'r', encoding='utf-8') as json_stream: return Json.parse(json_stream, True)"
            },
            {
                "url": 3131,
                "code": "def _read_json_file(self, json_file): self.log.debug(\"Reading '%s' JSON file...\" % json_file) with open(json_file, 'r') as f: return json.load(f, object_pairs_hook=OrderedDict)"
            },
            {
                "url": 3659,
                "code": "def from_file(filename): f = open(filename, 'r') j = json.load(f) f.close() return from_dict(j)"
            },
            {
                "url": 2956,
                "code": "def read_dict_from_file(file_path): with open(file_path) as file: lines = file.read().splitlines() obj = {} for line in lines: key, value = line.split(':', maxsplit=1) obj[key] = eval(value) return obj"
            },
            {
                "url": 977,
                "code": "def open_json(file_name): with open(file_name, \"r\") as json_data: data = json.load(json_data) return data"
            },
            {
                "url": 157,
                "code": "def from_json(cls, json_str): d = json.loads(json_str) return cls.from_dict(d)"
            },
            {
                "url": 1059,
                "code": "def _dict_to_proto(py_dict, proto): dict_json_str = json.dumps(py_dict) return json_format.Parse(dict_json_str, proto)"
            },
            {
                "url": 2552,
                "code": "def load_from_file(cls, file_path: str): with open(file_path, \"r\") as f: data = json.load(f) item = cls.decode(data=data) return item"
            },
            {
                "url": 4507,
                "code": "def from_json(cls, s): d = json.loads(s) return get_dict_handler(d[\"type\"])(d)"
            },
            {
                "url": 1300,
                "code": "def read_json(location): location = ensure_path(location) with location.open('r', encoding='utf8') as f: return ujson.load(f)"
            },
            {
                "url": 5288,
                "code": "def from_json(cls, json_doc): try: d = json.load(json_doc) except AttributeError: # catch the read() error d = json.loads(json_doc) return cls.from_dict(d)"
            },
            {
                "url": 1409,
                "code": "def _loadfilepath(self, filepath, **kwargs): with open(filepath, \"r\") as f: data = json.load(f, **kwargs) return data"
            },
            {
                "url": 4188,
                "code": "def json_get_data(filename): with open(filename) as fp: json_data = json.load(fp) return json_data return False"
            },
            {
                "url": 983,
                "code": "def json_iter (path): with open(path, 'r') as f: for line in f.readlines(): yield json.loads(line)"
            },
            {
                "url": 3889,
                "code": "def load_jsonf(fpath, encoding): with codecs.open(fpath, encoding=encoding) as f: return json.load(f)"
            }
        ],
        "url": 5563
    },
    {
        "nl_input": "python change the shape of list",
        "code_input": [
            {
                "url": 2814,
                "code": "def shape_list(l,shape,dtype): return np.array(l, dtype=dtype).reshape(shape)"
            },
            {
                "url": 3787,
                "code": "def _listify(collection): new_list = [] for index in range(len(collection)): new_list.append(collection[index]) return new_list"
            },
            {
                "url": 5658,
                "code": "def flatten_list(x: List[Any]) -> List[Any]: # noqa return [item for sublist in x for item in sublist]"
            },
            {
                "url": 5705,
                "code": "def flatten_list(l: List[list]) -> list: return [v for inner_l in l for v in inner_l]"
            },
            {
                "url": 566,
                "code": "def flatten(l, types=(list, float)): l = [item if isinstance(item, types) else [item] for item in l] return [item for sublist in l for item in sublist]"
            },
            {
                "url": 4892,
                "code": "def flat_list(input_list): r x = input_list if isinstance(x, list): return [a for i in x for a in flat_list(i)] else: return [x]"
            },
            {
                "url": 5549,
                "code": "def listify(a): if a is None: return [] elif not isinstance(a, (tuple, list, np.ndarray)): return [a] return list(a)"
            },
            {
                "url": 536,
                "code": "def flat_list(lst): if isinstance(lst, list): for item in lst: for i in flat_list(item): yield i else: yield lst"
            },
            {
                "url": 2303,
                "code": "def check_type_and_size_of_param_list(param_list, expected_length): try: assert isinstance(param_list, list) assert len(param_list) == expected_length except AssertionError: msg = \"param_list must be a list containing {} elements.\" raise ValueError(msg.format(expected_length)) return None"
            },
            {
                "url": 706,
                "code": "def get_list_dimensions(_list): if isinstance(_list, list) or isinstance(_list, tuple): return [len(_list)] + get_list_dimensions(_list[0]) return []"
            },
            {
                "url": 5280,
                "code": "def encode_list(dynamizer, value): encoded_list = [] dict(map(dynamizer.raw_encode, value)) for v in value: encoded_type, encoded_value = dynamizer.raw_encode(v) encoded_list.append({ encoded_type: encoded_value, }) return 'L', encoded_list"
            },
            {
                "url": 6037,
                "code": "def ensure_list(iterable: Iterable[A]) -> List[A]: if isinstance(iterable, list): return iterable else: return list(iterable)"
            },
            {
                "url": 1014,
                "code": "def flatten_list(l): return list(chain.from_iterable(repeat(x,1) if isinstance(x,str) else x for x in l))"
            },
            {
                "url": 664,
                "code": "def flatten(l): return sum(map(flatten, l), []) \\ if isinstance(l, list) or isinstance(l, tuple) else [l]"
            },
            {
                "url": 5769,
                "code": "def encode_list(key, list_): # type: (str, Iterable) -> Dict[str, str] if not list_: return {} return {key: \" \".join(str(i) for i in list_)}"
            }
        ],
        "url": 2814
    },
    {
        "nl_input": "how to get the datatypes in python",
        "code_input": [
            {
                "url": 614,
                "code": "def datatype(dbtype, description, cursor): dt = cursor.db.introspection.get_field_type(dbtype, description) if type(dt) is tuple: return dt[0] else: return dt"
            },
            {
                "url": 5877,
                "code": "def get_datatype(self, table: str, column: str) -> str: return self.flavour.get_datatype(self, table, column).upper()"
            },
            {
                "url": 5803,
                "code": "def dtypes(self): return [(str(f.name), f.dataType.simpleString()) for f in self.schema.fields]"
            },
            {
                "url": 461,
                "code": "def _get_column_types(self, data): columns = list(zip_longest(*data)) return [self._get_column_type(column) for column in columns]"
            },
            {
                "url": 1693,
                "code": "def _getTypename(self, defn): return 'REAL' if defn.type.float or 'TIME' in defn.type.name or defn.dntoeu else 'INTEGER'"
            },
            {
                "url": 2399,
                "code": "def get_type_len(self): # Check types and set type/len self.get_sql() return self.type, self.len, self.len_decimal"
            },
            {
                "url": 308,
                "code": "def type_converter(text): if text.isdigit(): return int(text), int try: return float(text), float except ValueError: return text, STRING_TYPE"
            },
            {
                "url": 921,
                "code": "def getTypeStr(_type): r if isinstance(_type, CustomType): return str(_type) if hasattr(_type, '__name__'): return _type.__name__ return ''"
            },
            {
                "url": 5220,
                "code": "def irecarray_to_py(a): pytypes = [pyify(typestr) for name,typestr in a.dtype.descr] def convert_record(r): return tuple([converter(value) for converter, value in zip(pytypes,r)]) return (convert_record(r) for r in a)"
            },
            {
                "url": 1659,
                "code": "def get_ctype(rtype, cfunc, *args): val_p = backend.ffi.new(rtype) args = args + (val_p,) cfunc(*args) return val_p[0]"
            },
            {
                "url": 3442,
                "code": "def _get_type(self, value): if value is None: return type(None) elif type(value) in int_types: return int elif type(value) in float_types: return float elif isinstance(value, binary_type): return binary_type else: return text_type"
            },
            {
                "url": 4049,
                "code": "def types(self): output = set() for var in self.values(): if var.has_value(): output.update(var.types()) return list(output)"
            },
            {
                "url": 516,
                "code": "def dtype(self): try: return self.data.dtype except AttributeError: return numpy.dtype('%s%d' % (self._sample_type, self._sample_bytes))"
            },
            {
                "url": 986,
                "code": "def get_var_type(self, name): name = create_string_buffer(name) type_ = create_string_buffer(MAXSTRLEN) self.library.get_var_type.argtypes = [c_char_p, c_char_p] self.library.get_var_type(name, type_) return type_.value"
            },
            {
                "url": 285,
                "code": "def make_kind_check(python_types, numpy_kind): def check(value): if hasattr(value, 'dtype'): return value.dtype.kind == numpy_kind return isinstance(value, python_types) return check"
            }
        ],
        "url": 5803
    },
    {
        "nl_input": "initializing an empty string with a size python",
        "code_input": [
            {
                "url": 4340,
                "code": "def schunk(string, size): return [string[i:i+size] for i in range(0, len(string), size)]"
            },
            {
                "url": 1511,
                "code": "def chunks(arr, size): for i in _range(0, len(arr), size): yield arr[i:i+size]"
            },
            {
                "url": 424,
                "code": "def _split_str(s, n): length = len(s) return [s[i:i + n] for i in range(0, length, n)]"
            },
            {
                "url": 5338,
                "code": "def generate_chunks(string, num_chars): for start in range(0, len(string), num_chars): yield string[start:start+num_chars]"
            },
            {
                "url": 5830,
                "code": "def pset(iterable=(), pre_size=8): if not iterable: return _EMPTY_PSET return PSet._from_iterable(iterable, pre_size=pre_size)"
            },
            {
                "url": 1962,
                "code": "def __init__(self, ba=None): self.bytearray = ba or (bytearray(b'\\0') * self.SIZEOF)"
            },
            {
                "url": 4337,
                "code": "def chunks(iterable, size=1): iterator = iter(iterable) for element in iterator: yield chain([element], islice(iterator, size - 1))"
            },
            {
                "url": 3224,
                "code": "def split_len(s, length): return [s[i:i+length] for i in range(0, len(s), length)]"
            },
            {
                "url": 2536,
                "code": "def get_iter_string_reader(stdin): bufsize = 1024 iter_str = (stdin[i:i + bufsize] for i in range(0, len(stdin), bufsize)) return get_iter_chunk_reader(iter_str)"
            },
            {
                "url": 276,
                "code": "def random_str(size=10): return ''.join(random.choice(string.ascii_lowercase) for _ in range(size))"
            },
            {
                "url": 4955,
                "code": "def chunks(dictionary, chunk_size): iterable = iter(dictionary) for __ in range(0, len(dictionary), chunk_size): yield {key: dictionary[key] for key in islice(iterable, chunk_size)}"
            },
            {
                "url": 2014,
                "code": "def chkstr(s, v): if type(s) != str: raise TypeError(\"{var} must be str\".format(var=v)) if not s: raise ValueError(\"{var} cannot be empty\".format(var=v))"
            },
            {
                "url": 2538,
                "code": "def to_string(s, encoding='utf-8'): if six.PY2: return s.encode(encoding) if isinstance(s, bytes): return s.decode(encoding) return s"
            },
            {
                "url": 3326,
                "code": "def bytes_to_str(s, encoding='utf-8'): if six.PY3 and isinstance(s, bytes): return s.decode(encoding) return s"
            },
            {
                "url": 4510,
                "code": "def np2str(value): if hasattr(value, 'dtype') and \\ issubclass(value.dtype.type, (np.string_, np.object_)) and value.size == 1: value = np.asscalar(value) if not isinstance(value, str): # python 3 - was scalar numpy array of bytes # otherwise python 2 - scalar numpy array of 'str' value = value.decode() return value else: raise ValueError(\"Array is not a string type or is larger than 1\")"
            }
        ],
        "url": 276
    },
    {
        "nl_input": "cast str as int in python",
        "code_input": [
            {
                "url": 5603,
                "code": "def try_cast_int(s): try: temp = re.findall('\\d', str(s)) temp = ''.join(temp) return int(temp) except: return s"
            },
            {
                "url": 3791,
                "code": "def cast_int(x): try: x = int(x) except ValueError: try: x = x.strip() except AttributeError as e: logger_misc.warn(\"parse_str: AttributeError: String not number or word, {}, {}\".format(x, e)) return x"
            },
            {
                "url": 40,
                "code": "def get_number(s, cast=int): import string d = \"\".join(x for x in str(s) if x in string.digits) return cast(d)"
            },
            {
                "url": 1860,
                "code": "def str2int(string_with_int): return int(\"\".join([char for char in string_with_int if char in string.digits]) or 0)"
            },
            {
                "url": 6171,
                "code": "def convert_to_int(x: Any, default: int = None) -> int: try: return int(x) except (TypeError, ValueError): return default"
            },
            {
                "url": 894,
                "code": "def safe_int_conv(number): try: return int(np.array(number).astype(int, casting='safe')) except TypeError: raise ValueError('cannot safely convert {} to integer'.format(number))"
            },
            {
                "url": 2494,
                "code": "def safe_int(val, default=None): try: val = int(val) except (ValueError, TypeError): val = default return val"
            },
            {
                "url": 5836,
                "code": "def clean_int(x) -> int: try: return int(x) except ValueError: raise forms.ValidationError( \"Cannot convert to integer: {}\".format(repr(x)))"
            },
            {
                "url": 2036,
                "code": "def bin_to_int(string): if isinstance(string, str): return struct.unpack(\"b\", string)[0] else: return struct.unpack(\"b\", bytes([string]))[0]"
            },
            {
                "url": 4197,
                "code": "def str_to_num(str_value): str_value = str(str_value) try: return int(str_value) except ValueError: return float(str_value)"
            },
            {
                "url": 1329,
                "code": "def validate_int(value): if value and not isinstance(value, int): try: int(str(value)) except (TypeError, ValueError): raise ValidationError('not a valid number') return value"
            },
            {
                "url": 1603,
                "code": "def string_to_int( s ): result = 0 for c in s: if not isinstance(c, int): c = ord( c ) result = 256 * result + c return result"
            },
            {
                "url": 4658,
                "code": "def _cast_to_type(self, value): if isinstance(value, str) or value is None: return value return str(value)"
            },
            {
                "url": 1791,
                "code": "def is_int(string): try: a = float(string) b = int(a) except ValueError: return False else: return a == b"
            },
            {
                "url": 5274,
                "code": "def convert_string(string): if is_int(string): return int(string) elif is_float(string): return float(string) elif convert_bool(string)[0]: return convert_bool(string)[1] elif string == 'None': return None else: return string"
            }
        ],
        "url": 5603
    },
    {
        "nl_input": "python, sql table column details",
        "code_input": [
            {
                "url": 277,
                "code": "def get_table_columns(dbconn, tablename): cur = dbconn.cursor() cur.execute(\"PRAGMA table_info('%s');\" % tablename) info = cur.fetchall() cols = [(i[1], i[2]) for i in info] return cols"
            },
            {
                "url": 2535,
                "code": "def column_names(self, table): table_info = self.execute( u'PRAGMA table_info(%s)' % quote(table)) return (column['name'] for column in table_info)"
            },
            {
                "url": 5550,
                "code": "def get_column_names(engine: Engine, tablename: str) -> List[str]: return [info.name for info in gen_columns_info(engine, tablename)]"
            },
            {
                "url": 913,
                "code": "def get_column_keys_and_names(table): ins = inspect(table) return ((k, c.name) for k, c in ins.mapper.c.items())"
            },
            {
                "url": 4131,
                "code": "def _columns_for_table(table_name): return {cname: col for (tname, cname), col in _COLUMNS.items() if tname == table_name}"
            },
            {
                "url": 716,
                "code": "def get_table_names(connection): cursor = connection.cursor() cursor.execute(\"SELECT name FROM sqlite_master WHERE type == 'table'\") return [name for (name,) in cursor]"
            },
            {
                "url": 2834,
                "code": "def get_column_definition(self, table, column): # Parse column definitions for match for col in self.get_column_definition_all(table): if col.strip('`').startswith(column): return col.strip(',')"
            },
            {
                "url": 4514,
                "code": "def _get_column_by_db_name(cls, name): return cls._columns.get(cls._db_map.get(name, name))"
            },
            {
                "url": 4614,
                "code": "def get_table_list(dbconn): cur = dbconn.cursor() cur.execute(\"SELECT name FROM sqlite_master WHERE type='table';\") try: return [item[0] for item in cur.fetchall()] except IndexError: return get_table_list(dbconn)"
            },
            {
                "url": 461,
                "code": "def _get_column_types(self, data): columns = list(zip_longest(*data)) return [self._get_column_type(column) for column in columns]"
            },
            {
                "url": 3007,
                "code": "def prettifysql(sql): pretty = [] for line in sql.split('\\n'): pretty.extend([\"%s,\\n\" % x for x in line.split(',')]) return pretty"
            },
            {
                "url": 389,
                "code": "def columns(self): res = [col['name'] for col in self.column_definitions] res.extend([col['name'] for col in self.foreign_key_definitions]) return res"
            },
            {
                "url": 4517,
                "code": "def add_column(connection, column): stmt = alembic.ddl.base.AddColumn(_State.table.name, column) connection.execute(stmt) _State.reflect_metadata()"
            },
            {
                "url": 1858,
                "code": "def _get_str_columns(sf): return [name for name in sf.column_names() if sf[name].dtype == str]"
            },
            {
                "url": 614,
                "code": "def datatype(dbtype, description, cursor): dt = cursor.db.introspection.get_field_type(dbtype, description) if type(dt) is tuple: return dt[0] else: return dt"
            }
        ],
        "url": 2535
    },
    {
        "nl_input": "python pathlib to traverse directories",
        "code_input": [
            {
                "url": 2643,
                "code": "def recursively_get_files_from_directory(directory): return [ os.path.join(root, filename) for root, directories, filenames in os.walk(directory) for filename in filenames ]"
            },
            {
                "url": 653,
                "code": "def isdir(path, **kwargs): import os.path return os.path.isdir(path, **kwargs)"
            },
            {
                "url": 665,
                "code": "def directory_files(path): for entry in os.scandir(path): if not entry.name.startswith('.') and entry.is_file(): yield entry.name"
            },
            {
                "url": 2459,
                "code": "def listfolderpath(p): for entry in scandir.scandir(p): if entry.is_dir(): yield entry.path"
            },
            {
                "url": 4368,
                "code": "def search_script_directory(self, path): for subdir, dirs, files in os.walk(path): for file_name in files: if file_name.endswith(\".py\"): self.search_script_file(subdir, file_name)"
            },
            {
                "url": 2576,
                "code": "def clean_py_files(path): for dirname, subdirlist, filelist in os.walk(path): for f in filelist: if f.endswith('py'): os.remove(os.path.join(dirname, f))"
            },
            {
                "url": 2992,
                "code": "def get_files(dir_name): return [(os.path.join('.', d), [os.path.join(d, f) for f in files]) for d, _, files in os.walk(dir_name)]"
            },
            {
                "url": 3908,
                "code": "def get_all_files(folder): for path, dirlist, filelist in os.walk(folder): for fn in filelist: yield op.join(path, fn)"
            },
            {
                "url": 3035,
                "code": "def makedirs(path): if not os.path.isdir(path): os.makedirs(path) return path"
            },
            {
                "url": 2022,
                "code": "def setup_path(): import os.path; import sys if sys.argv[0]: top_dir = os.path.dirname(os.path.abspath(sys.argv[0])) sys.path = [os.path.join(top_dir, \"src\")] + sys.path pass return"
            },
            {
                "url": 3817,
                "code": "def safe_mkdir_for(path, clean=False): safe_mkdir(os.path.dirname(path), clean=clean)"
            },
            {
                "url": 1370,
                "code": "def in_directory(path): curdir = os.path.abspath(os.curdir) os.chdir(path) yield os.chdir(curdir)"
            },
            {
                "url": 4916,
                "code": "def create_dir_rec(path: Path): if not path.exists(): Path.mkdir(path, parents=True, exist_ok=True)"
            },
            {
                "url": 2870,
                "code": "def list_files(directory): return [f for f in pathlib.Path(directory).iterdir() if f.is_file() and not f.name.startswith('.')]"
            },
            {
                "url": 3,
                "code": "def create_path(path): import os if not os.path.exists(path): os.makedirs(path)"
            }
        ],
        "url": 2992
    },
    {
        "nl_input": "python create list of columns with their dtype",
        "code_input": [
            {
                "url": 461,
                "code": "def _get_column_types(self, data): columns = list(zip_longest(*data)) return [self._get_column_type(column) for column in columns]"
            },
            {
                "url": 1187,
                "code": "def column_stack_2d(data): return list(list(itt.chain.from_iterable(_)) for _ in zip(*data))"
            },
            {
                "url": 1858,
                "code": "def _get_str_columns(sf): return [name for name in sf.column_names() if sf[name].dtype == str]"
            },
            {
                "url": 2169,
                "code": "def from_array(cls, arr): return cls().with_columns([(f, arr[f]) for f in arr.dtype.names])"
            },
            {
                "url": 5442,
                "code": "def list_of_dict(self): ret = [] for row in self: ret.append(dict([(self._col_names[i], row[i]) for i in range(len(self._col_names))])) return ReprListDict(ret, col_names=self._col_names, col_types=self._col_types, width_limit=self._width_limit, digits=self._digits, convert_unicode=self._convert_unicode)"
            },
            {
                "url": 5803,
                "code": "def dtypes(self): return [(str(f.name), f.dataType.simpleString()) for f in self.schema.fields]"
            },
            {
                "url": 5209,
                "code": "def to_array(self): dt = np.dtype(list(zip(self.labels, (c.dtype for c in self.columns)))) arr = np.empty_like(self.columns[0], dt) for label in self.labels: arr[label] = self[label] return arr"
            },
            {
                "url": 5103,
                "code": "def build_columns(self, X, verbose=False): return sp.sparse.csc_matrix(X[:, self.feature][:, np.newaxis])"
            },
            {
                "url": 1513,
                "code": "def to_dicts(recarray): for rec in recarray: yield dict(zip(recarray.dtype.names, rec.tolist()))"
            },
            {
                "url": 4734,
                "code": "def clean_colnames(df): col_list = [] for index in range(_dutils.cols(df)): col_list.append(df.columns[index].strip().lower().replace(' ','_')) df.columns = col_list"
            },
            {
                "url": 4484,
                "code": "def _maybe_pandas_data(data, feature_names, feature_types): if not isinstance(data, DataFrame): return data, feature_names, feature_types data_dtypes = data.dtypes if not all(dtype.name in PANDAS_DTYPE_MAPPER for dtype in data_dtypes): bad_fields = [data.columns[i] for i, dtype in enumerate(data_dtypes) if dtype.name not in PANDAS_DTYPE_MAPPER] msg = \"\"\"DataFrame.dtypes for data must be int, float or bool. Did not expect the data types in fields \"\"\" raise ValueError(msg + ', '.join(bad_fields)) if feature_names is None: if isinstance(data.columns, MultiIndex): feature_names = [ ' '.join([str(x) for x in i]) for i in data.columns ] else: feature_names = data.columns.format() if feature_types is None: feature_types = [PANDAS_DTYPE_MAPPER[dtype.name] for dtype in data_dtypes] data = data.values.astype('float') return data, feature_names, feature_types"
            },
            {
                "url": 922,
                "code": "def iget_list_column_slice(list_, start=None, stop=None, stride=None): if isinstance(start, slice): slice_ = start else: slice_ = slice(start, stop, stride) return (row[slice_] for row in list_)"
            },
            {
                "url": 2081,
                "code": "def get_dt_list(fn_list): dt_list = np.array([fn_getdatetime(fn) for fn in fn_list]) return dt_list"
            },
            {
                "url": 5746,
                "code": "def csv_to_numpy(string_like, dtype=None): # type: (str) -> np.array stream = StringIO(string_like) return np.genfromtxt(stream, dtype=dtype, delimiter=',')"
            },
            {
                "url": 2705,
                "code": "def _make_index(df, cols=META_IDX): return pd.MultiIndex.from_tuples( pd.unique(list(zip(*[df[col] for col in cols]))), names=tuple(cols))"
            }
        ],
        "url": 1858
    },
    {
        "nl_input": "python turn all nested object to dict",
        "code_input": [
            {
                "url": 364,
                "code": "def dict_from_object(obj: object): # If object is a dict instance, no need to convert. return (obj if isinstance(obj, dict) else {attr: getattr(obj, attr) for attr in dir(obj) if not attr.startswith('_')})"
            },
            {
                "url": 5529,
                "code": "def _zeep_to_dict(cls, obj): res = serialize_object(obj) res = cls._get_non_empty_dict(res) return res"
            },
            {
                "url": 4880,
                "code": "def _convert_dict_to_json(array): return json.dumps( array, skipkeys=False, allow_nan=False, indent=None, separators=(\",\", \":\"), sort_keys=True, default=lambda o: o.__dict__, )"
            },
            {
                "url": 1480,
                "code": "def to_dict(dictish): if hasattr(dictish, 'iterkeys'): m = dictish.iterkeys elif hasattr(dictish, 'keys'): m = dictish.keys else: raise ValueError(dictish) return dict((k, dictish[k]) for k in m())"
            },
            {
                "url": 1389,
                "code": "def stringify_dict_contents(dct): return { str_if_nested_or_str(k): str_if_nested_or_str(v) for k, v in dct.items() }"
            },
            {
                "url": 1367,
                "code": "def list_of_lists_to_dict(l): d = {} for key, val in l: d.setdefault(key, []).append(val) return d"
            },
            {
                "url": 1583,
                "code": "def dict_to_numpy_array(d): return fromarrays(d.values(), np.dtype([(str(k), v.dtype) for k, v in d.items()]))"
            },
            {
                "url": 1843,
                "code": "def list2dict(lst): dic = {} for k,v in lst: dic[k] = v return dic"
            },
            {
                "url": 1059,
                "code": "def _dict_to_proto(py_dict, proto): dict_json_str = json.dumps(py_dict) return json_format.Parse(dict_json_str, proto)"
            },
            {
                "url": 2202,
                "code": "def get_dict_for_attrs(obj, attrs): data = {} for attr in attrs: data[attr] = getattr(obj, attr) return data"
            },
            {
                "url": 1318,
                "code": "def fromDict(cls, _dict): obj = cls() obj.__dict__.update(_dict) return obj"
            },
            {
                "url": 1268,
                "code": "def get_python_dict(scala_map): python_dict = {} keys = get_python_list(scala_map.keys().toList()) for key in keys: python_dict[key] = scala_map.apply(key) return python_dict"
            },
            {
                "url": 3775,
                "code": "def as_dict(self): dicts = [x.as_dict for x in self.children] return {'{0} {1}'.format(self.name, self.value): dicts}"
            },
            {
                "url": 6065,
                "code": "def pretty_describe(object, nestedness=0, indent=2): if not isinstance(object, dict): return str(object) sep = f'\\n{\" \" * nestedness * indent}' out = sep.join((f'{k}: {pretty_describe(v, nestedness + 1)}' for k, v in object.items())) if nestedness > 0 and out: return f'{sep}{out}' return out"
            },
            {
                "url": 3978,
                "code": "def safe_repr(obj): name = getattr(obj, '__name__', getattr(obj.__class__, '__name__')) if name == 'ndict': name = 'dict' return name or repr(obj)"
            }
        ],
        "url": 3775
    },
    {
        "nl_input": "python read dicom images",
        "code_input": [
            {
                "url": 1089,
                "code": "def numpy(self): # load GDCM's image reading functionality image_reader = gdcm.ImageReader() image_reader.SetFileName(self.fname) if not image_reader.Read(): raise IOError(\"Could not read DICOM image\") pixel_array = self._gdcm_to_numpy(image_reader.GetImage()) return pixel_array"
            },
            {
                "url": 369,
                "code": "def imdecode(image_path): import os assert os.path.exists(image_path), image_path + ' not found' im = cv2.imread(image_path) return im"
            },
            {
                "url": 4647,
                "code": "def read_image(filepath): im_bytes = tf.io.read_file(filepath) im = tf.image.decode_image(im_bytes, channels=CHANNELS) im = tf.image.convert_image_dtype(im, tf.float32) return im"
            },
            {
                "url": 2177,
                "code": "def ReadTif(tifFile): img = Image.open(tifFile) img = np.array(img) return img"
            },
            {
                "url": 2547,
                "code": "def url_to_image(url, flag=cv2.IMREAD_COLOR): resp = urlopen(url) image = np.asarray(bytearray(resp.read()), dtype=\"uint8\") image = cv2.imdecode(image, flag) return image"
            },
            {
                "url": 872,
                "code": "def read_img(path): img = cv2.resize(cv2.imread(path, 0), (80, 30)).astype(np.float32) / 255 img = np.expand_dims(img.transpose(1, 0), 0) return img"
            },
            {
                "url": 3771,
                "code": "def load_tiff(file): ndv, xsize, ysize, geot, projection, datatype = get_geo_info(file) data = gdalnumeric.LoadFile(file) data = np.ma.masked_array(data, mask=data == ndv, fill_value=ndv) return data"
            },
            {
                "url": 2485,
                "code": "def load_image(fname): with open(fname, \"rb\") as f: i = Image.open(fname) #i.load() return i"
            },
            {
                "url": 6039,
                "code": "def load_preprocess_images(image_paths: List[str], image_size: tuple) -> List[np.ndarray]: image_size = image_size[1:] # we do not need the number of channels images = [] for image_path in image_paths: images.append(load_preprocess_image(image_path, image_size)) return images"
            },
            {
                "url": 3081,
                "code": "def get_image(self, source): buf = StringIO(source.read()) return Image.open(buf)"
            },
            {
                "url": 4784,
                "code": "def get_img_data(f, maxsize = (1200, 850), first = False): img = Image.open(f) img.thumbnail(maxsize) if first: # tkinter is inactive the first time bio = io.BytesIO() img.save(bio, format = \"PNG\") del img return bio.getvalue() return ImageTk.PhotoImage(img)"
            },
            {
                "url": 4868,
                "code": "def each_img(img_dir): for fname in utils.each_img(img_dir): fname = os.path.join(img_dir, fname) yield cv.imread(fname), fname"
            },
            {
                "url": 666,
                "code": "def read_array(path, mmap_mode=None): file_ext = op.splitext(path)[1] if file_ext == '.npy': return np.load(path, mmap_mode=mmap_mode) raise NotImplementedError(\"The file extension `{}` \".format(file_ext) + \"is not currently supported.\")"
            },
            {
                "url": 2549,
                "code": "def read_numpy(fd, byte_order, dtype, count): return numpy.fromfile(fd, byte_order+dtype[-1], count)"
            },
            {
                "url": 3731,
                "code": "def read(self): stream = BytesIO() self.cam.capture(stream, format='png') # \"Rewind\" the stream to the beginning so we can read its content stream.seek(0) return Image.open(stream)"
            }
        ],
        "url": 1089
    },
    {
        "nl_input": "python making string lower case",
        "code_input": [
            {
                "url": 5588,
                "code": "def lowercase_chars(string: any) -> str: return ''.join([c if c.islower() else '' for c in str(string)])"
            },
            {
                "url": 5614,
                "code": "def _lower(string): if not string: return \"\" new_string = [string[0].lower()] for char in string[1:]: if char.isupper(): new_string.append(\"_\") new_string.append(char.lower()) return \"\".join(new_string)"
            },
            {
                "url": 5595,
                "code": "def lower_camel_case_from_underscores(string): components = string.split('_') string = components[0] for component in components[1:]: string += component[0].upper() + component[1:] return string"
            },
            {
                "url": 3244,
                "code": "def camelcase(string): string = re.sub(r\"^[\\-_\\.]\", '', str(string)) if not string: return string return lowercase(string[0]) + re.sub(r\"[\\-_\\.\\s]([a-z])\", lambda matched: uppercase(matched.group(1)), string[1:])"
            },
            {
                "url": 3327,
                "code": "def clean(some_string, uppercase=False): if uppercase: return some_string.strip().upper() else: return some_string.strip().lower()"
            },
            {
                "url": 5981,
                "code": "def capitalize(string): if not string: return string if len(string) == 1: return string.upper() return string[0].upper() + string[1:].lower()"
            },
            {
                "url": 5592,
                "code": "def gen_lower(x: Iterable[str]) -> Generator[str, None, None]: for string in x: yield string.lower()"
            },
            {
                "url": 718,
                "code": "def camel_case_from_underscores(string): components = string.split('_') string = '' for component in components: string += component[0].upper() + component[1:] return string"
            },
            {
                "url": 4677,
                "code": "def camelcase2list(s, lower=False): s = re.findall(r'([A-Z][a-z0-9]+)', s) return [w.lower() for w in s] if lower else s"
            },
            {
                "url": 1117,
                "code": "def normalise_string(string): string = (string.strip()).lower() return re.sub(r'\\W+', '_', string)"
            },
            {
                "url": 5767,
                "code": "def camel_to_snake_case(string): s = _1.sub(r'\\1_\\2', string) return _2.sub(r'\\1_\\2', s).lower()"
            },
            {
                "url": 5661,
                "code": "def uppercase_chars(string: any) -> str: return ''.join([c if c.isupper() else '' for c in str(string)])"
            },
            {
                "url": 6176,
                "code": "def convert_camel_case_string(name: str) -> str: string = re.sub(\"(.)([A-Z][a-z]+)\", r\"\\1_\\2\", name) return re.sub(\"([a-z0-9])([A-Z])\", r\"\\1_\\2\", string).lower()"
            },
            {
                "url": 725,
                "code": "def downcaseTokens(s,l,t): return [ tt.lower() for tt in map(_ustr,t) ]"
            },
            {
                "url": 5965,
                "code": "def snake_case(a_string): partial = re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', a_string) return re.sub('([a-z0-9])([A-Z])', r'\\1_\\2', partial).lower()"
            }
        ],
        "url": 3683
    },
    {
        "nl_input": "how to implement a macro in python",
        "code_input": [
            {
                "url": 4263,
                "code": "def define_macro(self, name, themacro): from IPython.core import macro if isinstance(themacro, basestring): themacro = macro.Macro(themacro) if not isinstance(themacro, macro.Macro): raise ValueError('A macro must be a string or a Macro instance.') self.user_ns[name] = themacro"
            },
            {
                "url": 5309,
                "code": "def code_from_ipynb(nb, markdown=False): code = PREAMBLE for cell in nb['cells']: if cell['cell_type'] == 'code': # transform the input to executable Python code += ''.join(cell['source']) if cell['cell_type'] == 'markdown': code += '\\n# ' + '# '.join(cell['source']) # We want a blank newline after each cell's output. # And the last line of source doesn't have a newline usually. code += '\\n\\n' return code"
            },
            {
                "url": 477,
                "code": "def runcode(code): for line in code: print('# '+line) exec(line,globals()) print('# return ans') return ans"
            },
            {
                "url": 4133,
                "code": "def method_header(method_name, nogil=False, idx_as_arg=False): if not config.FASTCYTHON: nogil = False header = 'cpdef inline void %s(self' % method_name header += ', int idx)' if idx_as_arg else ')' header += ' nogil:' if nogil else ':' return header"
            },
            {
                "url": 1931,
                "code": "def managepy(cmd, extra=None): extra = extra.split() if extra else [] run_django_cli(['invoke', cmd] + extra)"
            },
            {
                "url": 311,
                "code": "def python_mime(fn): @wraps(fn) def python_mime_decorator(*args, **kwargs): response.content_type = \"text/x-python\" return fn(*args, **kwargs) return python_mime_decorator"
            },
            {
                "url": 4956,
                "code": "def extend_with(func): if not func.__name__ in ArgParseInator._plugins: ArgParseInator._plugins[func.__name__] = func"
            },
            {
                "url": 5526,
                "code": "def python(string: str): return underscore(singularize(string) if Naming._pluralize(string) else string)"
            },
            {
                "url": 5053,
                "code": "def PythonPercentFormat(format_str): if format_str.startswith('printf '): fmt = format_str[len('printf '):] return lambda value: fmt % value else: return None"
            },
            {
                "url": 4458,
                "code": "def _split_python(python): python = _preprocess(python) if not python: return [] lexer = PythonSplitLexer() lexer.read(python) return lexer.chunks"
            },
            {
                "url": 4180,
                "code": "def _multilingual(function, *args, **kwargs): return getattr(_module(kwargs.pop(\"language\", \"en\")), function)(*args, **kwargs)"
            },
            {
                "url": 263,
                "code": "def exec_function(ast, globals_map): locals_map = globals_map exec ast in globals_map, locals_map return locals_map"
            },
            {
                "url": 1784,
                "code": "def _expand(self, str, local_vars={}): return ninja_syntax.expand(str, self.vars, local_vars)"
            },
            {
                "url": 3109,
                "code": "def __call__(self, _): if self.iter % self.step == 0: print(self.fmt.format(self.iter), **self.kwargs) self.iter += 1"
            },
            {
                "url": 4367,
                "code": "def run_func(self, func_path, *func_args, **kwargs): if not self.started: raise ValueError('Session not started, use start()') nargout = kwargs.pop('nargout', 1) func_args += tuple(item for pair in zip(kwargs.keys(), kwargs.values()) for item in pair) dname = os.path.dirname(func_path) fname = os.path.basename(func_path) func_name, ext = os.path.splitext(fname) if ext and not ext == '.m': raise TypeError('Need to give path to .m file') return self._json_response(cmd='eval', func_name=func_name, func_args=func_args or '', dname=dname, nargout=nargout)"
            }
        ],
        "url": 4263
    },
    {
        "nl_input": "python subprocess close stdin",
        "code_input": [
            {
                "url": 3126,
                "code": "def close(self): if self._subprocess is not None: os.killpg(self._subprocess.pid, signal.SIGTERM) self._subprocess = None"
            },
            {
                "url": 3531,
                "code": "def _finish(self): if self._process.returncode is None: self._process.stdin.flush() self._process.stdin.close() self._process.wait() self.closed = True"
            },
            {
                "url": 1194,
                "code": "def disown(cmd): subprocess.Popen(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)"
            },
            {
                "url": 4276,
                "code": "def __exit__(self, *args): sys.stdout = self._orig self._devnull.close()"
            },
            {
                "url": 1997,
                "code": "async def terminate(self): self.proc.terminate() await asyncio.wait_for(self.proc.wait(), self.kill_delay) if self.proc.returncode is None: self.proc.kill() await self.proc.wait() await super().terminate()"
            },
            {
                "url": 1064,
                "code": "def call_and_exit(self, cmd, shell=True): sys.exit(subprocess.call(cmd, shell=shell))"
            },
            {
                "url": 271,
                "code": "def cli_command_quit(self, msg): if self.state == State.RUNNING and self.sprocess and self.sprocess.proc: self.sprocess.proc.kill() else: sys.exit(0)"
            },
            {
                "url": 2327,
                "code": "def kill_mprocess(process): if process and proc_alive(process): process.terminate() process.communicate() return not proc_alive(process)"
            },
            {
                "url": 2728,
                "code": "def process_kill(pid, sig=None): sig = sig or signal.SIGTERM os.kill(pid, sig)"
            },
            {
                "url": 6074,
                "code": "def _exit(self, status_code): # If there are active threads still running infinite loops, sys.exit # won't kill them but os._exit will. os._exit skips calling cleanup # handlers, flushing stdio buffers, etc. exit_func = os._exit if threading.active_count() > 1 else sys.exit exit_func(status_code)"
            },
            {
                "url": 4558,
                "code": "def close(self): try: self._conn.send((self._CLOSE, None)) self._conn.close() except IOError: # The connection was already closed. pass self._process.join()"
            },
            {
                "url": 212,
                "code": "def _stdin_ready_posix(): infds, outfds, erfds = select.select([sys.stdin],[],[],0) return bool(infds)"
            },
            {
                "url": 609,
                "code": "def call_out(command): # start external command process p = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE) # get outputs out, _ = p.communicate() return p.returncode, out.strip()"
            },
            {
                "url": 2277,
                "code": "def kill(self): if self.process: self.process.kill() self.process.wait()"
            },
            {
                "url": 2428,
                "code": "def correspond(text): subproc.stdin.write(text) subproc.stdin.flush() return drain()"
            }
        ],
        "url": 3531
    },
    {
        "nl_input": "sum within a comprehension python",
        "code_input": [
            {
                "url": 2917,
                "code": "def async_comp_check(self, original, loc, tokens): return self.check_py(\"36\", \"async comprehension\", original, loc, tokens)"
            },
            {
                "url": 2195,
                "code": "def query_sum(queryset, field): return queryset.aggregate(s=models.functions.Coalesce(models.Sum(field), 0))['s']"
            },
            {
                "url": 361,
                "code": "def cumsum(inlist): newlist = copy.deepcopy(inlist) for i in range(1, len(newlist)): newlist[i] = newlist[i] + newlist[i - 1] return newlist"
            },
            {
                "url": 5277,
                "code": "def smartSum(x,key,value): if key not in list(x.keys()): x[key] = value else: x[key]+=value"
            },
            {
                "url": 325,
                "code": "def _accumulate(sequence, func): iterator = iter(sequence) total = next(iterator) yield total for element in iterator: total = func(total, element) yield total"
            },
            {
                "url": 1206,
                "code": "def lcumsum (inlist): newlist = copy.deepcopy(inlist) for i in range(1,len(newlist)): newlist[i] = newlist[i] + newlist[i-1] return newlist"
            },
            {
                "url": 1278,
                "code": "def mean(inlist): sum = 0 for item in inlist: sum = sum + item return sum / float(len(inlist))"
            },
            {
                "url": 2060,
                "code": "def _cumprod(l): ret = [1] for item in l: ret.append(ret[-1] * item) return ret"
            },
            {
                "url": 2665,
                "code": "def Sum(a, axis, keep_dims): return np.sum(a, axis=axis if not isinstance(axis, np.ndarray) else tuple(axis), keepdims=keep_dims),"
            },
            {
                "url": 475,
                "code": "def visit_BoolOp(self, node): return sum((self.visit(value) for value in node.values), [])"
            },
            {
                "url": 5886,
                "code": "def reduce(function, initval=None): if initval is None: return lambda s: __builtin__.reduce(function, s) else: return lambda s: __builtin__.reduce(function, s, initval)"
            },
            {
                "url": 272,
                "code": "def dot(self, w): return sum([x * y for x, y in zip(self, w)])"
            },
            {
                "url": 5560,
                "code": "def _sum_cycles_from_tokens(self, tokens: List[str]) -> int: return sum((int(self._nonnumber_pattern.sub('', t)) for t in tokens))"
            },
            {
                "url": 3674,
                "code": "def consts(self): # We cannot use a set comprehension because consts do not need # to be hashable. consts = [] append_const = consts.append for instr in self.instrs: if isinstance(instr, LOAD_CONST) and instr.arg not in consts: append_const(instr.arg) return tuple(consts)"
            },
            {
                "url": 2056,
                "code": "def compose_all(tups): from . import ast # I weep for humanity return functools.reduce(lambda x, y: x.compose(y), map(ast.make_tuple, tups), ast.make_tuple({}))"
            }
        ],
        "url": 325
    },
    {
        "nl_input": "python timedelta without microseconds",
        "code_input": [
            {
                "url": 4766,
                "code": "def timedelta_seconds(timedelta): return (timedelta.total_seconds() if hasattr(timedelta, \"total_seconds\") else timedelta.days * 24 * 3600 + timedelta.seconds + timedelta.microseconds / 1000000.)"
            },
            {
                "url": 1263,
                "code": "def timestamp_to_datetime(timestamp): from datetime import datetime, timedelta obj = datetime.fromtimestamp(timestamp[0]) return obj + timedelta(microseconds=int(timestamp[1]))"
            },
            {
                "url": 2438,
                "code": "def timedelta2millisecond(td): milliseconds = td.days * 24 * 60 * 60 * 1000 milliseconds += td.seconds * 1000 milliseconds += td.microseconds / 1000 return milliseconds"
            },
            {
                "url": 2766,
                "code": "def datetime_to_timestamp(dt): delta = dt - datetime.utcfromtimestamp(0) return delta.seconds + delta.days * 24 * 3600"
            },
            {
                "url": 1704,
                "code": "def from_timestamp(microsecond_timestamp): # Create datetime without losing precision from floating point (yes, this # is actually needed): return datetime.datetime.fromtimestamp( microsecond_timestamp // 1000000, datetime.timezone.utc ).replace(microsecond=(microsecond_timestamp % 1000000))"
            },
            {
                "url": 4885,
                "code": "def total_seconds(td): secs = td.seconds + td.days * 24 * 3600 if td.microseconds: secs += 1 return secs"
            },
            {
                "url": 2902,
                "code": "def datetime_delta_to_ms(delta): delta_ms = delta.days * 24 * 60 * 60 * 1000 delta_ms += delta.seconds * 1000 delta_ms += delta.microseconds / 1000 delta_ms = int(delta_ms) return delta_ms"
            },
            {
                "url": 4056,
                "code": "def convertDatetime(t): epoch = datetime.datetime.utcfromtimestamp(0) delta = t - epoch millis = delta.total_seconds() * 1000 return int(millis)"
            },
            {
                "url": 1259,
                "code": "def ms_to_datetime(ms): dt = datetime.datetime.utcfromtimestamp(ms / 1000) return dt.replace(microsecond=(ms % 1000) * 1000).replace(tzinfo=pytz.utc)"
            },
            {
                "url": 119,
                "code": "def ToDatetime(self): return datetime.utcfromtimestamp( self.seconds + self.nanos / float(_NANOS_PER_SECOND))"
            },
            {
                "url": 115,
                "code": "def datetime_to_ms(dt): seconds = calendar.timegm(dt.utctimetuple()) return seconds * 1000 + int(dt.microsecond / 1000)"
            },
            {
                "url": 2788,
                "code": "def convert_timeval(seconds_since_epoch): frac, whole = math.modf(seconds_since_epoch) microseconds = math.floor(frac * 1000000) seconds = math.floor(whole) return seconds, microseconds"
            },
            {
                "url": 6005,
                "code": "def run_time() -> timedelta: delta = start_time if start_time else datetime.utcnow() return datetime.utcnow() - delta"
            },
            {
                "url": 3713,
                "code": "def time2seconds(t): return t.hour * 3600 + t.minute * 60 + t.second + float(t.microsecond) / 1e6"
            },
            {
                "url": 3262,
                "code": "def timediff(time): now = datetime.datetime.utcnow() diff = now - time diff_sec = diff.total_seconds() return diff_sec"
            }
        ],
        "url": 4766
    },
    {
        "nl_input": "change python object to string",
        "code_input": [
            {
                "url": 4526,
                "code": "def get_object_as_string(obj): if isinstance(obj, str): return obj if isinstance(obj, list): return '\\r\\n\\;'.join([get_object_as_string(item) for item in obj]) attrs = vars(obj) as_string = ', '.join(\"%s: %s\" % item for item in attrs.items()) return as_string"
            },
            {
                "url": 2806,
                "code": "def to_str(obj): if not isinstance(obj, str) and PY3 and isinstance(obj, bytes): obj = obj.decode('utf-8') return obj if isinstance(obj, string_types) else str(obj)"
            },
            {
                "url": 4237,
                "code": "def _tostr(self,obj): if not obj: return '' if isinstance(obj, list): return ', '.join(map(self._tostr, obj)) return str(obj)"
            },
            {
                "url": 1439,
                "code": "def seq_to_str(obj, sep=\",\"): if isinstance(obj, string_classes): return obj elif isinstance(obj, (list, tuple)): return sep.join([str(x) for x in obj]) else: return str(obj)"
            },
            {
                "url": 4042,
                "code": "def obj_to_string(obj, top=True): obj = prepare_for_json_encoding(obj) if type(obj) == six.text_type: return obj return json.dumps(obj)"
            },
            {
                "url": 2538,
                "code": "def to_string(s, encoding='utf-8'): if six.PY2: return s.encode(encoding) if isinstance(s, bytes): return s.decode(encoding) return s"
            },
            {
                "url": 1942,
                "code": "def _get_pretty_string(obj): sio = StringIO() pprint.pprint(obj, stream=sio) return sio.getvalue()"
            },
            {
                "url": 1451,
                "code": "def to_str(s): if isinstance(s, bytes): s = s.decode('utf-8') elif not isinstance(s, str): s = str(s) return s"
            },
            {
                "url": 4120,
                "code": "def object_to_json(obj): if isinstance(obj, (datetime.datetime, datetime.date, datetime.time)): return obj.isoformat() return str(obj)"
            },
            {
                "url": 5541,
                "code": "def string(value) -> str: return system_json.dumps(Json(value).safe_object(), ensure_ascii=False)"
            },
            {
                "url": 1758,
                "code": "def to_json(obj): i = StringIO.StringIO() w = Writer(i, encoding='UTF-8') w.write_value(obj) return i.getvalue()"
            },
            {
                "url": 1789,
                "code": "def is_string(obj): if PYTHON3: str_type = (bytes, str) else: str_type = (bytes, str, unicode) return isinstance(obj, str_type)"
            },
            {
                "url": 1121,
                "code": "def check_str(obj): if isinstance(obj, str): return obj if isinstance(obj, float): return str(int(obj)) else: return str(obj)"
            },
            {
                "url": 1935,
                "code": "def object_to_json(obj, indent=2): instance_json = json.dumps(obj, indent=indent, ensure_ascii=False, cls=DjangoJSONEncoder) return instance_json"
            },
            {
                "url": 722,
                "code": "def force_to_string(unknown): result = '' if type(unknown) is str: result = unknown if type(unknown) is int: result = str(unknown) if type(unknown) is float: result = str(unknown) if type(unknown) is dict: result = Dict2String(unknown) if type(unknown) is list: result = List2String(unknown) return result"
            }
        ],
        "url": 5541
    },
    {
        "nl_input": "eit request header in python flask",
        "code_input": [
            {
                "url": 5922,
                "code": "def _request(self, method: str, endpoint: str, params: dict = None, data: dict = None, headers: dict = None) -> dict:"
            },
            {
                "url": 5042,
                "code": "def request(self, method, url, body=None, headers={}): self._send_request(method, url, body, headers)"
            },
            {
                "url": 1456,
                "code": "def get_trace_id_from_flask(): if flask is None or not flask.request: return None header = flask.request.headers.get(_FLASK_TRACE_HEADER) if header is None: return None trace_id = header.split(\"/\", 1)[0] return trace_id"
            },
            {
                "url": 3330,
                "code": "def setup_request_sessions(self): self.req_session = requests.Session() self.req_session.headers.update(self.headers)"
            },
            {
                "url": 310,
                "code": "def handleFlaskPostRequest(flaskRequest, endpoint): if flaskRequest.method == \"POST\": return handleHttpPost(flaskRequest, endpoint) elif flaskRequest.method == \"OPTIONS\": return handleHttpOptions() else: raise exceptions.MethodNotAllowedException()"
            },
            {
                "url": 4256,
                "code": "def get_from_headers(request, key): value = request.headers.get(key) return to_native(value)"
            },
            {
                "url": 2301,
                "code": "def requests_request(method, url, **kwargs): session = local_sessions.session response = session.request(method=method, url=url, **kwargs) session.close() return response"
            },
            {
                "url": 2496,
                "code": "def process_request(self, request, response): self.logger.info('Requested: {0} {1} {2}'.format(request.method, request.relative_uri, request.content_type))"
            },
            {
                "url": 3067,
                "code": "def _decode_request(self, encoded_request): obj = self.serializer.loads(encoded_request) return request_from_dict(obj, self.spider)"
            },
            {
                "url": 3213,
                "code": "def log_request(self, code='-', size='-'): if self.server.logRequests: BaseHTTPServer.BaseHTTPRequestHandler.log_request(self, code, size)"
            },
            {
                "url": 1102,
                "code": "def get_header(request, header_service): service = request.META.get('HTTP_{}'.format(header_service), b'') if isinstance(service, str): # Work around django test client oddness service = service.encode(HTTP_HEADER_ENCODING) return service"
            },
            {
                "url": 2840,
                "code": "def getFlaskResponse(responseString, httpStatus=200): return flask.Response(responseString, status=httpStatus, mimetype=MIMETYPE)"
            },
            {
                "url": 3345,
                "code": "def _request(self, data): return requests.post(self.endpoint, data=data.encode(\"ascii\")).content"
            },
            {
                "url": 4985,
                "code": "def getheader(self, name, default=None): return self.aiohttp_response.headers.get(name, default)"
            },
            {
                "url": 3156,
                "code": "def pretty_print_post(req): print(('{}\\n{}\\n{}\\n\\n{}'.format( '-----------START-----------', req.method + ' ' + req.url, '\\n'.join('{}: {}'.format(k, v) for k, v in list(req.headers.items())), req.body, )))"
            }
        ],
        "url": 1456
    },
    {
        "nl_input": "python lower all elements in list",
        "code_input": [
            {
                "url": 5592,
                "code": "def gen_lower(x: Iterable[str]) -> Generator[str, None, None]: for string in x: yield string.lower()"
            },
            {
                "url": 5614,
                "code": "def _lower(string): if not string: return \"\" new_string = [string[0].lower()] for char in string[1:]: if char.isupper(): new_string.append(\"_\") new_string.append(char.lower()) return \"\".join(new_string)"
            },
            {
                "url": 4780,
                "code": "def _upper(val_list): res = [] for ele in val_list: res.append(ele.upper()) return res"
            },
            {
                "url": 4677,
                "code": "def camelcase2list(s, lower=False): s = re.findall(r'([A-Z][a-z0-9]+)', s) return [w.lower() for w in s] if lower else s"
            },
            {
                "url": 5588,
                "code": "def lowercase_chars(string: any) -> str: return ''.join([c if c.islower() else '' for c in str(string)])"
            },
            {
                "url": 5595,
                "code": "def lower_camel_case_from_underscores(string): components = string.split('_') string = components[0] for component in components[1:]: string += component[0].upper() + component[1:] return string"
            },
            {
                "url": 725,
                "code": "def downcaseTokens(s,l,t): return [ tt.lower() for tt in map(_ustr,t) ]"
            },
            {
                "url": 3464,
                "code": "def normalize_enum_constant(s): if s.islower(): return s if s.isupper(): return s.lower() return \"\".join(ch if ch.islower() else \"_\" + ch.lower() for ch in s).strip(\"_\")"
            },
            {
                "url": 3327,
                "code": "def clean(some_string, uppercase=False): if uppercase: return some_string.strip().upper() else: return some_string.strip().lower()"
            },
            {
                "url": 939,
                "code": "def lowstrip(term): term = re.sub('\\s+', ' ', term) term = term.lower() return term"
            },
            {
                "url": 2136,
                "code": "def allsame(list_, strict=True): if len(list_) == 0: return True first_item = list_[0] return list_all_eq_to(list_, first_item, strict)"
            },
            {
                "url": 1566,
                "code": "def _to_lower_alpha_only(s): s = re.sub(r'\\n', ' ', s.lower()) return re.sub(r'[^a-z\\s]', '', s)"
            },
            {
                "url": 718,
                "code": "def camel_case_from_underscores(string): components = string.split('_') string = '' for component in components: string += component[0].upper() + component[1:] return string"
            },
            {
                "url": 524,
                "code": "def list_add_capitalize(l): nl = [] for i in l: nl.append(i) if hasattr(i, \"capitalize\"): nl.append(i.capitalize()) return list(set(nl))"
            },
            {
                "url": 1206,
                "code": "def lcumsum (inlist): newlist = copy.deepcopy(inlist) for i in range(1,len(newlist)): newlist[i] = newlist[i] + newlist[i-1] return newlist"
            }
        ],
        "url": 5592
    },
    {
        "nl_input": "using sort to move element in to new position in list python",
        "code_input": [
            {
                "url": 3348,
                "code": "def insort_no_dup(lst, item): import bisect ix = bisect.bisect_left(lst, item) if lst[ix] != item: lst[ix:ix] = [item]"
            },
            {
                "url": 1236,
                "code": "def list_move_to_front(l,value='other'): l=list(l) if value in l: l.remove(value) l.insert(0,value) return l"
            },
            {
                "url": 6186,
                "code": "def insert_ordered(value, array): index = 0 # search for the last array item that value is larger than for n in range(0,len(array)): if value >= array[n]: index = n+1 array.insert(index, value) return index"
            },
            {
                "url": 953,
                "code": "def sorted_index(values, x): i = bisect_left(values, x) j = bisect_right(values, x) return values[i:j].index(x) + i"
            },
            {
                "url": 3655,
                "code": "def deduplicate(list_object): new = [] for item in list_object: if item not in new: new.append(item) return new"
            },
            {
                "url": 5770,
                "code": "def natural_sort(list_to_sort: Iterable[str]) -> List[str]: return sorted(list_to_sort, key=natural_keys)"
            },
            {
                "url": 1985,
                "code": "def binSearch(arr, val): i = bisect_left(arr, val) if i != len(arr) and arr[i] == val: return i return -1"
            },
            {
                "url": 4334,
                "code": "def natural_sort(list, key=lambda s:s): def get_alphanum_key_func(key): convert = lambda text: int(text) if text.isdigit() else text return lambda s: [convert(c) for c in re.split('([0-9]+)', key(s))] sort_key = get_alphanum_key_func(key) list.sort(key=sort_key)"
            },
            {
                "url": 1588,
                "code": "def bisect_index(a, x): i = bisect.bisect_left(a, x) if i != len(a) and a[i] == x: return i raise ValueError"
            },
            {
                "url": 2641,
                "code": "def unsort_vector(data, indices_of_increasing): return numpy.array([data[indices_of_increasing.index(i)] for i in range(len(data))])"
            },
            {
                "url": 361,
                "code": "def cumsum(inlist): newlist = copy.deepcopy(inlist) for i in range(1, len(newlist)): newlist[i] = newlist[i] + newlist[i - 1] return newlist"
            },
            {
                "url": 2433,
                "code": "def purge_duplicates(list_in): _list = [] for item in list_in: if item not in _list: _list.append(item) return _list"
            },
            {
                "url": 721,
                "code": "def dedupe_list(l): result = [] for el in l: if el not in result: result.append(el) return result"
            },
            {
                "url": 356,
                "code": "def issorted(list_, op=operator.le): return all(op(list_[ix], list_[ix + 1]) for ix in range(len(list_) - 1))"
            },
            {
                "url": 1049,
                "code": "def uniquify_list(L): return [e for i, e in enumerate(L) if L.index(e) == i]"
            }
        ],
        "url": 3348
    },
    {
        "nl_input": "remove special characters from column names in python",
        "code_input": [
            {
                "url": 4734,
                "code": "def clean_colnames(df): col_list = [] for index in range(_dutils.cols(df)): col_list.append(df.columns[index].strip().lower().replace(' ','_')) df.columns = col_list"
            },
            {
                "url": 5616,
                "code": "def clean_column_names(df: DataFrame) -> DataFrame: f = df.copy() f.columns = [col.strip() for col in f.columns] return f"
            },
            {
                "url": 6049,
                "code": "def normalize_column_names(df): r columns = df.columns if hasattr(df, 'columns') else df columns = [c.lower().replace(' ', '_') for c in columns] return columns"
            },
            {
                "url": 877,
                "code": "def _drop_str_columns(df): str_columns = filter(lambda pair: pair[1].char == 'S', df._gather_dtypes().items()) str_column_names = list(map(lambda pair: pair[0], str_columns)) return df.drop(str_column_names)"
            },
            {
                "url": 1437,
                "code": "def strip_columns(tab): for colname in tab.colnames: if tab[colname].dtype.kind in ['S', 'U']: tab[colname] = np.core.defchararray.strip(tab[colname])"
            },
            {
                "url": 3935,
                "code": "def _remove_nonascii(self, df): df_copy = df.copy(deep=True) for col in df_copy.columns: if (df_copy[col].dtype == np.dtype('O')): df_copy[col] = df[col].apply( lambda x: re.sub(r'[^\\x00-\\x7f]', r'', x) if isinstance(x, six.string_types) else x) return df_copy"
            },
            {
                "url": 1101,
                "code": "def del_Unnamed(df): cols_del=[c for c in df.columns if 'Unnamed' in c] return df.drop(cols_del,axis=1)"
            },
            {
                "url": 5340,
                "code": "def _clean_up_name(self, name): for n in self.naughty: name = name.replace(n, '_') return name"
            },
            {
                "url": 3705,
                "code": "def normalize(name): # Name should not contain some specials chars (issue #1068) ret = name.replace(':', '') ret = ret.replace('%', '') ret = ret.replace(' ', '_') return ret"
            },
            {
                "url": 1462,
                "code": "def stringify_col(df, col_name): df = df.copy() df[col_name] = df[col_name].fillna(\"\") df[col_name] = df[col_name].astype(str) return df"
            },
            {
                "url": 4809,
                "code": "def columnclean(column): cleanedcolumn = str(column) \\ .replace('%', 'percent') \\ .replace('(', '_') \\ .replace(')', '') \\ .replace('As', 'Adenosines') \\ .replace('Cs', 'Cytosines') \\ .replace('Gs', 'Guanines') \\ .replace('Ts', 'Thymines') \\ .replace('Ns', 'Unknowns') \\ .replace('index', 'adapterIndex') return cleanedcolumn"
            },
            {
                "url": 1651,
                "code": "def _clean_str(self, s): return s.translate(str.maketrans('', '', punctuation)).replace('\\u200b', \" \").strip().lower()"
            },
            {
                "url": 390,
                "code": "def remove_non_magic_cols(self): for table_name in self.tables: table = self.tables[table_name] table.remove_non_magic_cols_from_table()"
            },
            {
                "url": 1117,
                "code": "def normalise_string(string): string = (string.strip()).lower() return re.sub(r'\\W+', '_', string)"
            },
            {
                "url": 839,
                "code": "def remove_bad(string): remove = [':', ',', '(', ')', ' ', '|', ';', '\\''] for c in remove: string = string.replace(c, '_') return string"
            }
        ],
        "url": 6049
    },
    {
        "nl_input": "calculate the average of a given list in python",
        "code_input": [
            {
                "url": 2957,
                "code": "def calc_list_average(l): total = 0.0 for value in l: total += value return total / len(l)"
            },
            {
                "url": 1530,
                "code": "def average(arr): if len(arr) == 0: sys.stderr.write(\"ERROR: no content in array to take average\\n\") sys.exit() if len(arr) == 1: return arr[0] return float(sum(arr))/float(len(arr))"
            },
            {
                "url": 1278,
                "code": "def mean(inlist): sum = 0 for item in inlist: sum = sum + item return sum / float(len(inlist))"
            },
            {
                "url": 78,
                "code": "def average(iterator): count = 0 total = 0 for num in iterator: count += 1 total += num return float(total)/count"
            },
            {
                "url": 5718,
                "code": "def average_arrays(arrays: List[mx.nd.NDArray]) -> mx.nd.NDArray: if not arrays: raise ValueError(\"arrays is empty.\") if len(arrays) == 1: return arrays[0] check_condition(all(arrays[0].shape == a.shape for a in arrays), \"nd array shapes do not match\") return mx.nd.add_n(*arrays) / len(arrays)"
            },
            {
                "url": 3025,
                "code": "def moving_average(array, n=3): ret = _np.cumsum(array, dtype=float) ret[n:] = ret[n:] - ret[:-n] return ret[n - 1:] / n"
            },
            {
                "url": 5908,
                "code": "def moving_average(iterable, n): it = iter(iterable) d = collections.deque(itertools.islice(it, n - 1)) d.appendleft(0) s = sum(d) for elem in it: s += elem - d.popleft() d.append(elem) yield s / float(n)"
            },
            {
                "url": 4408,
                "code": "def moving_average(a, n): ret = np.cumsum(a, dtype=float) ret[n:] = ret[n:] - ret[:-n] return ret[n - 1:] / n"
            },
            {
                "url": 6111,
                "code": "def moving_average(arr: np.ndarray, n: int = 3) -> np.ndarray: ret = np.cumsum(arr, dtype=float) ret[n:] = ret[n:] - ret[:-n] return ret[n - 1:] / n"
            },
            {
                "url": 2930,
                "code": "def get_average_color(colors): c = reduce(color_reducer, colors) total = len(colors) return tuple(v / total for v in c)"
            },
            {
                "url": 99,
                "code": "def mean_date(dt_list): dt_list_sort = sorted(dt_list) dt_list_sort_rel = [dt - dt_list_sort[0] for dt in dt_list_sort] avg_timedelta = sum(dt_list_sort_rel, timedelta())/len(dt_list_sort_rel) return dt_list_sort[0] + avg_timedelta"
            },
            {
                "url": 1531,
                "code": "def _aggr_mean(inList): aggrSum = 0 nonNone = 0 for elem in inList: if elem != SENTINEL_VALUE_FOR_MISSING_DATA: aggrSum += elem nonNone += 1 if nonNone != 0: return aggrSum / nonNone else: return None"
            },
            {
                "url": 1529,
                "code": "def _mean_dict(dict_list): return {k: np.array([d[k] for d in dict_list]).mean() for k in dict_list[0].keys()}"
            },
            {
                "url": 360,
                "code": "def get_average_length_of_string(strings): if not strings: return 0 return sum(len(word) for word in strings) / len(strings)"
            },
            {
                "url": 1350,
                "code": "def average_gradient(data, *kwargs): return np.average(np.array(np.gradient(data))**2)"
            }
        ],
        "url": 1278
    },
    {
        "nl_input": "past python git clone",
        "code_input": [
            {
                "url": 2738,
                "code": "def clone_with_copy(src_path, dest_path): log.info('Cloning directory tree %s to %s', src_path, dest_path) shutil.copytree(src_path, dest_path)"
            },
            {
                "url": 632,
                "code": "def check_git(): try: with open(os.devnull, \"wb\") as devnull: subprocess.check_call([\"git\", \"--version\"], stdout=devnull, stderr=devnull) except: raise RuntimeError(\"Please make sure git is installed and on your path.\")"
            },
            {
                "url": 2666,
                "code": "def is_git_repo(): cmd = \"git\", \"rev-parse\", \"--git-dir\" try: subprocess.run(cmd, stdout=subprocess.DEVNULL, check=True) return True except subprocess.CalledProcessError: return False"
            },
            {
                "url": 4078,
                "code": "def install_plugin(username, repo): print(\"Installing plugin from \" + username + \"/\" + repo) pip.main(['install', '-U', \"git+git://github.com/\" + username + \"/\" + repo + \".git\"])"
            },
            {
                "url": 5245,
                "code": "def activate(): # This is derived from the clone cli = CommandLineInterface() cli.ensure_config() cli.write_dockerfile() cli.build() cli.run()"
            },
            {
                "url": 1869,
                "code": "def get_git_branch(git_path='git'): branch_match = call((git_path, 'rev-parse', '--symbolic-full-name', 'HEAD')) if branch_match == \"HEAD\": return None else: return os.path.basename(branch_match)"
            },
            {
                "url": 2885,
                "code": "def get_current_branch(): cmd = [\"git\", \"rev-parse\", \"--abbrev-ref\", \"HEAD\"] output = subprocess.check_output(cmd, stderr=subprocess.STDOUT) return output.strip().decode(\"utf-8\")"
            },
            {
                "url": 5593,
                "code": "def last_commit(self) -> Tuple: from libs.repos import git return git.get_last_commit(repo_path=self.path)"
            },
            {
                "url": 4425,
                "code": "def mkhead(repo, path): return git.Head(repo, git.Head.to_full_path(path))"
            },
            {
                "url": 997,
                "code": "def _makes_clone(_func, *args, **kw): self = args[0]._clone() _func(self, *args[1:], **kw) return self"
            },
            {
                "url": 2068,
                "code": "def is_changed(): executed, changed_lines = execute_git('status --porcelain', output=False) merge_not_finished = mod_path.exists('.git/MERGE_HEAD') return changed_lines.strip() or merge_not_finished"
            },
            {
                "url": 5244,
                "code": "def clone(src, **kwargs): obj = object.__new__(type(src)) obj.__dict__.update(src.__dict__) obj.__dict__.update(kwargs) return obj"
            },
            {
                "url": 3189,
                "code": "def fetch_hg_push_log(repo_name, repo_url): newrelic.agent.add_custom_parameter(\"repo_name\", repo_name) process = HgPushlogProcess() process.run(repo_url + '/json-pushes/?full=1&version=2', repo_name)"
            },
            {
                "url": 6051,
                "code": "def branches(): # type: () -> List[str] out = shell.run( 'git branch', capture=True, never_pretend=True ).stdout.strip() return [x.strip('* \\t\\n') for x in out.splitlines()]"
            },
            {
                "url": 421,
                "code": "def get_last_commit(git_path=None): if git_path is None: git_path = GIT_PATH line = get_last_commit_line(git_path) revision_id = line.split()[1] return revision_id"
            }
        ],
        "url": 4425
    },
    {
        "nl_input": "python lambda function with 3 params",
        "code_input": [
            {
                "url": 3361,
                "code": "def lambda_tuple_converter(func): if func is not None and func.__code__.co_argcount == 1: return lambda *args: func(args[0] if len(args) == 1 else args) else: return func"
            },
            {
                "url": 1406,
                "code": "def lambda_from_file(python_file): lambda_function = [] with open(python_file, 'r') as f: lambda_function.extend(f.read().splitlines()) return awslambda.Code(ZipFile=(Join('\\n', lambda_function)))"
            },
            {
                "url": 2067,
                "code": "def make_lambda(call): empty_args = ast.arguments(args=[], vararg=None, kwarg=None, defaults=[]) return ast.Lambda(args=empty_args, body=call)"
            },
            {
                "url": 6076,
                "code": "def head(self) -> Any: lambda_list = self._get_value() return lambda_list(lambda head, _: head)"
            },
            {
                "url": 4016,
                "code": "def pool_args(function, sequence, kwargs): return zip(itertools.repeat(function), sequence, itertools.repeat(kwargs))"
            },
            {
                "url": 5886,
                "code": "def reduce(function, initval=None): if initval is None: return lambda s: __builtin__.reduce(function, s) else: return lambda s: __builtin__.reduce(function, s, initval)"
            },
            {
                "url": 137,
                "code": "def decorator(func): r def wrapper(__decorated__=None, *Args, **KwArgs): if __decorated__ is None: # the decorator has some optional arguments. return lambda _func: func(_func, *Args, **KwArgs) else: return func(__decorated__, *Args, **KwArgs) return wrap(wrapper, func)"
            },
            {
                "url": 5441,
                "code": "def tuple_check(*args, func=None): func = func or inspect.stack()[2][3] for var in args: if not isinstance(var, (tuple, collections.abc.Sequence)): name = type(var).__name__ raise TupleError( f'Function {func} expected tuple, {name} got instead.')"
            },
            {
                "url": 2631,
                "code": "def create_aws_lambda(ctx, bucket, region_name, aws_access_key_id, aws_secret_access_key): from canari.commands.create_aws_lambda import create_aws_lambda create_aws_lambda(ctx.project, bucket, region_name, aws_access_key_id, aws_secret_access_key)"
            },
            {
                "url": 4204,
                "code": "def _varargs_to_iterable_method(func): def wrapped(self, iterable, **kwargs): return func(self, *iterable, **kwargs) return wrapped"
            },
            {
                "url": 2498,
                "code": "def map(cls, iterable, func, *a, **kw): return cls(func(x, *a, **kw) for x in iterable)"
            },
            {
                "url": 1714,
                "code": "def generator_to_list(fn): def wrapper(*args, **kw): return list(fn(*args, **kw)) return wrapper"
            },
            {
                "url": 1433,
                "code": "def def_linear(fun): defjvp_argnum(fun, lambda argnum, g, ans, args, kwargs: fun(*subval(args, argnum, g), **kwargs))"
            },
            {
                "url": 2069,
                "code": "def apply_kwargs(func, **kwargs): new_kwargs = {} params = signature(func).parameters for param_name in params.keys(): if param_name in kwargs: new_kwargs[param_name] = kwargs[param_name] return func(**new_kwargs)"
            },
            {
                "url": 3554,
                "code": "def get_function(function_name): module, basename = str(function_name).rsplit('.', 1) try: return getattr(__import__(module, fromlist=[basename]), basename) except (ImportError, AttributeError): raise FunctionNotFound(function_name)"
            }
        ],
        "url": 2067
    },
    {
        "nl_input": "check for punctuation python",
        "code_input": [
            {
                "url": 3520,
                "code": "def is_punctuation(text): return not (text.lower() in config.AVRO_VOWELS or text.lower() in config.AVRO_CONSONANTS)"
            },
            {
                "url": 749,
                "code": "def is_delimiter(line): return bool(line) and line[0] in punctuation and line[0]*len(line) == line"
            },
            {
                "url": 1838,
                "code": "def unpunctuate(s, *, char_blacklist=string.punctuation): # remove punctuation s = \"\".join(c for c in s if c not in char_blacklist) # remove consecutive spaces return \" \".join(filter(None, s.split(\" \")))"
            },
            {
                "url": 3082,
                "code": "def tokenize_words(self, text): return [ self.strip_punctuation(word) for word in text.split(' ') if self.strip_punctuation(word) ]"
            },
            {
                "url": 1651,
                "code": "def _clean_str(self, s): return s.translate(str.maketrans('', '', punctuation)).replace('\\u200b', \" \").strip().lower()"
            },
            {
                "url": 5526,
                "code": "def python(string: str): return underscore(singularize(string) if Naming._pluralize(string) else string)"
            },
            {
                "url": 2208,
                "code": "def remove_punctuation(text, exceptions=[]): all_but = [ r'\\w', r'\\s' ] all_but.extend(exceptions) pattern = '[^{}]'.format(''.join(all_but)) return re.sub(pattern, '', text)"
            },
            {
                "url": 2704,
                "code": "def counter_from_str(self, string): string_list = [chars for chars in string if chars not in self.punctuation] string_joined = ''.join(string_list) tokens = self.punkt.word_tokenize(string_joined) return Counter(tokens)"
            },
            {
                "url": 2835,
                "code": "def is_palindrome(string, strict=True): if is_full_string(string): if strict: return reverse(string) == string return is_palindrome(SPACES_RE.sub('', string)) return False"
            },
            {
                "url": 167,
                "code": "def is_identifier(string): matched = PYTHON_IDENTIFIER_RE.match(string) return bool(matched) and not keyword.iskeyword(string)"
            },
            {
                "url": 5168,
                "code": "def preprocess_french(trans, fr_nlp, remove_brackets_content=True): if remove_brackets_content: trans = pangloss.remove_content_in_brackets(trans, \"[]\") # Not sure why I have to split and rejoin, but that fixes a Spacy token # error. trans = fr_nlp(\" \".join(trans.split()[:])) #trans = fr_nlp(trans) trans = \" \".join([token.lower_ for token in trans if not token.is_punct]) return trans"
            },
            {
                "url": 5175,
                "code": "def check(text): err = \"malapropisms.misc\" msg = u\"'{}' is a malapropism.\" illogics = [ \"the infinitesimal universe\", \"a serial experience\", \"attack my voracity\", ] return existence_check(text, illogics, err, msg, offset=1)"
            },
            {
                "url": 5747,
                "code": "def _check_whitespace(string): if string.count(' ') + string.count('\\t') + string.count('\\n') > 0: raise ValueError(INSTRUCTION_HAS_WHITESPACE)"
            },
            {
                "url": 5589,
                "code": "def is_unicode(string): str_type = str(type(string)) if str_type.find('str') > 0 or str_type.find('unicode') > 0: return True return False"
            },
            {
                "url": 4207,
                "code": "def _begins_with_one_of(sentence, parts_of_speech): doc = nlp(sentence) if doc[0].tag_ in parts_of_speech: return True return False"
            }
        ],
        "url": 3520
    },
    {
        "nl_input": "unsupported media type json python",
        "code_input": [
            {
                "url": 1040,
                "code": "async def json_or_text(response): text = await response.text() if response.headers['Content-Type'] == 'application/json; charset=utf-8': return json.loads(text) return text"
            },
            {
                "url": 2695,
                "code": "def parse(self, data, mimetype): encoding = mimetype.params.get('charset') or 'utf-8' return json.loads(data.decode(encoding))"
            },
            {
                "url": 2062,
                "code": "def json_decode(data): if isinstance(data, six.binary_type): data = data.decode('utf-8') return json.loads(data)"
            },
            {
                "url": 2057,
                "code": "def json(body, charset='utf-8', **kwargs): return json_converter.loads(text(body, charset=charset))"
            },
            {
                "url": 4775,
                "code": "def write_json_response(self, response): self.write(tornado.escape.json_encode(response)) self.set_header(\"Content-Type\", \"application/json\")"
            },
            {
                "url": 311,
                "code": "def python_mime(fn): @wraps(fn) def python_mime_decorator(*args, **kwargs): response.content_type = \"text/x-python\" return fn(*args, **kwargs) return python_mime_decorator"
            },
            {
                "url": 3889,
                "code": "def load_jsonf(fpath, encoding): with codecs.open(fpath, encoding=encoding) as f: return json.load(f)"
            },
            {
                "url": 4478,
                "code": "def text(value, encoding=\"utf-8\", errors=\"strict\"): if isinstance(value, text_type): return value elif isinstance(value, bytes): return text_type(value, encoding, errors) else: return text_type(value)"
            },
            {
                "url": 4925,
                "code": "def guess_media_type(filepath): o = subprocess.check_output(['file', '--mime-type', '-Lb', filepath]) o = o.strip() return o"
            },
            {
                "url": 4449,
                "code": "def content_type(self, data): self._content_type = str(data) self.add_header('Content-Type', str(data))"
            },
            {
                "url": 2691,
                "code": "def multipart_parse_json(api_url, data): headers = {'Content-Type': 'application/x-www-form-urlencoded'} response_text = requests.post(api_url, data=data, headers=headers)\\ .text.encode('ascii', errors='replace') return json.loads(response_text.decode())"
            },
            {
                "url": 4159,
                "code": "def _file_type(self, field): type = mimetypes.guess_type(self._files[field])[0] return type.encode(\"utf-8\") if isinstance(type, unicode) else str(type)"
            },
            {
                "url": 865,
                "code": "def json_datetime_serial(obj): if isinstance(obj, (datetime, date)): serial = obj.isoformat() return serial if ObjectId is not None and isinstance(obj, ObjectId): # TODO: try to use bson.json_util instead return str(obj) raise TypeError(\"Type not serializable\")"
            },
            {
                "url": 5177,
                "code": "def create_response(self, request, content, content_type): return HttpResponse(content=content, content_type=content_type)"
            },
            {
                "url": 711,
                "code": "def dict_jsonp(param): if not isinstance(param, dict): param = dict(param) return jsonp(param)"
            }
        ],
        "url": 2695
    },
    {
        "nl_input": "python separate string to list",
        "code_input": [
            {
                "url": 5723,
                "code": "def _str_to_list(value, separator): value_list = [item.strip() for item in value.split(separator)] value_list_sanitized = builtins.list(filter(None, value_list)) if len(value_list_sanitized) > 0: return value_list_sanitized else: raise ValueError('Invalid list variable.')"
            },
            {
                "url": 5700,
                "code": "def list_to_str(list, separator=','): list = [str(x) for x in list] return separator.join(list)"
            },
            {
                "url": 2880,
                "code": "def string_to_list(string, sep=\",\", filter_empty=False): return [value.strip() for value in string.split(sep) if (not filter_empty or value)]"
            },
            {
                "url": 2418,
                "code": "def _str_to_list(s): _list = s.split(\",\") return list(map(lambda i: i.lstrip(), _list))"
            },
            {
                "url": 3417,
                "code": "def list2string (inlist,delimit=' '): stringlist = [makestr(_) for _ in inlist] return string.join(stringlist,delimit)"
            },
            {
                "url": 3278,
                "code": "def comma_delimited_to_list(list_param): if isinstance(list_param, list): return list_param if isinstance(list_param, str): return list_param.split(',') else: return []"
            },
            {
                "url": 1146,
                "code": "def split_strings_in_list_retain_spaces(orig_list): temp_list = list() for line in orig_list: line_split = __re.split(r'(\\s+)', line) temp_list.append(line_split) return temp_list"
            },
            {
                "url": 1837,
                "code": "def to_list(var): if var is None: return [] if isinstance(var, str): var = var.split('\\n') elif not isinstance(var, list): try: var = list(var) except TypeError: raise ValueError(\"{} cannot be converted to the list.\".format(var)) return var"
            },
            {
                "url": 1984,
                "code": "def list_i2str(ilist): slist = [] for el in ilist: slist.append(str(el)) return slist"
            },
            {
                "url": 3842,
                "code": "def _return_comma_list(self, l): if isinstance(l, (text_type, int)): return l if not isinstance(l, list): raise TypeError(l, ' should be a list of integers, \\ not {0}'.format(type(l))) str_ids = ','.join(str(i) for i in l) return str_ids"
            },
            {
                "url": 77,
                "code": "def list_to_csv(value): if isinstance(value, (list, tuple, set)): value = \",\".join(value) return value"
            },
            {
                "url": 5598,
                "code": "def list_to_str(lst): if len(lst) == 1: str_ = lst[0] elif len(lst) == 2: str_ = ' and '.join(lst) elif len(lst) > 2: str_ = ', '.join(lst[:-1]) str_ += ', and {0}'.format(lst[-1]) else: raise ValueError('List of length 0 provided.') return str_"
            },
            {
                "url": 2414,
                "code": "def validate_stringlist(s): if isinstance(s, six.string_types): return [six.text_type(v.strip()) for v in s.split(',') if v.strip()] else: try: return list(map(validate_str, s)) except TypeError as e: raise ValueError(e.message)"
            },
            {
                "url": 2332,
                "code": "def validate_string_list(lst): if not isinstance(lst, list): raise ValueError('input %r must be a list' % lst) for x in lst: if not isinstance(x, basestring): raise ValueError('element %r in list must be a string' % x)"
            },
            {
                "url": 2574,
                "code": "def __normalize_list(self, msg): if isinstance(msg, list): msg = \"\".join(msg) return list(map(lambda x: x.strip(), msg.split(\",\")))"
            }
        ],
        "url": 5723
    },
    {
        "nl_input": "python remove phrase from list of strings",
        "code_input": [
            {
                "url": 1153,
                "code": "def _removeStopwords(text_list): output_list = [] for word in text_list: if word.lower() not in _stopwords: output_list.append(word) return output_list"
            },
            {
                "url": 3553,
                "code": "def remove_from_string(string, values): for v in values: string = string.replace(v, '') return string"
            },
            {
                "url": 3082,
                "code": "def tokenize_words(self, text): return [ self.strip_punctuation(word) for word in text.split(' ') if self.strip_punctuation(word) ]"
            },
            {
                "url": 1838,
                "code": "def unpunctuate(s, *, char_blacklist=string.punctuation): # remove punctuation s = \"\".join(c for c in s if c not in char_blacklist) # remove consecutive spaces return \" \".join(filter(None, s.split(\" \")))"
            },
            {
                "url": 3796,
                "code": "def clean_strings(iterable): retval = [] for val in iterable: try: retval.append(val.strip()) except(AttributeError): retval.append(val) return retval"
            },
            {
                "url": 844,
                "code": "def wordify(text): stopset = set(nltk.corpus.stopwords.words('english')) tokens = nltk.WordPunctTokenizer().tokenize(text) return [w for w in tokens if w not in stopset]"
            },
            {
                "url": 939,
                "code": "def lowstrip(term): term = re.sub('\\s+', ' ', term) term = term.lower() return term"
            },
            {
                "url": 6168,
                "code": "def remove_blank_spaces(syllables: List[str]) -> List[str]: cleaned = [] for syl in syllables: if syl == \" \" or syl == '': pass else: cleaned.append(syl) return cleaned"
            },
            {
                "url": 4788,
                "code": "def clean_text_by_sentences(text, language=\"english\", additional_stopwords=None): init_textcleanner(language, additional_stopwords) original_sentences = split_sentences(text) filtered_sentences = filter_words(original_sentences) return merge_syntactic_units(original_sentences, filtered_sentences)"
            },
            {
                "url": 1651,
                "code": "def _clean_str(self, s): return s.translate(str.maketrans('', '', punctuation)).replace('\\u200b', \" \").strip().lower()"
            },
            {
                "url": 5168,
                "code": "def preprocess_french(trans, fr_nlp, remove_brackets_content=True): if remove_brackets_content: trans = pangloss.remove_content_in_brackets(trans, \"[]\") # Not sure why I have to split and rejoin, but that fixes a Spacy token # error. trans = fr_nlp(\" \".join(trans.split()[:])) #trans = fr_nlp(trans) trans = \" \".join([token.lower_ for token in trans if not token.is_punct]) return trans"
            },
            {
                "url": 2208,
                "code": "def remove_punctuation(text, exceptions=[]): all_but = [ r'\\w', r'\\s' ] all_but.extend(exceptions) pattern = '[^{}]'.format(''.join(all_but)) return re.sub(pattern, '', text)"
            },
            {
                "url": 2880,
                "code": "def string_to_list(string, sep=\",\", filter_empty=False): return [value.strip() for value in string.split(sep) if (not filter_empty or value)]"
            },
            {
                "url": 839,
                "code": "def remove_bad(string): remove = [':', ',', '(', ')', ' ', '|', ';', '\\''] for c in remove: string = string.replace(c, '_') return string"
            },
            {
                "url": 3327,
                "code": "def clean(some_string, uppercase=False): if uppercase: return some_string.strip().upper() else: return some_string.strip().lower()"
            }
        ],
        "url": 5557
    },
    {
        "nl_input": "python fastest way to load data",
        "code_input": [
            {
                "url": 962,
                "code": "def load_data(filename): data = pandas.read_csv(filename, header=None, delimiter='\\t', skiprows=9) return data.as_matrix()"
            },
            {
                "url": 1409,
                "code": "def _loadfilepath(self, filepath, **kwargs): with open(filepath, \"r\") as f: data = json.load(f, **kwargs) return data"
            },
            {
                "url": 4188,
                "code": "def json_get_data(filename): with open(filename) as fp: json_data = json.load(fp) return json_data return False"
            },
            {
                "url": 4715,
                "code": "def read_raw(data_path): with open(data_path, 'rb') as f: data = pickle.load(f) return data"
            },
            {
                "url": 2552,
                "code": "def load_from_file(cls, file_path: str): with open(file_path, \"r\") as f: data = json.load(f) item = cls.decode(data=data) return item"
            },
            {
                "url": 977,
                "code": "def open_json(file_name): with open(file_name, \"r\") as json_data: data = json.load(json_data) return data"
            },
            {
                "url": 3889,
                "code": "def load_jsonf(fpath, encoding): with codecs.open(fpath, encoding=encoding) as f: return json.load(f)"
            },
            {
                "url": 1410,
                "code": "def get(url): response = urllib.request.urlopen(url) data = response.read() data = data.decode(\"utf-8\") data = json.loads(data) return data"
            },
            {
                "url": 3900,
                "code": "def load_db(file, db, verbose=True): db_data = json.load(file, verbose=verbose) return _load(db_data, db)"
            },
            {
                "url": 2695,
                "code": "def parse(self, data, mimetype): encoding = mimetype.params.get('charset') or 'utf-8' return json.loads(data.decode(encoding))"
            },
            {
                "url": 641,
                "code": "def _load_data(filepath): with h5py.File(filepath, \"r\") as h5dataset: image_array = np.array(h5dataset[\"images\"]) # The 'label' data set in the hdf5 file actually contains the float values # and not the class labels. values_array = np.array(h5dataset[\"labels\"]) return image_array, values_array"
            },
            {
                "url": 4832,
                "code": "def get_cached_data(datatable, **kwargs): cache_key = '%s%s' % (CACHE_PREFIX, datatable.get_cache_key(**kwargs)) data = cache.get(cache_key) log.debug(\"Reading data from cache at %r: %r\", cache_key, data) return data"
            },
            {
                "url": 5016,
                "code": "def load(cls, fp, **kwargs): json_obj = json.load(fp, **kwargs) return parse(cls, json_obj)"
            },
            {
                "url": 2062,
                "code": "def json_decode(data): if isinstance(data, six.binary_type): data = data.decode('utf-8') return json.loads(data)"
            },
            {
                "url": 4949,
                "code": "def load_fasta_file(filename): with open(filename, \"r\") as handle: records = list(SeqIO.parse(handle, \"fasta\")) return records"
            }
        ],
        "url": 2830
    },
    {
        "nl_input": "add noise to the audio python",
        "code_input": [
            {
                "url": 639,
                "code": "def add_noise(Y, sigma): return Y + np.random.normal(0, sigma, Y.shape)"
            },
            {
                "url": 3344,
                "code": "def normal_noise(points): return np.random.rand(1) * np.random.randn(points, 1) \\ + random.sample([2, -2], 1)"
            },
            {
                "url": 694,
                "code": "def synthesize(self, duration): sr = self.samplerate.samples_per_second seconds = duration / Seconds(1) samples = np.random.uniform(low=-1., high=1., size=int(sr * seconds)) return AudioSamples(samples, self.samplerate)"
            },
            {
                "url": 3764,
                "code": "def uniform_noise(points): return np.random.rand(1) * np.random.uniform(points, 1) \\ + random.sample([2, -2], 1)"
            },
            {
                "url": 1904,
                "code": "def readwav(filename): from scipy.io.wavfile import read as readwav samplerate, signal = readwav(filename) return signal, samplerate"
            },
            {
                "url": 3676,
                "code": "def gaussian_noise(x, severity=1): c = [.08, .12, 0.18, 0.26, 0.38][severity - 1] x = np.array(x) / 255. x_clip = np.clip(x + np.random.normal(size=x.shape, scale=c), 0, 1) * 255 return around_and_astype(x_clip)"
            },
            {
                "url": 1080,
                "code": "def write_wav(path, samples, sr=16000): max_value = np.abs(np.iinfo(np.int16).min) data = (samples * max_value).astype(np.int16) scipy.io.wavfile.write(path, sr, data)"
            },
            {
                "url": 4318,
                "code": "def write_wave(path, audio, sample_rate): with contextlib.closing(wave.open(path, 'wb')) as wf: wf.setnchannels(1) wf.setsampwidth(2) wf.setframerate(sample_rate) wf.writeframes(audio)"
            },
            {
                "url": 3937,
                "code": "def makeAnimation(self): aclip=mpy.AudioFileClip(\"sound.wav\") self.iS=self.iS.set_audio(aclip) self.iS.write_videofile(\"mixedVideo.webm\",15,audio=True) print(\"wrote \"+\"mixedVideo.webm\")"
            },
            {
                "url": 1396,
                "code": "def shot_noise(x, severity=1): c = [60, 25, 12, 5, 3][severity - 1] x = np.array(x) / 255. x_clip = np.clip(np.random.poisson(x * c) / float(c), 0, 1) * 255 return around_and_astype(x_clip)"
            },
            {
                "url": 374,
                "code": "def smooth_gaussian(image, sigma=1): return scipy.ndimage.filters.gaussian_filter(image, sigma=sigma, mode=\"nearest\")"
            },
            {
                "url": 4234,
                "code": "def fit_gaussian(samples, ddof=0): if len(samples.shape) == 1: return np.mean(samples), np.std(samples, ddof=ddof) return np.mean(samples, axis=1), np.std(samples, axis=1, ddof=ddof)"
            },
            {
                "url": 5075,
                "code": "def trim_trailing_silence(self): length = self.get_active_length() self.pianoroll = self.pianoroll[:length]"
            },
            {
                "url": 558,
                "code": "def sine_wave(frequency): xs = tf.reshape(tf.range(_samples(), dtype=tf.float32), [1, _samples(), 1]) ts = xs / FLAGS.sample_rate return tf.sin(2 * math.pi * frequency * ts)"
            },
            {
                "url": 1128,
                "code": "def _saferound(value, decimal_places): try: f = float(value) except ValueError: return '' format = '%%.%df' % decimal_places return format % f"
            }
        ],
        "url": 694
    },
    {
        "nl_input": "object with commas turned into list python",
        "code_input": [
            {
                "url": 3278,
                "code": "def comma_delimited_to_list(list_param): if isinstance(list_param, list): return list_param if isinstance(list_param, str): return list_param.split(',') else: return []"
            },
            {
                "url": 3842,
                "code": "def _return_comma_list(self, l): if isinstance(l, (text_type, int)): return l if not isinstance(l, list): raise TypeError(l, ' should be a list of integers, \\ not {0}'.format(type(l))) str_ids = ','.join(str(i) for i in l) return str_ids"
            },
            {
                "url": 5700,
                "code": "def list_to_str(list, separator=','): list = [str(x) for x in list] return separator.join(list)"
            },
            {
                "url": 77,
                "code": "def list_to_csv(value): if isinstance(value, (list, tuple, set)): value = \",\".join(value) return value"
            },
            {
                "url": 160,
                "code": "def commajoin_as_strings(iterable): return _(u',').join((six.text_type(i) for i in iterable))"
            },
            {
                "url": 1110,
                "code": "def split_comma_argument(comma_sep_str): terms = [] for term in comma_sep_str.split(','): if term: terms.append(term) return terms"
            },
            {
                "url": 3417,
                "code": "def list2string (inlist,delimit=' '): stringlist = [makestr(_) for _ in inlist] return string.join(stringlist,delimit)"
            },
            {
                "url": 2418,
                "code": "def _str_to_list(s): _list = s.split(\",\") return list(map(lambda i: i.lstrip(), _list))"
            },
            {
                "url": 5723,
                "code": "def _str_to_list(value, separator): value_list = [item.strip() for item in value.split(separator)] value_list_sanitized = builtins.list(filter(None, value_list)) if len(value_list_sanitized) > 0: return value_list_sanitized else: raise ValueError('Invalid list variable.')"
            },
            {
                "url": 1837,
                "code": "def to_list(var): if var is None: return [] if isinstance(var, str): var = var.split('\\n') elif not isinstance(var, list): try: var = list(var) except TypeError: raise ValueError(\"{} cannot be converted to the list.\".format(var)) return var"
            },
            {
                "url": 2742,
                "code": "def csvtolist(inputstr): reader = csv.reader([inputstr], skipinitialspace=True) output = [] for r in reader: output += r return output"
            },
            {
                "url": 392,
                "code": "def _split_comma_separated(string): return set(text.strip() for text in string.split(',') if text.strip())"
            },
            {
                "url": 2574,
                "code": "def __normalize_list(self, msg): if isinstance(msg, list): msg = \"\".join(msg) return list(map(lambda x: x.strip(), msg.split(\",\")))"
            },
            {
                "url": 2880,
                "code": "def string_to_list(string, sep=\",\", filter_empty=False): return [value.strip() for value in string.split(sep) if (not filter_empty or value)]"
            },
            {
                "url": 3280,
                "code": "def readCommaList(fileList): names=fileList.split(',') fileList=[] for item in names: fileList.append(item) return fileList"
            }
        ],
        "url": 1439
    },
    {
        "nl_input": "python set limits on x axis",
        "code_input": [
            {
                "url": 3834,
                "code": "def set_xlimits(self, min=None, max=None): self.limits['xmin'] = min self.limits['xmax'] = max"
            },
            {
                "url": 3455,
                "code": "def set_xlimits(self, row, column, min=None, max=None): subplot = self.get_subplot_at(row, column) subplot.set_xlimits(min, max)"
            },
            {
                "url": 1516,
                "code": "def set_xlimits_widgets(self, set_min=True, set_max=True): xmin, xmax = self.tab_plot.ax.get_xlim() if set_min: self.w.x_lo.set_text('{0}'.format(xmin)) if set_max: self.w.x_hi.set_text('{0}'.format(xmax))"
            },
            {
                "url": 4327,
                "code": "def set_ylim(self, xlims, dx, xscale, reverse=False): self._set_axis_limits('y', xlims, dx, xscale, reverse) return"
            },
            {
                "url": 790,
                "code": "def set_ylimits(self, row, column, min=None, max=None): subplot = self.get_subplot_at(row, column) subplot.set_ylimits(min, max)"
            },
            {
                "url": 3028,
                "code": "def _set_axis_limits(self, which, lims, d, scale, reverse=False): setattr(self.limits, which + 'lims', lims) setattr(self.limits, 'd' + which, d) setattr(self.limits, which + 'scale', scale) if reverse: setattr(self.limits, 'reverse_' + which + '_axis', True) return"
            },
            {
                "url": 5089,
                "code": "def set_limits(self, min_=None, max_=None): self._min, self._max = min_, max_"
            },
            {
                "url": 4994,
                "code": "def set_mlimits(self, row, column, min=None, max=None): subplot = self.get_subplot_at(row, column) subplot.set_mlimits(min, max)"
            },
            {
                "url": 5697,
                "code": "def impose_legend_limit(limit=30, axes=\"gca\", **kwargs): if axes==\"gca\": axes = _pylab.gca() # make these axes current _pylab.axes(axes) # loop over all the lines_pylab. for n in range(0,len(axes.lines)): if n > limit-1 and not n==len(axes.lines)-1: axes.lines[n].set_label(\"_nolegend_\") if n == limit-1 and not n==len(axes.lines)-1: axes.lines[n].set_label(\"...\") _pylab.legend(**kwargs)"
            },
            {
                "url": 4635,
                "code": "def ylim(self, low, high): self.chart['yAxis'][0]['min'] = low self.chart['yAxis'][0]['max'] = high return self"
            },
            {
                "url": 2368,
                "code": "def set_axis_options(self, row, column, text): subplot = self.get_subplot_at(row, column) subplot.set_axis_options(text)"
            },
            {
                "url": 944,
                "code": "def show_xticklabels(self, row, column): subplot = self.get_subplot_at(row, column) subplot.show_xticklabels()"
            },
            {
                "url": 5493,
                "code": "def zoom(ax, xy='x', factor=1): limits = ax.get_xlim() if xy == 'x' else ax.get_ylim() new_limits = (0.5*(limits[0] + limits[1]) + 1./factor * np.array((-0.5, 0.5)) * (limits[1] - limits[0])) if xy == 'x': ax.set_xlim(new_limits) else: ax.set_ylim(new_limits)"
            },
            {
                "url": 2073,
                "code": "def open01(x, limit=1.e-6): try: return np.array([min(max(y, limit), 1. - limit) for y in x]) except TypeError: return min(max(x, limit), 1. - limit)"
            },
            {
                "url": 4826,
                "code": "def set_xticks_for_all(self, row_column_list=None, ticks=None): if row_column_list is None: self.ticks['x'] = ticks else: for row, column in row_column_list: self.set_xticks(row, column, ticks)"
            }
        ],
        "url": 3834
    },
    {
        "nl_input": "is python ssl socket connection thread safe",
        "code_input": [
            {
                "url": 2787,
                "code": "def enable_ssl(self, *args, **kwargs): if self.handshake_sent: raise SSLError('can only enable SSL before handshake') self.secure = True self.sock = ssl.wrap_socket(self.sock, *args, **kwargs)"
            },
            {
                "url": 5409,
                "code": "def _sslobj(sock): pass if isinstance(sock._sslobj, _ssl._SSLSocket): return sock._sslobj else: return sock._sslobj._sslobj"
            },
            {
                "url": 3711,
                "code": "def connected_socket(address, timeout=3): sock = socket.create_connection(address, timeout) yield sock sock.close()"
            },
            {
                "url": 602,
                "code": "def inject_into_urllib3(): util.ssl_.SSLContext = SecureTransportContext util.HAS_SNI = HAS_SNI util.ssl_.HAS_SNI = HAS_SNI util.IS_SECURETRANSPORT = True util.ssl_.IS_SECURETRANSPORT = True"
            },
            {
                "url": 1176,
                "code": "def _shutdown_transport(self): if self.sock is not None: try: unwrap = self.sock.unwrap except AttributeError: return try: self.sock = unwrap() except ValueError: # Failure within SSL might mean unwrap exists but socket is not # deemed wrapped pass"
            },
            {
                "url": 2168,
                "code": "def __connect(): global redis_instance if use_tcp_socket: redis_instance = redis.StrictRedis(host=hostname, port=port) else: redis_instance = redis.StrictRedis(unix_socket_path=unix_socket)"
            },
            {
                "url": 1243,
                "code": "def is_connected(self): try: return self.socket is not None and self.socket.getsockname()[1] != 0 and BaseTransport.is_connected(self) except socket.error: return False"
            },
            {
                "url": 5424,
                "code": "def connect(self): self.socket = socket.create_connection(self.address, self.timeout)"
            },
            {
                "url": 846,
                "code": "def start_connect(self): Log.debug(\"In start_connect() of %s\" % self._get_classname()) # TODO: specify buffer size, exception handling self.create_socket(socket.AF_INET, socket.SOCK_STREAM) # when ready, handle_connect is called self._connecting = True self.connect(self.endpoint)"
            },
            {
                "url": 1266,
                "code": "def get_pg_connection(host, user, port, password, database, ssl={}): return psycopg2.connect(host=host, user=user, port=port, password=password, dbname=database, sslmode=ssl.get('sslmode', None), sslcert=ssl.get('sslcert', None), sslkey=ssl.get('sslkey', None), sslrootcert=ssl.get('sslrootcert', None), )"
            },
            {
                "url": 1666,
                "code": "def socket_close(self): if self.sock != NC.INVALID_SOCKET: self.sock.close() self.sock = NC.INVALID_SOCKET"
            },
            {
                "url": 348,
                "code": "def connect(): ftp_class = ftplib.FTP if not SSL else ftplib.FTP_TLS ftp = ftp_class(timeout=TIMEOUT) ftp.connect(HOST, PORT) ftp.login(USER, PASSWORD) if SSL: ftp.prot_p() # secure data connection return ftp"
            },
            {
                "url": 5466,
                "code": "def start(self, test_connection=True): if self._context is None: self._logger.debug('Starting Client') self._context = zmq.Context() self._poll = zmq.Poller() self._start_socket() if test_connection: self.test_ping()"
            },
            {
                "url": 2639,
                "code": "def disable_cert_validation(): current_context = ssl._create_default_https_context ssl._create_default_https_context = ssl._create_unverified_context try: yield finally: ssl._create_default_https_context = current_context"
            },
            {
                "url": 4322,
                "code": "def shutdown(self): if self.sock: self.sock.close() self.sock = None self.connected = False"
            }
        ],
        "url": 2787
    },
    {
        "nl_input": "python3 encode decode bytes",
        "code_input": [
            {
                "url": 5925,
                "code": "def decodebytes(input): py_version = sys.version_info[0] if py_version >= 3: return _decodebytes_py3(input) return _decodebytes_py2(input)"
            },
            {
                "url": 3326,
                "code": "def bytes_to_str(s, encoding='utf-8'): if six.PY3 and isinstance(s, bytes): return s.decode(encoding) return s"
            },
            {
                "url": 3413,
                "code": "def to_bytes(s, encoding=\"utf-8\"): if isinstance(s, six.binary_type): return s if six.PY3: return bytes(s, encoding) return s.encode(encoding)"
            },
            {
                "url": 1897,
                "code": "def decode_bytes(string): if is_string_type(type(string)): string = bytes(string, \"utf-8\") return base64.decodebytes(string)"
            },
            {
                "url": 5583,
                "code": "def strtobytes(input, encoding): py_version = sys.version_info[0] if py_version >= 3: return _strtobytes_py3(input, encoding) return _strtobytes_py2(input, encoding)"
            },
            {
                "url": 1377,
                "code": "def to_bytes(value): vtype = type(value) if vtype == bytes or vtype == type(None): return value try: return vtype.encode(value) except UnicodeEncodeError: pass return value"
            },
            {
                "url": 2538,
                "code": "def to_string(s, encoding='utf-8'): if six.PY2: return s.encode(encoding) if isinstance(s, bytes): return s.decode(encoding) return s"
            },
            {
                "url": 5522,
                "code": "def cast_bytes(s, encoding=None): if not isinstance(s, bytes): return encode(s, encoding) return s"
            },
            {
                "url": 1328,
                "code": "def b2u(string): if (isinstance(string, bytes) or (PY2 and isinstance(string, str))): return string.decode('utf-8') return string"
            },
            {
                "url": 3497,
                "code": "def read_string(cls, string): if PY3 and not isinstance(string, byte_types): string = string.encode() return cls.decode(string)"
            },
            {
                "url": 3848,
                "code": "def value_to_python(self, value): if not isinstance(value, bytes): raise tldap.exceptions.ValidationError(\"should be a bytes\") value = value.decode(\"utf_8\") return value"
            },
            {
                "url": 5882,
                "code": "def decode(self, bytes, raw=False): return struct.unpack(self.format, buffer(bytes))[0]"
            },
            {
                "url": 1737,
                "code": "def tob(data, enc='utf8'): return data.encode(enc) if isinstance(data, six.text_type) else bytes(data)"
            },
            {
                "url": 1451,
                "code": "def to_str(s): if isinstance(s, bytes): s = s.decode('utf-8') elif not isinstance(s, str): s = str(s) return s"
            },
            {
                "url": 5639,
                "code": "def bytes_hack(buf): ub = None if sys.version_info > (3,): ub = buf else: ub = bytes(buf) return ub"
            }
        ],
        "url": 1377
    },
    {
        "nl_input": "xsd file to python object",
        "code_input": [
            {
                "url": 1677,
                "code": "def from_file(cls, file_path, validate=True): return xmlmap.load_xmlobject_from_file(file_path, xmlclass=cls, validate=validate)"
            },
            {
                "url": 3309,
                "code": "def xml_str_to_dict(s): xml = minidom.parseString(s) return pythonzimbra.tools.xmlserializer.dom_to_dict(xml.firstChild)"
            },
            {
                "url": 3311,
                "code": "def validate(self, xml_input): parsed_xml = etree.parse(self._handle_xml(xml_input)) try: return self.xmlschema.validate(parsed_xml) except AttributeError: raise CannotValidate('Set XSD to validate the XML')"
            },
            {
                "url": 1679,
                "code": "def schemaValidateFile(self, filename, options): ret = libxml2mod.xmlSchemaValidateFile(self._o, filename, options) return ret"
            },
            {
                "url": 1646,
                "code": "def SchemaValidate(self, xsd): ret = libxml2mod.xmlTextReaderSchemaValidate(self._o, xsd) return ret"
            },
            {
                "url": 89,
                "code": "def xmltreefromfile(filename): try: return ElementTree.parse(filename, ElementTree.XMLParser(collect_ids=False)) except TypeError: return ElementTree.parse(filename, ElementTree.XMLParser())"
            },
            {
                "url": 4187,
                "code": "def load(file_object): marshaller = JavaObjectUnmarshaller(file_object) marshaller.add_transformer(DefaultObjectTransformer()) return marshaller.readObject()"
            },
            {
                "url": 3456,
                "code": "def schemaParse(self): ret = libxml2mod.xmlSchemaParse(self._o) if ret is None:raise parserError('xmlSchemaParse() failed') __tmp = Schema(_obj=ret) return __tmp"
            },
            {
                "url": 380,
                "code": "def cli(yamlfile, format, context): print(JSONLDGenerator(yamlfile, format).serialize(context=context))"
            },
            {
                "url": 5563,
                "code": "def from_file(file_path) -> dict: with io.open(file_path, 'r', encoding='utf-8') as json_stream: return Json.parse(json_stream, True)"
            },
            {
                "url": 2552,
                "code": "def load_from_file(cls, file_path: str): with open(file_path, \"r\") as f: data = json.load(f) item = cls.decode(data=data) return item"
            },
            {
                "url": 687,
                "code": "def validate(raw_schema, target=None, **kwargs): schema = schema_validator(raw_schema, **kwargs) if target is not None: validate_object(target, schema=schema, **kwargs)"
            },
            {
                "url": 3826,
                "code": "def cli(yamlfile, format, output): print(OwlSchemaGenerator(yamlfile, format).serialize(output=output))"
            },
            {
                "url": 1059,
                "code": "def _dict_to_proto(py_dict, proto): dict_json_str = json.dumps(py_dict) return json_format.Parse(dict_json_str, proto)"
            },
            {
                "url": 2922,
                "code": "def parse(filename): with open(filename) as f: parser = ASDLParser() return parser.parse(f.read())"
            }
        ],
        "url": 1677
    },
    {
        "nl_input": "python expand a path",
        "code_input": [
            {
                "url": 3524,
                "code": "def expandpath(path): return os.path.expandvars(os.path.expanduser(path)).replace(\"//\", \"/\")"
            },
            {
                "url": 5050,
                "code": "def expand_path(path): return os.path.abspath(os.path.expandvars(os.path.expanduser(path)))"
            },
            {
                "url": 2827,
                "code": "def expandvars_dict(settings): return dict( (key, os.path.expandvars(value)) for key, value in settings.iteritems() )"
            },
            {
                "url": 2295,
                "code": "def fixpath(path): return os.path.normpath(os.path.realpath(os.path.expanduser(path)))"
            },
            {
                "url": 1784,
                "code": "def _expand(self, str, local_vars={}): return ninja_syntax.expand(str, self.vars, local_vars)"
            },
            {
                "url": 880,
                "code": "def normalize_path(path): return os.path.normcase(os.path.realpath(os.path.expanduser(path)))"
            },
            {
                "url": 1158,
                "code": "def expand_args(cmd_args): if isinstance(cmd_args, (tuple, list)): args_list = list(cmd_args) else: args_list = shlex.split(cmd_args) return args_list"
            },
            {
                "url": 2996,
                "code": "def prepare_path(path): if type(path) == list: return os.path.join(*path) return path"
            },
            {
                "url": 692,
                "code": "def get_absolute_path(*args): directory = os.path.dirname(os.path.abspath(__file__)) return os.path.join(directory, *args)"
            },
            {
                "url": 3,
                "code": "def create_path(path): import os if not os.path.exists(path): os.makedirs(path)"
            },
            {
                "url": 3035,
                "code": "def makedirs(path): if not os.path.isdir(path): os.makedirs(path) return path"
            },
            {
                "url": 762,
                "code": "def relpath(path): return os.path.normpath( os.path.join(os.path.abspath(os.path.dirname(__file__)), path) )"
            },
            {
                "url": 87,
                "code": "def relative_path(path): return os.path.join(os.path.dirname(__file__), path)"
            },
            {
                "url": 3819,
                "code": "def path(self): path = super(WindowsPath2, self).path if path.startswith(\"\\\\\\\\?\\\\\"): return path[4:] return path"
            },
            {
                "url": 2209,
                "code": "def is_file(path): try: return path.expanduser().absolute().is_file() except AttributeError: return os.path.isfile(os.path.abspath(os.path.expanduser(str(path))))"
            }
        ],
        "url": 3524
    },
    {
        "nl_input": "python flask template table example",
        "code_input": [
            {
                "url": 3292,
                "code": "def print_table(*args, **kwargs): t = format_table(*args, **kwargs) click.echo(t)"
            },
            {
                "url": 3724,
                "code": "def _render_table(data, fields=None): return IPython.core.display.HTML(datalab.utils.commands.HtmlBuilder.render_table(data, fields))"
            },
            {
                "url": 765,
                "code": "def html(header_rows): name = 'table%d' % next(tablecounter) return HtmlTable([map(str, row) for row in header_rows], name).render()"
            },
            {
                "url": 6129,
                "code": "def to_javascript_(self, table_name: str=\"data\") -> str: try: renderer = pytablewriter.JavaScriptTableWriter data = self._build_export(renderer, table_name) return data except Exception as e: self.err(e, \"Can not convert data to javascript code\")"
            },
            {
                "url": 2750,
                "code": "def append_table(self, name, **kwargs): self.stack.append(Table(name, **kwargs))"
            },
            {
                "url": 1420,
                "code": "def _format_list(result): if not result: return result if isinstance(result[0], dict): return _format_list_objects(result) table = Table(['value']) for item in result: table.add_row([iter_to_table(item)]) return table"
            },
            {
                "url": 669,
                "code": "def render_template(template_name, **context): tmpl = jinja_env.get_template(template_name) context[\"url_for\"] = url_for return Response(tmpl.render(context), mimetype=\"text/html\")"
            },
            {
                "url": 1442,
                "code": "def format_prettytable(table): for i, row in enumerate(table.rows): for j, item in enumerate(row): table.rows[i][j] = format_output(item) ptable = table.prettytable() ptable.hrules = prettytable.FRAME ptable.horizontal_char = '.' ptable.vertical_char = ':' ptable.junction_char = ':' return ptable"
            },
            {
                "url": 1548,
                "code": "def render_template(self, source, **kwargs_context): r return self.jinja_env.from_string(source).render(kwargs_context)"
            },
            {
                "url": 2460,
                "code": "def render_template(env, filename, values=None): if not values: values = {} tmpl = env.get_template(filename) return tmpl.render(values)"
            },
            {
                "url": 2780,
                "code": "def create_bigquery_table(self, database, schema, table_name, callback, sql): conn = self.get_thread_connection() client = conn.handle view_ref = self.table_ref(database, schema, table_name, conn) view = google.cloud.bigquery.Table(view_ref) callback(view) with self.exception_handler(sql): client.create_table(view)"
            },
            {
                "url": 5495,
                "code": "def gen_text(env: TextIOBase, package: str, tmpl: str): if env: env_args = json_datetime.load(env) else: env_args = {} jinja_env = template.setup(package) echo(jinja_env.get_template(tmpl).render(**env_args))"
            },
            {
                "url": 4297,
                "code": "def __print_table(table): col_width = [max(len(x) for x in col) for col in zip(*table)] print(\"| \" + \" | \".join(\"{:{}}\".format(x, col_width[i]) for i, x in enumerate(table[0])) + \" |\") print(\"| \" + \" | \".join(\"{:{}}\".format('-' * col_width[i], col_width[i]) for i, x in enumerate(table[0])) + \" |\") for line in table[1:]: print(\"| \" + \" | \".join(\"{:{}}\".format(x, col_width[i]) for i, x in enumerate(line)) + \" |\")"
            },
            {
                "url": 3328,
                "code": "def render(template, context): path, filename = os.path.split(template) return jinja2.Environment( loader=jinja2.FileSystemLoader(path or './') ).get_template(filename).render(context)"
            },
            {
                "url": 1846,
                "code": "def render(template=None, ostr=None, **kwargs): jinja_environment.filters['texscape'] = tex_escape template = template or DEFAULT_TEMPLATE ostr = ostr or sys.stdout jinja_template = jinja_environment.get_template(template) jinja_template.stream(**kwargs).dump(ostr)"
            }
        ],
        "url": 4050
    },
    {
        "nl_input": "how to check if object defined python",
        "code_input": [
            {
                "url": 202,
                "code": "def is_defined(self, objtxt, force_import=False): return self.interpreter.is_defined(objtxt, force_import)"
            },
            {
                "url": 747,
                "code": "def is_defined(self, obj, force_import=False): from spyder_kernels.utils.dochelpers import isdefined ns = self._get_current_namespace(with_magics=True) return isdefined(obj, force_import=force_import, namespace=ns)"
            },
            {
                "url": 2087,
                "code": "def is_text(obj, name=None): try: # python2 ans = isinstance(obj, basestring) except NameError: # python3 ans = isinstance(obj, str) if name: print(\"is_text: (%s) %s = %s\" % (ans, name, obj.__class__), file=sys.stderr) return ans"
            },
            {
                "url": 4527,
                "code": "def isroutine(object): return (isbuiltin(object) or isfunction(object) or ismethod(object) or ismethoddescriptor(object))"
            },
            {
                "url": 1789,
                "code": "def is_string(obj): if PYTHON3: str_type = (bytes, str) else: str_type = (bytes, str, unicode) return isinstance(obj, str_type)"
            },
            {
                "url": 6187,
                "code": "def check_python_version(): # Required due to multiple with statements on one line req_version = (2, 7) cur_version = sys.version_info if cur_version >= req_version: print(\"Python version... %sOK%s (found %s, requires %s)\" % (Bcolors.OKGREEN, Bcolors.ENDC, str(platform.python_version()), str(req_version[0]) + \".\" + str(req_version[1]))) else: print(\"Python version... %sFAIL%s (found %s, requires %s)\" % (Bcolors.FAIL, Bcolors.ENDC, str(cur_version), str(req_version)))"
            },
            {
                "url": 1121,
                "code": "def check_str(obj): if isinstance(obj, str): return obj if isinstance(obj, float): return str(int(obj)) else: return str(obj)"
            },
            {
                "url": 1297,
                "code": "def istype(obj, check): if isinstance(check, tuple): for cls in check: if type(obj) is cls: return True return False else: return type(obj) is check"
            },
            {
                "url": 2141,
                "code": "def isstring(value): classes = (str, bytes) if pyutils.PY3 else basestring # noqa: F821 return isinstance(value, classes)"
            },
            {
                "url": 2128,
                "code": "def is_integer(obj): if PYTHON3: return isinstance(obj, int) return isinstance(obj, (int, long))"
            },
            {
                "url": 198,
                "code": "def is_dataframe(obj): try: # This is the best method of type checking from pandas import DataFrame return isinstance(obj, DataFrame) except ImportError: # Pandas is not a dependency, so this is scary return obj.__class__.__name__ == \"DataFrame\""
            },
            {
                "url": 285,
                "code": "def make_kind_check(python_types, numpy_kind): def check(value): if hasattr(value, 'dtype'): return value.dtype.kind == numpy_kind return isinstance(value, python_types) return check"
            },
            {
                "url": 6043,
                "code": "def is_builtin_object(node: astroid.node_classes.NodeNG) -> bool: return node and node.root().name == BUILTINS_NAME"
            },
            {
                "url": 2997,
                "code": "def is_valid_data(obj): if obj: try: tmp = json.dumps(obj, default=datetime_encoder) del tmp except (TypeError, UnicodeDecodeError): return False return True"
            },
            {
                "url": 3356,
                "code": "def is_number(obj): return isinstance(obj, (int, float, np.int_, np.float_))"
            }
        ],
        "url": 202
    },
    {
        "nl_input": "s3 sync between bucket python",
        "code_input": [
            {
                "url": 4472,
                "code": "def sync_s3(self): bucket, key = self.open_s3() for directory in self.DIRECTORIES: for root, dirs, files in os.walk(directory): self.upload_s3((bucket, key, self.AWS_BUCKET_NAME, directory), root, files, dirs)"
            },
            {
                "url": 1312,
                "code": "def s3(ctx, bucket_name, data_file, region): if not ctx.data_file: ctx.data_file = data_file if not ctx.bucket_name: ctx.bucket_name = bucket_name if not ctx.region: ctx.region = region ctx.type = 's3'"
            },
            {
                "url": 1455,
                "code": "def remove_file_from_s3(awsclient, bucket, key): client_s3 = awsclient.get_client('s3') response = client_s3.delete_object(Bucket=bucket, Key=key)"
            },
            {
                "url": 4020,
                "code": "def s3_connect(bucket_name, s3_access_key_id, s3_secret_key): conn = connect_s3(s3_access_key_id, s3_secret_key) try: return conn.get_bucket(bucket_name) except S3ResponseError as e: if e.status == 403: raise Exception(\"Bad Amazon S3 credentials.\") raise"
            },
            {
                "url": 5656,
                "code": "def s3_get(url: str, temp_file: IO) -> None: s3_resource = boto3.resource(\"s3\") bucket_name, s3_path = split_s3_path(url) s3_resource.Bucket(bucket_name).download_fileobj(s3_path, temp_file)"
            },
            {
                "url": 2612,
                "code": "def download_file(bucket_name, path, target, sagemaker_session): path = path.lstrip('/') boto_session = sagemaker_session.boto_session s3 = boto_session.resource('s3') bucket = s3.Bucket(bucket_name) bucket.download_file(path, target)"
            },
            {
                "url": 4304,
                "code": "def delete_s3_bucket(client, resource): if dbconfig.get('enable_delete_s3_buckets', NS_AUDITOR_REQUIRED_TAGS, False): client.delete_bucket(Bucket=resource.id) return ActionStatus.SUCCEED, resource.metrics()"
            },
            {
                "url": 1054,
                "code": "def parse_s3_url(url): bucket = '' path = '' if url: result = urlparse(url) bucket = result.netloc path = result.path.strip('/') return bucket, path"
            },
            {
                "url": 4441,
                "code": "def get_key(self, key, bucket_name=None): if not bucket_name: (bucket_name, key) = self.parse_s3_url(key) obj = self.get_resource_type('s3').Object(bucket_name, key) obj.load() return obj"
            },
            {
                "url": 368,
                "code": "def download_file_from_bucket(self, bucket, file_path, key): with open(file_path, 'wb') as data: self.__s3.download_fileobj(bucket, key, data) return file_path"
            },
            {
                "url": 2631,
                "code": "def create_aws_lambda(ctx, bucket, region_name, aws_access_key_id, aws_secret_access_key): from canari.commands.create_aws_lambda import create_aws_lambda create_aws_lambda(ctx.project, bucket, region_name, aws_access_key_id, aws_secret_access_key)"
            },
            {
                "url": 815,
                "code": "def touch(): from .models import Bucket bucket = Bucket.create() db.session.commit() click.secho(str(bucket), fg='green')"
            },
            {
                "url": 1547,
                "code": "def get_as_bytes(self, s3_path): (bucket, key) = self._path_to_bucket_and_key(s3_path) obj = self.s3.Object(bucket, key) contents = obj.get()['Body'].read() return contents"
            },
            {
                "url": 3039,
                "code": "def health_check(self): logger.debug('Health Check on S3 file for: {namespace}'.format( namespace=self.namespace )) try: self.client.head_object(Bucket=self.bucket_name, Key=self.data_file) return True except ClientError as e: logger.debug('Error encountered with S3. Assume unhealthy')"
            },
            {
                "url": 3769,
                "code": "def get_as_string(self, s3_path, encoding='utf-8'): content = self.get_as_bytes(s3_path) return content.decode(encoding)"
            }
        ],
        "url": 1312
    },
    {
        "nl_input": "change the position of 3d coordinate in python",
        "code_input": [
            {
                "url": 17,
                "code": "def transform_to_3d(points,normal,z=0): d = np.cross(normal, (0, 0, 1)) M = rotation_matrix(d) transformed_points = M.dot(points.T).T + z return transformed_points"
            },
            {
                "url": 15,
                "code": "def transform_from_rot_trans(R, t): R = R.reshape(3, 3) t = t.reshape(3, 1) return np.vstack((np.hstack([R, t]), [0, 0, 0, 1]))"
            },
            {
                "url": 1270,
                "code": "def list(self): return [self._pos3d.x, self._pos3d.y, self._pos3d.z]"
            },
            {
                "url": 2955,
                "code": "def R_rot_3d(th): sx, sy, sz = np.sin(th).T cx, cy, cz = np.cos(th).T R = np.empty((len(th), 3, 3), dtype=np.float) R[:, 0, 0] = cy * cz R[:, 0, 1] = -cy * sz R[:, 0, 2] = sy R[:, 1, 0] = sx * sy * cz + cx * sz R[:, 1, 1] = -sx * sy * sz + cx * cz R[:, 1, 2] = -sx * cy R[:, 2, 0] = -cx * sy * cz + sx * sz R[:, 2, 1] = cx * sy * sz + sx * cz R[:, 2, 2] = cx * cy return R"
            },
            {
                "url": 3693,
                "code": "def plot3d_init(fignum): from mpl_toolkits.mplot3d import Axes3D fig = plt.figure(fignum) ax = fig.add_subplot(111, projection='3d') return ax"
            },
            {
                "url": 2216,
                "code": "def translate_v3(vec, amount): return Vec3(vec.x+amount, vec.y+amount, vec.z+amount)"
            },
            {
                "url": 5295,
                "code": "def rotation_from_quaternion(q_wxyz): q_xyzw = np.array([q_wxyz[1], q_wxyz[2], q_wxyz[3], q_wxyz[0]]) R = transformations.quaternion_matrix(q_xyzw)[:3,:3] return R"
            },
            {
                "url": 4739,
                "code": "def move(self, x, y): self._cursor = self._normalizePoint(x, y)"
            },
            {
                "url": 5418,
                "code": "def rotate_point(xorigin, yorigin, x, y, angle): rotx = (x - xorigin) * np.cos(angle) - (y - yorigin) * np.sin(angle) roty = (x - yorigin) * np.sin(angle) + (y - yorigin) * np.cos(angle) return rotx, roty"
            },
            {
                "url": 2441,
                "code": "def flatten4d3d(x): xshape = shape_list(x) result = tf.reshape(x, [xshape[0], xshape[1] * xshape[2], xshape[3]]) return result"
            },
            {
                "url": 2502,
                "code": "def _position(): cursor = POINT() ctypes.windll.user32.GetCursorPos(ctypes.byref(cursor)) return (cursor.x, cursor.y)"
            },
            {
                "url": 5236,
                "code": "def vectorsToMatrix(aa, bb): MM = np.zeros([3, 3], np.float) for ii in range(3): for jj in range(3): MM[ii, jj] = aa[ii] * bb[jj] return MM"
            },
            {
                "url": 55,
                "code": "def qrot(vector, quaternion): t = 2 * np.cross(quaternion[1:], vector) v_rot = vector + quaternion[0] * t + np.cross(quaternion[1:], t) return v_rot"
            },
            {
                "url": 2579,
                "code": "def py3round(number): if abs(round(number) - number) == 0.5: return int(2.0 * round(number / 2.0)) return int(round(number))"
            },
            {
                "url": 3715,
                "code": "def mouse_get_pos(): p = POINT() AUTO_IT.AU3_MouseGetPos(ctypes.byref(p)) return p.x, p.y"
            }
        ],
        "url": 1270
    },
    {
        "nl_input": "python how to get the number of cores in a computer",
        "code_input": [
            {
                "url": 5653,
                "code": "def cpu_count() -> int: if multiprocessing is None: return 1 try: return multiprocessing.cpu_count() except NotImplementedError: pass try: return os.sysconf(\"SC_NPROCESSORS_CONF\") except (AttributeError, ValueError): pass gen_log.error(\"Could not detect number of processors; assuming 1\") return 1"
            },
            {
                "url": 956,
                "code": "def _num_cpus_darwin(): p = subprocess.Popen(['sysctl','-n','hw.ncpu'],stdout=subprocess.PIPE) return p.stdout.read()"
            },
            {
                "url": 3055,
                "code": "def machine_info(): import psutil BYTES_IN_GIG = 1073741824.0 free_bytes = psutil.virtual_memory().total return [{\"memory\": float(\"%.1f\" % (free_bytes / BYTES_IN_GIG)), \"cores\": multiprocessing.cpu_count(), \"name\": socket.gethostname()}]"
            },
            {
                "url": 146,
                "code": "def get_system_cpu_times(): user, nice, system, idle = _psutil_osx.get_system_cpu_times() return _cputimes_ntuple(user, nice, system, idle)"
            },
            {
                "url": 2137,
                "code": "def ncores_reserved(self): return sum(task.manager.num_cores for task in self if task.status == task.S_SUB)"
            },
            {
                "url": 4121,
                "code": "def get_pid_list(): pids = [int(x) for x in os.listdir('/proc') if x.isdigit()] return pids"
            },
            {
                "url": 5665,
                "code": "def check64bit(current_system=\"python\"): if current_system == \"python\": return sys.maxsize > 2147483647 elif current_system == \"os\": import platform pm = platform.machine() if pm != \"..\" and pm.endswith('64'): # recent Python (not Iron) return True else: if 'PROCESSOR_ARCHITEW6432' in os.environ: return True # 32 bit program running on 64 bit Windows try: # 64 bit Windows 64 bit program return os.environ['PROCESSOR_ARCHITECTURE'].endswith('64') except IndexError: pass # not Windows try: # this often works in Linux return '64' in platform.architecture()[0] except Exception: # is an older version of Python, assume also an older os@ # (best we can guess) return False"
            },
            {
                "url": 3831,
                "code": "def _cpu(self): value = int(psutil.cpu_percent()) set_metric(\"cpu\", value, category=self.category) gauge(\"cpu\", value)"
            },
            {
                "url": 824,
                "code": "def count_generator(generator, memory_efficient=True): if memory_efficient: counter = 0 for _ in generator: counter += 1 return counter else: return len(list(generator))"
            },
            {
                "url": 3053,
                "code": "def compute_partition_size(result, processes): try: return max(math.ceil(len(result) / processes), 1) except TypeError: return 1"
            },
            {
                "url": 401,
                "code": "def memory(): mem_info = dict() for k, v in psutil.virtual_memory()._asdict().items(): mem_info[k] = int(v) return mem_info"
            },
            {
                "url": 6206,
                "code": "def _darwin_current_arch(self): if sys.platform == \"darwin\": if sys.maxsize > 2 ** 32: # 64bits. return platform.mac_ver()[2] # Both Darwin and Python are 64bits. else: # Python 32 bits return platform.processor()"
            },
            {
                "url": 5752,
                "code": "def memory_usage(): try: import psutil import os except ImportError: return _memory_usage_ps() process = psutil.Process(os.getpid()) mem = process.memory_info()[0] / float(2 ** 20) return mem"
            },
            {
                "url": 1459,
                "code": "def get_memory_usage(): process = psutil.Process(os.getpid()) mem = process.memory_info().rss return mem / (1024 * 1024)"
            },
            {
                "url": 3170,
                "code": "def set_mem_per_proc(self, mem_mb): super().set_mem_per_proc(mem_mb) self.qparams[\"mem_per_cpu\"] = self.mem_per_proc"
            }
        ],
        "url": 956
    },
    {
        "nl_input": "python how to use pdb set trace",
        "code_input": [
            {
                "url": 900,
                "code": "def set_trace(): # https://github.com/nose-devs/nose/blob/master/nose/tools/nontrivial.py pdb.Pdb(stdout=sys.__stdout__).set_trace(sys._getframe().f_back)"
            },
            {
                "url": 899,
                "code": "def debug_on_error(type, value, tb): traceback.print_exc(type, value, tb) print() pdb.pm()"
            },
            {
                "url": 2799,
                "code": "def __run(self): sys.settrace(self.globaltrace) self.__run_backup() self.run = self.__run_backup"
            },
            {
                "url": 924,
                "code": "def print_trace(self): traceback.print_exc() for tb in self.tracebacks: print tb, print ''"
            },
            {
                "url": 4023,
                "code": "def _trace_full (frame, event, arg): if event == \"line\": _trace_line(frame, event, arg) else: _trace(frame, event, arg) return _trace_full"
            },
            {
                "url": 2213,
                "code": "def user_return(self, frame, return_value): pdb.Pdb.user_return(self, frame, return_value)"
            },
            {
                "url": 2324,
                "code": "def setup_detect_python2(): if None in [RTs._rt_py2_detect, RTs._rtp_py2_detect]: RTs._rt_py2_detect = RefactoringTool(py2_detect_fixers) RTs._rtp_py2_detect = RefactoringTool(py2_detect_fixers, {'print_function': True})"
            },
            {
                "url": 3744,
                "code": "def debug(ftn, txt): if debug_p: sys.stdout.write(\"{0}.{1}:{2}\\n\".format(modname, ftn, txt)) sys.stdout.flush()"
            },
            {
                "url": 2733,
                "code": "def connect(*args, **kwargs): kwargs['cursor_factory'] = TraceCursor conn = pg_connect(*args, **kwargs) return conn"
            },
            {
                "url": 4941,
                "code": "def _extract_traceback(start): tb = sys.exc_info()[2] for i in range(start): tb = tb.tb_next return _parse_traceback(tb)"
            },
            {
                "url": 1880,
                "code": "def debug(sequence): points = [] for i, p in enumerate(sequence): copy = Point(p) copy['index'] = i points.append(copy) return sequence.__class__(points)"
            },
            {
                "url": 1456,
                "code": "def get_trace_id_from_flask(): if flask is None or not flask.request: return None header = flask.request.headers.get(_FLASK_TRACE_HEADER) if header is None: return None trace_id = header.split(\"/\", 1)[0] return trace_id"
            },
            {
                "url": 5600,
                "code": "def cli_run(): parser = argparse.ArgumentParser(description='Stupidly simple code answers from StackOverflow') parser.add_argument('query', help=\"What's the problem ?\", type=str, nargs='+') parser.add_argument('-t','--tags', help='semicolon separated tags -> python;lambda') args = parser.parse_args() main(args)"
            },
            {
                "url": 2590,
                "code": "def from_traceback(cls, tb): while tb.tb_next: tb = tb.tb_next return cls(tb.tb_frame.f_code, current_offset=tb.tb_lasti)"
            },
            {
                "url": 4757,
                "code": "def excepthook(self, etype, value, tb): self.showtraceback((etype,value,tb),tb_offset=0)"
            }
        ],
        "url": 900
    },
    {
        "nl_input": "python dictionary url encode",
        "code_input": [
            {
                "url": 2486,
                "code": "def get_dict_to_encoded_url(data): unicode_data = dict([(k, smart_str(v)) for k, v in data.items()]) encoded = urllib.urlencode(unicode_data) return encoded"
            },
            {
                "url": 191,
                "code": "def dict_to_querystring(dictionary): s = u\"\" for d in dictionary.keys(): s = unicode.format(u\"{0}{1}={2}&\", s, d, dictionary[d]) return s[:-1]"
            },
            {
                "url": 548,
                "code": "def url_encode(url): if isinstance(url, text_type): url = url.encode('utf8') return quote(url, ':/%?&=')"
            },
            {
                "url": 5769,
                "code": "def encode_list(key, list_): # type: (str, Iterable) -> Dict[str, str] if not list_: return {} return {key: \" \".join(str(i) for i in list_)}"
            },
            {
                "url": 5974,
                "code": "def translate_dict(cls, val): escaped = ', '.join( [\"{} -> {}\".format(cls.translate_str(k), cls.translate(v)) for k, v in val.items()] ) return 'Map({})'.format(escaped)"
            },
            {
                "url": 189,
                "code": "def dict_to_html_attrs(dict_): res = ' '.join('%s=\"%s\"' % (k, v) for k, v in dict_.items()) return res"
            },
            {
                "url": 4880,
                "code": "def _convert_dict_to_json(array): return json.dumps( array, skipkeys=False, allow_nan=False, indent=None, separators=(\",\", \":\"), sort_keys=True, default=lambda o: o.__dict__, )"
            },
            {
                "url": 2540,
                "code": "def urlencoded(body, charset='ascii', **kwargs): return parse_query_string(text(body, charset=charset), False)"
            },
            {
                "url": 711,
                "code": "def dict_jsonp(param): if not isinstance(param, dict): param = dict(param) return jsonp(param)"
            },
            {
                "url": 1059,
                "code": "def _dict_to_proto(py_dict, proto): dict_json_str = json.dumps(py_dict) return json_format.Parse(dict_json_str, proto)"
            },
            {
                "url": 1391,
                "code": "def pretty_dict_string(d, indent=0): s = '' for key, value in sorted(d.items()): s += ' ' * indent + str(key) if isinstance(value, dict): s += '\\n' + pretty_dict_string(value, indent+1) else: s += '=' + str(value) + '\\n' return s"
            },
            {
                "url": 2166,
                "code": "def encode(strs): res = '' for string in strs.split(): res += str(len(string)) + \":\" + string return res"
            },
            {
                "url": 684,
                "code": "def pretty_dict_str(d, indent=2): b = StringIO() write_pretty_dict_str(b, d, indent=indent) return b.getvalue()"
            },
            {
                "url": 1583,
                "code": "def dict_to_numpy_array(d): return fromarrays(d.values(), np.dtype([(str(k), v.dtype) for k, v in d.items()]))"
            },
            {
                "url": 2685,
                "code": "def str_dict(some_dict): return {str(k): str(v) for k, v in some_dict.items()}"
            }
        ],
        "url": 2486
    },
    {
        "nl_input": "how to check whether a string is int in python",
        "code_input": [
            {
                "url": 1791,
                "code": "def is_int(string): try: a = float(string) b = int(a) except ValueError: return False else: return a == b"
            },
            {
                "url": 5776,
                "code": "def _isint(string): return type(string) is int or \\ (isinstance(string, _binary_type) or isinstance(string, _text_type)) and \\ _isconvertible(int, string)"
            },
            {
                "url": 2437,
                "code": "def check_int(integer): if not isinstance(integer, str): return False if integer[0] in ('-', '+'): return integer[1:].isdigit() return integer.isdigit()"
            },
            {
                "url": 2128,
                "code": "def is_integer(obj): if PYTHON3: return isinstance(obj, int) return isinstance(obj, (int, long))"
            },
            {
                "url": 637,
                "code": "def is_int(value): if isinstance(value, bool): return False try: int(value) return True except (ValueError, TypeError): return False"
            },
            {
                "url": 1329,
                "code": "def validate_int(value): if value and not isinstance(value, int): try: int(str(value)) except (TypeError, ValueError): raise ValidationError('not a valid number') return value"
            },
            {
                "url": 3523,
                "code": "def is_int_type(val): try: # Python 2 return isinstance(val, (int, long)) except NameError: # Python 3 return isinstance(val, int)"
            },
            {
                "url": 5567,
                "code": "def is_integer(value: Any) -> bool: return (isinstance(value, int) and not isinstance(value, bool)) or ( isinstance(value, float) and isfinite(value) and int(value) == value )"
            },
            {
                "url": 1860,
                "code": "def str2int(string_with_int): return int(\"\".join([char for char in string_with_int if char in string.digits]) or 0)"
            },
            {
                "url": 1121,
                "code": "def check_str(obj): if isinstance(obj, str): return obj if isinstance(obj, float): return str(int(obj)) else: return str(obj)"
            },
            {
                "url": 4573,
                "code": "def test_value(self, value): if not isinstance(value, int): raise ValueError('expected int value: ' + str(type(value)))"
            },
            {
                "url": 5836,
                "code": "def clean_int(x) -> int: try: return int(x) except ValueError: raise forms.ValidationError( \"Cannot convert to integer: {}\".format(repr(x)))"
            },
            {
                "url": 289,
                "code": "def _check_for_int(x): try: y = int(x) except (OverflowError, ValueError): pass else: # There is no way in AMF0 to distinguish between integers and floats if x == x and y == x: return y return x"
            },
            {
                "url": 5274,
                "code": "def convert_string(string): if is_int(string): return int(string) elif is_float(string): return float(string) elif convert_bool(string)[0]: return convert_bool(string)[1] elif string == 'None': return None else: return string"
            },
            {
                "url": 4975,
                "code": "def is_integer(dtype): dtype = tf.as_dtype(dtype) if hasattr(dtype, 'is_integer'): return dtype.is_integer return np.issubdtype(np.dtype(dtype), np.integer)"
            }
        ],
        "url": 5776
    },
    {
        "nl_input": "python 3 change permission of file chmod",
        "code_input": [
            {
                "url": 1658,
                "code": "def chmod(f): try: os.chmod(f, S_IWRITE) # windows (cover all) except Exception as e: pass try: os.chmod(f, 0o777) # *nix except Exception as e: pass"
            },
            {
                "url": 2424,
                "code": "def chmod(scope, filename, mode): for file in filename: os.chmod(file, mode[0]) return True"
            },
            {
                "url": 2690,
                "code": "def chmod_plus_w(path): path_mode = os.stat(path).st_mode path_mode &= int('777', 8) path_mode |= stat.S_IWRITE os.chmod(path, path_mode)"
            },
            {
                "url": 3432,
                "code": "def make_writeable(filename): if not os.access(filename, os.W_OK): st = os.stat(filename) new_permissions = stat.S_IMODE(st.st_mode) | stat.S_IWUSR os.chmod(filename, new_permissions)"
            },
            {
                "url": 2659,
                "code": "def add_exec_permission_to(target_file): mode = os.stat(target_file).st_mode os.chmod(target_file, mode | stat.S_IXUSR)"
            },
            {
                "url": 940,
                "code": "def chmod(self, mode): self.sftp._log(DEBUG, 'chmod(%s, %r)' % (hexlify(self.handle), mode)) attr = SFTPAttributes() attr.st_mode = mode self.sftp._request(CMD_FSETSTAT, self.handle, attr)"
            },
            {
                "url": 561,
                "code": "def make_file_read_only(file_path): old_permissions = os.stat(file_path).st_mode os.chmod(file_path, old_permissions & ~WRITE_PERMISSIONS)"
            },
            {
                "url": 1152,
                "code": "def chmod_add_excute(filename): st = os.stat(filename) os.chmod(filename, st.st_mode | stat.S_IEXEC)"
            },
            {
                "url": 3032,
                "code": "def set_executable(filename): st = os.stat(filename) os.chmod(filename, st.st_mode | stat.S_IEXEC)"
            },
            {
                "url": 698,
                "code": "def copy_no_perm(src, dst): shutil.copy(src, dst) perm = os.stat(dst).st_mode shutil.copystat(src, dst) os.chmod(dst, perm)"
            },
            {
                "url": 4838,
                "code": "def flipwritable(fn, mode=None): if os.access(fn, os.W_OK): return None old_mode = os.stat(fn).st_mode os.chmod(fn, stat.S_IWRITE | old_mode) return old_mode"
            },
            {
                "url": 4551,
                "code": "def rmfile(path): if osp.isfile(path): if is_win: os.chmod(path, 0o777) os.remove(path)"
            },
            {
                "url": 3186,
                "code": "def is_writable_by_others(filename): mode = os.stat(filename)[stat.ST_MODE] return mode & stat.S_IWOTH"
            },
            {
                "url": 341,
                "code": "def make_executable(script_path): status = os.stat(script_path) os.chmod(script_path, status.st_mode | stat.S_IEXEC)"
            },
            {
                "url": 4732,
                "code": "def set_file_mtime(path, mtime, atime=None): if not atime: atime = mtime f = open(path, 'a') try: os.utime(path, (atime, mtime)) finally: f.close()"
            }
        ],
        "url": 2659
    },
    {
        "nl_input": "python gaussian filter array",
        "code_input": [
            {
                "url": 374,
                "code": "def smooth_gaussian(image, sigma=1): return scipy.ndimage.filters.gaussian_filter(image, sigma=sigma, mode=\"nearest\")"
            },
            {
                "url": 316,
                "code": "def convolve_gaussian_2d(image, gaussian_kernel_1d): result = scipy.ndimage.filters.correlate1d( image, gaussian_kernel_1d, axis=0) result = scipy.ndimage.filters.correlate1d( result, gaussian_kernel_1d, axis=1) return result"
            },
            {
                "url": 3083,
                "code": "def GaussianBlur(X, ksize_width, ksize_height, sigma_x, sigma_y): return image_transform( X, cv2.GaussianBlur, ksize=(ksize_width, ksize_height), sigmaX=sigma_x, sigmaY=sigma_y )"
            },
            {
                "url": 6200,
                "code": "def kernel(self, spread=1): # TODO: use self.kernel_type to choose function def gaussian(data, pixel): return mvn.pdf(data, mean=pixel, cov=spread) return gaussian"
            },
            {
                "url": 5069,
                "code": "def gaussian_kernel(gstd): Nc = np.ceil(gstd*3)*2+1 x = np.linspace(-(Nc-1)/2,(Nc-1)/2,Nc,endpoint=True) g = np.exp(-.5*((x/gstd)**2)) g = g/np.sum(g) return g"
            },
            {
                "url": 4967,
                "code": "def gaussian_kernel(sigma, truncate=4.0): sigma = float(sigma) radius = int(truncate * sigma + 0.5) x, y = np.mgrid[-radius:radius + 1, -radius:radius + 1] sigma = sigma ** 2 k = 2 * np.exp(-0.5 * (x ** 2 + y ** 2) / sigma) k = k / np.sum(k) return k"
            },
            {
                "url": 5689,
                "code": "def smooth_image(image, sigma, sigma_in_physical_coordinates=True, FWHM=False, max_kernel_width=32): if image.components == 1: return _smooth_image_helper(image, sigma, sigma_in_physical_coordinates, FWHM, max_kernel_width) else: imagelist = utils.split_channels(image) newimages = [] for image in imagelist: newimage = _smooth_image_helper(image, sigma, sigma_in_physical_coordinates, FWHM, max_kernel_width) newimages.append(newimage) return utils.merge_channels(newimages)"
            },
            {
                "url": 2935,
                "code": "def Gaussian(x, a, x0, sigma, y0): return a * np.exp(-(x - x0) ** 2 / (2 * sigma ** 2)) + y0"
            },
            {
                "url": 1591,
                "code": "def gaussian_variogram_model(m, d): psill = float(m[0]) range_ = float(m[1]) nugget = float(m[2]) return psill * (1. - np.exp(-d**2./(range_*4./7.)**2.)) + nugget"
            },
            {
                "url": 376,
                "code": "def EvalGaussianPdf(x, mu, sigma): return scipy.stats.norm.pdf(x, mu, sigma)"
            },
            {
                "url": 5281,
                "code": "def compute_ssim(image1, image2, gaussian_kernel_sigma=1.5, gaussian_kernel_width=11): gaussian_kernel_1d = get_gaussian_kernel( gaussian_kernel_width, gaussian_kernel_sigma) return SSIM(image1, gaussian_kernel_1d).ssim_value(image2)"
            },
            {
                "url": 2753,
                "code": "def get_2D_samples_gauss(n, m, sigma, random_state=None): return make_2D_samples_gauss(n, m, sigma, random_state=None)"
            },
            {
                "url": 5668,
                "code": "def _gaussian_function(self, datalength: int, values: np.ndarray, height: int, index: int) -> np.ndarray: return height * np.exp(-(1 / (self.spread_number * datalength)) * (values - ((datalength / self.function_number) * index)) ** 2)"
            },
            {
                "url": 3457,
                "code": "def convolve_fft(array, kernel): array = np.asarray(array, dtype=np.complex) kernel = np.asarray(kernel, dtype=np.complex) if array.ndim != kernel.ndim: raise ValueError(\"Image and kernel must have same number of \" \"dimensions\") array_shape = array.shape kernel_shape = kernel.shape new_shape = np.array(array_shape) + np.array(kernel_shape) array_slices = [] kernel_slices = [] for (new_dimsize, array_dimsize, kernel_dimsize) in zip( new_shape, array_shape, kernel_shape): center = new_dimsize - (new_dimsize + 1) // 2 array_slices += [slice(center - array_dimsize // 2, center + (array_dimsize + 1) // 2)] kernel_slices += [slice(center - kernel_dimsize // 2, center + (kernel_dimsize + 1) // 2)] array_slices = tuple(array_slices) kernel_slices = tuple(kernel_slices) if not np.all(new_shape == array_shape): big_array = np.zeros(new_shape, dtype=np.complex) big_array[array_slices] = array else: big_array = array if not np.all(new_shape == kernel_shape): big_kernel = np.zeros(new_shape, dtype=np.complex) big_kernel[kernel_slices] = kernel else: big_kernel = kernel array_fft = np.fft.fftn(big_array) kernel_fft = np.fft.fftn(np.fft.ifftshift(big_kernel)) rifft = np.fft.ifftn(array_fft * kernel_fft) return rifft[array_slices].real"
            },
            {
                "url": 3676,
                "code": "def gaussian_noise(x, severity=1): c = [.08, .12, 0.18, 0.26, 0.38][severity - 1] x = np.array(x) / 255. x_clip = np.clip(x + np.random.normal(size=x.shape, scale=c), 0, 1) * 255 return around_and_astype(x_clip)"
            }
        ],
        "url": 374
    },
    {
        "nl_input": "how to cut off a calculated number to two decimals in python",
        "code_input": [
            {
                "url": 321,
                "code": "def round_to_float(number, precision): rounded = Decimal(str(floor((number + precision / 2) // precision)) ) * Decimal(str(precision)) return float(rounded)"
            },
            {
                "url": 2296,
                "code": "def drop_trailing_zeros_decimal(num): out = str(num) return out.rstrip('0').rstrip('.') if '.' in out else out"
            },
            {
                "url": 4489,
                "code": "def round_float(f, digits, rounding=ROUND_HALF_UP): return Decimal(str(f)).quantize(Decimal(10) ** (-1 * digits), rounding=rounding)"
            },
            {
                "url": 60,
                "code": "def round_to_int(number, precision): precision = int(precision) rounded = (int(number) + precision / 2) // precision * precision return rounded"
            },
            {
                "url": 3610,
                "code": "def fixed(ctx, number, decimals=2, no_commas=False): value = _round(ctx, number, decimals) format_str = '{:f}' if no_commas else '{:,f}' return format_str.format(value)"
            },
            {
                "url": 658,
                "code": "def round_to_x_digits(number, digits): return round(number * math.pow(10, digits)) / math.pow(10, digits)"
            },
            {
                "url": 4008,
                "code": "def drop_trailing_zeros(num): txt = '%f' %(num) txt = txt.rstrip('0') if txt.endswith('.'): txt = txt[:-1] return txt"
            },
            {
                "url": 6258,
                "code": "def trim_decimals(s, precision=-3): encoded = s.encode('ascii', 'ignore') str_val = \"\" if six.PY3: str_val = str(encoded, encoding='ascii', errors='ignore')[:precision] else: # If precision is 0, this must be handled seperately if precision == 0: str_val = str(encoded) else: str_val = str(encoded)[:precision] if len(str_val) > 0: return float(str_val) else: return 0"
            },
            {
                "url": 2579,
                "code": "def py3round(number): if abs(round(number) - number) == 0.5: return int(2.0 * round(number / 2.0)) return int(round(number))"
            },
            {
                "url": 4260,
                "code": "def print_float(self, value, decimal_digits=2, justify_right=True): format_string = '{{0:0.{0}F}}'.format(decimal_digits) self.print_number_str(format_string.format(value), justify_right)"
            },
            {
                "url": 5704,
                "code": "def truncate(value: Decimal, n_digits: int) -> Decimal: return Decimal(math.trunc(value * (10 ** n_digits))) / (10 ** n_digits)"
            },
            {
                "url": 2300,
                "code": "def specialRound(number, rounding): temp = 0 if rounding == 0: temp = number else: temp = round(number, rounding) if temp % 1 == 0: return int(temp) else: return float(temp)"
            },
            {
                "url": 2309,
                "code": "def price_rounding(price, decimals=2): try: exponent = D('.' + decimals * '0') except InvalidOperation: # Currencies with no decimal places, ex. JPY, HUF exponent = D() return price.quantize(exponent, rounding=ROUND_UP)"
            },
            {
                "url": 1062,
                "code": "def get_rounded(self, digits): result = self.copy() result.round(digits) return result"
            },
            {
                "url": 323,
                "code": "def intround(value): return int(decimal.Decimal.from_float( value).to_integral_value(decimal.ROUND_HALF_EVEN))"
            }
        ],
        "url": 5704
    },
    {
        "nl_input": "replace many value at once in python",
        "code_input": [
            {
                "url": 1023,
                "code": "def multi_replace(instr, search_list=[], repl_list=None): repl_list = [''] * len(search_list) if repl_list is None else repl_list for ser, repl in zip(search_list, repl_list): instr = instr.replace(ser, repl) return instr"
            },
            {
                "url": 5699,
                "code": "def replace_in_list(stringlist: Iterable[str], replacedict: Dict[str, str]) -> List[str]: newlist = [] for fromstring in stringlist: newlist.append(multiple_replace(fromstring, replacedict)) return newlist"
            },
            {
                "url": 5928,
                "code": "def multiple_replace(string, replacements): # type: (str, Dict[str,str]) -> str pattern = re.compile(\"|\".join([re.escape(k) for k in sorted(replacements, key=len, reverse=True)]), flags=re.DOTALL) return pattern.sub(lambda x: replacements[x.group(0)], string)"
            },
            {
                "url": 4308,
                "code": "def _replace(self, data, replacements): for find, repl in replacements: data = data.replace(find, repl) return data"
            },
            {
                "url": 3181,
                "code": "def replace(s, replace): for r in replace: s = s.replace(*r) return s"
            },
            {
                "url": 3362,
                "code": "def replace_list(items, match, replacement): return [replace(item, match, replacement) for item in items]"
            },
            {
                "url": 5637,
                "code": "def __replace_all(repls: dict, input: str) -> str: return re.sub('|'.join(re.escape(key) for key in repls.keys()), lambda k: repls[k.group(0)], input)"
            },
            {
                "url": 2767,
                "code": "def replace_all(text, dic): for i, j in dic.iteritems(): text = text.replace(i, j) return text"
            },
            {
                "url": 656,
                "code": "def myreplace(astr, thefind, thereplace): alist = astr.split(thefind) new_s = alist.split(thereplace) return new_s"
            },
            {
                "url": 1210,
                "code": "def replace(scope, strings, source, dest): return [s.replace(source[0], dest[0]) for s in strings]"
            },
            {
                "url": 6132,
                "code": "def dictlist_replace(dict_list: Iterable[Dict], key: str, value: Any) -> None: for d in dict_list: d[key] = value"
            },
            {
                "url": 5988,
                "code": "def replace(s, old, new, maxreplace=-1): return s.replace(old, new, maxreplace)"
            },
            {
                "url": 5076,
                "code": "def list_replace(subject_list, replacement, string): for s in subject_list: string = string.replace(s, replacement) return string"
            },
            {
                "url": 513,
                "code": "def replace_all(filepath, searchExp, replaceExp): for line in fileinput.input(filepath, inplace=1): if searchExp in line: line = line.replace(searchExp, replaceExp) sys.stdout.write(line)"
            },
            {
                "url": 6031,
                "code": "def replace_variables(self, source: str, variables: dict) -> str: try: replaced = re.sub( \"{{(.*?)}}\", lambda m: variables.get(m.group(1), \"\"), source ) except TypeError: replaced = source return replaced"
            }
        ],
        "url": 3362
    },
    {
        "nl_input": "python numpy conver to float64",
        "code_input": [
            {
                "url": 64,
                "code": "def cfloat64_array_to_numpy(cptr, length): if isinstance(cptr, ctypes.POINTER(ctypes.c_double)): return np.fromiter(cptr, dtype=np.float64, count=length) else: raise RuntimeError('Expected double pointer')"
            },
            {
                "url": 82,
                "code": "def cfloat32_array_to_numpy(cptr, length): if isinstance(cptr, ctypes.POINTER(ctypes.c_float)): return np.fromiter(cptr, dtype=np.float32, count=length) else: raise RuntimeError('Expected float pointer')"
            },
            {
                "url": 79,
                "code": "def cint32_array_to_numpy(cptr, length): if isinstance(cptr, ctypes.POINTER(ctypes.c_int32)): return np.fromiter(cptr, dtype=np.int32, count=length) else: raise RuntimeError('Expected int pointer')"
            },
            {
                "url": 84,
                "code": "def cint8_array_to_numpy(cptr, length): if isinstance(cptr, ctypes.POINTER(ctypes.c_int8)): return np.fromiter(cptr, dtype=np.int8, count=length) else: raise RuntimeError('Expected int pointer')"
            },
            {
                "url": 4198,
                "code": "def _maybe_cast_to_float64(da): if da.dtype == np.float32: logging.warning('Datapoints were stored using the np.float32 datatype.' 'For accurate reduction operations using bottleneck, ' 'datapoints are being cast to the np.float64 datatype.' ' For more information see: https://github.com/pydata/' 'xarray/issues/1346') return da.astype(np.float64) else: return da"
            },
            {
                "url": 4148,
                "code": "def ensure_dtype_float(x, default=np.float64): r if isinstance(x, np.ndarray): if x.dtype.kind == 'f': return x elif x.dtype.kind == 'i': return x.astype(default) else: raise TypeError('x is of type '+str(x.dtype)+' that cannot be converted to float') else: raise TypeError('x is not an array')"
            },
            {
                "url": 1870,
                "code": "def _to_array(value): if isinstance(value, (tuple, list)): return array(value) elif isinstance(value, (float, int)): return np.float64(value) else: return value"
            },
            {
                "url": 2305,
                "code": "def is_float_array(val): return is_np_array(val) and issubclass(val.dtype.type, np.floating)"
            },
            {
                "url": 894,
                "code": "def safe_int_conv(number): try: return int(np.array(number).astype(int, casting='safe')) except TypeError: raise ValueError('cannot safely convert {} to integer'.format(number))"
            },
            {
                "url": 772,
                "code": "def is_float(value): return isinstance(value, float) or isinstance(value, int) or isinstance(value, np.float64), float(value)"
            },
            {
                "url": 655,
                "code": "def is_float_array(l): r if isinstance(l, np.ndarray): if l.dtype.kind == 'f': return True return False"
            },
            {
                "url": 1583,
                "code": "def dict_to_numpy_array(d): return fromarrays(d.values(), np.dtype([(str(k), v.dtype) for k, v in d.items()]))"
            },
            {
                "url": 6117,
                "code": "def numpy_to_yaml(representer: Representer, data: np.ndarray) -> Sequence[Any]: return representer.represent_sequence( \"!numpy_array\", data.tolist() )"
            },
            {
                "url": 483,
                "code": "def _convert_to_float_if_possible(s): try: ret = float(s) except (ValueError, TypeError): ret = s return ret"
            },
            {
                "url": 5543,
                "code": "def dictlist_convert_to_float(dict_list: Iterable[Dict], key: str) -> None: for d in dict_list: try: d[key] = float(d[key]) except ValueError: d[key] = None"
            }
        ],
        "url": 854
    },
    {
        "nl_input": "python how to rank a list object",
        "code_input": [
            {
                "url": 4604,
                "code": "def ranks(self, key, value): return [normalize_rank(el) for el in force_list(value.get('a'))]"
            },
            {
                "url": 583,
                "code": "def _rank(self, ranking, n): return nlargest(n, ranking, key=ranking.get)"
            },
            {
                "url": 5999,
                "code": "def revrank_dict(dict, key=lambda t: t[1], as_tuple=False): sorted_list = sorted(dict.items(), key=key, reverse=True) return OrderedDict(sorted_list) if not as_tuple else tuple(sorted_list)"
            },
            {
                "url": 2183,
                "code": "def rank(self): r = np.empty(self.size, np.int) r[self.sorter] = np.arange(self.size) return r"
            },
            {
                "url": 320,
                "code": "def count_list(the_list): count = the_list.count result = [(item, count(item)) for item in set(the_list)] result.sort() return result"
            },
            {
                "url": 2253,
                "code": "def zrank(self, name, value): with self.pipe as pipe: value = self.valueparse.encode(value) return pipe.zrank(self.redis_key(name), value)"
            },
            {
                "url": 4334,
                "code": "def natural_sort(list, key=lambda s:s): def get_alphanum_key_func(key): convert = lambda text: int(text) if text.isdigit() else text return lambda s: [convert(c) for c in re.split('([0-9]+)', key(s))] sort_key = get_alphanum_key_func(key) list.sort(key=sort_key)"
            },
            {
                "url": 5551,
                "code": "def list_depth(list_, func=max, _depth=0): depth_list = [list_depth(item, func=func, _depth=_depth + 1) for item in list_ if util_type.is_listlike(item)] if len(depth_list) > 0: return func(depth_list) else: return _depth"
            },
            {
                "url": 5770,
                "code": "def natural_sort(list_to_sort: Iterable[str]) -> List[str]: return sorted(list_to_sort, key=natural_keys)"
            },
            {
                "url": 420,
                "code": "def rank(idx, dim): idxm = multi_index(idx, dim) out = 0 while idxm[-1:] == (0,): out += 1 idxm = idxm[:-1] return out"
            },
            {
                "url": 5013,
                "code": "def zs(inlist): zscores = [] for item in inlist: zscores.append(z(inlist, item)) return zscores"
            },
            {
                "url": 2383,
                "code": "def delistify(x): if isinstance(x, list): x = [e.replace(\"'\", \"\") for e in x] return '-'.join(sorted(x)) return x"
            },
            {
                "url": 1177,
                "code": "def sort_nicely(l): convert = lambda text: int(text) if text.isdigit() else text alphanum_key = lambda key: [convert(c) for c in re.split('([0-9]+)', key)] l.sort(key=alphanum_key)"
            },
            {
                "url": 4603,
                "code": "def _normalize(obj): if isinstance(obj, list): return [_normalize(item) for item in obj] elif isinstance(obj, dict): return {k: _normalize(v) for k, v in obj.items() if v is not None} elif hasattr(obj, 'to_python'): return obj.to_python() return obj"
            },
            {
                "url": 1172,
                "code": "def sort_dict(d, key=None, reverse=False): kv_items = [kv for kv in d.items()] # Sort kv_items according to key. if key is None: kv_items.sort(key=lambda t: t[1], reverse=reverse) else: kv_items.sort(key=key, reverse=reverse) # Build ordered dict. return collections.OrderedDict(kv_items)"
            }
        ],
        "url": 4604
    },
    {
        "nl_input": "how to check if file doesn't exist in python",
        "code_input": [
            {
                "url": 4496,
                "code": "def is_valid_file(parser,arg): if not os.path.exists(arg): parser.error(\"File %s not found\"%arg) else: return arg"
            },
            {
                "url": 2931,
                "code": "def is_valid_file(parser, arg): arg = os.path.abspath(arg) if not os.path.exists(arg): parser.error(\"The file %s does not exist!\" % arg) else: return arg"
            },
            {
                "url": 2959,
                "code": "def _file_exists(path, filename): return os.path.isfile(os.path.join(path, filename))"
            },
            {
                "url": 5731,
                "code": "def file_exists(fname): try: return fname and os.path.exists(fname) and os.path.getsize(fname) > 0 except OSError: return False"
            },
            {
                "url": 5533,
                "code": "def is_file_exists_error(e): if six.PY3: return isinstance(e, FileExistsError) # noqa: F821 else: return isinstance(e, OSError) and e.errno == 17"
            },
            {
                "url": 5808,
                "code": "def valid_file(path: str) -> bool: path = Path(path).expanduser() log.debug(\"checking if %s is a valid file\", path) return path.exists() and path.is_file()"
            },
            {
                "url": 2011,
                "code": "def _file_and_exists(val, input_files): return ((os.path.exists(val) and os.path.isfile(val)) or val in input_files)"
            },
            {
                "url": 1166,
                "code": "def file_found(filename,force): if os.path.exists(filename) and not force: logger.info(\"Found %s; skipping...\"%filename) return True else: return False"
            },
            {
                "url": 4843,
                "code": "def remote_file_exists(self, url): status = requests.head(url).status_code if status != 200: raise RemoteFileDoesntExist"
            },
            {
                "url": 4953,
                "code": "def exists(self, path): import hdfs try: self.client.status(path) return True except hdfs.util.HdfsError as e: if str(e).startswith('File does not exist: '): return False else: raise e"
            },
            {
                "url": 1608,
                "code": "def is_valid_folder(parser, arg): arg = os.path.abspath(arg) if not os.path.isdir(arg): parser.error(\"The folder %s does not exist!\" % arg) else: return arg"
            },
            {
                "url": 3323,
                "code": "def isemptyfile(filepath): exists = os.path.exists(safepath(filepath)) if exists: filesize = os.path.getsize(safepath(filepath)) return filesize == 0 else: return False"
            },
            {
                "url": 3646,
                "code": "def _one_exists(input_files): for f in input_files: if os.path.exists(f): return True return False"
            },
            {
                "url": 239,
                "code": "def _pip_exists(self): return os.path.isfile(os.path.join(self.path, 'bin', 'pip'))"
            },
            {
                "url": 2400,
                "code": "def exists(self, filepath): if self.is_ssh(filepath): self._check_ftp() remotepath = self._get_remote(filepath) try: self.ftp.stat(remotepath) except IOError as e: if e.errno == errno.ENOENT: return False else: return True else: return os.path.exists(filepath)"
            }
        ],
        "url": 2931
    },
    {
        "nl_input": "how to get the parent directory in python",
        "code_input": [
            {
                "url": 415,
                "code": "def get_parent_dir(name): parent_dir = os.path.dirname(os.path.dirname(name)) if parent_dir: return parent_dir return os.path.abspath('.')"
            },
            {
                "url": 1895,
                "code": "def get_parent_folder_name(file_path): return os.path.split(os.path.split(os.path.abspath(file_path))[0])[-1]"
            },
            {
                "url": 482,
                "code": "def go_to_parent_directory(self): self.chdir(osp.abspath(osp.join(getcwd_or_home(), os.pardir)))"
            },
            {
                "url": 1426,
                "code": "def path(self): return pathlib.Path(self.package.__file__).resolve().parent.parent"
            },
            {
                "url": 692,
                "code": "def get_absolute_path(*args): directory = os.path.dirname(os.path.abspath(__file__)) return os.path.join(directory, *args)"
            },
            {
                "url": 991,
                "code": "def find_root(self): cmd = self while cmd.parent: cmd = cmd.parent return cmd"
            },
            {
                "url": 2746,
                "code": "def makedirs(directory): parent = os.path.dirname(os.path.abspath(directory)) if not os.path.exists(parent): makedirs(parent) os.mkdir(directory)"
            },
            {
                "url": 3810,
                "code": "def grandparent_path(self): return os.path.basename(os.path.join(self.path, '../..'))"
            },
            {
                "url": 3737,
                "code": "def get_base_dir(): return os.path.split(os.path.abspath(os.path.dirname(__file__)))[0]"
            },
            {
                "url": 3020,
                "code": "def _IsDirectory(parent, item): return tf.io.gfile.isdir(os.path.join(parent, item))"
            },
            {
                "url": 1712,
                "code": "def getpackagepath(): moduleDirectory = os.path.dirname(__file__) packagePath = os.path.dirname(__file__) + \"/../\" return packagePath"
            },
            {
                "url": 4936,
                "code": "def get_system_root_directory(): root = os.path.dirname(__file__) root = os.path.dirname(root) root = os.path.abspath(root) return root"
            },
            {
                "url": 1945,
                "code": "def set_parent_path(self, value): self._parent_path = value self.path = value + r'/' + self.name self._update_childrens_parent_path()"
            },
            {
                "url": 5425,
                "code": "def dump_parent(self, obj): if not self._is_parent(obj): return self._dump_relative(obj.pid) return None"
            },
            {
                "url": 853,
                "code": "def path_for_import(name): return os.path.dirname(os.path.abspath(import_module(name).__file__))"
            }
        ],
        "url": 415
    },
    {
        "nl_input": "resize an image python pil",
        "code_input": [
            {
                "url": 2018,
                "code": "def resize(self, size): return Image(self.pil_image.resize(size, PIL.Image.ANTIALIAS))"
            },
            {
                "url": 1142,
                "code": "def resize_image(self, data, size): from machina.core.compat import PILImage as Image image = Image.open(BytesIO(data)) # Resize! image.thumbnail(size, Image.ANTIALIAS) string = BytesIO() image.save(string, format='PNG') return string.getvalue()"
            },
            {
                "url": 4823,
                "code": "def resize(self): resized_size = self.get_resized_size() if not resized_size: return self.image = self.image.resize(resized_size, Image.ANTIALIAS)"
            },
            {
                "url": 1269,
                "code": "def resize_image_to_fit_width(image, dest_w): scale_factor = dest_w / image.size[0] dest_h = image.size[1] * scale_factor scaled_image = image.resize((int(dest_w), int(dest_h)), PIL.Image.ANTIALIAS) return scaled_image"
            },
            {
                "url": 5568,
                "code": "def getDimensionForImage(filename, maxsize): try: from PIL import Image except ImportError: return None img = Image.open(filename) width, height = img.size if width > maxsize[0] or height > maxsize[1]: img.thumbnail(maxsize) out.info(\"Downscaled display size from %s to %s\" % ((width, height), img.size)) return img.size"
            },
            {
                "url": 1466,
                "code": "def resize_by_area(img, size): return tf.to_int64( tf.image.resize_images(img, [size, size], tf.image.ResizeMethod.AREA))"
            },
            {
                "url": 3209,
                "code": "def display_pil_image(im): from IPython.core import display b = BytesIO() im.save(b, format='png') data = b.getvalue() ip_img = display.Image(data=data, format='png', embed=True) return ip_img._repr_png_()"
            },
            {
                "url": 4663,
                "code": "def new(self, size, fill): return Image(PIL.Image.new(\"RGB\", size, fill))"
            },
            {
                "url": 5328,
                "code": "def open_as_pillow(filename): with __sys_open(filename, 'rb') as f: data = BytesIO(f.read()) return Image.open(data)"
            },
            {
                "url": 2551,
                "code": "def resize_image_with_crop_or_pad(img, target_height, target_width): h, w = target_height, target_width max_h, max_w, c = img.shape # crop img = crop_center(img, min(max_h, h), min(max_w, w)) # pad padded_img = np.zeros(shape=(h, w, c), dtype=img.dtype) padded_img[:img.shape[0], :img.shape[1], :img.shape[2]] = img return padded_img"
            },
            {
                "url": 3128,
                "code": "def scale_image(image, new_width): (original_width, original_height) = image.size aspect_ratio = original_height/float(original_width) new_height = int(aspect_ratio * new_width) # This scales it wider than tall, since characters are biased new_image = image.resize((new_width*2, new_height)) return new_image"
            },
            {
                "url": 5683,
                "code": "def resize(im, short, max_size): im_shape = im.shape im_size_min = np.min(im_shape[0:2]) im_size_max = np.max(im_shape[0:2]) im_scale = float(short) / float(im_size_min) # prevent bigger axis from being more than max_size: if np.round(im_scale * im_size_max) > max_size: im_scale = float(max_size) / float(im_size_max) im = cv2.resize(im, None, None, fx=im_scale, fy=im_scale, interpolation=cv2.INTER_LINEAR) return im, im_scale"
            },
            {
                "url": 4784,
                "code": "def get_img_data(f, maxsize = (1200, 850), first = False): img = Image.open(f) img.thumbnail(maxsize) if first: # tkinter is inactive the first time bio = io.BytesIO() img.save(bio, format = \"PNG\") del img return bio.getvalue() return ImageTk.PhotoImage(img)"
            },
            {
                "url": 5421,
                "code": "def file_to_png(fp): import PIL.Image # pylint: disable=import-error with io.BytesIO() as dest: PIL.Image.open(fp).save(dest, \"PNG\", optimize=True) return dest.getvalue()"
            },
            {
                "url": 6050,
                "code": "def _width_is_big_enough(image, width): if width > image.size[0]: raise ImageSizeError(image.size[0], width)"
            }
        ],
        "url": 2018
    },
    {
        "nl_input": "python boxplot data frame",
        "code_input": [
            {
                "url": 2783,
                "code": "def compute_boxplot(self, series): from matplotlib.cbook import boxplot_stats series = series[series.notnull()] if len(series.values) == 0: return {} elif not is_numeric_dtype(series): return self.non_numeric_stats(series) stats = boxplot_stats(list(series.values))[0] stats['count'] = len(series.values) stats['fliers'] = \"|\".join(map(str, stats['fliers'])) return stats"
            },
            {
                "url": 3794,
                "code": "def scatterplot_matrix(df, features, downsample_frac=None, figsize=(15, 15)): if downsample_frac: df = df.sample(frac=downsample_frac) plt.figure(figsize=figsize) sns.pairplot(df[features], hue='target') plt.show()"
            },
            {
                "url": 5402,
                "code": "def PyplotHistogram(): import numpy as np import matplotlib.pyplot as plt np.random.seed(0) n_bins = 10 x = np.random.randn(1000, 3) fig, axes = plt.subplots(nrows=2, ncols=2) ax0, ax1, ax2, ax3 = axes.flatten() colors = ['red', 'tan', 'lime'] ax0.hist(x, n_bins, normed=1, histtype='bar', color=colors, label=colors) ax0.legend(prop={'size': 10}) ax0.set_title('bars with legend') ax1.hist(x, n_bins, normed=1, histtype='bar', stacked=True) ax1.set_title('stacked bar') ax2.hist(x, n_bins, histtype='step', stacked=True, fill=False) ax2.set_title('stack step (unfilled)') # Make a multiple-histogram of data-sets with different length. x_multi = [np.random.randn(n) for n in [10000, 5000, 2000]] ax3.hist(x_multi, n_bins, histtype='bar') ax3.set_title('different sample sizes') fig.tight_layout() return fig"
            },
            {
                "url": 2110,
                "code": "def _histplot_op(ax, data, **kwargs): bins = get_bins(data) ax.hist(data, bins=bins, align=\"left\", density=True, **kwargs) return ax"
            },
            {
                "url": 514,
                "code": "def __call__(self, kind: Optional[str] = None, **kwargs): return plot(self.histogram, kind=kind, **kwargs)"
            },
            {
                "url": 1311,
                "code": "def finish_plot(): plt.legend() plt.grid(color='0.7') plt.xlabel('x') plt.ylabel('y') plt.show()"
            },
            {
                "url": 2109,
                "code": "def plot(self): plt.plot(self.bin_edges, self.hist, self.bin_edges, self.best_pdf)"
            },
            {
                "url": 3404,
                "code": "def stackplot(marray, seconds=None, start_time=None, ylabels=None): tarray = np.transpose(marray) stackplot_t(tarray, seconds=seconds, start_time=start_time, ylabels=ylabels) plt.show()"
            },
            {
                "url": 3277,
                "code": "def _linear_seaborn_(self, label=None, style=None, opts=None): xticks, yticks = self._get_ticks(opts) try: fig = sns.lmplot(self.x, self.y, data=self.df) fig = self._set_with_height(fig, opts) return fig except Exception as e: self.err(e, self.linear_, \"Can not draw linear regression chart\")"
            },
            {
                "url": 3735,
                "code": "def oplot(self, x, y, **kw): self.panel.oplot(x, y, **kw)"
            },
            {
                "url": 3012,
                "code": "def show_correlation_matrix(self, correlation_matrix): cr_plot.create_correlation_matrix_plot( correlation_matrix, self.title, self.headers_to_test ) pyplot.show()"
            },
            {
                "url": 5215,
                "code": "def point8_to_box(points): p = points.reshape((-1, 4, 2)) minxy = p.min(axis=1) # nx2 maxxy = p.max(axis=1) # nx2 return np.concatenate((minxy, maxxy), axis=1)"
            },
            {
                "url": 944,
                "code": "def show_xticklabels(self, row, column): subplot = self.get_subplot_at(row, column) subplot.show_xticklabels()"
            },
            {
                "url": 1352,
                "code": "def add_plot(x, y, xl, yl, fig, ax, LATEX=False, linestyle=None, **kwargs): if LATEX: xl_data = xl[1] # NOQA yl_data = yl[1] else: xl_data = xl[0] # NOQA yl_data = yl[0] for idx in range(len(y)): ax.plot(x, y[idx], label=yl_data[idx], linestyle=linestyle) ax.legend(loc='upper right') ax.set_ylim(auto=True)"
            },
            {
                "url": 2680,
                "code": "def from_df(data_frame): labels = data_frame.keys().tolist() data = data_frame.values.tolist() return SqlTable(labels, data, \"{:.3f}\", \"\\n\")"
            }
        ],
        "url": 2783
    },
    {
        "nl_input": "python glpk read from lp file",
        "code_input": [
            {
                "url": 4588,
                "code": "def glpk_read_cplex(path): from swiglpk import glp_create_prob, glp_read_lp problem = glp_create_prob() glp_read_lp(problem, None, path) return problem"
            },
            {
                "url": 5862,
                "code": "def rl_get_point() -> int: # pragma: no cover if rl_type == RlType.GNU: return ctypes.c_int.in_dll(readline_lib, \"rl_point\").value elif rl_type == RlType.PYREADLINE: return readline.rl.mode.l_buffer.point else: return 0"
            },
            {
                "url": 876,
                "code": "def _openpyxl_read_xl(xl_path: str): try: wb = load_workbook(filename=xl_path, read_only=True) except: raise else: return wb"
            },
            {
                "url": 3134,
                "code": "def read_data(file, endian, num=1): res = struct.unpack(endian + 'L' * num, file.read(num * 4)) if len(res) == 1: return res[0] return res"
            },
            {
                "url": 4619,
                "code": "def main(pargs): input_file = sys.argv[1] fp = ParseFileLineByLine(input_file) for i in fp: print(i)"
            },
            {
                "url": 2922,
                "code": "def parse(filename): with open(filename) as f: parser = ASDLParser() return parser.parse(f.read())"
            },
            {
                "url": 2654,
                "code": "def load(self, name): name = ctypes.util.find_library(name) return ctypes.cdll.LoadLibrary(name)"
            },
            {
                "url": 4841,
                "code": "def load_from_file(module_path): from imp import load_module, PY_SOURCE imported = None if module_path: with open(module_path, 'r') as openfile: imported = load_module('mod', openfile, module_path, ('imported', 'r', PY_SOURCE)) return imported"
            },
            {
                "url": 666,
                "code": "def read_array(path, mmap_mode=None): file_ext = op.splitext(path)[1] if file_ext == '.npy': return np.load(path, mmap_mode=mmap_mode) raise NotImplementedError(\"The file extension `{}` \".format(file_ext) + \"is not currently supported.\")"
            },
            {
                "url": 5118,
                "code": "def import_public_rsa_key_from_file(filename): with open(filename, \"rb\") as key_file: public_key = serialization.load_pem_public_key( key_file.read(), backend=default_backend()) return public_key"
            },
            {
                "url": 1406,
                "code": "def lambda_from_file(python_file): lambda_function = [] with open(python_file, 'r') as f: lambda_function.extend(f.read().splitlines()) return awslambda.Code(ZipFile=(Join('\\n', lambda_function)))"
            },
            {
                "url": 3100,
                "code": "def unpickle(pickle_file): pickle = None with open(pickle_file, \"rb\") as pickle_f: pickle = dill.load(pickle_f) if not pickle: LOG.error(\"Could not load python object from file\") return pickle"
            },
            {
                "url": 3132,
                "code": "def get_list_from_file(file_name): with open(file_name, mode='r', encoding='utf-8') as f1: lst = f1.readlines() return lst"
            },
            {
                "url": 970,
                "code": "def read_string_from_file(path, encoding=\"utf8\"): with codecs.open(path, \"rb\", encoding=encoding) as f: value = f.read() return value"
            },
            {
                "url": 1904,
                "code": "def readwav(filename): from scipy.io.wavfile import read as readwav samplerate, signal = readwav(filename) return signal, samplerate"
            }
        ],
        "url": 4588
    },
    {
        "nl_input": "python threadpool close join",
        "code_input": [
            {
                "url": 5119,
                "code": "def Join(self): for _ in range(self.JOIN_TIMEOUT_DECISECONDS): if self._queue.empty() and not self.busy_threads: return time.sleep(0.1) raise ValueError(\"Timeout during Join() for threadpool %s.\" % self.name)"
            },
            {
                "url": 4765,
                "code": "def join(self): for thread in self.worker_threads: thread.join() WorkerThread.join(self)"
            },
            {
                "url": 4341,
                "code": "def terminate(self): if self._pool is not None: self._pool.terminate() self._pool.join() self._pool = None"
            },
            {
                "url": 1252,
                "code": "def join(self): self.inputfeeder_thread.join() self.pool.join() self.resulttracker_thread.join() self.failuretracker_thread.join()"
            },
            {
                "url": 2942,
                "code": "def wait_until_exit(self): [t.join() for t in self.threads] self.threads = list()"
            },
            {
                "url": 785,
                "code": "def terminate(self): for t in self._threads: t.quit() self._thread = [] self._workers = []"
            },
            {
                "url": 5005,
                "code": "def wait(self, timeout=None): if not self.__running: raise RuntimeError(\"ThreadPool ain't running\") self.__queue.wait(timeout)"
            },
            {
                "url": 4751,
                "code": "def stop(self): with self.lock: for dummy in self.threads: self.queue.put(None)"
            },
            {
                "url": 709,
                "code": "def wait_until_exit(self): if self._timeout is None: raise Exception(\"Thread will never exit. Use stop or specify timeout when starting it!\") self._thread.join() self.stop()"
            },
            {
                "url": 550,
                "code": "def finish(): out.warn(\"Interrupted!\") for t in threads: t.stop() jobs.clear() out.warn(\"Waiting for download threads to finish.\")"
            },
            {
                "url": 1761,
                "code": "def parallel(processes, threads): pool = multithread(threads) pool.map(run_process, processes) pool.close() pool.join()"
            },
            {
                "url": 3838,
                "code": "def close(self, wait=False): self.session.close() self.pool.shutdown(wait=wait)"
            },
            {
                "url": 4005,
                "code": "def wait_and_join(self, task): while not task.has_started: time.sleep(self._polling_time) task.thread.join()"
            },
            {
                "url": 112,
                "code": "async def _thread_coro(self, *args): return await self._loop.run_in_executor( self._executor, self._function, *args)"
            },
            {
                "url": 2623,
                "code": "async def wait_and_quit(loop): from pylp.lib.tasks import running if running: await asyncio.wait(map(lambda runner: runner.future, running))"
            }
        ],
        "url": 1252
    },
    {
        "nl_input": "python sklearn onehotencoder string values",
        "code_input": [
            {
                "url": 3644,
                "code": "def one_hot_encoding(input_tensor, num_labels): xview = input_tensor.view(-1, 1).to(torch.long) onehot = torch.zeros(xview.size(0), num_labels, device=input_tensor.device, dtype=torch.float) onehot.scatter_(1, xview, 1) return onehot.view(list(input_tensor.shape) + [-1])"
            },
            {
                "url": 1405,
                "code": "def one_hot2string(arr, vocab): tokens = one_hot2token(arr) indexToLetter = _get_index_dict(vocab) return [''.join([indexToLetter[x] for x in row]) for row in tokens]"
            },
            {
                "url": 866,
                "code": "def to_one_hot(dataY): nc = 1 + np.max(dataY) onehot = [np.zeros(nc, dtype=np.int8) for _ in dataY] for i, j in enumerate(dataY): onehot[i][j] = 1 return onehot"
            },
            {
                "url": 59,
                "code": "def one_hot(x, size, dtype=np.float32): return np.array(x[..., np.newaxis] == np.arange(size), dtype)"
            },
            {
                "url": 1246,
                "code": "def encode_dataset(dataset, vocabulary): def encode(features): return {k: vocabulary.encode_tf(v) for k, v in features.items()} return dataset.map(encode, num_parallel_calls=tf.data.experimental.AUTOTUNE)"
            },
            {
                "url": 2166,
                "code": "def encode(strs): res = '' for string in strs.split(): res += str(len(string)) + \":\" + string return res"
            },
            {
                "url": 4762,
                "code": "def encode_to_shape(inputs, shape, scope): with tf.variable_scope(scope, reuse=tf.AUTO_REUSE): w, h = shape[1], shape[2] x = inputs x = tfl.flatten(x) x = tfl.dense(x, w * h, activation=None, name=\"enc_dense\") x = tf.reshape(x, (-1, w, h, 1)) return x"
            },
            {
                "url": 4510,
                "code": "def np2str(value): if hasattr(value, 'dtype') and \\ issubclass(value.dtype.type, (np.string_, np.object_)) and value.size == 1: value = np.asscalar(value) if not isinstance(value, str): # python 3 - was scalar numpy array of bytes # otherwise python 2 - scalar numpy array of 'str' value = value.decode() return value else: raise ValueError(\"Array is not a string type or is larger than 1\")"
            },
            {
                "url": 1535,
                "code": "def encode_batch(self, inputBatch): X = inputBatch encode = self.encode Y = np.array([ encode(x) for x in X]) return Y"
            },
            {
                "url": 3072,
                "code": "def _numpy_bytes_to_char(arr): # ensure the array is contiguous arr = np.array(arr, copy=False, order='C', dtype=np.string_) return arr.reshape(arr.shape + (1,)).view('S1')"
            },
            {
                "url": 12,
                "code": "def _array2cstr(arr): out = StringIO() np.save(out, arr) return b64encode(out.getvalue())"
            },
            {
                "url": 3005,
                "code": "def lmx_h1k_f64k(): hparams = lmx_base() hparams.hidden_size = 1024 hparams.filter_size = 65536 hparams.batch_size = 2048 return hparams"
            },
            {
                "url": 2538,
                "code": "def to_string(s, encoding='utf-8'): if six.PY2: return s.encode(encoding) if isinstance(s, bytes): return s.decode(encoding) return s"
            },
            {
                "url": 3919,
                "code": "def transformer_tall_pretrain_lm_tpu_adafactor(): hparams = transformer_tall_pretrain_lm() update_hparams_for_tpu(hparams) hparams.max_length = 1024 # For multi-problem on TPU we need it in absolute examples. hparams.batch_size = 8 hparams.multiproblem_vocab_size = 2**16 return hparams"
            },
            {
                "url": 696,
                "code": "def calculate_embedding(self, batch_image_bytes): return self.tf_session.run( self.embedding, feed_dict={self.input_jpeg: batch_image_bytes})"
            }
        ],
        "url": 1405
    },
    {
        "nl_input": "python change to bytes",
        "code_input": [
            {
                "url": 5639,
                "code": "def bytes_hack(buf): ub = None if sys.version_info > (3,): ub = buf else: ub = bytes(buf) return ub"
            },
            {
                "url": 3326,
                "code": "def bytes_to_str(s, encoding='utf-8'): if six.PY3 and isinstance(s, bytes): return s.decode(encoding) return s"
            },
            {
                "url": 3413,
                "code": "def to_bytes(s, encoding=\"utf-8\"): if isinstance(s, six.binary_type): return s if six.PY3: return bytes(s, encoding) return s.encode(encoding)"
            },
            {
                "url": 5925,
                "code": "def decodebytes(input): py_version = sys.version_info[0] if py_version >= 3: return _decodebytes_py3(input) return _decodebytes_py2(input)"
            },
            {
                "url": 5583,
                "code": "def strtobytes(input, encoding): py_version = sys.version_info[0] if py_version >= 3: return _strtobytes_py3(input, encoding) return _strtobytes_py2(input, encoding)"
            },
            {
                "url": 1328,
                "code": "def b2u(string): if (isinstance(string, bytes) or (PY2 and isinstance(string, str))): return string.decode('utf-8') return string"
            },
            {
                "url": 1213,
                "code": "def str2bytes(x): if type(x) is bytes: return x elif type(x) is str: return bytes([ ord(i) for i in x ]) else: return str2bytes(str(x))"
            },
            {
                "url": 1377,
                "code": "def to_bytes(value): vtype = type(value) if vtype == bytes or vtype == type(None): return value try: return vtype.encode(value) except UnicodeEncodeError: pass return value"
            },
            {
                "url": 5212,
                "code": "def is_bytes(string): if six.PY3 and isinstance(string, (bytes, memoryview, bytearray)): # noqa return True elif six.PY2 and isinstance(string, (buffer, bytearray)): # noqa return True return False"
            },
            {
                "url": 3848,
                "code": "def value_to_python(self, value): if not isinstance(value, bytes): raise tldap.exceptions.ValidationError(\"should be a bytes\") value = value.decode(\"utf_8\") return value"
            },
            {
                "url": 5522,
                "code": "def cast_bytes(s, encoding=None): if not isinstance(s, bytes): return encode(s, encoding) return s"
            },
            {
                "url": 5701,
                "code": "def convert_bytes_to_ints(in_bytes, num): dt = numpy.dtype('>i' + str(num)) return numpy.frombuffer(in_bytes, dt)"
            },
            {
                "url": 2538,
                "code": "def to_string(s, encoding='utf-8'): if six.PY2: return s.encode(encoding) if isinstance(s, bytes): return s.decode(encoding) return s"
            },
            {
                "url": 3880,
                "code": "def Binary(x): if isinstance(x, text_type) and not (JYTHON or IRONPYTHON): return x.encode() return bytes(x)"
            },
            {
                "url": 1451,
                "code": "def to_str(s): if isinstance(s, bytes): s = s.decode('utf-8') elif not isinstance(s, str): s = str(s) return s"
            }
        ],
        "url": 5708
    },
    {
        "nl_input": "python json loads try",
        "code_input": [
            {
                "url": 201,
                "code": "def serialize_json_string(self, value): # Check if the value might be a json string if not isinstance(value, six.string_types): return value # Make sure it starts with a brace if not value.startswith('{') or value.startswith('['): return value # Try to load the string try: return json.loads(value) except: return value"
            },
            {
                "url": 2062,
                "code": "def json_decode(data): if isinstance(data, six.binary_type): data = data.decode('utf-8') return json.loads(data)"
            },
            {
                "url": 2054,
                "code": "def load(raw_bytes): try: if not isinstance(raw_bytes, string_type): raw_bytes = raw_bytes.decode() return json.loads(raw_bytes) except ValueError as e: raise SerializationException(str(e))"
            },
            {
                "url": 157,
                "code": "def from_json(cls, json_str): d = json.loads(json_str) return cls.from_dict(d)"
            },
            {
                "url": 1198,
                "code": "def _serialize_json(obj, fp): json.dump(obj, fp, indent=4, default=serialize)"
            },
            {
                "url": 1379,
                "code": "def loadb(b): assert isinstance(b, (bytes, bytearray)) return std_json.loads(b.decode('utf-8'))"
            },
            {
                "url": 5288,
                "code": "def from_json(cls, json_doc): try: d = json.load(json_doc) except AttributeError: # catch the read() error d = json.loads(json_doc) return cls.from_dict(d)"
            },
            {
                "url": 2151,
                "code": "def from_json_str(cls, json_str): return cls.from_json(json.loads(json_str, cls=JsonDecoder))"
            },
            {
                "url": 3889,
                "code": "def load_jsonf(fpath, encoding): with codecs.open(fpath, encoding=encoding) as f: return json.load(f)"
            },
            {
                "url": 2057,
                "code": "def json(body, charset='utf-8', **kwargs): return json_converter.loads(text(body, charset=charset))"
            },
            {
                "url": 5016,
                "code": "def load(cls, fp, **kwargs): json_obj = json.load(fp, **kwargs) return parse(cls, json_obj)"
            },
            {
                "url": 977,
                "code": "def open_json(file_name): with open(file_name, \"r\") as json_data: data = json.load(json_data) return data"
            },
            {
                "url": 4442,
                "code": "def save_json(object, handle, indent=2): obj_json = json.dumps(object, indent=indent, cls=NumpyJSONEncoder) handle.write(obj_json)"
            },
            {
                "url": 4188,
                "code": "def json_get_data(filename): with open(filename) as fp: json_data = json.load(fp) return json_data return False"
            },
            {
                "url": 682,
                "code": "def dump_json(obj): return simplejson.dumps(obj, ignore_nan=True, default=json_util.default)"
            }
        ],
        "url": 2057
    },
    {
        "nl_input": "create an empty column in data frame python",
        "code_input": [
            {
                "url": 27,
                "code": "def add_blank_row(self, label): col_labels = self.df.columns blank_item = pd.Series({}, index=col_labels, name=label) # use .loc to add in place (append won't do that) self.df.loc[blank_item.name] = blank_item return self.df"
            },
            {
                "url": 1317,
                "code": "def set_empty(self, row, column): subplot = self.get_subplot_at(row, column) subplot.set_empty()"
            },
            {
                "url": 1801,
                "code": "def fill_nulls(self, col: str): n = [None, \"\"] try: self.df[col] = self.df[col].replace(n, nan) except Exception as e: self.err(e)"
            },
            {
                "url": 2333,
                "code": "def clean_df(df, fill_nan=True, drop_empty_columns=True): if fill_nan: df = df.fillna(value=np.nan) if drop_empty_columns: df = df.dropna(axis=1, how='all') return df.sort_index()"
            },
            {
                "url": 5659,
                "code": "def is_not_null(df: DataFrame, col_name: str) -> bool: if ( isinstance(df, pd.DataFrame) and col_name in df.columns and df[col_name].notnull().any() ): return True else: return False"
            },
            {
                "url": 5850,
                "code": "def _create_empty_array(self, frames, always_2d, dtype): import numpy as np if always_2d or self.channels > 1: shape = frames, self.channels else: shape = frames, return np.empty(shape, dtype, order='C')"
            },
            {
                "url": 889,
                "code": "def clean_dataframe(df): df = df.fillna(method='ffill') df = df.fillna(0.0) return df"
            },
            {
                "url": 5616,
                "code": "def clean_column_names(df: DataFrame) -> DataFrame: f = df.copy() f.columns = [col.strip() for col in f.columns] return f"
            },
            {
                "url": 2680,
                "code": "def from_df(data_frame): labels = data_frame.keys().tolist() data = data_frame.values.tolist() return SqlTable(labels, data, \"{:.3f}\", \"\\n\")"
            },
            {
                "url": 1462,
                "code": "def stringify_col(df, col_name): df = df.copy() df[col_name] = df[col_name].fillna(\"\") df[col_name] = df[col_name].astype(str) return df"
            },
            {
                "url": 507,
                "code": "def drop_empty(rows): return zip(*[col for col in zip(*rows) if bool(filter(bool, col[1:]))])"
            },
            {
                "url": 6165,
                "code": "def fix_missing(df, col, name, na_dict): if is_numeric_dtype(col): if pd.isnull(col).sum() or (name in na_dict): df[name+'_na'] = pd.isnull(col) filler = na_dict[name] if name in na_dict else col.median() df[name] = col.fillna(filler) na_dict[name] = filler return na_dict"
            },
            {
                "url": 4753,
                "code": "def _insert_row(self, i, index): if i == len(self._index): self._add_row(index) else: self._index.insert(i, index) self._data.insert(i, None)"
            },
            {
                "url": 4652,
                "code": "def step_table_made(self): try: empty = self.step_table.empty except AttributeError: empty = True return not empty"
            },
            {
                "url": 3290,
                "code": "def _raise_error_if_column_exists(dataset, column_name = 'dataset', dataset_variable_name = 'dataset', column_name_error_message_name = 'column_name'): err_msg = 'The SFrame {0} must contain the column {1}.'.format( dataset_variable_name, column_name_error_message_name) if column_name not in dataset.column_names(): raise ToolkitError(str(err_msg))"
            }
        ],
        "url": 27
    },
    {
        "nl_input": "remove whitespace at end of line in python",
        "code_input": [
            {
                "url": 1664,
                "code": "def _delete_whitespace(self): while isinstance(self._lines[-1], (self._Space, self._LineBreak, self._Indent)): del self._lines[-1]"
            },
            {
                "url": 2039,
                "code": "def get_line_ending(line): non_whitespace_index = len(line.rstrip()) - len(line) if not non_whitespace_index: return '' else: return line[non_whitespace_index:]"
            },
            {
                "url": 3541,
                "code": "def empty_line_count_at_the_end(self): count = 0 for line in self.lines[::-1]: if not line or line.isspace(): count += 1 else: break return count"
            },
            {
                "url": 5725,
                "code": "def remove_blank_lines(string): return \"\\n\".join(line for line in string.split(\"\\n\") if len(line.strip()))"
            },
            {
                "url": 5108,
                "code": "def fix_line_breaks(s): l = s.splitlines() x = [i.strip() for i in l] x = [i for i in x if i] # remove blank lines return \"\\n\".join(x)"
            },
            {
                "url": 2422,
                "code": "def text_remove_empty_lines(text): lines = [ line.rstrip() for line in text.splitlines() if line.strip() ] return \"\\n\".join(lines)"
            },
            {
                "url": 2577,
                "code": "def clean_whitespace(statement): import re # Replace linebreaks and tabs with spaces statement.text = statement.text.replace('\\n', ' ').replace('\\r', ' ').replace('\\t', ' ') # Remove any leeding or trailing whitespace statement.text = statement.text.strip() # Remove consecutive spaces statement.text = re.sub(' +', ' ', statement.text) return statement"
            },
            {
                "url": 2581,
                "code": "def clean(s): lines = [l.rstrip() for l in s.split('\\n')] return '\\n'.join(lines)"
            },
            {
                "url": 153,
                "code": "def endline_semicolon_check(self, original, loc, tokens): return self.check_strict(\"semicolon at end of line\", original, loc, tokens)"
            },
            {
                "url": 1805,
                "code": "def cleanLines(source, lineSep=os.linesep): stripped = (line.strip(lineSep) for line in source) return (line for line in stripped if len(line) != 0)"
            },
            {
                "url": 3447,
                "code": "def clean_whitespace(string, compact=False): for a, b in (('\\r\\n', '\\n'), ('\\r', '\\n'), ('\\n\\n', '\\n'), ('\\t', ' '), (' ', ' ')): string = string.replace(a, b) if compact: for a, b in (('\\n', ' '), ('[ ', '['), (' ', ' '), (' ', ' '), (' ', ' ')): string = string.replace(a, b) return string.strip()"
            },
            {
                "url": 366,
                "code": "def strip_spaces(s): return u\" \".join([c for c in s.split(u' ') if c])"
            },
            {
                "url": 4403,
                "code": "def get_indentation(line): if line.strip(): non_whitespace_index = len(line) - len(line.lstrip()) return line[:non_whitespace_index] else: return ''"
            },
            {
                "url": 3891,
                "code": "def _trim(self, somestr): tmp = RE_LSPACES.sub(\"\", somestr) tmp = RE_TSPACES.sub(\"\", tmp) return str(tmp)"
            },
            {
                "url": 1006,
                "code": "def _remove_blank(l): ret = [] for i, _ in enumerate(l): if l[i] == 0: break ret.append(l[i]) return ret"
            }
        ],
        "url": 2581
    },
    {
        "nl_input": "python file opening modes",
        "code_input": [
            {
                "url": 1796,
                "code": "def open_file(file, mode): if hasattr(file, \"read\"): return file if hasattr(file, \"open\"): return file.open(mode) return open(file, mode)"
            },
            {
                "url": 4698,
                "code": "def fopen(name, mode='r', buffering=-1): f = _fopen(name, mode, buffering) return _FileObjectThreadWithContext(f, mode, buffering)"
            },
            {
                "url": 3485,
                "code": "def _open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None, *, loop=None, executor=None): if loop is None: loop = asyncio.get_event_loop() cb = partial(sync_open, file, mode=mode, buffering=buffering, encoding=encoding, errors=errors, newline=newline, closefd=closefd, opener=opener) f = yield from loop.run_in_executor(executor, cb) return wrap(f, loop=loop, executor=executor)"
            },
            {
                "url": 1063,
                "code": "def open_with_encoding(filename, encoding, mode='r'): return io.open(filename, mode=mode, encoding=encoding, newline='')"
            },
            {
                "url": 5169,
                "code": "def __init__(self, filename, mode, encoding=None): FileHandler.__init__(self, filename, mode, encoding) self.mode = mode self.encoding = encoding"
            },
            {
                "url": 4899,
                "code": "def open(name=None, fileobj=None, closefd=True): return Guesser().open(name=name, fileobj=fileobj, closefd=closefd)"
            },
            {
                "url": 4948,
                "code": "def open_hdf5(filename, mode='r'): if isinstance(filename, (h5py.Group, h5py.Dataset)): return filename if isinstance(filename, FILE_LIKE): return h5py.File(filename.name, mode) return h5py.File(filename, mode)"
            },
            {
                "url": 564,
                "code": "def fopenat(base_fd, path): return os.fdopen(openat(base_fd, path, os.O_RDONLY), 'rb')"
            },
            {
                "url": 6263,
                "code": "def copen(filepath, flag='r', encoding=None): if encoding is None: encoding = locale.getdefaultlocale()[1] return codecs.open(filepath, flag, encoding)"
            },
            {
                "url": 3426,
                "code": "def _open_text(fname, **kwargs): if PY3: kwargs.setdefault('encoding', ENCODING) kwargs.setdefault('errors', ENCODING_ERRS) return open(fname, \"rt\", **kwargs)"
            },
            {
                "url": 4141,
                "code": "def get_h5file(file_path, mode='r'): if not op.exists(file_path): raise IOError('Could not find file {}.'.format(file_path)) try: h5file = h5py.File(file_path, mode=mode) except: raise else: return h5file"
            },
            {
                "url": 3273,
                "code": "def write_to(f, mode): if hasattr(f, 'write'): yield f else: f = open(f, mode) yield f f.close()"
            },
            {
                "url": 3547,
                "code": "def fileopenbox(msg=None, title=None, argInitialFile=None): return psidialogs.ask_file(message=msg, title=title, default=argInitialFile)"
            },
            {
                "url": 2424,
                "code": "def chmod(scope, filename, mode): for file in filename: os.chmod(file, mode[0]) return True"
            },
            {
                "url": 5407,
                "code": "def bin_open(fname: str): if fname.endswith(\".gz\"): return gzip.open(fname, \"rb\") return open(fname, \"rb\")"
            }
        ],
        "url": 1796
    },
    {
        "nl_input": "python code input prompt for questions",
        "code_input": [
            {
                "url": 5528,
                "code": "def ask_str(question: str, default: str = None): default_q = \" [default: {0}]: \".format( default) if default is not None else \"\" answer = input(\"{0} [{1}]: \".format(question, default_q)) if answer == \"\": return default return answer"
            },
            {
                "url": 3632,
                "code": "def input(self, prompt, default=None, show_default=True): return click.prompt(prompt, default=default, show_default=show_default)"
            },
            {
                "url": 63,
                "code": "def string_input(prompt=''): v = sys.version[0] if v == '3': return input(prompt) else: return raw_input(prompt)"
            },
            {
                "url": 1524,
                "code": "def get_raw_input(description, default=False): additional = ' (default: %s)' % default if default else '' prompt = ' %s%s: ' % (description, additional) user_input = input_(prompt) return user_input"
            },
            {
                "url": 6170,
                "code": "def input(prompt=\"\"): string = stdin_decode(raw_input(prompt)) caller_frame = sys._getframe(1) globals = caller_frame.f_globals locals = caller_frame.f_locals return eval(string, globals, locals)"
            },
            {
                "url": 1771,
                "code": "def getpass(self, prompt, default=None): return click.prompt(prompt, hide_input=True, default=default)"
            },
            {
                "url": 1479,
                "code": "def input_int_default(question=\"\", default=0): answer = input_string(question) if answer == \"\" or answer == \"yes\": return default else: return int(answer)"
            },
            {
                "url": 4634,
                "code": "def confirm(question, default=True): valid = {\"\": default, \"yes\": True, \"y\": True, \"no\": False, \"n\": False} while 1: choice = input(question + (\" [Y/n] \" if default else \" [y/N] \")).lower() if choice in valid: return valid[choice] print(\"Please respond with 'y' or 'n' \")"
            },
            {
                "url": 864,
                "code": "def _user_yes_no_query(self, question): sys.stdout.write('%s [y/n]\\n' % question) while True: try: return strtobool(raw_input().lower()) except ValueError: sys.stdout.write('Please respond with \\'y\\' or \\'n\\'.\\n')"
            },
            {
                "url": 5056,
                "code": "def prompt(*args, **kwargs): try: return click.prompt(*args, **kwargs) except click.Abort: return False"
            },
            {
                "url": 5416,
                "code": "def prompt_yes_or_no(message): user_input = input(\"{} [y/n]:\".format(message)).lower() if user_input.startswith(\"y\"): return True elif user_input.startswith(\"n\"): return False else: return prompt_yes_or_no(message)"
            },
            {
                "url": 2700,
                "code": "def get_input(input_func, input_str): val = input_func(\"Please enter your {0}: \".format(input_str)) while not val or not len(val.strip()): val = input_func(\"You didn't enter a valid {0}, please try again: \".format(input_str)) return val"
            },
            {
                "url": 975,
                "code": "async def async_input(prompt): print(prompt, end='', flush=True) return (await loop.run_in_executor(None, sys.stdin.readline)).rstrip()"
            },
            {
                "url": 65,
                "code": "def yn_prompt(msg, default=True): ret = custom_prompt(msg, [\"y\", \"n\"], \"y\" if default else \"n\") if ret == \"y\": return True return False"
            },
            {
                "url": 3504,
                "code": "def ask_folder(message='Select folder.', default='', title=''): return backend_api.opendialog(\"ask_folder\", dict(message=message, default=default, title=title))"
            }
        ],
        "url": 63
    },
    {
        "nl_input": "python parse a log file that is logging",
        "code_input": [
            {
                "url": 1429,
                "code": "def parse(self): f = open(self.parse_log_path, \"r\") self.parse2(f) f.close()"
            },
            {
                "url": 750,
                "code": "def load_config(filename=\"logging.ini\", *args, **kwargs): logging.config.fileConfig(filename, *args, **kwargs)"
            },
            {
                "url": 3709,
                "code": "def setupLogFile(self): self.logWrite(\"\\n###############################################\") self.logWrite(\"calcpkg.py log from \" + str(datetime.datetime.now())) self.changeLogging(True)"
            },
            {
                "url": 3667,
                "code": "def log_all(self, file): global rflink_log if file == None: rflink_log = None else: log.debug('logging to: %s', file) rflink_log = open(file, 'a')"
            },
            {
                "url": 4619,
                "code": "def main(pargs): input_file = sys.argv[1] fp = ParseFileLineByLine(input_file) for i in fp: print(i)"
            },
            {
                "url": 4418,
                "code": "def log(logger, level, message): if logger.parent.name != 'root': logger.log(level, message) else: print(message, file=sys.stderr)"
            },
            {
                "url": 5129,
                "code": "def log(self, level, msg=None, *args, **kwargs): return self._log(level, msg, args, kwargs)"
            },
            {
                "url": 4313,
                "code": "def set_logging_config(log_level, handlers): logging.basicConfig( format='%(asctime)s %(levelname)s:%(name)s:%(funcName)s: %(message)s', datefmt='%Y-%m-%d %H:%M:%S', level=log_level, handlers=handlers)"
            },
            {
                "url": 4610,
                "code": "def log_to_json(log): return [log.timestamp.isoformat()[:22], log.level, log.process, log.message]"
            },
            {
                "url": 2091,
                "code": "def log_no_newline(self, msg): self.print2file(self.logfile, False, False, msg)"
            },
            {
                "url": 3027,
                "code": "def GetLoggingLocation(): frame = inspect.currentframe() this_file = frame.f_code.co_filename frame = frame.f_back while frame: if this_file == frame.f_code.co_filename: if 'cdbg_logging_location' in frame.f_locals: ret = frame.f_locals['cdbg_logging_location'] if len(ret) != 3: return (None, None, None) return ret frame = frame.f_back return (None, None, None)"
            },
            {
                "url": 3663,
                "code": "def getLinesFromLogFile(stream): stream.flush() stream.seek(0) lines = stream.readlines() return lines"
            },
            {
                "url": 754,
                "code": "def logger(message, level=10): logging.getLogger(__name__).log(level, str(message))"
            },
            {
                "url": 2353,
                "code": "def reset_default_logger(): global logger global _loglevel global _logfile global _formatter _loglevel = logging.DEBUG _logfile = None _formatter = None logger = setup_logger(name=LOGZERO_DEFAULT_LOGGER, logfile=_logfile, level=_loglevel, formatter=_formatter)"
            },
            {
                "url": 2028,
                "code": "def ServerLoggingStartupInit(): global LOGGER if local_log: logging.debug(\"Using local LogInit from %s\", local_log) local_log.LogInit() logging.debug(\"Using local AppLogInit from %s\", local_log) LOGGER = local_log.AppLogInit() else: LogInit() LOGGER = AppLogInit()"
            }
        ],
        "url": 1429
    },
    {
        "nl_input": "remove an entry from a dict python",
        "code_input": [
            {
                "url": 185,
                "code": "def _remove_dict_keys_with_value(dict_, val): return {k: v for k, v in dict_.items() if v is not val}"
            },
            {
                "url": 4214,
                "code": "def remove(self, entry): try: list = self.cache[entry.key] list.remove(entry) except: pass"
            },
            {
                "url": 1015,
                "code": "def rm_keys_from_dict(d, keys): # Loop for each key given for key in keys: # Is the key in the dictionary? if key in d: try: d.pop(key, None) except KeyError: # Not concerned with an error. Keep going. pass return d"
            },
            {
                "url": 4874,
                "code": "def __delitem__ (self, key): self._keys.remove(key) super(ListDict, self).__delitem__(key)"
            },
            {
                "url": 5594,
                "code": "def dictlist_wipe_key(dict_list: Iterable[Dict], key: str) -> None: for d in dict_list: d.pop(key, None)"
            },
            {
                "url": 3146,
                "code": "def pop (self, key): if key in self._keys: self._keys.remove(key) super(ListDict, self).pop(key)"
            },
            {
                "url": 4062,
                "code": "def __delitem__(self, key): index, value = self._dict.pop(key) key2, value2 = self._list.pop(index) assert key == key2 assert value is value2 self._fix_indices_after_delete(index)"
            },
            {
                "url": 2205,
                "code": "def clean_dict_keys(d): new_d = {} for (k, v) in d.iteritems(): new_d[str(k)] = v return new_d"
            },
            {
                "url": 1019,
                "code": "def pop(self, index=-1): value = self._list.pop(index) del self._dict[value] return value"
            },
            {
                "url": 2569,
                "code": "def _delete_keys(dct, keys): c = deepcopy(dct) assert isinstance(keys, list) for k in keys: c.pop(k) return c"
            },
            {
                "url": 2281,
                "code": "def _remove_none_values(dictionary): return list(map(dictionary.pop, [i for i in dictionary if dictionary[i] is None]))"
            },
            {
                "url": 1017,
                "code": "def purge_dict(idict): odict = {} for key, val in idict.items(): if is_null(val): continue odict[key] = val return odict"
            },
            {
                "url": 2335,
                "code": "def delete_entry(self, key): pipe = self.client.pipeline() pipe.srem(self.keys_container, key) pipe.delete(key) pipe.execute()"
            },
            {
                "url": 2777,
                "code": "def remove(self, key): item = self.item_finder.pop(key) item[-1] = None self.removed_count += 1"
            },
            {
                "url": 4747,
                "code": "def delete(self, key_name): self.db.remove(Query().name == key_name) return self.get(key_name) == {}"
            }
        ],
        "url": 5594
    },
    {
        "nl_input": "new line statemnt pythong write",
        "code_input": [
            {
                "url": 2415,
                "code": "def write_line(self, line, count=1): self.write(line) self.write_newlines(count)"
            },
            {
                "url": 1028,
                "code": "def stdoutwriteline(*args): s = \"\" for i in args: s += str(i) + \" \" s = s.strip() sys.stdout.write(str(s) + \"\\n\") sys.stdout.flush() return s"
            },
            {
                "url": 428,
                "code": "def go_to_new_line(self): self.stdkey_end(False, False) self.insert_text(self.get_line_separator())"
            },
            {
                "url": 1452,
                "code": "def printOut(value, end='\\n'): sys.stdout.write(value) sys.stdout.write(end) sys.stdout.flush()"
            },
            {
                "url": 3202,
                "code": "def linebuffered_stdout(): if sys.stdout.line_buffering: return sys.stdout orig = sys.stdout new = type(orig)(orig.buffer, encoding=orig.encoding, errors=orig.errors, line_buffering=True) new.mode = orig.mode return new"
            },
            {
                "url": 3858,
                "code": "def println(msg): sys.stdout.write(msg) sys.stdout.flush() sys.stdout.write('\\x08' * len(msg)) sys.stdout.flush()"
            },
            {
                "url": 3812,
                "code": "def ensure_newline(self): DECTCEM_SHOW = '\\033[?25h' # show cursor AT_END = DECTCEM_SHOW + '\\n' if not self._cursor_at_newline: self.write(AT_END) self._cursor_at_newline = True"
            },
            {
                "url": 2091,
                "code": "def log_no_newline(self, msg): self.print2file(self.logfile, False, False, msg)"
            },
            {
                "url": 1467,
                "code": "def raw_print(*args, **kw): print(*args, sep=kw.get('sep', ' '), end=kw.get('end', '\\n'), file=sys.__stdout__) sys.__stdout__.flush()"
            },
            {
                "url": 1534,
                "code": "def out(self, output, newline=True): click.echo(output, nl=newline)"
            },
            {
                "url": 1037,
                "code": "def print_out(self, *lst): self.print2file(self.stdout, True, True, *lst)"
            },
            {
                "url": 1026,
                "code": "def cprint(string, fg=None, bg=None, end='\\n', target=sys.stdout): _color_manager.set_color(fg, bg) target.write(string + end) target.flush() # Needed for Python 3.x _color_manager.set_defaults()"
            },
            {
                "url": 1079,
                "code": "def _stdout_raw(self, s): print(s, end='', file=sys.stdout) sys.stdout.flush()"
            },
            {
                "url": 2503,
                "code": "def comment (self, s, **args): self.write(u\"// \") self.writeln(s=s, **args)"
            },
            {
                "url": 86,
                "code": "def add_str(window, line_num, str): try: window.addstr(line_num, 0, str) except curses.error: pass"
            }
        ],
        "url": 2415
    },
    {
        "nl_input": "python view as series column format string",
        "code_input": [
            {
                "url": 3512,
                "code": "def convert_str_to_datetime(df, *, column: str, format: str): df[column] = pd.to_datetime(df[column], format=format) return df"
            },
            {
                "url": 3291,
                "code": "def format(x, format): # don't change the dtype, otherwise for each block the dtype may be different (string length) sl = vaex.strings.format(x, format) return column.ColumnStringArrow(sl.bytes, sl.indices, sl.length, sl.offset, string_sequence=sl)"
            },
            {
                "url": 2523,
                "code": "def _parse(self, date_str, format='%Y-%m-%d'): rv = pd.to_datetime(date_str, format=format) if hasattr(rv, 'to_pydatetime'): rv = rv.to_pydatetime() return rv"
            },
            {
                "url": 4288,
                "code": "def stringToDate(fmt=\"%Y-%m-%d\"): import time import datetime def conv_func(s): return datetime.date(*time.strptime(s,fmt)[:3]) return conv_func"
            },
            {
                "url": 3319,
                "code": "def from_series(cls, series): # TODO: add a 'name' parameter name = series.name df = pd.DataFrame({name: series}) ds = Dataset.from_dataframe(df) return ds[name]"
            },
            {
                "url": 1858,
                "code": "def _get_str_columns(sf): return [name for name in sf.column_names() if sf[name].dtype == str]"
            },
            {
                "url": 4522,
                "code": "def timestamp_to_datetime(cls, dt, dt_format=DATETIME_FORMAT): return cls.convert_datetime(cls.get_datetime(dt), dt_format=dt_format)"
            },
            {
                "url": 1462,
                "code": "def stringify_col(df, col_name): df = df.copy() df[col_name] = df[col_name].fillna(\"\") df[col_name] = df[col_name].astype(str) return df"
            },
            {
                "url": 5746,
                "code": "def csv_to_numpy(string_like, dtype=None): # type: (str) -> np.array stream = StringIO(string_like) return np.genfromtxt(stream, dtype=dtype, delimiter=',')"
            },
            {
                "url": 877,
                "code": "def _drop_str_columns(df): str_columns = filter(lambda pair: pair[1].char == 'S', df._gather_dtypes().items()) str_column_names = list(map(lambda pair: pair[0], str_columns)) return df.drop(str_column_names)"
            },
            {
                "url": 2664,
                "code": "def convert_time_string(date_str): dt, _, _ = date_str.partition(\".\") dt = datetime.strptime(dt, \"%Y-%m-%dT%H:%M:%S\") return dt"
            },
            {
                "url": 2816,
                "code": "def add_datetime(dataframe, timestamp_key='UNIXTIME'): def convert_data(timestamp): return datetime.fromtimestamp(float(timestamp) / 1e3, UTC_TZ) try: log.debug(\"Adding DATETIME column to the data\") converted = dataframe[timestamp_key].apply(convert_data) dataframe['DATETIME'] = converted except KeyError: log.warning(\"Could not add DATETIME column\")"
            },
            {
                "url": 25,
                "code": "def get_column(self, X, column): if isinstance(X, pd.DataFrame): return X[column].values return X[:, column]"
            },
            {
                "url": 3552,
                "code": "def as_dict(df, ix=':'): if isinstance(df.index, pd.DatetimeIndex): df['datetime'] = df.index return df.to_dict(orient='records')[ix]"
            },
            {
                "url": 5247,
                "code": "def ts_func(f): def wrap_func(df, *args): # TODO: should vectorize to apply over all columns? return Chromatogram(f(df.values, *args), df.index, df.columns) return wrap_func"
            }
        ],
        "url": 3291
    },
    {
        "nl_input": "python select not null column values",
        "code_input": [
            {
                "url": 1092,
                "code": "def selectnotnone(table, field, complement=False): return select(table, field, lambda v: v is not None, complement=complement)"
            },
            {
                "url": 5659,
                "code": "def is_not_null(df: DataFrame, col_name: str) -> bool: if ( isinstance(df, pd.DataFrame) and col_name in df.columns and df[col_name].notnull().any() ): return True else: return False"
            },
            {
                "url": 5083,
                "code": "def selectnotin(table, field, value, complement=False): return select(table, field, lambda v: v not in value, complement=complement)"
            },
            {
                "url": 670,
                "code": "def selectnone(table, field, complement=False): return select(table, field, lambda v: v is None, complement=complement)"
            },
            {
                "url": 649,
                "code": "def _notnull(expr): if isinstance(expr, SequenceExpr): return NotNull(_input=expr, _data_type=types.boolean) elif isinstance(expr, Scalar): return NotNull(_input=expr, _value_type=types.boolean)"
            },
            {
                "url": 5021,
                "code": "def count_nulls(self, field): try: n = self.df[field].isnull().sum() except KeyError: self.warning(\"Can not find column\", field) return except Exception as e: self.err(e, \"Can not count nulls\") return self.ok(\"Found\", n, \"nulls in column\", field)"
            },
            {
                "url": 4546,
                "code": "def selectin(table, field, value, complement=False): return select(table, field, lambda v: v in value, complement=complement)"
            },
            {
                "url": 3969,
                "code": "def select_if(df, fun): def _filter_f(col): try: return fun(df[col]) except: return False cols = list(filter(_filter_f, df.columns)) return df[cols]"
            },
            {
                "url": 2204,
                "code": "def dropna(self, subset=None): subset = check_and_obtain_subset_columns(subset, self) not_nas = [v.notna() for v in self[subset]._iter()] and_filter = reduce(lambda x, y: x & y, not_nas) return self[and_filter]"
            },
            {
                "url": 4393,
                "code": "def select_random(engine, table_or_columns, limit=5): s = select(table_or_columns).order_by(func.random()).limit(limit) return engine.execute(s).fetchall()"
            },
            {
                "url": 208,
                "code": "def _not_none(items): if not isinstance(items, (tuple, list)): items = (items,) return all(item is not _none for item in items)"
            },
            {
                "url": 1801,
                "code": "def fill_nulls(self, col: str): n = [None, \"\"] try: self.df[col] = self.df[col].replace(n, nan) except Exception as e: self.err(e)"
            },
            {
                "url": 6089,
                "code": "def columns_equal(a: Column, b: Column) -> bool: return ( a.name == b.name and column_types_equal(a.type, b.type) and a.nullable == b.nullable )"
            },
            {
                "url": 5494,
                "code": "def rowlenselect(table, n, complement=False): where = lambda row: len(row) == n return select(table, where, complement=complement)"
            },
            {
                "url": 2669,
                "code": "def isin(self, column, compare_list): return [x in compare_list for x in self._data[self._columns.index(column)]]"
            }
        ],
        "url": 1092
    },
    {
        "nl_input": "how do functions in python know the parametr type",
        "code_input": [
            {
                "url": 2303,
                "code": "def check_type_and_size_of_param_list(param_list, expected_length): try: assert isinstance(param_list, list) assert len(param_list) == expected_length except AssertionError: msg = \"param_list must be a list containing {} elements.\" raise ValueError(msg.format(expected_length)) return None"
            },
            {
                "url": 285,
                "code": "def make_kind_check(python_types, numpy_kind): def check(value): if hasattr(value, 'dtype'): return value.dtype.kind == numpy_kind return isinstance(value, python_types) return check"
            },
            {
                "url": 1519,
                "code": "def _assert_is_type(name, value, value_type): if not isinstance(value, value_type): if type(value_type) is tuple: types = ', '.join(t.__name__ for t in value_type) raise ValueError('{0} must be one of ({1})'.format(name, types)) else: raise ValueError('{0} must be {1}' .format(name, value_type.__name__))"
            },
            {
                "url": 5638,
                "code": "def maybe_infer_dtype_type(element): tipo = None if hasattr(element, 'dtype'): tipo = element.dtype elif is_list_like(element): element = np.asarray(element) tipo = element.dtype return tipo"
            },
            {
                "url": 3599,
                "code": "def _py_ex_argtype(executable): result = [] for p in executable.ordered_parameters: atypes = p.argtypes if atypes is not None: result.extend(p.argtypes) else: print((\"No argtypes for: {}\".format(p.definition()))) if type(executable).__name__ == \"Function\": result.extend(executable.argtypes) return result"
            },
            {
                "url": 534,
                "code": "def is_builtin_type(tp): return hasattr(__builtins__, tp.__name__) and tp is getattr(__builtins__, tp.__name__)"
            },
            {
                "url": 4009,
                "code": "def str_check(*args, func=None): func = func or inspect.stack()[2][3] for var in args: if not isinstance(var, (str, collections.UserString, collections.abc.Sequence)): name = type(var).__name__ raise StringError( f'Function {func} expected str, {name} got instead.')"
            },
            {
                "url": 2399,
                "code": "def get_type_len(self): # Check types and set type/len self.get_sql() return self.type, self.len, self.len_decimal"
            },
            {
                "url": 1297,
                "code": "def istype(obj, check): if isinstance(check, tuple): for cls in check: if type(obj) is cls: return True return False else: return type(obj) is check"
            },
            {
                "url": 2376,
                "code": "def validate_type(self, type_): if type_ is not None and type_ not in self.types_set: raise ValueError('Invalid type for %s:%s' % (self.__class__, type_))"
            },
            {
                "url": 5441,
                "code": "def tuple_check(*args, func=None): func = func or inspect.stack()[2][3] for var in args: if not isinstance(var, (tuple, collections.abc.Sequence)): name = type(var).__name__ raise TupleError( f'Function {func} expected tuple, {name} got instead.')"
            },
            {
                "url": 1659,
                "code": "def get_ctype(rtype, cfunc, *args): val_p = backend.ffi.new(rtype) args = args + (val_p,) cfunc(*args) return val_p[0]"
            },
            {
                "url": 921,
                "code": "def getTypeStr(_type): r if isinstance(_type, CustomType): return str(_type) if hasattr(_type, '__name__'): return _type.__name__ return ''"
            },
            {
                "url": 3728,
                "code": "def fix_call(callable, *args, **kw): try: val = callable(*args, **kw) except TypeError: exc_info = fix_type_error(None, callable, args, kw) reraise(*exc_info) return val"
            },
            {
                "url": 196,
                "code": "def is_callable(*p): import symbols return all(isinstance(x, symbols.FUNCTION) for x in p)"
            }
        ],
        "url": 4548
    },
    {
        "nl_input": "cursor positioning python windows",
        "code_input": [
            {
                "url": 2502,
                "code": "def _position(): cursor = POINT() ctypes.windll.user32.GetCursorPos(ctypes.byref(cursor)) return (cursor.x, cursor.y)"
            },
            {
                "url": 5602,
                "code": "def SetCursorPos(x: int, y: int) -> bool: return bool(ctypes.windll.user32.SetCursorPos(x, y))"
            },
            {
                "url": 2456,
                "code": "def set_cursor_position(self, position): position = self.get_position(position) cursor = self.textCursor() cursor.setPosition(position) self.setTextCursor(cursor) self.ensureCursorVisible()"
            },
            {
                "url": 2366,
                "code": "def set_position(self, x, y, width, height): SetWindowPos(self._hwnd, None, x, y, width, height, ctypes.c_uint(0))"
            },
            {
                "url": 3051,
                "code": "def set_cursor(self, x, y): curses.curs_set(1) self.screen.move(y, x)"
            },
            {
                "url": 1924,
                "code": "def OnMove(self, event): # Store window position in config position = self.main_window.GetScreenPositionTuple() config[\"window_position\"] = repr(position)"
            },
            {
                "url": 363,
                "code": "def move_to(self, ypos, xpos): # the screen's co-ordinates are 1 based, but the command is 0 based xpos -= 1 ypos -= 1 self.exec_command(\"MoveCursor({0}, {1})\".format(ypos, xpos).encode(\"ascii\"))"
            },
            {
                "url": 4739,
                "code": "def move(self, x, y): self._cursor = self._normalizePoint(x, y)"
            },
            {
                "url": 5795,
                "code": "def _cursorLeft(self): if self.cursorPos > 0: self.cursorPos -= 1 sys.stdout.write(console.CURSOR_LEFT) sys.stdout.flush()"
            },
            {
                "url": 3191,
                "code": "def update_cursor_position(self, line, index): value = 'Line {}, Col {}'.format(line + 1, index + 1) self.set_value(value)"
            },
            {
                "url": 5706,
                "code": "def MoveWindow(handle: int, x: int, y: int, width: int, height: int, repaint: int = 1) -> bool: return bool(ctypes.windll.user32.MoveWindow(ctypes.c_void_p(handle), x, y, width, height, repaint))"
            },
            {
                "url": 3715,
                "code": "def mouse_get_pos(): p = POINT() AUTO_IT.AU3_MouseGetPos(ctypes.byref(p)) return p.x, p.y"
            },
            {
                "url": 4232,
                "code": "def on_mouse_motion(self, x, y, dx, dy): # Screen coordinates relative to the lower-left corner # so we have to flip the y axis to make this consistent with # other window libraries self.example.mouse_position_event(x, self.buffer_height - y)"
            },
            {
                "url": 5869,
                "code": "def get_cursor(self): x, y = self._cursor width, height = self.parent.get_size() while x >= width: x -= width y += 1 if y >= height and self.scrollMode == 'scroll': y = height - 1 return x, y"
            },
            {
                "url": 984,
                "code": "def mouse_move_event(self, event): self.example.mouse_position_event(event.x(), event.y())"
            }
        ],
        "url": 365
    },
    {
        "nl_input": "python how to equally space points in an ellipse",
        "code_input": [
            {
                "url": 1016,
                "code": "def create_ellipse(width,height,angle): angle = angle / 180.0 * np.pi thetas = np.linspace(0,2*np.pi,200) a = width / 2.0 b = height / 2.0 x = a*np.cos(thetas)*np.cos(angle) - b*np.sin(thetas)*np.sin(angle) y = a*np.cos(thetas)*np.sin(angle) + b*np.sin(thetas)*np.cos(angle) z = np.zeros(thetas.shape) return np.vstack((x,y,z)).T"
            },
            {
                "url": 294,
                "code": "def get_lons_from_cartesian(x__, y__): return rad2deg(arccos(x__ / sqrt(x__ ** 2 + y__ ** 2))) * sign(y__)"
            },
            {
                "url": 1558,
                "code": "def angle(x, y): return arccos(dot(x, y)/(norm(x)*norm(y)))*180./pi"
            },
            {
                "url": 2748,
                "code": "def create_rot2d(angle): ca = math.cos(angle) sa = math.sin(angle) return np.array([[ca, -sa], [sa, ca]])"
            },
            {
                "url": 2951,
                "code": "def circles_pycairo(width, height, color): cairo_color = color / rgb(255, 255, 255) surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, width, height) ctx = cairo.Context(surface) # draw a circle in the center ctx.new_path() ctx.set_source_rgb(cairo_color.red, cairo_color.green, cairo_color.blue) ctx.arc(width / 2, height / 2, width / 2, 0, 2 * pi) ctx.fill() surface.write_to_png('circles.png')"
            },
            {
                "url": 912,
                "code": "def cart2pol(x, y): theta = np.arctan2(y, x) rho = np.hypot(x, y) return theta, rho"
            },
            {
                "url": 5849,
                "code": "def arcball_map_to_sphere(point, center, radius): v0 = (point[0] - center[0]) / radius v1 = (center[1] - point[1]) / radius n = v0*v0 + v1*v1 if n > 1.0: # position outside of sphere n = math.sqrt(n) return numpy.array([v0/n, v1/n, 0.0]) else: return numpy.array([v0, v1, math.sqrt(1.0 - n)])"
            },
            {
                "url": 4726,
                "code": "def from_rotation_vector(rot): rot = np.array(rot, copy=False) quats = np.zeros(rot.shape[:-1]+(4,)) quats[..., 1:] = rot[...]/2 quats = as_quat_array(quats) return np.exp(quats)"
            },
            {
                "url": 3887,
                "code": "def xyz2lonlat(x, y, z): lon = xu.rad2deg(xu.arctan2(y, x)) lat = xu.rad2deg(xu.arctan2(z, xu.sqrt(x**2 + y**2))) return lon, lat"
            },
            {
                "url": 3995,
                "code": "def angle_to_cartesian(lon, lat): theta = np.array(np.pi / 2. - lat) return np.vstack((np.sin(theta) * np.cos(lon), np.sin(theta) * np.sin(lon), np.cos(theta))).T"
            },
            {
                "url": 1952,
                "code": "def geodetic_to_ecef(latitude, longitude, altitude): ellip = np.sqrt(1. - earth_b ** 2 / earth_a ** 2) r_n = earth_a / np.sqrt(1. - ellip ** 2 * np.sin(np.deg2rad(latitude)) ** 2) # colatitude = 90. - latitude x = (r_n + altitude) * np.cos(np.deg2rad(latitude)) * np.cos(np.deg2rad(longitude)) y = (r_n + altitude) * np.cos(np.deg2rad(latitude)) * np.sin(np.deg2rad(longitude)) z = (r_n * (1. - ellip ** 2) + altitude) * np.sin(np.deg2rad(latitude)) return x, y, z"
            },
            {
                "url": 3294,
                "code": "def quadratic_bezier(start, end, c0=(0, 0), c1=(0, 0), steps=50): steps = np.linspace(0, 1, steps) sx, sy = start ex, ey = end cx0, cy0 = c0 cx1, cy1 = c1 xs = ((1-steps)**3*sx + 3*((1-steps)**2)*steps*cx0 + 3*(1-steps)*steps**2*cx1 + steps**3*ex) ys = ((1-steps)**3*sy + 3*((1-steps)**2)*steps*cy0 + 3*(1-steps)*steps**2*cy1 + steps**3*ey) return np.column_stack([xs, ys])"
            },
            {
                "url": 4471,
                "code": "def polygon_from_points(points): polygon = [] for pair in points.split(\" \"): x_y = pair.split(\",\") polygon.append([float(x_y[0]), float(x_y[1])]) return polygon"
            },
            {
                "url": 5215,
                "code": "def point8_to_box(points): p = points.reshape((-1, 4, 2)) minxy = p.min(axis=1) # nx2 maxxy = p.max(axis=1) # nx2 return np.concatenate((minxy, maxxy), axis=1)"
            },
            {
                "url": 4093,
                "code": "def euler(self): e_xyz = transformations.euler_from_matrix(self.rotation, 'sxyz') return np.array([180.0 / np.pi * a for a in e_xyz])"
            }
        ],
        "url": 1016
    },
    {
        "nl_input": "how to see how similar two images are in python",
        "code_input": [
            {
                "url": 5226,
                "code": "def __similarity(s1, s2, ngrams_fn, n=3): ngrams1, ngrams2 = set(ngrams_fn(s1, n=n)), set(ngrams_fn(s2, n=n)) matches = ngrams1.intersection(ngrams2) return 2 * len(matches) / (len(ngrams1) + len(ngrams2))"
            },
            {
                "url": 5964,
                "code": "def similarity(word1: str, word2: str) -> float: return _MODEL.similarity(word1, word2)"
            },
            {
                "url": 5379,
                "code": "def _calculate_similarity(c): ma = {} for idc in c: set1 = _get_seqs(c[idc]) [ma.update({(idc, idc2): _common(set1, _get_seqs(c[idc2]), idc, idc2)}) for idc2 in c if idc != idc2 and (idc2, idc) not in ma] # logger.debug(\"_calculate_similarity_ %s\" % ma) return ma"
            },
            {
                "url": 5800,
                "code": "def tanimoto_set_similarity(x: Iterable[X], y: Iterable[X]) -> float: a, b = set(x), set(y) union = a | b if not union: return 0.0 return len(a & b) / len(union)"
            },
            {
                "url": 101,
                "code": "def similarity(self, other): if self.magnitude == 0 or other.magnitude == 0: return 0 return self.dot(other) / self.magnitude"
            },
            {
                "url": 3573,
                "code": "def hamming_distance(str1, str2): if len(str1) != len(str2): raise VisualizationError('Strings not same length.') return sum(s1 != s2 for s1, s2 in zip(str1, str2))"
            },
            {
                "url": 2602,
                "code": "def similarity_transformation(rot, mat): return np.dot(rot, np.dot(mat, np.linalg.inv(rot)))"
            },
            {
                "url": 6098,
                "code": "def calculate_single_tanimoto_set_distances(target: Iterable[X], dict_of_sets: Mapping[Y, Set[X]]) -> Mapping[Y, float]: target_set = set(target) return { k: tanimoto_set_similarity(target_set, s) for k, s in dict_of_sets.items() }"
            },
            {
                "url": 522,
                "code": "def compare(dicts): common_members = {} common_keys = reduce(lambda x, y: x & y, map(dict.keys, dicts)) for k in common_keys: common_members[k] = list( reduce(lambda x, y: x & y, [set(d[k]) for d in dicts])) return common_members"
            },
            {
                "url": 4037,
                "code": "def compare(string1, string2): if len(string1) != len(string2): return False result = True for c1, c2 in izip(string1, string2): result &= c1 == c2 return result"
            },
            {
                "url": 1482,
                "code": "def __matches(s1, s2, ngrams_fn, n=3): ngrams1, ngrams2 = set(ngrams_fn(s1, n=n)), set(ngrams_fn(s2, n=n)) return ngrams1.intersection(ngrams2)"
            },
            {
                "url": 4937,
                "code": "def _jit_pairwise_distances(pos1, pos2): n1 = pos1.shape[0] n2 = pos2.shape[0] D = np.empty((n1, n2)) for i in range(n1): for j in range(n2): D[i, j] = np.sqrt(((pos1[i] - pos2[j])**2).sum()) return D"
            },
            {
                "url": 4410,
                "code": "def word_matches(s1, s2, n=3): return __matches(s1, s2, word_ngrams, n=n)"
            },
            {
                "url": 4142,
                "code": "def distance_matrix(trains1, trains2, cos, tau): return dissimilarity_matrix(trains1, trains2, cos, tau, \"distance\")"
            },
            {
                "url": 180,
                "code": "def numpy_aware_eq(a, b): if isinstance(a, np.ndarray) or isinstance(b, np.ndarray): return np.array_equal(a, b) if ((isinstance(a, Iterable) and isinstance(b, Iterable)) and not isinstance(a, str) and not isinstance(b, str)): if len(a) != len(b): return False return all(numpy_aware_eq(x, y) for x, y in zip(a, b)) return a == b"
            }
        ],
        "url": 1294
    },
    {
        "nl_input": "how to make a input to have no spaces in python\\",
        "code_input": [
            {
                "url": 366,
                "code": "def strip_spaces(s): return u\" \".join([c for c in s.split(u' ') if c])"
            },
            {
                "url": 603,
                "code": "def strip_spaces(x): x = x.replace(b' ', b'') x = x.replace(b'\\t', b'') return x"
            },
            {
                "url": 2423,
                "code": "def strip_spaces(value, sep=None, join=True): value = value.strip() value = [v.strip() for v in value.split(sep)] join_sep = sep or ' ' return join_sep.join(value) if join else value"
            },
            {
                "url": 6168,
                "code": "def remove_blank_spaces(syllables: List[str]) -> List[str]: cleaned = [] for syl in syllables: if syl == \" \" or syl == '': pass else: cleaned.append(syl) return cleaned"
            },
            {
                "url": 5725,
                "code": "def remove_blank_lines(string): return \"\\n\".join(line for line in string.split(\"\\n\") if len(line.strip()))"
            },
            {
                "url": 3479,
                "code": "def indent(s, spaces=4): new = re.sub('(\\n+)', '\\\\1%s' % (' ' * spaces), s) return (' ' * spaces) + new.strip()"
            },
            {
                "url": 2393,
                "code": "def reindent(s, numspaces): leading_space = numspaces * ' ' lines = [leading_space + line.strip()for line in s.splitlines()] return '\\n'.join(lines)"
            },
            {
                "url": 5108,
                "code": "def fix_line_breaks(s): l = s.splitlines() x = [i.strip() for i in l] x = [i for i in x if i] # remove blank lines return \"\\n\".join(x)"
            },
            {
                "url": 6146,
                "code": "def space_list(line: str) -> List[int]: spaces = [] for idx, car in enumerate(list(line)): if car == \" \": spaces.append(idx) return spaces"
            },
            {
                "url": 1838,
                "code": "def unpunctuate(s, *, char_blacklist=string.punctuation): # remove punctuation s = \"\".join(c for c in s if c not in char_blacklist) # remove consecutive spaces return \" \".join(filter(None, s.split(\" \")))"
            },
            {
                "url": 2577,
                "code": "def clean_whitespace(statement): import re # Replace linebreaks and tabs with spaces statement.text = statement.text.replace('\\n', ' ').replace('\\r', ' ').replace('\\t', ' ') # Remove any leeding or trailing whitespace statement.text = statement.text.strip() # Remove consecutive spaces statement.text = re.sub(' +', ' ', statement.text) return statement"
            },
            {
                "url": 3891,
                "code": "def _trim(self, somestr): tmp = RE_LSPACES.sub(\"\", somestr) tmp = RE_TSPACES.sub(\"\", tmp) return str(tmp)"
            },
            {
                "url": 3447,
                "code": "def clean_whitespace(string, compact=False): for a, b in (('\\r\\n', '\\n'), ('\\r', '\\n'), ('\\n\\n', '\\n'), ('\\t', ' '), (' ', ' ')): string = string.replace(a, b) if compact: for a, b in (('\\n', ' '), ('[ ', '['), (' ', ' '), (' ', ' '), (' ', ' ')): string = string.replace(a, b) return string.strip()"
            },
            {
                "url": 2581,
                "code": "def clean(s): lines = [l.rstrip() for l in s.split('\\n')] return '\\n'.join(lines)"
            },
            {
                "url": 1651,
                "code": "def _clean_str(self, s): return s.translate(str.maketrans('', '', punctuation)).replace('\\u200b', \" \").strip().lower()"
            }
        ],
        "url": 3248
    },
    {
        "nl_input": "next line to read in python",
        "code_input": [
            {
                "url": 973,
                "code": "def _read_stdin(): line = sys.stdin.readline() while line: yield line line = sys.stdin.readline()"
            },
            {
                "url": 4999,
                "code": "def next(self): _LOGGER.debug(\"reading next\") if self.closed: _LOGGER.debug(\"stream is closed\") raise StopIteration() line = self.readline() if not line: _LOGGER.debug(\"nothing more to read\") raise StopIteration() return line"
            },
            {
                "url": 1590,
                "code": "def __next__(self): # Retrieve the row, thereby incrementing the line number: row = super(UnicodeReaderWithLineNumber, self).__next__() return self.lineno + 1, row"
            },
            {
                "url": 579,
                "code": "def next (self): # File-like object. result = self.readline() if result == self._empty_buffer: raise StopIteration return result"
            },
            {
                "url": 5230,
                "code": "def read(self): for line in self.io.read(): with self.parse_line(line) as j: yield j"
            },
            {
                "url": 5311,
                "code": "def readline(self): self.lineno += 1 if self._buffer: return self._buffer.pop() else: return self.input.readline()"
            },
            {
                "url": 2755,
                "code": "def next(self): # I'm pretty sure this is the completely wrong way to go about this, but # oh well, this works. if not hasattr(self, '_iter'): self._iter = self.readrow_as_dict() return self._iter.next()"
            },
            {
                "url": 2559,
                "code": "def standard_input(): with click.get_text_stream(\"stdin\") as stdin: while stdin.readable(): line = stdin.readline() if line: yield line.strip().encode(\"utf-8\")"
            },
            {
                "url": 3443,
                "code": "def read_next_block(infile, block_size=io.DEFAULT_BUFFER_SIZE): chunk = infile.read(block_size) while chunk: yield chunk chunk = infile.read(block_size)"
            },
            {
                "url": 34,
                "code": "def advance_one_line(self): current_line = self._current_token.line_number while current_line == self._current_token.line_number: self._current_token = ConfigParser.Token(*next(self._token_generator))"
            },
            {
                "url": 1989,
                "code": "def read_stdin(): if sys.stdin.isatty() and sys.stdout.isatty(): print('\\nReading from stdin until end of file (Ctrl + D)...') return sys.stdin.read()"
            },
            {
                "url": 4173,
                "code": "def readline( file, skip_blank=False ): while 1: line = file.readline() #print \"every line: %r\" % line if not line: return None if line[0] != '#' and not ( skip_blank and line.isspace() ): return line"
            },
            {
                "url": 3215,
                "code": "def _skip_frame(self): size = self.read_size() for i in range(size+1): line = self._f.readline() if len(line) == 0: raise StopIteration"
            },
            {
                "url": 1098,
                "code": "async def readline(self): future = asyncio.Future() data_available = False while True: if not data_available: if not self.my_serial.inWaiting(): await asyncio.sleep(self.sleep_tune) else: data_available = True data = self.my_serial.readline() future.set_result(data) else: if not future.done(): await asyncio.sleep(self.sleep_tune) else: return future.result()"
            },
            {
                "url": 2388,
                "code": "def step_next_line(self): self._eol.append(self.position) self._lineno += 1 self._col_offset = 0"
            }
        ],
        "url": 1590
    },
    {
        "nl_input": "move an item in list to front python",
        "code_input": [
            {
                "url": 1236,
                "code": "def list_move_to_front(l,value='other'): l=list(l) if value in l: l.remove(value) l.insert(0,value) return l"
            },
            {
                "url": 1502,
                "code": "def append(self, item): print(item) super(MyList, self).append(item)"
            },
            {
                "url": 5545,
                "code": "def find_first_in_list(txt: str, str_list: [str]) -> int: # type: ignore start = len(txt) + 1 for item in str_list: if start > txt.find(item) > -1: start = txt.find(item) return start if len(txt) + 1 > start > -1 else -1"
            },
            {
                "url": 3348,
                "code": "def insort_no_dup(lst, item): import bisect ix = bisect.bisect_left(lst, item) if lst[ix] != item: lst[ix:ix] = [item]"
            },
            {
                "url": 4710,
                "code": "def lpush(self, key, *args): redis_list = self._get_list(key, 'LPUSH', create=True) # Creates the list at this key if it doesn't exist, and appends args to its beginning args_reversed = [self._encode(arg) for arg in args] args_reversed.reverse() updated_list = args_reversed + redis_list self.redis[self._encode(key)] = updated_list # Return the length of the list after the push operation return len(updated_list)"
            },
            {
                "url": 6186,
                "code": "def insert_ordered(value, array): index = 0 # search for the last array item that value is larger than for n in range(0,len(array)): if value >= array[n]: index = n+1 array.insert(index, value) return index"
            },
            {
                "url": 2626,
                "code": "def add(self, value): if value not in self._set: self._set.add(value) self._list.add(value)"
            },
            {
                "url": 484,
                "code": "def _top(self): # Goto top of the list self.top.body.focus_position = 2 if self.compact is False else 0 self.top.keypress(self.size, \"\")"
            },
            {
                "url": 5320,
                "code": "def move_to_start(self, column_label): self._columns.move_to_end(column_label, last=False) return self"
            },
            {
                "url": 1019,
                "code": "def pop(self, index=-1): value = self._list.pop(index) del self._dict[value] return value"
            },
            {
                "url": 5569,
                "code": "def _rindex(mylist: Sequence[T], x: T) -> int: return len(mylist) - mylist[::-1].index(x) - 1"
            },
            {
                "url": 2947,
                "code": "def move_back(self, dt): self._position = self._old_position self.rect.topleft = self._position self.feet.midbottom = self.rect.midbottom"
            },
            {
                "url": 4462,
                "code": "def _heapreplace_max(heap, item): returnitem = heap[0] # raises appropriate IndexError if heap is empty heap[0] = item _siftup_max(heap, 0) return returnitem"
            },
            {
                "url": 2925,
                "code": "def _fill_array_from_list(the_list, the_array): for i, val in enumerate(the_list): the_array[i] = val return the_array"
            },
            {
                "url": 3362,
                "code": "def replace_list(items, match, replacement): return [replace(item, match, replacement) for item in items]"
            }
        ],
        "url": 1236
    },
    {
        "nl_input": "python wrap (s,w) print",
        "code_input": [
            {
                "url": 5216,
                "code": "def wrap(s, width=80): return '\\n'.join(textwrap.wrap(str(s), width=width))"
            },
            {
                "url": 3257,
                "code": "def do_wordwrap(s, width=79, break_long_words=True): import textwrap return u'\\n'.join(textwrap.wrap(s, width=width, expand_tabs=False, replace_whitespace=False, break_long_words=break_long_words))"
            },
            {
                "url": 2913,
                "code": "def wrap(text, width=70, **kwargs): w = TextWrapper(width=width, **kwargs) return w.wrap(text)"
            },
            {
                "url": 5313,
                "code": "def rewrap(s, width=COLS): s = ' '.join([l.strip() for l in s.strip().split('\\n')]) return '\\n'.join(textwrap.wrap(s, width))"
            },
            {
                "url": 4482,
                "code": "def wrap(text, indent=' '): wrapper = textwrap.TextWrapper( width=int(os.environ.get('COLUMNS', 80)), initial_indent=indent, subsequent_indent=indent ) return '\\n'.join(wrapper.wrap(text))"
            },
            {
                "url": 1661,
                "code": "def wrap(string, length, indent): newline = \"\\n\" + \" \" * indent return newline.join((string[i : i + length] for i in range(0, len(string), length)))"
            },
            {
                "url": 4399,
                "code": "def _wrap(text, columns=80): out = [] for cnt, char in enumerate(text): out.append(char) if (cnt + 1) % columns == 0: out.append(\"\\n\") return \"\".join(out)"
            },
            {
                "url": 1467,
                "code": "def raw_print(*args, **kw): print(*args, sep=kw.get('sep', ' '), end=kw.get('end', '\\n'), file=sys.__stdout__) sys.__stdout__.flush()"
            },
            {
                "url": 2524,
                "code": "def normalize_text(text, line_len=80, indent=\"\"): return \"\\n\".join( textwrap.wrap( text, width=line_len, initial_indent=indent, subsequent_indent=indent ) )"
            },
            {
                "url": 891,
                "code": "def map_wrap(f): @functools.wraps(f) def wrapper(*args, **kwargs): return f(*args, **kwargs) return wrapper"
            },
            {
                "url": 1028,
                "code": "def stdoutwriteline(*args): s = \"\" for i in args: s += str(i) + \" \" s = s.strip() sys.stdout.write(str(s) + \"\\n\") sys.stdout.flush() return s"
            },
            {
                "url": 1078,
                "code": "def _screen(self, s, newline=False): if self.verbose: if newline: print(s) else: print(s, end=' ')"
            },
            {
                "url": 3339,
                "code": "def print(cls, *args, **kwargs): # pylint: disable=protected-access with _shared._PRINT_LOCK: print(*args, **kwargs) _sys.stdout.flush()"
            },
            {
                "url": 1452,
                "code": "def printOut(value, end='\\n'): sys.stdout.write(value) sys.stdout.write(end) sys.stdout.flush()"
            },
            {
                "url": 1079,
                "code": "def _stdout_raw(self, s): print(s, end='', file=sys.stdout) sys.stdout.flush()"
            }
        ],
        "url": 4399
    },
    {
        "nl_input": "how to check if missing values are blanks or nan or none in python",
        "code_input": [
            {
                "url": 4722,
                "code": "def fillna(series_or_arr, missing_value=0.0): if pandas.notnull(missing_value): if isinstance(series_or_arr, (numpy.ndarray)): series_or_arr[numpy.isnan(series_or_arr)] = missing_value else: series_or_arr.fillna(missing_value, inplace=True) return series_or_arr"
            },
            {
                "url": 6165,
                "code": "def fix_missing(df, col, name, na_dict): if is_numeric_dtype(col): if pd.isnull(col).sum() or (name in na_dict): df[name+'_na'] = pd.isnull(col) filler = na_dict[name] if name in na_dict else col.median() df[name] = col.fillna(filler) na_dict[name] = filler return na_dict"
            },
            {
                "url": 1801,
                "code": "def fill_nulls(self, col: str): n = [None, \"\"] try: self.df[col] = self.df[col].replace(n, nan) except Exception as e: self.err(e)"
            },
            {
                "url": 292,
                "code": "def _maybe_fill(arr, fill_value=np.nan): if _isna_compat(arr, fill_value): arr.fill(fill_value) return arr"
            },
            {
                "url": 2179,
                "code": "def _isnan(self): if self._can_hold_na: return isna(self) else: # shouldn't reach to this condition by checking hasnans beforehand values = np.empty(len(self), dtype=np.bool_) values.fill(False) return values"
            },
            {
                "url": 5399,
                "code": "def table_nan_locs(table): ans = [] for rownum, row in enumerate(table): try: if pd.isnull(row).any(): colnums = pd.isnull(row).nonzero()[0] ans += [(rownum, colnum) for colnum in colnums] except AttributeError: # table is really just a sequence of scalars if pd.isnull(row): ans += [(rownum, 0)] return ans"
            },
            {
                "url": 5888,
                "code": "def warn_if_nans_exist(X): null_count = count_rows_with_nans(X) total = len(X) percent = 100 * null_count / total if null_count > 0: warning_message = \\ 'Warning! Found {} rows of {} ({:0.2f}%) with nan values. Only ' \\ 'complete rows will be plotted.'.format(null_count, total, percent) warnings.warn(warning_message, DataWarning)"
            },
            {
                "url": 2333,
                "code": "def clean_df(df, fill_nan=True, drop_empty_columns=True): if fill_nan: df = df.fillna(value=np.nan) if drop_empty_columns: df = df.dropna(axis=1, how='all') return df.sort_index()"
            },
            {
                "url": 3194,
                "code": "def na_if(series, *values): series = pd.Series(series) series[series.isin(values)] = np.nan return series"
            },
            {
                "url": 1025,
                "code": "def _replace_nan(a, val): mask = isnull(a) return where_method(val, mask, a), mask"
            },
            {
                "url": 2500,
                "code": "def clean_with_zeros(self,x): x[~np.any(np.isnan(x) | np.isinf(x),axis=1)] = 0 return x"
            },
            {
                "url": 889,
                "code": "def clean_dataframe(df): df = df.fillna(method='ffill') df = df.fillna(0.0) return df"
            },
            {
                "url": 5659,
                "code": "def is_not_null(df: DataFrame, col_name: str) -> bool: if ( isinstance(df, pd.DataFrame) and col_name in df.columns and df[col_name].notnull().any() ): return True else: return False"
            },
            {
                "url": 5607,
                "code": "def remove_nans_1D(*args) -> tuple: vals = np.isnan(args[0]) for a in args: vals |= np.isnan(a) return tuple(np.array(a)[~vals] for a in args)"
            },
            {
                "url": 5021,
                "code": "def count_nulls(self, field): try: n = self.df[field].isnull().sum() except KeyError: self.warning(\"Can not find column\", field) return except Exception as e: self.err(e, \"Can not count nulls\") return self.ok(\"Found\", n, \"nulls in column\", field)"
            }
        ],
        "url": 5888
    },
    {
        "nl_input": "python to get the indices of bin edges",
        "code_input": [
            {
                "url": 521,
                "code": "def val_to_bin(edges, x): ibin = np.digitize(np.array(x, ndmin=1), edges) - 1 return ibin"
            },
            {
                "url": 1540,
                "code": "def get_bin_indices(self, values): return tuple([self.get_axis_bin_index(values[ax_i], ax_i) for ax_i in range(self.dimensions)])"
            },
            {
                "url": 5975,
                "code": "def get_bin_edges_from_axis(axis) -> np.ndarray: # Don't include over- or underflow bins bins = range(1, axis.GetNbins() + 1) # Bin edges bin_edges = np.empty(len(bins) + 1) bin_edges[:-1] = [axis.GetBinLowEdge(i) for i in bins] bin_edges[-1] = axis.GetBinUpEdge(axis.GetNbins()) return bin_edges"
            },
            {
                "url": 3175,
                "code": "def edge_index(self): return dict((edge, index) for index, edge in enumerate(self.edges))"
            },
            {
                "url": 5389,
                "code": "def getEdges(npArr): edges = np.concatenate(([0], npArr[:,0] + npArr[:,2])) return np.array([Decimal(str(i)) for i in edges])"
            },
            {
                "url": 5791,
                "code": "def shape(self) -> Tuple[int, ...]: return tuple(bins.bin_count for bins in self._binnings)"
            },
            {
                "url": 4629,
                "code": "def _increment(arr, indices): arr = _as_array(arr) indices = _as_array(indices) bbins = np.bincount(indices) arr[:len(bbins)] += bbins return arr"
            },
            {
                "url": 4119,
                "code": "def lon_lat_bins(bb, coord_bin_width): west, south, east, north = bb west = numpy.floor(west / coord_bin_width) * coord_bin_width east = numpy.ceil(east / coord_bin_width) * coord_bin_width lon_extent = get_longitudinal_extent(west, east) lon_bins, _, _ = npoints_between( west, 0, 0, east, 0, 0, numpy.round(lon_extent / coord_bin_width + 1)) lat_bins = coord_bin_width * numpy.arange( int(numpy.floor(south / coord_bin_width)), int(numpy.ceil(north / coord_bin_width) + 1)) return lon_bins, lat_bins"
            },
            {
                "url": 5573,
                "code": "def indices_to_labels(self, indices: Sequence[int]) -> List[str]: return [(self.INDEX_TO_LABEL[index]) for index in indices]"
            },
            {
                "url": 3066,
                "code": "def vals2bins(vals,res=100): # flatten if list of lists if any(isinstance(el, list) for el in vals): vals = list(itertools.chain(*vals)) return list(np.digitize(vals, np.linspace(np.min(vals), np.max(vals)+1, res+1)) - 1)"
            },
            {
                "url": 3070,
                "code": "def pairwise_indices(self): return np.array([sig.pairwise_indices for sig in self.values]).T"
            },
            {
                "url": 140,
                "code": "def _interval_to_bound_points(array): array_boundaries = np.array([x.left for x in array]) array_boundaries = np.concatenate( (array_boundaries, np.array([array[-1].right]))) return array_boundaries"
            },
            {
                "url": 1985,
                "code": "def binSearch(arr, val): i = bisect_left(arr, val) if i != len(arr) and arr[i] == val: return i return -1"
            },
            {
                "url": 4059,
                "code": "def to_bin(data, width): data_str = bin(data & (2**width-1))[2:].zfill(width) return [int(x) for x in tuple(data_str)]"
            },
            {
                "url": 3163,
                "code": "def inverseHistogram(hist, bin_range): data = hist.astype(float) / np.min(hist[np.nonzero(hist)]) new_data = np.empty(shape=np.sum(data, dtype=int)) i = 0 xvals = np.linspace(bin_range[0], bin_range[1], len(data)) for d, x in zip(data, xvals): new_data[i:i + d] = x i += int(d) return new_data"
            }
        ],
        "url": 521
    },
    {
        "nl_input": "python comma separated value",
        "code_input": [
            {
                "url": 77,
                "code": "def list_to_csv(value): if isinstance(value, (list, tuple, set)): value = \",\".join(value) return value"
            },
            {
                "url": 3278,
                "code": "def comma_delimited_to_list(list_param): if isinstance(list_param, list): return list_param if isinstance(list_param, str): return list_param.split(',') else: return []"
            },
            {
                "url": 160,
                "code": "def commajoin_as_strings(iterable): return _(u',').join((six.text_type(i) for i in iterable))"
            },
            {
                "url": 1110,
                "code": "def split_comma_argument(comma_sep_str): terms = [] for term in comma_sep_str.split(','): if term: terms.append(term) return terms"
            },
            {
                "url": 392,
                "code": "def _split_comma_separated(string): return set(text.strip() for text in string.split(',') if text.strip())"
            },
            {
                "url": 3842,
                "code": "def _return_comma_list(self, l): if isinstance(l, (text_type, int)): return l if not isinstance(l, list): raise TypeError(l, ' should be a list of integers, \\ not {0}'.format(type(l))) str_ids = ','.join(str(i) for i in l) return str_ids"
            },
            {
                "url": 5700,
                "code": "def list_to_str(list, separator=','): list = [str(x) for x in list] return separator.join(list)"
            },
            {
                "url": 736,
                "code": "def comma_converter(float_string): trans_table = maketrans(b',', b'.') return float(float_string.translate(trans_table))"
            },
            {
                "url": 5723,
                "code": "def _str_to_list(value, separator): value_list = [item.strip() for item in value.split(separator)] value_list_sanitized = builtins.list(filter(None, value_list)) if len(value_list_sanitized) > 0: return value_list_sanitized else: raise ValueError('Invalid list variable.')"
            },
            {
                "url": 2880,
                "code": "def string_to_list(string, sep=\",\", filter_empty=False): return [value.strip() for value in string.split(sep) if (not filter_empty or value)]"
            },
            {
                "url": 2742,
                "code": "def csvtolist(inputstr): reader = csv.reader([inputstr], skipinitialspace=True) output = [] for r in reader: output += r return output"
            },
            {
                "url": 1295,
                "code": "def delimited(items, character='|'): return '|'.join(items) if type(items) in (list, tuple, set) else items"
            },
            {
                "url": 660,
                "code": "def as_tuple(self, value): if isinstance(value, list): value = tuple(value) return value"
            },
            {
                "url": 892,
                "code": "def list_formatter(handler, item, value): return u', '.join(str(v) for v in value)"
            },
            {
                "url": 3850,
                "code": "def _split(value): if isinstance(value, str): # iterable, but not meant for splitting return value, value try: invalue, outvalue = value except TypeError: invalue = outvalue = value except ValueError: raise ValueError(\"Only single values and pairs are allowed\") return invalue, outvalue"
            }
        ],
        "url": 77
    },
    {
        "nl_input": "python requests disable ssl certificate verification",
        "code_input": [
            {
                "url": 2639,
                "code": "def disable_cert_validation(): current_context = ssl._create_default_https_context ssl._create_default_https_context = ssl._create_unverified_context try: yield finally: ssl._create_default_https_context = current_context"
            },
            {
                "url": 2308,
                "code": "def disable_insecure_request_warning(): import requests from requests.packages.urllib3.exceptions import InsecureRequestWarning requests.packages.urllib3.disable_warnings(InsecureRequestWarning)"
            },
            {
                "url": 2787,
                "code": "def enable_ssl(self, *args, **kwargs): if self.handshake_sent: raise SSLError('can only enable SSL before handshake') self.secure = True self.sock = ssl.wrap_socket(self.sock, *args, **kwargs)"
            },
            {
                "url": 602,
                "code": "def inject_into_urllib3(): util.ssl_.SSLContext = SecureTransportContext util.HAS_SNI = HAS_SNI util.ssl_.HAS_SNI = HAS_SNI util.IS_SECURETRANSPORT = True util.ssl_.IS_SECURETRANSPORT = True"
            },
            {
                "url": 1176,
                "code": "def _shutdown_transport(self): if self.sock is not None: try: unwrap = self.sock.unwrap except AttributeError: return try: self.sock = unwrap() except ValueError: # Failure within SSL might mean unwrap exists but socket is not # deemed wrapped pass"
            },
            {
                "url": 1266,
                "code": "def get_pg_connection(host, user, port, password, database, ssl={}): return psycopg2.connect(host=host, user=user, port=port, password=password, dbname=database, sslmode=ssl.get('sslmode', None), sslcert=ssl.get('sslcert', None), sslkey=ssl.get('sslkey', None), sslrootcert=ssl.get('sslrootcert', None), )"
            },
            {
                "url": 5409,
                "code": "def _sslobj(sock): pass if isinstance(sock._sslobj, _ssl._SSLSocket): return sock._sslobj else: return sock._sslobj._sslobj"
            },
            {
                "url": 532,
                "code": "def should_skip_logging(func): disabled = strtobool(request.headers.get(\"x-request-nolog\", \"false\")) return disabled or getattr(func, SKIP_LOGGING, False)"
            },
            {
                "url": 5003,
                "code": "def test_security(self): self.assertEqual(run_example(examples_folder + \"security.py --generate\"), 0) self.assertEqual(run_example(examples_folder + \"security.py --revoke\"), 0)"
            },
            {
                "url": 3330,
                "code": "def setup_request_sessions(self): self.req_session = requests.Session() self.req_session.headers.update(self.headers)"
            },
            {
                "url": 6187,
                "code": "def check_python_version(): # Required due to multiple with statements on one line req_version = (2, 7) cur_version = sys.version_info if cur_version >= req_version: print(\"Python version... %sOK%s (found %s, requires %s)\" % (Bcolors.OKGREEN, Bcolors.ENDC, str(platform.python_version()), str(req_version[0]) + \".\" + str(req_version[1]))) else: print(\"Python version... %sFAIL%s (found %s, requires %s)\" % (Bcolors.FAIL, Bcolors.ENDC, str(cur_version), str(req_version)))"
            },
            {
                "url": 3802,
                "code": "def rest_put_stream(self, url, stream, headers=None, session=None, verify=True, cert=None): res = session.put(url, headers=headers, data=stream, verify=verify, cert=cert) return res.text, res.status_code"
            },
            {
                "url": 3847,
                "code": "def set_proxy(proxy_url, transport_proxy=None): global proxy, PYPI_URL PYPI_URL = proxy_url proxy = xmlrpc.ServerProxy( proxy_url, transport=RequestsTransport(proxy_url.startswith('https://')), allow_none=True)"
            },
            {
                "url": 6007,
                "code": "def _RetryRequest(self, timeout=None, **request_args): while True: try: now = time.time() if not timeout: timeout = config.CONFIG[\"Client.http_timeout\"] result = requests.request(**request_args) # By default requests doesn't raise on HTTP error codes. result.raise_for_status() # Requests does not always raise an exception when an incorrect response # is received. This fixes that behaviour. if not result.ok: raise requests.RequestException(response=result) return time.time() - now, result # Catch any exceptions that dont have a code (e.g. socket.error). except IOError as e: self.consecutive_connection_errors += 1 # Request failed. If we connected successfully before we attempt a few # connections before we determine that it really failed. This might # happen if the front end is loaded and returns a few throttling 500 # messages. if self.active_base_url is not None: # Propagate 406 immediately without retrying, as 406 is a valid # response that indicates a need for enrollment. response = getattr(e, \"response\", None) if getattr(response, \"status_code\", None) == 406: raise if self.consecutive_connection_errors >= self.retry_error_limit: # We tried several times but this really did not work, just fail it. logging.info( \"Too many connection errors to %s, retrying another URL\", self.active_base_url) self.active_base_url = None raise e # Back off hard to allow the front end to recover. logging.debug( \"Unable to connect to frontend. Backing off %s seconds.\", self.error_poll_min) self.Wait(self.error_poll_min) # We never previously connected, maybe the URL/proxy is wrong? Just fail # right away to allow callers to try a different URL. else: raise e"
            },
            {
                "url": 4106,
                "code": "def handle_request_parsing_error(err, req, schema, error_status_code, error_headers): abort(error_status_code, errors=err.messages)"
            }
        ],
        "url": 2308
    },
    {
        "nl_input": "python var and distribution of probability",
        "code_input": [
            {
                "url": 376,
                "code": "def EvalGaussianPdf(x, mu, sigma): return scipy.stats.norm.pdf(x, mu, sigma)"
            },
            {
                "url": 4556,
                "code": "def EvalPoissonPmf(k, lam): # don't use the scipy function (yet). for lam=0 it returns NaN; # should be 0.0 # return scipy.stats.poisson.pmf(k, lam) return lam ** k * math.exp(-lam) / math.factorial(k)"
            },
            {
                "url": 5805,
                "code": "def sample_normal(mean, var, rng): ret = numpy.sqrt(var) * rng.randn(*mean.shape) + mean return ret"
            },
            {
                "url": 638,
                "code": "def norm(x, mu, sigma=1.0): return stats.norm(loc=mu, scale=sigma).pdf(x)"
            },
            {
                "url": 741,
                "code": "def lognorm(x, mu, sigma=1.0): return stats.lognorm(sigma, scale=mu).pdf(x)"
            },
            {
                "url": 96,
                "code": "def pdf(x, mu, std): return (1.0 / (std * sqrt(2 * pi))) * np.exp(-(x - mu) ** 2 / (2 * std ** 2))"
            },
            {
                "url": 1336,
                "code": "def ln_norm(x, mu, sigma=1.0): return np.log(stats.norm(loc=mu, scale=sigma).pdf(x))"
            },
            {
                "url": 268,
                "code": "def gauss_pdf(x, mu, sigma): return 1 / np.sqrt(2 * np.pi) / sigma * np.exp(-(x - mu) ** 2 / 2. / sigma ** 2)"
            },
            {
                "url": 3947,
                "code": "def EvalBinomialPmf(k, n, p): return scipy.stats.binom.pmf(k, n, p)"
            },
            {
                "url": 4662,
                "code": "def gaussian_distribution(mean, stdev, num_pts=50): xstart = mean - (4.0 * stdev) xend = mean + (4.0 * stdev) x = np.linspace(xstart,xend,num_pts) y = (1.0/np.sqrt(2.0*np.pi*stdev*stdev)) * np.exp(-1.0 * ((x - mean)**2)/(2.0*stdev*stdev)) return x,y"
            },
            {
                "url": 6200,
                "code": "def kernel(self, spread=1): # TODO: use self.kernel_type to choose function def gaussian(data, pixel): return mvn.pdf(data, mean=pixel, cov=spread) return gaussian"
            },
            {
                "url": 3331,
                "code": "def lognormcdf(x, mu, tau): x = np.atleast_1d(x) return np.array( [0.5 * (1 - flib.derf(-(np.sqrt(tau / 2)) * (np.log(y) - mu))) for y in x])"
            },
            {
                "url": 1610,
                "code": "def Gaussian(x, mu, sig): return sympy.exp(-(x - mu)**2/(2*sig**2))/sympy.sqrt(2*sympy.pi*sig**2)"
            },
            {
                "url": 3765,
                "code": "def SampleSum(dists, n): pmf = MakePmfFromList(RandomSum(dists) for i in xrange(n)) return pmf"
            },
            {
                "url": 5842,
                "code": "def _gauss(mean: int, sigma: int) -> int: return int(random.gauss(mean, sigma))"
            }
        ],
        "url": 96
    },
    {
        "nl_input": "how to determine it's a orthogonal matrix using python",
        "code_input": [
            {
                "url": 1241,
                "code": "def is_square_matrix(mat): mat = np.array(mat) if mat.ndim != 2: return False shape = mat.shape return shape[0] == shape[1]"
            },
            {
                "url": 5774,
                "code": "def is_orthogonal( matrix: np.ndarray, *, rtol: float = 1e-5, atol: float = 1e-8) -> bool: return (matrix.shape[0] == matrix.shape[1] and np.all(np.imag(matrix) == 0) and np.allclose(matrix.dot(matrix.T), np.eye(matrix.shape[0]), rtol=rtol, atol=atol))"
            },
            {
                "url": 5863,
                "code": "def is_unitary(matrix: np.ndarray) -> bool: rows, cols = matrix.shape if rows != cols: return False return np.allclose(np.eye(rows), matrix.dot(matrix.T.conj()))"
            },
            {
                "url": 766,
                "code": "def isSquare(matrix): try: try: dim1, dim2 = matrix.shape except AttributeError: dim1, dim2 = _np.array(matrix).shape except ValueError: return False if dim1 == dim2: return True return False"
            },
            {
                "url": 1574,
                "code": "def is_bool_matrix(l): r if isinstance(l, np.ndarray): if l.ndim == 2 and (l.dtype == bool): return True return False"
            },
            {
                "url": 2131,
                "code": "def is_sparse_vector(x): return sp.issparse(x) and len(x.shape) == 2 and x.shape[0] == 1"
            },
            {
                "url": 2512,
                "code": "def MatrixInverse(a, adj): return np.linalg.inv(a if not adj else _adjoint(a)),"
            },
            {
                "url": 1168,
                "code": "def MatrixSolve(a, rhs, adj): return np.linalg.solve(a if not adj else _adjoint(a), rhs),"
            },
            {
                "url": 867,
                "code": "def matrix_at_check(self, original, loc, tokens): return self.check_py(\"35\", \"matrix multiplication\", original, loc, tokens)"
            },
            {
                "url": 1862,
                "code": "def ident(): matrix = stypes.emptyDoubleMatrix() libspice.ident_c(matrix) return stypes.cMatrixToNumpy(matrix)"
            },
            {
                "url": 3003,
                "code": "def normalize_matrix(matrix): abs_matrix = np.abs(matrix.copy()) return abs_matrix / abs_matrix.max()"
            },
            {
                "url": 2881,
                "code": "def sparse_to_matrix(sparse): sparse = np.asanyarray(sparse, dtype=np.int) if not util.is_shape(sparse, (-1, 3)): raise ValueError('sparse must be (n,3)!') shape = sparse.max(axis=0) + 1 matrix = np.zeros(np.product(shape), dtype=np.bool) multiplier = np.array([np.product(shape[1:]), shape[2], 1]) index = (sparse * multiplier).sum(axis=1) matrix[index] = True dense = matrix.reshape(shape) return dense"
            },
            {
                "url": 4088,
                "code": "def is_vector(inp): inp = np.asarray(inp) nr_dim = np.ndim(inp) if nr_dim == 1: return True elif (nr_dim == 2) and (1 in inp.shape): return True else: return False"
            },
            {
                "url": 1890,
                "code": "def matrix_to_gl(matrix): matrix = np.asanyarray(matrix, dtype=np.float64) if matrix.shape != (4, 4): raise ValueError('matrix must be (4,4)!') # switch to column major and flatten to (16,) column = matrix.T.flatten() # convert to GLfloat glmatrix = (gl.GLfloat * 16)(*column) return glmatrix"
            },
            {
                "url": 5558,
                "code": "def get_pij_matrix(t, diag, A, A_inv): return A.dot(np.diag(np.exp(diag * t))).dot(A_inv)"
            }
        ],
        "url": 5774
    },
    {
        "nl_input": "strip html tags in python",
        "code_input": [
            {
                "url": 3151,
                "code": "def strip_html(string, keep_tag_content=False): r = HTML_TAG_ONLY_RE if keep_tag_content else HTML_RE return r.sub('', string)"
            },
            {
                "url": 3792,
                "code": "def do_striptags(value): if hasattr(value, '__html__'): value = value.__html__() return Markup(unicode(value)).striptags()"
            },
            {
                "url": 3720,
                "code": "def clean_markdown(text): result = text if isinstance(text, str): result = ''.join( BeautifulSoup(markdown(text), 'lxml').findAll(text=True)) return result"
            },
            {
                "url": 1408,
                "code": "def html_to_text(content): text = None h2t = html2text.HTML2Text() h2t.ignore_links = False text = h2t.handle(content) return text"
            },
            {
                "url": 4810,
                "code": "def strip_tweet(text, remove_url=True): if remove_url: text = url_pattern.sub('', text) else: text = expand_url(text) text = mention_pattern.sub('', text) text = html_parser.unescape(text) text = text.strip() return text"
            },
            {
                "url": 5991,
                "code": "def strip_codes(s: Any) -> str: return codepat.sub('', str(s) if (s or (s == 0)) else '')"
            },
            {
                "url": 1103,
                "code": "def _removeTags(tags, objects): for t in tags: for o in objects: o.tags.remove(t) return True"
            },
            {
                "url": 3796,
                "code": "def clean_strings(iterable): retval = [] for val in iterable: try: retval.append(val.strip()) except(AttributeError): retval.append(val) return retval"
            },
            {
                "url": 2421,
                "code": "def _repr_strip(mystring): r = repr(mystring) if r.startswith(\"'\") and r.endswith(\"'\"): return r[1:-1] else: return r"
            },
            {
                "url": 2580,
                "code": "def strip_xml_namespace(root): try: root.tag = root.tag.split('}')[1] except IndexError: pass for element in root.getchildren(): strip_xml_namespace(element)"
            },
            {
                "url": 3747,
                "code": "def _strip_namespace(self, xml): p = re.compile(b\"xmlns=*[\\\"\\\"][^\\\"\\\"]*[\\\"\\\"]\") allmatches = p.finditer(xml) for match in allmatches: xml = xml.replace(match.group(), b\"\") return xml"
            },
            {
                "url": 5031,
                "code": "def tag_to_dict(html): element = document_fromstring(html).xpath(\"//html/body/child::*\")[0] attributes = dict(element.attrib) attributes[\"text\"] = element.text_content() return attributes"
            },
            {
                "url": 603,
                "code": "def strip_spaces(x): x = x.replace(b' ', b'') x = x.replace(b'\\t', b'') return x"
            },
            {
                "url": 1651,
                "code": "def _clean_str(self, s): return s.translate(str.maketrans('', '', punctuation)).replace('\\u200b', \" \").strip().lower()"
            },
            {
                "url": 778,
                "code": "def strip(notebook): for cell in notebook.cells: if cell.cell_type == 'code': cell.outputs = [] cell.execution_count = None"
            }
        ],
        "url": 3792
    },
    {
        "nl_input": "center align python text",
        "code_input": [
            {
                "url": 156,
                "code": "def center_text(text, width=80): centered = [] for line in text.splitlines(): centered.append(line.center(width)) return \"\\n\".join(centered)"
            },
            {
                "url": 6178,
                "code": "def text_alignment(x, y): if x == 0: ha = \"center\" elif x > 0: ha = \"left\" else: ha = \"right\" if y == 0: va = \"center\" elif y > 0: va = \"bottom\" else: va = \"top\" return ha, va"
            },
            {
                "url": 2311,
                "code": "def _pad(self, text): top_bottom = (\"\\n\" * self._padding) + \" \" right_left = \" \" * self._padding * self.PAD_WIDTH return top_bottom + right_left + text + right_left + top_bottom"
            },
            {
                "url": 2524,
                "code": "def normalize_text(text, line_len=80, indent=\"\"): return \"\\n\".join( textwrap.wrap( text, width=line_len, initial_indent=indent, subsequent_indent=indent ) )"
            },
            {
                "url": 2913,
                "code": "def wrap(text, width=70, **kwargs): w = TextWrapper(width=width, **kwargs) return w.wrap(text)"
            },
            {
                "url": 4399,
                "code": "def _wrap(text, columns=80): out = [] for cnt, char in enumerate(text): out.append(char) if (cnt + 1) % columns == 0: out.append(\"\\n\") return \"\".join(out)"
            },
            {
                "url": 4482,
                "code": "def wrap(text, indent=' '): wrapper = textwrap.TextWrapper( width=int(os.environ.get('COLUMNS', 80)), initial_indent=indent, subsequent_indent=indent ) return '\\n'.join(wrapper.wrap(text))"
            },
            {
                "url": 1067,
                "code": "def add_text(text, x=0.01, y=0.01, axes=\"gca\", draw=True, **kwargs): if axes==\"gca\": axes = _pylab.gca() axes.text(x, y, text, transform=axes.transAxes, **kwargs) if draw: _pylab.draw()"
            },
            {
                "url": 5772,
                "code": "def margin(text): r lines = str(text).split('\\n') return '\\n'.join(' {} '.format(l) for l in lines)"
            },
            {
                "url": 2982,
                "code": "def indent(text, amount, ch=' '): padding = amount * ch return ''.join(padding+line for line in text.splitlines(True))"
            },
            {
                "url": 816,
                "code": "def align_file_position(f, size): align = (size - 1) - (f.tell() % size) f.seek(align, 1)"
            },
            {
                "url": 1718,
                "code": "def position(self, x, y, text): sys.stdout.write(\"\\x1b7\\x1b[%d;%df%s\\x1b8\" % (x, y, text)) sys.stdout.flush()"
            },
            {
                "url": 1183,
                "code": "def text_width(string, font_name, font_size): return stringWidth(string, fontName=font_name, fontSize=font_size)"
            },
            {
                "url": 1446,
                "code": "def indented_show(text, howmany=1): print(StrTemplate.pad_indent(text=text, howmany=howmany))"
            },
            {
                "url": 5216,
                "code": "def wrap(s, width=80): return '\\n'.join(textwrap.wrap(str(s), width=width))"
            }
        ],
        "url": 156
    },
    {
        "nl_input": "python get list of keys on an object",
        "code_input": [
            {
                "url": 2245,
                "code": "def get_all_items(obj): if hasattr(obj, 'getlist'): items = [] for key in obj: for value in obj.getlist(key): items.append((key, value)) return items else: return obj.items()"
            },
            {
                "url": 4239,
                "code": "def iterlists(self): for key, values in dict.iteritems(self): yield key, list(values)"
            },
            {
                "url": 2157,
                "code": "def _get_non_empty_list(cls, iter): res = [] for value in iter: if hasattr(value, 'items'): value = cls._get_non_empty_dict(value) or None if value is not None: res.append(value) return res"
            },
            {
                "url": 1757,
                "code": "def items(iterable): if hasattr(iterable, 'iteritems'): return (p for p in iterable.iteritems()) elif hasattr(iterable, 'items'): return (p for p in iterable.items()) else: return (p for p in enumerate(iterable))"
            },
            {
                "url": 2593,
                "code": "def get_value(key, obj, default=missing): if isinstance(key, int): return _get_value_for_key(key, obj, default) return _get_value_for_keys(key.split('.'), obj, default)"
            },
            {
                "url": 5615,
                "code": "def iterate_items(dictish): if hasattr(dictish, 'iteritems'): return dictish.iteritems() if hasattr(dictish, 'items'): return dictish.items() return dictish"
            },
            {
                "url": 2202,
                "code": "def get_dict_for_attrs(obj, attrs): data = {} for attr in attrs: data[attr] = getattr(obj, attr) return data"
            },
            {
                "url": 5769,
                "code": "def encode_list(key, list_): # type: (str, Iterable) -> Dict[str, str] if not list_: return {} return {key: \" \".join(str(i) for i in list_)}"
            },
            {
                "url": 1480,
                "code": "def to_dict(dictish): if hasattr(dictish, 'iterkeys'): m = dictish.iterkeys elif hasattr(dictish, 'keys'): m = dictish.keys else: raise ValueError(dictish) return dict((k, dictish[k]) for k in m())"
            },
            {
                "url": 719,
                "code": "def list_get(l, idx, default=None): try: if l[idx]: return l[idx] else: return default except IndexError: return default"
            },
            {
                "url": 1367,
                "code": "def list_of_lists_to_dict(l): d = {} for key, val in l: d.setdefault(key, []).append(val) return d"
            },
            {
                "url": 5832,
                "code": "def __as_list(value: List[JsonObjTypes]) -> List[JsonTypes]: return [e._as_dict if isinstance(e, JsonObj) else e for e in value]"
            },
            {
                "url": 1843,
                "code": "def list2dict(lst): dic = {} for k,v in lst: dic[k] = v return dic"
            },
            {
                "url": 5612,
                "code": "def get_keys_of_max_n(dict_obj, n): return sorted([ item[0] for item in sorted( dict_obj.items(), key=lambda item: item[1], reverse=True )[:n] ])"
            },
            {
                "url": 2126,
                "code": "def all_strings(arr): if not isinstance([], list): raise TypeError(\"non-list value found where list is expected\") return all(isinstance(x, str) for x in arr)"
            }
        ],
        "url": 387
    },
    {
        "nl_input": "is there any python function to check for nan valu",
        "code_input": [
            {
                "url": 2179,
                "code": "def _isnan(self): if self._can_hold_na: return isna(self) else: # shouldn't reach to this condition by checking hasnans beforehand values = np.empty(len(self), dtype=np.bool_) values.fill(False) return values"
            },
            {
                "url": 723,
                "code": "def nan_pixels(self): nan_px = np.where(np.isnan(np.sum(self.raw_data, axis=2))) nan_px = np.c_[nan_px[0], nan_px[1]] return nan_px"
            },
            {
                "url": 1025,
                "code": "def _replace_nan(a, val): mask = isnull(a) return where_method(val, mask, a), mask"
            },
            {
                "url": 5888,
                "code": "def warn_if_nans_exist(X): null_count = count_rows_with_nans(X) total = len(X) percent = 100 * null_count / total if null_count > 0: warning_message = \\ 'Warning! Found {} rows of {} ({:0.2f}%) with nan values. Only ' \\ 'complete rows will be plotted.'.format(null_count, total, percent) warnings.warn(warning_message, DataWarning)"
            },
            {
                "url": 2305,
                "code": "def is_float_array(val): return is_np_array(val) and issubclass(val.dtype.type, np.floating)"
            },
            {
                "url": 5399,
                "code": "def table_nan_locs(table): ans = [] for rownum, row in enumerate(table): try: if pd.isnull(row).any(): colnums = pd.isnull(row).nonzero()[0] ans += [(rownum, colnum) for colnum in colnums] except AttributeError: # table is really just a sequence of scalars if pd.isnull(row): ans += [(rownum, 0)] return ans"
            },
            {
                "url": 772,
                "code": "def is_float(value): return isinstance(value, float) or isinstance(value, int) or isinstance(value, np.float64), float(value)"
            },
            {
                "url": 292,
                "code": "def _maybe_fill(arr, fill_value=np.nan): if _isna_compat(arr, fill_value): arr.fill(fill_value) return arr"
            },
            {
                "url": 5935,
                "code": "def isfinite(data: mx.nd.NDArray) -> mx.nd.NDArray: is_data_not_nan = data == data is_data_not_infinite = data.abs() != np.inf return mx.nd.logical_and(is_data_not_infinite, is_data_not_nan)"
            },
            {
                "url": 3194,
                "code": "def na_if(series, *values): series = pd.Series(series) series[series.isin(values)] = np.nan return series"
            },
            {
                "url": 5607,
                "code": "def remove_nans_1D(*args) -> tuple: vals = np.isnan(args[0]) for a in args: vals |= np.isnan(a) return tuple(np.array(a)[~vals] for a in args)"
            },
            {
                "url": 3579,
                "code": "def _force_float(v): try: return float(v) except Exception as exc: return float('nan') logger.warning('Failed to convert {} to float with {} error. Using 0 instead.'.format(v, exc))"
            },
            {
                "url": 5919,
                "code": "def is_none(string_, default='raise'): none = ['none', 'undefined', 'unknown', 'null', ''] if string_.lower() in none: return True elif not default: return False else: raise ValueError('The value \\'{}\\' cannot be mapped to none.' .format(string_))"
            },
            {
                "url": 1854,
                "code": "def count_rows_with_nans(X): if X.ndim == 2: return np.where(np.isnan(X).sum(axis=1) != 0, 1, 0).sum()"
            },
            {
                "url": 2999,
                "code": "def set_float(val): out = None if not val in (None, ''): try: out = float(val) except ValueError: return None if numpy.isnan(out): out = default return out"
            }
        ],
        "url": 621
    },
    {
        "nl_input": "python get cookie for request",
        "code_input": [
            {
                "url": 3111,
                "code": "def parse_cookies(self, req, name, field): return core.get_value(req.COOKIES, name, field)"
            },
            {
                "url": 5970,
                "code": "def cookies(self) -> Dict[str, str]: cookies = SimpleCookie() cookies.load(self.headers.get('Cookie', '')) return {key: cookie.value for key, cookie in cookies.items()}"
            },
            {
                "url": 3809,
                "code": "def _get_data(self): cookie = self.adapter.cookies.get(self.name) return self._deserialize(cookie) if cookie else {}"
            },
            {
                "url": 42,
                "code": "def parse_cookies_str(cookies): cookie_dict = {} for record in cookies.split(\";\"): key, value = record.strip().split(\"=\", 1) cookie_dict[key] = value return cookie_dict"
            },
            {
                "url": 3378,
                "code": "def _save_cookies(requests_cookiejar, filename): with open(filename, 'wb') as handle: pickle.dump(requests_cookiejar, handle)"
            },
            {
                "url": 2944,
                "code": "def get_csrf_token(response): cookie_headers = [ h.decode('ascii') for h in response.headers.getlist(\"Set-Cookie\") ] if not cookie_headers: return None csrf_headers = [ h for h in cookie_headers if h.startswith(\"csrftoken=\") ] if not csrf_headers: return None match = re.match(\"csrftoken=([^ ;]+);\", csrf_headers[-1]) return match.group(1)"
            },
            {
                "url": 2657,
                "code": "def save_config_value(request, response, key, value): request.session[key] = value response.set_cookie(key, value, expires=one_year_from_now()) return response"
            },
            {
                "url": 4256,
                "code": "def get_from_headers(request, key): value = request.headers.get(key) return to_native(value)"
            },
            {
                "url": 1031,
                "code": "def save_session_to_file(self, sessionfile): pickle.dump(requests.utils.dict_from_cookiejar(self._session.cookies), sessionfile)"
            },
            {
                "url": 1873,
                "code": "def get(key, default=None): data = get_form() or get_query_string() return data.get(key, default)"
            },
            {
                "url": 1975,
                "code": "def wget(url): import urllib.parse request = urllib.request.urlopen(url) filestring = request.read() return filestring"
            },
            {
                "url": 6096,
                "code": "def copy_session(session: requests.Session) -> requests.Session: new = requests.Session() new.cookies = requests.utils.cookiejar_from_dict(requests.utils.dict_from_cookiejar(session.cookies)) new.headers = session.headers.copy() return new"
            },
            {
                "url": 1410,
                "code": "def get(url): response = urllib.request.urlopen(url) data = response.read() data = data.decode(\"utf-8\") data = json.loads(data) return data"
            },
            {
                "url": 1423,
                "code": "def get(self, key): res = self.connection.get(key) print(res) return res"
            },
            {
                "url": 3776,
                "code": "def get(self, key): value = redis_conn.get(key) if value is not None: value = pickle.loads(value) return value"
            }
        ],
        "url": 3111
    },
    {
        "nl_input": "python is list no na",
        "code_input": [
            {
                "url": 5549,
                "code": "def listify(a): if a is None: return [] elif not isinstance(a, (tuple, list, np.ndarray)): return [a] return list(a)"
            },
            {
                "url": 6037,
                "code": "def ensure_list(iterable: Iterable[A]) -> List[A]: if isinstance(iterable, list): return iterable else: return list(iterable)"
            },
            {
                "url": 1782,
                "code": "def is_list_of_list(item): if ( type(item) in (list, tuple) and len(item) and isinstance(item[0], (list, tuple)) ): return True return False"
            },
            {
                "url": 1837,
                "code": "def to_list(var): if var is None: return [] if isinstance(var, str): var = var.split('\\n') elif not isinstance(var, list): try: var = list(var) except TypeError: raise ValueError(\"{} cannot be converted to the list.\".format(var)) return var"
            },
            {
                "url": 755,
                "code": "def is_listish(obj): if isinstance(obj, (list, tuple, set)): return True return is_sequence(obj)"
            },
            {
                "url": 2126,
                "code": "def all_strings(arr): if not isinstance([], list): raise TypeError(\"non-list value found where list is expected\") return all(isinstance(x, str) for x in arr)"
            },
            {
                "url": 3787,
                "code": "def _listify(collection): new_list = [] for index in range(len(collection)): new_list.append(collection[index]) return new_list"
            },
            {
                "url": 94,
                "code": "def listlike(obj): return hasattr(obj, \"__iter__\") \\ and not issubclass(type(obj), str)\\ and not issubclass(type(obj), unicode)"
            },
            {
                "url": 5723,
                "code": "def _str_to_list(value, separator): value_list = [item.strip() for item in value.split(separator)] value_list_sanitized = builtins.list(filter(None, value_list)) if len(value_list_sanitized) > 0: return value_list_sanitized else: raise ValueError('Invalid list variable.')"
            },
            {
                "url": 2157,
                "code": "def _get_non_empty_list(cls, iter): res = [] for value in iter: if hasattr(value, 'items'): value = cls._get_non_empty_dict(value) or None if value is not None: res.append(value) return res"
            },
            {
                "url": 192,
                "code": "def _check_elements_equal(lst): assert isinstance(lst, list), \"Input value must be a list.\" return not lst or lst.count(lst[0]) == len(lst)"
            },
            {
                "url": 2303,
                "code": "def check_type_and_size_of_param_list(param_list, expected_length): try: assert isinstance(param_list, list) assert len(param_list) == expected_length except AssertionError: msg = \"param_list must be a list containing {} elements.\" raise ValueError(msg.format(expected_length)) return None"
            },
            {
                "url": 1984,
                "code": "def list_i2str(ilist): slist = [] for el in ilist: slist.append(str(el)) return slist"
            },
            {
                "url": 2332,
                "code": "def validate_string_list(lst): if not isinstance(lst, list): raise ValueError('input %r must be a list' % lst) for x in lst: if not isinstance(x, basestring): raise ValueError('element %r in list must be a string' % x)"
            },
            {
                "url": 4892,
                "code": "def flat_list(input_list): r x = input_list if isinstance(x, list): return [a for i in x for a in flat_list(i)] else: return [x]"
            }
        ],
        "url": 755
    },
    {
        "nl_input": "python determine if a file is image",
        "code_input": [
            {
                "url": 1965,
                "code": "def is_file_url(url): from .misc import to_text if not url: return False if not isinstance(url, six.string_types): try: url = getattr(url, \"url\") except AttributeError: raise ValueError(\"Cannot parse url from unknown type: {0!r}\".format(url)) url = to_text(url, encoding=\"utf-8\") return urllib_parse.urlparse(url.lower()).scheme == \"file\""
            },
            {
                "url": 1636,
                "code": "def is_image(filename): # note: isfile() also accepts symlinks return os.path.isfile(filename) and filename.lower().endswith(ImageExts)"
            },
            {
                "url": 1614,
                "code": "def is_valid_image_extension(file_path): valid_extensions = ['.jpeg', '.jpg', '.gif', '.png'] _, extension = os.path.splitext(file_path) return extension.lower() in valid_extensions"
            },
            {
                "url": 2959,
                "code": "def _file_exists(path, filename): return os.path.isfile(os.path.join(path, filename))"
            },
            {
                "url": 188,
                "code": "def is_image_file_valid(file_path_name): # Image.verify is only implemented for PNG images, and it only verifies # the CRC checksum in the image. The only way to check from within # Pillow is to load the image in a try/except and check the error. If # as much info as possible is from the image is needed, # ``ImageFile.LOAD_TRUNCATED_IMAGES=True`` needs to bet set and it # will attempt to parse as much as possible. try: with Image.open(file_path_name) as image: image.load() except IOError: return False return True"
            },
            {
                "url": 2209,
                "code": "def is_file(path): try: return path.expanduser().absolute().is_file() except AttributeError: return os.path.isfile(os.path.abspath(os.path.expanduser(str(path))))"
            },
            {
                "url": 2784,
                "code": "def IsBinary(self, filename): mimetype = mimetypes.guess_type(filename)[0] if not mimetype: return False # e.g. README, \"real\" binaries usually have an extension # special case for text files which don't start with text/ if mimetype in TEXT_MIMETYPES: return False return not mimetype.startswith(\"text/\")"
            },
            {
                "url": 2931,
                "code": "def is_valid_file(parser, arg): arg = os.path.abspath(arg) if not os.path.exists(arg): parser.error(\"The file %s does not exist!\" % arg) else: return arg"
            },
            {
                "url": 6226,
                "code": "def _is_video(filepath) -> bool: if os.path.exists(filepath): # Could be broken symlink extension = os.path.splitext(filepath)[1] return extension in ('.mkv', '.mp4', '.avi') else: return False"
            },
            {
                "url": 5834,
                "code": "def isfile_notempty(inputfile: str) -> bool: try: return isfile(inputfile) and getsize(inputfile) > 0 except TypeError: raise TypeError('inputfile is not a valid type')"
            },
            {
                "url": 4496,
                "code": "def is_valid_file(parser,arg): if not os.path.exists(arg): parser.error(\"File %s not found\"%arg) else: return arg"
            },
            {
                "url": 2011,
                "code": "def _file_and_exists(val, input_files): return ((os.path.exists(val) and os.path.isfile(val)) or val in input_files)"
            },
            {
                "url": 5533,
                "code": "def is_file_exists_error(e): if six.PY3: return isinstance(e, FileExistsError) # noqa: F821 else: return isinstance(e, OSError) and e.errno == 17"
            },
            {
                "url": 5808,
                "code": "def valid_file(path: str) -> bool: path = Path(path).expanduser() log.debug(\"checking if %s is a valid file\", path) return path.exists() and path.is_file()"
            },
            {
                "url": 4159,
                "code": "def _file_type(self, field): type = mimetypes.guess_type(self._files[field])[0] return type.encode(\"utf-8\") if isinstance(type, unicode) else str(type)"
            }
        ],
        "url": 1636
    },
    {
        "nl_input": "python reorganise a data frame",
        "code_input": [
            {
                "url": 4720,
                "code": "def _preprocess(df): df = df.stack() df.index.rename([\"id\", \"time\"], inplace=True) # .reset_index() df.name = \"value\" df = df.reset_index() return df"
            },
            {
                "url": 2532,
                "code": "def normalize(self): if self.preprocessed_data.empty: data = self.original_data else: data = self.preprocessed_data data = pd.DataFrame(preprocessing.normalize(data), columns=data.columns, index=data.index) self.preprocessed_data = data"
            },
            {
                "url": 1605,
                "code": "def to_dataframe(products): try: import pandas as pd except ImportError: raise ImportError(\"to_dataframe requires the optional dependency Pandas.\") return pd.DataFrame.from_dict(products, orient='index')"
            },
            {
                "url": 2680,
                "code": "def from_df(data_frame): labels = data_frame.keys().tolist() data = data_frame.values.tolist() return SqlTable(labels, data, \"{:.3f}\", \"\\n\")"
            },
            {
                "url": 2333,
                "code": "def clean_df(df, fill_nan=True, drop_empty_columns=True): if fill_nan: df = df.fillna(value=np.nan) if drop_empty_columns: df = df.dropna(axis=1, how='all') return df.sort_index()"
            },
            {
                "url": 1187,
                "code": "def column_stack_2d(data): return list(list(itt.chain.from_iterable(_)) for _ in zip(*data))"
            },
            {
                "url": 1725,
                "code": "def _update_index_on_df(df, index_names): if index_names: df = df.set_index(index_names) # Remove names from unnamed indexes index_names = _denormalize_index_names(index_names) df.index.names = index_names return df"
            },
            {
                "url": 3319,
                "code": "def from_series(cls, series): # TODO: add a 'name' parameter name = series.name df = pd.DataFrame({name: series}) ds = Dataset.from_dataframe(df) return ds[name]"
            },
            {
                "url": 1180,
                "code": "def sort_data(data, cols): return data.sort_values(cols)[cols + ['value']].reset_index(drop=True)"
            },
            {
                "url": 3692,
                "code": "def _possibly_convert_objects(values): return np.asarray(pd.Series(values.ravel())).reshape(values.shape)"
            },
            {
                "url": 1719,
                "code": "def transform(self, df): for name, function in self.outputs: df[name] = function(df)"
            },
            {
                "url": 3552,
                "code": "def as_dict(df, ix=':'): if isinstance(df.index, pd.DatetimeIndex): df['datetime'] = df.index return df.to_dict(orient='records')[ix]"
            },
            {
                "url": 889,
                "code": "def clean_dataframe(df): df = df.fillna(method='ffill') df = df.fillna(0.0) return df"
            },
            {
                "url": 5163,
                "code": "def reindex_axis(self, labels, axis=0, **kwargs): # for compatibility with higher dims if axis != 0: raise ValueError(\"cannot reindex series on non-zero axis!\") msg = (\"'.reindex_axis' is deprecated and will be removed in a future \" \"version. Use '.reindex' instead.\") warnings.warn(msg, FutureWarning, stacklevel=2) return self.reindex(index=labels, **kwargs)"
            },
            {
                "url": 3404,
                "code": "def stackplot(marray, seconds=None, start_time=None, ylabels=None): tarray = np.transpose(marray) stackplot_t(tarray, seconds=seconds, start_time=start_time, ylabels=ylabels) plt.show()"
            }
        ],
        "url": 4720
    },
    {
        "nl_input": "read first line in txt file in python",
        "code_input": [
            {
                "url": 971,
                "code": "def getfirstline(file, default): with open(file, 'rb') as fh: content = fh.readlines() if len(content) == 1: return content[0].decode('utf-8').strip('\\n') return default"
            },
            {
                "url": 4173,
                "code": "def readline( file, skip_blank=False ): while 1: line = file.readline() #print \"every line: %r\" % line if not line: return None if line[0] != '#' and not ( skip_blank and line.isspace() ): return line"
            },
            {
                "url": 712,
                "code": "def txt_line_iterator(path): with tf.gfile.Open(path) as f: for line in f: yield line.strip()"
            },
            {
                "url": 5545,
                "code": "def find_first_in_list(txt: str, str_list: [str]) -> int: # type: ignore start = len(txt) + 1 for item in str_list: if start > txt.find(item) > -1: start = txt.find(item) return start if len(txt) + 1 > start > -1 else -1"
            },
            {
                "url": 3132,
                "code": "def get_list_from_file(file_name): with open(file_name, mode='r', encoding='utf-8') as f1: lst = f1.readlines() return lst"
            },
            {
                "url": 5554,
                "code": "def read_text_from_file(path: str) -> str: with open(path) as text_file: content = text_file.read() return content"
            },
            {
                "url": 1976,
                "code": "def _read_text(self, filename): with io.open(filename, 'rt', encoding='utf-8') as f: return f.read()"
            },
            {
                "url": 970,
                "code": "def read_string_from_file(path, encoding=\"utf8\"): with codecs.open(path, \"rb\", encoding=encoding) as f: value = f.read() return value"
            },
            {
                "url": 5707,
                "code": "def is_line_in_file(filename: str, line: str) -> bool: assert \"\\n\" not in line with open(filename, \"r\") as file: for fileline in file: if fileline == line: return True return False"
            },
            {
                "url": 873,
                "code": "def file_to_str(fname): data = None # rU = read with Universal line terminator with open(fname, 'rU') as fd: data = fd.read() return data"
            },
            {
                "url": 5327,
                "code": "def _find_first_of(line, substrings): starts = ((line.find(i), i) for i in substrings) found = [(i, sub) for i, sub in starts if i != -1] if found: return min(found) else: return -1, None"
            },
            {
                "url": 244,
                "code": "def read_from_file(file_path, encoding=\"utf-8\"): with codecs.open(file_path, \"r\", encoding) as f: return f.read()"
            },
            {
                "url": 5230,
                "code": "def read(self): for line in self.io.read(): with self.parse_line(line) as j: yield j"
            },
            {
                "url": 3184,
                "code": "def str_from_file(path): with open(path) as f: s = f.read().strip() return s"
            },
            {
                "url": 973,
                "code": "def _read_stdin(): line = sys.stdin.readline() while line: yield line line = sys.stdin.readline()"
            }
        ],
        "url": 971
    },
    {
        "nl_input": "pass defined parser object to subparser python",
        "code_input": [
            {
                "url": 2613,
                "code": "def set_subparsers_args(self, *args, **kwargs): self.subparsers_args = args self.subparsers_kwargs = kwargs"
            },
            {
                "url": 3225,
                "code": "def __init__(self): # Root parser self.parser = argparse.ArgumentParser() # Subparsers self.subparsers = self.parser.add_subparsers() # Parser dictionary, to avoir overwriting existing parsers self.parsers = {}"
            },
            {
                "url": 2600,
                "code": "def sub(name, func,**kwarg): sp = subparsers.add_parser(name, **kwarg) sp.set_defaults(func=func) sp.arg = sp.add_argument return sp"
            },
            {
                "url": 6022,
                "code": "def default_parser() -> argparse.ArgumentParser: parser = argparse.ArgumentParser( prog=CONSOLE_SCRIPT, formatter_class=argparse.ArgumentDefaultsHelpFormatter, ) build_parser(parser) return parser"
            },
            {
                "url": 2192,
                "code": "def apply_argument_parser(argumentsParser, options=None): if options is not None: args = argumentsParser.parse_args(options) else: args = argumentsParser.parse_args() return args"
            },
            {
                "url": 1434,
                "code": "def add_to_parser(self, parser): kwargs = self._get_kwargs() args = self._get_args() parser.add_argument(*args, **kwargs)"
            },
            {
                "url": 3283,
                "code": "def parsed_args(): parser = argparse.ArgumentParser(description=, epilog=\"\") parser.add_argument('command',nargs='*', help=\"Name of the function to run with arguments\") args = parser.parse_args() return (args, parser)"
            },
            {
                "url": 3966,
                "code": "def parser(): parser = argparse.ArgumentParser() parser.add_argument('-c', '--config_paths', default=[], action='append', help='path to a configuration directory') return parser"
            },
            {
                "url": 3968,
                "code": "def createArgumentParser(description): parser = argparse.ArgumentParser( description=description, formatter_class=SortedHelpFormatter) return parser"
            },
            {
                "url": 4820,
                "code": "def add_option(self, *args, **kwargs): if self.parseTool == 'argparse': if args and args[0] == '': # no short option args = args[1:] return self.parser.add_argument(*args, **kwargs) else: return self.parser.add_option(*args, **kwargs)"
            },
            {
                "url": 4451,
                "code": "def cli_parse(parser): parser.add_argument('-n', '--samples', type=int, required=True, help='Number of Samples') return parser"
            },
            {
                "url": 345,
                "code": "def main(args=sys.argv): parser = create_optparser(args[0]) return cli(parser.parse_args(args[1:]))"
            },
            {
                "url": 4956,
                "code": "def extend_with(func): if not func.__name__ in ArgParseInator._plugins: ArgParseInator._plugins[func.__name__] = func"
            },
            {
                "url": 4619,
                "code": "def main(pargs): input_file = sys.argv[1] fp = ParseFileLineByLine(input_file) for i in fp: print(i)"
            },
            {
                "url": 4450,
                "code": "def set_default(self, section, option, default): if not self.parser.has_option(section, option): self.parser.set(section, option, default)"
            }
        ],
        "url": 2600
    },
    {
        "nl_input": "how to print generic error in python",
        "code_input": [
            {
                "url": 899,
                "code": "def debug_on_error(type, value, tb): traceback.print_exc(type, value, tb) print() pdb.pm()"
            },
            {
                "url": 1444,
                "code": "def pylog(self, *args, **kwargs): printerr(self.name, args, kwargs, traceback.format_exc())"
            },
            {
                "url": 3811,
                "code": "def print_err(*args, end='\\n'): print(*args, end=end, file=sys.stderr) sys.stderr.flush()"
            },
            {
                "url": 4359,
                "code": "def str_traceback(error, tb): if not isinstance(tb, types.TracebackType): return tb return ''.join(traceback.format_exception(error.__class__, error, tb))"
            },
            {
                "url": 2284,
                "code": "def on_error(e): # pragma: no cover exname = {'RuntimeError': 'Runtime error', 'Value Error': 'Value error'} sys.stderr.write('{}: {}\\n'.format(exname[e.__class__.__name__], str(e))) sys.stderr.write('See file slam_error.log for additional details.\\n') sys.exit(1)"
            },
            {
                "url": 4330,
                "code": "def print_error(msg): if IS_POSIX: print(u\"%s[ERRO] %s%s\" % (ANSI_ERROR, msg, ANSI_END)) else: print(u\"[ERRO] %s\" % (msg))"
            },
            {
                "url": 1778,
                "code": "def log_exception(exc_info=None, stream=None): exc_info = exc_info or sys.exc_info() stream = stream or sys.stderr try: from traceback import print_exception print_exception(exc_info[0], exc_info[1], exc_info[2], None, stream) stream.flush() finally: exc_info = None"
            },
            {
                "url": 1071,
                "code": "def error(*args): if sys.stdin.isatty(): print('ERROR:', *args, file=sys.stderr) else: notify_error(*args)"
            },
            {
                "url": 3557,
                "code": "def reraise(error): if hasattr(error, \"_type_\"): six.reraise(type(error), error, error._traceback) raise error"
            },
            {
                "url": 3780,
                "code": "def on_IOError(self, e): sys.stderr.write(\"Error: %s: \\\"%s\\\"\\n\" % (e.strerror, e.filename))"
            },
            {
                "url": 3782,
                "code": "def error(self, text): self.logger.error(\"{}{}\".format(self.message_prefix, text))"
            },
            {
                "url": 2322,
                "code": "def format_exception(e): from .utils.printing import fill return '\\n'.join(fill(line) for line in traceback.format_exception_only(type(e), e))"
            },
            {
                "url": 5019,
                "code": "def _debug_log(self, msg): if not self.debug: return sys.stderr.write('{}\\n'.format(msg))"
            },
            {
                "url": 924,
                "code": "def print_trace(self): traceback.print_exc() for tb in self.tracebacks: print tb, print ''"
            },
            {
                "url": 3410,
                "code": "def excepthook(self, except_type, exception, traceback): if except_type is DeepReferenceError: print(exception.msg) else: self.default_excepthook(except_type, exception, traceback)"
            }
        ],
        "url": 3811
    },
    {
        "nl_input": "python change the name of a key",
        "code_input": [
            {
                "url": 3836,
                "code": "def normalise_key(self, key): key = key.replace('-', '_') if key.startswith(\"noy_\"): key = key[4:] return key"
            },
            {
                "url": 5955,
                "code": "def camelize(key): return ''.join(x.capitalize() if i > 0 else x for i, x in enumerate(key.split('_')))"
            },
            {
                "url": 3705,
                "code": "def normalize(name): # Name should not contain some specials chars (issue #1068) ret = name.replace(':', '') ret = ret.replace('%', '') ret = ret.replace(' ', '_') return ret"
            },
            {
                "url": 1076,
                "code": "def _get_name(self, key): if key in self.display_names: return self.display_names[key] return key.capitalize()"
            },
            {
                "url": 813,
                "code": "def make_env_key(app_name, key): key = key.replace('-', '_').replace(' ', '_') return str(\"_\".join((x.upper() for x in (app_name, key))))"
            },
            {
                "url": 1602,
                "code": "def unit_key_from_name(name): result = name for old, new in six.iteritems(UNIT_KEY_REPLACEMENTS): result = result.replace(old, new) # Collapse redundant underscores and convert to uppercase. result = re.sub(r'_+', '_', result.upper()) return result"
            },
            {
                "url": 5526,
                "code": "def python(string: str): return underscore(singularize(string) if Naming._pluralize(string) else string)"
            },
            {
                "url": 5340,
                "code": "def _clean_up_name(self, name): for n in self.naughty: name = name.replace(n, '_') return name"
            },
            {
                "url": 1527,
                "code": "def convert_camel_case_to_snake_case(name): s1 = re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', name) return re.sub('([a-z0-9])([A-Z])', r'\\1_\\2', s1).lower()"
            },
            {
                "url": 43,
                "code": "def to_snake_case(name): s1 = FIRST_CAP_REGEX.sub(r'\\1_\\2', name) return ALL_CAP_REGEX.sub(r'\\1_\\2', s1).lower()"
            },
            {
                "url": 6176,
                "code": "def convert_camel_case_string(name: str) -> str: string = re.sub(\"(.)([A-Z][a-z]+)\", r\"\\1_\\2\", name) return re.sub(\"([a-z0-9])([A-Z])\", r\"\\1_\\2\", string).lower()"
            },
            {
                "url": 1807,
                "code": "def camel_to_snake_case(name): pattern = r'[A-Z][a-z]+|[A-Z]+(?![a-z])' return '_'.join(map(str.lower, re.findall(pattern, name)))"
            },
            {
                "url": 4911,
                "code": "def identifierify(name): name = name.lower() name = re.sub('[^a-z0-9]', '_', name) return name"
            },
            {
                "url": 3685,
                "code": "def snake_to_camel(name): ret = \"\".join(x.title() for x in name.split(\"_\")) ret = ret[0].lower() + ret[1:] return ret"
            },
            {
                "url": 2112,
                "code": "def to_camel_case(snake_case_name): bits = snake_case_name.split('_') return ''.join([bit.capitalize() for bit in bits])"
            }
        ],
        "url": 1602
    },
    {
        "nl_input": "moving mouse python click",
        "code_input": [
            {
                "url": 3970,
                "code": "def mouseMoveEvent(self, event): self.declaration.mouse_move_event(event) super(QtGraphicsView, self).mouseMoveEvent(event)"
            },
            {
                "url": 984,
                "code": "def mouse_move_event(self, event): self.example.mouse_position_event(event.x(), event.y())"
            },
            {
                "url": 1082,
                "code": "def mouse_out(self): self.scroll_to() ActionChains(self.parent.driver).move_by_offset(0, 0).click().perform()"
            },
            {
                "url": 4232,
                "code": "def on_mouse_motion(self, x, y, dx, dy): # Screen coordinates relative to the lower-left corner # so we have to flip the y axis to make this consistent with # other window libraries self.example.mouse_position_event(x, self.buffer_height - y)"
            },
            {
                "url": 5654,
                "code": "def mouse_event(dwFlags: int, dx: int, dy: int, dwData: int, dwExtraInfo: int) -> None: ctypes.windll.user32.mouse_event(dwFlags, dx, dy, dwData, dwExtraInfo)"
            },
            {
                "url": 2883,
                "code": "def get_mouse_location(self): x = ctypes.c_int(0) y = ctypes.c_int(0) screen_num = ctypes.c_int(0) _libxdo.xdo_get_mouse_location( self._xdo, ctypes.byref(x), ctypes.byref(y), ctypes.byref(screen_num)) return mouse_location(x.value, y.value, screen_num.value)"
            },
            {
                "url": 1924,
                "code": "def OnMove(self, event): # Store window position in config position = self.main_window.GetScreenPositionTuple() config[\"window_position\"] = repr(position)"
            },
            {
                "url": 4739,
                "code": "def move(self, x, y): self._cursor = self._normalizePoint(x, y)"
            },
            {
                "url": 3715,
                "code": "def mouse_get_pos(): p = POINT() AUTO_IT.AU3_MouseGetPos(ctypes.byref(p)) return p.x, p.y"
            },
            {
                "url": 3024,
                "code": "def buttonUp(self, button=mouse.LEFT): self._lock.acquire() mouse.release(button) self._lock.release()"
            },
            {
                "url": 4664,
                "code": "def wheel(delta=1): location = get_position() e = Quartz.CGEventCreateMouseEvent( None, Quartz.kCGEventScrollWheel, location, Quartz.kCGMouseButtonLeft) e2 = Quartz.CGEventCreateScrollWheelEvent( None, Quartz.kCGScrollEventUnitLine, 1, delta) Quartz.CGEventPost(Quartz.kCGHIDEventTap, e) Quartz.CGEventPost(Quartz.kCGHIDEventTap, e2)"
            },
            {
                "url": 2473,
                "code": "def onLeftDown(self, event=None): if event is None: return self.cursor_mode_action('leftdown', event=event) self.ForwardEvent(event=event.guiEvent)"
            },
            {
                "url": 4209,
                "code": "def OnDoubleClick(self, event): node = HotMapNavigator.findNodeAtPosition(self.hot_map, event.GetPosition()) if node: wx.PostEvent( self, SquareActivationEvent( node=node, point=event.GetPosition(), map=self ) )"
            },
            {
                "url": 3042,
                "code": "def is_clicked(self, MouseStateType): return self.previous_mouse_state.query_state(MouseStateType) and ( not self.current_mouse_state.query_state(MouseStateType))"
            },
            {
                "url": 363,
                "code": "def move_to(self, ypos, xpos): # the screen's co-ordinates are 1 based, but the command is 0 based xpos -= 1 ypos -= 1 self.exec_command(\"MoveCursor({0}, {1})\".format(ypos, xpos).encode(\"ascii\"))"
            }
        ],
        "url": 984
    },
    {
        "nl_input": "python to determine if services are running",
        "code_input": [
            {
                "url": 235,
                "code": "def service_available(service_name): try: subprocess.check_output( ['service', service_name, 'status'], stderr=subprocess.STDOUT).decode('UTF-8') except subprocess.CalledProcessError as e: return b'unrecognized service' not in e.output else: return True"
            },
            {
                "url": 5720,
                "code": "def is_running(process_id: int) -> bool: pstr = str(process_id) encoding = sys.getdefaultencoding() s = subprocess.Popen([\"ps\", \"-p\", pstr], stdout=subprocess.PIPE) for line in s.stdout: strline = line.decode(encoding) if pstr in strline: return True return False"
            },
            {
                "url": 3595,
                "code": "def is_running(self): return self.state in [self.STATE_IDLE, self.STATE_ACTIVE, self.STATE_SLEEPING]"
            },
            {
                "url": 1032,
                "code": "def is_http_running_on(port): try: conn = httplib.HTTPConnection('127.0.0.1:' + str(port)) conn.connect() conn.close() return True except Exception: return False"
            },
            {
                "url": 114,
                "code": "def check_output(args, env=None, sp=subprocess): log.debug('calling %s with env %s', args, env) output = sp.check_output(args=args, env=env) log.debug('output: %r', output) return output"
            },
            {
                "url": 3784,
                "code": "def register_service(self, service): if service not in self.services: self.services.append(service)"
            },
            {
                "url": 5138,
                "code": "def get_services(): with win32.OpenSCManager( dwDesiredAccess = win32.SC_MANAGER_ENUMERATE_SERVICE ) as hSCManager: try: return win32.EnumServicesStatusEx(hSCManager) except AttributeError: return win32.EnumServicesStatus(hSCManager)"
            },
            {
                "url": 5671,
                "code": "def SvcStop(self) -> None: # tell the SCM we're shutting down # noinspection PyUnresolvedReferences self.ReportServiceStatus(win32service.SERVICE_STOP_PENDING) # fire the stop event win32event.SetEvent(self.h_stop_event)"
            },
            {
                "url": 239,
                "code": "def _pip_exists(self): return os.path.isfile(os.path.join(self.path, 'bin', 'pip'))"
            },
            {
                "url": 2448,
                "code": "def start(self): if not self._is_running: self._do_run = True self._thread.start() return self"
            },
            {
                "url": 3036,
                "code": "def server(port): args = ['python', 'manage.py', 'runserver'] if port: args.append(port) run.main(args)"
            },
            {
                "url": 3332,
                "code": "def run(self): LOGGER.debug(\"rabbitmq.Service.run\") try: self.channel.start_consuming() except Exception as e: LOGGER.warn(\"rabbitmq.Service.run - Exception raised while consuming\")"
            },
            {
                "url": 528,
                "code": "def pid_exists(pid): try: os.kill(pid, 0) except OSError as exc: return exc.errno == errno.EPERM else: return True"
            },
            {
                "url": 1891,
                "code": "def check_output(args): log.debug('run: %s', args) out = subprocess.check_output(args=args).decode('utf-8') log.debug('out: %r', out) return out"
            },
            {
                "url": 3493,
                "code": "def check_dependencies_remote(args): cmd = [args.python, '-m', 'depends', args.requirement] env = dict(PYTHONPATH=os.path.dirname(__file__)) return subprocess.check_call(cmd, env=env)"
            }
        ],
        "url": 235
    },
    {
        "nl_input": "python set contains multiple items",
        "code_input": [
            {
                "url": 5830,
                "code": "def pset(iterable=(), pre_size=8): if not iterable: return _EMPTY_PSET return PSet._from_iterable(iterable, pre_size=pre_size)"
            },
            {
                "url": 5848,
                "code": "def dict_of_sets_add(dictionary, key, value): # type: (DictUpperBound, Any, Any) -> None set_objs = dictionary.get(key, set()) set_objs.add(value) dictionary[key] = set_objs"
            },
            {
                "url": 2435,
                "code": "def __eq__(self, anotherset): if not isinstance(anotherset, LR0ItemSet): raise TypeError if len(self.itemlist) != len(anotherset.itemlist): return False for element in self.itemlist: if element not in anotherset.itemlist: return False return True"
            },
            {
                "url": 6019,
                "code": "def issuperset(self, items): return all(_compat.map(self._seen.__contains__, items))"
            },
            {
                "url": 278,
                "code": "def remove_duplicates(lst): dset = set() return [l for l in lst if l not in dset and not dset.add(l)]"
            },
            {
                "url": 2626,
                "code": "def add(self, value): if value not in self._set: self._set.add(value) self._list.add(value)"
            },
            {
                "url": 230,
                "code": "def issuperset(self, other): self._binary_sanity_check(other) return set.issuperset(self, other)"
            },
            {
                "url": 2351,
                "code": "def is_set(self, key): data = self.model.get_data() return isinstance(data[key], set)"
            },
            {
                "url": 1757,
                "code": "def items(iterable): if hasattr(iterable, 'iteritems'): return (p for p in iterable.iteritems()) elif hasattr(iterable, 'items'): return (p for p in iterable.items()) else: return (p for p in enumerate(iterable))"
            },
            {
                "url": 5611,
                "code": "def read_set_from_file(filename: str) -> Set[str]: collection = set() with open(filename, 'r') as file_: for line in file_: collection.add(line.rstrip()) return collection"
            },
            {
                "url": 3951,
                "code": "def _get_set(self, key, operation, create=False): return self._get_by_type(key, operation, create, b'set', set())"
            },
            {
                "url": 339,
                "code": "def _init_unique_sets(self): ks = dict() for t in self._unique_checks: key = t[0] ks[key] = set() # empty set return ks"
            },
            {
                "url": 4591,
                "code": "def unique(iterable): seen = set() for item in iterable: if item not in seen: seen.add(item) yield item"
            },
            {
                "url": 392,
                "code": "def _split_comma_separated(string): return set(text.strip() for text in string.split(',') if text.strip())"
            },
            {
                "url": 6020,
                "code": "def union(cls, *sets): import utool as ut lists_ = ut.flatten([list(s) for s in sets]) return cls(lists_)"
            }
        ],
        "url": 6019
    },
    {
        "nl_input": "python protobyf parse from byte",
        "code_input": [
            {
                "url": 1059,
                "code": "def _dict_to_proto(py_dict, proto): dict_json_str = json.dumps(py_dict) return json_format.Parse(dict_json_str, proto)"
            },
            {
                "url": 1333,
                "code": "def AsPrimitiveProto(self): if self.protobuf: result = self.protobuf() result.ParseFromString(self.SerializeToString()) return result"
            },
            {
                "url": 1343,
                "code": "def from_pb(cls, pb): obj = cls._from_pb(pb) obj._pb = pb return obj"
            },
            {
                "url": 3722,
                "code": "def read_proto_object(fobj, klass): log.debug('%s chunk', klass.__name__) obj = klass() obj.ParseFromString(read_block(fobj)) log.debug('Header: %s', str(obj)) return obj"
            },
            {
                "url": 2465,
                "code": "def toJson(protoObject, indent=None): # Using the internal method because this way we can reformat the JSON js = json_format.MessageToDict(protoObject, False) return json.dumps(js, indent=indent)"
            },
            {
                "url": 2695,
                "code": "def parse(self, data, mimetype): encoding = mimetype.params.get('charset') or 'utf-8' return json.loads(data.decode(encoding))"
            },
            {
                "url": 3476,
                "code": "def be_array_from_bytes(fmt, data): arr = array.array(str(fmt), data) return fix_byteorder(arr)"
            },
            {
                "url": 1379,
                "code": "def loadb(b): assert isinstance(b, (bytes, bytearray)) return std_json.loads(b.decode('utf-8'))"
            },
            {
                "url": 5882,
                "code": "def decode(self, bytes, raw=False): return struct.unpack(self.format, buffer(bytes))[0]"
            },
            {
                "url": 3326,
                "code": "def bytes_to_str(s, encoding='utf-8'): if six.PY3 and isinstance(s, bytes): return s.decode(encoding) return s"
            },
            {
                "url": 1328,
                "code": "def b2u(string): if (isinstance(string, bytes) or (PY2 and isinstance(string, str))): return string.decode('utf-8') return string"
            },
            {
                "url": 5701,
                "code": "def convert_bytes_to_ints(in_bytes, num): dt = numpy.dtype('>i' + str(num)) return numpy.frombuffer(in_bytes, dt)"
            },
            {
                "url": 2054,
                "code": "def load(raw_bytes): try: if not isinstance(raw_bytes, string_type): raw_bytes = raw_bytes.decode() return json.loads(raw_bytes) except ValueError as e: raise SerializationException(str(e))"
            },
            {
                "url": 5925,
                "code": "def decodebytes(input): py_version = sys.version_info[0] if py_version >= 3: return _decodebytes_py3(input) return _decodebytes_py2(input)"
            },
            {
                "url": 3413,
                "code": "def to_bytes(s, encoding=\"utf-8\"): if isinstance(s, six.binary_type): return s if six.PY3: return bytes(s, encoding) return s.encode(encoding)"
            }
        ],
        "url": 5882
    },
    {
        "nl_input": "python check if a directory is writable",
        "code_input": [
            {
                "url": 651,
                "code": "def _writable_dir(path): return os.path.isdir(path) and os.access(path, os.W_OK)"
            },
            {
                "url": 1644,
                "code": "def is_readable_dir(path): return os.path.isdir(path) and os.access(path, os.R_OK) and os.access(path, os.X_OK)"
            },
            {
                "url": 2176,
                "code": "def ensure_dir_exists(directory): if directory and not os.path.exists(directory): os.makedirs(directory)"
            },
            {
                "url": 1598,
                "code": "def check_create_folder(filename): os.makedirs(os.path.dirname(filename), exist_ok=True)"
            },
            {
                "url": 1255,
                "code": "def make_directory(path): if not os.path.exists(path): # concurrent writes that try to create the same dir can fail try: os.makedirs(path) except OSError as e: if e.errno == errno.EEXIST: pass else: raise e"
            },
            {
                "url": 653,
                "code": "def isdir(path, **kwargs): import os.path return os.path.isdir(path, **kwargs)"
            },
            {
                "url": 3678,
                "code": "def ensure_dir(f): d = os.path.dirname(f) if not os.path.exists(d): os.makedirs(d)"
            },
            {
                "url": 3430,
                "code": "def isdir(s): try: st = os.stat(s) except os.error: return False return stat.S_ISDIR(st.st_mode)"
            },
            {
                "url": 2445,
                "code": "def is_readable(filename): return os.path.isfile(filename) and os.access(filename, os.R_OK)"
            },
            {
                "url": 3186,
                "code": "def is_writable_by_others(filename): mode = os.stat(filename)[stat.ST_MODE] return mode & stat.S_IWOTH"
            },
            {
                "url": 807,
                "code": "def makedirs(path, mode=0o777, exist_ok=False): os.makedirs(path, mode, exist_ok)"
            },
            {
                "url": 4492,
                "code": "def readable(path): try: st = os.stat(path) return 0 != st.st_mode & READABLE_MASK except os.error: return None return True"
            },
            {
                "url": 2939,
                "code": "def is_executable(path): return os.path.isfile(path) and os.access(path, os.X_OK)"
            },
            {
                "url": 3817,
                "code": "def safe_mkdir_for(path, clean=False): safe_mkdir(os.path.dirname(path), clean=clean)"
            },
            {
                "url": 3432,
                "code": "def make_writeable(filename): if not os.access(filename, os.W_OK): st = os.stat(filename) new_permissions = stat.S_IMODE(st.st_mode) | stat.S_IWUSR os.chmod(filename, new_permissions)"
            }
        ],
        "url": 651
    },
    {
        "nl_input": "object as list python",
        "code_input": [
            {
                "url": 5832,
                "code": "def __as_list(value: List[JsonObjTypes]) -> List[JsonTypes]: return [e._as_dict if isinstance(e, JsonObj) else e for e in value]"
            },
            {
                "url": 1837,
                "code": "def to_list(var): if var is None: return [] if isinstance(var, str): var = var.split('\\n') elif not isinstance(var, list): try: var = list(var) except TypeError: raise ValueError(\"{} cannot be converted to the list.\".format(var)) return var"
            },
            {
                "url": 633,
                "code": "def as_list(self): return [self.name, self.value, [x.as_list for x in self.children]]"
            },
            {
                "url": 5723,
                "code": "def _str_to_list(value, separator): value_list = [item.strip() for item in value.split(separator)] value_list_sanitized = builtins.list(filter(None, value_list)) if len(value_list_sanitized) > 0: return value_list_sanitized else: raise ValueError('Invalid list variable.')"
            },
            {
                "url": 3411,
                "code": "def toList(variable, types=(basestring, int, float, )): if isinstance(variable, types): return [variable] else: return variable"
            },
            {
                "url": 5549,
                "code": "def listify(a): if a is None: return [] elif not isinstance(a, (tuple, list, np.ndarray)): return [a] return list(a)"
            },
            {
                "url": 3786,
                "code": "def as_list(callable): @wraps(callable) def wrapper(value_iter): return [callable(value) for value in value_iter] return wrapper"
            },
            {
                "url": 6037,
                "code": "def ensure_list(iterable: Iterable[A]) -> List[A]: if isinstance(iterable, list): return iterable else: return list(iterable)"
            },
            {
                "url": 3000,
                "code": "def parse_list(cls, api, json_list): results = [] for json_obj in json_list: if json_obj: obj = cls.parse(api, json_obj) results.append(obj) return results"
            },
            {
                "url": 5769,
                "code": "def encode_list(key, list_): # type: (str, Iterable) -> Dict[str, str] if not list_: return {} return {key: \" \".join(str(i) for i in list_)}"
            },
            {
                "url": 2466,
                "code": "def toListInt(value): if TypeConverters._can_convert_to_list(value): value = TypeConverters.toList(value) if all(map(lambda v: TypeConverters._is_integer(v), value)): return [int(v) for v in value] raise TypeError(\"Could not convert %s to list of ints\" % value)"
            },
            {
                "url": 1420,
                "code": "def _format_list(result): if not result: return result if isinstance(result[0], dict): return _format_list_objects(result) table = Table(['value']) for item in result: table.add_row([iter_to_table(item)]) return table"
            },
            {
                "url": 5700,
                "code": "def list_to_str(list, separator=','): list = [str(x) for x in list] return separator.join(list)"
            },
            {
                "url": 94,
                "code": "def listlike(obj): return hasattr(obj, \"__iter__\") \\ and not issubclass(type(obj), str)\\ and not issubclass(type(obj), unicode)"
            },
            {
                "url": 660,
                "code": "def as_tuple(self, value): if isinstance(value, list): value = tuple(value) return value"
            }
        ],
        "url": 633
    },
    {
        "nl_input": "replace function nan python",
        "code_input": [
            {
                "url": 1025,
                "code": "def _replace_nan(a, val): mask = isnull(a) return where_method(val, mask, a), mask"
            },
            {
                "url": 5607,
                "code": "def remove_nans_1D(*args) -> tuple: vals = np.isnan(args[0]) for a in args: vals |= np.isnan(a) return tuple(np.array(a)[~vals] for a in args)"
            },
            {
                "url": 4722,
                "code": "def fillna(series_or_arr, missing_value=0.0): if pandas.notnull(missing_value): if isinstance(series_or_arr, (numpy.ndarray)): series_or_arr[numpy.isnan(series_or_arr)] = missing_value else: series_or_arr.fillna(missing_value, inplace=True) return series_or_arr"
            },
            {
                "url": 621,
                "code": "def reduce_fn(x): values = x.values if pd and isinstance(x, pd.Series) else x for v in values: if not is_nan(v): return v return np.NaN"
            },
            {
                "url": 292,
                "code": "def _maybe_fill(arr, fill_value=np.nan): if _isna_compat(arr, fill_value): arr.fill(fill_value) return arr"
            },
            {
                "url": 1801,
                "code": "def fill_nulls(self, col: str): n = [None, \"\"] try: self.df[col] = self.df[col].replace(n, nan) except Exception as e: self.err(e)"
            },
            {
                "url": 6165,
                "code": "def fix_missing(df, col, name, na_dict): if is_numeric_dtype(col): if pd.isnull(col).sum() or (name in na_dict): df[name+'_na'] = pd.isnull(col) filler = na_dict[name] if name in na_dict else col.median() df[name] = col.fillna(filler) na_dict[name] = filler return na_dict"
            },
            {
                "url": 3194,
                "code": "def na_if(series, *values): series = pd.Series(series) series[series.isin(values)] = np.nan return series"
            },
            {
                "url": 5888,
                "code": "def warn_if_nans_exist(X): null_count = count_rows_with_nans(X) total = len(X) percent = 100 * null_count / total if null_count > 0: warning_message = \\ 'Warning! Found {} rows of {} ({:0.2f}%) with nan values. Only ' \\ 'complete rows will be plotted.'.format(null_count, total, percent) warnings.warn(warning_message, DataWarning)"
            },
            {
                "url": 2964,
                "code": "def _replace_none(self, aDict): for k, v in aDict.items(): if v is None: aDict[k] = 'none'"
            },
            {
                "url": 2999,
                "code": "def set_float(val): out = None if not val in (None, ''): try: out = float(val) except ValueError: return None if numpy.isnan(out): out = default return out"
            },
            {
                "url": 1742,
                "code": "def var(series): if np.issubdtype(series.dtype, np.number): return series.var() else: return np.nan"
            },
            {
                "url": 5399,
                "code": "def table_nan_locs(table): ans = [] for rownum, row in enumerate(table): try: if pd.isnull(row).any(): colnums = pd.isnull(row).nonzero()[0] ans += [(rownum, colnum) for colnum in colnums] except AttributeError: # table is really just a sequence of scalars if pd.isnull(row): ans += [(rownum, 0)] return ans"
            },
            {
                "url": 2842,
                "code": "def replace_nones(dict_or_list): def replace_none_in_value(value): if isinstance(value, basestring) and value.lower() == \"none\": return None return value items = dict_or_list.iteritems() if isinstance(dict_or_list, dict) else enumerate(dict_or_list) for accessor, value in items: if isinstance(value, (dict, list)): replace_nones(value) else: dict_or_list[accessor] = replace_none_in_value(value)"
            },
            {
                "url": 3579,
                "code": "def _force_float(v): try: return float(v) except Exception as exc: return float('nan') logger.warning('Failed to convert {} to float with {} error. Using 0 instead.'.format(v, exc))"
            }
        ],
        "url": 1025
    },
    {
        "nl_input": "python hash table check if key exist",
        "code_input": [
            {
                "url": 4072,
                "code": "def check_hash_key(query_on, key): return ( isinstance(key, BaseCondition) and (key.operation == \"==\") and (key.column is query_on.hash_key) )"
            },
            {
                "url": 5872,
                "code": "def check_key(self, key: str) -> bool: keys = self.get_keys() return key in keys"
            },
            {
                "url": 163,
                "code": "def __contains__(self, key): k = self._real_key(key) return k in self._data"
            },
            {
                "url": 3777,
                "code": "def __contains__(self, key): pickled_key = self._pickle_key(key) return bool(self.redis.hexists(self.key, pickled_key))"
            },
            {
                "url": 6110,
                "code": "def index_exists(self, table: str, indexname: str) -> bool: # MySQL: sql = (\"SELECT COUNT(*) FROM information_schema.statistics\" \" WHERE table_name=? AND index_name=?\") row = self.fetchone(sql, table, indexname) return True if row[0] >= 1 else False"
            },
            {
                "url": 2688,
                "code": "def _tableExists(self, tableName): cursor=_conn.execute(.format(tableName)) exists = cursor.fetchone() is not None cursor.close() return exists"
            },
            {
                "url": 4147,
                "code": "def check_if_branch_exist(db, root_hash, key_prefix): validate_is_bytes(key_prefix) return _check_if_branch_exist(db, root_hash, encode_to_bin(key_prefix))"
            },
            {
                "url": 5574,
                "code": "def has_key(cls, *args): key = args if len(args) > 1 else args[0] return key in cls._instances"
            },
            {
                "url": 5106,
                "code": "def table_exists(cursor, tablename, schema='public'): query = cursor.execute(query, (schema, tablename)) res = cursor.fetchone()[0] return res"
            },
            {
                "url": 2392,
                "code": "def __contains__ (self, key): assert isinstance(key, basestring) return dict.__contains__(self, key.lower())"
            },
            {
                "url": 4001,
                "code": "def _check_key(self, key): if not len(key) == 2: raise TypeError('invalid key: %r' % key) elif key[1] not in TYPES: raise TypeError('invalid datatype: %s' % key[1])"
            },
            {
                "url": 1586,
                "code": "def check_attribute_exists(instance): attributes = instance.get('attributes', {}).keys() if instance.get('key_attribute') not in attributes: return False label_attr = instance.get('label_attribute') if label_attr and label_attr not in attributes: return False return True"
            },
            {
                "url": 1628,
                "code": "def table_exists(self, table): if not self.dataset_exists(table.dataset): return False try: self.client.tables().get(projectId=table.project_id, datasetId=table.dataset_id, tableId=table.table_id).execute() except http.HttpError as ex: if ex.resp.status == 404: return False raise return True"
            },
            {
                "url": 5210,
                "code": "def _check_valid(key, val, valid): if val not in valid: raise ValueError('%s must be one of %s, not \"%s\"' % (key, valid, val))"
            },
            {
                "url": 4491,
                "code": "def exists(self): resp = self.r_session.head(self.database_url) if resp.status_code not in [200, 404]: resp.raise_for_status() return resp.status_code == 200"
            }
        ],
        "url": 5872
    },
    {
        "nl_input": "take all points in box python",
        "code_input": [
            {
                "url": 5215,
                "code": "def point8_to_box(points): p = points.reshape((-1, 4, 2)) minxy = p.min(axis=1) # nx2 maxxy = p.max(axis=1) # nx2 return np.concatenate((minxy, maxxy), axis=1)"
            },
            {
                "url": 1735,
                "code": "def bounding_box_from(points, i, i1, thr): pi = points[i] pi1 = points[i1] min_lat = min(pi.lat, pi1.lat) min_lon = min(pi.lon, pi1.lon) max_lat = max(pi.lat, pi1.lat) max_lon = max(pi.lon, pi1.lon) return min_lat-thr, min_lon-thr, max_lat+thr, max_lon+thr"
            },
            {
                "url": 347,
                "code": "def from_points(cls, list_of_lists): result = [] for l in list_of_lists: curve = [] for point in l: curve.append((point.lon, point.lat)) result.append(curve) return Polygon(result)"
            },
            {
                "url": 3642,
                "code": "def bounding_box(img): r locations = numpy.argwhere(img) mins = locations.min(0) maxs = locations.max(0) + 1 return [slice(x, y) for x, y in zip(mins, maxs)]"
            },
            {
                "url": 2402,
                "code": "def calculate_bounding_box(data): mins = data.min(0) maxes = data.max(0) return mins, maxes"
            },
            {
                "url": 4471,
                "code": "def polygon_from_points(points): polygon = [] for pair in points.split(\" \"): x_y = pair.split(\",\") polygon.append([float(x_y[0]), float(x_y[1])]) return polygon"
            },
            {
                "url": 935,
                "code": "def _get_points(self): return tuple([self._getitem__points(i) for i in range(self._len__points())])"
            },
            {
                "url": 223,
                "code": "def from_rectangle(box): x = box.left + box.width * random.uniform(0, 1) y = box.bottom + box.height * random.uniform(0, 1) return Vector(x, y)"
            },
            {
                "url": 4984,
                "code": "def get_points(self): return [(k, self.runtime._ring[k]) for k in self.runtime._keys]"
            },
            {
                "url": 140,
                "code": "def _interval_to_bound_points(array): array_boundaries = np.array([x.left for x in array]) array_boundaries = np.concatenate( (array_boundaries, np.array([array[-1].right]))) return array_boundaries"
            },
            {
                "url": 3668,
                "code": "def adjust_bounding_box(bbox): for i in range(0, 4): if i in bounding_box: bbox[i] = bounding_box[i] else: bbox[i] += delta_bounding_box[i] return bbox"
            },
            {
                "url": 4550,
                "code": "def boxes_intersect(box1, box2): xmin1, xmax1, ymin1, ymax1 = box1 xmin2, xmax2, ymin2, ymax2 = box2 if interval_intersection_width(xmin1, xmax1, xmin2, xmax2) and \\ interval_intersection_width(ymin1, ymax1, ymin2, ymax2): return True else: return False"
            },
            {
                "url": 1980,
                "code": "def search_overlap(self, point_list): result = set() for j in point_list: self.search_point(j, result) return result"
            },
            {
                "url": 4743,
                "code": "def parsePoint(line): values = [float(s) for s in line.split(' ')] if values[0] == -1: # Convert -1 labels to 0 for MLlib values[0] = 0 return LabeledPoint(values[0], values[1:])"
            },
            {
                "url": 1219,
                "code": "def filter_none(list_of_points): remove_elementnone = filter(lambda p: p is not None, list_of_points) remove_sublistnone = filter(lambda p: not contains_none(p), remove_elementnone) return list(remove_sublistnone)"
            }
        ],
        "url": 5215
    },
    {
        "nl_input": "python create enum by name",
        "code_input": [
            {
                "url": 4091,
                "code": "def get_enum_from_name(self, enum_name): return next((e for e in self.enums if e.name == enum_name), None)"
            },
            {
                "url": 5688,
                "code": "def dict_to_enum_fn(d: Dict[str, Any], enum_class: Type[Enum]) -> Enum: return enum_class[d['name']]"
            },
            {
                "url": 471,
                "code": "def EnumValueName(self, enum, value): return self.enum_types_by_name[enum].values_by_number[value].name"
            },
            {
                "url": 5679,
                "code": "def __init__(self, enum_obj: Any) -> None: if enum_obj: self.name = enum_obj self.items = ', '.join([str(i) for i in enum_obj]) else: self.items = ''"
            },
            {
                "url": 2916,
                "code": "def Value(self, name): if name in self._enum_type.values_by_name: return self._enum_type.values_by_name[name].number raise ValueError('Enum %s has no value defined for name %s' % ( self._enum_type.name, name))"
            },
            {
                "url": 1772,
                "code": "def unpack_out(self, name): return self.parse(, enum_class=self._import_type(), value=name)[\"enum\"]"
            },
            {
                "url": 2146,
                "code": "def _Enum(docstring, *names): enums = dict(zip(names, range(len(names)))) reverse = dict((value, key) for key, value in enums.iteritems()) enums['reverse_mapping'] = reverse enums['__doc__'] = docstring return type('Enum', (object,), enums)"
            },
            {
                "url": 569,
                "code": "def to_python(self, value): if value is None: return value if isinstance(value, self.enum): return value return self.enum[value]"
            },
            {
                "url": 2804,
                "code": "def from_string(cls, string): # find enum value for attr in dir(cls): value = getattr(cls, attr) if value == string: return value # if not found, log warning and return the value passed in logger.warning(\"{} is not a valid enum value for {}.\".format(string, cls.__name__)) return string"
            },
            {
                "url": 3981,
                "code": "def __init__(self, enumtype, index, key): self._enumtype = enumtype self._index = index self._key = key"
            },
            {
                "url": 246,
                "code": "def describe_enum_value(enum_value): enum_value_descriptor = EnumValueDescriptor() enum_value_descriptor.name = six.text_type(enum_value.name) enum_value_descriptor.number = enum_value.number return enum_value_descriptor"
            },
            {
                "url": 4012,
                "code": "def _lookup_enum_in_ns(namespace, value): for attribute in dir(namespace): if getattr(namespace, attribute) == value: return attribute"
            },
            {
                "url": 4090,
                "code": "def _dump_enum(self, e, top=''): self._print() self._print('enum {} {{'.format(e.name)) self.defines.append('{}.{}'.format(top,e.name)) self.tabs+=1 for v in e.value: self._print('{} = {};'.format(v.name, v.number)) self.tabs-=1 self._print('}')"
            },
            {
                "url": 2988,
                "code": "def getEventTypeNameFromEnum(self, eType): fn = self.function_table.getEventTypeNameFromEnum result = fn(eType) return result"
            },
            {
                "url": 248,
                "code": "def items(self): return [(value_descriptor.name, value_descriptor.number) for value_descriptor in self._enum_type.values]"
            }
        ],
        "url": 4091
    },
    {
        "nl_input": "python matplotlib use arrow markers",
        "code_input": [
            {
                "url": 3302,
                "code": "def add_arrow(self, x1, y1, x2, y2, **kws): self.panel.add_arrow(x1, y1, x2, y2, **kws)"
            },
            {
                "url": 788,
                "code": "def clear_matplotlib_ticks(self, axis=\"both\"): ax = self.get_axes() plotting.clear_matplotlib_ticks(ax=ax, axis=axis)"
            },
            {
                "url": 944,
                "code": "def show_xticklabels(self, row, column): subplot = self.get_subplot_at(row, column) subplot.show_xticklabels()"
            },
            {
                "url": 1352,
                "code": "def add_plot(x, y, xl, yl, fig, ax, LATEX=False, linestyle=None, **kwargs): if LATEX: xl_data = xl[1] # NOQA yl_data = yl[1] else: xl_data = xl[0] # NOQA yl_data = yl[0] for idx in range(len(y)): ax.plot(x, y[idx], label=yl_data[idx], linestyle=linestyle) ax.legend(loc='upper right') ax.set_ylim(auto=True)"
            },
            {
                "url": 3693,
                "code": "def plot3d_init(fignum): from mpl_toolkits.mplot3d import Axes3D fig = plt.figure(fignum) ax = fig.add_subplot(111, projection='3d') return ax"
            },
            {
                "url": 1311,
                "code": "def finish_plot(): plt.legend() plt.grid(color='0.7') plt.xlabel('x') plt.ylabel('y') plt.show()"
            },
            {
                "url": 5697,
                "code": "def impose_legend_limit(limit=30, axes=\"gca\", **kwargs): if axes==\"gca\": axes = _pylab.gca() # make these axes current _pylab.axes(axes) # loop over all the lines_pylab. for n in range(0,len(axes.lines)): if n > limit-1 and not n==len(axes.lines)-1: axes.lines[n].set_label(\"_nolegend_\") if n == limit-1 and not n==len(axes.lines)-1: axes.lines[n].set_label(\"...\") _pylab.legend(**kwargs)"
            },
            {
                "url": 5262,
                "code": "def activate_subplot(numPlot): # see http://www.mail-archive.com/matplotlib-users@lists.sourceforge.net/msg07156.html from pylab import gcf, axes numPlot -= 1 # index is 0-based, plots are 1-based return axes(gcf().get_axes()[numPlot])"
            },
            {
                "url": 2426,
                "code": "def show_yticklabels(self, row, column): subplot = self.get_subplot_at(row, column) subplot.show_yticklabels()"
            },
            {
                "url": 2272,
                "code": "def remove_legend(ax=None): from pylab import gca, draw if ax is None: ax = gca() ax.legend_ = None draw()"
            },
            {
                "url": 2330,
                "code": "def plot_and_save(self, **kwargs): self.fig = pyplot.figure() self.plot() self.axes = pyplot.gca() self.save_plot(self.fig, self.axes, **kwargs) pyplot.close(self.fig)"
            },
            {
                "url": 1376,
                "code": "def add_matplotlib_cmap(cm, name=None): global cmaps cmap = matplotlib_to_ginga_cmap(cm, name=name) cmaps[cmap.name] = cmap"
            },
            {
                "url": 1067,
                "code": "def add_text(text, x=0.01, y=0.01, axes=\"gca\", draw=True, **kwargs): if axes==\"gca\": axes = _pylab.gca() axes.text(x, y, text, transform=axes.transAxes, **kwargs) if draw: _pylab.draw()"
            },
            {
                "url": 367,
                "code": "def scatter(self, *args, **kwargs): cls = _make_class(ScatterVisual, _default_marker=kwargs.pop('marker', None), ) return self._add_item(cls, *args, **kwargs)"
            },
            {
                "url": 3735,
                "code": "def oplot(self, x, y, **kw): self.panel.oplot(x, y, **kw)"
            }
        ],
        "url": 3302
    },
    {
        "nl_input": "python function default args",
        "code_input": [
            {
                "url": 1432,
                "code": "def arg_default(*args, **kwargs): parser = argparse.ArgumentParser() parser.add_argument(*args, **kwargs) args = vars(parser.parse_args([])) _, default = args.popitem() return default"
            },
            {
                "url": 139,
                "code": "def get_default_args(func): args, varargs, keywords, defaults = getargspec_no_self(func) return dict(zip(args[-len(defaults):], defaults))"
            },
            {
                "url": 4452,
                "code": "def args_update(self): for key, value in self._config_data.items(): setattr(self._default_args, key, value)"
            },
            {
                "url": 6022,
                "code": "def default_parser() -> argparse.ArgumentParser: parser = argparse.ArgumentParser( prog=CONSOLE_SCRIPT, formatter_class=argparse.ArgumentDefaultsHelpFormatter, ) build_parser(parser) return parser"
            },
            {
                "url": 3284,
                "code": "def _correct_args(func, kwargs): args = inspect.getargspec(func)[0] return [kwargs[arg] for arg in args] + kwargs['__args']"
            },
            {
                "url": 3954,
                "code": "def get_args(method_or_func): try: # Python 3.0+ args = list(inspect.signature(method_or_func).parameters.keys()) except AttributeError: # Python 2.7 args = inspect.getargspec(method_or_func).args return args"
            },
            {
                "url": 2192,
                "code": "def apply_argument_parser(argumentsParser, options=None): if options is not None: args = argumentsParser.parse_args(options) else: args = argumentsParser.parse_args() return args"
            },
            {
                "url": 2846,
                "code": "def arguments_as_dict(cls, *args, **kwargs): all_args = (None, ) + args return inspect.getcallargs(cls.run, *all_args, **kwargs)"
            },
            {
                "url": 3233,
                "code": "def validate_args(**args): if not args['query']: print(\"\\nMissing required query argument.\") sys.exit() for key in DEFAULTS: if key not in args: args[key] = DEFAULTS[key] return args"
            },
            {
                "url": 3283,
                "code": "def parsed_args(): parser = argparse.ArgumentParser(description=, epilog=\"\") parser.add_argument('command',nargs='*', help=\"Name of the function to run with arguments\") args = parser.parse_args() return (args, parser)"
            },
            {
                "url": 1315,
                "code": "def get_url_args(url): url_data = urllib.parse.urlparse(url) arg_dict = urllib.parse.parse_qs(url_data.query) return arg_dict"
            },
            {
                "url": 5363,
                "code": "def with_defaults(method, nparams, defaults=None): args = [None] * nparams if not defaults else defaults + max(nparams - len(defaults), 0) * [None] return method(*args)"
            },
            {
                "url": 4190,
                "code": "def param (self, param, kwargs, default_value=False): if param in kwargs: value= kwargs[param] del kwargs[param] else: value= default_value setattr (self, param, value)"
            },
            {
                "url": 1713,
                "code": "def print_args(output=sys.stdout): def decorator(func): \"\"\"The decorator function. \"\"\" @wraps(func) def _(*args, **kwargs): \"\"\"The decorated function. \"\"\" output.write( \"Args: {0}, KwArgs: {1}\\n\".format(str(args), str(kwargs))) return func(*args, **kwargs) return _ return decorator"
            },
            {
                "url": 2067,
                "code": "def make_lambda(call): empty_args = ast.arguments(args=[], vararg=None, kwarg=None, defaults=[]) return ast.Lambda(args=empty_args, body=call)"
            }
        ],
        "url": 139
    },
    {
        "nl_input": "python how to select first 100 rows",
        "code_input": [
            {
                "url": 5702,
                "code": "def fetchallfirstvalues(self, sql: str, *args) -> List[Any]: rows = self.fetchall(sql, *args) return [row[0] for row in rows]"
            },
            {
                "url": 5650,
                "code": "def genfirstvalues(cursor: Cursor, arraysize: int = 1000) \\ -> Generator[Any, None, None]: return (row[0] for row in genrows(cursor, arraysize))"
            },
            {
                "url": 5304,
                "code": "def fetch(table, cols=\"*\", where=(), group=\"\", order=(), limit=(), **kwargs): return select(table, cols, where, group, order, limit, **kwargs).fetchall()"
            },
            {
                "url": 5937,
                "code": "def execute_sql(self, query): c = self.con.cursor() c.execute(query) result = [] if c.rowcount > 0: try: result = c.fetchall() except psycopg2.ProgrammingError: pass return result"
            },
            {
                "url": 4393,
                "code": "def select_random(engine, table_or_columns, limit=5): s = select(table_or_columns).order_by(func.random()).limit(limit) return engine.execute(s).fetchall()"
            },
            {
                "url": 481,
                "code": "def select(self, cmd, *args, **kwargs): self.cursor.execute(cmd, *args, **kwargs) return self.cursor.fetchall()"
            },
            {
                "url": 5806,
                "code": "def fetchvalue(self, sql: str, *args) -> Optional[Any]: row = self.fetchone(sql, *args) if row is None: return None return row[0]"
            },
            {
                "url": 4609,
                "code": "def count_rows(self, table, cols='*'): query = 'SELECT COUNT({0}) FROM {1}'.format(join_cols(cols), wrap(table)) result = self.fetch(query) return result if result is not None else 0"
            },
            {
                "url": 5901,
                "code": "async def fetchall(self) -> Iterable[sqlite3.Row]: return await self._execute(self._cursor.fetchall)"
            },
            {
                "url": 5494,
                "code": "def rowlenselect(table, n, complement=False): where = lambda row: len(row) == n return select(table, where, complement=complement)"
            },
            {
                "url": 1281,
                "code": "def query_fetch_one(self, query, values): self.cursor.execute(query, values) retval = self.cursor.fetchone() self.__close_db() return retval"
            },
            {
                "url": 90,
                "code": "def _dictfetchall(self, cursor): columns = [col[0] for col in cursor.description] return [ dict(zip(columns, row)) for row in cursor.fetchall() ]"
            },
            {
                "url": 88,
                "code": "def dictfetchall(cursor): desc = cursor.description return [dict(zip([col[0] for col in desc], row)) for row in cursor.fetchall()]"
            },
            {
                "url": 2990,
                "code": "def query_proc_row(procname, args=(), factory=None): for row in query_proc(procname, args, factory): return row return None"
            },
            {
                "url": 587,
                "code": "def get_last_row(dbconn, tablename, n=1, uuid=None): return fetch(dbconn, tablename, n, uuid, end=True)"
            }
        ],
        "url": 5650
    },
    {
        "nl_input": "removing columnsns in data frame python",
        "code_input": [
            {
                "url": 834,
                "code": "def remove_columns(self, data, columns): for column in columns: if column in data.columns: data = data.drop(column, axis=1) return data"
            },
            {
                "url": 5616,
                "code": "def clean_column_names(df: DataFrame) -> DataFrame: f = df.copy() f.columns = [col.strip() for col in f.columns] return f"
            },
            {
                "url": 1101,
                "code": "def del_Unnamed(df): cols_del=[c for c in df.columns if 'Unnamed' in c] return df.drop(cols_del,axis=1)"
            },
            {
                "url": 4734,
                "code": "def clean_colnames(df): col_list = [] for index in range(_dutils.cols(df)): col_list.append(df.columns[index].strip().lower().replace(' ','_')) df.columns = col_list"
            },
            {
                "url": 877,
                "code": "def _drop_str_columns(df): str_columns = filter(lambda pair: pair[1].char == 'S', df._gather_dtypes().items()) str_column_names = list(map(lambda pair: pair[0], str_columns)) return df.drop(str_column_names)"
            },
            {
                "url": 3616,
                "code": "def remove_rows_matching(df, column, match): df = df.copy() mask = df[column].values != match return df.iloc[mask, :]"
            },
            {
                "url": 1437,
                "code": "def strip_columns(tab): for colname in tab.colnames: if tab[colname].dtype.kind in ['S', 'U']: tab[colname] = np.core.defchararray.strip(tab[colname])"
            },
            {
                "url": 2333,
                "code": "def clean_df(df, fill_nan=True, drop_empty_columns=True): if fill_nan: df = df.fillna(value=np.nan) if drop_empty_columns: df = df.dropna(axis=1, how='all') return df.sort_index()"
            },
            {
                "url": 6049,
                "code": "def normalize_column_names(df): r columns = df.columns if hasattr(df, 'columns') else df columns = [c.lower().replace(' ', '_') for c in columns] return columns"
            },
            {
                "url": 3935,
                "code": "def _remove_nonascii(self, df): df_copy = df.copy(deep=True) for col in df_copy.columns: if (df_copy[col].dtype == np.dtype('O')): df_copy[col] = df[col].apply( lambda x: re.sub(r'[^\\x00-\\x7f]', r'', x) if isinstance(x, six.string_types) else x) return df_copy"
            },
            {
                "url": 390,
                "code": "def remove_non_magic_cols(self): for table_name in self.tables: table = self.tables[table_name] table.remove_non_magic_cols_from_table()"
            },
            {
                "url": 5008,
                "code": "def cols_strip(df,col_list, dest = False): if not dest: return _pd.DataFrame({col_name:col_strip(df,col_name) for col_name in col_list}) for col_name in col_list: col_strip(df,col_name,dest)"
            },
            {
                "url": 889,
                "code": "def clean_dataframe(df): df = df.fillna(method='ffill') df = df.fillna(0.0) return df"
            },
            {
                "url": 25,
                "code": "def get_column(self, X, column): if isinstance(X, pd.DataFrame): return X[column].values return X[:, column]"
            },
            {
                "url": 5659,
                "code": "def is_not_null(df: DataFrame, col_name: str) -> bool: if ( isinstance(df, pd.DataFrame) and col_name in df.columns and df[col_name].notnull().any() ): return True else: return False"
            }
        ],
        "url": 5616
    },
    {
        "nl_input": "python array to torch tensor",
        "code_input": [
            {
                "url": 5649,
                "code": "def astensor(array: TensorLike) -> BKTensor: tensor = tf.convert_to_tensor(value=array, dtype=CTYPE) return tensor"
            },
            {
                "url": 5152,
                "code": "def _parse_array(self, tensor_proto): try: from onnx.numpy_helper import to_array except ImportError as e: raise ImportError(\"Unable to import onnx which is required {}\".format(e)) np_array = to_array(tensor_proto).reshape(tuple(tensor_proto.dims)) return mx.nd.array(np_array)"
            },
            {
                "url": 126,
                "code": "def convert_array(array): out = io.BytesIO(array) out.seek(0) return np.load(out)"
            },
            {
                "url": 9,
                "code": "def _convert_to_array(array_like, dtype): if isinstance(array_like, bytes): return np.frombuffer(array_like, dtype=dtype) return np.asarray(array_like, dtype=dtype)"
            },
            {
                "url": 5880,
                "code": "def array_to_npy(array_like): # type: (np.array or Iterable or int or float) -> object buffer = BytesIO() np.save(buffer, array_like) return buffer.getvalue()"
            },
            {
                "url": 1583,
                "code": "def dict_to_numpy_array(d): return fromarrays(d.values(), np.dtype([(str(k), v.dtype) for k, v in d.items()]))"
            },
            {
                "url": 6117,
                "code": "def numpy_to_yaml(representer: Representer, data: np.ndarray) -> Sequence[Any]: return representer.represent_sequence( \"!numpy_array\", data.tolist() )"
            },
            {
                "url": 4776,
                "code": "def _ndarray_representer(dumper, data): mapping = [('object', data.tolist()), ('dtype', data.dtype.name)] return dumper.represent_mapping(_NUMPY_ARRAY_TAG, mapping)"
            },
            {
                "url": 2616,
                "code": "def adapt_array(arr): out = io.BytesIO() np.save(out, arr), out.seek(0) return buffer(out.read())"
            },
            {
                "url": 304,
                "code": "def torecarray(*args, **kwargs): import numpy as np return toarray(*args, **kwargs).view(np.recarray)"
            },
            {
                "url": 1584,
                "code": "def adapt_array(arr): out = io.BytesIO() np.save(out, arr) out.seek(0) return sqlite3.Binary(out.read())"
            },
            {
                "url": 231,
                "code": "def deserialize_ndarray_npy(d): with io.BytesIO() as f: f.write(json.loads(d['npy']).encode('latin-1')) f.seek(0) return np.load(f)"
            },
            {
                "url": 1870,
                "code": "def _to_array(value): if isinstance(value, (tuple, list)): return array(value) elif isinstance(value, (float, int)): return np.float64(value) else: return value"
            },
            {
                "url": 5220,
                "code": "def irecarray_to_py(a): pytypes = [pyify(typestr) for name,typestr in a.dtype.descr] def convert_record(r): return tuple([converter(value) for converter, value in zip(pytypes,r)]) return (convert_record(r) for r in a)"
            },
            {
                "url": 1885,
                "code": "def c_array(ctype, values): if isinstance(values, np.ndarray) and values.dtype.itemsize == ctypes.sizeof(ctype): return (ctype * len(values)).from_buffer_copy(values) return (ctype * len(values))(*values)"
            }
        ],
        "url": 5649
    },
    {
        "nl_input": "how to turn a list into a csv python",
        "code_input": [
            {
                "url": 77,
                "code": "def list_to_csv(value): if isinstance(value, (list, tuple, set)): value = \",\".join(value) return value"
            },
            {
                "url": 4825,
                "code": "def list_to_csv(my_list, csv_file): if PY3: csv_handler = open(csv_file, 'w', newline='') else: csv_handler = open(csv_file, 'wb') try: writer = csv.writer(csv_handler, delimiter=',', quoting=csv.QUOTE_ALL) writer.writerows(my_list) finally: csv_handler.close()"
            },
            {
                "url": 2742,
                "code": "def csvtolist(inputstr): reader = csv.reader([inputstr], skipinitialspace=True) output = [] for r in reader: output += r return output"
            },
            {
                "url": 5700,
                "code": "def list_to_str(list, separator=','): list = [str(x) for x in list] return separator.join(list)"
            },
            {
                "url": 5746,
                "code": "def csv_to_numpy(string_like, dtype=None): # type: (str) -> np.array stream = StringIO(string_like) return np.genfromtxt(stream, dtype=dtype, delimiter=',')"
            },
            {
                "url": 3278,
                "code": "def comma_delimited_to_list(list_param): if isinstance(list_param, list): return list_param if isinstance(list_param, str): return list_param.split(',') else: return []"
            },
            {
                "url": 3417,
                "code": "def list2string (inlist,delimit=' '): stringlist = [makestr(_) for _ in inlist] return string.join(stringlist,delimit)"
            },
            {
                "url": 1837,
                "code": "def to_list(var): if var is None: return [] if isinstance(var, str): var = var.split('\\n') elif not isinstance(var, list): try: var = list(var) except TypeError: raise ValueError(\"{} cannot be converted to the list.\".format(var)) return var"
            },
            {
                "url": 1253,
                "code": "def write_tsv_line_from_list(linelist, outfp): line = '\\t'.join(linelist) outfp.write(line) outfp.write('\\n')"
            },
            {
                "url": 57,
                "code": "def csv_to_dicts(file, header=None): with open(file) as csvfile: return [row for row in csv.DictReader(csvfile, fieldnames=header)]"
            },
            {
                "url": 4044,
                "code": "def writeCSV(data, headers, csvFile): with open(csvFile, \"wb\") as f: writer = csv.writer(f, delimiter=\",\") writer.writerow(headers) writer.writerows(data)"
            },
            {
                "url": 5769,
                "code": "def encode_list(key, list_): # type: (str, Iterable) -> Dict[str, str] if not list_: return {} return {key: \" \".join(str(i) for i in list_)}"
            },
            {
                "url": 1420,
                "code": "def _format_list(result): if not result: return result if isinstance(result[0], dict): return _format_list_objects(result) table = Table(['value']) for item in result: table.add_row([iter_to_table(item)]) return table"
            },
            {
                "url": 160,
                "code": "def commajoin_as_strings(iterable): return _(u',').join((six.text_type(i) for i in iterable))"
            },
            {
                "url": 1146,
                "code": "def split_strings_in_list_retain_spaces(orig_list): temp_list = list() for line in orig_list: line_split = __re.split(r'(\\s+)', line) temp_list.append(line_split) return temp_list"
            }
        ],
        "url": 77
    },
    {
        "nl_input": "how do i unzip file in python",
        "code_input": [
            {
                "url": 2214,
                "code": "def unzip_file_to_dir(path_to_zip, output_directory): z = ZipFile(path_to_zip, 'r') z.extractall(output_directory) z.close()"
            },
            {
                "url": 2696,
                "code": "def install_from_zip(url): fname = 'tmp.zip' downlad_file(url, fname) unzip_file(fname) print(\"Removing {}\".format(fname)) os.unlink(fname)"
            },
            {
                "url": 3315,
                "code": "def extract_zip(zip_path, target_folder): with zipfile.ZipFile(zip_path) as archive: archive.extractall(target_folder)"
            },
            {
                "url": 1359,
                "code": "def extract_all(zipfile, dest_folder): z = ZipFile(zipfile) print(z) z.extract(dest_folder)"
            },
            {
                "url": 1220,
                "code": "def _unzip_handle(handle): if isinstance(handle, basestring): handle = _gzip_open_filename(handle) else: handle = _gzip_open_handle(handle) return handle"
            },
            {
                "url": 496,
                "code": "def __gzip(filename): zipname = filename + '.gz' file_pointer = open(filename,'rb') zip_pointer = gzip.open(zipname,'wb') zip_pointer.writelines(file_pointer) file_pointer.close() zip_pointer.close() return zipname"
            },
            {
                "url": 3460,
                "code": "def ungzip_data(input_data): buf = StringIO(input_data) f = gzip.GzipFile(fileobj=buf) return f"
            },
            {
                "url": 293,
                "code": "def extract_alzip (archive, compression, cmd, verbosity, interactive, outdir): return [cmd, '-d', outdir, archive]"
            },
            {
                "url": 502,
                "code": "def current_zipfile(): if zipfile.is_zipfile(sys.argv[0]): fd = open(sys.argv[0], \"rb\") return zipfile.ZipFile(fd)"
            },
            {
                "url": 1361,
                "code": "def extract(self, destination): with zipfile.ZipFile(self.archive, 'r') as zip_ref: zip_ref.extractall(destination)"
            },
            {
                "url": 3100,
                "code": "def unpickle(pickle_file): pickle = None with open(pickle_file, \"rb\") as pickle_f: pickle = dill.load(pickle_f) if not pickle: LOG.error(\"Could not load python object from file\") return pickle"
            },
            {
                "url": 1754,
                "code": "def unpickle_file(picklefile, **kwargs): with open(picklefile, 'rb') as f: return pickle.load(f, **kwargs)"
            },
            {
                "url": 1562,
                "code": "def get_gzipped_contents(input_file): zbuf = StringIO() zfile = GzipFile(mode=\"wb\", compresslevel=6, fileobj=zbuf) zfile.write(input_file.read()) zfile.close() return ContentFile(zbuf.getvalue())"
            },
            {
                "url": 5407,
                "code": "def bin_open(fname: str): if fname.endswith(\".gz\"): return gzip.open(fname, \"rb\") return open(fname, \"rb\")"
            },
            {
                "url": 2786,
                "code": "def install_rpm_py(): python_path = sys.executable cmd = '{0} install.py'.format(python_path) exit_status = os.system(cmd) if exit_status != 0: raise Exception('Command failed: {0}'.format(cmd))"
            }
        ],
        "url": 1220
    }
]