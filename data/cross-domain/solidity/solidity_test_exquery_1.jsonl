[
    {
        "nl_input": "The query requires a function to replace the current owner with a new owner in a smart contract. The function should ensure only the existing owner can perform this action, possibly including events to log the owner change. It may also involve validating the new owner and updating the owner's address accordingly.",
        "url": 0
    },
    {
        "nl_input": "The query requires a function to compute the real cap using a given cap value and a key. It involves hashing these inputs to derive a unique result, as demonstrated by the use of the keccak256 hash function in the provided code. The requirement focuses on creating a deterministic computation for the real cap based on the inputs.",
        "url": 1
    },
    {
        "nl_input": "The query requires a constructor function where the function name must match the contract name declared above. The focus is on ensuring that the function serves as a constructor, aligning with the contract's name and purpose, unlike the provided examples which are getter functions returning specific attributes of the contract.",
        "url": 2
    },
    {
        "nl_input": "The query requires defining the amount of Kitten Coins a user needs to hold to qualify for holder rewards. This involves setting a specific threshold (holderAmount) that determines eligibility for rewards, which can be configured by the contract owner. The solution should include a function to set this threshold dynamically.",
        "url": 3
    },
    {
        "nl_input": "The query requires a function to check the balance of a particular account in a token contract. The function should take an address as input and return the corresponding balance stored in the contract's state variable `balances`. The provided code examples demonstrate implementations with slight variations in syntax but fulfill the same functionality.",
        "url": 4
    },
    {
        "nl_input": "The query requires a function to burn BNTTs from users, ensuring the user has sufficient balance and the value is positive. The most suitable code implements a burn function that deducts the specified amount from the user's balance, updates the total supply, and records the burn event, while enforcing ownership and validity checks.",
        "url": 5
    },
    {
        "nl_input": "The query requires a method to update the current state of tranches and currentRound based on certain conditions. It involves transitioning between funding rounds, updating tranches status, and resetting currentRound when specific caps are met. The solution should handle multiple rounds and ensure proper state transitions.",
        "url": 6
    },
    {
        "nl_input": "The query requires a function or modifier that ensures certain conditions are met when an action is executed, such as releasing functionality after a specific date, pausing or unpausing operations, or nullifying a contract. The provided code examples demonstrate modifiers and functions that implement these conditional behaviors in smart contracts.",
        "url": 7
    },
    {
        "nl_input": "The query requires a function to log data requests using a specific ID. It should retrieve and return details associated with the given ID, such as initialization status, data URL, and related data points. The focus is on accessing stored data requests and providing their information based on the requested ID.",
        "url": 8
    },
    {
        "nl_input": "The query requires a mechanism for a controller to step down, implying a function that allows the current controller or owner to relinquish their control or transfer ownership. The provided code snippets do not directly match this requirement but suggest the need for a function like \"renounceOwnership\" or \"transferOwnership\" in a smart contract context.",
        "url": 9
    },
    {
        "nl_input": "The query requires a function that facilitates the withdrawal of tokens from a contract. Specifically, it involves transferring tokens to a specified address, ensuring conditions like ownership or contract status are met, and updating relevant balances or states within the contract during the process.",
        "url": 10
    },
    {
        "nl_input": "The query requires a public interface to access the directory of games, including details such as contract address, description, URL, submitter, and time. It needs functions to retrieve total games and specific game information. The provided code suggests the requirement for a contract with functions like getTotalGames and theGames for accessing game records.",
        "url": 11
    },
    {
        "nl_input": "The query requires a function allowing users to retrieve their assigned prize. The most relevant code provides a `withdrawPrize` function, which calculates the user's prize based on owned tokens, clears the payout mapping, and transfers the calculated prize from a prize pool to the user, ensuring the prize is greater than zero before execution.",
        "url": 12
    },
    {
        "nl_input": "The query requires implementing a function to add a new casino with specific attributes (star rating, price, owner, name, and description) to a list or mapping. The function should generate a unique ID for the new casino, create a casino object with the provided details, and store it in a data structure for further access.",
        "url": 13
    },
    {
        "nl_input": "The query requires a function to transfer tokens from one account to another, ensuring the sender has sufficient balance and approval. The function should deduct tokens from the sender's balance, add them to the recipient's balance, and emit a transfer event, confirming the transaction's success.",
        "url": 14
    },
    {
        "nl_input": "The query requires a function to toggle the locked state in a smart contract, allowing the owner to change the lock status and emit an event indicating the new state. The provided code includes a toggle function that switches the 'locked' boolean and emits a 'ToggleLocked' event with the updated status.",
        "url": 15
    },
    {
        "nl_input": "The query requires a function that allows the pendingOwner address to finalize the transfer within a specified time frame. The function should ensure the transaction is only executable by the owner, check if the finalization period has started and ended, and confirm the transfer upon meeting these conditions.",
        "url": 16
    },
    {
        "nl_input": "The query requires a function to override the default transfer behavior in a smart contract, ensuring custom logic is applied before executing the transfer. This includes checking conditions like transfer allowances or activation status before invoking the parent contract's transfer method. The goal is to add control or restrictions to token transfers beyond standard functionality.",
        "url": 17
    },
    {
        "nl_input": "The query requires a function to allocate tokens to users with specific parameters. It needs to handle multiple users, their respective token values, and possibly additional attributes like lock types. The function should ensure the correct number of parameters and update token balances and total supply accordingly, emitting a transfer event for transparency.",
        "url": 18
    },
    {
        "nl_input": "The query requires a function to check the allowance of one address to spend tokens from another address. The function should take two addresses as inputs and return a uint256 value representing the remaining allowance. Despite variations in the provided code, none fully meet the requirement since they either return zero or are not properly implemented.",
        "url": 19
    },
    {
        "nl_input": "The query requires a mechanism to delegate execution to an implementation contract, involving the use of delegate calls or similar functionality. It should include address validation, gas management, and handling return or revert scenarios to ensure proper delegation behavior in a smart contract environment.",
        "url": 20
    },
    {
        "nl_input": "The query requires a function to cancel pending operations or requests. Specifically, it needs logic to handle the cancellation of auctions, projects, or withdrawal requests within a smart contract system. This involves updating states (e.g., marking as canceled, resetting values) and potentially notifying relevant parties through events or returns. The solution should ensure proper state management and recursive checks if applicable.",
        "url": 21
    },
    {
        "nl_input": "The query requires a function to check if the length of a string is within a specified minimum and maximum range. The desired function should take a string and two uint values as input and return a boolean indicating whether the string's length satisfies the given constraints. This ensures the string length is neither too short nor too long.",
        "url": 22
    },
    {
        "nl_input": "The query requires implementing a cooldown mechanism for childbirth, ensuring a character or entity must wait a specific period before breeding again. The function should update the cooldown status, potentially increasing the cooldown duration with each breeding event, and verify if the entity is ready to breed by checking the cooldown expiration.",
        "url": 23
    },
    {
        "nl_input": "The query requires a function to set a specific contract address that has permission to call the \"vacate\" function on the current contract. This involves defining a function that accepts an address as an argument, validates it, and assigns it as the authorized caller for the \"vacate\" functionality, ensuring proper access control.",
        "url": 24
    },
    {
        "nl_input": "The query requires a function to facilitate the purchase of tokens using Ether, ensuring a minimum value is met, calculating the number of tokens based on the rate, minting the tokens, and transferring Ether to a wallet. The function should handle requirements like validating the sender and ensuring the token supply does not exceed the hard cap.",
        "url": 25
    },
    {
        "nl_input": "The query requires determining the number of token base units per grain, as represented by the 'tokenUnits' function. It involves calculating and returning an array of token units for each token in a list. The requirement is to extract or compute these units for all tokens, likely involving a loop through available tokens and collecting their respective unit values.",
        "url": 26
    },
    {
        "nl_input": "The query requires a function to update a specific address (e.g., multi-signature, signer, or wallet address) within a smart contract, ensuring the new address is valid and typically restricted to authorized users (e.g., onlyOwner or onlyMultiSig). The function should include a validation check to prevent setting an invalid address (e.g., address(0)).",
        "url": 27
    },
    {
        "nl_input": "The query requires identifying if the `burnToken` function has ended. It needs a mechanism to confirm the completion of the token-burning process, likely involving a check for an \"ended\" state or time-based condition, ensuring tokens are burned only when specific criteria (e.g., `hasEnded()` or supply conditions) are met.",
        "url": 28
    },
    {
        "nl_input": "The query requires a function allowing participants to request refunds if the token generation minimum is not met. The function should verify conditions such as contribution amount, sale completion status, and block time, then refund participants by transferring their contributed amount and updating balances accordingly.",
        "url": 29
    },
    {
        "nl_input": "The query requires a code snippet that ensures a function can only be executed via a script by the contract, effectively implementing a quorum mechanism. This involves restricting function calls to those originating from within the contract itself, ensuring external unauthorized access is prohibited. The provided codes focus on different modifiers but do not directly fulfill the quorum requirement.",
        "url": 30
    },
    {
        "nl_input": "The query requires a function to check the balance of tokens in a wallet. Specifically, it needs to handle both ETH and ERC20 token balances by checking the wallet's balance or using the `balanceOf` method from the token contract. The provided code examples demonstrate implementations that fulfill this requirement by interacting with token contracts and retrieving balances.",
        "url": 31
    },
    {
        "nl_input": "The query requires determining the number of wei needed to purchase 0.01 Mozo token. It involves calculating token amounts based on wei investment using a defined rate. The relevant code extracts showcase functions that compute token amounts by multiplying the invested wei with a rate, indicating the relationship between wei and token quantities in different contract scenarios.",
        "url": 32
    },
    {
        "nl_input": "The query requires a function that allows the contract owner to transfer ethers from the contract's balance to their address. This involves an \"onlyOwner\" restriction and typically uses either the `transfer` or `send` method to send the specified amount or entire balance to the owner's address for rescuing funds.",
        "url": 33
    },
    {
        "nl_input": "The query requires a function to modify the contract's owner address, ensuring only the current owner can execute this change. The function should accept a new owner address as an argument, update the owner, and optionally emit an event to log the ownership change. Security and authorization checks (e.g., `onlyOwner`) are crucial for this functionality.",
        "url": 34
    },
    {
        "nl_input": "The query requires a function that returns both the token amount and its equivalent value in USD based on an input amount. Specifically, it needs to calculate tokens using bonus logic and convert the result into USD, ensuring proper handling of zero values for both tokens and USD amounts. The solution should involve multiple-step calculations incorporating rates and bonuses.",
        "url": 35
    },
    {
        "nl_input": "The query requires methods for user authorisation management in smart contracts. It involves adding addresses to an authorised list, checking if a user is authorised, and managing authorisations with specific amounts. The focus is on ensuring only authorised entities can perform certain actions, using modifiers or functions to control access and update authorisation statuses.",
        "url": 36
    },
    {
        "nl_input": "The query requires a function allowing customers to buy a box, involving payment, validation checks, and potential rewards or token creation. It should handle conditions like availability, pricing, and possibly random outcomes or bonuses, ensuring excess funds are refunded and maintaining system constraints. The focus is on external payable functions with specific logic for processing the purchase.",
        "url": 37
    },
    {
        "nl_input": "The query requires a function to retrieve sale prices of a Property in both ETH and PXL based on the property ID. If the property is system-owned, it returns system-defined prices; otherwise, it returns the price set by the property owner in PXL, with ETH price potentially being zero if not applicable.",
        "url": 38
    },
    {
        "nl_input": "The query requires a function to calculate the total remaining free trial drops of a token. It needs to check if the token has a free trial and then return the difference between the maximum allowed drops and the already used drops for that specific token. If the token doesn't have a free trial, it should return zero.",
        "url": 39
    },
    {
        "nl_input": "The query requires a function to transfer ownership of a contract to a new address and subsequently destroy the contract. The ideal code should include a mechanism to ensure the new owner is valid, transfer ownership, and self-destruct the contract after the transfer is complete.",
        "url": 40
    },
    {
        "nl_input": "The query requires a function to transfer tokens from the sender's address to a specified recipient address, ensuring the balance and allowance are updated correctly. It involves token management, subtracting tokens from the sender, adding them to the receiver, and confirming the transaction's success while adhering to predefined conditions.",
        "url": 41
    },
    {
        "nl_input": "The query requires a function that allows the owner to modify the token exchange rate, typically set as a default value (e.g., 0.005 Ether per token). The desired functionality should include a method accessible only by the owner to update the exchange rate dynamically, ensuring flexibility in managing token pricing during operations like crowdfunding or sales.",
        "url": 42
    },
    {
        "nl_input": "The query requires a function that allows providers to return a subscription deposit to customers immediately upon cancellation. The function should verify the subscription is canceled, ensure there's a deposit to return, confirm the caller's authorization, and execute the deposit return process.",
        "url": 43
    },
    {
        "nl_input": "The query requires a function to set the approval expiry window before the contract is locked. It needs to be callable by an authorized user (e.g., owner) and should accept a parameter defining the duration or timestamp for the expiry window, ensuring it is configured prior to locking the contract.",
        "url": 44
    },
    {
        "nl_input": "The query requires a function to retrieve the BOP balance for a given address. The most suitable code should have a function that accepts an address as input and returns the balance associated with that address, likely interacting with a token contract or balance mapping. The function must be accessible and correctly implement the balance-checking logic.",
        "url": 45
    },
    {
        "nl_input": "The query requires identifying functions that are defined as constant instead of pure, focusing on their functionality without altering blockchain state. The relevant function should compute values based on input parameters or current block information without external dependencies or state mutations, such as calculating block offsets or halving intervals.",
        "url": 46
    },
    {
        "nl_input": "The query requires a function to reallocate unsold and leftover bounty tokens. Specifically, it involves transferring or minting tokens to designated addresses after the main allocation or sale period has ended, ensuring that any remaining bounty tokens are appropriately redistributed according to predefined rules.",
        "url": 47
    },
    {
        "nl_input": "The query requires a function to handle user-initiated withdrawals, allowing users to cancel the withdrawal request. The desired code should manage withdrawal statuses, ensure correct conditions for withdrawal (e.g., time constraints), and provide flexibility if the user changes their decision before completing the process. It may involve updating user states and refunding amounts accordingly.",
        "url": 48
    },
    {
        "nl_input": "The query requires a function to mint tokens and assign them to a specific address. The function should ensure the address is valid, allocate the specified token amount, and possibly trigger a transfer event to notify the network about the newly minted tokens assigned to the given address.",
        "url": 49
    },
    {
        "nl_input": "The query requires a function to determine the current bonus during the ICO, considering time-based stages and adjusting the bonus accordingly. It involves checking the ICO state, comparing timestamps with predefined stages, and decrementing the bonus based on specific conditions while ensuring it doesn't fall below a minimum threshold.",
        "url": 50
    },
    {
        "nl_input": "The query requires implementing a function to call the token allocation function on all token bankrolls. This involves iterating through predefined token amounts and allocating them using an internal function. The requirement focuses on ensuring tokens are assigned to addresses, maintaining balance updates, and possibly checking available tokens based on percentages allocated.",
        "url": 51
    },
    {
        "nl_input": "The query requires a function to transfer tokens from the owner's account to another account, ensuring the owner has sufficient balance. It allows zero-value transfers and includes a developer override. The function should handle token transfers securely, verifying balances and possibly bypassing standard checks via dev override.",
        "url": 52
    },
    {
        "nl_input": "The query requires a function to send a token to a user's address. It needs to verify the sender's authorization, ensure the amount does not exceed the available deposit, and confirm successful token transfer using a reliable method, updating the remaining deposit after the transaction. The function should interact with an external token contract for the transfer.",
        "url": 53
    },
    {
        "nl_input": "The query requires extracting 256-bit (or 32-byte) data from a bytes stream. The relevant code defines a function `slice32` that takes a byte array (`b`) and an `offset`, iterating through 32 bytes to construct and return a `bytes32` (256-bit) output by bitwise manipulation. This matches the requirement for extracting 256-bit data from a bytes stream.",
        "url": 54
    },
    {
        "nl_input": "The query requires a function to retrieve all relevant information about a specific element, including its ID, name, selling price, owner, and associated scientist ID. The most suitable code provides a function that takes a token ID as input and returns these details stored in a mapping or array structure related to elements.",
        "url": 55
    },
    {
        "nl_input": "The query requires a mechanism to ensure a contract is operational before proceeding, likely using modifiers or internal functions to validate the state. It involves checking conditions such as operational status, funding goals, or specific contract configurations, and potentially reverting if these conditions are not met. The focus is on maintaining valid contract states during execution.",
        "url": 56
    },
    {
        "nl_input": "The query requires a function to calculate the total payout amount, commission, and donation amounts based on predefined rates. It involves deducting commission and donation from the total bet amount, transferring the respective amounts to owner and charity, and updating the total payout amount accordingly. The solution should handle these calculations and transactions privately within a contract.",
        "url": 57
    },
    {
        "nl_input": "The query requires a function to delete or cancel a transaction request. The desired function should take an identifier (e.g., `_key`) as input, verify its existence, and then remove the associated transaction data while maintaining structural integrity of arrays or mappings. It may also involve emitting events or returning status codes upon successful deletion.",
        "url": 58
    },
    {
        "nl_input": "The query requires a function allowing contract owners to add a new dungeon floor by specifying its ID, along with new rewards and floor genes. The selected code should ensure only the contract owner can modify dungeon states and increment the floor number while updating relevant attributes like rewards and genes.",
        "url": 59
    },
    {
        "nl_input": "The query requires calculating the number of tokens to be transferred to an investor's address based on the invested ethers. It involves determining a token amount by considering the investment value, token rate, and possibly conversion factors. The function should handle Ether input, compute the corresponding token quantity, and ensure accurate transfer calculations.",
        "url": 60
    },
    {
        "nl_input": "The query requires a function allowing the owner to enable a crowdsale contract to distribute tokens. The function should ensure the token is whitelisted, check the distribution limits, and record the distribution details while emitting an event for active token distribution.",
        "url": 61
    },
    {
        "nl_input": "The query requires creating a request and assigning it a unique ID. The description involves generating a new request, setting its ID as the next available one, and associating details such as type, target, value, and message with this request. It also includes recording creation time and emitting an event to notify about the new request.",
        "url": 62
    },
    {
        "nl_input": "The query requires implementing a function to assign an allowance value to a spender address, permitting it to use the sender's tokens. It involves updating the allowance mapping with the spender's address and specified value, ensuring proper approval functionality within a smart contract.",
        "url": 63
    },
    {
        "nl_input": "The query requires a function to handle the deposit of funds, likely involving tokens or cryptocurrency. It should log or manage deposits, possibly with parameters like token type, amount, and wallet balance, ensuring proper validation and recording of the deposit action.",
        "url": 64
    },
    {
        "nl_input": "The query requires a function to withdraw deposited funds, typically restricted to the contract owner. It should allow specifying an amount to transfer, with optional parameters like destination address and balance checks. The function may also include events or require conditions to ensure valid transactions.",
        "url": 65
    },
    {
        "nl_input": "The query requires implementing a modifier or function that restricts execution to only one specific payer. The most relevant code demonstrates a modifier named \"onlyPayer\" which ensures the caller is authorized as a payer. This matches the requirement for limiting actions to a single payer by using a mapping or similar structure to verify the sender's authorization.",
        "url": 66
    },
    {
        "nl_input": "The query requires a function that allows the owner to transfer tokens from one address to another, ensuring specific conditions are met, such as valid addresses, token amounts, and potentially restricting certain addresses. The function should handle token transfers securely and may involve checks for ownership, beneficiary validity, and token balances.",
        "url": 67
    },
    {
        "nl_input": "The query requires a function to facilitate payments on behalf of a sender. It should accept parameters for the sender's identity and the payment amount, ensuring the benefactor is valid and forwarding the payment to the designated address while recording transaction details. The solution must handle payment validation and maintain records of transactions accurately.",
        "url": 68
    },
    {
        "nl_input": "The query requires implementing a function or modifier to add or manage \"burning man\" addresses in a contract system. Specifically, it involves adding an address while ensuring uniqueness and utilizing multisignature verification for security. The operation should update the contract state to recognize the new \"burning man\" address upon successful validation.",
        "url": 69
    },
    {
        "nl_input": "The query requires a function to add staff addresses to a whitelist. It should accept an array of addresses, validate each address, and add valid ones to the whitelist if they aren't already included, ensuring no duplicate entries and ignoring null addresses. The function must be accessible only to authorized users (e.g., admins or whitelisters).",
        "url": 70
    },
    {
        "nl_input": "The query requires implementing a function to freeze an account at a specified target address. The function should take the target address as input, set its status to frozen, and possibly emit an event indicating the action. It assumes the existence of a mapping to track frozen accounts and restricts this functionality to the contract owner.",
        "url": 71
    },
    {
        "nl_input": "The query requires setting an address with the authority to approve users through KYC. It needs a function that allows the owner to designate a specific address as the KYC provider, enabling it to manage user approvals. This involves updating and assigning the authorized KYC provider's address within the contract.",
        "url": 72
    },
    {
        "nl_input": "The query requires a function to retrieve the price of a registered asset in the format (bool areRecent, uint prices, uint decimals). It needs to check the recency of the price and return the price along with its decimal precision. The solution should handle multiple assets and ensure the prices are up-to-date, providing a combined result for all assets listed.",
        "url": 73
    },
    {
        "nl_input": "The query requires a function to remove or cancel an auction, specifically deleting auction data associated with a given identifier (_deedId or _partId). The most relevant code demonstrates removing an auction by deleting its entry in a mapping and optionally transferring the item back to the seller while emitting a cancellation event. This ensures the auction is properly terminated and cleaned up.",
        "url": 74
    },
    {
        "nl_input": "The query requires a function to retrieve the dividends of an owner, potentially including bonus amounts. It needs a method that calculates dividends for a specific recipient, with an option to include additional referral bonuses. The solution should involve internal calculations and return the total dividend value based on the given conditions.",
        "url": 75
    },
    {
        "nl_input": "The query requires creating a new product contract, which involves defining product ownership and potentially transferring or marking products. The relevant code should include functions for setting product ownership, ensuring permissioned access, and possibly handling fees or transfers related to the product. It must support operations like claiming ownership or marking products with specific conditions.",
        "url": 76
    },
    {
        "nl_input": "The query requires a function to execute a token spin action, involving wagering tokens, updating player spin data, and emitting a wager event. It needs to check game activity, block number constraints, and handle tier calculations based on divRate. The function should also manage contract balance updates and ensure unique block numbers for each spin.",
        "url": 77
    },
    {
        "nl_input": "The query requires a function allowing anyone to contribute to the buy executer's reward. The most relevant code should include a payable function to add funds to a reward pool, enabling external contributions without restrictions. It must support increasing the reward dynamically based on the contributed value.",
        "url": 78
    },
    {
        "nl_input": "The query requires a function to facilitate donations for an event. It should handle transferring a specified amount to the event address and record the contribution, ensuring the event is active and the transaction successful. The function must also emit an event detailing the donation for transparency and record-keeping.",
        "url": 79
    },
    {
        "nl_input": "The query requires a function to add an owner in a smart contract, ensuring the new owner's address is valid and does not already exist. The function should update the owner-related data structure, possibly emitting an event or returning a value to confirm the addition. It may include modifiers for access control and consistency checks.",
        "url": 80
    },
    {
        "nl_input": "The query requires a function to check if the provided fee is sufficient before proceeding. It should retrieve the required fee, verify if the sender is exempt or if the sent value meets the fee requirement, and handle fee distribution or rejection if conditions aren't met. The focus is on fee validation and processing logic.",
        "url": 81
    },
    {
        "nl_input": "The query requires a function to return the current game state with relevant details. Specifically, it needs to provide information such as the game's state, ID, direction, bet amount, first roll, final roll, and winnings for a given player. The function should be accessible publicly and apply to the specific player's ongoing game.",
        "url": 82
    },
    {
        "nl_input": "The query requires a function to calculate the amount of WPX tokens received based on the input Wei amount and predefined rates per 1 ETH. It involves determining the appropriate rate for the given Wei amount, multiplying it by the rate, and returning the resulting token amount, considering different tiers or conditions for rate application.",
        "url": 83
    },
    {
        "nl_input": "The query requires a function to pause and unpause an Initial Coin Offering (ICO), ensuring only the sender (owner) can execute these actions. The function should change the ICO's state and may involve emitting an event to signal the unpause action.",
        "url": 84
    },
    {
        "nl_input": "The query requires a function to close a sale, ensuring it is callable only by the contract owner and marks the sale as closed while burning unsold tokens. The relevant code should handle token burning and update the sale status accordingly, confirming the sale closure process.",
        "url": 85
    },
    {
        "nl_input": "The query requires a function to add KYC'ed addresses to a whitelist. The function should accept an array of addresses and mark them as whitelisted. It may include access restrictions (e.g., onlyWhitelister or onlyOwner) and ensure the addresses are valid before adding them to the whitelist mapping.",
        "url": 86
    },
    {
        "nl_input": "The query requires a modifier that allows actions for everybody, ensuring no restrictions apply to any user. The relevant code should include a condition that checks for a state where everyone is permitted to execute the action, typically using a boolean flag or similar mechanism to confirm that the function is open to all participants without specific role constraints.",
        "url": 87
    },
    {
        "nl_input": "The query requires a mechanism to safeguard investors' funds by ensuring that invested amounts are retrievable if a key is lost or after a specific period. It should include functionality for returning balances under certain conditions, protecting investor assets, and potentially handling locked amounts based on time constraints.",
        "url": 88
    },
    {
        "nl_input": "The query requires a function to return the owner of a specific soul. It needs a mapping or storage mechanism that associates souls with their respective owners and a function to retrieve the owner's address based on the input. The most suitable code should directly reflect this relationship by returning the owner associated with a given soul.",
        "url": 89
    },
    {
        "nl_input": "The query requires a function to put a LinglongCat up for auction, specifying its ID, starting price, ending price, and auction duration. The selected code should ensure the sender owns the LinglongCat and it is not pregnant, then approve and create the auction accordingly.",
        "url": 90
    },
    {
        "nl_input": "The query requires a function to allocate tokens to a specified address. The function should take the address as input and update the token balance for that address, potentially including event emission or internal allocation logic. It must ensure the address is valid and may involve checks or restrictions on when tokens can be assigned.",
        "url": 91
    },
    {
        "nl_input": "The query requires a function to manage token release, ensuring it can only be called before or after tokens are released. It involves checking release conditions, possibly using modifiers or specific release functions, and may include tracking released tokens for owners or executing token release actions through predefined methods.",
        "url": 92
    },
    {
        "nl_input": "The query requires a function to calculate and provide bonuses based on certain conditions. Specifically, it involves adding bonuses depending on levels or thresholds, utilizing input amounts, and considering remaining tokens or balances. The result should return the computed reward or bonus value after applying the relevant bonus logic.",
        "url": 93
    },
    {
        "nl_input": "The query requires a function to lock ERC721 behavior, enabling trades on third-party platforms. The relevant code should include a function that disables or pauses ERC721 functionality, allowing control over trading. Specifically, it needs a mechanism (e.g., `disableERC721`, `pause`, or similar) to manage ERC721 status effectively.",
        "url": 94
    },
    {
        "nl_input": "The query requires obtaining the address of a smart contract. The provided code snippets demonstrate methods to retrieve a contract's address, either by using the `this` keyword for the current contract, accessing a mapping of contract names to addresses, or calling a function from another contract to get the current round's address. The focus is on returning the contract's address as per the query's need.",
        "url": 95
    },
    {
        "nl_input": "The query requires a function to set an alias for msg.sender. The relevant code defines a function setAlias(string alias) which associates the provided alias with msg.sender, storing it in a mapping called aliases and simultaneously updating another mapping addresses with the sender's address linked to the alias.",
        "url": 96
    },
    {
        "nl_input": "The query requires a function to cast a vote for an account, ensuring the voter has sufficient voting power, preventing self-voting, and updating vote counts accordingly. The solution should include checks for valid participants, available votes, and proper vote tallying mechanisms while maintaining the integrity of the voting process.",
        "url": 97
    },
    {
        "nl_input": "The query requires functionality to lock up a specific address until a specified time. This involves setting a lockup period for an address, ensuring the new lockup time is later than any existing one, and emitting an event to notify the change. The implementation should include validation of addresses and times, with the ability to handle multiple addresses if needed.",
        "url": 98
    },
    {
        "nl_input": "The query requires identifying contracts that can modify KittyData. Only KittyGym and Arena contracts are authorized to make changes, as indicated by the modifier in the reference code. The description focuses on the authorization mechanism ensuring only specific contracts (KittyGym and Arena) can interact with KittyData, maintaining data integrity and restricted access.",
        "url": 99
    },
    {
        "nl_input": "The query requires a function to set the enabled status of an account, ensuring only the owner can modify it. The most relevant code provides a function `setEnabled` that accepts an address and a boolean value, updating the account's enabled status if it differs from the current one, with access restricted to the contract owner.",
        "url": 100
    },
    {
        "nl_input": "The query requires a function to send a specified value to the next investor(s) in a list. It involves iterating through a list of investors, checking balances, and recursively sending funds until the value is fully distributed or the investor list ends. The process ensures proper balance updates and handles cases where an investor's balance is insufficient.",
        "url": 101
    },
    {
        "nl_input": "The query requires a function to modify the treasury address, where payments are forwarded. It needs a method allowing an authorized user (e.g., owner) to update the address securely. The provided code examples demonstrate functions like `setTreasury` or `changeWallet` that fulfill this requirement by enabling address updates in smart contracts.",
        "url": 102
    },
    {
        "nl_input": "The query requires a helper function to retrieve player information, specifically their details through a contract function. The desired function should be public, constant, and return multiple uint values representing player info. Based on the provided code, the focus is on creating or identifying a function similar to 'getMyInfo' that fetches and returns player data effectively.",
        "url": 103
    },
    {
        "nl_input": "The query requires a function to migrate token holders to a new contract. It needs to iterate through the list of holders, transfer their balances to the new contract via a migration agent, update the total supply, and record the migration progress. The solution should ensure no holder is missed and accurately reflect balance changes during migration.",
        "url": 104
    },
    {
        "nl_input": "The query requires implementing a function to store the gas price as a storage variable for easy reference and update it using an oraclize function. The solution involves setting the gas price via a custom oraclize function, ensuring only authorized users can modify it while validating the input before updating the stored gas price value.",
        "url": 105
    },
    {
        "nl_input": "The query requires a function to send tokens to a partner, ensuring tokens are calculated based on sold and supply limits, then emitted to the partner address. It involves operations like checking if tokens have already been sent, calculating partner tokens, and updating states after transferring tokens. Only relevant code meeting this requirement should be considered.",
        "url": 106
    },
    {
        "nl_input": "The query requires a function to self-register a new DIN (Digital Identity Number) and set the resolver. The relevant code should allow a user to register a DIN while specifying a resolver address, enabling the association of the DIN with the designated resolver in the system.",
        "url": 107
    },
    {
        "nl_input": "The query requires an internal function to transfer ownership of a team, ensuring the new owner is valid and updating ownership records accordingly. It involves modifying ownership counts, updating the team's owner, and emitting a transfer event to log the change, while maintaining privacy and security within the contract.",
        "url": 108
    },
    {
        "nl_input": "The query requires a function to set a parameter identified by a given name to a specified value. The most relevant code should include a function that takes a name (or key) and a value as inputs and stores them, likely using a hashing mechanism for the name. The function is intended to be private or internal, ensuring controlled access to the parameter setting functionality.",
        "url": 109
    },
    {
        "nl_input": "The query requires a function to set or update a token address within a contract, ensuring the address is valid and not already set. It involves access restrictions (e.g., onlyOwner, onlyFounder) and may include boolean flags to track if the token has been deployed or set. The function should return a confirmation of success in some cases.",
        "url": 110
    },
    {
        "nl_input": "The query requires a function to manually perform a health check, adjustable via maintenance mode settings. The relevant code defines a function `performHealthCheck` that updates the maintenance mode and triggers a `healthCheck` if the mode is within a specific range, indicating a controlled operational status. Only the first code snippet meets this requirement.",
        "url": 111
    },
    {
        "nl_input": "The query requires a function to set a new token wallet address, ensuring the address is not zero and may include additional validation checks. The function should be callable only by an authorized entity (e.g., owner or founder) and could trigger an event or return a status indicating success.",
        "url": 112
    },
    {
        "nl_input": "The query requires a function to check if an address is registered within a contract. The most suitable code provides a function named `isRegisteredAccount` or `isRegistered`, which accepts an address as input and returns a boolean value indicating whether the address is registered in the system (using mappings like `allowedAddresses` or `records`).",
        "url": 113
    },
    {
        "nl_input": "The query requires a function to return the total supply of tokens in a contract. It should be constant and return an unsigned integer value representing the total number of tokens. The function name should be \"totalSupply\" and needs to accurately reflect the current token supply within the contract.",
        "url": 114
    },
    {
        "nl_input": "The query requires calling the \"addMinter\" function from the TAU token contract after deployment. It needs a function that adds a specified address as a minter, ensuring the address is valid and not already a minter. The function should be accessible only to the owner and return a boolean confirming the operation's success.",
        "url": 115
    },
    {
        "nl_input": "The query requires a function to transfer shares (or tokens) to another address, ensuring proper balance updates and possibly shareholder management. The implementation should validate the transfer amount, prevent self-transfer, update balances, handle new shareholders, and potentially trigger a transfer event as per EIP-20 standards.",
        "url": 116
    },
    {
        "nl_input": "The query requires a function to close the fund when a specific condition is met, such as the minimum funding goal being reached or the balance being below a certain threshold. The code should handle transitioning the contract to a closed state, potentially transferring remaining funds, and emitting an event to indicate closure.",
        "url": 117
    },
    {
        "nl_input": "The query requires a function to distribute tokens to specified addresses. It involves checking conditions before distribution, calculating amounts based on ratios, and ensuring the total supply isn't exceeded. The process includes transferring tokens, updating balances, and emitting events to confirm successful distribution. Security measures like access control and token whitelisting might also be necessary.",
        "url": 118
    },
    {
        "nl_input": "The query aims to collect all fees paid till now. It requires a function that accumulates fees, possibly from multiple transactions, and returns the total amount collected. The code should handle fee allocation, ensure accurate accounting, and potentially distribute or store the collected fees in a wallet or contract state for further use.",
        "url": 119
    },
    {
        "nl_input": "The query requires a function to update the token fee when approving a transfer. It needs to handle allowance updates, ensure proper fee deduction, and confirm successful approval for token transfers, involving operations such as `approve`, `balanceOf`, and fee management within the context of token transactions.",
        "url": 120
    },
    {
        "nl_input": "The query requires a function to burn tokens from the sender's balance. It needs to ensure that the specified amount is available in the sender's balance, deduct the amount from the balance, reduce the total supply accordingly, and possibly emit an event to log the burn action. The solution should involve proper validation and updating of balances and supply.",
        "url": 121
    },
    {
        "nl_input": "The query seeks a generic substitution for the require() function, which is used to enforce conditions in modifiers within Solidity smart contracts. The provided code examples demonstrate different use cases of require(), such as ensuring a function runs only once, verifying release time, and restricting access based on sender identity. The requirement is to replace require() with an alternative that maintains condition enforcement functionality.",
        "url": 122
    },
    {
        "nl_input": "The query requires a public getter function to retrieve action mapping details in a web3.js compatible format. It needs to return multiple values such as confirmations, expiration, triggered status, target address, and ETH value associated with a specific action ID, ensuring proper functionality within the web3.js environment. The provided code examples are references for implementing this requirement.",
        "url": 123
    },
    {
        "nl_input": "The query requires a function allowing the contract owner to remove a target address from the blacklist. The desired functionality should include a method that accepts an address as input, checks ownership permissions, and updates the blacklist status of the target address by setting it to false.",
        "url": 124
    },
    {
        "nl_input": "The query requires a helper method to retrieve token details, including name, symbol, and totalSupply in one function call. The desired implementation should provide these details efficiently through a single function for easy access.",
        "url": 125
    },
    {
        "nl_input": "The query requires a function to determine the remaining number of tokens that can be removed or canceled. Specifically, it involves checking the available tokens for removal based on certain conditions, such as ensuring the amount is valid and adjusting the token count accordingly. The focus is on calculating removable tokens while maintaining accurate accounting.",
        "url": 126
    },
    {
        "nl_input": "The query requires a function to retrieve the actual amounts of active personal stakes associated with a specific address. It needs to return an array of uint256 values representing these stake amounts. The focus is on viewing existing stake data rather than creating or updating stakes.",
        "url": 127
    },
    {
        "nl_input": "The query requires a function that allows a whitelisted internal application to set the ICO end date, ensuring it can only be used once. The function must verify that the ICO end date has not been previously set and then assigns the provided date as the ICO end date. This ensures control and security over ICO timeline modifications.",
        "url": 128
    },
    {
        "nl_input": "The query requires a function to set a controller address, ensuring the operation is authorized and the controller attachment is enabled. The function should emit an event notifying of the new controller after successfully updating the address. This ensures proper management and tracking of the controller changes within the contract system.",
        "url": 129
    },
    {
        "nl_input": "The query requires a function to set the owner's cut as a percentage charged to the seller upon a successful sale. The function should ensure the cut is less than 100%, update the ownerCutPercentage variable, and emit an event notifying of the change. Only authorized users can execute this function.",
        "url": 130
    },
    {
        "nl_input": "The query requires a function to update the address of an access manager. The most suitable code should allow the contract owner to modify the access manager's address, ensuring it is non-zero and properly assigned. This involves an external function with appropriate permissions and validation checks to successfully update and confirm the new access manager address.",
        "url": 131
    },
    {
        "nl_input": "The query requires generating a giant cat image using pixel data. The code should define a function that constructs an image of a cat by manipulating pixel rows and hexadecimal color values stored in an array. The function must return the resulting image data, which represents the cat's visual representation in a programmable format.",
        "url": 132
    },
    {
        "nl_input": "The query requires a function to retrieve the commitment value associated with a specified address. The relevant code provides a function named `commitmentOf` that takes an address as input and returns the corresponding commitment value stored in the `miners` mapping. This function meets the requirement by allowing access to the commitment data for a given address.",
        "url": 133
    },
    {
        "nl_input": "The query requires a function to change the wallet address for reserved vesting, allowing the setting of a smart-contract address later. It needs a function that updates the reserved wallet address, ensuring flexibility for future smart-contract assignments, with proper access restrictions (e.g., onlyOwner).",
        "url": 134
    },
    {
        "nl_input": "The query requires a function to create or update a personal claim, represented by a key-value pair, associated with the user's address. It should allow users to set or modify claims about themselves in a smart contract system, ensuring the data is correctly stored and linked to the user initiating the action.",
        "url": 135
    },
    {
        "nl_input": "The query requires a function to check if a user belongs to a specific group. The desired functionality should take a group name and user address as inputs and return a boolean value indicating whether the user is part of the specified group, considering both user registration status and group membership.",
        "url": 136
    },
    {
        "nl_input": "The query requires a function to transfer ERC20 tokens to the owner, ensuring only the contract owner can initiate the transfer. The function should take the token address and amount as parameters, then execute the transfer while confirming success. Specific conditions may include restrictions on certain addresses or the use of safe transfer methods for security.",
        "url": 137
    },
    {
        "nl_input": "The query requires a function that consistently returns 0 as the remaining allowance. It seeks to define an allowance mechanism where the remaining tokens available for spending are always zero, irrespective of the tokenOwner and spender parameters. This is demonstrated through a constant return value of 0 in the relevant code logic.",
        "url": 138
    },
    {
        "nl_input": "The query requires a function to forward payment from the sender to the specified address ('to'). It should handle value transfer, ensure the 'to' address is valid, and possibly deduct a fee. The selected code must facilitate transferring the remaining amount after fee deduction and update balances or supply if needed.",
        "url": 139
    },
    {
        "nl_input": "The query requires a function to add an address to the accredited list, ensuring the address is valid and meets specific criteria. The function should handle investor details, including vesting periods, revokability, and investment limits, and emit an event upon successful addition. This ensures proper management and tracking of accredited investors.",
        "url": 140
    },
    {
        "nl_input": "The query requires a function to unpause token transfers, ensuring the owner can resume paused token operations. It involves an \"unpauseToken\" function with owner-only access, invoking a \"token.unpause()\" method to enable transfers. The provided code examples demonstrate this functionality within smart contracts.",
        "url": 141
    },
    {
        "nl_input": "The query requires a function to freeze multiple addresses, allowing an owner to specify a list of addresses and set their freeze status. The function should iterate through the list, update each address's freeze state, and potentially emit an event indicating the change in funds status. Some versions include additional checks or timestamp functionality.",
        "url": 142
    },
    {
        "nl_input": "The query requires a function to create a new Tuber entity with specified attributes, including its name, owner, and price. The function should handle the creation process privately, ensure data type constraints, assign a unique ID to the new Tuber, emit a Birth event, set its price, and transfer ownership from address(0) to the designated owner.",
        "url": 143
    },
    {
        "nl_input": "The query requires a function to return the number of decimals used by a token, as seen in the first code snippet where the function `tokenDecimals` returns the `decimals` value. This indicates the need for a method that specifies token precision in a smart contract.",
        "url": 144
    },
    {
        "nl_input": "The query requires a function to handle the redemption of MTU tokens, allowing users to either withdraw ETH based on their applied units or transfer tokens back to them. It involves checking conditions like timestamp and redeem rate, updating redeemed amounts, transferring funds or tokens, and emitting events for successful redemptions while resetting user-specific data.",
        "url": 145
    },
    {
        "nl_input": "The query requires a function to calculate the number of tokens received for a given amount of wei, based on a specific rate or course. The most relevant code defines a function that directly computes the token amount by dividing the input wei value by the course variable, returning the result as the token count.",
        "url": 146
    },
    {
        "nl_input": "The query requires a function to manage contribution amounts and cap logic, ensuring contributions do not exceed individual or overall caps. It involves calculating the allowable contribution based on existing caps, updating raised amounts, and triggering events when soft or hard caps are reached. The solution should handle minimum contributions and compensate contributors post-campaign if necessary.",
        "url": 147
    },
    {
        "nl_input": "The query requires a function to update the symbol of a token. The desired functionality should allow the symbol to be set or modified, potentially restricted to the owner. It involves a setter function for the symbol, such as `setSymbol` or `setTokenInformation`, enabling updates to the token's symbolic representation.",
        "url": 148
    },
    {
        "nl_input": "The query requires a method to list all deeds associated with an owner without using arrays, serving as an alternative to ERC721Enumerable. The solution should efficiently retrieve deeds by index, ensuring compatibility and avoiding direct array manipulation, thus optimizing performance and resource usage in smart contract implementations.",
        "url": 149
    },
    {
        "nl_input": "The query requires a function to change the contract's owner to a new address specified by the parameter `_owner`. The function should restrict access to the current owner and provide confirmation of the ownership transfer, potentially through an event emission.",
        "url": 150
    },
    {
        "nl_input": "The query requires a function that allows the owner to mint new tokens, specifying the recipient address and the amount to be minted. The function should update the balance of the recipient, increase the total supply, and emit transfer events accordingly, ensuring proper token creation and allocation within the contract.",
        "url": 151
    },
    {
        "nl_input": "The query requires a function to set or update a token address, ensuring it can only be executed by an authorized user (e.g., owner or founder). The function should validate the new address and update the contract's state accordingly, often involving checks like whether the token is already set or if the address is valid.",
        "url": 152
    },
    {
        "nl_input": "The query requires an internal method to create a new EtherDog by specifying its attributes (matron ID, sire ID, generation, genes) and storing it. The method ensures data constraints, initializes the EtherDog's properties, adds it to the EtherDogs collection, emits a birth event, transfers ownership, and returns the new EtherDog's ID.",
        "url": 153
    },
    {
        "nl_input": "The query requires a function to transfer all raised funds to the founder's wallet. It needs a mechanism to ensure that the total balance or specified funds are sent to the founder's address, likely restricted to be called by the owner, ensuring security and proper allocation of funds within a smart contract environment.",
        "url": 154
    },
    {
        "nl_input": "The query requires a function to close betting and determine the champion based on the champion ID. It needs to save the result, mark the bet as closed, calculate the reward for the winning choice, and log the winning details. The relevant code should handle these operations efficiently within a smart contract environment.",
        "url": 155
    },
    {
        "nl_input": "The query requires a function to handle an urgency situation, specifically draining Ether in emergencies. It needs a function that sends a specified amount of Ether to an owner's address, ensuring only the contract owner can trigger this action. The implementation should include security measures like access control and proper return statements to confirm successful transactions.",
        "url": 156
    },
    {
        "nl_input": "The query requires a function for administrators to add claimants, including their address and claim amount, while marking if they have claimed. The relevant code should allow an admin to create a new claimant entry with specified details and store it in a list or structure for further processing.",
        "url": 157
    },
    {
        "nl_input": "The query requires a function to place bets on roulette dozens (first, second, or third). The selected dozen is specified as input (0, 1, or 2), and the function ensures valid input before placing the bet. It focuses on betting logic for dozen selections within a smart contract system.",
        "url": 158
    },
    {
        "nl_input": "The query requires a contract ensuring the signature is valid for a certified, basic account with a sufficiently low gas price and high value. The description focuses on verifying the account's eligibility based on geographical certification, account type, and transaction value, as demonstrated in the provided code examples. It ensures conditions like dust limit value and account verification are met.",
        "url": 159
    },
    {
        "nl_input": "The query requires an internal function that processes loan repayment, assuming the repayment amount is already transferred. It should validate the loan ID, ensure the loan is open, verify repayment amount matches the required tokens, and handle interest or collateral return while updating the loan state to repaid. The function must also emit an event upon successful repayment.",
        "url": 160
    },
    {
        "nl_input": "The query requires a function that can be overridden by test mocks, typically for unit testing purposes. It needs a function allowing comparison or assertion of values to validate expected outcomes against actual results in a testable manner. The focus is on enabling flexible testing through mock overrides, ensuring accurate and modifiable test conditions.",
        "url": 161
    },
    {
        "nl_input": "The query requires a function to retrieve the enemy combination associated with a specific address. If the combination is not personalized, it should return a default initial enemy combination. The result should be an array of enemy slot class IDs representing the enemy combination linked to the given address.",
        "url": 162
    },
    {
        "nl_input": "The query requires a function to read player metadata for migration purposes, specifically as the contract owner. It needs to retrieve details such as player ID, name, address, scores (confirmed and unconfirmed), and activity status using a board hash and player ID as inputs. The function should ensure only the contract owner can access this information.",
        "url": 163
    },
    {
        "nl_input": "The query requires determining the current halving number, which corresponds to a function that calculates the halving based on the current block. The relevant code provides a function `currentHalving()` that returns the halving number by utilizing the `blockHalving` function with the current block as an argument. This meets the requirement to identify the current halving number in a blockchain context.",
        "url": 164
    },
    {
        "nl_input": "The query requires a function allowing the crowdsale owner to withdraw any amount of ether from the contract at any time. The implementation should ensure only the owner can initiate withdrawals and specify the recipient address(es) for transferred funds, with flexibility in defining the amount or proportion of ether to be withdrawn.",
        "url": 165
    },
    {
        "nl_input": "The query requires a function to convert a uint256 WSIC value into a warship structure, extracting specific bits for different attributes. The needed code should define a warship with attributes derived from the WSIC value by bit-shifting and masking operations, constructing and returning the warship object. Only the relevant contract providing this translation logic is suitable.",
        "url": 166
    },
    {
        "nl_input": "The query requires a function that allows only the owner to deliver tokens to ICO investors. The function should specify the recipient address and the amount of tokens to be delivered. It may also include additional parameters such as frozen days for ICO tokens. The focus is on ensuring the function is restricted to the contract owner for security and control.",
        "url": 167
    },
    {
        "nl_input": "The query requires a method to signal a vote for a specific candidate. The method should validate the candidate's eligibility, ensure the voter hasn't voted for the candidate before, and record the vote. It may also involve emitting an event to confirm the voting action and ensuring constraints like block conditions or voter balance are met.",
        "url": 168
    },
    {
        "nl_input": "The query requires a function to calculate the total amount of pending bets in a betting system. Specifically, it involves iterating through a list of bets, checking their states (e.g., waiting for pairing or oracle response), and summing up their values based on these states. The result is returned as a cumulative amount of pending bet values.",
        "url": 169
    },
    {
        "nl_input": "The query requires a function to set the address of a smart contract for delegating execution of methods. The desired function should ensure only the owner can change the delegate address and emit an event upon successful delegation. It involves managing permissions and updating the delegate address dynamically.",
        "url": 170
    },
    {
        "nl_input": "The query requires implementing a Digix price feed functionality, allowing updates to the price feed with blockNumber, nonce, ask, and bid values for 1K Digix. It involves verifying the signature of the provided data, ensuring the new nonce is greater than the previous one, and encoding the updated price feed while adhering to block number constraints.",
        "url": 171
    },
    {
        "nl_input": "The query requires a function to transfer ownership of an estate from one address to another, ensuring the estate exists, validating the addresses, updating related data, and recording the transfer. It involves checking token existence, clearing approvals, removing and adding tokens for respective owners, and emitting a transfer event. The focus is on securely transferring digital assets within a blockchain environment.",
        "url": 172
    },
    {
        "nl_input": "The query requires an internal utility function to finalize a PVE battle, assuming all battle finish requirements are already checked. It should reset warrior actions, update cooldowns, potentially progress dungeon indices, and emit events related to PVE completion. The function must handle warrior data and ensure proper post-battle states without re-verifying battle conditions.",
        "url": 173
    },
    {
        "nl_input": "The query requires a function to retrieve the token balance of a specific user at a given block. The desired code should support querying historical balances using both the user's address and the target block number as parameters, leveraging a method like `balanceOfAt` to achieve this functionality.",
        "url": 174
    },
    {
        "nl_input": "The query requires a function to mint tokens for pre-crowdsale purchases before the crowdsale begins. It needs to ensure that the current time is before the start time, the investor's address is valid, and the total token supply after minting does not exceed the pre-crowdsale cap. The function should then mint the specified number of tokens to the investor's address.",
        "url": 175
    },
    {
        "nl_input": "The query requires an ERC20 transfer function modified to allow transfers only after the sale has been finalized. This involves ensuring the sale completion status is confirmed before executing any token transfers, typically by incorporating a condition that checks the finalization state of the sale within the transfer logic.",
        "url": 176
    },
    {
        "nl_input": "The query requires a function to calculate a rate based on a base rate and a bonus percentage. The most relevant code implements a function that adjusts a base rate by adding a bonus percentage, which depends on certain conditions (e.g., funding thresholds). It then calculates the final rate using the formula: (baseRate * (100 + bonus)) / 100. This matches the query's need for rate calculation with bonuses.",
        "url": 177
    },
    {
        "nl_input": "The query seeks a function to dynamically adjust a rate based on specific conditions or time intervals. The requirement involves calculating rates depending on the current time or certain balances, with potential updates at defined intervals. The focus is on implementing logic that modifies rates according to preset rules or external factors like contract balances.",
        "url": 178
    },
    {
        "nl_input": "The query requires an internal utility function to initiate a PVP battle, assuming all battle requirements are pre-validated. It needs to handle warrior data and matching counts, potentially triggering rewards or battle outcomes, while ensuring the function is restricted to internal use and not exposed to external interactions without proper authorization.",
        "url": 179
    },
    {
        "nl_input": "The query requires a mechanism to ensure a function can only be called once. This involves implementing a condition that checks whether the function has already been executed and prevents further calls after the first execution, typically using a state variable to track the function's execution status.",
        "url": 180
    },
    {
        "nl_input": "The query requires a function to accept contributions only if the user has passed KYC verification. The relevant code should ensure that contributions are accepted based on KYC status, with proper checks and updates to contribution records, ensuring security and correctness in handling contributions post-verification.",
        "url": 181
    },
    {
        "nl_input": "The query requires a function to modify the minimum bet amount with the least changes. It should allow the contract owner to update the minimum bet value, ensuring it's greater than zero. The solution must efficiently implement this adjustment while maintaining contract integrity and functionality.",
        "url": 182
    },
    {
        "nl_input": "The query requires a function to calculate the number of tokens retrievable for a specific amount of Ether invested. It should take an input value representing the investment amount and return the corresponding token amount based on a defined rate or formula. The function must be accessible and capable of performing this calculation accurately.",
        "url": 183
    },
    {
        "nl_input": "The query requires a function to retrieve gift IDs based on a specific template ID. It needs to map template IDs to their corresponding gift IDs, as demonstrated in the referenced code with the function `getGiftsByTemplateId`. The result should return an array of gift IDs associated with the given template ID. Other functionalities, such as updating or validating gifts, are not relevant to this query.",
        "url": 184
    },
    {
        "nl_input": "The query requires a function to be executed after the crowdsale ends, performing finalization tasks such as forwarding funds, enabling refunds, or transferring balances based on goal achievement. It must ensure proper conditions are met (e.g., timestamps, goals) and update the contract's state accordingly. The function should handle both successful and unsuccessful crowdsale scenarios.",
        "url": 185
    },
    {
        "nl_input": "The query requires calculating tokens to be sent to the buyer based on a predefined rate set during deployment. It involves receiving Ether, determining the number of tokens using the rate, ensuring caps are not exceeded, minting or transferring tokens to the buyer, and forwarding the received Ether to a wallet.",
        "url": 186
    },
    {
        "nl_input": "The query requires implementing a distillation process. However, none of the provided code snippets directly relate to a distillation process. The requirement likely involves creating a function or logic that simulates or executes a distillation mechanism, possibly involving separation, refinement, or processing steps. This should be tailored to the specific context or domain where distillation is applied.",
        "url": 187
    },
    {
        "nl_input": "The query requires a function to fortify multiple previously claimed tiles in a single transaction. It involves verifying the amount, ensuring the process is not paused or called by a contract, and using specific parameters like `_claimedTileIds`, `_fortifyAmount`, and `_useBattleValue` to execute the fortification through a service.",
        "url": 188
    },
    {
        "nl_input": "The query requires a function to process purchases during a private sale, ensuring the current stage is private, calculating tokens based on contributed wei, and handling cases where the purchase exceeds available tokens. It includes transferring remaining wei to the beneficiary and updating the sale stage if necessary.",
        "url": 189
    },
    {
        "nl_input": "The query requires a function to transfer tokens from the owner's account to another account, ensuring only the escrow can send tokens for private sales. The function should validate the amount, timing, and addresses involved before executing the transfer using an authorized mechanism.",
        "url": 190
    },
    {
        "nl_input": "The query requires creating a new poll with specified parameters, such as quorum, commit duration, and reveal duration. It involves generating a unique poll ID, setting end dates for commit and reveal phases, and initializing vote counts. The contract should emit an event upon successful poll creation and return the poll ID.",
        "url": 191
    },
    {
        "nl_input": "The query requires determining if the state \"dstWalletLMNO\" is set. It involves ensuring that \"dstWalletLMNO\" is not the zero address before performing operations like debiting tokens from a wallet, maintaining balance checks, and updating token supply in a smart contract environment. The focus is on validating the proper setup of \"dstWalletLMNO\".",
        "url": 192
    },
    {
        "nl_input": "The query requires implementing a mechanism to allow access to slots bankroll only after 60 days. This involves setting conditions to restrict bankroll retrieval until the specified time period has elapsed, likely using modifiers or functions to enforce the timing constraint and ensure proper authorization.",
        "url": 193
    },
    {
        "nl_input": "The query requires a function to transfer approved ERC-20 tokens from a user and provide RMC tokens in return. The provided code examples demonstrate token withdrawal or transfer mechanisms, but the specific requirement is for exchanging user-approved ERC-20 tokens while issuing RMC tokens as part of the transaction logic.",
        "url": 194
    },
    {
        "nl_input": "The query requires determining conditions for releasing the jackpot and identifying the recipient. The provided code snippets focus on different aspects: one handles sending the jackpot balance to a ticket holder under specific conditions, another checks the total jackpot value based on completion status, and the third deals with seeding the jackpot balance. The requirement is to define logic for releasing the jackpot to a winner if conditions are met.",
        "url": 195
    },
    {
        "nl_input": "The query requires a function to calculate the profit from selling a specified number of outcome tokens, considering market fees and ensuring the profit meets a minimum threshold. It involves transferring tokens, updating sale records, and returning the net profit after deducting fees, while validating the transaction constraints.",
        "url": 196
    },
    {
        "nl_input": "The query requires implementing a function to assign asset share tokens to the authors of winning bids. The process involves calculating shares and returns for each bid, updating bid statuses, transferring any return amounts, and maintaining shareholder balances. It ensures all winning bids are processed and shares are correctly allocated before finalizing the assignment.",
        "url": 197
    },
    {
        "nl_input": "The query requires a function to calculate the available tokens for a recipient based on specific conditions and time phases. It involves checking allocations, considering different steps or phases, and ensuring the recipient is eligible. The function should return the total available tokens as a uint256 value.",
        "url": 198
    },
    {
        "nl_input": "The query seeks a function to check the available inventory of a product by its ID. The required code should have a function that takes a product ID as input and returns the available quantity of that product, matching the functionality of the 'availableInventoryOf' function in the provided code samples.",
        "url": 199
    },
    {
        "nl_input": "The query requires a function to mint tokens, adding them to a specified address and updating the total supply. It involves ensuring the recipient address is valid, modifying balances or token IDs accordingly, and emitting transfer events to reflect the minting process. The provided code examples demonstrate variations of token minting mechanisms.",
        "url": 200
    },
    {
        "nl_input": "The query requires implementing a functionality that allows the reservation owner to either close the reservation early or extend its duration. This involves providing the owner with the ability to modify the end time of a reservation or auction, ensuring they can control when it concludes or continues, as demonstrated by the provided code samples.",
        "url": 201
    },
    {
        "nl_input": "The query requires a function to change the lock period, accessible only by the contract owner. It should allow the owner to set or modify the duration of the lock period with specific constraints (e.g., within 1\u201330 days). The function ensures flexibility in adjusting the lock timeframe while maintaining security through ownership restrictions.",
        "url": 202
    },
    {
        "nl_input": "The query requires a mechanism for the owner to return collected ETH to contributors if the soft cap is not reached or KYC checks fail. This involves refunding backers and draining ETH from the contract under specific conditions, ensuring proper validation and transfer of funds back to users based on their contributions.",
        "url": 203
    },
    {
        "nl_input": "The query requires a function to cancel an auction, ensuring the auction is removed, and any related transfers or status updates are executed. It involves verifying permissions, updating auction states, and notifying participants through events. The solution should handle specific item identification and owner validation.",
        "url": 204
    },
    {
        "nl_input": "The query requires a function allowing the contract owner to seed the Jackpot with Ether and retrieve it after the Jackpot is paid. The needed code should include functionality to add funds to the Jackpot, track the seeded amount, and ensure only the contract owner can perform these actions. It must also handle returning the Jackpot funds once paid out.",
        "url": 205
    },
    {
        "nl_input": "The query requires a function to retrieve the sender's information. Specifically, it needs a contract function that uses `msg.sender` to fetch details associated with the sender, such as their address, balance, or player info. The most relevant code should directly return information tied to the sender in a readable format.",
        "url": 206
    },
    {
        "nl_input": "The query requires implementing the tokenRecipient interface, likely involving functions to claim or transfer tokens to a specified address. The needed code should include functionality for claiming tokens on behalf of an investor or minting tokens to a specific address, ensuring compliance with the tokenRecipient interface requirements.",
        "url": 207
    },
    {
        "nl_input": "The query requires a function to handle ETH backup withdrawal, ensuring funds are transferred correctly. It needs a mechanism to check if ETH is present, validate conditions (e.g., ownership, contract stage), and transfer the balance to a specified address while maintaining security and preventing unauthorized access. The solution should include error handling and proper balance management.",
        "url": 208
    },
    {
        "nl_input": "The query requires a function that allows the owner to change the address of the admin. The function should ensure the new admin address is not the same as the owner or the contract itself and may involve emitting an event after a successful change. It also requires validation to confirm the new admin address is valid and not zero.",
        "url": 209
    },
    {
        "nl_input": "The query requires a method to internally zero out mappings for sellers, specifically targeting 'sellerListMapping' and 'sellerToPrice'. The desired functionality should be an internal function that resets these mappings for a given seller without affecting other data structures or performing additional operations. This ensures clean and isolated updates to the specified mappings.",
        "url": 210
    },
    {
        "nl_input": "The query requires a function to transfer land represented by coordinates (x, y) to a specified address. The relevant code provides a function named `transferLand` that encodes the land's coordinates into a token ID and transfers it to the target address, fulfilling the requirement for transferring land in a smart contract system.",
        "url": 211
    },
    {
        "nl_input": "The query requires a function that allows the owner to conclude the loyalty part and initiate the presale phase. The relevant code should include a function callable only by the owner, which sets the loyalty part as finished and records the presale start time using the current block number.",
        "url": 212
    },
    {
        "nl_input": "The query requires a function to handle contract cleanup or shutdown when it's no longer needed, such as after a contract upgrade. It should include conditions to ensure the correct state and time have been reached, and may involve transferring remaining funds or self-destructing the contract to prevent misuse. The solution must be secure and accessible only by the owner.",
        "url": 213
    },
    {
        "nl_input": "The query requires a function to add a new manager. The desired function should allow the addition of a new manager address, ensuring proper authorization and validation. It may involve updating manager statuses, emitting events for changes, and confirming unique manager addresses to prevent duplicates. The function must be secure, accessible only to authorized users, and capable of handling valid manager inputs effectively.",
        "url": 214
    },
    {
        "nl_input": "The query requires a function to stake tokens on behalf of a user, rewarding them with credits. Specifically, it involves a staking mechanism where the caller stakes tokens for a particular user and updates their credit balance based on the staked amount and default lock-in duration. The function should handle token staking and credit rewards accurately.",
        "url": 215
    },
    {
        "nl_input": "The query requires a modifier to verify if a value can fit within a 64-bit unsigned integer. It ensures that the given value, when cast to a 64-bit uint and then back to a 256-bit uint, remains unchanged, confirming it is within the 64-bit range. This is crucial for preventing overflow or underflow in smart contracts.",
        "url": 216
    },
    {
        "nl_input": "The query requires initializing bet data, likely involving setting a ticket price and bet title. This initialization is intended to configure the basic parameters of a betting system or contract, ensuring that essential details are established before the betting process begins. The focus is on defining these initial settings within a smart contract environment.",
        "url": 217
    },
    {
        "nl_input": "The query requires a function to submit a ring for validation and settlement in a smart contract. It involves verifying input data integrity, tokens registration, signatures, assembling orders, and handling the ring with specified fees. The function ensures proper execution through multiple checks and updates the ring index upon completion.",
        "url": 218
    },
    {
        "nl_input": "The query requires a default approval function in a smart contract, allowing the sender to approve a spender to withdraw a specified amount from their balance. The function should update the allowance and emit an Approval event, ensuring that the approval logic adheres to standard ERC20 token behavior, with a boolean return value indicating success.",
        "url": 219
    },
    {
        "nl_input": "The query describes a refund process when the minimum capital (MIN_CAP) is not reached. Backers must approve Devvote token refunds, call the refund function with the specified amount, and withdraw payments in ETH. The code should handle transferring tokens, burning them, and sending ETH refunds to backers. Only the relevant refund logic meeting these criteria should be considered.",
        "url": 220
    },
    {
        "nl_input": "The query requires extracting X and Y coordinates of a curve point for a public key from a smart contract. The relevant code should define a function that takes a node as input and returns the corresponding X and Y coordinates stored in the contract's records. This involves accessing a mapping or storage structure where public key coordinates are saved against specific nodes.",
        "url": 221
    },
    {
        "nl_input": "The query requires a function to return the current Cap value in a smart contract. Specifically, it needs a constant function that retrieves and returns a predefined ICO cap (IcoCap) as a uint256 value without modifying the contract state. This ensures users can check the cap value efficiently.",
        "url": 222
    },
    {
        "nl_input": "The query requires a function to set the ICO status based on specific conditions. It needs to activate the ICO status, update it according to token availability and stages, and determine if the ICO is active based on time constraints. The solution should handle ICO activation, status updates when tokens are sold out, and check if the current time falls within the ICO period.",
        "url": 223
    },
    {
        "nl_input": "The query requires extracting the contract constant `_symbol`. The focus is on a function that returns the symbol as a string in a viewable manner. The relevant code demonstrates a function named `symbol()` that returns the `_symbol` value from the contract. This meets the requirement to retrieve and expose the contract's symbol constant for public access.",
        "url": 224
    },
    {
        "nl_input": "The query requires a function to assign a token address to a variable, callable only by the founder and executable only once. The function should ensure the token address is set securely and irreversibly, preventing multiple assignments. It involves access control and a mechanism to track whether the token address has already been set.",
        "url": 225
    },
    {
        "nl_input": "The query requires a function to return the registered EOS public key for a given address. If the key exists in storage, it should return the stored key; otherwise, it should query the EOS crowdsale key and return that value. The function must be publicly accessible and only involve viewing data without modifying it.",
        "url": 226
    },
    {
        "nl_input": "The query requires a function to transfer tokens from one address to another, ensuring the transfer is authorized and updating balances accordingly. It involves checking token allowances, subtracting tokens from the sender's balance, adding them to the recipient's balance, and emitting a transfer event to confirm the transaction's success.",
        "url": 227
    },
    {
        "nl_input": "The query requires a function to facilitate batch approval for all, allowing multiple spenders to be approved in one operation. It needs to ensure that the spenders' list is not empty and that each spender is valid (not zero address), then set the approval status for all specified spenders accordingly. The implementation should support batch operations efficiently.",
        "url": 228
    },
    {
        "nl_input": "The query requires a function to burn all remaining tokens in the owner's account and adjust the license cost. The selected code should ensure tokens are burned only once, update the total supply, and set the license cost using a numerator and denominator. It must also include necessary checks and logs for transparency and security.",
        "url": 229
    },
    {
        "nl_input": "The query requires creating a new proposal within a smart contract, allowing a user to propose changes, such as transferring ownership or approving transactions. It involves defining a function that accepts parameters like an address and amount, ensures validity through requirements, and updates the proposal state or emits events upon approval.",
        "url": 230
    },
    {
        "nl_input": "The query requires a function to return the number of matches recorded in a contract. Specifically, it needs a public view function that calculates and returns the count of matches (likely stored in an array or similar structure) within the smart contract context. The most relevant code demonstrates a function returning the length of a 'matches' array.",
        "url": 231
    },
    {
        "nl_input": "The query requires a function to allow the core team account to release FT (fungible token) tokens. Specifically, it needs a mechanism where authorized users can trigger the release of tokens assigned to the core team. The focus is on enabling token release functionality tied to the core team's account management.",
        "url": 232
    },
    {
        "nl_input": "The query requires a function to calculate the offset of a given block by determining the remainder when the block number is divided by a specific interval (subsidyHalvingInterval). The relevant code provides a function named `blockOffset` that performs this calculation using the modulo operator. It takes a block number as input and returns the offset value.",
        "url": 233
    },
    {
        "nl_input": "The query requires a function to set the expiry time in milliseconds since 1970, needing a code snippet where an owner can define a timestamp for expiration, ensuring it's properly recorded and possibly triggering an event for notification. The provided codes reference functions that allow owners to set time-related parameters.",
        "url": 234
    },
    {
        "nl_input": "The query requires a function to remove a contract address from the list of active contracts. It needs to locate the contract address, update the list by replacing it with the last active contract, adjust the indices, and finally reduce the list size while ensuring the removed address is no longer active or indexed.",
        "url": 235
    },
    {
        "nl_input": "The query requires a function to transfer or claim ownership of a product. It involves verifying the sender's permission, updating the owner's address, and emitting an event to notify of the ownership change. The solution should ensure only authorized users can initiate the transfer and finalize the ownership update accordingly.",
        "url": 236
    },
    {
        "nl_input": "The query requires a function to set or change the wallet address, ensuring the new address is valid and not the zero address, the contract's own address, or the token address. It may also include an ownership check and emit an event upon successful update. The function should be callable only by the contract owner.",
        "url": 237
    },
    {
        "nl_input": "The query requires a mechanism to safely remove or abort a game, refunding players if possible and updating game status with reasons such as cancellation or timeout. It involves deactivating the game, handling player payments, and maintaining statistics on game terminations. The provided code excerpts demonstrate functions for aborting games, manually removing them, and checking game activity.",
        "url": 238
    },
    {
        "nl_input": "The query requires a function to retrieve the owner of a specific token. The most relevant code should provide a method that maps or returns tokens associated with an owner's address, such as listing owned tokens or balances. Specifically, it needs a function like \"tokensOf,\" \"releasedTokenOf,\" or \"balanceOf\" to achieve this functionality.",
        "url": 239
    },
    {
        "nl_input": "The query requires a function to determine if an entity was created with createUser(), returning true, or createVirtualEntity(), returning false. It involves checking the entity's ownership and status, ensuring it is active and matching it to its owner within the system's registered entities. The focus is on identifying user-created entities versus virtual ones.",
        "url": 240
    },
    {
        "nl_input": "The query requires a function to buy tokens, specifically involving token purchase logic. It needs to handle conditions like sender validation, minimum value checks, rate calculation, token minting, and transferring funds. The function should ensure the total issued tokens do not exceed the hard cap and log the purchase event.",
        "url": 241
    },
    {
        "nl_input": "The query requires a function allowing the owner to set a standard signature that redirects to one of the pre-signed functions. The code should include a mechanism to validate and update the standard signature to one of the predefined signatures, ensuring only the owner can perform this action.",
        "url": 242
    },
    {
        "nl_input": "The query requires a function to retrieve the TOC price. Specifically, it needs a public view function that returns the TOC price as a uint256 value stored in a mapping or variable within a smart contract. The focus is on accessing an existing price value without modifying the contract state.",
        "url": 243
    },
    {
        "nl_input": "The query requires a function to cancel an order on the black market for selling a specific quantity of coke at a certain price. The desired function should locate and remove the corresponding offer from the market, ensuring the seller, quantity, and price ratio match, and emit an event upon successful cancellation.",
        "url": 244
    },
    {
        "nl_input": "The query requires a function to calculate the total lottery amount. It should consider bets, commissions, donations, and fees, ensuring accurate distribution and calculation of amounts. The result must include transferring relevant amounts to owners or charities while maintaining transparency in financial transactions within the lottery system.",
        "url": 245
    },
    {
        "nl_input": "The query requires functions related to game management in smart contracts. Specifically, it needs functions that can handle operations such as retrieving total games, accessing game details (e.g., address, description, URL, submitter), and managing game states like forfeiting a game, updating player balances, and recording game results. The focus is on game data manipulation and retrieval.",
        "url": 246
    },
    {
        "nl_input": "The query aims to verify the validity of contract relationships, ensuring conditions are met without reducing requirements to zero or making them too high. It checks for proper signing of terms and conditions and validates gift statuses within contracts. The focus is on maintaining appropriate contract states and ensuring logical consistency in validations.",
        "url": 247
    },
    {
        "nl_input": "The query requires a helper function for the UI to display the amount of ETH already contributed by a user. The function should take a user address as input and return the contribution amount associated with that user, allowing the UI to present this data effectively.",
        "url": 248
    },
    {
        "nl_input": "The query requires a function to extract an address encoded as the first argument in transaction data. It needs to decode the data, verify its length, and return the address value. The focus is on processing transaction data correctly to retrieve and return the embedded address.",
        "url": 249
    },
    {
        "nl_input": "The query requires determining if a given Day-Index is a Holiday. The relevant code provides a function to retrieve a holiday by its index, checking within predefined lists and ranges. It involves mapping day indices to specific holiday lists and returning the corresponding result. Other codes focus on different functionalities like presale periods and refund poll dates, which are unrelated to the holiday determination task.",
        "url": 250
    },
    {
        "nl_input": "The query requires a function to check if a given address has already invested. It needs a boolean return indicating the presence of the address in the list of investors. The function should iterate through the investor list or use a mapping to determine if the address exists as an investor.",
        "url": 251
    },
    {
        "nl_input": "The query seeks to determine the current stage based on elapsed time since the start. It involves calculating the stage using the difference between the current block timestamp and a start time, divided by a stage duration. The requirement is to extract logic for progressing through stages over time, potentially involving conditions or transitions between stages.",
        "url": 252
    },
    {
        "nl_input": "The query requires implementing a restriction to prevent authorized wallets from withdrawing funds to a specific address. The provided code examples involve fund withdrawal functions with access controls, but the requirement focuses on adding logic to disallow transfers to a particular address as part of the withdrawal process. This ensures certain addresses cannot receive funds during withdrawals.",
        "url": 253
    },
    {
        "nl_input": "The query requires displaying timelock periods and their corresponding locked values. It needs a function that retrieves an array of timelock periods for a given address, adjusting the periods based on predefined offsets (earlier/later). The focus is on presenting the adjusted lock times rather than setting or checking locked states or periods. Other functionalities like locking mechanisms or ownership restrictions are not relevant to this requirement.",
        "url": 254
    },
    {
        "nl_input": "The query requires a function allowing the registry owner to withdraw surplus value. The function should ensure only the owner can initiate the withdrawal and transfer the contract's balance to the owner's address, preventing unauthorized access while ensuring all surplus funds are retrievable.",
        "url": 255
    },
    {
        "nl_input": "The query requires a function to set up a whitelist by adding addresses or configuring its state within a smart contract. This involves enabling or disabling the whitelist, adding specific addresses to it, and ensuring these operations are restricted to the owner and comply with the contract's current stage or status.",
        "url": 256
    },
    {
        "nl_input": "The query requires a function to transfer ownership of a contract to a new Ethereum address. The function should ensure the new owner address is valid and update the ownership accordingly, potentially emitting an event to log the transfer. It must be callable only by the current owner for security reasons.",
        "url": 257
    },
    {
        "nl_input": "The query requires a function that allows the current collector to transfer contract control to a newCollector, ensuring the newCollector's address is valid (non-zero). The function should emit an event indicating the transfer and update the collector variable accordingly. It must also restrict access to the current owner only.",
        "url": 258
    },
    {
        "nl_input": "The query requires a function that caps the reward amount to the minimum of three values: reward, balance, and daily limit remaining. It ensures the reward does not exceed the contract's current balance or the remaining daily limit. The function should take the reward as input, compare it with balance and daily limit, and return the capped value.",
        "url": 259
    },
    {
        "nl_input": "The query requires a function to transfer superOwner authority to a new address, ensuring the current authority confirms the change. The function should emit an event indicating the role transition and update the superOwner variable to the new address provided as an argument. Security checks may also be necessary to ensure valid transfers.",
        "url": 260
    },
    {
        "nl_input": "The query requires a function enabling users to purchase Dragon Ball Z heroes by paying the current price of the hero. Upon purchase, the ownership transfers to the buyer, and the hero's price doubles. A portion of the payment is allocated as developer fees and commissions to the original owner. The process ensures the system is not paused and validates the correct payment amount.",
        "url": 261
    },
    {
        "nl_input": "The query requires a function to determine the total number of bronze caps produced. The relevant code provides a function named `producedBronzeCaps` which returns the amount of bronze caps produced so far using the `packedProducedCaps` variable. Other functions like `totalSupply` and `computeRealCap` are unrelated to the query's needs.",
        "url": 262
    },
    {
        "nl_input": "The query requires a function to update the 'balances' mapping and 'totalSupplyHistory'. It needs to handle token creation by updating the balance of an address and maintaining a history of total supply changes. The relevant code should include logic for modifying the 'balances' map and recording updates to 'totalSupply'.",
        "url": 263
    },
    {
        "nl_input": "The query requires a function to determine if a funding process has been completed successfully. It involves checking the status of funding rounds, transitioning between rounds based on specific caps, and setting a completion timestamp upon success. The function should handle multiple funding stages and confirm the final successful state.",
        "url": 264
    },
    {
        "nl_input": "The query requires a function to set the value of `timePerPeriod` as an array. The most suitable code provides a function `setTimePerPeriod` that accepts a uint array of size 5 and sets it to the `timePerPeriod` variable, ensuring configurability by an authorized user (governor). This meets the requirement for adjusting period durations dynamically.",
        "url": 265
    },
    {
        "nl_input": "The query requires a function that allows the owner to permit a specific address (e.g., a crowdsale contract) to transfer tokens even during a lock-up period. This involves identifying a code snippet where the owner can explicitly authorize token transfers to or from a designated address despite restrictions.",
        "url": 266
    },
    {
        "nl_input": "The query requires a function to handle a player's forfeiture in a game, updating the game state, recording the result as a forfeit, and transferring the game value to the winning player while deducting fees. It ensures the forfeiting player is player 1 and updates won/lost totals for both players.",
        "url": 267
    },
    {
        "nl_input": "The query requires a function to clean up game instances by setting them to inactive, refunding any remaining balances to players, and being callable only by housekeeping routines. It should handle cases where refunds fail and log such events, updating game status and statistics accordingly.",
        "url": 268
    },
    {
        "nl_input": "The query requires a function that allows the contract owner to modify the bonus for the current phase of an ICO. The function should check if the provided bonus differs from the existing one and update it accordingly, while emitting an event to notify about the change. Only the owner can perform this action.",
        "url": 269
    },
    {
        "nl_input": "The query requires a function to add a new animal type in the game 'max'. It needs to handle costs associated with each animal type, ensuring only the owner can execute this function. The solution involves appending the cost of the new animal type and calculating related values based on a fee percentage.",
        "url": 270
    },
    {
        "nl_input": "The query requires a modifier ensuring actions are only executable when the contract is not paused. It seeks a mechanism, such as a `whenNotPaused` modifier, which uses a condition (e.g., `require`) to confirm the contract's active state before allowing function execution, thereby maintaining contract integrity and control.",
        "url": 271
    },
    {
        "nl_input": "The query requires a function to directly mint tokens to a Hash Time-Lock Contract (HTLC). It needs a method that creates new tokens, assigns them to the HTLC contract address, and emits appropriate events like Transfer. The function should ensure the minting process is secure, with proper validations and supply management.",
        "url": 272
    },
    {
        "nl_input": "The query requires a function to change the wallet address, ensuring only the owner can execute it. The function should accept a new wallet address as an argument, validate it (ensuring it's not zero), and update the wallet address accordingly. This ensures security and prevents unauthorized changes.",
        "url": 273
    },
    {
        "nl_input": "The query requires a function to retrieve the namespace associated with a given address using the service locator pattern. The function should check if the namespace is valid based on TTL (time-to-live) and update time, returning an empty string if expired. It involves hashing the namespace, checking registry details, and ensuring the address's namespace is up-to-date.",
        "url": 274
    },
    {
        "nl_input": "The query requires a function to create a free token and transfer it to a specified recipient, ensuring the recipient address is valid and not restricted. The function should also manage token supply limits and track the number of tokens created. It involves token creation, validation checks, and transferring ownership to the recipient.",
        "url": 275
    },
    {
        "nl_input": "The query requires a function or modifier ensuring only the contract owner can execute specific actions. It uses an \"onlyOwner\" modifier with a require statement to verify that the message sender matches the contract owner, preventing unauthorized access. The provided codes demonstrate variations of this modifier with slight differences in syntax and error messages.",
        "url": 276
    },
    {
        "nl_input": "The query requires a mechanism to ensure ETH does not get locked in the contract. The solution should include a modifier or function that prevents locking and allows withdrawal of ETH by the owner, ensuring funds remain accessible and the contract state is not locked.",
        "url": 277
    },
    {
        "nl_input": "The query requires an efficient method to call \"claimAllForInvestor(msg.sender)\". The focus is on a function that processes claims for a specific investor (msg.sender) in a contract, ensuring tokens or allocations are correctly claimed and transferred. This involves identifying a suitable function implementation that performs this action effectively within the given code snippets.",
        "url": 278
    },
    {
        "nl_input": "The query requires a function to return the price of a specific team based on the team ID. The relevant code should have a function that takes a team ID as input and returns the current price of the specified team. This matches the functionality in the first code snippet provided.",
        "url": 279
    },
    {
        "nl_input": "The query requires a function to modify the timestamp for the next steal action. It should accept a time value in seconds and update the 'nextStealTimestamp' by adding the given seconds to the current time ('now'). The function needs to be internal and named appropriately to reflect its purpose of updating the next steal time.",
        "url": 280
    },
    {
        "nl_input": "The query requires a function to return the registration date of a holder. Specifically, it needs a contract function that accepts an address as input and outputs the corresponding registration time stored for that address in the contract's data structure. The function should ensure proper retrieval of the registered timestamp linked to the given holder's address.",
        "url": 281
    },
    {
        "nl_input": "The query requires a function to update the reward rate for a specific token, ensuring the new rate is positive and the token address is valid. It involves iterating through reward sources, matching the token address, and updating the corresponding reward rate while maintaining data integrity and ownership restrictions.",
        "url": 282
    },
    {
        "nl_input": "The query requires functionality for owner creation or activation within a contract. It involves adding or activating an owner address, ensuring it is non-zero, and updating ownership mappings or lists accordingly. The process may include transferring ownership, requiring the new owner address to be valid and updating the owner state.",
        "url": 283
    },
    {
        "nl_input": "The query requires creating a new round in a lottery system, setting a hashed salt and proof of N as secrets. It involves generating a new instance of a lottery round with specific parameters and transferring ownership to the designated owner while ensuring proper initialization and error handling during the creation process.",
        "url": 284
    },
    {
        "nl_input": "The query requires a function to set a soft cap value in a contract, specifically converting the input value by multiplying it with 10^12. The relevant code demonstrates a function named `setSoftCap` that accepts a uint256 parameter and updates the soft cap after scaling it appropriately. This matches the requirement for managing soft cap values in a smart contract context.",
        "url": 285
    },
    {
        "nl_input": "The query requires a function to withdraw tokens other than DGZ to the beneficiary. The suitable code should allow the owner to transfer any token except DGZ to the beneficiary by specifying the token address and amount, ensuring flexibility for withdrawing various tokens while excluding DGZ tokens from this process.",
        "url": 286
    },
    {
        "nl_input": "The query requires a function to set a block as not for sale, ensuring the caller is authorized. It involves identifying the block using coordinates (x, y), verifying ownership, and updating the \"forSale\" status to 0, ultimately emitting an event confirming the block is no longer for sale. Authorization and correct state updates are critical.",
        "url": 287
    },
    {
        "nl_input": "The query requires a function to allow msg.sender to claim their owed tokens. The function should calculate the token allocation for the sender, reset their allocation records, and transfer the tokens to the sender's address. It must ensure proper stages and handle presale/main sale allocations appropriately.",
        "url": 288
    },
    {
        "nl_input": "The query requires a function to retrieve all relevant information about a specific GameItem using its unique token ID. This includes the item's ID, name, selling price, owner address, and associated game ID. The function should be publicly accessible and return these details in a structured format for further use.",
        "url": 289
    },
    {
        "nl_input": "The query requires a mechanism allowing users to claim segments every 1000 units (blocks). The relevant code implements a function `claimSegments` that calculates and distributes rewards based on user contributions and segment entitlements, ensuring claims align with the specified block intervals. It involves validating user states, computing payouts, and updating balances accordingly.",
        "url": 290
    },
    {
        "nl_input": "The query requires a mechanism for exchanging or transferring tokens between addresses, ensuring proper allocation and adherence to predefined rules. The relevant code should handle token claims, allocations, and transfers while considering stages like presales or mainsales, and verifying conditions such as nonzero addresses and sufficient balances.",
        "url": 291
    },
    {
        "nl_input": "The query requires a mechanism to facilitate the sale of presale tokens. It involves purchasing presale tokens by sending value, calculating token amounts based on exchange rates, updating token balances, tracking total tokens sold, and ensuring the sale occurs within designated timeframes and limits. The solution should handle token transfers and maintain accurate records of presale transactions.",
        "url": 292
    },
    {
        "nl_input": "The query requires a mechanism to prevent specific targets from sending or receiving tokens. This involves functions that can restrict token transfers by disabling approvals, removing tokens from addresses, and managing receiver allowances. The implementation should ensure that unauthorized addresses cannot participate in token transactions.",
        "url": 293
    },
    {
        "nl_input": "The query requires a function to remove a specified address from a list or mapping within a smart contract. The function should check if the address exists, remove it by replacing it with the last element in the list, reduce the list length, and ensure proper validation and error handling during the removal process.",
        "url": 294
    },
    {
        "nl_input": "The query aims to determine the end date of a customer's term deposit by utilizing a function that retrieves the termination block for a given address. It focuses on identifying when the term deposit period concludes, ensuring accurate tracking of deposit durations within the system.",
        "url": 295
    },
    {
        "nl_input": "The query requires implementing a function to add a CZR lock with specified parameters: address, start lock time, amount, and lock duration in months. The function checks if the amount is valid, sets the start time if not provided, stores the lock details in a mapping, and triggers an event with the lock information.",
        "url": 296
    },
    {
        "nl_input": "The query requires a function to transfer data layer authority to a new owner. The relevant code demonstrates a function named `transferDataAuthority` that takes an address parameter (`newOwner`) and transfers the authority to this new address, ensuring only the current owner can invoke this action. This meets the requirement for securely transferring control over data.",
        "url": 297
    },
    {
        "nl_input": "The query requires a function to resolve a challenge for a given `_propID`. It involves checking the proposal's status, determining if the challenge is passed, updating the challenge's resolution status, distributing rewards, and emitting events for challenge success or failure based on voting outcomes. The function ensures proper reward distribution to either the proposal owner or challenger.",
        "url": 298
    },
    {
        "nl_input": "The query requires a function to decrease the approved amount of tokens for a spender. It should take the spender's address and the value to decrease as inputs, update the allowed amount accordingly, and emit an Approval event with the updated allowance. The function must ensure that the new allowance does not go below zero.",
        "url": 299
    },
    {
        "nl_input": "The query requires a function to whitelist a list of addresses. The desired functionality involves iterating through an array of addresses and setting each address as whitelisted (true) in a mapping. The solution should be implemented within a smart contract, ensuring only authorized users can modify the whitelist.",
        "url": 300
    },
    {
        "nl_input": "The query requires identifying a function that is exclusively called by the \"shiftSale\" process. The focus is on the \"shiftSalePurchase\" function within the provided code, which is invoked only from shiftsale, as indicated in the description. This function executes a purchase and returns a boolean value confirming success.",
        "url": 301
    },
    {
        "nl_input": "The query requires extending the OpenZeppelin StandardToken's transferFrom function to include snapshot functionality. Specifically, it involves taking snapshots of the sender's and recipient's balances before executing the token transfer. This ensures that balance states are recorded at specific points in time, facilitating features like historical balance tracking or checkpoint creation.",
        "url": 302
    },
    {
        "nl_input": "The query requires a function to check the amount of tokens delegated from an owner to a spender. It needs to ensure that the spender has been allocated a specific number of tokens by the owner, likely involving a verification process to confirm token ownership or delegation. The solution should include functionality to validate token amounts and relationships between owner and spender.",
        "url": 303
    },
    {
        "nl_input": "The query requires a function to add intervals in a data structure, specifically within a contract environment. It involves creating interval IDs, managing nodes in a tree structure, and recursively finding the correct position to insert the interval based on begin and end values. The primary focus is on implementing logic for inserting intervals while maintaining tree organization.",
        "url": 304
    },
    {
        "nl_input": "The query requires a function to withdraw tokens only after the crowdsale has ended and been finalized. The solution should ensure that the withdrawal is restricted to post-crowdsale finalization, confirming the process is complete before allowing token transfers. It must involve checks for finalization and closure before executing the token withdrawal.",
        "url": 305
    },
    {
        "nl_input": "The query requires a function to return the balance of tokens owned by a specific address (Owner). The function should be named `balanceOf`, take an address as input, and return a uint value representing the token balance. It involves mapping or storing balances associated with each owner's address in a blockchain contract.",
        "url": 306
    },
    {
        "nl_input": "The query requires a function to update the Token address, ensuring it can be changed by an authorized user (e.g., owner or founder). The function should accept a new token address as input, validate it if necessary, and update the current token address in the contract. Some implementations may include additional checks, such as ensuring the address is not zero or that the token address has not already been set.",
        "url": 307
    },
    {
        "nl_input": "The query requires updating a board's status based on the losing color in a game. Specifically, if the losing color is Black, the board status should be updated to indicate a White win, and vice versa. The function must handle invalid colors by reverting the process.",
        "url": 308
    },
    {
        "nl_input": "The query requires a function to determine if an event has ended, returning a boolean value. It should check whether the current time exceeds the end time or if there are no tokens left. Alternatively, it could simply return a predefined state variable indicating if the event is finalized. The focus is on evaluating the event's status dynamically or through a set condition.",
        "url": 309
    },
    {
        "nl_input": "The query requires a method to check if a given address is an eligible burner. The relevant code should contain logic that verifies whether a specific address is authorized as a burner by checking against a list or condition, ensuring only approved burners can proceed with burner-related actions. This involves using modifiers or functions to enforce eligibility rules for burning tokens.",
        "url": 310
    },
    {
        "nl_input": "The query requires a function to handle multisig transactions with adjustable unlock times and deposit values. Specifically, it needs to update the deposit by adding msg.value and allow modifying the unlock time under certain conditions. The solution should ensure proper handling of multisig structures and maintain security assertions for time constraints.",
        "url": 311
    },
    {
        "nl_input": "The query requires a function to calculate and remove rotten potatoes from a user's cellar, transferring the rotten amount to trash while updating the last recycle timestamp. It involves checking elapsed time, determining the quantity of rotten potatoes based on decay rate, adjusting the user's cellar balance, and recording the transaction.",
        "url": 312
    },
    {
        "nl_input": "The query requires a function to retrieve the renewal interval of a product in seconds. Specifically, it needs a mapping or storage where product IDs are associated with their intervals, and a function that takes a product ID as input and returns the corresponding interval value in seconds. The first code snippet demonstrates this functionality accurately.",
        "url": 313
    },
    {
        "nl_input": "The query requires a function allowing users to withdraw owed values recorded under addressToFailedOldOwnerTransferAmount. The function should check if the value is greater than zero, reset the recorded amount, update total failed transfer amounts, and transfer the owed value to the user's address. This ensures proper withdrawal of funds associated with failed old owner transfers.",
        "url": 314
    },
    {
        "nl_input": "The query requires a function to calculate winnings based on a given bet and percentage. It needs to multiply the bet by the percentage and then divide by 100 to determine the winnings amount, using safe mathematical operations to prevent overflow or underflow issues in a smart contract environment.",
        "url": 315
    },
    {
        "nl_input": "The query requires a function allowing both Owner and Admin roles to change the admin address, ensuring the new address is valid and not the same as the owner or contract address. The solution should include a mechanism to confirm the address change and return a success status.",
        "url": 316
    },
    {
        "nl_input": "The query requires a function to simulate the creation of a leaderboard hash using a name and admin address, returning a unique hash value. It involves generating a hash with inputs like 'name' and 'admin' to establish a distinct identifier for leaderboard entries using cryptographic hashing (e.g., keccak256).",
        "url": 317
    },
    {
        "nl_input": "The query requires setter methods that operate only when the state is unlocked. The focus is on ensuring that certain functions or modifiers can alter the state or properties of a contract, but exclusively under the condition that the contract is not in a locked state, as indicated by a boolean variable.",
        "url": 318
    },
    {
        "nl_input": "The query requires a function to add content to an agreement, including details like name, description, and reward. The most relevant code should allow adding content with these parameters, ensuring proper validation and execution. Specifically, it needs a function that accepts strings for name and description, along with a uint for reward, and returns a boolean indicating success.",
        "url": 319
    },
    {
        "nl_input": "The query requires a function to update the rate for a specific round, allowing modification of the rate associated with a given round number. It involves setting or adjusting a rate value within a predefined structure for rounds, ensuring the round number is valid before making changes.",
        "url": 320
    },
    {
        "nl_input": "The query requires a function to mark products by adding a product account and hashing the item's public key using sha3. The code should ensure active product, brand, and app statuses, check permissions, record markings, emit events, and handle fees with token transfers. Only the relevant functionality from the provided code should be extracted to meet these requirements.",
        "url": 321
    },
    {
        "nl_input": "The query requires a function to end an auction, ensuring it transitions to the \"Ended\" state, triggers an event with the highest bidder and bid details, and transfers the highest bid amount to the auction owner. It must also prevent execution if the auction is already ended.",
        "url": 322
    },
    {
        "nl_input": "The query requires a function to retrieve an owner's address using a 0-indexed position from a list or mapping. The desired implementation should take an index as input and return the corresponding owner's address, ensuring the index is adjusted if the list is 1-indexed internally. This functionality allows for accessing specific owners in a contract efficiently.",
        "url": 323
    },
    {
        "nl_input": "The query requires a function to set an initial date and token address, ensuring proper ownership and distribution conditions. It involves configuring sale parameters, setting start and end dates, and verifying the token's total supply and ownership before finalizing the setup stage. The focus is on initializing token-related configurations with specific validation checks.",
        "url": 324
    },
    {
        "nl_input": "The query requires a function to return the ticket price for a bet. Specifically, it needs a public view function that retrieves and returns the stored ticket price value in a smart contract, expressed in Wei or a similar unit. This allows users to check the cost associated with participating in the bet.",
        "url": 325
    },
    {
        "nl_input": "The query requires a function that handles the purchase of tokens during a token sale, ensuring conditions like sale timing, token availability, purchase limits, and pricing are met. It should also manage token transfer, update sold token count, adjust prices dynamically based on sold tokens, and handle refunds for excess payments.",
        "url": 326
    },
    {
        "nl_input": "The query requires a function to enable token transfers, burn unsold tokens, and set the token offering address to zero. The solution should include logic to activate transfers, calculate and destroy leftover tokens, and ensure the contract's token offering address is reset to 0 after the process.",
        "url": 327
    },
    {
        "nl_input": "The query requires a function to place a bet using an Access Code and Mode parameter. The function should validate the bet amount, ensure the game limit per block isn't exceeded, and determine winnings based on random number generation and odds calculation. It must also track player participation and handle payments accordingly.",
        "url": 328
    },
    {
        "nl_input": "The query requires a function to compute the transcoder status by checking if a given address is registered as a transcoder. It should return a status indicating whether the transcoder is registered or not, using a predefined status enum for clarity. The relevant code demonstrates this functionality with a conditional check.",
        "url": 329
    },
    {
        "nl_input": "The query requires a function to fill a buy order using a corresponding sell order. It involves calculating tokens obtained, managing ether remaining, and interacting with trading functions from different exchanges (e.g., EtherDeltaTrader or ZrxTrader). The process includes validating fees, determining fill amounts, and ensuring proper transaction execution while updating balances accordingly.",
        "url": 330
    },
    {
        "nl_input": "The query requires a mechanism to enable token transfers once trading has started. Specifically, it needs a function that activates token transfer functionality when called, ensuring tokens can be moved between addresses after trading begins. This involves setting a status or condition that permits transfers in a token contract.",
        "url": 331
    },
    {
        "nl_input": "The query requires a function to determine the available allocation for a given address, considering time-based token releases. It needs to check if tokens are accessible based on predefined steps (step1, step2, step3) and sum the allocations accordingly. The function should ensure the recipient is eligible and return the total available tokens.",
        "url": 332
    },
    {
        "nl_input": "The query requires a function that allows admins to transfer and lock a value, with the ability to set a release time for the locked funds. The function should ensure that only authorized users can invoke it, potentially limiting the transfer and lock action through administrative privileges.",
        "url": 333
    },
    {
        "nl_input": "The query requires transferring ether to the beneficiaryAddress. It needs a function that takes an address and transfers a specified amount of ether to it, ensuring the transfer is secure and the balance sufficient. The solution should involve a method to send funds, possibly with access restrictions, like only allowing the owner to initiate the transfer.",
        "url": 334
    },
    {
        "nl_input": "The query seeks a function to retrieve the address of the library founder based on a token ID. It requires a mapping or storage mechanism (e.g., `libraryIndexToFounder`) to associate token IDs with founder addresses and validate that the founder address is not zero. The implementation should be publicly accessible and part of a smart contract.",
        "url": 335
    },
    {
        "nl_input": "The query requires a function that allows users to delete their accounts. The selected code provides a deleteUser() function, which removes the user's information from address and user directories, ensuring no data remains associated with the user's address, and emits a UserDeleted event to confirm the action.",
        "url": 336
    },
    {
        "nl_input": "The query requires a function that enables buyers to claim tokens they have purchased previously. The function should handle token allocation, ensure the correct stage of trading, and transfer the appropriate amount of tokens to the buyer's address while resetting their allocation records.",
        "url": 337
    },
    {
        "nl_input": "The query requires a function to transfer tokens from the caller's address to a new holder's address, ensuring the transfer amount is within the caller's token balance. The function should validate the transfer parameters, deduct the tokens from the caller's balance, and add them to the recipient's balance, potentially triggering a transfer event.",
        "url": 338
    },
    {
        "nl_input": "The query requires a function to check if the sale is properly configured and has not ended. It needs to ensure that the sale status reflects whether it is active or if it has concluded, focusing on conditions such as timing and configuration flags. The solution should confirm the sale's eligibility based on predefined parameters like start/end times or specific enablement settings.",
        "url": 339
    },
    {
        "nl_input": "The query requires calculating the total Ether amount needed to purchase an item, considering fees and available balance. It involves functions that handle Ether transactions, fee calculations, and ensuring sufficient balance for a successful purchase. The focus is on determining the exact Ether amount required, including any applicable fees or tiered rates.",
        "url": 340
    },
    {
        "nl_input": "The query requires a function to calculate and return the bonus based on the current ICO stage and timestamp. It involves checking the ICO state, comparing the current time with predefined stages, and adjusting the bonus accordingly. The function should handle both pre-ICO and main ICO phases, ensuring the correct bonus is returned depending on the time and stage.",
        "url": 341
    },
    {
        "nl_input": "The query requires a function to finalize the crowdsale and permanently stop minting tokens. It needs to ensure that the crowdsale is marked as finished, minting is halted, and any related actions like fund forwarding are executed. The solution should involve setting finalization flags and invoking token minting completion methods.",
        "url": 342
    },
    {
        "nl_input": "The query requires a function to participate in an airdrop, ensuring the participant meets specific conditions: limited participants, within the airdrop time frame, and no prior participation. The function should also issue tokens to the participant and update the participant count.",
        "url": 343
    },
    {
        "nl_input": "The query requires a function to retrieve ELHT token information based on a given Token ID, with a maximum of 64 tokens. It needs to interact with the ERC20 token standard, likely using methods like balanceOf to check token balances and possibly transfer tokens, ensuring the correct token information is returned according to the specified Token ID.",
        "url": 344
    },
    {
        "nl_input": "The query requires a contract function allowing the owner to authorize redemptions in units of 1/1000 ETH. The solution needs to ensure authorized addresses can redeem specific amounts, with proper balance checks and transfer logic implemented. Specifically, it involves managing redemption rates, balances, and transferring ether or tokens accordingly.",
        "url": 345
    },
    {
        "nl_input": "The query requires a function allowing the owner to transfer ether, either to an updated contract or another address. It should include parameters for specifying the target address and amount, ensuring the amount does not exceed the contract's balance, and confirming successful transfer execution. The provided codes serve as examples of fund-moving functions with owner restrictions.",
        "url": 346
    },
    {
        "nl_input": "The query requires identifying the address of an Oracle contract that implements the OracleInterface. The code demonstrates interactions with oracle contracts, including proposing oracles with IPFS hashes and managing balances. The requirement focuses on ensuring the Oracle contract's address is correctly specified and adheres to the OracleInterface standard for proper functionality.",
        "url": 347
    },
    {
        "nl_input": "The query requires a function to create a trade offer using `msg.value`. The function should ensure that both `msg.value` and a specified setting parameter are greater than zero before proceeding with the offer creation. It involves implementing logic for initiating offers in a contract-based trading system.",
        "url": 348
    },
    {
        "nl_input": "The query requires a function to check or update the token balance for a specific address. It involves functionality where balances can either be retrieved or toggled based on certain conditions. The most relevant code should allow updating or retrieving the balance associated with a token holder's address.",
        "url": 349
    },
    {
        "nl_input": "The query requires a function to check the results of a fundraiser in USD, converting the raised balance using a predefined rate. The most relevant code provides a function that calculates the fundraiser's outcome by multiplying the contract's balance with a conversion rate and returning the result in a suitable format, likely representing the equivalent value in USD based on the given rate.",
        "url": 350
    },
    {
        "nl_input": "The query requires a function to track and manage reward balances distributed from a token pool. It involves maintaining balances, calculating available tokens, and ensuring proper distribution while updating the pool's balance and recipient's rewards accurately. The solution should handle multiple recipients and token types dynamically.",
        "url": 351
    },
    {
        "nl_input": "The query requires a function to collect service/affiliate fees for a buy transaction. It needs to calculate the fee based on the ethers amount, ensure sufficient balance for the fee deduction, and transfer the fee to the specified affiliate address while returning the remaining ethers after fee collection.",
        "url": 352
    },
    {
        "nl_input": "The query requires an internal function to verify if transferring a specific token is allowed, involving checks such as logic contracts, sender conditions, or exceptions. It ensures specific rules (e.g., vesting dates, transfer allowances) are met before permitting token transfers. The focus is on evaluating transfer permissions based on predefined criteria within the contract.",
        "url": 353
    },
    {
        "nl_input": "The query requires overriding the `transferFrom` function in a MintableToken contract to include KYC (Know Your Customer) logic. This involves ensuring that the transfer complies with KYC requirements before allowing the token transfer, typically by checking a KYC status for the sender or recipient. The implementation should integrate this compliance check into the existing transfer functionality.",
        "url": 354
    },
    {
        "nl_input": "The query requires a function to change the address associated with a specific role. The desired functionality should allow modification of an address for a given role, ensuring proper authorization and updating related mappings or arrays to reflect the new address assignment accurately.",
        "url": 355
    },
    {
        "nl_input": "The query requires a function to withdraw ZRX tokens, ensuring they can be retrieved by an admin if a new contract version is deployed. The relevant code should include a function that transfers a specified amount of ZRX tokens to an admin address, using the token's transfer method and restricting access to authorized users only.",
        "url": 356
    },
    {
        "nl_input": "The query requires a modifier to ensure that transfers are only allowed after the minting process has been completed. This involves checking if minting is finished before enabling transfer functionality, typically using a boolean flag like `mintingFinished` to control the flow and restrict actions until minting concludes.",
        "url": 357
    },
    {
        "nl_input": "The query requires a function to refund investors if the softcap is not reached and the sale period has ended. The function should check conditions like unsuccessful sale, contribution amount, and time constraints, then transfer the invested funds back to the sender while updating related records and emitting appropriate events.",
        "url": 358
    },
    {
        "nl_input": "The query requires a function to determine if the contribution period is currently active, ensuring that the hard cap is not reached, the system is enabled, and the current time is within the specified start and end times. The most relevant code provides a boolean return based on these conditions.",
        "url": 359
    },
    {
        "nl_input": "The query requires an internal function to manage ICO status when tokens are sold out. It should check the available tokens for different ICO stages (PrivateICO, PreICO, ICO_w1, ICO_w2) and update the status to \"Waiting\" or \"Closed\" accordingly, ensuring proper transition based on token availability.",
        "url": 360
    },
    {
        "nl_input": "The query requires a function that allows the owner to add addresses which can burn tokens. Specifically, it needs a mechanism where the contract owner can whitelist or designate certain addresses with the permission to perform token burning operations. This ensures controlled access for token destruction within the system.",
        "url": 361
    },
    {
        "nl_input": "The query requires a function to allow a wallet to claim ownership of an account. The desired function should transfer ownership from the current owner to a pending owner, ensuring the transaction occurs within a specified block range and resetting the pending owner afterward. It involves transferring ownership and updating related addresses.",
        "url": 362
    },
    {
        "nl_input": "The query requires a function to buy a collectible item, likely involving payment processing and fee collection. The most relevant code includes a function to calculate and deduct fees during the purchase, ensuring sufficient balance and transferring the remaining amount after fees. It involves operations like collecting fees, checking balances, and executing the purchase with affiliate considerations.",
        "url": 363
    },
    {
        "nl_input": "The query requires a function to determine the next minimal bid or final bid for auctions, considering if the auction has ended. It needs to check existing bids, calculate the minimal raise if applicable, and return the appropriate bid value based on whether the region is owned or currently being bid on.",
        "url": 364
    },
    {
        "nl_input": "The query requires a function to create promo narco up to a specified limit. The function should include parameters for narco genes, name, and owner address, ensuring the owner is not null and incrementing the promo creation count while checking against the promo creation limit. This involves creating a narco entity with given attributes.",
        "url": 365
    },
    {
        "nl_input": "The query requires modifying fundamental ICO parameters, such as bonus rates or token supply, before the ICO starts. It involves functions allowing the owner to update bonuses for Pre ICO and Main ICO phases, set the ICO token supply with constraints, or adjust prices based on ICO stages. These changes ensure flexibility in ICO configuration while maintaining integrity.",
        "url": 366
    },
    {
        "nl_input": "The query requires a function that allows the override address to be changed only by the current override address. The function should take a new override address as an argument, update the override address, and emit an event notification confirming the change. The implementation must ensure that only the current override address can invoke this functionality.",
        "url": 367
    },
    {
        "nl_input": "The query requires a function to approve multiple token IDs at once. It needs a loop to iterate through an array of token IDs, ensuring the sender owns each token and setting approvals individually for each token ID, while emitting an Approval event for every approved token.",
        "url": 368
    },
    {
        "nl_input": "The query requires a function to buy DOL tokens from VAULT by sending ETH. The code should facilitate the transfer of ETH to the VAULT contract and receive DOL tokens in return, ensuring proper balance updates and transaction execution between the user and the VAULT contract.",
        "url": 369
    },
    {
        "nl_input": "The query requires a function to handle the finalization of a crowdsale, ensuring the process is executed only once, transferring remaining tokens or funds to a specified wallet, and confirming the successful completion of the crowdsale. The function should include necessary validations, such as checking if the sale is already finalized or if goals are met.",
        "url": 370
    },
    {
        "nl_input": "The query requires initiating a poll using canonical parameters, as indicated by the PollCreated event. It needs a function that creates a poll with specified vote quorum, commit duration, and reveal duration, emitting an event with these details. The solution should involve creating a poll instance, setting its properties, and ensuring proper initialization before emitting the event.",
        "url": 371
    },
    {
        "nl_input": "The query requires a function to set an individual cap for stage 2 of a crowdsale. The needed code should allow setting a maximum allocation per investor for stage 2, ensuring control over investment limits. This involves a function that accepts a uint256 value as the cap and assigns it to the stage 2 allocation variable, accessible only to authorized users.",
        "url": 372
    },
    {
        "nl_input": "The query requires calculating possible withdraw tokens for sellerBalances. The relevant code demonstrates a withdrawal function transferring tokens to a seller based on balance calculations, involving token balances and IOU adjustments. It focuses on accurately determining the number of tokens to transfer during withdrawal while ensuring proper balance management and ownership validation.",
        "url": 373
    },
    {
        "nl_input": "The query aims to retrieve specific information related to price feeds, such as retrieving previous price feed data (block number, nonce, ask, bid), verifying signatures, and encoding new price feeds. It also involves functions to get ticket prices or asset prices with recency checks, ensuring the latest and valid price information is obtained.",
        "url": 374
    },
    {
        "nl_input": "The query requires a function to set a security check report URI. The function should allow an authorized user (owner) to update the URI value, ensuring it can be changed as needed for security or configuration purposes. The selected code demonstrates this functionality with the `setSecurityCheck` method.",
        "url": 375
    },
    {
        "nl_input": "The query requires a function that calculates the number of tokens purchasable with a given wei amount. It should consider different rates based on the wei amount and return the token amount accordingly. The function needs to handle internal rate calculations, ensure proper conversion, and may include conditions for minimum purchase thresholds or rate tiers.",
        "url": 376
    },
    {
        "nl_input": "The query requires a function to set the sale status of an account. It needs a method that accepts an account address and a boolean value to enable or disable the sale status for that specific account, ensuring proper authorization and validation before updating the status in the contract's state.",
        "url": 377
    },
    {
        "nl_input": "The query requires a method to calculate the Developer's Cut in a game, specifically extracting logic that determines the developer's percentage or share from a given price or fund. This involves multiplying the total amount by a developer-defined cut rate and dividing it to obtain the final cut value. The focus is on private or internal functions handling such calculations within smart contracts.",
        "url": 378
    },
    {
        "nl_input": "The query requires adding functionality to the StandardToken methods, specifically focusing on internal functions for minting tokens and adding balances. The desired implementation involves ensuring non-zero addresses, updating token balances using safe arithmetic operations, and emitting transfer events when minting tokens. The provided code demonstrates examples of these functionalities.",
        "url": 379
    },
    {
        "nl_input": "The query requires a mechanism to restrict function calls to authorized accounts only, throwing an error if an unauthorized account attempts to call it. This involves using modifiers or functions that check the caller's address against a list of authorized addresses or specific roles (e.g., owner, depositor, beneficiary) before allowing execution.",
        "url": 380
    },
    {
        "nl_input": "The query requires a function to set the deposit gas cost using a specified value. The relevant code defines a function named `setDepositGasCost` which accepts a parameter `gasCost` and assigns it to the `depositGasCost` variable, ensuring the gas cost can be updated as needed. Only authorized users can execute this function.",
        "url": 381
    },
    {
        "nl_input": "The query requires implementing a token transfer function that sends _value tokens to _to from msg.sender, involving a fallback mechanism for token reception. The description includes transferring tokens, ensuring proper sender and receiver addresses, and updating the total tokens received, utilizing internal functions for token management and fallback execution.",
        "url": 382
    },
    {
        "nl_input": "The query requires implementing a function to transfer ERC20 tokens from a contract to the owner. It involves using the ERC20 interface to interact with token contracts, ensuring only the owner can initiate the transfer, and specifying the token address and amount as parameters. The function should return a boolean indicating success. Safe transfer methods and balance checks are optional enhancements.",
        "url": 383
    },
    {
        "nl_input": "The query requires implementing a function to disable token transfers in a smart contract. This involves setting a condition or flag to prevent the transfer of tokens between addresses until explicitly re-enabled. The solution should ensure that no tokens can be moved while the transfer is disabled, potentially involving checks and modifiers to enforce this restriction.",
        "url": 384
    },
    {
        "nl_input": "The query requires a mechanism to restrict token transfers based on the tradingOpen modifier, which depends on whether the sale is closed or if the date is past December 24, 2017. The relevant code should implement a function that controls the transfer of tokens according to these conditions. Specifically, it needs to ensure transfers are allowed only when tradingOpen is true.",
        "url": 385
    },
    {
        "nl_input": "The query requires a modifier to ensure actions are only executable when funds are not locked. The relevant code should include a modifier that checks the status of a \"locked\" variable, allowing execution only if the funds are unlocked, typically implemented using a require statement with a negated condition (!locked).",
        "url": 386
    },
    {
        "nl_input": "The query requires an internal function for handling ETH refunds during stage three. It should ensure the contract stage is three, verify the sender's authorization, confirm the refunded value meets the minimum contribution, store the refund amount, and log the refund event with the sender's information and value.",
        "url": 387
    },
    {
        "nl_input": "The query requires a function to send bonus funds to a contract, ensuring proper conditions are met, such as sender authorization, bonus limits, and updating bonus-related values. The code should handle bonus allocation, track bonuses sent, and manage balances or rewards accordingly in a secure and controlled manner.",
        "url": 388
    },
    {
        "nl_input": "The query requires a function to calculate the token amount based on input value. It should take a parameter like 'amount' or '_value' and return the corresponding token quantity, potentially involving multiplication with a rate or price, and may include conditions for zero values. The function is expected to be part of a smart contract and publicly accessible.",
        "url": 389
    },
    {
        "nl_input": "The query requires a function to withdraw ETH from a contract, typically accessible only by the owner. It involves transferring the contract's balance to the owner's address. Some variations include specifying an amount to withdraw or splitting the withdrawal between multiple addresses, but the core functionality focuses on withdrawing funds while ensuring proper authorization and balance handling.",
        "url": 390
    },
    {
        "nl_input": "The query requires a function that updates a specific parameter or setting within a smart contract. This includes updating permissions, toggling features, or modifying contribution thresholds. The function should be accessible only to authorized users and may involve emitting an event to log the update.",
        "url": 391
    },
    {
        "nl_input": "The query requires overriding the token purchase function to send extra tokens to registered addresses. It needs a mechanism to identify registered beneficiaries and allocate additional tokens during the purchase process, likely involving internal processing of token amounts and ensuring the address is valid and eligible for extra tokens.",
        "url": 392
    },
    {
        "nl_input": "The query requires a function to return the total amount of tokens as a uint256 value. The function should be publicly accessible and constant/view, ensuring it does not modify the contract's state. It must return the total supply of tokens stored in a variable, either named \"totalSupply\" or similar.",
        "url": 393
    },
    {
        "nl_input": "The query requires a function to set the status of developers in a smart contract, allowing an owner to update whether an address is considered a developer. It involves managing developer roles by associating addresses with their respective statuses and emitting an event to notify changes in developer status. Reference code demonstrates setting developer status through a public function.",
        "url": 394
    },
    {
        "nl_input": "The query requires a function allowing users to set rabbit data using a signed message from the COO. The function should verify the signature, ensure the task ID is unused, and update the rabbit's attributes (explosive, endurance, nimble) accordingly. It must also emit an event upon successful update.",
        "url": 395
    },
    {
        "nl_input": "The query requires a function to deposit tokens in a game for a specific user. The function should handle token transfer, ensure the amount is valid, and possibly associate the deposit with a user or entity. It may also involve events or internal functions to manage the deposit process securely.",
        "url": 396
    },
    {
        "nl_input": "The query requires a function to set the price per token for pre-ICO addresses, allowing it to be disabled by setting the price to 0. It involves managing pre-ICO addresses and their associated token prices, ensuring flexibility in updating or disabling these prices as needed.",
        "url": 397
    },
    {
        "nl_input": "The query requires a mechanism to update prices if the last update was more than one day ago. It involves checking the time elapsed since the last update, updating the price if necessary, and recording the current update time. The solution should dynamically adjust prices based on predefined growth rates or conditions and trigger an event upon successful adjustment.",
        "url": 398
    },
    {
        "nl_input": "The query requires a function to freeze multiple accounts simultaneously. It needs to accept an array of addresses and a boolean value indicating the freeze status, then iterate through the array to update each account's freeze status while triggering an event for each action. The implementation must ensure proper validation and ownership control.",
        "url": 399
    },
    {
        "nl_input": "The query requires a function to update the payout for burritos owned by a specific owner. It calculates the owed amount based on the burrito's payout percentage, updates the withdrawn amount for each burrito, and finally increases the owner's payout balance by the total owed. The process involves iterating through the owner's burritos and performing calculations based on pool totals and individual burrito data.",
        "url": 400
    },
    {
        "nl_input": "The query requires an admin function to withdraw PLAT balance. The desired function should allow an authorized user (admin/owner) to withdraw the PLAT token balance from the contract, ensuring only the designated authority can perform this action while transferring the full or specified token amount to the sender's address.",
        "url": 401
    },
    {
        "nl_input": "The query requires a function to verify if all contributors' tokens have been successfully distributed. It needs to iterate through a list of contributors, checking each one's distribution status, and confirm that all tokens are distributed before returning a successful result. The function should handle cases where any contributor has not received their tokens.",
        "url": 402
    },
    {
        "nl_input": "The query requires a function to handle contributor-related operations in a smart contract, such as retrieving contributor IDs, compensating contributors based on their contributions, or checking the distribution status of tokens among contributors. The focus is on managing contributor data, ensuring compensation, and verifying token distribution.",
        "url": 403
    },
    {
        "nl_input": "The query requires a function to check the allowance, specifically the amount that _spender can withdraw from _owner's account. The relevant code provides a constant function 'allowance' which returns the remaining balance that can be withdrawn by _spender from _owner's account, utilizing the 'allowed' mapping structure.",
        "url": 404
    },
    {
        "nl_input": "The query requires a function to calculate the amount of tokens returnable for a user based on input parameters. Specifically, it needs logic to determine token amounts corresponding to a user's input value, potentially involving conversions or calculations like buying tokens with another token and updating user balances accordingly. The focus is on accurate token computation and user balance management.",
        "url": 405
    },
    {
        "nl_input": "The query requires a function to start an auction, ensuring the auction status transitions from pending to active, emitting an event with the current block number. It involves initializing the auction process, verifying conditions for creation, and potentially escrowing items while setting auction parameters like start price, end price, and duration.",
        "url": 406
    },
    {
        "nl_input": "The query requires a function to reenable functionality after a freeze has been initiated. Specifically, it needs code that can unfreeze transfers or actions within a contract, ensuring normal operations resume post-freeze. The solution should involve an owner-only or authorized function to reset freeze conditions and notify users if necessary.",
        "url": 407
    },
    {
        "nl_input": "The query requires a function to finalize the token generation event, ensuring unsold tokens are returned, minting is completed, and the finalization status is updated. It involves operations like stopping minting, forwarding funds, and emitting relevant events to mark the successful conclusion of the token sale process.",
        "url": 408
    },
    {
        "nl_input": "The query requires a function to calculate points for the round of sixteen, quarter-finals, and semifinals in a tournament. It needs to evaluate team performance based on their progression through these stages and assign corresponding points. The focus is on identifying teams that advanced to specific rounds and summing up their respective points accurately.",
        "url": 409
    },
    {
        "nl_input": "The query requires a function to transfer all Ether from the contract's balance to an address specified by the owner. The provided code examples demonstrate transferring Ether using the `transfer` method, ensuring only the owner can initiate the transaction and sending the entire contract balance to the designated address.",
        "url": 410
    },
    {
        "nl_input": "The query requires a function to set default vesting schedule parameters, including bonus percentage, principle lock percentage, bonus and principle lock periods, and early participant price. The function should allow these parameters to be configured, enabling customization of the vesting schedule for participants.",
        "url": 411
    },
    {
        "nl_input": "The query requires a function to handle ETH transfer transactions when rewards are depleted, ensuring the contract can still pay for transaction costs. It needs a mechanism to withdraw a specified amount of Ether, check balance availability, and transfer the amount to the owner or sender while maintaining contract functionality.",
        "url": 412
    },
    {
        "nl_input": "The query requires a function to burn all tokens owned by the owner. The function should ensure that the burn process is initiated by the owner, and it should handle the reduction of the owner's balance and the total supply accordingly. It may also include checks to confirm the burn has not occurred before and log the event.",
        "url": 413
    },
    {
        "nl_input": "The query requires a utility function that ensures a function is executed only once within a smart contract. The relevant code demonstrates a modifier named `onlyOnce` which uses a require statement to check if the function attempt count is zero before allowing execution, ensuring the function's uniqueness and preventing re-execution.",
        "url": 414
    },
    {
        "nl_input": "The query requires a function that checks if the amount of fuel to be bought exceeds the sellable supply for the day. It should calculate whether adding the potential purchase to the already sold amount would surpass the available supply minus any reserved amount, returning false if the condition is met.",
        "url": 415
    },
    {
        "nl_input": "The query requires a function to retrieve the total number of tweets for a specific round. The relevant code should take a round number as input and return the corresponding number of tweets stored for that round in a structured data format or mapping.",
        "url": 416
    },
    {
        "nl_input": "The query requires a function to set allowances for other addresses, allowing one address to spend tokens on behalf of another. The function should take two addresses as inputs (owner and spender) and return the remaining allowance. It involves managing and retrieving allowance data from a mapping structure within a smart contract.",
        "url": 417
    },
    {
        "nl_input": "The query seeks the total supply of XLMGOLD tokens. It requires a function named `totalSupply` that returns the total number of tokens as a uint value. The implementation should accurately reflect the total token supply, typically represented by a variable such as `_totalSupply` or `numTokens`. The function must be accessible and correctly defined in the smart contract.",
        "url": 418
    },
    {
        "nl_input": "The query requires a time utility function. It needs a function to handle or retrieve time-related data, such as getting the current time (in milliseconds) or setting specific time configurations like time windows or periods. The focus is on functions that manipulate or provide time values for further use in smart contracts.",
        "url": 419
    },
    {
        "nl_input": "The query requires a function to withdraw DGZ tokens to a beneficiary. The function should ensure that the token transfer is recorded and possibly restricted by certain conditions, such as the crowdsale status. It must involve transferring a specified amount of tokens to the beneficiary address while logging the withdrawal event.",
        "url": 420
    },
    {
        "nl_input": "The query requires a function to perform a safe addition of two unsigned integers (x and y), returning their sum while ensuring no overflow occurs. If an overflow is detected, an exception should be thrown. The function should be pure and internal, with a mechanism to validate that the addition does not exceed the maximum value allowed for the data type.",
        "url": 421
    },
    {
        "nl_input": "The query requires a function to allocate tokens for a private sale. This involves processing token purchases during the private sale stage, ensuring the available token pool is not exceeded, and transferring the appropriate amount of tokens to the beneficiary based on the contributed wei amount. If the pool limit is reached, any excess wei should be refunded.",
        "url": 422
    },
    {
        "nl_input": "The query requires a function to preallocate a liquid portion of tokens, ensuring the allocation is controlled and recorded. It involves minting tokens for a specified address, reducing the allocatable liquid amount, and emitting an event to confirm the allocation. The function should include security measures, such as access restrictions and validation of allocatable liquid tokens.",
        "url": 423
    },
    {
        "nl_input": "The query requires a function to return the total number of Zodiacs currently in existence. It should calculate this by determining the length of the Zodiac array and subtracting one to exclude the initial placeholder entry. The result is a uint value representing the total supply of Zodiacs.",
        "url": 424
    },
    {
        "nl_input": "The query requires a contract constructor definition. Among the provided code snippets, none explicitly show a constructor in the traditional sense (e.g., `constructor()` function). However, they demonstrate contract definitions with functions indicating setup or initialization logic, such as `setDistributor`, `startContruibute`, and `isContribPeriodRunning`. The requirement likely seeks details on initializing contract properties or permissions during construction.",
        "url": 425
    },
    {
        "nl_input": "The query requires a function to retrieve the genes of a specific hero or claim a hero if the user doesn't own any. The solution should involve checking the user's hero balance, claiming a hero if necessary, and retrieving the hero's gene information using the hero ID.",
        "url": 426
    },
    {
        "nl_input": "The query requires setting a transform agent that manages specific transformations, ensuring it is not null and aligns with the current state. The agent must confirm its identity, match original supply and funds, and trigger a confirmation event. The provided code examples involve setting agents, but only the first example directly relates to setting a transform agent with validation checks.",
        "url": 427
    },
    {
        "nl_input": "The query requires a function to withdraw all ether from a contract, transferring the entire balance to the owner. The most suitable code should have a function that handles the withdrawal of the full balance without specifying an amount, ensuring the owner receives the contract's total ether balance directly.",
        "url": 428
    },
    {
        "nl_input": "The query requires a function to mint Kin tokens, specifically involving the creation and allocation of tokens to a specified address. The relevant code demonstrates an internal minting process where tokens are added to an address, ensuring it's not null, and triggering a transfer event. It focuses on token generation and assignment within a contract.",
        "url": 429
    },
    {
        "nl_input": "The query requires a function to execute periodic subscription payments. It needs to handle subscription states, ensure proper authorization, calculate the amount to charge, and update payment details such as paidUntil and execution count. Additionally, it should interact with a service provider and manage payment fulfillment while preventing unauthorized or duplicate transactions.",
        "url": 430
    },
    {
        "nl_input": "The query requires a function that can be called by users and token holders to check a specific condition, analogous to checking if \"Trump is still president.\" The code should implement a boolean logic or status-checking mechanism. It needs to evaluate a condition and return a result indicating whether the condition (e.g., presidency status) is true or false.",
        "url": 431
    },
    {
        "nl_input": "The query requires a mechanism to restrict function calls to the burnable account only. It needs code that ensures only the designated burn address can execute specific functions, throwing an error otherwise. This involves using modifiers or conditional checks to validate the caller's address against the authorized burnable account before proceeding.",
        "url": 432
    },
    {
        "nl_input": "The query requires a function to check if an early purchase has been amended. It needs to verify whether a specific early purchase, identified by its index, exists within a list of amended early purchases. The function should return a boolean value indicating the presence of the amended early purchase.",
        "url": 433
    },
    {
        "nl_input": "The query requires a function to mark a document as visible by setting its visibility status and emitting an event. Specifically, it needs a function that takes a document ID as input, checks if the document is invisible, updates its status to visible, and triggers an event indicating this change. This ensures the document's visibility is appropriately managed within the system.",
        "url": 434
    },
    {
        "nl_input": "The query requires a function that determines the current round based on certain conditions. Specifically, it needs to iterate through a list of rounds and check if the total tokens sold fall within a specified range for each round, then return the corresponding round details. The function should be publicly accessible and constant, ensuring no state modifications occur during execution.",
        "url": 435
    },
    {
        "nl_input": "The query requires a function to update a listingHash's status from 'application' to 'listing' or resolve an existing challenge. It needs to check if the listing can be whitelisted or if any challenge associated with the listingHash can be resolved, performing the appropriate action based on these conditions. If neither condition is met, the function should revert.",
        "url": 436
    },
    {
        "nl_input": "The query requires a function to handle refund processes based on specific conditions. It needs to check if a refund is available within a designated time frame, either through a predefined date or a dynamic list of dates, and ensure the user's balance is refunded accurately. The solution should include logic for verifying eligibility, resetting balances, and transferring funds back to users.",
        "url": 437
    },
    {
        "nl_input": "The query requires a minting function that allows the creation of new tokens, typically restricted to the contract owner. The function should handle token supply updates, ensure valid recipient addresses, and emit relevant events (e.g., Mint or Transfer) to log token creation activities. It may also include supply limits or internal logic for token management.",
        "url": 438
    },
    {
        "nl_input": "The query requires a function to transfer tokens from one address to another, checking if the tokens are dividends to be paid. It involves ensuring the sender has sufficient balance, deducting the transferred amount from the sender, adding it to the recipient, and potentially logging the transaction while verifying if the transfer relates to dividend payments.",
        "url": 439
    },
    {
        "nl_input": "The query requires a function to refund investments to investors when certain conditions are met, such as the sale being unsuccessful or refunds being allowed. The function should transfer the invested amount back to the investor's address and reset their investment record to zero.",
        "url": 440
    },
    {
        "nl_input": "The query requires a function to set the KYC contribution cap for a single address based on different levels. The level determines the contribution cap, with higher levels allowing larger caps, including fixed ether amounts or values calculated using SafeMath operations. If the level is zero, the contribution cap should be set to zero.",
        "url": 441
    },
    {
        "nl_input": "The query requires a function to return the current exchange rate of LNC per Ether. It needs to identify the correct exchange rate based on the investor's address, distinguishing between early investors and others. The function should provide the exchange rate as a constant or viewable value without modifying the contract state.",
        "url": 442
    },
    {
        "nl_input": "The query requires a function to update the minimum contribution/bet amount, ensuring it is greater than zero. The most relevant code allows updating this value externally by authorized users, with a requirement that the new minimum must exceed zero, and emits an event upon successful update. This ensures flexibility in adjusting participation thresholds dynamically.",
        "url": 443
    },
    {
        "nl_input": "The query requires a function to manually send tokens to a specified address, ensuring the amount is positive and within the available token limits for Pre-ICO or ICO stages. It also needs to record purchase information and handle insufficient tokens by reverting the transaction. The function should be accessible only to privileged addresses and when the specified address is whitelisted.",
        "url": 444
    },
    {
        "nl_input": "The query requires a function to determine the number of voters who have voted for a specific proposal, identified by its root hash. The relevant code provides a constant function \"howManyVoters\" that takes a bytes32 parameter (_rootHash) and returns the total number of voters (totalVoters) associated with the given proposal. Other codes focus on voting mechanics but do not directly fulfill this requirement.",
        "url": 445
    },
    {
        "nl_input": "The query requires a function to add a user address to a participants list, ensuring no duplicate entries. It should check if the user address already exists in the list and only add it if it's not present, maintaining a unique set of participant addresses within a specific structure or storage related to a lottery or similar system.",
        "url": 446
    },
    {
        "nl_input": "The query requires a function to deauthorize an issuer, which involves removing or disabling the issuer's authorization status. The most relevant code shows a function that sets an issuer's authorization to false and emits an event notifying of the removal. This meets the requirement by effectively deauthorizing the specified issuer address.",
        "url": 447
    },
    {
        "nl_input": "The query requires calculating the amount of non-vested tokens at a specific time. It needs a function that subtracts vested tokens from the total granted tokens based on a given time. The solution should determine how many tokens are still locked and not yet available for transfer, considering the vesting schedule and elapsed time.",
        "url": 448
    },
    {
        "nl_input": "The query requires setting up an array that defines vesting stages with specific dates and percentages. The array should include timestamps for each stage, calculated from a starting timestamp, and corresponding percentages of tokens unlocked at each stage. This setup allows for structured token release over defined periods.",
        "url": 449
    },
    {
        "nl_input": "The query requires a function to facilitate the purchase of tokens by sending ether, ensuring conditions like minimum ether value, token calculation based on ether sent, and transferring ether to a specified wallet. It also involves updating balances, minting tokens, and emitting relevant events for transparency and record-keeping during the token purchase process.",
        "url": 450
    },
    {
        "nl_input": "The query requires a function to return the number of contributors for all campaigns. It needs to identify contributors and count them, potentially returning an array or list of contributor IDs or counts. The focus is on retrieving and presenting the total number of contributors associated with the campaigns in a structured format.",
        "url": 451
    },
    {
        "nl_input": "The query requires a function to handle token selling during crowd time. It needs to manage the transfer of tokens from the contract to an investor, ensure the availability of tokens, and possibly involve conditions for successful transactions, such as price and ownership validation. The function should update token supply and execute the transfer accordingly.",
        "url": 452
    },
    {
        "nl_input": "The query requires a function to validate if an address is suitable for token transfer, ensuring it is neither the zero address nor the token contract address itself. The provided codes demonstrate token transfer functions with validation logic, but the specific requirement focuses on address validation before executing the token transfer.",
        "url": 453
    },
    {
        "nl_input": "The query requires adding an address to administer the token, even when paused. This involves implementing a function that allows the owner to add or update an administrator address with specific privileges, ensuring the address can manage token functionalities during paused states. The solution should include logic to verify and set the new administrator address effectively.",
        "url": 454
    },
    {
        "nl_input": "The query requires a function to extract and handle address or bytes32 types directly from byte arrays without manual casting. Specifically, it needs logic to parse addresses from byte inputs and methods to slice bytes into bytes32 outputs. This ensures seamless handling of address and bytes32 data types for user convenience.",
        "url": 455
    },
    {
        "nl_input": "The query requires a private function to add a fee for a specific address, ensuring that if the address already has a fee, it increments the existing fee. The function should be accessible only within the contract and not externally.",
        "url": 456
    },
    {
        "nl_input": "The query requires implementing re-entry protection in smart contracts to prevent recursive calls that could lead to unauthorized fund transfers. The provided code examples demonstrate techniques such as using conditions to check block numbers, ensuring proper balance handling, and avoiding recursive calls by validating state changes before executing sensitive operations like transfers. The focus is on secure contract functions managing funds.",
        "url": 457
    },
    {
        "nl_input": "The query requires a function to filter buyers based on their approval status as investors. It needs to iterate through a list of buyers, check their status in an approved investor list, and return a filtered list of addresses that match the specified investor status. The function should handle memory allocation and ensure no empty addresses are included in the result.",
        "url": 458
    },
    {
        "nl_input": "The query requires a function modifier that restricts access to specific functions, ensuring only the contract owner can execute them. This is achieved by checking if the message sender matches the owner's address using a require statement. The correct implementation should allow execution only when the sender is the owner, as per the owned pattern in Solidity contracts.",
        "url": 459
    },
    {
        "nl_input": "The query requires setting the variable \"paused\" to false. This is achieved through an unpause function, which is accessible under certain conditions (e.g., when paused and by authorized users like manager or owner). Additionally, one implementation emits an Unpause event upon execution. The requirement focuses on the functionality to unpause a contract state.",
        "url": 460
    },
    {
        "nl_input": "The query requires a function or modifier that controls the release of tokens, ensuring they are not released prematurely. It needs logic involving token release conditions, such as timelocks or release date checks, and may involve functions to manage or check the release status of tokens for specific owners.",
        "url": 461
    },
    {
        "nl_input": "The query requires a function to check the number of ACE Equity Tokens a spender is allowed to spend from an owner. This involves identifying a method that takes an owner and spender address as input and returns the allowed token amount, typically using a mapping like `allowed[owner][spender]` to retrieve the spender's allowance from the owner's tokens.",
        "url": 462
    },
    {
        "nl_input": "The query requires a function to handle bonus token distribution and subsequent return to the main coin. It needs logic for transferring bonus tokens to recipients, managing token balance updates, and ensuring proper transaction execution after distributing bonuses, potentially including fallback mechanisms for refunds or leftover handling.",
        "url": 463
    },
    {
        "nl_input": "The query requires a function to check the balance of a given account in a blockchain contract. The function should take an address as input and return the corresponding balance. The provided codes demonstrate implementations of the 'balanceOf' function, which retrieves the balance associated with the specified account address.",
        "url": 464
    },
    {
        "nl_input": "The query requires a function to claim ownership of a specific unicorn ID. The desired code should verify permissions, transfer ownership from the current owner to the sender, and involve a unique unicorn ID as a parameter. It ensures authorized transactions and updates the ownership status accordingly.",
        "url": 465
    },
    {
        "nl_input": "The query requires a function to handle redemption states during both paused and non-paused conditions. It needs logic to check or modify the \"paused\" state, potentially involving functions like `unpause()` or `getPaused()`, with modifiers such as `onlyManager` or `onlyOwner` for access control, and possibly emitting events like `Unpause()`.",
        "url": 466
    },
    {
        "nl_input": "The query requires a function to transfer advisor tokens to an advisor wallet, ensuring specific conditions are met: ownership verification, time lock expiration, available supply, and proper vesting increments. Upon final vesting, the supply should reset. The function involves minting tokens to a specified wallet address after validating these criteria.",
        "url": 467
    },
    {
        "nl_input": "The query requires a function that allows the owner to transfer ERC20 tokens to a multi-signature vault. Specifically, it needs a mechanism to identify the ERC20 token contract, retrieve the balance from the current contract, and transfer the tokens to the specified multi-signature vault address securely.",
        "url": 468
    },
    {
        "nl_input": "The query requires a function that approves the transfer of tokens and calls another contract in a single step. It should include functionality to approve token transfer, involve external contract interaction, and ensure proper ownership or allowance checks before executing the transfer. The solution must combine approval and transfer logic seamlessly.",
        "url": 469
    },
    {
        "nl_input": "The query requires a function to transfer ownership of another contract, whose current owner is the caller, to a specified address. The function should ensure the new owner address is valid (not zero) and execute the ownership transfer accordingly. It may involve calling a transferOwnership method on the target contract.",
        "url": 470
    },
    {
        "nl_input": "The query requires a function to retrieve a list of token IDs owned by a specific address. The relevant code should define a method that accepts an address as input and returns an array of token IDs associated with that address, as seen in the first code example where the `tokensOf` function returns `ownedTokens[_owner]`.",
        "url": 471
    },
    {
        "nl_input": "The query requires implementing the functionality of ending a crowdsale, including checking sale conditions, setting the sale as ended, and initializing related parameters like prizes or states. It also involves transferring this functionality to the Steak contract for better organization and potentially public access. The focus is on ensuring proper state transitions and condition validations during the crowdsale closure.",
        "url": 472
    },
    {
        "nl_input": "The query requires a function to calculate the token amount based on the provided wei amount. It involves determining the rate depending on the wei amount and then computing the token amount by multiplying the wei amount with the corresponding rate. The function should handle different rates for varying wei amounts and return the resulting token amount.",
        "url": 473
    },
    {
        "nl_input": "The query requires a function that allows the token owner to rename the token by updating its name and symbol after certain operations are completed. It should also notify the audience about the changes through an event emission, ensuring they use the updated token contract information.",
        "url": 474
    },
    {
        "nl_input": "The query requires a function to facilitate the purchase of option tokens, allowing users to buy different types of option tokens (e.g., 30%, 20%, 10%) based on availability and value. The solution should handle multiple token purchases in sequence, ensuring remaining amounts are allocated appropriately until fully utilized or options are exhausted.",
        "url": 475
    },
    {
        "nl_input": "The query requires a function to calculate the unclaimed fees of a fund manager, including both management and performance fees. The calculation should consider time passed, gains, and fee rates, ensuring accurate fee allocation based on the fund's value and performance against a high-water mark. The result combines both types of fees into a single unclaimed fees value.",
        "url": 476
    },
    {
        "nl_input": "The query requires implementing a condition to ensure that trading is restricted until at least 3 weeks have passed since the sale closed. This involves adding a time-based restriction before trading can be reopened, likely using a timestamp or block timestamp mechanism to enforce the waiting period after the sale closes.",
        "url": 477
    },
    {
        "nl_input": "The query requires a function to purchase a soldier, specifying the army ID and number of soldiers. The function should handle different prices for varying quantities of soldiers (1, 10, 100, or 1000) and update the soldier count in the specified army accordingly. It ensures correct payment is received before processing the purchase.",
        "url": 478
    },
    {
        "nl_input": "The query requires a function to add a minter to the list of authorized minters, ensuring the minter address is valid and not already added. It should be accessible only by the owner and return a boolean indicating success. The function must include proper validation checks before updating the minter status.",
        "url": 479
    },
    {
        "nl_input": "The query requires initiating the distribution phase in a contract, allowing owners to claim their tokens. It involves activating token distribution, ensuring the token is whitelisted, checking the minimum distribution limit, and recording distribution details such as owners, amount, and token information. The process emits an event indicating active token distribution.",
        "url": 480
    },
    {
        "nl_input": "The query requires an internal function to remove a specific deed ID from the list associated with a given address. The function should locate the deed, update the list by replacing the deed with the last one in the array, adjust indices, and decrement the total deeds count while ensuring data integrity and correctness.",
        "url": 481
    },
    {
        "nl_input": "The query requires a function to return the share balance of the sender. It needs a contract function that takes no parameters, checks conditions (if necessary), and returns the share balance associated with the sender's address. The function should be view-only and ensure the balance corresponds to the sender's account.",
        "url": 482
    },
    {
        "nl_input": "The query requires extracting properties of a bid submission in an auction smart contract. It involves validating the bid amount, updating the highest bidder and bid value, and emitting an event upon successful bid placement. The process ensures the bid exceeds the current highest bid and is within the auction timeframe, while managing returns for outbid participants.",
        "url": 483
    },
    {
        "nl_input": "The query requires a function that allows the contract owner to add a new Sale wallet address for secure fund storage. The function should ensure the wallet address is valid and add it to the list of sale wallets, confirming successful addition with a boolean return value.",
        "url": 484
    },
    {
        "nl_input": "The query requires a modifier to ensure that only the specified Contractor can execute a function. This involves checking if the sender of the transaction matches the predefined Contractor address using a condition like `require(msg.sender == _contractor)` within the modifier implementation.",
        "url": 485
    },
    {
        "nl_input": "The query requires a function to move locked tokens to the team account. Specifically, it needs a mechanism to release or transfer tokens that are currently locked, typically involving a timelock or similar restriction, ensuring they are moved to the designated team account upon specific conditions being met.",
        "url": 486
    },
    {
        "nl_input": "The query requires modifying the `hasEnded` function to return true when all tokens are sold. It should check if the remaining tokens are zero, disregarding the time condition. The function needs to solely rely on the token count to determine if the sale has ended, ensuring accuracy in scenarios where all tokens are sold before the designated end time.",
        "url": 487
    },
    {
        "nl_input": "The query requires a function that returns the name of a token. The most suitable code is a function named 'name' which returns the string value of the token's name as defined in the contract. Other functions like 'getTokenDetail' and 'getTokenType' do not directly meet the requirement as they return additional information or different data types.",
        "url": 488
    },
    {
        "nl_input": "The query requires a function to set the current rate of ETH/USD. It needs a contract function that updates the exchange rate based on input, typically restricted to the owner for security. The function should accept a parameter representing the new rate and update the corresponding variable within the contract.",
        "url": 489
    },
    {
        "nl_input": "The query requires a SafeMath divide function implementation to perform safe division operations in Solidity, preventing division by zero and ensuring accurate results. It should include error handling or assertions to maintain integrity during division operations within smart contracts. The provided code examples demonstrate variations of such functionality.",
        "url": 490
    },
    {
        "nl_input": "The query requires a function to airdrop tokens to multiple addresses with specified values. It needs to ensure the lengths of destination and value arrays match, iterate through the arrays, and transfer tokens from a source address to each destination address with the corresponding value, using a multiplier for value adjustment.",
        "url": 491
    },
    {
        "nl_input": "The query requires a function to refund investors' ether when invoked from the token contract. It should ensure refunds are allowed, verify investor contributions, reset contribution records, and transfer the contributed amount back to each investor's address while updating related balances and distributed tokens accordingly.",
        "url": 492
    },
    {
        "nl_input": "The query requires a function to perform batch transfers of Ether (ETH) to multiple addresses. The desired functionality should divide the sent Ether equally among the specified recipients, ensuring that the transaction is payable and that there are valid recipient addresses. The function must handle dynamic arrays of recipient addresses and distribute funds accordingly.",
        "url": 493
    },
    {
        "nl_input": "The query requires a function allowing the owner to propose an address change for the owner. The suitable code should include a function where the owner can specify a new address, which is then proposed as the new owner. This involves setting the new address and potentially emitting an event to notify about the ownership change proposal.",
        "url": 494
    },
    {
        "nl_input": "The query requires an interface declaration for interacting with a contract, allowing the specification of a new address for the interface. The relevant code demonstrates a function to set a new address for the BLInterface, ensuring control via an \"onlyOwner\" modifier. It needs a proper structure to define and update the contract's interface address dynamically.",
        "url": 495
    },
    {
        "nl_input": "The query requires a function to cancel reserved tokens, ensuring the amount is positive, the wallet address is valid, the crowdsale has not ended, and the cancellation does not exceed the reserved amount for the wallet. It also involves updating token reservations and emitting an event for the cancellation.",
        "url": 496
    },
    {
        "nl_input": "The query seeks to identify functions or modifiers restricted to the contract owner, ensuring only the owner can execute specific actions. The provided code highlights the use of the \"onlyOwner\" modifier, which enforces that a function can only be called by the contract's owner through a require statement checking if the sender matches the owner.",
        "url": 497
    },
    {
        "nl_input": "The query requires a function to transfer tokens from one address to another, ensuring proper balance adjustments and approval checks. It needs a method that deducts tokens from the sender's balance, adds them to the receiver's balance, and emits a transfer event to confirm the transaction, while possibly including ownership or time restrictions for security.",
        "url": 498
    },
    {
        "nl_input": "The query requires a function that allows one user to authorize another user to spend a specific amount of tokens on their behalf. This involves updating an allowance mapping with the approved spender and amount, emitting an Approval event, and returning a boolean indicating success. The function must ensure proper authorization and prevent re-entrancy or double approval issues.",
        "url": 499
    },
    {
        "nl_input": "The query requires a function to return funds to the curator. The most suitable code demonstrates a clawback function where the curator can retrieve the contract's balance if they are the sender. It ensures funds are sent back to the curator upon request, maintaining security and proper access control.",
        "url": 500
    },
    {
        "nl_input": "The query requires a function that checks if a certain condition is met before initiating a specific state or action, without running in the constructor. It needs a mechanism to verify whether a contract has started based on the current block number compared to a predefined start block. The desired function should return a boolean value indicating if the contract is started.",
        "url": 501
    },
    {
        "nl_input": "The query requires transferring token balances to a specified address. The code should include functionality to subtract tokens from the sender's balance, add them to the receiver's balance, and emit a transfer event to confirm the transaction, ensuring that the transfer is successful and the balances are updated correctly.",
        "url": 502
    },
    {
        "nl_input": "The query requires a function to deposit wei into an exchange contract. The focus is on identifying a contract function that accepts wei as input and processes it, potentially logging the deposit or associating it with a user's wallet. The solution should involve a deposit mechanism with parameters for tokens, amounts, and balances.",
        "url": 503
    },
    {
        "nl_input": "The query requires a method to verify that terms and conditions have been read and understood. The relevant code provides a function `termsAndConditionsAreSigned` which uses Ethereum's `ecrecover` to confirm if the message hash of the terms and conditions has been signed by the user, thereby proving acknowledgment. Other codes are unrelated.",
        "url": 504
    },
    {
        "nl_input": "The query seeks to determine the number of tokens available for purchase and the conditions under which tokens can be bought, including price calculations based on the number of tokens sold. It also requires information on the limits of token purchases and the phases of token sales with varying pricing structures.\n\nTokens left: 376",
        "url": 505
    },
    {
        "nl_input": "The query requires implementing the functionality to allow a token itself to send tokens using the `transferFrom()` method. This involves adjusting balances and allowances between addresses while ensuring proper subtraction and addition of token values, ultimately emitting a `Transfer` event to confirm the transaction's success.",
        "url": 506
    },
    {
        "nl_input": "The query requires a function to facilitate the selling of keys by transferring tokens and equivalent value to the seller, ensuring sufficient balance. The code should handle transactions securely, verifying balances before executing transfers and utilizing internal functions like `_transfer` for token movement. It involves public functions with parameters for amount and uses sellPrice for calculations.",
        "url": 507
    },
    {
        "nl_input": "The query requires a function to return the child address corresponding to a given parent address. The most relevant code provides a function named `returnChildAddressForParent`, which takes a parent address as input and returns the associated child address by interacting with another contract at a specified address.",
        "url": 508
    },
    {
        "nl_input": "The query requires a function or modifier that allows execution by everyone, without restrictions. Specifically, it needs code ensuring any user can invoke a function, as indicated by the \"callable by everyone\" requirement. The provided code examples include modifiers and checks that control access based on conditions like authorized users or specific roles.",
        "url": 509
    },
    {
        "nl_input": "The query requires a function to manage and distribute rewards, ensuring the amount is positive and adjusting balances accordingly. It involves transferring rewards from a pool to an owner, capping rewards based on balance and limits, and allowing the addition of rewards through payable functions. The focus is on maintaining accurate reward distribution and balance management within a contract system.",
        "url": 510
    },
    {
        "nl_input": "The query requires a function to validate sale parameters, ensuring either a fixed-price sale or that the expiration time is positive. It checks the logic for validating sale parameters based on conditions provided in the code snippet from URL 511. The function should return a boolean indicating if the parameters are valid according to these rules. Other codes focus on sale status or pre-sale checks, not parameter validation.",
        "url": 511
    },
    {
        "nl_input": "The query requires a function to validate if a given rate is within specified limits, using an internal check. It ensures the rate falls between predefined minimum and maximum values, as demonstrated by the provided code examples with similar functionality. The requirement focuses on implementing a pure or restricted function for rate validation.",
        "url": 512
    },
    {
        "nl_input": "The query requires a function to determine the number of tokens owned by a specific address (owner). It needs a mapping or array that stores the token count per owner and a function named `balanceOf` or similar, which accepts an owner's address as input and returns the corresponding token balance.",
        "url": 513
    },
    {
        "nl_input": "The query requires a function to determine if one value is equal to or greater than another. It needs a boolean return indicating the comparison result between two uint256 values, ensuring efficient and direct evaluation of the condition without additional operations or constraints unrelated to the comparison itself.",
        "url": 514
    },
    {
        "nl_input": "The query requires a function that provides benefits to the owner, ensuring funds are transferred correctly and maintaining balance assertions. It involves checking conditions, transferring benefit funds to the owner, resetting the benefit fund value, and confirming the contract's balance aligns with expected values after the transfer. Only relevant code aspects meeting this requirement should be considered.",
        "url": 515
    },
    {
        "nl_input": "The query requires logging diary entries with a time stamp. The code should allow users to record diary content along with the current time stamp. Specifically, it needs a function to store diary entries, associating each entry with a time stamp (using \"now\") and incrementing an ID for new entries. Time-related functionality includes recording or updating timestamps.",
        "url": 516
    },
    {
        "nl_input": "The query requires a function to remove (burn) specific token values (123-120) from the sender's balance, updating the total supply and recording the burn. It needs a mechanism to ensure the sender's balance is sufficient, adjust balances and total supply accordingly, and possibly emit an event to log the transaction. Owner restrictions or optional conditions may apply.",
        "url": 517
    },
    {
        "nl_input": "The query requires a function to set the value of \"card/watt/month\". Among the provided code snippets, none directly match this requirement. However, the query needs a function that allows setting a specific value, similar to \"setCentsPerMonth\" in the first code snippet. The desired function should accept a parameter to define the \"card/watt/month\" value.",
        "url": 518
    },
    {
        "nl_input": "The query requires a function to approve the removal of an owner, ensuring the caller is an owner who hasn't previously requested the removal. The function must verify that the number of owners remains above a threshold, the removal request is within its valid timeframe, and track approvals before executing the removal.",
        "url": 519
    },
    {
        "nl_input": "The query requires a function to return funds to contributors if the ICO is unsuccessful. It needs conditions to ensure the ICO has finished and the funding goal was not met, along with logic to transfer invested amounts back to the contributors' accounts. The solution should include modifiers or assertions to validate the state and eligibility for refunds.",
        "url": 520
    },
    {
        "nl_input": "The query requires a function to withdraw a consolation prize after losing Eth. The code should calculate the prize based on tokens owned by the user, reset token payouts, ensure the prize is non-zero, and transfer the calculated amount from the prize pool to the user. It involves iterating through the user's token list and using a payout mapping to determine the total prize.",
        "url": 521
    },
    {
        "nl_input": "The query requires identifying the maximum investment limit accepted during a sale, expressed in wei. The relevant code should contain a function or logic that defines this limit, likely involving a conversion from another unit (e.g., euro cents to wei) or a condition that restricts the amount of funds accepted. The focus is on extracting the specific value or calculation method for this maximum limit.",
        "url": 522
    },
    {
        "nl_input": "The query requires a function to transfer a tulip (represented as a token or unique ID) to another address without needing additional confirmation. The function should verify the recipient address validity, confirm ownership of the tulip by the sender, and execute the transfer accordingly. It must handle specific tulip IDs and ensure proper address checks during the transaction process.",
        "url": 523
    },
    {
        "nl_input": "The query requires a function or modifier ensuring that certain operations can only be executed after a specified vesting period elapses. This involves checking if the current time surpasses a defined vesting duration before allowing execution, typically using modifiers or conditional statements for time-based restrictions.",
        "url": 524
    },
    {
        "nl_input": "The query requires a function or condition that accepts only a specific value of 0.1 ether. The relevant code describes a function that processes token amounts based on ether input, specifically addressing the case where the input is exactly 0.1 ether, ensuring it meets the required condition. Other codes are unrelated to this specific requirement.",
        "url": 525
    },
    {
        "nl_input": "The query requires a function to send Bankroll funds for additional dividends. It needs to calculate the dividend share of the user, ensure sufficient funds, update the dividend records, and transfer the calculated amount to the user's address while emitting an event for the withdrawal.",
        "url": 526
    },
    {
        "nl_input": "The query requires a function to approve token transfers, ensuring the caller has sufficient tokens. It needs logic to verify ownership before approving, possibly supporting multiple tokens. The implementation should include error handling for insufficient balances or improper approvals, with events emitted upon successful approval actions.",
        "url": 527
    },
    {
        "nl_input": "The query requires a function that allows the owner wallet to change the rate of tokens. Specifically, it needs a function named \"setRate\" or similar, which accepts a parameter for the new token rate and can only be executed by the contract owner. The function should update the token rate accordingly.",
        "url": 528
    },
    {
        "nl_input": "The query requires a function to distribute ERC20 tokens to holders based on a predefined ratio. The most relevant code demonstrates distributing tokens by iterating through a list of holders, calculating each holder's amount according to the ratio, and transferring the tokens. It ensures distribution happens only once and emits an event upon completion.",
        "url": 529
    },
    {
        "nl_input": "The query requires a function to transfer tokens from one address to the owner's address, ensuring proper authorization and conditions are met. It involves transferring token ownership or amounts between addresses while maintaining security checks and updating balances accordingly. The focus is on implementing a secure and accurate token transfer mechanism within a smart contract.",
        "url": 530
    },
    {
        "nl_input": "The query requires a function to place a bet on a specific number in a roulette-like game, ensuring the bet size is within limits, the casino has sufficient funds, and the chosen number is valid. If the random number matches the bet, the user wins 36 times their bet; otherwise, they lose. The function handles invalid inputs and insufficient funds gracefully by returning appropriate messages.",
        "url": 531
    },
    {
        "nl_input": "The query requires a function to manually refund a bet when the oraclize callback is not received. It needs to check if the bet is in a waiting state and then refund the bet amount to the player's address, ensuring the bet is marked as refunded and updating related states accordingly.",
        "url": 532
    },
    {
        "nl_input": "The query requires a function to set the verification slashing period, ensuring it doesn't exceed a maximum limit when added to the verification period. The function should update the parameter and notify of the change. It involves external access control, likely restricted to a controller owner.",
        "url": 533
    },
    {
        "nl_input": "The query requires a function to set a time lock for a given allocation address, ensuring the timelock date is not earlier than the current time and the address is valid. The function should record the timelock information and emit an event confirming the action.",
        "url": 534
    },
    {
        "nl_input": "The query requires a function to decline token minting for a specified investor, removing their allocation from the total tokens to be minted and resetting their individual token holdings. The solution should involve updating the token minting records and emitting an event indicating the decline for the specified investor address.",
        "url": 535
    },
    {
        "nl_input": "The query requires a function to set the percentage for the reserved wallet in a smart contract. This involves defining a method that allows the owner to update the reserved tokens' percentage, ensuring flexibility in managing token allocation within the contract's ecosystem. The provided code examples inform this by showcasing similar functionality for setting or modifying reserved wallet parameters.",
        "url": 536
    },
    {
        "nl_input": "The query requires setting up an interface to the Blocklord contract, allowing interaction with its functionality. Specifically, it involves creating a function to set or update the address of the Blocklord contract interface, enabling the contract owner to specify the new address for the Blocklord interface dynamically. This ensures flexibility in connecting to the desired Blocklord contract instance.",
        "url": 537
    },
    {
        "nl_input": "The query requires a mechanism to ensure equal distribution of original tokens in a contract, preventing any dominant dump scenario to promote healthy longevity. The focus is on transferring tokens to designated addresses, ensuring unsold tokens are handled, and distributing tokens fairly among participants while maintaining a balanced and sustainable system.",
        "url": 538
    },
    {
        "nl_input": "The query requires a function to safely withdraw unbought tokens back to the seller. It needs a mechanism to ensure that only the owner can initiate the withdrawal, and the tokens returned should be accurately calculated based on the remaining balance, excluding any purchased or withdrawn amounts. The solution must also confirm the crowdsale has closed and is finalized before executing the withdrawal.",
        "url": 539
    },
    {
        "nl_input": "The query requires a function to update the whitelistedPlannedContributions counter by subtracting the contribution about to be applied. It involves modifying a counter variable using the subtraction of a planned contribution value and potentially emitting an event to notify the update.",
        "url": 540
    },
    {
        "nl_input": "The query requires implementing a function to set the price for summoning a hero using Ether (Eth). The description should focus on defining how much Eth is needed for the summoning process, ensuring the contract accepts payable transactions and correctly handles the Eth value for purchasing or summoning a hero.",
        "url": 541
    },
    {
        "nl_input": "The query requires logging wallet interaction events off-chain. Specifically, it needs a function to record deposits by logging the user address, token type, amount, and wallet balance. This ensures off-chain tracking of wallet activities without altering the wallet address, focusing on event logging rather than changing wallet ownership or configuration.",
        "url": 542
    },
    {
        "nl_input": "The query requires a mechanism for player two to approve the SlammerTime contract, triggering an event notifying player one of their intent to \"rumble.\" This involves broadcasting an approval action within a game context, likely using smart contract events to signal player interactions and intentions. The solution should focus on implementing this approval-triggered notification.",
        "url": 543
    },
    {
        "nl_input": "The query seeks a function that is publicly accessible and related to retrieving a symbol or name attribute. Based on the provided code snippets, the requirement focuses on identifying contracts with public view functions named \"symbol\" or \"name\" that return a string value, indicating the need for accessing token symbols or names in smart contracts.",
        "url": 544
    },
    {
        "nl_input": "The query requires a method to check the ICO stage based on a given time. It needs a function that determines whether a specific time falls within the ICO period, possibly using start and end timestamps. Additionally, it may involve defining or identifying different stages of the ICO, such as PreICO or main ICO, and calculating bonuses depending on the current stage and time.",
        "url": 545
    },
    {
        "nl_input": "The query requires identifying a method that can issue tokens to anyone without explicit owner consent, focusing on the internal function called by \"buyToken\". The relevant code describes a mechanism where tokens are issued or transferred internally as part of a purchase process, ensuring functionality for buying tokens while invoking additional token-related actions.",
        "url": 546
    },
    {
        "nl_input": "The query requires a function allowing the owner to modify the number of available tokens for an ICO, ensuring it remains below 70 million. The relevant code provides a function `setIcoTokenSupply` that enables the owner to set the ICO token supply before a start date, with a requirement that the new supply must be less than the total token supply.",
        "url": 547
    },
    {
        "nl_input": "The query requires a function to return the asset allowance from one holder to another. Specifically, it needs a method that takes two addresses (holder and spender) and returns the allowance value, typically stored in a mapping within the contract. The function should be publicly accessible and view-only, ensuring no state modifications occur during the query.",
        "url": 548
    },
    {
        "nl_input": "The query requires proposing the transfer of the EngravedToken contract ownership to a specified address (_engravedAddress). This involves creating or invoking a function that allows the current owner (or beneficiary) to propose such a transfer, including setting a deadline and ensuring the proposal meets specific conditions before execution.",
        "url": 549
    },
    {
        "nl_input": "The query requires a function to complete a breeding auction by bidding, ensuring the bidder owns the mom token, both tokens can breed, and the dad token is available for mating. It also involves calculating and paying a breeding fee, placing a bid on the dad token, and executing the breeding process with the mom and dad tokens.",
        "url": 550
    },
    {
        "nl_input": "The query requires a function to modify a minimum value setting within a smart contract, ensuring the new value is non-zero and updating the corresponding variable. This allows for adjusting thresholds like minimum bet amounts or withdrawal limits, with restrictions to prevent unauthorized changes and ensure valid input. Only authorized entities can execute this change.",
        "url": 551
    },
    {
        "nl_input": "The query requires an internal function to clear the current approval and transfer ownership of a specified token ID. It ensures the new owner is valid, differs from the current owner, and matches the token's approved address. The function clears approval, removes the token from the old owner, adds it to the new owner, and emits a transfer event.",
        "url": 552
    },
    {
        "nl_input": "The query requires a function within an ICO contract that allows the owner to unpause a token contract. This involves a method, typically named \"unpauseToken\" or \"unpause,\" which is accessible only by the owner and interacts with the token contract to change its paused state to false, resuming normal operations.",
        "url": 553
    },
    {
        "nl_input": "The query requires a function to place a bid in an auction using the value sent with the transaction. The function should ensure the bid exceeds the current highest bid, update the bidder and bid amount if successful, and handle returning funds to the previous highest bidder if applicable. It involves managing auction states, validating bids, and updating auction data accordingly.",
        "url": 554
    },
    {
        "nl_input": "The query requires a function to facilitate the purchase of HQX tokens. The code should include a payable function that ensures the sender is not frozen, validates the transaction value, and executes the token purchase process. The most suitable code will have a mechanism for buying tokens with appropriate checks and balances.",
        "url": 555
    },
    {
        "nl_input": "The query requires a mechanism to handle unexpected funds in a contract, ensuring proceeds are paid out immediately while maintaining balance integrity. The code should manage fund transfers, refunds, or forwarding, possibly involving beneficiary addresses, amounts, and time conditions, with safety checks to confirm successful transactions and prevent discrepancies in the contract's balance.",
        "url": 556
    },
    {
        "nl_input": "The query requires implementing a function to set or modify the admin user's quota under specific conditions (e.g., openTag being 0). It involves managing admin roles, ensuring addresses are valid, and possibly removing or updating admin permissions. The provided code references admin management functions within smart contracts.",
        "url": 557
    },
    {
        "nl_input": "The query requires a function to check if a game is active based on a given game ID. It needs to verify whether the game exists and is marked as active in the system. The solution should return a boolean value indicating the game's active status.",
        "url": 558
    },
    {
        "nl_input": "The query requires functions related to pyramid grid writing. The relevant code should involve operations on a grid or canvas, such as setting pixels with specific indexes and colors. It likely needs functionality to manage and update a grid structure, ensuring correct mappings between positions and their assigned values, as seen in the setPixels function.",
        "url": 559
    },
    {
        "nl_input": "The query requires identifying code that defines a function to check the total supply of tokens in a contract. The relevant code is a function returning the total token supply. Token count: 17.",
        "url": 560
    },
    {
        "nl_input": "The query requires a function to calculate the expected MET for a given ETH amount. It needs a method that accepts an ETH deposit amount and returns the corresponding MET value, likely using a conversion rate or similar logic to determine the output based on input ETH.",
        "url": 561
    },
    {
        "nl_input": "The query requires a function to disapprove a user's KYC status. Specifically, it needs to set the KYC status of a given user address to false and emit an event indicating the change. The relevant code modifies the supporter's KYC status in a mapping and triggers a KYC event with the user address and the new status (false).",
        "url": 562
    },
    {
        "nl_input": "The query requires a function to unpause a smart contract, typically involving setting a \"paused\" state variable to false and possibly emitting an event to notify users. The function should likely include modifiers for access control, ensuring only authorized users (e.g., managers or owners) can call it while the contract is paused.",
        "url": 563
    },
    {
        "nl_input": "The query requires a function to sell a specified amount of tokens to a contract, ensuring the contract deducts the tokens from its supply and transfers them to the investor's address. The focus is on accurately handling token subtraction and transfer, confirming sufficient token availability before execution.",
        "url": 564
    },
    {
        "nl_input": "The query requires a function to update the maximum gas price, allowing the owner to set a new value greater than zero. The provided code includes a function 'updateMaxGasPrice' that fulfills this requirement by updating the maxGasPrice variable when called by the owner with a valid value.",
        "url": 565
    },
    {
        "nl_input": "The query requires a function to handle the purchase of artworks triggered by a LikeCoin transfer callback. It should verify the transaction, calculate the cost, and allocate artworks to the buyer accordingly, ensuring the process is integrated with the LikeCoin system for seamless execution.",
        "url": 566
    },
    {
        "nl_input": "The query requires methods related to ICO (Initial Coin Offering) functionality. This includes checking ICO status based on time, activating ICO status, and transferring tokens during the ICO phase. The methods should ensure proper conditions, such as valid time ranges, active ICO status, and authorized senders for token transfers.",
        "url": 567
    },
    {
        "nl_input": "The query requires a function enabling coin holders to increase the vote count for an option in an ongoing ballot. The function should verify the ballot's activity, ensure the voter has sufficient balance, and update both the vote count for the selected option and the voter's used balance accordingly.",
        "url": 568
    },
    {
        "nl_input": "The query requires a modifier that restricts function access to the pendingOwner account only, throwing an error if any other account attempts to call it. The suitable code defines a modifier named onlyPendingOwner, which checks if the msg.sender matches the pendingOwner before allowing execution to proceed. This ensures exclusive access control for the pendingOwner.",
        "url": 569
    },
    {
        "nl_input": "The query requires a function to check if a given address represents a certificate authority. The relevant code provides a function named `isCA`, which takes an address as input and returns a boolean value indicating whether the address is associated with a certificate authority by checking if the lookup API for the address is non-empty.",
        "url": 570
    },
    {
        "nl_input": "The query requires a function to distribute winnings (bounty and bonds) to users who provided accepted answers. It involves iterating through lists of beneficiaries, calculating their shares, handling referral bonuses, and updating the prize pool. The focus is on ensuring correct fund allocation and managing any remaining fees or funds.",
        "url": 571
    },
    {
        "nl_input": "The query requires functionality for handling the crowdsale process and token manipulations, specifically minting tokens for investors during the pre-crowdsale phase, ensuring conditions like time constraints and supply caps are met, and possibly finalizing the crowdsale by transferring tokens and concluding minting. The focus is on managing token distribution and ownership transitions.",
        "url": 572
    },
    {
        "nl_input": "The query requires identifying the condition or function related to not reaching the soft cap in a smart contract context. Specifically, it involves checking for a scenario where the soft cap is not met after the ICO finishes, ensuring the logic aligns with post-ICO funding goals and states. The relevant code should handle this condition effectively.",
        "url": 573
    },
    {
        "nl_input": "The query requires implementing a function to set the reward divisor value in a smart contract. It should allow the contract owner to update the reward divisor dynamically. The key focus is on providing an external function that accepts a new divisor value and assigns it to the rewardDivisor variable, ensuring only the owner can execute this change.",
        "url": 574
    },
    {
        "nl_input": "The query requires creating a new series with a specified name, root hash, and initial count, ensuring the sender owns the node hash and the root hash is non-zero. The series should store these details and trigger a creation event upon successful initialization.",
        "url": 575
    },
    {
        "nl_input": "The query requires a function to return the number of coins owned by a specific address. It needs a mapping or array that stores the count of coins associated with each owner and should efficiently retrieve this count when an owner's address is provided as input. The function must be accessible for viewing purposes without altering the stored data.",
        "url": 576
    },
    {
        "nl_input": "The query requires a function to transfer tokens and conclude a specific stage, likely involving token distribution and ownership transfer. The desired function should handle transitions like ending a sale, burning remaining tokens, or finalizing the process while ensuring proper requirements are met, such as stage completion or ownership verification.",
        "url": 577
    },
    {
        "nl_input": "The query requires a function that allows an oracle proposal by a maker, involving operations such as checking balances, deducting fees, and recording proposals with associated indexes. It also emits an event indicating the proposal details, including the proposer, taker, index, and IPFS hash. The function ensures balance checks and sufficient funds before proceeding.",
        "url": 578
    },
    {
        "nl_input": "The query requires a function to set a new owner for a proxy contract while removing the old owner. It needs a mechanism to transfer ownership, ensuring the new owner is valid and updating the contract's state accordingly, possibly emitting an event or handling edge cases like invalid addresses. The focus is on securely changing ownership in smart contracts.",
        "url": 579
    },
    {
        "nl_input": "The query requires a function allowing users to donate tokens to a manufacturer's pool, ensuring the manufacturer ID and amount are valid, transferring tokens from the sender to the contract, and emitting an event confirming the donation. The description focuses on depositing tokens into a specific manufacturer's pool.",
        "url": 580
    },
    {
        "nl_input": "The query requires a function to retrieve the balance of a specific user. The most suitable code should allow querying the balance associated with a user address. It involves either checking token balances or directly accessing predefined balance storage, ensuring the returned value corresponds to the requested user's account status.",
        "url": 581
    },
    {
        "nl_input": "The query requires a function to revoke freeze permissions for wallet addresses. Specifically, it needs a method to set the permission status of wallets to disallow freezing tokens. This involves iterating through wallet addresses and updating their ability to freeze tokens accordingly, with an event emitted for each change.",
        "url": 582
    },
    {
        "nl_input": "The query requires a function to handle fund transfers to a smart contract when called by a user or another contract. It should ensure proper transfer logic, including balance checks and the ability to send funds to either contracts or addresses while handling data if necessary. The solution must be secure and reliable for fund transactions.",
        "url": 583
    },
    {
        "nl_input": "The query requires a function allowing the owner to withdraw unsold tokens after an auction ends. The function should calculate the gap between total tokens and those sold, then transfer the remaining tokens to the specified recipient. It must ensure the auction has concluded and tokens are not yet distributed.",
        "url": 584
    },
    {
        "nl_input": "The query requires a function to calculate the conversion of fees to tokens, considering factors like contributed amount, previous supply, initial supply, and total fees. It emphasizes the potential for future updates in the controller logic. The function should dynamically compute token amounts based on these inputs and conditions.",
        "url": 585
    },
    {
        "nl_input": "The query requires a function to approve a new borrower. The most suitable code should allow adding a borrower and setting their approval status to true. It involves an external function, likely restricted to the contract owner, that updates a mapping or state variable to enable borrowing permissions for the specified address.",
        "url": 586
    },
    {
        "nl_input": "The query requires a function to lookup the current token price. It needs to consider different stages or conditions that may affect the price, such as auction status or specific events like preICO or ICO phases, and should return the updated or calculated token price accordingly.",
        "url": 587
    },
    {
        "nl_input": "The query requires a function to return the total number of games stored in a contract. It should be a view function that accesses a games array or similar data structure and returns its length as a uint value, allowing users to retrieve the count of games available in the smart contract's state efficiently.",
        "url": 588
    },
    {
        "nl_input": "The query requires identifying code that involves the implementation or usage of an interface marker. The relevant code demonstrates a function to set a new address for a BLInterface, showcasing how an interface is updated within a contract. This indicates the need for understanding how interfaces are defined, assigned, and interacted with in smart contracts.",
        "url": 589
    },
    {
        "nl_input": "The query requires a function to retrieve the value of the paused variable in a contract. The most suitable code provides a getter function named getPaused() that returns the current state of the paused variable, indicating whether the contract is paused or not. This allows external contracts or users to check the pause status.",
        "url": 590
    },
    {
        "nl_input": "The query requires a function to check if a given key is registered. It needs a boolean return indicating the registration status of the provided address or key. The focus is on verifying existence or registration status within a mapping or set, ensuring the key has been previously registered.",
        "url": 591
    },
    {
        "nl_input": "The query requires a function to check or manage status, likely for a sale or ICO. It needs a boolean return indicating activation status or a method to modify the status to active. The focus is on functions like 'saleStatus', 'getActionStatus', or 'activateICOStatus' that handle status retrieval or activation within a contract.",
        "url": 592
    },
    {
        "nl_input": "The query requires a function to check a user's REB balance tier. It needs to evaluate the user's balance and return the corresponding tier level, such as Platinum, Gold, Titanium, Free, or indicate if the user possesses no REB. The function should take the user's address as input and compare their balance against predefined thresholds to determine the appropriate tier.",
        "url": 593
    },
    {
        "nl_input": "The query requires creating a promotional team with a specified name, price, and assigning it to an address. If the owner's address is not provided, it defaults to a predefined COO address. If the price is not specified or invalid, it defaults to a starting price. The function ensures a limit on promo creations and utilizes a private team creation method to finalize the process.",
        "url": 594
    },
    {
        "nl_input": "The query requires a function to pay the creator upon successful completion. The function should verify success, ensure the creator hasn't been paid yet, transfer ether and tokens to the creator, and burn remaining tokens if the project is successful. Otherwise, it should return all tokens to the creator.",
        "url": 595
    },
    {
        "nl_input": "The query requires overriding the getRate function to integrate with an external rate provider. The goal is to dynamically fetch rates using the provider, likely involving user-specific or contextual data. The most relevant code demonstrates passing parameters like sender and token count to the rate provider for customized rate calculation. Ensure the implementation aligns with the provider's interface for accurate integration.",
        "url": 596
    },
    {
        "nl_input": "The query requires a function to transfer remaining funds to a specified wallet after the contract concludes. It should ensure that the balance is moved securely and appropriately, possibly involving checks or conditions before executing the transfer. The focus is on post-contract fund movement with owner authorization.",
        "url": 597
    },
    {
        "nl_input": "The query requires a function that allows a token holder to authorize a contract's address by using the approve() function. This involves specifying the spender's address and the amount or token ID, ensuring proper approval is emitted, and confirming the authorization logic within the contract. The function should handle approvals securely and emit an Approval event upon success.",
        "url": 598
    },
    {
        "nl_input": "The query requires a function to calculate and set the rate of FARM tokens per 1 ETH based on transaction time and pricing rules. It needs logic that adjusts the token rate dynamically, potentially factoring in balances or supply, as seen in the provided code examples. Specifically, it involves setting or getting the rate with possible conditional calculations.",
        "url": 599
    },
    {
        "nl_input": "The query requires a function to facilitate immediate refunds when certain conditions are met, such as the sale being unsuccessful or refunds being available. The function should transfer the invested amount back to the user, resetting their balance to zero and potentially emitting an event to log the refund action.",
        "url": 600
    },
    {
        "nl_input": "The query requires a function to manage token purchases at a specified price. It involves transferring funds, updating token balances for buyers and beneficiaries, ensuring valid transactions, and possibly adjusting token prices based on sale dynamics. The solution should handle purchase limits, price calculations, and maintain overall supply and demand constraints efficiently.",
        "url": 601
    },
    {
        "nl_input": "The query requires a function to set the historical balance for an owner's address based on snapshots within a specified range. It needs to ensure balances are correctly recorded at each snapshot moment, using a multi-level indexing system to store balances efficiently. The implementation must validate input parameters and handle bitwise operations for index manipulation.",
        "url": 602
    },
    {
        "nl_input": "The query requires a function to validate changes in signature requirement parameters, ensuring the new required value is not zero and does not exceed the allowable range based on the total length. It involves logging error messages for invalid cases and returning a boolean to indicate validation success or failure.",
        "url": 603
    },
    {
        "nl_input": "The query aims to calculate the amount of tokens released for a vesting schedule. It requires determining the vested tokens based on elapsed days, total vesting days, and the initial vesting amount. The function should handle cases where the vesting period has either been fully completed or is still ongoing, returning the appropriate vested token amount accordingly.",
        "url": 604
    },
    {
        "nl_input": "The query requires a function to retrieve the total supply of tokens, assuming it cannot exceed the maximum value (2^256 - 1). The function should be accessible externally or publicly and return a uint256 value representing the total supply. The provided codes demonstrate variations of such a function using different naming conventions and visibility modifiers.",
        "url": 605
    },
    {
        "nl_input": "The query requires a function to retrieve statistics or data. Specifically, it needs a function that returns an array or multiple values representing stats. The focus is on obtaining detailed statistical information, such as monster stats in the first code, general stats in the second, or player info in the third. The requirement is to fetch pre-defined statistical data based on input or context.",
        "url": 606
    },
    {
        "nl_input": "The query requires a function to reset all balances to 0 and set the state to false. It needs a mechanism to iterate through all accounts, zero out their balances, and update the state variable to false, ensuring no account can perform actions until the state is set back to true.",
        "url": 607
    },
    {
        "nl_input": "The query requires a token purchase function with anti-money laundering (AML) and Know Your Customer (KYC) checks. It needs code ensuring buyer validation, proper token transfer, and compliance with regulatory requirements. The provided examples involve token purchases but lack explicit AML/KYC implementation, focusing instead on transferring tokens and handling payments. The solution should integrate AML/KYC verification into the purchase process.",
        "url": 608
    },
    {
        "nl_input": "The query requires a function that allows the owner to set or update news content in a smart contract, emitting an event with the new news after successful execution. The function should take a string parameter for the news content, ensure only the owner can invoke it, and return a boolean indicating success.",
        "url": 609
    },
    {
        "nl_input": "The query requires a function to transfer the balance from a sale auction contract to the ZodiacCore contract. It needs logic ensuring the transfer occurs under specific conditions, such as ownership verification and balance calculations. The solution involves identifying a suitable transfer mechanism, as seen in the provided code snippets, to securely complete the transaction.",
        "url": 610
    },
    {
        "nl_input": "The query requires a function to shut down a contract and remove it from the blockchain state. This involves a self-destruct mechanism, accessible only by the owner, ensuring the contract is terminated and removed from the network while possibly transferring remaining funds or resources.",
        "url": 611
    },
    {
        "nl_input": "The query requires a function to delete or remove entries, likely for fixing bugs. It needs a mechanism to eliminate specific data, such as removing a user or clearing information. The ideal function should target particular entries (e.g., by address) and reset or nullify their values effectively. This ensures problematic data can be addressed without affecting the overall system.",
        "url": 612
    },
    {
        "nl_input": "The query requires a function to request and retrieve a certification document by its index for a specific student, ensuring the fee for this paid feature is covered. The relevant code provides a payable function that returns the certification document associated with the given student address and index.",
        "url": 613
    },
    {
        "nl_input": "The query requires a function to verify whether an address is an investor. It checks if a given address exists in a list or mapping of investors and returns a boolean value indicating the verification result. The function should efficiently determine investor status, potentially using loops or mappings for storage and retrieval.",
        "url": 614
    },
    {
        "nl_input": "The query requires a function to retrieve comprehensive information about a match, including team names, total amounts, participants, win index, match completion status, minimum bet amount, match number, and betting status. The relevant code provides a function named `getMatchInfo` that returns these details as specified in the query. Other codes do not meet this requirement.",
        "url": 615
    },
    {
        "nl_input": "The query requires a function to transfer tokens to a specified address, replacing the default `msg.sender` with a specified entity. The function should ensure proper authorization and execute the token transfer accordingly, potentially involving a fallback mechanism or additional checks for security and correctness.",
        "url": 616
    },
    {
        "nl_input": "The query requires a function allowing the contract owner to transfer any accidentally sent ERC20 tokens to their address, while excluding the specific token intended for the contract. The function should ensure that the intended token is not transferred out, protecting its integrity within the contract.",
        "url": 617
    },
    {
        "nl_input": "The query requires updating the `startTimestamp` property with a new `_start` value, ensuring the new value is less than `endTimestamp` and greater than the current time. It also involves emitting an event `StartTimestampUpdated` with the old and new values after successfully updating the property.",
        "url": 618
    },
    {
        "nl_input": "The query requires creating a new offer with a specific setting. It involves defining a function within a smart contract that accepts a parameter for the setting, ensures non-zero values for both the input and transaction value, and internally processes the creation of the offer. The focus is on ensuring proper validation and invoking an internal function to finalize the offer creation.",
        "url": 619
    },
    {
        "nl_input": "The query requires a function to transfer a specified balance from the sender's address to a recipient address (_to), along with additional data (_data). The function should verify that the sender has sufficient balance, update balances for both addresses, and emit a transfer event indicating the transaction details. It must ensure the recipient address is valid and handle contract-specific transfers if applicable.",
        "url": 620
    },
    {
        "nl_input": "The query requires implementing a function to set the current DOL prices, ensuring the price is updated only by an authorized owner and may include conditions such as non-zero values or incremental updates. The description should focus on updating price parameters with ownership restrictions and optional validation rules.",
        "url": 621
    },
    {
        "nl_input": "The query requires implementing a function to add a Kin token vesting grant. This involves defining the grant's parameters, such as the recipient, total tokens, vesting schedule, and any associated timestamps or conditions for unlocking tokens. The solution should integrate with existing vesting logic and storage structures.",
        "url": 622
    },
    {
        "nl_input": "The query requires implementing a function to freeze tokens and send them to a specified address with an expiration time. The function should ensure the sender has sufficient balance, update freezing balances, and emit relevant events for both transfer and freezing actions. It involves managing token freezing logic with timestamps.",
        "url": 623
    },
    {
        "nl_input": "The query requires a function to retrieve all relevant information about a specific waifu, including their name, selling price, and owner's address, based on the provided token ID. This involves accessing stored waifu data and associated attributes within the contract. The most relevant code is the first one, as it defines a function that returns the required waifu details.",
        "url": 624
    },
    {
        "nl_input": "The query requires a function to assign a new address to the CEO role, ensuring the address is not zero. The most relevant code provides a `setCEO` function that updates the `ceoAddress` with the new address, while enforcing the condition that the new address cannot be zero. This meets the requirement for securely reassigning the CEO role in a smart contract.",
        "url": 625
    },
    {
        "nl_input": "The query requires a function to retrieve the releasedToken count for a specified address. The relevant code provides a function named `releasedTokenOf` which accepts an address as input and returns the number of tokens released to that address, utilizing a mapping called `releasedTokens`. This matches the requirement to get the releasedToken of the specified address.",
        "url": 626
    },
    {
        "nl_input": "The query requires a function to handle the logic of a predator attack, including selecting animals to be attacked, calculating rewards or costs, and triggering subsequent actions. It involves random selection based on animal count, processing killed animals, managing gas costs, and distributing remaining rewards after an attack.",
        "url": 627
    },
    {
        "nl_input": "The query requires a function to extend the ICO end date. It needs a method that allows setting or updating the ICO end date, ensuring it can only be modified under specific conditions, such as being called by an authorized user and not having an existing end date already set. The solution must prevent unauthorized changes and ensure logical consistency in date settings.",
        "url": 628
    },
    {
        "nl_input": "The query requires a function that allows pre-approved users to take ownership of a specific color, identified by a unique token ID. The function should verify the new owner is not null, check approval status, and transfer ownership from the old owner to the new owner using a \"_transfer\" method or equivalent logic.",
        "url": 629
    },
    {
        "nl_input": "The query requires a function that sends pooled Ether to a specified receiving address, calculates the unused Ether for refund, and transitions the contract to stage two. It should handle conditions like minimum contribution, gas limits, and ensure proper balance management during the transaction process.",
        "url": 630
    },
    {
        "nl_input": "The query requires a function to retrieve connection details between two entities, including their active statuses, data, direction, and expiration. It involves resolving entity addresses, checking their active states, and fetching associated connection information stored in a mapping structure. The result is a tuple containing these specific details for the given entities and connection type.",
        "url": 631
    },
    {
        "nl_input": "The query requires a code snippet that implements a modifier or function ensuring an agreement is not locked, allowing specific operations only when the contract's state is unlocked. This involves using a boolean variable to track the locking status and a require statement to enforce the condition before executing the associated functionality.",
        "url": 632
    },
    {
        "nl_input": "The query requires a function to check if a given sequence can be represented in the form of 4815162342 multiplied by powers of 10, with trailing zeros. The function should iterate through a range of exponents and return the specific exponent (i) if the condition is met, or -1 if no match is found. Only relevant code for this task should be considered.",
        "url": 633
    },
    {
        "nl_input": "The query requires calculating the fee from the losing portion of the total pot. It involves determining the remaining amount after subtracting the winners' pot from the total pot, then applying a fee percentage to this remaining amount. The result should be the remaining balance after deducting the calculated fee.",
        "url": 634
    },
    {
        "nl_input": "The query requires updating network constants if necessary. The focus is on functions within smart contracts that can modify or return constant values. Specifically, it involves identifying functions like 'currentBonus', 'currentRound', and 'maintain' which either return constant values or update contract constants such as 'REGISTRATION_COST'. The requirement implies assessing and potentially changing these constant values within the network.",
        "url": 635
    },
    {
        "nl_input": "The query requires implementing a function to allocate initial tokens to founders' addresses. The provided code examples demonstrate token allocation to specific addresses, ensuring that the allocation happens only once and involves transferring predefined amounts to designated addresses such as founders, support, and bounty addresses. The solution should include these functionalities while adhering to security requirements.",
        "url": 636
    },
    {
        "nl_input": "The query requires a function to create and store a new promise object with specified recipient, amount, and lock duration. It should update the promisedTokenBalance by adding the promise amount and log the creation of the promise while maintaining the state as pending. The function must ensure the amount does not exceed the uncommittedTokenBalance.",
        "url": 637
    },
    {
        "nl_input": "The query requires a function to transfer tokens from one address to another using an allowance mechanism. Specifically, it needs to deduct the transferred amount from the sender's balance and allowance, then add it to the recipient's balance, ensuring proper approval and emitting a transfer event. The provided code examples demonstrate variations of this functionality.",
        "url": 638
    },
    {
        "nl_input": "The query requires a function to perform batch transfers to multiple receivers with a specified value. The function should ensure the receivers' list is not empty, handle frozen accounts, verify sender balance, and execute transfers accordingly, emitting events for each successful transaction. It may also include constraints on the number of receivers and require the sender to cover the total transfer amount.",
        "url": 639
    },
    {
        "nl_input": "The query requires a function to return the total supply of a token. The provided code snippets demonstrate implementations where a `totalSupply()` function returns a uint value representing the total number of tokens, using different variable names such as `numTokens`, `_totalSupply`, or `totalSupply`. The function is constant and does not alter the contract's state.",
        "url": 640
    },
    {
        "nl_input": "The query requires a function to start a crowd-sale, initializing the process and setting relevant parameters such as start time or blocks. It ensures the crowd-sale is not already started and may involve defining different phases with specific durations. The function should be callable only by the owner.",
        "url": 641
    },
    {
        "nl_input": "The query requires a function to remove or delete a contract entry. Specifically, it needs functionality that deletes an auction by ID, removes a seller's data from a sale list, or deactivates a contract by modifying its indices and mappings. The desired implementation should ensure the targeted contract or related data is effectively removed or marked as deleted.",
        "url": 642
    },
    {
        "nl_input": "The query requires a function to update the `coldWallet2` address, ensuring it cannot be set to an invalid address (e.g., `address(0)`). The function should likely include access control (e.g., `onlyOwner`) to restrict who can modify the `coldWallet2` address. This ensures security and proper management of the wallet address.",
        "url": 643
    },
    {
        "nl_input": "The query requires a function to pay using mileage points. The function should deduct mileage points from the user's account based on the specified amount, generate random values to determine hero ranks, and summon heroes accordingly. It involves ensuring sufficient mileage points, performing calculations, and executing a loop for multiple hero summons.",
        "url": 644
    },
    {
        "nl_input": "The query requires a function to approve a proxy for token transfers, allowing a specified address to manage tokens on behalf of the owner. The desired function should take an address and a token ID as parameters, verify the sender's ownership, and approve the specified address for token transfer. It should also emit an approval event confirming the action.",
        "url": 645
    },
    {
        "nl_input": "The query requires a function to check if a given zodiac is ready to breed, ensuring it is not currently siring and its cooldown period has ended. This involves verifying the zodiac's breeding status and comparing its cooldown end block with the current block number.",
        "url": 646
    },
    {
        "nl_input": "The query requires a function to deposit funds into a user's account, ensuring the sender is authorized (e.g., whitelisted) and updating their balance accordingly. It should also potentially log the deposit action with relevant details like token type, amount, and updated wallet balance for tracking purposes.",
        "url": 647
    },
    {
        "nl_input": "The query requires a method that allows anyone to withdraw funds to the coindrops wallet after the locking period has ended. The method should ensure the locking period is over, verify the withdrawal status, and transfer the specified tokens to the coindrops wallet while updating the withdrawal status to prevent further withdrawals.",
        "url": 648
    },
    {
        "nl_input": "The query requires a function to concatenate two strings or string-like objects. Specifically, it needs to allocate a new string that combines the contents of \"self\" and \"other\". The result should be a pure, internal function that efficiently merges the two inputs into a single output string using memory operations.",
        "url": 649
    },
    {
        "nl_input": "The query requires executing a multi-signature transaction using a smart contract, where one signer is the msg.sender and another is verified through a signature. The transaction involves sending a specific value to an address with associated data, ensuring the operation hash is validated and the transaction succeeds, while emitting a confirmation event.",
        "url": 650
    },
    {
        "nl_input": "The query requires a function to unlock or release vested tokens for a user. It involves checking if any tokens are vested and transferable, then transferring those tokens to the user's address while updating the transferred amount and total vesting records. The function should emit an event indicating the tokens have been unlocked.",
        "url": 651
    },
    {
        "nl_input": "The query requires a function to handle dividend payments by adding dividends to the contract. It should manage dividend distribution, ensure proper accounting, and possibly include conditions for valid transactions. The function must interact with the contract's balance and update relevant variables to reflect the added dividends accurately.",
        "url": 652
    },
    {
        "nl_input": "The query requires a function to disable the whitelist state, allowing the owner to set the whitelist status to false and emit an event with the updated state. The most relevant code provides a function that disables the whitelist by setting 'whitelistEnable' to false and emitting a 'WhitelistState' event.",
        "url": 653
    },
    {
        "nl_input": "The query requires a function or modifier that ensures a specific action can only be executed after the presale has concluded. It needs to verify the presale's end condition, possibly using timestamps or a boolean flag indicating the presale's completion. The solution should prevent unauthorized calls before the presale ends.",
        "url": 654
    },
    {
        "nl_input": "The query requires a function to cancel any outstanding multisig call. Specifically, it needs a mechanism to revoke pending multisig transactions by resetting associated parameters, ensuring the cancellation is authorized and properly recorded. The solution should handle cases where no calls exist to cancel and provide appropriate feedback or status returns.",
        "url": 655
    },
    {
        "nl_input": "The query requires a function to refund all Ether to the sender when a specific condition is met (e.g., sale unsuccessful or minimum cap not reached). The solution should ensure that fees are refunded, and the sender receives the exact invested amount. It involves transferring the balance back to the user's address upon calling the refund function.",
        "url": 656
    },
    {
        "nl_input": "The query requires public methods named \"give\" and \"take\" that can only be called by owners. These methods likely involve transferring value or ownership, ensuring security by restricting access to authorized users. The focus is on implementing functionality where only designated owners can execute specific operations related to transferring assets or control within a smart contract system.",
        "url": 657
    },
    {
        "nl_input": "The query requires a function to issue tokens to users, transferring them from a deposit or minting new ones. It involves checking conditions like sender validity, token amount, and ensuring successful transfer or minting. The solution should handle token issuance securely, updating balances and maintaining overall token supply constraints.",
        "url": 658
    },
    {
        "nl_input": "The query requires a function to create tokens that are only usable during an active sale. It involves checking if the sale is active, ensuring token availability, and managing token purchase limits. The process includes calculating total price based on tokens sold, updating balances, and transferring tokens to the buyer while adhering to sale constraints.",
        "url": 659
    },
    {
        "nl_input": "The query requires adding a property or functionality related to \"add prop\" in the context of a smart contract. Specifically, it involves adding an address to a set or activating a state for a given wallet address. The focus is on incorporating a new member or address with specific permissions or states within the contract's structure.",
        "url": 660
    },
    {
        "nl_input": "The query requires a function allowing the factory owner to withdraw any ERC20 asset tokens from the contract. The function should take the token address and the amount of tokens as parameters, ensure only the owner can call it, and return a boolean indicating success. It involves transferring specified ERC20 tokens to the owner.",
        "url": 661
    },
    {
        "nl_input": "The query requires a function to seal the Crowdsale upon completion. It needs to ensure the Crowdsale is finalized only when specific conditions are met, such as reaching the goal or exceeding the closing time. The solution should involve setting finalization flags, transferring funds if successful, or enabling refunds if unsuccessful.",
        "url": 662
    },
    {
        "nl_input": "The query requires a function to retrieve the total supply of a token in a smart contract. It should be publicly accessible, constant or view, and return a uint or uint256 value representing the total supply. The function name must be \"totalSupply\" and adhere to standard ERC-20 conventions for querying the total token supply.",
        "url": 663
    },
    {
        "nl_input": "The query requires a function that allows the requester to cancel their adoption request, refunding any associated funds and emitting an event to confirm cancellation. Specifically, it involves checking if the request exists, ensuring the caller is the original requester, transferring funds back to the requester, and clearing the request data.",
        "url": 664
    },
    {
        "nl_input": "The query requires an internal function to create, accept, and handle additionals for a request initiated by the payer. It involves processing request data, validating payee information, calculating expected amounts, collecting fees, updating requester details, creating the request, storing payment addresses, and accepting additions. The function ensures proper validation and execution within a smart contract environment.",
        "url": 665
    },
    {
        "nl_input": "The query requires a function to calculate the amount of tokens a sender is purchasing based on the input value. It involves determining the number of tokens using a rate or price conversion, potentially including bonuses or caps. The result should provide the token amount corresponding to the input value in a straightforward calculation process.",
        "url": 666
    },
    {
        "nl_input": "The query requires implementing a mechanism to handle variable-length arrays in Solidity, specifically focusing on concatenating or returning dynamic arrays. The provided code illustrates examples of returning dynamic arrays or strings by manipulating memory pointers and lengths, ensuring efficient handling of variable-sized data structures in smart contracts.",
        "url": 667
    },
    {
        "nl_input": "The query requires a smart contract function to set up a token sale, including parameters like initial date and token address. It ensures the token's total supply is zero and verifies the contract's ownership of the token. The setup initializes stages and durations for the sale, ensuring proper configuration before proceeding.",
        "url": 668
    },
    {
        "nl_input": "The query requires a function that allows the contract owner to lock it, ensuring it cannot be unlocked unless specific conditions are met. The desired functionality involves setting a lock status, emitting an event upon locking, and potentially allowing a single unlock instance. It focuses on controlling access and maintaining security through owner-only execution.",
        "url": 669
    },
    {
        "nl_input": "The query requires a function to create a Company entity with specified attributes (_name, _owner, _price) and handle its initialization, including validation of the price, storing company details, assigning a unique ID, and transferring ownership. The result should ensure proper company creation while adhering to defined constraints and emitting relevant events.",
        "url": 670
    },
    {
        "nl_input": "The query requires setting the cooldownEndTime for a given Dog based on its current cooldownIndex. This involves calculating the cooldownEndBlock by dividing the cooldown value at the current index by secondsPerBlock and adding the result to the current block number. If the cooldownIndex is less than 13, it should be incremented. The solution must update the Dog's cooldownEndBlock accordingly.",
        "url": 671
    },
    {
        "nl_input": "The query requires a function to perform update operations, specifically tracking changes by recording the address and value of each operation while incrementing an operation counter. The most relevant code demonstrates this by storing sender addresses and values in mappings and incrementing the operation index. Other codes involve permission updates but do not match the update operations requirement.",
        "url": 672
    },
    {
        "nl_input": "The query requires a function to assign the proceeds of a buyout among different parties, including the current owner, surrounding tile beneficiaries, and referrers, while also managing fees and prize pool funds. The function should handle cases where the current owner or referrers are not available and ensure proper distribution of funds.",
        "url": 673
    },
    {
        "nl_input": "The query requires a function to retrieve the RDN price in WEI during an auction at the time of the function call. It needs to consider the current state of bids, such as existing owners or minimal raise requirements, and return the price based on these conditions. The function should be publicly accessible and not alter any state.",
        "url": 674
    },
    {
        "nl_input": "The query requires a function to approve the transfer of a specified amount of tokens from the transaction creator to a recipient. The function should take the recipient's address and the amount as parameters, ensure the approval is implemented correctly, and return a boolean indicating success.",
        "url": 675
    },
    {
        "nl_input": "The query requires a modifier to ensure execution only when the crowdsale is active. It needs logic to check if the crowdsale is currently running, likely using time bounds (e.g., startTime and endTime) or a boolean flag (e.g., isCrowdsaleStopped). The solution should integrate seamlessly into a smart contract as a restrictive modifier.",
        "url": 676
    },
    {
        "nl_input": "The query requires implementing additional accessors for managing roles or permissions within a contract. This involves functions to add members with specific roles (e.g., bonus management), set access managers, and define successors, ensuring proper authorization and validation (e.g., non-zero addresses). The focus is on maintaining security and flexibility in role assignment and contract administration.",
        "url": 677
    },
    {
        "nl_input": "The query requires implementing a mechanism to lock the DAICO token supply until a specific date and time (2018-09-01 14:00:00). The solution should ensure that tokens cannot be transferred before this timestamp, likely using a time-based condition and modifier or function to enforce the lock.",
        "url": 678
    },
    {
        "nl_input": "The query requires a mechanism to adjust gas reimbursement during transfers when the sender's account falls below a minimum threshold. This involves modifying the gas amount based on specific conditions, ensuring efficient and fair transaction costs. The provided code examples do not directly match this requirement but involve adjustments and transfers in different contexts. A solution should dynamically adapt gas reimbursement according to account balances.",
        "url": 679
    },
    {
        "nl_input": "The query requires a function to transfer tokens from the owner to another address during the ICO phase. The function should ensure the ICO is active, validate the recipient address, check token balance, and confirm the sender is authorized (e.g., ICO contract). It also involves updating balances and emitting a transfer event.",
        "url": 680
    },
    {
        "nl_input": "The query requires a function to transfer tokens from one address to another, ensuring proper balance adjustments and approval checks. It needs to handle token transfers securely, confirming sufficient balances and allowances, while emitting a transfer event to log the transaction details. The solution should support ERC20 standards for compatibility with OBL contracts.",
        "url": 681
    },
    {
        "nl_input": "The query requires a function to accept ethers and purchase tokens on behalf of the user (msg.sender) using msg.value. The function should handle token calculation based on ether value, ensure valid beneficiary addresses, update balances, transfer funds appropriately, and emit relevant events for transparency and confirmation of the token purchase.",
        "url": 682
    },
    {
        "nl_input": "The query requires a function to return \"truth\" if the given account is allowed to buy tokens. It involves checking conditions related to account permissions and ensuring the transaction value is valid, as seen in the provided code snippets where account status and transaction details are verified before allowing token purchase.",
        "url": 683
    },
    {
        "nl_input": "The query requires a function to check if a specific project has been canceled. It needs to identify whether a project, based on its ID, is canceled directly or indirectly through its parent project. The function should traverse the project hierarchy and return a boolean value indicating the cancellation status of the specified project.",
        "url": 684
    },
    {
        "nl_input": "The query requires a mechanism to check if the market maker contract instance is open for public access. Specifically, it needs a modifier or function that uses a require statement to verify the openness of the market maker contract for public interaction, ensuring proper access control before executing related functions.",
        "url": 685
    },
    {
        "nl_input": "The query requires a function to update a sequence value at the next snapshot. It involves checking if a new snapshot is needed, comparing current and previous values, and updating or creating a new entry in the sequence based on conditions. The function ensures that unmodified values do not create unnecessary snapshots and handles empty sequences appropriately.",
        "url": 686
    },
    {
        "nl_input": "The query requires a function that enables sending ether to a Campaign, creating CampaignTokens in a chosen address. It involves handling token generation, ensuring contribution limits, and transferring ether. The function should consider time-based token bonuses, supply caps, and potential KYC requirements for large contributions.",
        "url": 687
    },
    {
        "nl_input": "The query requires a function to determine if a given promise can be collected by the recipient, checking if the promise's state is either confirmed or pending and if the current block timestamp is equal to or exceeds the lockedUntil time. The function should return a boolean value indicating whether the promise is collectible.",
        "url": 688
    },
    {
        "nl_input": "The query requires a function or modifier to manage the start time of a contract, ensuring it begins at a specified timestamp or block. It should include mechanisms to set, update, or verify the start time, potentially involving access control (e.g., onlyAdmin) and conditions to validate the new start time against current time or end time.",
        "url": 689
    },
    {
        "nl_input": "The query requires a function that allows the admin to finalize a sale, ensuring certain conditions are met (e.g., sale ended, goals reached). It should complete allocations, transfer funds, handle token burning if necessary, and update sale status. The solution must include security measures like ownership verification and proper state management.",
        "url": 690
    },
    {
        "nl_input": "The query requires a function to withdraw tokens under specific conditions. It involves checking if a process has closed and is finalized, ensuring the user's balance is positive before resetting it and delivering tokens. Alternatively, it may transfer remaining tokens to a recipient after certain time-based or sale-related conditions are met. The focus is on managing token withdrawal with conditional checks.",
        "url": 691
    },
    {
        "nl_input": "The query requires a function to facilitate token purchases on behalf of a benefactor. It needs to accept an identifier and benefactor's address, ensure non-zero value transactions, update payment records for both purchaser and benefactor, and forward funds to a multisig wallet while emitting relevant events. The solution should handle reverting invalid transactions and maintain accurate accounting.",
        "url": 692
    },
    {
        "nl_input": "The query requires a function that prepares compression data and triggers an event for buy or reload transactions. Specifically, it involves calculating amounts, updating balances, compressing data with timestamps and IDs, and emitting an event with detailed transaction information. The focus is on handling transaction data and ensuring relevant events are fired accurately.",
        "url": 693
    },
    {
        "nl_input": "The query requires a function to permanently stop the minting of tokens. The most relevant code provides a function `finishMinting()` that sets a boolean `isMintingFinished` to true, preventing further token minting and recording the date when minting stopped, ensuring tokens cannot be minted anymore.",
        "url": 694
    },
    {
        "nl_input": "The query requires a function to add a bonus to a specific block identified by coordinates (x, y). The function should ensure the bonus amount does not exceed the available bonus balance and update the block's bonus value accordingly. The implementation must involve key generation for block identification and state updates using storage functions.",
        "url": 695
    },
    {
        "nl_input": "The query requires a function to set a new rate with conditions or restrictions. It needs to ensure the rate is updated based on specific logic, such as balance thresholds, range limitations, or owner permissions. The function should dynamically adjust or validate the rate before applying changes, ensuring system integrity and proper access control.",
        "url": 696
    },
    {
        "nl_input": "The query requires a function to calculate the remaining release period of an account's specific stage. It involves checking frozen accounts, comparing current time with end times, and returning the difference if the release period is not over. If the release period has passed, it should return zero. The function needs to handle multiple stages and ensure the target address exists in the frozen accounts list.",
        "url": 697
    },
    {
        "nl_input": "The query requires a function to pay out tokens, ensuring the sender's balance is checked and sufficient. It involves transferring token amounts from the sender's balance to their address, utilizing an internal function. The process includes zeroing the sender's balance post-transfer and recording the transaction details with timestamps.",
        "url": 698
    },
    {
        "nl_input": "The query requires a function to transfer token ownership after the completion of a token sale. It needs to ensure the sale is finalized, verify conditions such as minimum tokens generated, and then execute the ownership transfer to a new address while maintaining security and validity checks.",
        "url": 699
    },
    {
        "nl_input": "The query requires a function allowing the owner or revoke role to change the revoke address, ensuring it doesn't match the owner, admin, or ops roles. The selected code must enforce these constraints and emit an event upon successful change. It involves access control and address validation within a smart contract.",
        "url": 700
    },
    {
        "nl_input": "The query requires an admin or bankroll function to change the bankroll address. The relevant code provides a function `setBankroll(address bankrollAddress)` that updates the bankroll address with proper access restrictions. It ensures only authorized roles (developer or current bankroll) can modify the bankroll address, maintaining security and control over address changes.",
        "url": 701
    },
    {
        "nl_input": "The query seeks to determine if a pre-sale condition is active based on time constraints and specific flags. It requires a function or modifier that evaluates whether the current time falls within a predefined pre-sale period and checks additional conditions like enabled status or available amount. The most relevant code should provide a boolean result indicating the pre-sale status.",
        "url": 702
    },
    {
        "nl_input": "The query requires identifying the code that allows a director to open contributions. The relevant code should have a function enabling the director to initiate or reopen a contribution period. Specifically, it involves a function accessible by the director role to change the state of contributions, allowing them to be active or open for participation.",
        "url": 703
    },
    {
        "nl_input": "The query requires a function to update or create a cloned token address. The desired functionality involves either updating an existing token address or creating a new clone token with specified parameters (e.g., snapshot block, name, symbol) and returning its address. The provided code includes examples of updating a token address and creating a cloned token.",
        "url": 704
    },
    {
        "nl_input": "The query requires a contract function that allows for self-destruction under specific conditions and sends remaining funds to the owner. It needs a time-based restriction before self-destruction is possible, ensures any balance is transferred to the owner, and then executes the self-destruct process securely. Only relevant aspects meeting these criteria should be described.",
        "url": 705
    },
    {
        "nl_input": "The query requires a function to claim tokens for an economic reserve wallet, ensuring the claim is time-locked and follows a vesting schedule. It calculates the unlocked token amount based on vesting stages, updates the claimed balance, and transfers the tokens to the reserve wallet address while emitting a distribution event.",
        "url": 706
    },
    {
        "nl_input": "The query requires a function to transfer a specified amount of funds from the sender's balance to a company address, ensuring the recipient address is valid and the sender has sufficient balance. The function should log the transaction and return a success status.",
        "url": 707
    },
    {
        "nl_input": "The query requires a function to calculate the asset valuation in ART token quantity. It needs to take the asset's valuation and the ART token price as inputs, then compute the equivalent ART token amount using conversion factors for oracle price decimals and decimal precision differences. The result should reflect the accurate token quantity based on provided prices and invested amounts.",
        "url": 708
    },
    {
        "nl_input": "The query requires a function to retrieve information associated with a specific ID. The desired functionality should return details corresponding to the given ID, such as an identifier and its related owner or data. Among the provided code snippets, the focus is on extracting or returning data linked to a specified ID within a contract.",
        "url": 709
    },
    {
        "nl_input": "The query requires a function to count the number of ELHTs tracked by the contract. The requirement is to implement or identify a function that returns the total count of ELHTs associated with the contract, similar to the provided examples which return counts of games, coins, or voters. The function should be publicly accessible and not modify the contract state.",
        "url": 710
    },
    {
        "nl_input": "The query requires a function to initiate a user upon their first visit, setting initial resources and map coordinates. Specifically, it needs to check if the user is not already initiated, then assign default resource values and map positions while updating the total city count. The most relevant code should include these initialization steps for new users.",
        "url": 711
    },
    {
        "nl_input": "The query requires a method to allow users with old proxy tokens to swap them for new tokens at a 1:2 ratio. The solution should involve transferring the old tokens from the user to an issuing token owner and then delivering twice the amount of new tokens to the user, ensuring the old tokens are no longer in the user's balance.",
        "url": 712
    },
    {
        "nl_input": "The query requires a function to facilitate the purchase of tokens from sellers, ensuring proper calculation of token prices, commissions, and transferring ownership while updating seller and buyer balances accurately. It involves iterating through available tokens for sale, handling payment, and managing transaction errors.",
        "url": 713
    },
    {
        "nl_input": "The query requires a function to calculate token amounts based on Ether (wei) input, applying different rates depending on the wei amount. It involves converting wei to tokens using predefined rates, with specific conditions for wei thresholds (e.g., 0.1 ether, 1 ether). The result should return the token amount, considering the 18-decimal precision for Ether and no decimals for NSP.",
        "url": 714
    },
    {
        "nl_input": "The query requires a function to remove an admin address from a system, ensuring the admin exists before removal. It involves updating a list or mapping of admins and possibly emitting an event upon successful removal. The function should handle internal state changes and may include access restrictions or conditions to prevent invalid operations.",
        "url": 715
    },
    {
        "nl_input": "The query requires a function to verify an address. The relevant code should include a function that sets a verification status for an address, ensuring it can toggle the verified state. It may involve checking permissions and updating the verification attribute associated with the address in the contract.",
        "url": 716
    },
    {
        "nl_input": "The query requires a modifier named \"onlyOwner\" to ensure that only the contract owner can execute specific functions. It checks if the sender of the message (msg.sender) is the same as the predefined owner. The correct implementation should use a require statement to confirm this condition before allowing execution to proceed. Incorrect versions, such as those with reversed logic, must be avoided.",
        "url": 717
    },
    {
        "nl_input": "The query requires a function to retrieve the total number of tokens in a contract. This involves identifying a variable or function, such as 'totalSupply', that returns the total token count. The relevant code should define or return the total tokens, either as a fixed value or through a calculation, ensuring it meets the requirement for obtaining the total token supply.",
        "url": 718
    },
    {
        "nl_input": "The query requires a function to retrieve the type of token (long or short) for a specified token address. The relevant code provides a function `getTokenType(address _token)` that returns the token type associated with the given token address from a mapping. This matches the requirement to identify token types based on their address.",
        "url": 719
    },
    {
        "nl_input": "The query requires a function to verify if an owner holds at least '_amount' shares of a specific company. It ensures the owner's share balance is greater than or equal to the specified '_amount', with '_amount' being non-zero. The function should be internal, view-only, and part of a contract system managing company shareholders and their share allocations.",
        "url": 720
    },
    {
        "nl_input": "The query requires a function to check if an ICO (Initial Coin Offering) is active based on specific conditions. It needs logic that evaluates whether the ICO status is active by comparing timestamps or checking available tokens and updating the status accordingly. The ideal solution involves determining ICO activity through predefined start and end times or token availability.",
        "url": 721
    },
    {
        "nl_input": "The query seeks to determine the success of a burning process in a smart contract context. It requires identifying whether tokens or specific addresses have been successfully burned, likely involving checks for existing burn statuses, multisignature validations, and updating supply or burner permissions accordingly. The focus is on confirming the outcome of the burning operation.",
        "url": 722
    },
    {
        "nl_input": "The query requires a function that allows a decentralized application (\u0110App) to accept Bitcoin transfers. Specifically, it needs a mechanism to handle Bitcoin investments by converting them into Ethereum addresses and values, facilitating interactions between Bitcoin and the \u0110App's internal investment system. The solution should involve a function that processes these transfers accurately and securely.",
        "url": 723
    },
    {
        "nl_input": "The query requires a function to calculate the number of tokens that have vested based on elapsed time and vesting schedule. It involves determining vested tokens using parameters like vesting start day, total vesting days, and the amount to be vested. The result should return the vested token count according to the given timeline.",
        "url": 724
    },
    {
        "nl_input": "The query requires a function to calculate the number of tokens receivable for a given Ether amount (_weiAmount), considering different rates based on the input value. The function should handle rate tiers, multiply the Ether amount by the appropriate rate, and return the resulting token amount, ensuring proper conversion using 'ether' for wei precision.",
        "url": 725
    },
    {
        "nl_input": "The query requires a function to throw an error if the order is expired. The relevant code should include a mechanism to check the current time against an expiration timestamp and ensure that an error or condition prevents further execution if the order has expired. This involves comparing timestamps and using conditions to enforce validity.",
        "url": 726
    },
    {
        "nl_input": "The query requires a mechanism to refund Ether to users if their token purchase request is rejected. This involves ensuring that when a user attempts to buy tokens and the transaction fails due to conditions not being met, the sent Ether should be returned to the user's address securely.",
        "url": 727
    },
    {
        "nl_input": "The query requires a function to transfer tokens within the Lava balances, ensuring proper subtraction and addition of token amounts in the balance mappings while maintaining internal consistency. The function should involve token transfers between specified addresses, updating balances accordingly, and potentially emitting a transfer event to confirm the transaction's success.",
        "url": 728
    },
    {
        "nl_input": "The query requires an internal function for handling transactions with ether, specifically focusing on withdrawing ether. The function should manage the transfer of ether to the sender's address, ensuring proper balance checks and updates. It may involve transferring specific amounts or splitting funds between multiple addresses while maintaining security and ownership restrictions.",
        "url": 729
    },
    {
        "nl_input": "The query requires a function to transfer ERC20 tokens with an activated modifier, ensuring only the owner can initiate the transfer. The function should include parameters for the token address and amount, utilizing the ERC20 transfer method while incorporating a security modifier to restrict access to authorized users.",
        "url": 730
    },
    {
        "nl_input": "The query requires a function to calculate the product of two 128-bit numbers and return the result as a 256-bit number. The calculation involves splitting the numbers into high and low parts, performing multiplications, and safely adding the results while ensuring no overflow occurs. The final result is shifted appropriately to maintain precision.",
        "url": 731
    },
    {
        "nl_input": "The query requires a function to handle post-ICO administration, ensuring at least the minimum token goal is met. It mandates distributing 10% of funds to cover operational expenses and allocating the remaining 90% to the company after verifying sale closure and deadline fulfillment. The function should also include security checks for authorized callers and manage remuneration stages effectively.",
        "url": 732
    },
    {
        "nl_input": "The query requires a function that can be separately used by derived contracts. The function \"seal\" in the first code snippet fulfills this requirement as it can be utilized in derived contracts, indicated by the modifier \"onlyOwner\" which suggests it's accessible to specific derived contracts or roles, allowing the setting of a \"sealed\" state to true.",
        "url": 733
    },
    {
        "nl_input": "The query requires setting the IPFS hash of an image for a couple, likely within a smart contract environment. The function should allow only the owner to set the hash and record this action with a timestamp and description. The focus is on storing the hash and documenting the event related to the couple's marriage image.",
        "url": 734
    },
    {
        "nl_input": "The query requires a mechanism to handle refunds or execute funds based on specific conditions. It needs functionality to either close the vault and finalize if the funding goal is met, or enable refunds if not. Additionally, it should include a refund process that transfers invested amounts back to contributors when the sale is unsuccessful.",
        "url": 735
    },
    {
        "nl_input": "The query requires a function that allows the owner to start or stop trading by setting a boolean value. The most suitable code provides a function named `startTrading`, which accepts a boolean parameter `_startStop` to control the trading status, ensuring only the owner can invoke it. This meets the requirement for starting and stopping trading dynamically.",
        "url": 736
    },
    {
        "nl_input": "The query requires functionality to tweak and update game-related parameters or statuses within a smart contract system. Specifically, it involves updating options (e.g., boxMax or game addresses) and ensuring valid game states (e.g., active games). The solution should include mechanisms for updating configurations and handling game outcomes or statuses.",
        "url": 737
    },
    {
        "nl_input": "The query requires a function to allow users to buy outcome tokens from a market maker. The function should specify the index and count of outcome tokens, calculate costs including fees, ensure sufficient funds are available, transfer collateral, and update the net outcome tokens sold while emitting an event for the purchase.",
        "url": 738
    },
    {
        "nl_input": "The query requires an internal function for handling withdrawals during stage three, ensuring the process is only executable by the creator/owner and after a specific stage condition is met. The function should transfer the contract's balance to the creator's address while validating the current stage status before initiating the withdrawal.",
        "url": 739
    },
    {
        "nl_input": "The query requires implementing a mechanism that always permits smart contracts (SCs) to upgrade themselves, even after a lockdown. This involves allowing an SC to transfer upgrade permissions to a new address while maintaining the ability to perform upgrades irrespective of locked states within the system. The provided code demonstrates methods for handling locks and transferring upgrade permissions.",
        "url": 740
    },
    {
        "nl_input": "The query requires a function to update the whitelist contract address. It needs to ensure the new address is valid and update the whitelist accordingly. The function should be accessible only to authorized users, such as operators or owners, and may involve interacting with interfaces or specific contract types for proper integration.",
        "url": 741
    },
    {
        "nl_input": "The query requires a function to transfer tokens owned by the contract to another address. It needs to ensure the token amount is valid, possibly involve ownership checks, and confirm successful transfer execution. The solution should handle balances properly and may include restrictions or conditions for the transfer process.",
        "url": 742
    },
    {
        "nl_input": "The query requires a function to transfer tokens from one address (_from) to another (_to), with the ability to specify the token type and amount. The selected code should ensure sufficient balance and approval, then execute the transfer while maintaining accurate balances and emitting a transfer event if necessary.",
        "url": 743
    },
    {
        "nl_input": "The query seeks to determine the number of tokens one can obtain, specifically requiring a function that calculates token amounts based on input values. It needs a clear definition of how many tokens are available or can be acquired, potentially involving functions like 'howManyTokensForEther' or 'tokenUnits'. The focus is on understanding token distribution or calculation logic within smart contracts.",
        "url": 744
    },
    {
        "nl_input": "The query requires a function to return the composition price of a specific token ID. It needs a mapping or storage mechanism that associates token IDs with their respective composition prices, allowing retrieval through a function call with the token ID as input. The function should be publicly accessible and not alter the contract's state.",
        "url": 745
    },
    {
        "nl_input": "The query requires a function to enable trading for everyone. The most suitable code should have a function that sets a boolean variable to true, allowing public trading without restrictions. It involves an action triggered by an authorized user (e.g., admin/owner) to open trading in a smart contract environment.",
        "url": 746
    },
    {
        "nl_input": "The query requires a function to confirm if a document is a valid certification, which is a paying feature. The needed function takes an address and document hash as inputs, checks its validity status, and returns a boolean value indicating whether the document is indeed a valid certification for the specified student.",
        "url": 747
    },
    {
        "nl_input": "The query requires enabling a pre-sale functionality by setting a boolean value. Specifically, it involves defining or modifying a function to determine if the pre-sale is active based on time constraints or a specific flag. The solution should allow for setting an account's sale status and ensuring proper access control for this operation.",
        "url": 748
    },
    {
        "nl_input": "The query requires a function to refund ETH to destination addresses. It needs to ensure the correct amount is transferred, possibly involving checks or conditions before executing the refund. The solution should support transferring ETH to one or multiple addresses as specified.",
        "url": 749
    },
    {
        "nl_input": "The query requires a function or modifier that changes or checks the state of a contract. This could involve setting a distributor's state, enforcing a specific release state, or ensuring the contract is in a particular phase (e.g., PreFunding or Funding). The provided code examples demonstrate modifiers and functions that manage or validate contract states.",
        "url": 750
    },
    {
        "nl_input": "The query requires a function to return the number of signers associated with a specific function. It needs to count or retrieve the total signers linked to a particular operation or proposal within a smart contract, ensuring only valid and non-duplicate signers are counted. This functionality supports multi-signature verification processes.",
        "url": 751
    },
    {
        "nl_input": "The query requires a function to set or update a token address in a smart contract, ensuring the address is only modifiable under specific conditions (e.g., by the founder or owner) and can confirm whether the token address has been successfully set or updated.",
        "url": 752
    },
    {
        "nl_input": "The query requires a function to facilitate the purchase of tokens from a reserve, ensuring the buyer's address is valid, sufficient balance exists, and proper value is sent. It involves transferring funds, updating balances, and recording the transaction details for transparency and accuracy.",
        "url": 753
    },
    {
        "nl_input": "The query requires a function to update statistics associated with a specific token ID. It should allow modifying the stats of an asset, ensuring only authorized contracts can perform this action. The most relevant code provides a function to update stats for a given token ID by replacing its current stats with new ones.",
        "url": 754
    },
    {
        "nl_input": "The query requires a function to return the count of \"dicks,\" likely referring to elements in a list or array named \"biggestDicks.\" The desired functionality is to retrieve the number of items stored, as indicated by the length property. This matches a simple counting mechanism within a smart contract context.",
        "url": 755
    },
    {
        "nl_input": "The query requires a function to create a WorkOrder by consuming a market order, locking the associated cost, and emitting the work order to a worker pool. It involves parameters such as market order index, worker pool address, app address, dataset address, and callback details, returning the created WorkOrder address.",
        "url": 756
    },
    {
        "nl_input": "The query requires creating a Collateralized Debt Position (CDP) using all the Dai in the sender's balance (with prior approval), then reinvesting the created Dai within the CDP until a target liquidation price or minimum investment is reached. The provided code includes a function to create a leveraged CDP with Dai and reinvest affiliate dividends, aligning with the reinvestment aspect.",
        "url": 757
    },
    {
        "nl_input": "The query requires overriding the _processPurchase function from the Crowdsale contract to customize token allocation logic. Specifically, it involves updating a beneficiary's deposited tokens by adding a calculated token amount. The focus is on integrating this functionality within the contract while ensuring proper token management and accounting for purchases.",
        "url": 758
    },
    {
        "nl_input": "The query requires calculating the fee charged on top of a value being sent. The relevant code should define how the fee is determined, applied, or enforced during a transaction, ensuring that the fee is accounted for and potentially sent to a specified address if conditions are met. This involves checking configurations, sender privileges, and handling insufficient funds scenarios.",
        "url": 759
    },
    {
        "nl_input": "The query requires a function to load the ETH balances of all accounts, returning an array of balances and the total balance. It involves iterating through a list of accounts, retrieving each account's balance, storing them in an array, and calculating the total balance of all accounts combined. The implementation should be compatible with Ethereum's balance-checking mechanisms.",
        "url": 760
    },
    {
        "nl_input": "The query requires checking if a specific asset/currency amount has been approved in the Oversight address. It needs a function to validate the approval status of an asset/currency by interacting with the Oversight contract, ensuring the specified amount is verified before proceeding. The focus is on approval validation within the Oversight context.",
        "url": 761
    },
    {
        "nl_input": "The query requires a function to allocate tokens to investors. The function should be callable by the owner and allow specifying the investor's address and the number of tokens to be minted or sent. It may include conditions to ensure the transaction's validity, such as checking timestamps, supply caps, or nonzero addresses.",
        "url": 762
    },
    {
        "nl_input": "The query requires a function to process a list of transfers by deconstructing combined input data (amount and address) to save gas and storage costs. It involves validating and splitting the long number into an address and amount, then storing these in a transfer list for distribution while ensuring data integrity and efficiency.",
        "url": 763
    },
    {
        "nl_input": "The query requires a function to allocate tokens to specific addresses or entities. The desired functionality involves distributing predefined amounts of tokens through a function call, ensuring the allocation process is controlled and potentially restricted to authorized users or conditions. The implementation should support multiple allocations in a single function execution.",
        "url": 764
    },
    {
        "nl_input": "The query requires a function to determine the amount of tokens approved for transfer. This involves checking the allowance or approved balance of tokens that one address can spend on behalf of another. The focus is on retrieving this specific token amount, ensuring it reflects correctly the permitted transferable tokens within a smart contract system.",
        "url": 765
    },
    {
        "nl_input": "The query requires an event handler that processes the \"token received\" event, ensuring the token and sender are valid, updating the total tokens received, and possibly interacting with a token contract. It involves handling token reception, validation, and maintaining state updates upon receiving tokens.",
        "url": 766
    },
    {
        "nl_input": "The query requires a function allowing investors to latch Fci by themselves. The relevant code shows that an investor can stake their balance in a specific round, provided the round is open and not withdrawable, and the process is not paused. The function updates the user's stake for the specified round based on their current balance.",
        "url": 767
    },
    {
        "nl_input": "The query requires a function to remove an existing certificate authority, ensuring it cannot issue new certificates. The desired functionality should include deleting the certificate authority's entry and logging the removal action. It must also ensure only authorized users can perform this operation.",
        "url": 768
    },
    {
        "nl_input": "The query requires a function to discard or reset stored values, analogous to \"throwing away the stash.\" The most relevant code describes a function that resets balances and airdrop values for beneficiaries, effectively cleaning the stored data. This matches the requirement to discard or clear accumulated information.",
        "url": 769
    },
    {
        "nl_input": "The query requires a function to withdraw ether to a wallet. It should include functionality where ether is transferred to specified addresses or the caller's wallet, potentially involving conditions or restrictions on the amount that can be withdrawn, as well as ensuring only authorized parties (e.g., the owner) can perform the withdrawal.",
        "url": 770
    },
    {
        "nl_input": "The query requires a function that returns a boolean value indicating whether the sale is currently active. Specifically, it needs to check the status of the sale and return true if the sale is active, using a predefined variable or logic to determine the current sale status.",
        "url": 771
    },
    {
        "nl_input": "The query requires functionality to migrate a specified value from one account to another within a contract system. It involves checking conditions such as valid migration agent, sufficient balance, and positive value. The migration updates balances, total supply, and migrated values, interacting with a MigrationAgent contract to complete the transfer and emitting a migration event.",
        "url": 772
    },
    {
        "nl_input": "The query requires a function to withdraw funds from the contract's balance. It should allow the owner to specify an amount and transfer it to their address, potentially triggering an event to log the withdrawal. The function may include conditions to ensure the contract's state permits the withdrawal.",
        "url": 773
    },
    {
        "nl_input": "The query requires a function to calculate the maximum number of extant nomins, which is the sum of the nomin pool and the total (circulating) supply. The relevant code should include a function that adds the nomin pool to the total supply and returns the result. This ensures the calculation of the overall cap for nomins in the system.",
        "url": 774
    },
    {
        "nl_input": "The query requires a function to be executed after the crowdsale ends, performing finalization tasks such as transferring funds, enabling refunds if goals are not met, minting tokens, finishing token minting, and marking the crowdsale as finalized. It ensures specific conditions are met before execution, like checking if the crowdsale has ended or if goals have been reached.",
        "url": 775
    },
    {
        "nl_input": "The query requires a function to set the paused state of NFTs, allowing the owner to toggle the pause status and emit an event reflecting the change. The relevant code should include a function that accepts a boolean parameter to update the paused state and notifies listeners of the change through an event.",
        "url": 776
    },
    {
        "nl_input": "The query requires a function to sell outcome tokens to a market maker, specifying the token index, count, and minimum profit. The function calculates profit, deducts fees, transfers tokens from the seller to the contract, and sends the profit to the seller, ensuring non-negative token counts and sufficient profit.",
        "url": 777
    },
    {
        "nl_input": "The query requires a function allowing users to summon a hero daily for free. The code should ensure that each user can only perform this action once every 24 hours, generate a random hero rank based on predefined probabilities, and call a function to summon the hero for the user. Only the first code snippet matches these requirements.",
        "url": 778
    },
    {
        "nl_input": "The query requires implementing a mechanism to allow another address the right to transfer a specific monster using the `transferFrom()` function. This involves setting up an approval system where an address can grant or revoke permission for other addresses to transfer tokens (or monsters) on its behalf, typically through a mapping of allowed addresses.",
        "url": 779
    },
    {
        "nl_input": "The query requires generating a unique key for a stock by combining the market and symbol. The relevant code defines a function that concatenates bytes of market and symbol to form a 12-byte key using assembly for direct memory loading, ensuring a unique identifier for each stock based on its market and symbol combination.",
        "url": 780
    },
    {
        "nl_input": "The query requires a function to handle refunds when KYC analysis fails. It needs to check conditions like unsuccessful sale, validate user contributions, update balances, and transfer the refund amount back to the user's address while logging the refund action. The function should ensure proper error handling and maintain accurate records of tokens and contributions.",
        "url": 781
    },
    {
        "nl_input": "The query requires a modifier function named \"onlyEtheraffle\" that ensures specific functions in the contract can only be executed by the Etheraffle address. This is achieved by checking if the sender of the message matches the predefined Etheraffle address before allowing the function to proceed. The provided code demonstrates this functionality with the \"onlyEtheraffle\" modifier.",
        "url": 782
    },
    {
        "nl_input": "The query requires a function to set the arbitration fee per juror, allowing authorized users to update this value. The desired function should accept a parameter for the new fee amount and update the corresponding variable, ensuring proper access control and potentially including validation or event emission for transparency.",
        "url": 783
    },
    {
        "nl_input": "The query requires modifying the DINRegistrar contract to include functionality for setting a new registrar address, allowing self-registration of DIN with a resolver, and managing distributor states. The changes should incorporate access control, such as ownership restrictions, and ensure proper event emissions for transparency.",
        "url": 784
    },
    {
        "nl_input": "The query requires a function to perform batch transfers of tokens from the owner's balance to multiple addresses. The most suitable code should allow the owner to send specified token amounts to several addresses in one operation, ensuring efficiency and correctness in transferring tokens while maintaining balance integrity.",
        "url": 785
    },
    {
        "nl_input": "The query requires enabling the TeamWithdraw state in a smart contract, setting up an initial budget plan with specific parameters such as proposal ID, budget amount, start/end times, and official voting time. It involves transitioning the contract state to TeamWithdraw and initializing the first budget plan based on the current balance and predefined rates.",
        "url": 786
    },
    {
        "nl_input": "The query requires a function to set initial shareholders, ensuring that each shareholder is unique and not the owner. It should add new shareholders sequentially, updating the shareholder count. The function must validate inputs, confirming that the new shareholder address is valid and not already assigned, before adding them to the contract's shareholder list.",
        "url": 787
    },
    {
        "nl_input": "The query requires a function to modify gift properties, such as price, description, and URL, with the ability to verify gift existence. It involves updating specific attributes of a gift stored in a contract, ensuring only the owner can perform these changes. The reference code demonstrates this functionality by showing how to update gift details using a structured storage system.",
        "url": 788
    },
    {
        "nl_input": "The query requires a function to calculate the locked token amount for investors, which will be released in three batches over time. The function should consider the current time and the investor's delivery date to determine the releasable amount based on predefined time intervals (e.g., 90 and 180 days).",
        "url": 789
    },
    {
        "nl_input": "The query requires a function to reset a bag's level to 0 if it hasn't been purchased in over 'timeout' periods, while keeping the existing owner unchanged. It involves checking the time elapsed since the last purchase and resetting the level if the timeout has been exceeded, without affecting the bag's ownership.",
        "url": 790
    },
    {
        "nl_input": "The query requires implementing an investment function based on a pricing strategy. The function should calculate the number of tokens bought using the invested amount and the defined pricing strategy, which may involve rate calculations. It must integrate with existing contract structures to ensure proper token distribution according to the investment value.",
        "url": 791
    },
    {
        "nl_input": "The query requires a function that handles both locked and unlocked tokens within a contract. It needs to include mechanisms for calculating vested tokens, transferring unlockable tokens to users, and managing token locking/unlocking statuses. The solution should involve functions for unlocking vested tokens, issuing tokens with locking options, and ensuring proper state updates during these processes.",
        "url": 792
    },
    {
        "nl_input": "The query requires a function that allows the contract owner to set a time duration after which a price is considered stale. The relevant code should include a function where the owner can specify a stale time, ensuring prices older than this duration are not valid. This involves setting a timestamp or time value within the contract logic.",
        "url": 793
    },
    {
        "nl_input": "The query requires a function that, when called by the owner, unpauses the contract and returns it to a normal state. The function should set the 'paused' variable to false and may emit an 'Unpause' event. It must ensure only the authorized entity (owner/manager) can invoke it while the contract is in a paused state.",
        "url": 794
    },
    {
        "nl_input": "The query requires a modifier or function ensuring token purchases occur only within a predefined time range (start and end dates). It should restrict purchases before the start date and after the end date, maintaining the integrity of the sale period. This ensures tokens are sold exclusively during the designated timeframe.",
        "url": 795
    },
    {
        "nl_input": "The query requires a function to facilitate the purchase of tokens during a presale. It should handle token calculation based on exchange rates, transfer funds, update token sale records, adjust total supply, and emit purchase events. The function must ensure proper beneficiary allocation and confirm successful token transfers before finalizing the transaction.",
        "url": 796
    },
    {
        "nl_input": "The query requires a function allowing participants to withdraw funds if the pre-sale does not meet the minimum funding level. The function should check if the pre-sale end date has passed, verify the total funding is below the required minimum, ensure the participant's balance is sufficient, and send the specified value back to the participant.",
        "url": 797
    },
    {
        "nl_input": "The query requires a function to allow users to claim all vested tokens up to the current date. The solution should involve checking the vested amount based on elapsed time and transferring the appropriate token quantity to the user. It needs to ensure that the tokens are released according to a predefined vesting schedule.",
        "url": 798
    },
    {
        "nl_input": "The query requires a function that allows the owner of a contract to mint new coins. The function should ensure that only the owner can perform this action, update the total supply of coins, and adjust the balance of the owner accordingly. Security measures, such as preventing reentrancy or ensuring valid inputs, are also important considerations.",
        "url": 799
    },
    {
        "nl_input": "The query requires a function to determine if the crowdsale has started by checking if the current block number is greater than or equal to the start block. It needs a boolean return indicating whether the start condition has been met, focusing on block progression rather than time.",
        "url": 800
    },
    {
        "nl_input": "The query requires a function to validate transcoding options strings. Specifically, it checks if the string length is greater than zero and divisible by a predefined VIDEO_PROFILE_SIZE constant, ensuring proper formatting and structure for transcoding profiles. The function should return a boolean value indicating validity.",
        "url": 801
    },
    {
        "nl_input": "The query requires a function to set points for tokens between the last chunk and a specified amount. It needs to iterate through tokens, calculate points using `calculateTokenPoints`, update a mapping, and handle worst-case tokens within a limit. The process updates the `lastCalculatedToken` after processing the given amount.",
        "url": 802
    },
    {
        "nl_input": "The query requires a function to remove a received foreign token, ensuring the token address is not zero. The most suitable code defines a function that deletes the token from storage and emits an event, confirming the removal. It enforces safety by validating the token address before proceeding with deletion.",
        "url": 803
    },
    {
        "nl_input": "The query requires a mechanism to allow addresses to participate early, involving whitelisting with status, minimum and maximum caps. The solution should verify the address, ensure caps are valid, and update the whitelist accordingly, notifying of new or changed entries while maintaining participation constraints within a defined period.",
        "url": 804
    },
    {
        "nl_input": "The query requires a function to add a wallet to additional bonus members. The desired functionality should allow the owner to activate a bonus state for a specified wallet, ensuring it is included in the list of bonus members. This involves updating the state of the given wallet to \"Active\" within the contract's data structure.",
        "url": 805
    },
    {
        "nl_input": "The query requires creating an auction for a specific deed, involving parameters such as deed ID, start price, end price, and auction duration. The code should ensure proper permissions, validate input values, escrow the deed, and store the auction details with a timestamp. It must also enforce minimum duration constraints and associate the auction with the deed owner.",
        "url": 806
    },
    {
        "nl_input": "The query requires a function to add a holder to a list of holders, ensuring the holder is not already added. It should include logic to maintain a unique list of holders and update a mapping or counter for tracking holder positions or existence within the list. The implementation must avoid duplicate entries effectively.",
        "url": 807
    },
    {
        "nl_input": "The query requires a function to check the existence of an asset, specifically determining if an asset has been created by verifying its owner. The most suitable code provides a function 'isCreated' that takes a bytes32 symbol as input and returns a boolean indicating whether the asset's owner is not zero, signifying its existence.",
        "url": 808
    },
    {
        "nl_input": "The query requires a function to withdraw ether from a contract, typically restricted to the owner. It involves transferring the contract's balance to the owner's address. Some variations include withdrawing a specific amount or distributing it to multiple addresses, but the core requirement is an owner-restricted ether withdrawal mechanism.",
        "url": 809
    },
    {
        "nl_input": "The query requires a function to check if a pet is on a sponsored leaderboard, ensuring each pet is associated with only one such leaderboard at a time. The relevant code should include a mapping or storage mechanism to track pets on leaderboards and a function to verify this status using the pet's ID.",
        "url": 810
    },
    {
        "nl_input": "The query requires extracting transfer configurations, including base, rate, collector, no_transfer_fee status, and minimum_transfer_amount from a smart contract function. It focuses on reading and returning these specific parameters related to transfer settings, as demonstrated in the reference code. Other codes relate to transfer control and execution but do not meet the query's needs.",
        "url": 811
    },
    {
        "nl_input": "The query requires a function to transfer tokens as a service, executable only by authorized masters. It needs to handle token transfers between specified addresses while ensuring the transaction is approved and conducted by authorized entities. The function should include parameters for the sender, receiver, and token amount, with restrictions ensuring security and proper authorization.",
        "url": 812
    },
    {
        "nl_input": "The query requires a function to withdraw the house stake, ensuring the remaining stake meets the minimum requirement and covers any potential losses. The most suitable code is from 'contract c12677', which defines the `withdrawHouseStake` function with conditions to validate the withdrawal amount and update the house stake accordingly before transferring funds to the owner.",
        "url": 813
    },
    {
        "nl_input": "The query requires a function to transition to the next round in a multi-phase system, setting start and end times, adjusting token caps based on remaining tokens, and updating the current phase. It involves iterating through phases, ensuring proper time and token allocation, and emitting an event upon successful transition.",
        "url": 814
    },
    {
        "nl_input": "The query requires a function to change the crowdsale stage based on a given value. It involves setting a specific stage (e.g., PreICO or ICO) by matching the input value and updating the current stage accordingly. The solution should include logic for validating and transitioning between stages in a crowdsale process.",
        "url": 815
    },
    {
        "nl_input": "The query requires a function to validate parameters and return a boolean value indicating their validity. Specifically, it checks conditions such as array length consistency, monotonic increase in amounts and dates, or parameter ranges (e.g., rate within MIN_RATE and MAX_RATE). The validation ensures correctness and adherence to predefined rules for inputs like sale kinds, expiration times, or numeric rates.",
        "url": 816
    },
    {
        "nl_input": "The query requires a function that allows the contract owner to transfer ownership of a top-level domain. The desired functionality should include specifying the domain node and setting a new owner address, ensuring the caller is authorized (e.g., `onlyOwner`). It involves interacting with a registry or registrar to update domain ownership records.",
        "url": 817
    },
    {
        "nl_input": "The query requires a function for external winery operations, allowing authorized users to add operation details such as track ID, operation ID, code, date, area code, and ICQRF code. The function should log the operation and confirm success. It involves mapping identities, emitting logs with relevant data, and ensuring only authorized wineries can execute the function.",
        "url": 818
    },
    {
        "nl_input": "The query requires modifying the code to ensure that any missed payday for an employee carries over the owed pay to the next pay period. This involves updating the logic to accumulate unpaid amounts and include them in future payments, maintaining accurate records of owed salaries for each employee.",
        "url": 819
    },
    {
        "nl_input": "The query requires a function allowing users to sell tokens for ETH, with the user needing to set an allowance for the contract beforehand. The code should handle transferring tokens from the user to the contract and sending ETH back to the user based on the token amount sold.",
        "url": 820
    },
    {
        "nl_input": "The query requires a function to calculate token amounts based on an invested amount and a rate. It involves multiplying the invested amount by a rate-derived value, potentially adjusting for different tiers or conditions, and returning the resultant token quantity. The focus is on handling rates and ensuring accurate token distribution according to specific logic.",
        "url": 821
    },
    {
        "nl_input": "The query requires a function to subtract two numbers, ensuring it reverts or handles overflow. Specifically, it needs a mechanism to check if the second number is greater than the first and either return zero or revert the operation to prevent underflow. This ensures safe mathematical subtraction within smart contracts.",
        "url": 822
    },
    {
        "nl_input": "The query requires a function to lock the maximum supply at its current value permanently. The desired function should set a boolean flag to true, indicating that the max supply is locked, and emit an event with relevant details. It must ensure that this action can only be performed by the contract owner and in the absence of ether transactions.",
        "url": 823
    },
    {
        "nl_input": "The query requires a function to allow users to claim IBC tokens based on specific conditions, such as sale stage, funding goals, and prediction bonuses. It involves updating sale stages, calculating token amounts with potential bonuses, resetting balances, distributing tokens, and transferring rewards to users while emitting an event for token claiming.",
        "url": 824
    },
    {
        "nl_input": "The query requires a function to create or activate a special manager. The desired functionality involves enabling a manager address, ensuring it is unique and valid, and updating its status in mappings or lists. Additionally, the process should emit events or return values indicating success or failure of the activation.",
        "url": 825
    },
    {
        "nl_input": "The query requires an initialization function to be executed post-deployment, ensuring proper contract setup. It should include ownership verification, initialization status checks, and setting initial parameters like prices, block numbers, and flags. The function must prevent re-initialization and ensure the contract is ready for operation after deployment. Only relevant code aspects meeting these criteria should be considered.",
        "url": 826
    },
    {
        "nl_input": "The query requires a function to transfer tokens to a specified receiver, ensuring the sender is authorized and the amount does not exceed the available deposit. It involves token transfer logic with balance updates and authorization checks, as seen in the provided code examples. The focus is on implementing a secure and functional token-sending mechanism.",
        "url": 827
    },
    {
        "nl_input": "The query requires a function to determine if the calldata specifications of two orders can match by comparing their buy and sell calldata, considering replacement patterns. It involves replacing specific parts of the calldata based on given patterns and then checking for equality between the modified calldata arrays. The result is a boolean indicating whether the calldata matches.",
        "url": 828
    },
    {
        "nl_input": "The query requires a function that allows the current owner to transfer contract ownership to a new address, ensuring the new owner is not a zero address. It involves an \"onlyOwner\" modifier to restrict access and may include an event or require statement for validation. The function name could be transferOwnership or changeOwnership, accepting the new owner's address as a parameter.",
        "url": 829
    },
    {
        "nl_input": "The query requires a function to return the balance of a specific account in a token contract. It needs a method like `balanceOf(address)` which takes an address as input and returns the corresponding balance stored in the contract's mapping for that address. The solution should be view-only and efficiently retrieve the balance value.",
        "url": 830
    },
    {
        "nl_input": "The query requires a function to pay unpaid dividends to shareholders. It needs to calculate the shareholder's dividend based on their shares, ensure sufficient funds, update dividend records, and transfer the calculated amount to the shareholder's address. The solution should handle dividend distribution logic, including tracking shares, amounts, and total dividends.",
        "url": 831
    },
    {
        "nl_input": "The query requires a function to calculate the user's share percentage based on BMC days and total BMC deposit for a given date. It involves determining the period index, retrieving BMC days for the user, calculating the total BMC deposit, and returning the share percentage using precise percent calculation. If no valid date is provided, it defaults to the current date.",
        "url": 832
    },
    {
        "nl_input": "The query requires a function to toggle a boolean state for debugging purposes in Solidity contracts using online tools like Remix. The most relevant code should include a toggle functionality, allowing the owner to switch a specific contract state (e.g., prebridge) between true and false. This supports dynamic contract behavior during development.",
        "url": 833
    },
    {
        "nl_input": "The query requires a modifier to restrict function access, allowing calls only from a specified exchange contract. The relevant code demonstrates an \"onlyExchange\" modifier that uses a require statement to ensure the caller (msg.sender) matches the address of the defined exchange contract, thereby enforcing the restriction. This ensures exclusive access to functions by the designated exchange.",
        "url": 834
    },
    {
        "nl_input": "The query requires a function to unlock vested tokens and transfer them to the grantee. It involves checking the vested amount, calculating transferable tokens, updating the transferred balance, reducing the total vesting, and finally transferring the tokens to the grantee while emitting an event for the transaction.",
        "url": 835
    },
    {
        "nl_input": "The query requires a function that adjusts a rate value based on specific conditions, potentially involving bonuses or thresholds. The focus is on manipulating rates with arithmetic operations and conditional checks, ensuring the final rate aligns with predefined criteria. The provided code examples inform this requirement by showcasing rate calculations, bonus additions, and balance-based adjustments.",
        "url": 836
    },
    {
        "nl_input": "The query requires a function to retrieve ether from a contract. Specifically, it needs a function that can handle ether balance retrieval, potentially interacting with ERC20 tokens or directly accessing the contract's ether balance. The ideal function should be able to return the ether balance held within the contract when called.",
        "url": 837
    },
    {
        "nl_input": "The query requires a function to retrieve a contract's address by its name. It needs to check if the contract exists and return its address if it does. The function should be external and view-only, ensuring no state changes occur during the retrieval process.",
        "url": 838
    },
    {
        "nl_input": "The query requires a function to handle internal balances, specifically focusing on retrieving or setting balance values. The most relevant code should provide functionality to either get the balance of a user (via `msg.sender`) or set the balance for a specific address internally. This involves interacting with a `balances` mapping within a smart contract context.",
        "url": 839
    },
    {
        "nl_input": "The query requires a function to transfer ownership of an SSP record. The needed code should accept the current key (identifier for the SSP record) and the new owner's address, updating the ownership accordingly while ensuring the new owner is valid and not a zero address. It involves secure ownership transfer with proper authorization checks.",
        "url": 840
    },
    {
        "nl_input": "The query requires a function to drain Ether from a contract. The most suitable code provides a function named `withdrawEther` that transfers the contract's entire balance to the owner, fulfilling the requirement for draining funds securely and efficiently. Other options include specific amount draining or conditional draining, but the primary need is for a straightforward Ether withdrawal mechanism.",
        "url": 841
    },
    {
        "nl_input": "The query requires a mechanism to issue tokens based on the amount of Ether received. The system should calculate the number of tokens corresponding to the Ether value, ensure the transaction meets minimum requirements, update token balances, and transfer Ether to a designated wallet. It may also involve rate calculations and cap restrictions to manage token issuance effectively.",
        "url": 842
    },
    {
        "nl_input": "The query requires a function to append a uint value (in decimal format) to a string. The function should convert the uint into its decimal representation and concatenate it to the given string, returning the resulting string. This involves handling the uint conversion and ensuring proper string manipulation for seamless concatenation.",
        "url": 843
    },
    {
        "nl_input": "The query requires a method that distributes tokens proportionally to contributors after a contribution period ends. The method should be callable by the owner, calculate each contributor's share based on their contribution, mark them as compensated, and transfer the tokens accordingly. It involves iterating through contributors, ensuring they haven't been compensated already, and updating compensation details.",
        "url": 844
    },
    {
        "nl_input": "The query requires a function to remove a destroyer's privilege by modifying their status and updating the list of destroyers. The function should ensure the destroyer is currently active, adjust the destroyer array by removing the specified address, and log the removal action with a timestamp.",
        "url": 845
    },
    {
        "nl_input": "The query requires a function that allows an account to place a higher bid on a token. The function should check if the new bid exceeds the existing bid, update the highest bidder and bid amount, and handle any refunds for the previous highest bidder. It should also emit an event confirming the increased bid.",
        "url": 846
    },
    {
        "nl_input": "The query requires retrieving the balance of a token associated with a contract, specifically using the ERC20 token interface to check the balance of the \"Faucet\" token. The relevant code should use the `balanceOf` function from the ERC20 standard to return the token balance for the given contract address.",
        "url": 847
    },
    {
        "nl_input": "The query requires a function to set the price for the EXH Token. It needs a method that allows updating or setting the token price, possibly with restrictions to authorized users only. The provided code examples demonstrate different approaches to managing token prices, including updating based on stages, calculating dynamically, or setting directly via a dedicated function.",
        "url": 848
    },
    {
        "nl_input": "The query requires a function to calculate the TOTAL payout per tier using the odds method. It involves determining winnings based on the number of winners and matching index through an odds calculation, as seen in the provided code snippets. The focus is on multiplying single odds by the number of winners to derive the total payout for each tier.",
        "url": 849
    },
    {
        "nl_input": "The query requires a function to allow the owner to withdraw a specified amount of funds from a contract's balance. The function should ensure only the owner can initiate the withdrawal, verify sufficient balance, and transfer the exact amount to the owner's address.",
        "url": 850
    },
    {
        "nl_input": "The query requires creating an original artwork using a given genome. The code should allow the caller to generate a unique piece of art by utilizing a specific genome and assigning it to an owner, either predefined or defaulting to the sender. It must ensure limitations on the number of artworks and handle payments or permissions accordingly.",
        "url": 851
    },
    {
        "nl_input": "The query requires a function to transfer tokens between addresses, ensuring proper balance adjustments and adherence to conditions like token tradeability and ownership restrictions. The function should handle token subtraction from the sender, addition to the receiver, and potentially include checks for token amounts, time constraints, or special address permissions.",
        "url": 852
    },
    {
        "nl_input": "The query requires a function that calculates the index of a 2D array position (_x, _y) and ensures the coordinates are within the grid size. If either coordinate is off-grid, an exception should be thrown. The function should return the calculated index using the formula: _x * size + _y.",
        "url": 853
    },
    {
        "nl_input": "The query requires a function to slice 20 contiguous bytes from a byte array, starting at a specified position. The function should take the byte array and starting position as inputs and return a 20-byte slice. The code needs to handle byte manipulation and bit-shifting to construct the resulting 20-byte output accurately.",
        "url": 854
    },
    {
        "nl_input": "The query requires a function modifier to verify if the `msg.sender` matches a specific address or contract. The provided code examples demonstrate modifiers that enforce conditions on `msg.sender`, ensuring it aligns with predefined addresses or contracts, such as `ContractResolver`, `burnAddress`, or `GDPOracle_`. The requirement is to create a similar modifier for this purpose.",
        "url": 855
    },
    {
        "nl_input": "The query requires a function to return an array containing the count of different weapons in an army, specifically drones, planes, helicopters, and tanks, associated with a given army ID. The result should be a tuple or array with these four counts in the specified order.",
        "url": 856
    },
    {
        "nl_input": "The query requires setting the PriceSetter address, allowing it to set a token price in wei. The relevant code defines a function to update the PriceSetter address with access control, ensuring only the contract owner can modify it. This function facilitates assigning a new PriceSetter responsible for managing token prices.",
        "url": 857
    },
    {
        "nl_input": "The query requires a function to withdraw tokens, ensuring the sender's balance is updated and tokens are transferred correctly. It involves checking conditions like closure and finalization, transferring tokens to the sender, and resetting the balance to zero after withdrawal. The focus is on securely handling token transfers and maintaining accurate balances.",
        "url": 858
    },
    {
        "nl_input": "The query requires a function to prevent users from submitting the same bet again by checking for duplicate bets based on the user's address, match ID, and betting price. The solution should verify if a bet with identical parameters has already been placed and return a boolean value indicating the presence of a duplicate.",
        "url": 859
    },
    {
        "nl_input": "The query requires a function to safely multiply two unsigned integers (x and y) while ensuring no overflow occurs. If an overflow is detected, an exception should be thrown. The function should return the product if the multiplication is safe. This involves checking that dividing the product by one operand returns the other operand.",
        "url": 860
    },
    {
        "nl_input": "The query requires a modifier function that executes a condition check before the actual function runs. Specifically, it ensures that the current time (now) meets a predefined temporal condition (e.g., being after a start or end time). The modifier uses a \"require\" statement for condition validation and includes the \"_\" symbol to indicate where the rest of the code is executed.",
        "url": 861
    },
    {
        "nl_input": "The query requires a function to check if an angel is on a sponsored leaderboard, ensuring each angel is associated with only one leaderboard at a time. The desired function should take an angel ID as input and return a boolean value indicating the angel's presence on a leaderboard.",
        "url": 862
    },
    {
        "nl_input": "The query requires a function to determine the maximum available amount of an order that can be fulfilled, considering the remaining unfilled portion and the available balance or supply. It involves calculations using order details, filled amounts, and balances or supplies, ensuring the returned value respects these constraints.",
        "url": 863
    },
    {
        "nl_input": "The query requires a function to withdraw funds, splitting the specified amount equally among all contract owners using safe mathematical operations. It ensures permissible withdrawal conditions are met, calculates the amount per owner, performs transfers iteratively, and emits an event indicating the withdrawal details for transparency and record-keeping.",
        "url": 864
    },
    {
        "nl_input": "The query requires a function that throws errors on any issue during coin transfer, avoiding returning false flags to prevent user mistakes. It should include standard checks and throw an error if transfers are disabled. The focus is on ensuring secure and reliable transfers by enforcing strict conditions.",
        "url": 865
    },
    {
        "nl_input": "The query requires a function to set a minimum wei amount with a default value of 1000, ensuring the new amount is greater than 0 and divisible by 10. It should also log changes to the minimum wei amount and confirm the update. The function must be callable only by the owner and when not paused.",
        "url": 866
    },
    {
        "nl_input": "The query seeks a function to retrieve the current round's address or details in a contract. It requires identifying the most relevant implementation among the provided options, focusing on functions like 'currentRound' or 'getCurrentRound' that return information about the ongoing round, potentially including its address or associated data.",
        "url": 867
    },
    {
        "nl_input": "The query requires a function to publish an article with a unique hash, associate it with a key hash, and specify the number of tokens. It must include checks for ownership, token limits, time intervals between publications, and uniqueness of the article hash, while updating relevant registers and emitting a publication result.",
        "url": 868
    },
    {
        "nl_input": "The query requires a function that allows the owner to enable token transfers. The desired functionality includes setting a transfer status to true, potentially handling token burning if necessary, and ensuring only the owner can execute this action. The focus is on enabling transfers with owner authorization.",
        "url": 869
    },
    {
        "nl_input": "The query requires a function to successfully remove an admin address, ensuring the address exists, isn't the sender, and isn't the last admin. Upon successful removal, the function should return true. The focus is on verifying the conditions for removal and confirming the operation's success.",
        "url": 870
    },
    {
        "nl_input": "The query requires a function that allows the pendingAdmin address to finalize the admin change process. It needs to verify that the pendingAdmin is the message sender, emit an event, update the admin to the pendingAdmin, and reset the pendingAdmin address. The provided code snippet 'claimAdmin' from contract c10483 fulfills this requirement.",
        "url": 871
    },
    {
        "nl_input": "The query requires a function to validate the destination of a token transfer, ensuring that the transfer is allowed based on specific conditions. It involves checking if the transfer is permitted by evaluating sender, receiver, and potentially other logic contracts or time-based restrictions. The focus is on confirming the validity of the transfer operation before execution.",
        "url": 872
    },
    {
        "nl_input": "The query requires a function to update the status of a minting agent. Specifically, it needs a method that accepts an address and a boolean status, updating whether the given address is authorized as a minting agent. This involves managing permissions for minting agents within a contract, typically restricted to the contract owner.",
        "url": 873
    },
    {
        "nl_input": "The query requires a function to calculate the total tokens available for purchase at the current time, ensuring the sale is active and within specified phases or limits. It involves checking conditions like sale start/end times, token supply limits, and phase-specific caps, returning the number of tokens that can still be purchased.",
        "url": 874
    },
    {
        "nl_input": "The query requires a function that allows an admin to finalize the ownership change after a specified period, ensuring the operation's validity through conditions like matching admin roles and block number constraints. The selected code should transfer ownership across multiple related contracts or components securely and effectively.",
        "url": 875
    },
    {
        "nl_input": "The query requires a function to stake a certain amount of tokens by transferring them from the caller's address. The function must ensure the caller has sufficient balance and authorize the transfer, reducing the caller's token balance accordingly. It involves external interactions and checks to confirm successful execution.",
        "url": 876
    },
    {
        "nl_input": "The query requires a function to execute a bid on an auction. The function should handle bidding logic, including validating the bid amount, updating the highest bidder and bid value, and managing the bidding process within the auction's time constraints. It may also involve transferring funds and recording bid details.",
        "url": 877
    },
    {
        "nl_input": "The query requires a function to approve a specified address (proxy/contract) to spend a certain amount of tokens on behalf of the message sender. This involves setting an allowance for the spender and emitting an Approval event to confirm the action, ensuring proper authorization and spending permissions.",
        "url": 878
    },
    {
        "nl_input": "The query requires a function that allows the owner to update the token rate. Specifically, it needs a mechanism where only the contract owner can modify the rate at which tokens are exchanged or distributed, ensuring control over token economics within the smart contract system.",
        "url": 879
    },
    {
        "nl_input": "The query requires implementing a function to throw an exception when two amounts (expectedValue and actualValue) are not equal. It needs a mechanism to compare these values and trigger an exception if they differ, ensuring accurate value matching in the program's logic. The focus is on error handling for unequal values.",
        "url": 880
    },
    {
        "nl_input": "The query requires creating a new proxy contract that associates an owner and a recovery key. It involves initializing a new Proxy instance, setting the owner with a timestamp, assigning the recovery key, and logging the creation event. The focus is on establishing relationships between identities, owners, and recovery keys within the contract.",
        "url": 881
    },
    {
        "nl_input": "The query requires a function to perform a safe mathematical operation, specifically multiplication, ensuring it handles potential overflow issues by validating the result. The function should return zero in edge cases and verify the operation's correctness before returning the product, thus preventing unsafe computations. This ensures robustness in arithmetic operations within smart contracts.",
        "url": 882
    },
    {
        "nl_input": "The query requires a function to change or set a successor address in a contract, ensuring the new successor is not a zero address. The most relevant code demonstrates this by allowing an admin to update the successor via `setSuccessor(address successor_)`, enforcing that the provided address is valid and non-zero.",
        "url": 883
    },
    {
        "nl_input": "The query seeks to determine profit calculation within a contract. Specifically, it looks for functions that compute profit based on certain inputs, such as discounts, token counts, or user-specific data. The relevant code should return a profit value derived from complex calculations involving market conditions, funding, and outcome tokens, ensuring accurate and detailed profit determination.",
        "url": 884
    },
    {
        "nl_input": "The query requires a function to check if a customer's transaction of payment for MCW has been spent. Specifically, it needs to verify the existence of a non-zero timestamp associated with the transaction in a registry. The result should return a boolean value indicating whether the transaction is marked as spent.",
        "url": 885
    },
    {
        "nl_input": "The query requires a function to set the free memory pointer beyond all accessed memory. This involves using inline assembly to store the memory size at a specific address, ensuring the pointer is updated correctly for further memory operations. The implementation should be private and pure, without external dependencies or state modifications.",
        "url": 886
    },
    {
        "nl_input": "The query requires a function to quickly check if Round1 funding is complete or expired, allowing only one check for Round1. The function should transition to the next round if Round1 caps are exceeded and update the current round status accordingly. It must also ensure that the check is limited to Round1 and executed only once.",
        "url": 887
    },
    {
        "nl_input": "The query requires a function to remove an address from the whitelist. Specifically, it needs a function that takes an address as input and sets its whitelisted status to false, ensuring only the owner can perform this action. The most relevant code demonstrates this functionality by modifying the whitelist mapping directly.",
        "url": 888
    },
    {
        "nl_input": "The query requires a function to process combat-related operations, likely in a game context, ensuring sufficient gas is available due to its expense. It needs logic to handle fees, manage game states, transfer values between players, and update win/loss records while considering gas costs for smooth execution.",
        "url": 889
    },
    {
        "nl_input": "The query requires a function to withdraw the remaining balance and share the pot. The most suitable code should allow the owner to transfer the contract's balance or tokens to a specified address. It must ensure proper access control, such as being callable only by the owner, and handle balance checks if necessary. The implementation should facilitate transferring funds or tokens accurately.",
        "url": 890
    },
    {
        "nl_input": "The query requires a function for air delivery in BioX that uses counts instead of wei_amount. It involves transferring tokens from the owner to another address, converting amounts based on supply and rate, and ensuring balance adjustments with event emission. The focus is on implementing logic where token counts replace direct wei usage.",
        "url": 891
    },
    {
        "nl_input": "The query requires a function that allows qualified crowdsale partners to purchase Star Tokens. The selected code should ensure the partner is qualified, handle token purchase logic, and possibly manage commission fees or caps on the amount that can be raised. It involves interactions like sending tokens, recording purchases, and adhering to specific conditions for eligibility and limits.",
        "url": 892
    },
    {
        "nl_input": "The query requires a modifier that ensures only the contract owner can execute a function. This involves checking if the sender of the message (msg.sender) is equal to the predefined owner address using a require statement, and allowing function execution only when this condition is met. The provided code examples demonstrate this functionality.",
        "url": 893
    },
    {
        "nl_input": "The query requires a function to fetch the size of an ERC223 contract, ensuring it is nonzero to confirm it as a valid contract. The provided code snippets do not directly meet this requirement, as they focus on balance retrieval rather than contract size verification. A suitable implementation should involve checking the contract's bytecode size at a given address to confirm its validity as a deployed contract.",
        "url": 894
    },
    {
        "nl_input": "The query requires a function to calculate compound interest output based on specified input and the number of payouts, applying a tax rate on the final result. The relevant code implements this by iteratively adding interest to the initial input for each payout period and then deducting an exit tax percentage from the total accumulated amount.",
        "url": 895
    },
    {
        "nl_input": "The query requires computing all second winners from the first round winners, comparing their hero powers with random factors, and determining the second-round winners accordingly. The process involves evaluating pairs of first-round winners, applying conditional logic based on hero power and randomness, and assigning the victorious candidates to the second-round winner slots.",
        "url": 896
    },
    {
        "nl_input": "The query requires a function to determine if the current round is in its lock period. Specifically, it needs to calculate the lock period based on the round's length and check whether the current block number falls within this locked phase of the round. The result should return a boolean value indicating if the lock period is active.",
        "url": 897
    },
    {
        "nl_input": "The query requires a function that resets the purchaser's cap when the window duration is met. It involves checking the duration, managing purchase records, and updating the purchaser's amount and block number if the reset condition is satisfied. The focus is on internal record management within a purchase-tracking system.",
        "url": 898
    },
    {
        "nl_input": "The query requires a function to set a global activation fee, ensuring the new fee is greater than zero and different from the current fee. It should be accessible only to authorized users (e.g., owner) and emit an event upon successful update. The function must return a boolean confirming the operation's success.",
        "url": 899
    },
    {
        "nl_input": "The query requires a function to set prices with conditions or restrictions, such as non-zero values or owner-only access. It involves updating price variables (e.g., sellPrice, buyPrice, or ratePerWei) within a smart contract, ensuring flexibility for different pricing strategies while maintaining security and control over price modifications.",
        "url": 900
    },
    {
        "nl_input": "The query requires a function within a smart contract that allows the owner to withdraw any ETH accidentally trapped in the contract. The function should ensure only the owner can initiate the transfer of the contract's balance to their address, providing a secure way to recover funds. Examples include \"sweep,\" \"withdrawEther,\" or \"recoverEthers.\"",
        "url": 901
    },
    {
        "nl_input": "The query requires a function to check if a gift exists and has not been redeemed, returning true only when both conditions are satisfied. It involves verifying the existence of a gift and ensuring it is not already redeemed, typically used in scenarios like gift management systems within smart contracts.",
        "url": 902
    },
    {
        "nl_input": "The query seeks to identify functions within a contract. Based on the provided code snippets, the requirement is to find specific functions such as `deposit`, `thisAddress`, and `symbol` that perform particular actions like handling payments, returning contract addresses, or providing symbol information. The focus is on understanding the functionality of these contract methods in blockchain development.",
        "url": 903
    },
    {
        "nl_input": "The query requires a function to compute an exponential approximation using fixed-point arithmetic with unsafe operations, accepting an input value and precision level. The function involves iterative multiplications and shifts to calculate the result, utilizing predefined constants for each iteration step before returning the final computed value.",
        "url": 904
    },
    {
        "nl_input": "The query requires a function to add a bonus member or manage special addresses in a smart contract. It involves activating a bonus state for a given wallet, managing special manager addresses by enabling them and maintaining their status, or adding bonuses to specific blocks with balance checks. The focus is on address management and bonus allocation within a secure context.",
        "url": 905
    },
    {
        "nl_input": "The query requires creating a new tank type with specified attributes: start price, earnings, base health, attack, armor, and speed. The implementation should involve defining a new entry in a data structure (e.g., array or mapping) that stores these attributes for the newly created tank type, ensuring it is accessible for further use.",
        "url": 906
    },
    {
        "nl_input": "The query requires a function to determine the current state based on the timestamp. It should evaluate the current time against predefined date ranges and active states, returning the corresponding state (e.g., PrivateSale, PreSale, CrowdSalePhase1-3, or Gap). The solution must include conditional checks for time intervals and active status flags.",
        "url": 907
    },
    {
        "nl_input": "The query requires a function to transfer ownership of a contract to a new owner, ensuring the new owner's address is valid and not null. It should restrict this functionality to the current owner only, possibly emitting an event to log the ownership transfer. The function name may vary but should perform ownership transfer securely.",
        "url": 908
    },
    {
        "nl_input": "The query requires a function to initiate a game, ensuring the arbiter is valid and not locked, verifying player count, checking if the game is already active, and allocating resources if necessary. It sets the game as active, initializes player information, and updates game statistics. The function also handles housekeeping tasks based on specified parameters.",
        "url": 909
    },
    {
        "nl_input": "The query requires identifying code that uses `msg.sender` for authorization or permission checks. The focus is on modifiers that ensure the sender of a transaction matches specific criteria, such as being an authorized address, a particular contract, or a designated oracle. This involves using `require` statements to validate `msg.sender` against predefined conditions or mappings.",
        "url": 910
    },
    {
        "nl_input": "The query requires setting addresses for the team's vested token allocation upon finalization. Specifically, it needs a function to define and validate non-zero addresses for team and contributors' vested token allocations, ensuring they are properly assigned before finalization. The function should be callable only by the contract owner for security and control purposes.",
        "url": 911
    },
    {
        "nl_input": "The query requires a function to sell eggs in exchange for Ether (ETH), deducting a fee and transferring the remaining value to the user. It involves calculating egg value, applying a fee, updating user balances, and ensuring proper transfers. The most relevant code implements these functionalities within a smart contract.",
        "url": 912
    },
    {
        "nl_input": "The query requires a function that allows the admin to toggle prebridge states. Specifically, it needs a function within a smart contract that changes the state of a boolean variable 'prebridge' when called by the owner. This functionality is essential for enabling or disabling certain features related to the prebridge state dynamically.",
        "url": 913
    },
    {
        "nl_input": "The query requires a function to retrieve the total amount of Ethereum invested during the Pre-ICO phase. The function should ensure that the Pre-ICO period has ended and transfer the collected Ether to the contract owner while resetting the invested sum. It involves conditions related to time and contract state.",
        "url": 914
    },
    {
        "nl_input": "The query requires a function to process refunds based on proposal numbers, refund amounts, and fees. It needs to check if a refund is available, deduct the refund amount and fees from balances, update execution status, transfer funds to the claimant, and emit relevant events for successful transactions while ensuring conditions are met.",
        "url": 915
    },
    {
        "nl_input": "The query requires implementing minimum and maximum limits for withdrawal amounts in a contract. The description involves defining a function to set the minimum withdrawal limit and ensuring that any withdrawal amount does not exceed the contract's balance, while also handling transfer logic and emitting events for successful withdrawals. Additional conditions may include user status checks and bonus calculations.",
        "url": 916
    },
    {
        "nl_input": "The query requires a function to return the Krown balance of a given address. It needs a method that takes an address as input and outputs the balance associated with that address, similar to the \"balanceOf\" functions in the provided code snippets. The solution should involve mapping addresses to their respective balances and retrieving the balance for the specified address.",
        "url": 917
    },
    {
        "nl_input": "The query requires a function to decode an RLPItem into an address, ensuring the data length is 20 bytes. It uses assembly language to manipulate memory and extract the address by dividing the loaded memory value at a specific position. The requirement focuses on decoding logic with error handling for non-data inputs and incorrect lengths.",
        "url": 918
    },
    {
        "nl_input": "The query requires a function to remove a policy rule associated with a specific signature, contract address, and group name. The function should validate inputs, locate the policy rule, adjust limits, update group indices, and finally delete the rule while emitting a confirmation event. It involves managing policy groups and ensuring data consistency during removal.",
        "url": 919
    },
    {
        "nl_input": "The query requires a function to prevent targets from sending or receiving tokens by setting Unix times. It needs to ensure that the specified targets have their token activities locked until a predefined Unix time, with a mechanism to set or update these lock times using an array of target addresses and corresponding Unix timestamps.",
        "url": 920
    },
    {
        "nl_input": "The query requires a method implementing core game logic that tracks button click events, ensures specific conditions (like fees and game state), records metadata (e.g., block details, timestamps), updates game generation upon certain conditions, and emits an event upon successful clicks while minting a token for the interaction.",
        "url": 921
    },
    {
        "nl_input": "The query requires a function that allows anyone to update the inflation rate yearly. The function should ensure at least one year has passed since the last update and adjust the inflation rate accordingly, affecting variables like poolMintAmount, ownerMintAmount, and stakingMintAmount based on the updated rate. It must be publicly callable with appropriate conditions to prevent frequent updates.",
        "url": 922
    },
    {
        "nl_input": "The query requires a function to calculate the Unix time until the next interest payout, intended for end-user visibility. It should determine the time remaining based on the current interval, start timestamp, and configured interval duration, ensuring no payout occurs after the specified stop interval. The result must be presented as a timestamp difference, returning zero if the stop interval is exceeded.",
        "url": 923
    },
    {
        "nl_input": "The query requires a function to calculate the price for the nth key, considering factors like keys, decimals, and potentially applying discounts or stage-based conditions. The most relevant code implements a formula returning the price by multiplying 'n' with a factor 'a' and adding 'b'. Additional considerations include discount application and stage-specific pricing logic.",
        "url": 924
    },
    {
        "nl_input": "The query requires a function that allows a specified spender to withdraw a certain amount multiple times from the owner's account, up to a predefined limit. The solution should involve approving a spender and ensuring the withdrawal does not exceed the allowed value, with proper balance updates and event logging.",
        "url": 925
    },
    {
        "nl_input": "The query requires a function to handle withdrawal operations, transferring funds to the user. It involves processing specific conditions, such as dates and statuses, calculating amounts (including bonuses), and ensuring proper transfers. The function should log withdrawal activities and manage user-specific data for accurate fund distribution.",
        "url": 926
    },
    {
        "nl_input": "The query requires a function to convert all affiliate rewards of the caller into tokens. Specifically, it needs to handle the caller's reward balance, ensure it is non-zero, and then exchange this balance for tokens, updating balances accordingly and potentially notifying about reinvestment actions.",
        "url": 927
    },
    {
        "nl_input": "The query requires a function to transfer ownership for a Vanity URL, ensuring the new address does not already have a vanity mapping, the current owner has a valid mapping, and the mapping is updated accordingly. It involves transferring the vanity URL association and emitting an event to notify of the transfer.",
        "url": 928
    },
    {
        "nl_input": "The query requires identifying internal functions within the provided code snippets. The description of the query's needs is: \"Extract and analyze internal functions from the given contracts, such as 'finalizeInternal', 'thisAddress', and 'getIndex', which are marked as internal and perform specific operations within their respective smart contracts.\"",
        "url": 929
    },
    {
        "nl_input": "The query requires a function to facilitate an internal transfer for AIRA, ensuring the transferring address has sufficient balance before executing the transaction and emitting a transfer event. The relevant code should manage balances of sender and receiver addresses while confirming the transfer logic is correctly implemented. Only the specific transfer functionality related to AIRA is required.",
        "url": 930
    },
    {
        "nl_input": "The query requires a function to retrieve the balance of a specified address. It should work for both Ether (ETH) and ERC20 token balances. The function needs to identify the type of token, using either the native balance for ETH or the token's balanceOf method for ERC20 tokens, ensuring flexibility in checking balances for different token types.",
        "url": 931
    },
    {
        "nl_input": "The query requires a function or modifier that ensures certain code functionality only executes after a specific sale or contribution period has started. This involves checking against a predefined start time or block number to confirm the initiation of the stage, ensuring temporal or blockchain progression conditions are met before allowing further actions.",
        "url": 932
    },
    {
        "nl_input": "The query requires a function to set multiple pixels in a single transaction. The function should take a canvas ID, an array of pixel indexes, and an array of colors, ensuring both arrays are of equal length. It then iterates through the indexes, setting each pixel's color if not previously set, and ensures at least one pixel is updated per transaction.",
        "url": 933
    },
    {
        "nl_input": "The query requires a mechanism to throw an error if a function is called before the crowdsale start time. The relevant code implements a modifier named `notBeforeSaleStarts`, which ensures that certain functions can only be executed after the crowdsale has started by checking if the current time (`now`) is greater than or equal to the start time (`startTime`).",
        "url": 934
    },
    {
        "nl_input": "The query requires a function to send profits in tokens to a specified address. It needs to ensure the transaction is authorized, the beneficiary address is valid, and the token amount is non-zero. The function should update token balances, total supply, and emit an event confirming the transfer.",
        "url": 935
    },
    {
        "nl_input": "The query requires setting the ID of the last token eligible for a prize. This involves defining a limit for tokens, ensuring the token ID is within bounds, and updating related states (e.g., validation state). The process may reset counters and initialize payout distributions for prize allocation.",
        "url": 936
    },
    {
        "nl_input": "The query seeks conditions for starting a specific stage in a contract, focusing on the logic that determines when a stage can begin. It requires identifying code that evaluates stage-specific criteria, such as matching a stage ID or checking contributions against a cap, and ensures proper sequencing or timing for stage transitions. The relevant code implements conditional checks for stage progression.",
        "url": 937
    },
    {
        "nl_input": "The query requires a function to set an external manager that can call setInterfaceImplementer on behalf of an address. The relevant code should allow setting a new manager for a given address, ensuring the manager can be enabled or changed, and emit an event notifying of the change. This involves managing addresses and their associated managers with proper access control.",
        "url": 938
    },
    {
        "nl_input": "The query requires a function to add a funder's address to a whitelist. The implementation should ensure that only authorized users can add addresses, and it may involve emitting an event to log the addition. The function could accept a single address or an array of addresses, marking them as whitelisted for specific contract interactions.",
        "url": 939
    },
    {
        "nl_input": "The query requires logic to set limits with conditions ensuring the minimum value does not exceed the maximum value. It involves updating variables for minimum and maximum limits, emitting an event upon change, and potentially incorporating validation states or additional constraints to ensure proper limit configuration.",
        "url": 940
    },
    {
        "nl_input": "The query requires creating AVALANCHE ICE Tokens, with all tokens stored in a specific address. This address will also handle community contributions and coin distributions. The provided code involves minting tokens for different purposes (advisors, bounty, community, etc.) and creating tokens with specified parameters, ensuring the required functionality is achievable.",
        "url": 941
    },
    {
        "nl_input": "The query requires a function to determine if the current time is within a pre-sale period, using conditions such as start and end times, and possibly additional constraints like availability or enabling flags. The provided code examples demonstrate implementations involving date ranges, boolean checks, and modifiers to restrict access unless the pre-sale period is active.",
        "url": 942
    },
    {
        "nl_input": "The query requires a function to retrieve an array of block numbers corresponding to all revisions of a specific blob identified by its ID. The function should iterate through all revisions of the blob and collect the block number for each revision into an array, which is then returned as the result.",
        "url": 943
    },
    {
        "nl_input": "The query requires setting up a bounty pool by defining a function to assign an address to the bounty pool variable. It ensures only the creator can set the bounty pool address, facilitating controlled management of the bounty pool within the contract. This setup is crucial for managing rewards or incentives in a contractual system.",
        "url": 944
    },
    {
        "nl_input": "The query requires a function to retrieve player-related information from a contract. Specifically, it needs a method to fetch details such as player ID, name, address, score, and activity status. The provided code snippets demonstrate various getter functions for player data, including info retrieval by player address or board hash. A suitable function should return comprehensive player details as specified.",
        "url": 945
    },
    {
        "nl_input": "The query requires a function that allows an admin to finalize a delegation process after a specified period, ensuring the operation is valid and transferring control to a new delegate contract while maintaining security constraints. The function should verify administrative rights, check block number conditions, and execute the delegation transition accordingly.",
        "url": 946
    },
    {
        "nl_input": "The query requires a function to receive WEDU tokens from another user. The provided code snippets do not directly match this requirement, but the functionality implies needing a transfer or mint function for token transactions. Thus, the query seeks a method enabling token reception, likely involving token addresses and amounts in a blockchain contract.",
        "url": 947
    },
    {
        "nl_input": "The query requires a function to calculate the price for tokens based on the current stage of a sale. It should handle different stages, potentially returning zero if the sale has ended or tokens have been distributed, and calculate the price for a given amount during active sale periods. The function may involve multiplication with the price and consider specific conditions for each stage.",
        "url": 948
    },
    {
        "nl_input": "The query requires a function to retrieve base stats of monsters using their unique ID, allowing shared stats for monsters with the same ID and facilitating evolution by only updating the monster ID. This approach aims to optimize gas costs and reduce transaction complexity in a blockchain environment.",
        "url": 949
    },
    {
        "nl_input": "The query requires implementing a function to release purchased tokens to buyers during the mainsale, adhering to Eidoo's ICOEngineInterface. It involves calculating tokens and bonuses based on the sale conditions, ensuring correct value transfer, handling refunds if necessary, and emitting appropriate events for token purchases and refunds.",
        "url": 950
    },
    {
        "nl_input": "The query requires a function or modifier that ensures only the owner, depositor, or beneficiary can execute a specific operation. The most suitable code includes a modifier named `checkAuthorizedUser`, which reverts if the caller is not one of these authorized accounts, enforcing access control as described in the query.",
        "url": 951
    },
    {
        "nl_input": "The query requires a function to airdrop tokens to multiple accounts. It needs to iterate through arrays of recipient addresses and corresponding token values, transferring specified amounts from a source account to each recipient. The function should ensure the lengths of recipients and values arrays match and may include ownership restrictions for security.",
        "url": 952
    },
    {
        "nl_input": "The query requires a function to check if a specific address has transfer approval for a certain Cutie. It needs to compare the address with the approved one stored for the given Cutie ID, returning a boolean value indicating whether the address is approved for transfer. The relevant code provides this functionality using internal contract logic.",
        "url": 953
    },
    {
        "nl_input": "The query requires a modifier that throws an exception if called by any account other than the specified GDPOracle account. It ensures only the designated GDPOracle can execute certain functions, restricting access and maintaining security within the smart contract environment. The provided code examples demonstrate similar access control mechanisms.",
        "url": 954
    },
    {
        "nl_input": "The query requires a function to retrieve specific redemption data, including redemption ID, reason, and value, associated with a particular address and index. The function should ensure the address is valid and the index exists within the redemption records of that address. It returns detailed information about the specified redemption for further use or verification.",
        "url": 955
    },
    {
        "nl_input": "The query requires a function to transfer animals from one contract to another, involving the management of animal types, their owners, and associated values. It should handle transferring ownership, updating balances or winnings, and interacting with another contract to complete the transaction securely. The primary focus is on animal-related data transfer and ensuring proper value exchanges.",
        "url": 956
    },
    {
        "nl_input": "The query requires a function to mint new tokens, adding them to a specified address and updating the total supply. It involves ensuring the recipient address is valid, incrementing the balance and total supply, and emitting relevant events (e.g., `Transfer` or `Mint`) to log the token creation process.",
        "url": 957
    },
    {
        "nl_input": "The query requires a function allowing the owner to delist by setting a cap to 0. The relevant code should include a function that enables the owner to modify caps, specifically supporting the action of delisting through setting a minimum or maximum cap value to zero while ensuring proper access control.",
        "url": 958
    },
    {
        "nl_input": "The query requires a function to manually start a crowdsale, callable only by the owner. It should allow starting the ICO before the scheduled date and undo a stopped crowdsale in case of human error. The function must ensure proper state transitions and potentially adjust time or block-related parameters.",
        "url": 959
    },
    {
        "nl_input": "The query requires a function to return the deed identifier of an owner at a specific index. It involves iterating through all deeds, checking ownership, and returning the identifier when the specified index is reached, ensuring the index is within the valid range of deeds owned by the given address.",
        "url": 960
    },
    {
        "nl_input": "The query requires a modifier to ensure a function is called only once. The relevant code demonstrates a modifier named `onlyOnce`, which uses a condition to check if the function attempt count is zero (`require(functAttempts <= 0)`), allowing execution solely if the function has not been called before. This ensures the function's single execution constraint.",
        "url": 961
    },
    {
        "nl_input": "The query requires a function to modify the development fee, allowing the owner or authorized entity to set a new fee value with certain restrictions. The most suitable code enables changing the dev fee, ensuring it does not exceed a specified limit and is only modifiable by an authorized sender.",
        "url": 962
    },
    {
        "nl_input": "The query requires overriding the `transferFrom` function to include additional logic before executing the parent contract's `transferFrom`. This may involve checks like dividends, KYC requirements, or ensuring transfers are allowed. The implementation should return a boolean indicating success and adhere to the ERC20 standard.",
        "url": 963
    },
    {
        "nl_input": "The query requires a function to sell a specified amount of tokens to a contract, transferring tokens from the contract's supply to the investor's address while updating available supply. It involves token subtraction, transfer logic, and ensuring proper balance management during the sale process.",
        "url": 964
    },
    {
        "nl_input": "The query requires a function to enable or disable an address as the sender of EUR-T. It needs a method that takes an address and a boolean value, updating the permission status for the specified address. The solution should involve modifying a mapping or similar structure to store the allowed status for each address.",
        "url": 965
    },
    {
        "nl_input": "The query requires a function to handle refunds, ensuring that only eligible users can receive their invested amount back. The refund process should reset the user's balance and transfer the funds, possibly including event logging or state checks to confirm the refund's availability.",
        "url": 966
    },
    {
        "nl_input": "The query requires a function to facilitate the purchase of shares by users. The implementation should include a mechanism for calculating the number of shares based on the provided value and the current buy price, ensuring the transaction is valid, and transferring the corresponding amount of shares to the buyer's address. Security and correctness of the operation are essential.",
        "url": 967
    },
    {
        "nl_input": "The query requires a function to send an Oraclize query using a specified API, ensuring sufficient balance to cover the query fee. It involves checking conditions based on time and previous queries, updating query status, and handling two different APIs based on whether the query has been called before. The function emits events indicating query success or failure.",
        "url": 968
    },
    {
        "nl_input": "The query requires a function to confirm autosell by checking if the token amount is sufficient for selling. It needs a boolean return indicating success or failure based on available tokens compared to the requested amount. The relevant code should involve token quantity validation and return true if the sale can proceed, ensuring proper autosell functionality.",
        "url": 969
    },
    {
        "nl_input": "The query requires an internal method to create a new Zodiac entity, storing its details such as matron ID, sire ID, generation, genes, and type. It ensures data constraints, calculates cooldown index, and emits a birth event upon successful creation, transferring ownership of the new Zodiac.",
        "url": 970
    },
    {
        "nl_input": "The query requires identifying code that automatically executes a function upon deployment. The focus should be on functions or modifiers ensuring specific conditions are met during the deployment stage, such as setting up whitelists or transitioning contract stages. This ensures the contract initializes correctly when deployed.",
        "url": 971
    },
    {
        "nl_input": "The query requires identifying the index of a newly created snapshot in a blockchain contract. It involves creating or updating snapshots with specific attributes, such as tokens count and addresses, ensuring the snapshot is stored correctly in the array or list. The focus is on returning or utilizing the index of the newly generated snapshot for further operations.",
        "url": 972
    },
    {
        "nl_input": "The query requires a function to retrieve the level of a hero associated with a specific token ID. It needs to access a mapping or storage where hero instances and their levels are recorded, returning the current level of the hero as a uint value when provided with a valid token ID.",
        "url": 973
    },
    {
        "nl_input": "The query requires a function to return the total number of tokens in existence. This involves identifying a contract function that calculates or stores the total token supply. The focus is on retrieving the exact count of tokens created or available within the contract's logic.",
        "url": 974
    },
    {
        "nl_input": "The query requires a function to withdraw all released vesting coins and update the balance accordingly. It involves calculating the released amount for each vesting, subtracting the already withdrawn amount, updating the withdrawal status, and finally adding the total withdrawable amount to the user's balance. The implementation should handle multiple vestings per user and ensure accurate accounting.",
        "url": 975
    },
    {
        "nl_input": "The query requires a function to create tokens based on fees pledged by an owner. It involves validating the controller, updating window blocks, converting pledged amounts to tokens, generating tokens for the owner, and emitting contribution logs. The process ensures proper accounting and token issuance within a blockchain contract system.",
        "url": 976
    },
    {
        "nl_input": "The query requires a function allowing marketing contributors to withdraw their rewarded tokens. Specifically, it needs to verify the contributor's eligible reward tokens, update their balance after withdrawal, and transfer the tokens accordingly, ensuring only authorized parties can initiate the withdrawal process.",
        "url": 977
    },
    {
        "nl_input": "The query requires a function to release vested tokens back to the Hut34 wallet. It needs logic that checks if the current time allows for token release, calculates the vested tokens, updates the release date, and transfers the appropriate amount of tokens to the Hut34 wallet address while emitting an event for tracking.",
        "url": 978
    },
    {
        "nl_input": "The query requires a function to set the symbol of a contract. The most suitable code is a function that specifically sets the symbol using a bytes32 parameter and ensures only the owner can execute it. Other codes either return the symbol or set both name and symbol together, which do not precisely match the requirement.",
        "url": 979
    },
    {
        "nl_input": "The query requires a function that allows token transfers once trading has started. It needs to ensure trading is active, verify the transfer amount, and confirm sender authorization before executing the transfer, returning a boolean for success. The focus is on enabling token movement while adhering to trading status and user permissions.",
        "url": 980
    },
    {
        "nl_input": "The query requires implementing a function or modifier that reverts the transaction if the sender is not the designated whiteListAgent. This ensures only the authorized whiteListAgent can execute specific actions, using modifiers or conditional checks to enforce access control based on the sender's address.",
        "url": 981
    },
    {
        "nl_input": "The query requires a function to adjust an inflation rate that starts at 100, decreases by 30 annually until reaching 10, then decreases by 0.5. The code should handle rate changes and possibly calculate mint amounts based on the updated rate for different entities like pool, owner, and staking. Only relevant details matching this requirement should be extracted.",
        "url": 982
    },
    {
        "nl_input": "The query requires a function to transfer tokens to a user address, ensuring the balance is updated correctly and sufficient permissions or conditions are met. It involves token transfers between addresses, checks for valid amounts, and may include ownership or time constraints for security and proper execution of the transfer process.",
        "url": 983
    },
    {
        "nl_input": "The query requires a function to remove an auction from public view and return the token to the seller. It needs to reset auction-related mappings, transfer tokens back to the seller, and potentially emit an event indicating the cancellation of the auction. The solution should handle both the removal of auction data and the restoration of assets to the original owner.",
        "url": 984
    },
    {
        "nl_input": "The query requires a function to approve the minting of a specified amount of tokens (_amount) and assign them to a specific owner (_owner). The function should ensure that the minting does not exceed the total supply cap, update the owner's token balance, and lock the tokens for a certain duration. It must also emit an event confirming the approval of minted tokens.",
        "url": 985
    },
    {
        "nl_input": "The query requires a function to retrieve the total jackpot value. If the jackpot is completed, it should return the final jackpot value; otherwise, it returns the contract's balance. The focus is on implementing logic that checks the completion status of the jackpot and returning the appropriate value based on this condition.",
        "url": 986
    },
    {
        "nl_input": "The query requires a function to calculate the amount of ETH a user can receive when selling a specific amount of BOB tokens. It involves determining the maximum purchasable tokens based on the contract's balance, adjusting for the sell order, transferring tokens from the user, and sending ETH to the user. The focus is on token-to-ETH conversion with balance constraints.",
        "url": 987
    },
    {
        "nl_input": "The query requires a modifier to control access for adding deposits, ensuring only authorized users (owner or those granted deposit access) can execute deposit-related functions. The relevant code defines an \"onlyAccessDeposit\" modifier that checks if the sender is the owner or has been granted deposit access before allowing the function to proceed.",
        "url": 988
    },
    {
        "nl_input": "The query requires a function to determine if an address can bypass the global freeze. It needs logic that checks permissions or conditions allowing specific addresses to remain unaffected by a freeze, potentially involving mappings or boolean flags associated with accounts. The focus is on identifying whether an account has special permission to bypass freezing mechanisms.",
        "url": 989
    },
    {
        "nl_input": "The query requires a callback function for handling Oraclize random number results. It needs to verify the proof, extract a random number from the result, and use it for further operations, such as determining winners in a betting scenario or generating random values for specific tasks. The function must ensure proper error handling and state management.",
        "url": 990
    },
    {
        "nl_input": "The query requires a function allowing the owner to update the rate of TCR to ETH. The provided code examples demonstrate functions named `setRate` or `setPriceRate` that enable the owner to modify conversion rates. The requirement is to implement or identify such a function for adjusting the TCR to ETH rate dynamically.",
        "url": 991
    },
    {
        "nl_input": "The query requires a function to check if an account is frozen. It needs a boolean return indicating the freeze status of a specific account. The function should take an account address as input and verify its frozen status using a mapping or similar data structure that stores frozen account information.",
        "url": 992
    },
    {
        "nl_input": "The query requires a function allowing the owner to send any transaction, similar to a multi-signature mechanism. This is essential for transferring DAC/campaign tokens or handling pledges. The provided code examples involve owner-only functions for sending funds, resolving contributions, and transferring tokens with specific conditions, highlighting the need for secure and controlled transactions within a campaign context.",
        "url": 993
    },
    {
        "nl_input": "The query requires a function to disable or nullify the contract, preventing further usage. It should ideally set a boolean flag to true, indicating the contract is nullified, ensuring only the owner can execute this action. This functionality aims to stop contract operations without destroying it or altering other states like whitelists.",
        "url": 994
    },
    {
        "nl_input": "The query requires a function to remove a minor owner, which can only be executed by the major/actual owner. The function should verify the minor owner's existence, ensure the major owner's share is within limits, and adjust ownership distribution accordingly. It involves managing owner addresses and shares while maintaining security and validity checks.",
        "url": 995
    },
    {
        "nl_input": "The query requires a function to retrieve the value of a specified node, represented by a bytes32 identifier. The relevant code should define a function that accepts a node ID as input and returns the corresponding node value, utilizing a library or mapping to fetch the value based on the provided node ID.",
        "url": 996
    },
    {
        "nl_input": "The query requires identifying who can transfer tokens. Based on the provided code, only the owner or authorized distributors can transfer tokens, as confirmed by the modifier 'canTransfer' which checks if the sender is either the owner or listed as a distributor. This ensures restricted access for token transfers.",
        "url": 997
    },
    {
        "nl_input": "The query requires a function to set a charity address, allowing the contract owner to update the address. The most relevant code provides a function named \"setCharity\" which accepts an address parameter and updates the charityAddress variable, ensuring only the contract owner can invoke this change.",
        "url": 998
    },
    {
        "nl_input": "The query requires a function to set the server-side address. The desired function should allow modification of an address, likely through an authorized mechanism (e.g., onlyOwner). It must include functionality for updating a specific address variable and possibly emit an event indicating the change for external notification.",
        "url": 999
    }
]