[
    {
        "nl_input": "The query requires a function to replace the current owner with a new owner in a smart contract. The function should ensure only the current owner can execute it, update the owner's address, and emit an event to log the change. The new owner must not already be an owner, and the old owner should be removed from the owners' list. The function should handle these checks and updates securely.",
        "url": 0
    },
    {
        "nl_input": "The query requires a function that computes the real cap based on a given cap key. The function should take two parameters: the cap and the key, and return the computed real cap, likely as a hash or derived value. The first code snippet is the most relevant as it directly implements this logic using `keccak256` to hash the cap and key together. The other snippets are unrelated to the cap key computation.",
        "url": 1
    },
    {
        "nl_input": "The query requires a constructor function that matches the contract name and returns a specific string or symbol. The function should be public and viewable, returning a string value such as a name or symbol defined in the contract. The function must adhere to the contract's naming convention and visibility requirements.",
        "url": 2
    },
    {
        "nl_input": "The query requires defining the amount of Kitten Coins a holder must possess to qualify for rewards. The relevant code involves setting a holder amount (via `holderAmount`) and calculating rewards based on token balances and daily limits, with bonus tiers depending on remaining token thresholds. The description focuses on reward eligibility and calculation mechanisms. (80 words)",
        "url": 3
    },
    {
        "nl_input": "The query requires a function that retrieves the balance of a specific account (address) from a smart contract. The function should accept an address parameter and return the corresponding balance stored in a mapping or storage variable named `balances`. The function should be view/constant to indicate it doesn't modify state. The return type should be `uint` (unsigned integer) representing the account's balance.",
        "url": 4
    },
    {
        "nl_input": "The query requires a function to burn BNTT tokens from users, ensuring the burner is the owner, the amount is valid, and the balances and total supply are updated accordingly. The function should emit an event to record the burn and return a success status if applicable.",
        "url": 5
    },
    {
        "nl_input": "The query requires a method to update the state of tranches and the current round in a multi-round system, ensuring transitions between rounds based on predefined conditions or caps. It should handle round progression, update timestamps, adjust token caps, and emit events when switching rounds. The solution must manage round-specific logic, such as token allocation and time boundaries, while maintaining the integrity of the tranche state.",
        "url": 6
    },
    {
        "nl_input": "The query seeks code related to terminating or nullifying a contract under specific conditions, such as time-based release, ownership restrictions, or pausing mechanisms. The desired functionality includes modifiers for release dates, owner-only access, or pausing states before executing termination or nullification actions.",
        "url": 7
    },
    {
        "nl_input": "The query requires a function that logs a data request with a specific ID, including details such as initialization status, data URL, and the number of data points. The function should emit an event or log the request information for tracking purposes. The implementation should focus on retrieving and logging the request data based on the provided ID.",
        "url": 8
    },
    {
        "nl_input": "The query requires a smart contract function that allows a controller to step down or relinquish control, typically by toggling a state variable or transferring ownership. The function should be restricted to the owner or controller and may emit an event to log the action. The desired functionality is similar to a pause or lock mechanism, where the controller can disable or enable certain features or roles.",
        "url": 9
    },
    {
        "nl_input": "The query requires a function that enables token withdrawals from a contract, ensuring the transfer of tokens to the designated recipient while possibly checking conditions like contract closure or ownership. The function should handle the withdrawal process securely, updating balances or states as needed. Suitable code should include token transfer logic, access control (e.g., `onlyOwner`), and checks for withdrawal eligibility (e.g., `require` statements).",
        "url": 10
    },
    {
        "nl_input": "The query requires a public interface to access game directory information, including functions to retrieve the total number of games, details of specific games (such as contract address, description, URL, submitter, and timestamp), and a method to check if a game is active. The interface should support view/constant functions for read-only operations and internal functions for validation checks.",
        "url": 11
    },
    {
        "nl_input": "The query requires a smart contract function that allows any user to withdraw their assigned prize. The function should check the user's eligibility, calculate the prize amount from their tokens, reset the token payout values, and transfer the prize to the user. The prize should be greater than zero and calculated based on the prize pool. The function must ensure the prize distribution state is in the 'Finished' phase before execution.",
        "url": 12
    },
    {
        "nl_input": "The query requires adding a new casino with specific attributes such as star rating, price, name, and description. The code should include an internal function to create a new casino entry, assign it a unique ID, store the details in a data structure, and maintain a list of all casino IDs. The function should ensure the new casino is properly registered and accessible within the system.",
        "url": 13
    },
    {
        "nl_input": "The query requires a smart contract function that enables the transfer of tokens from one account to another, handling balance updates, allowance checks, and emitting a transfer event. The function should manage token movements between specified addresses, ensuring proper authorization and balance adjustments.",
        "url": 14
    },
    {
        "nl_input": "The query requires a function or modifier to toggle or check the locked status of a contract. The desired functionality includes toggling the locked flag (changing its state between true and false), emitting an event when the state changes, and ensuring the operation is restricted to the contract owner. Additionally, a modifier to check if the contract is not locked before executing certain functions may be needed.",
        "url": 15
    },
    {
        "nl_input": "The query requires a function that allows a pendingOwner to finalize a transfer, ensuring the call is made within a specified start and end time. The function should include checks for ownership and time constraints before executing the transfer and updating the state. The code should also emit an event upon successful finalization. The focus is on secure, time-bound ownership transfer with proper validation and state management.",
        "url": 16
    },
    {
        "nl_input": "The query requires identifying code snippets that override the `transfer` function in a smart contract, ensuring it includes checks or modifications before executing the standard transfer. The relevant code must involve conditions like transfer permissions (`isTransferAllowed`) or state checks (`activated`), and should call `super.transfer` to complete the operation. The focus is on custom transfer logic that extends or restricts the default behavior.",
        "url": 17
    },
    {
        "nl_input": "The query requires a function to allocate tokens to users, specifying parameters like receiver address, customer UUID, and amount. The function should be callable under certain conditions (e.g., when not paused or by owners) and may include internal allocation logic or batch processing for multiple recipients. Token allocation should update balances, total supply, and optionally lock types or emit transfer events.",
        "url": 18
    },
    {
        "nl_input": "The query requires a Solidity function that checks the allowance of a spender from an owner's address, returning a uint256 value. The function should be named `allowance`, take two address parameters (owner and spender), and be either `view` or `pure` with a return type of `uint256`. The implementation can return a fixed value (like 0) or fetch from a mapping, but must adhere to the standard ERC20 allowance interface.",
        "url": 19
    },
    {
        "nl_input": "The query requires information on how to delegate execution to an implementation contract in Solidity. This involves using `delegatecall` to forward calls to another contract, handling the return data, and ensuring proper delegation setup through functions like `_delegate`, `setDelegate`, or `finalizeDelegation`. The delegation process typically includes checks for admin/owner permissions and updates the delegate address.",
        "url": 20
    },
    {
        "nl_input": "The query requires a description of smart contract functions that handle cancellation operations. The relevant functions include checking if a project is canceled, canceling an auction and transferring assets, and canceling a withdrawal request by resetting the withdrawal time. Each function performs a specific cancellation-related action within its contract context.",
        "url": 21
    },
    {
        "nl_input": "The query requires a function to check if the length of a string falls within specified minimum and maximum bounds. The function should return a boolean indicating whether the string length meets the criteria. The solution should involve converting the string to bytes to accurately measure its length and then comparing it against the provided min and max values. The function must be pure, meaning it does not modify the contract state.",
        "url": 22
    },
    {
        "nl_input": "The query requires setting a cooldown period for childbirth in a smart contract, including updating the cooldown end block or time, incrementing the cooldown index if applicable, and ensuring the entity is ready to breed by checking the current block number or timestamp against the cooldown end. The solution should manage cooldown states and emit events if necessary.",
        "url": 23
    },
    {
        "nl_input": "The query requires identifying code that sets a specific address (contract or otherwise) with permission to call a 'vacate' function on the contract. The suitable code should include a function that assigns an address with such privileges, typically involving access control checks (e.g., owner or admin validation) and address validation. The function may emit an event upon successful assignment. The focus is on address assignment with restricted permissions. (80 words)",
        "url": 24
    },
    {
        "nl_input": "The query requires a function to buy tokens using Ether, with checks for minimum Ether amount, token rate calculation, and transfer of tokens to the buyer and Ether to a wallet. The function should also ensure the sale is active and not paused, and track issued tokens against a hard cap. The description should include these key functionalities in a concise manner.",
        "url": 25
    },
    {
        "nl_input": "The query requires a function that returns the number of token base units per grain, specifically a method named `tokenUnits()` which retrieves an array of token units for each token in a collection. The function should be external and view-only, returning a `uint256[]` array where each element represents the token units for a corresponding token. The implementation should iterate through the tokens and populate the array with their respective unit values.",
        "url": 26
    },
    {
        "nl_input": "The query requires a function that changes a multi-signature address, ensuring the new address is not zero, with the modification restricted to authorized entities (e.g., `onlyMultiSig` or `onlyOwner`). The function should update the address and may include an event or validation check. The target is to find code snippets that implement such address-changing functionality with proper access control and safety checks.",
        "url": 27
    },
    {
        "nl_input": "The burnToken function has ended if the current time exceeds the endTime or all tokens are distributed (tokensLeft <= 0), verified by the hasEnded() check in the burnToken function.",
        "url": 28
    },
    {
        "nl_input": "The query requires a function that allows TGE participants to request a refund when the token generation minimum is not met. The function should check conditions like contribution amount, sale completion status, token generation threshold, and block number, then process the refund by resetting balances, updating totals, and transferring the refunded amount. The refund should only be possible if the specified conditions are satisfied.",
        "url": 29
    },
    {
        "nl_input": "The query requires a Solidity modifier that ensures a function can only be called once, typically via a script executed by the contract itself. The modifier should include a `require` statement to check if the function has not been called before (e.g., by tracking attempts or a boolean flag) and revert if the condition is not met. The goal is to enforce single-use functionality within the contract.",
        "url": 30
    },
    {
        "nl_input": "The query requires code that retrieves the balance of tokens in a wallet, supporting both native ETH and ERC20 tokens. The solution should include a function that checks the token type and returns the balance, either from the contract's native balance or via the ERC20 `balanceOf` method. The function should be view-only and handle token addresses appropriately.",
        "url": 31
    },
    {
        "nl_input": "The query requires calculating the number of wei needed to buy 0.01 Mozo token by extracting the token conversion rate logic from the provided code snippets. The solution should involve a function that takes a wei amount as input and returns the corresponding token amount based on predefined rate tiers or dynamic rate calculations. The focus is on the conversion mechanism between wei and tokens, considering different rate structures. (80 words)",
        "url": 32
    },
    {
        "nl_input": "The query requires a function that allows the contract owner to rescue or recover Ether from the contract, transferring it to a specified address or the owner's address. The function should be restricted to the owner only and can either transfer the entire contract balance or a specified amount. The solution should ensure secure Ether transfer using `transfer` or `send` methods.",
        "url": 33
    },
    {
        "nl_input": "The query requires a function that allows changing the contract owner, typically restricted to the current owner, and emits an event to log the change. The function should accept a new owner's address as a parameter and update the owner variable. Optionally, it may return a boolean to confirm the operation. The function should include the `onlyOwner` modifier to ensure only the current owner can execute it.",
        "url": 34
    },
    {
        "nl_input": "The query requires a function that calculates both the token amount and its equivalent value in USD based on a given input value. The function should handle cases where the input value is zero by returning zero for both outputs. The calculation should involve converting the input value to USD and then determining the corresponding token amount, possibly considering additional factors like bonuses or rates. The result should be returned as a tuple (tokenAmount, usdAmount).",
        "url": 35
    },
    {
        "nl_input": "The query requires methods for managing user authorization in smart contracts, including adding authorized addresses, checking if a caller is authorized, and setting authorization with specific conditions like balance requirements. The methods should involve modifiers or functions that restrict access based on predefined roles or ownership.",
        "url": 36
    },
    {
        "nl_input": "The query requires a smart contract that allows a customer to purchase a box, including checks for contract status, payment validation, and potential bonus or refund mechanisms. The contract should handle the transaction, verify conditions (like sale status and sender type), and manage token or item distribution based on the purchase, possibly with star ratings or bonuses. Excess funds should be refunded if applicable.",
        "url": 37
    },
    {
        "nl_input": "The query requires a function that retrieves the sale prices of a property in both ETH and PXL currencies. The function should accept a property ID as input and return two values: the sale price in ETH and the sale price in PXL. The function should also validate the property ID and handle cases where the property might not be owned (returning system sale prices) or is owned (returning the owner's sale price in PXL).",
        "url": 38
    },
    {
        "nl_input": "The query requires a function that calculates and returns the remaining free trial drops for a given token address. The function should check if the token has a trial period and subtract the used trial drops from the maximum allowed, returning the difference or zero if no trial exists. The expected output is a uint256 value representing the remaining trial drops.",
        "url": 39
    },
    {
        "nl_input": "The query requires a smart contract function that transfers ownership to a new address and subsequently destroys the contract. The function should include ownership validation (e.g., `onlyOwner` modifier) and ensure the new address is valid (non-zero). The contract self-destructs after the transfer, as seen in the third code example (`selfdestruct(msg.sender)`). The first two examples only handle ownership transfer without contract destruction.",
        "url": 40
    },
    {
        "nl_input": "The query requires a function to transfer tokens from the sender's address to a specified recipient, ensuring sender authorization (e.g., explicit checks like `msg.sender == tokenBearer` or balance/deposit validations), updating balances, and handling token deductions/additions. It should include safeguards (e.g., `require`, `assert`) and may emit transfer events.",
        "url": 41
    },
    {
        "nl_input": "The query requires a function that allows the contract owner to update the token exchange rate, typically set in Ether or Wei. The function should be restricted to the owner and accept a new rate parameter. The default rate is mentioned as 0.005 Ether. The solution should ensure only authorized roles (like owner or manager) can modify the rate, with optional validation checks for the new rate value.",
        "url": 42
    },
    {
        "nl_input": "The query requires a function that allows a provider to return a subscription deposit to a customer immediately when the subscription is canceled. The function should verify the subscription is canceled, check the deposit amount is positive, and ensure the caller is either the provider or contract owner before processing the refund. The deposit should be returned and the subscription marked as expired. (79 words)",
        "url": 43
    },
    {
        "nl_input": "The query requires a function that allows the contract owner to set a time-based parameter (e.g., expiry window, lockout period) measured in seconds or timestamps, restricted by ownership modifiers like `onlyOwner`, to configure approval expiration before contract locking.",
        "url": 44
    },
    {
        "nl_input": "The query requires retrieving the BOP token balance for a specified address. The suitable code should include a function named `balanceOf` that takes an address parameter and returns the token balance associated with that address. The function should be publicly callable and view-only, without modifying the contract state. The balance should be returned as an unsigned integer (uint).",
        "url": 45
    },
    {
        "nl_input": "The query requires identifying functions that can be defined as `pure` instead of `constant` because they neither read the blockchain state nor write to it. The focus is on functions that perform computations without interacting with blockchain data, such as mathematical operations or internal logic that doesn't rely on or modify the blockchain's state.",
        "url": 46
    },
    {
        "nl_input": "The query requires a function that reallocates unsold or leftover bounty tokens, typically transferring them to specified addresses (like founders, support, or bounty wallets) after a sale or event concludes. The function should ensure these tokens are only redistributed once and by authorized parties. The focus is on managing residual tokens post-distribution, not on initial allocation or sale processes.",
        "url": 47
    },
    {
        "nl_input": "The query requires a smart contract function that handles withdrawal requests, including scenarios where a user might change their mind about withdrawing. The function should check withdrawal conditions, update user status, calculate and transfer the correct amount, and log the transaction. It should also handle cases where the withdrawal is canceled or adjusted, ensuring proper state updates and event logging.",
        "url": 48
    },
    {
        "nl_input": "The query requires a function to mint or assign tokens to a specified address, ensuring the address is valid (not zero) and potentially emitting a transfer event. The function should handle token creation and assignment internally or through a call to another contract's mint function, with possible owner restrictions. The operation should include checks for valid addresses and may involve updating token balances or states.",
        "url": 49
    },
    {
        "nl_input": "The query requires an internal function to determine the current bonus during an ICO, checking the ICO state and time to apply specific bonus calculations. The function should return the bonus value, adjusting it based on predefined stages and time conditions, with zero bonus after the final stage. It should only be active during the ICO period.",
        "url": 50
    },
    {
        "nl_input": "The query requires executing a token allocation function across all token bankrolls, specifically calling a function named `tokenAllocate` or similar to distribute tokens according to predefined percentages or amounts. The function should be publicly accessible and may involve multiple allocation steps or checks for address validity and token availability. The code should handle the distribution process without requiring prior token assignment or enabling repeated claims. (80 words)",
        "url": 51
    },
    {
        "nl_input": "The query requires a function to transfer tokens from an owner's account to another address, ensuring the owner has sufficient balance, allowing zero-value transfers, and including a developer override. The function should validate the sender's authority and balance, handle the transfer, and update the balance accordingly. Zero-value transfers should be permitted, and there should be flexibility for developer overrides in the transfer logic.",
        "url": 52
    },
    {
        "nl_input": "The query requires a function that sends tokens to a user address, ensuring the sender is authorized (e.g., token bearer or wallet owner) and validating the recipient address and token amount. The function should include checks for sender permissions, valid recipient, and sufficient balance, then execute the transfer and update the balance if necessary. The focus is on secure token transfer with proper access control and validation. (80 words)",
        "url": 53
    },
    {
        "nl_input": "The query requires extracting a 256-bit (32-byte) segment from a bytes stream. The suitable code should take a bytes input and an offset, then return a 32-byte chunk (bytes32) by iterating through the stream and combining the bytes correctly. The operation should handle bitwise operations to ensure proper alignment and masking of the extracted data. The result must be a clean 256-bit value from the specified position in the stream.",
        "url": 54
    },
    {
        "nl_input": "The query requires a function that retrieves all relevant information about a specific element, including its token ID, name, selling price, owner, and scientist ID. The function should be public and return these details in a structured format. The first code snippet (`c20814`) matches this requirement exactly by providing a `getElement` function that returns all specified fields for a given token ID.",
        "url": 55
    },
    {
        "nl_input": "The query requires identifying code snippets that handle operational checks or revert conditions in smart contracts, specifically focusing on functions or modifiers that ensure contract operations are valid or revert under certain conditions, such as invalid states, operational status, or finalization checks. The description should highlight conditions triggering reverts or operational requirements. (80 words)",
        "url": 56
    },
    {
        "nl_input": "The query requires calculating the total payout amount after deducting commission and donation amounts from a total bet amount. The commission and donation are calculated as percentages of the total bet, then subtracted to determine the final payout. The solution should also handle transferring the commission to the owner and the donation to a charity address, with events logged for both transactions. The focus is on financial distribution with fixed percentage-based deductions. (80 words)",
        "url": 57
    },
    {
        "nl_input": "The query requires code that demonstrates how to delete a transaction or related data in a smart contract. The code should include functionality to remove transaction entries from storage, update relevant indices, and handle associated policy data if applicable. The operation should ensure proper checks (like transaction existence) and emit events if needed. The focus is on secure and efficient deletion of transaction records within a blockchain context.",
        "url": 58
    },
    {
        "nl_input": "The query requires a function that allows only contract owners to add a new dungeon floor by specifying its ID, along with new rewards and floor genes, while ensuring the dungeon's state is updated with the current time and incremented floor number. The function must include access control to restrict execution to the owner and verify the dungeon's existence.",
        "url": 59
    },
    {
        "nl_input": "The query requires calculating the number of tokens to be transferred to an investor based on the amount of ether invested, using a conversion rate or formula specified in the smart contract. The code should include a method to compute the token amount by multiplying the invested ether with a rate or performing a division operation, and then transferring the calculated tokens to the investor's address. (78 words)",
        "url": 60
    },
    {
        "nl_input": "The query requires a description of how an owner can distribute tokens through a crowdsale contract, including checks for token whitelisting, distribution status, minimum balance requirements, and tracking distribution details. The code should allow only the owner to initiate token distribution, update distribution records, and emit relevant events. The description should focus on the owner's ability to manage token distribution securely and transparently. (80 words)",
        "url": 61
    },
    {
        "nl_input": "The query requires a code snippet that demonstrates how to create a request and assign it the next available ID. The code should include functionality to increment the ID counter, store the request details (such as type, target address, value, and message), and emit an event upon creation. The focus is on the request creation process with automatic ID assignment.",
        "url": 62
    },
    {
        "nl_input": "The query requires a function that assigns an allowance value (`_value`) to a specified spender address (`_spender`) on behalf of the message sender (`msg.sender`). The function should update the allowance mapping and return a boolean indicating success. The best match is code 905, which directly implements this functionality by setting `allowance[msg.sender][_spender] = _value` and returning `true`. (80 words)",
        "url": 63
    },
    {
        "nl_input": "The query requires code that handles the deposit of funds, including functions to receive and track deposited amounts, possibly with token transfers or balance updates. The code should allow for payable functions, token address specifications, and balance management, ensuring secure and verifiable transactions.",
        "url": 64
    },
    {
        "nl_input": "The query requires a smart contract function to withdraw deposited funds, specifying conditions like amount, destination address, and owner-only access. The function should transfer the specified amount or the entire balance to the owner or a specified address, with checks for valid addresses and sufficient balance. Events or modifiers like `onlyOwner` and `icoEnded` may be included for access control and state validation.",
        "url": 65
    },
    {
        "nl_input": "The query requires a modifier or function that restricts access to only specified payers, ensuring that only addresses listed as payers can execute certain actions. The code should include a `require` statement to check if the sender is a payer before proceeding with the function or modifier's logic. The focus is on payer-specific access control.",
        "url": 66
    },
    {
        "nl_input": "The query requires a function that allows the contract owner to transfer tokens between addresses, with checks for valid amounts, non-zero addresses, and specific conditions like time constraints or blacklist status. The function should ensure only the owner can execute it and handle token transfers securely.",
        "url": 67
    },
    {
        "nl_input": "The query requires a smart contract function that allows a sender to make a payment on behalf of another party (benefactor). The function should handle the payment transfer, validate the transaction (e.g., non-zero value and valid benefactor address), and update relevant records or emit events. The payment should be forwarded to a specified recipient (e.g., a multisig wallet) and track the transaction details.",
        "url": 68
    },
    {
        "nl_input": "The seems the query is looking for code snippets related to adding or managing \"burning man\" or burner addresses in smart contracts. The requirements include functions to add a burning man address with checks for existence, modifiers to verify burner permissions, and methods to whitelist burn addresses restricted to contract owners. The focus is on authorization and management of burner-related functionalities in Ethereum smart contracts. (79 words)",
        "url": 69
    },
    {
        "nl_input": "The query requires a function to add one or more addresses to a whitelist, typically with admin or owner permissions. The function should validate the input addresses (e.g., non-zero checks) and update the whitelist storage. Optionally, it may emit an event or handle batch additions. The solution should ensure only authorized roles can execute the operation.",
        "url": 70
    },
    {
        "nl_input": "The query requires a function to freeze one or multiple accounts at specified addresses, with the ability to toggle the freeze status (freeze/unfreeze). The function should be restricted to the contract owner and emit an event when executed. The target can be a single address or an array of addresses, with validation to ensure the address(es) are valid (non-zero). The frozen status should be stored in a mapping for future reference.",
        "url": 71
    },
    {
        "nl_input": "The query requires setting an address with the authority to approve users through KYC (Know Your Customer) verification. The suitable code should allow an authorized entity (like an owner or KYC manager) to designate or modify the address responsible for KYC approvals. The focus is on functions that enable setting or changing the KYC provider or manager, not on general approval functions or KYC status updates. (80 words)",
        "url": 72
    },
    {
        "nl_input": "The query requires a function that returns the price of a registered asset in the format `(bool areRecent, uint prices, uint decimals)`. The function should check if the price is recent and return the price along with its decimals. The first code snippet matches this requirement as it includes all three parameters and checks for recent prices, while the other snippets only return a single price value without the required format.",
        "url": 73
    },
    {
        "nl_input": "The query requires a function to remove or cancel an auction by deleting or clearing the auction data associated with a specific identifier (e.g., `_deedId` or `_partId`). The function should handle the removal internally and may include additional steps like transferring ownership or emitting an event. The solution should ensure the auction is no longer active or accessible after removal.",
        "url": 74
    },
    {
        "nl_input": "The query requires retrieving dividend-related information for an owner, including functions to get dividends (with or without bonuses) and to withdraw dividends. The relevant code should handle dividend calculations, checks for dividend shares, and transferring the dividend amount to the owner. The description should focus on dividend retrieval and withdrawal mechanisms. (80 words)",
        "url": 75
    },
    {
        "nl_input": "The query requires creating a new product contract that includes functionality for product ownership management, such as transferring ownership with proper permissions and validation. The contract should handle product-related operations, including ownership claims and candidate verification, while ensuring security checks and emitting relevant events for ownership changes. The focus is on secure and permissioned product management within the contract.",
        "url": 76
    },
    {
        "nl_input": "The query requires a function that executes a spin or wager operation in a smart contract, involving token transactions, balance updates, and event emissions. It should validate game activity, block numbers, and player spins, while managing wager amounts, tiers, and division rates. The function must also handle spin completion and emit relevant events. The operation should be private and include checks for validity and game state.",
        "url": 77
    },
    {
        "nl_input": "The query requires a smart contract function that allows any contributor to add funds to a reward pool, where the contributed amount is added to the total reward. The function should be payable, accepting Ether, and update the reward balance accordingly. The focus is on enabling open contributions without restrictions, unlike functions that enforce specific conditions or are limited to certain roles. The simplest implementation is preferred.",
        "url": 78
    },
    {
        "nl_input": "The query requires a function that enables donating to an event, including transferring funds and recording the contribution. The function should check if the event is active, ensure successful fund transfer, and log the contribution details. The first option (contract c16665) matches these requirements with its `donate` function, which includes address and amount parameters, transfer validation, and event logging. The other options focus on different functionalities like payout calculations and button clicks, which don't align with the donation requirement.",
        "url": 79
    },
    {
        "nl_input": "The query requires a function to add an owner to a smart contract, ensuring the new owner's address is valid and not zero. The function should update the contract's state to include the new owner, possibly with checks for existing owners and maintaining consistency in owner records. The solution may involve modifiers for access control and emit events for tracking owner additions.",
        "url": 80
    },
    {
        "nl_input": "The query requires code that checks if a provided fee is sufficient for a transaction or operation. The code should verify the fee amount against a required value, handle cases where the fee is insufficient (e.g., reverting the transaction), and ensure the fee is correctly processed or transferred if adequate. The focus is on validation and conditional execution based on fee comparison.",
        "url": 81
    },
    {
        "nl_input": "The query requires a function that returns the current state of a game, including details like game ID, bet direction, bet amount, rolls, and winnings for a specific player. The function should be viewable and return multiple game state attributes in a structured format. The expected output should provide real-time game status information to track player progress and outcomes.",
        "url": 82
    },
    {
        "nl_input": "The query requires a function that calculates the amount of WPX tokens received based on the provided wei amount and predefined rates per 1 ETH. The function should handle different rate tiers depending on the wei amount (e.g., different rates for amounts between 0.1 ETH and 1 ETH, and for amounts 1 ETH or more). The calculation involves multiplying the wei amount by the appropriate rate and returning the resulting token amount.",
        "url": 83
    },
    {
        "nl_input": "The query requires a smart contract function that allows only the owner (sender) to pause and unpause an ICO. The function should include modifiers to ensure it can only be called by the owner and when the contract is in the correct state (paused or unpaused). It should also emit an event when the state changes. The function can be named `unpause` or `triggerICOState` and should toggle the pause status (`paused` or `isPaused`).",
        "url": 84
    },
    {
        "nl_input": "The query requires a function that allows the contract owner to close a sale, typically involving burning remaining sale tokens and marking the sale as closed. The function should include access control (e.g., `onlyOwner`) and a state condition (e.g., `beforeSaleClosed`). The expected outcome is to disable further sale activities and handle any remaining tokens appropriately.",
        "url": 85
    },
    {
        "nl_input": "The query requires a function to add KYC'ed addresses to a whitelist, with options for batch or single address addition, and typically includes access control (e.g., `onlyOwner` or `onlyWhitelister`). The function should validate addresses and update the whitelist state, optionally emitting events. The solution may involve looping through an array of addresses or handling a single address, with storage updates to mark addresses as whitelisted.",
        "url": 86
    },
    {
        "nl_input": "The query requires a modifier that allows actions to be performed by any user without restrictions, specifically ensuring that the function is not disabled for everyone. The modifier should not include checks for specific roles or addresses, unlike owner or burner-specific modifiers. The suitable code example is the `whenEveryone` modifier, which only checks that the action is not globally disabled (`!everyoneDisabled`).",
        "url": 87
    },
    {
        "nl_input": "The query requires a code snippet that implements a safeguard mechanism to protect investors from losing their investments, such as returning funds if certain conditions are met (e.g., time-based or failure conditions). The focus is on ensuring investor security by locking funds or enabling refunds under specific scenarios.",
        "url": 88
    },
    {
        "nl_input": "The query requires a function that returns the owner address of a specified soul or entity. The most suitable code is the first one, which includes a function `soulIsOwnedBy` that takes an address (`noSoulMate`) and returns the owner address stored in a mapping (`ownedBy`). This directly matches the need to retrieve the owner of a soul. The other functions either return an owner by index or a single owner, which do not fit the query's specific requirement.",
        "url": 89
    },
    {
        "nl_input": "The query requires a smart contract function to put a LinglongCat up for auction, specifying the starting price, ending price, and duration. The function should ensure the caller owns the LinglongCat and it's not pregnant, then approve and create the auction. The first code snippet meets these requirements by providing the necessary `createSaleAuction` function with the specified parameters and checks.",
        "url": 90
    },
    {
        "nl_input": "The query requires a function to allocate tokens to a specified address, ensuring the allocation is secure and validated. The function should check for valid addresses, prevent reallocation if tokens are already been assigned, and update the token balance accordingly. It may also include conditions like pausing functionality or owner restrictions. The allocation should trigger a transfer event and return the updated balance.",
        "url": 91
    },
    {
        "nl_input": "The query requires identifying code that checks or enforces conditions related to token release timing, specifically functions or modifiers that can be called only before or after tokens are released. The relevant code should include checks for release dates or conditions that control when token-related operations can be performed.",
        "url": 92
    },
    {
        "nl_input": "The query requires identifying code segments that handle bonus distribution or calculation in smart contracts. The focus is on functions that manage bonuses, including adding bonuses, calculating reward amounts, or distributing bonuses based on specific conditions like token thresholds or sender permissions. The code should involve operations like bonus allocation, reward computation, or bonus pool management. The description should be concise, highlighting the bonus-related functionality without detailed code analysis.",
        "url": 93
    },
    {
        "nl_input": "The query requires code that locks or disables ERC721 functionality to prevent trading on third-party platforms. The desired functionality should include a function that can be called by an authorized role (e.g., owner or admin) to disable ERC721 features or pause trading. The solution should ensure that the contract can no longer interact with ERC721-compliant platforms once the function is executed.",
        "url": 94
    },
    {
        "nl_input": "The query seeks code that retrieves the address of a smart contract. The most relevant code snippet returns the contract's own address using `this` keyword, while others fetch addresses from mappings or external calls. The primary requirement is a simple function that provides the contract's current address.",
        "url": 95
    },
    {
        "nl_input": "The query requires code that sets an alias for `msg.sender`, mapping the sender's address to a provided alias string and vice versa. The code should include a function that updates these mappings in a contract's storage. The expected functionality involves storing the alias associated with the sender and the sender's address associated with the alias. The other provided code snippets do not meet this requirement as they handle delegation or access control instead of alias management. (80 words)",
        "url": 96
    },
    {
        "nl_input": "The query requires a function to cast a vote for an account, ensuring checks like vote limits, sender validation, and candidate/ballot eligibility. The function should update vote counts and track used votes per account, possibly with constraints on voting periods or balances. The solution must prevent self-voting and enforce valid candidate/option selection.",
        "url": 97
    },
    {
        "nl_input": "The query requires a smart contract mechanism to lock a specific address until a specified future time. The solution should include a function that takes an address and a timestamp, validates the lock time is in the future, updates the lock state, and emits an event. It should support single or multiple addresses and enforce access control (e.g., onlyOwner or controller). The lock should prevent changes until the specified time is reached.",
        "url": 98
    },
    {
        "nl_input": "The query requires that only the KittyGym and Arena contracts are permitted to modify the KittyData contract. This is enforced through a modifier that restricts access to these specific contracts, ensuring no other contracts or addresses can make changes to KittyData.",
        "url": 99
    },
    {
        "nl_input": "The query requires code that can set the enabled status of an account, specifically a function that toggles the `enabled` status for a given address, with access restricted to the owner. The function should check the current status before updating it to avoid unnecessary state changes. The first code snippet meets these requirements with its `setEnabled` function, which includes owner verification and status comparison. The other snippets are unrelated to account status management. (80 words)",
        "url": 100
    },
    {
        "nl_input": "The query requires a function that recursively sends a specified value to investors in a list, handling cases where the value exceeds an investor's balance, moving to the next investor until the value is fully distributed or the list ends. It should ensure funds are deducted and sent correctly, reverting on failed transactions.",
        "url": 101
    },
    {
        "nl_input": "The query requires modifying the treasury or wallet address to which payments are forwarded. The suitable code should include a function that updates the destination address, restricted to the owner, without involving transfer logic. The first two code snippets meet this need by allowing the owner to change the treasury or wallet address, while the third snippet handles fund transfers but doesn't address the treasury update requirement.",
        "url": 102
    },
    {
        "nl_input": "The query seeks a helper function in Solidity that likely performs a specific utility task, such as enforcing a condition (e.g., executing a function only once), retrieving information (e.g., returning player data), or providing a simple return value (e.g., a contract name). The function should be concise and serve a supporting role within a smart contract.",
        "url": 103
    },
    {
        "nl_input": "The query requires a function to migrate token holders from an old contract to a new one, ensuring token balances are transferred and updated correctly. The function should be restricted to the owner, validate inputs, and handle batch transfers efficiently while maintaining total supply integrity. The migration process should also emit events for tracking and complete the transfer in a secure manner.",
        "url": 104
    },
    {
        "nl_input": "The query requires storing a gas price value in a storage variable and then updating it using an oraclize function. The solution should include a function that sets the gas price, checks for proper authorization (like owner-only access), and calls the oraclize function to update the gas price. The focus is on integrating oraclize's custom gas price functionality with secure access control.",
        "url": 105
    },
    {
        "nl_input": "The query requires a function that transfers tokens to a partner or specified address, ensuring proper authorization and balance checks, and updating the token balances accordingly. The function should handle token emission or transfer operations while maintaining contract state integrity.",
        "url": 106
    },
    {
        "nl_input": "The query requires a function to self-register a new DIN (Decentralized Identifier Number) and set a resolver address for it. The function should allow the caller to register the DIN and associate it with a specified resolver address, returning the newly created DIN. The operation should be permissionless, allowing any user to call it directly. The resolver address is provided as an input parameter to establish the association.",
        "url": 107
    },
    {
        "nl_input": "The query requires a function to transfer ownership of a team or entity from one address to another, ensuring the new owner is valid (non-zero address) and updating ownership counts or emitting events as needed. The function should handle internal state changes and may include checks or events like `Transfer` or `OwnershipTransferred`.",
        "url": 108
    },
    {
        "nl_input": "The query requires a function that sets a parameter identified by a given name to a specified value, typically using a key-value storage mechanism where the key is derived from the name (e.g., via hashing). The function should be private or internal and directly modify the storage without additional complex logic or snapshot management.",
        "url": 109
    },
    {
        "nl_input": "The query requires a function named `setToken` that updates the token address in a contract, typically restricted to authorized roles (e.g., founder or owner), with checks to ensure the token is set only once or the address is valid. The function should assign the new token address and update the contract state accordingly.",
        "url": 110
    },
    {
        "nl_input": "The query requires a function that manually triggers a health check, typically restricted to the owner, which can update a maintenance mode status and execute a health check if the mode is within a specific range. The function should include conditions to verify the maintenance mode before performing the health check.",
        "url": 111
    },
    {
        "nl_input": "The query requires a function to set a new token wallet address in a smart contract, ensuring the new address is valid (not zero address, not the contract's own address, and not the token's address) and only callable by the owner or founder. The function should update the wallet address and may include additional checks or events. The solution should prioritize security and proper access control.",
        "url": 112
    },
    {
        "nl_input": "The query requires a function to check if an address is registered, returning a boolean or timestamp-based verification. The first two code snippets provide relevant implementations: one checks against an allowed addresses list, while the other verifies registration by checking if a record exists (non-zero timestamp). The third snippet, which returns the contract's own address, is irrelevant. The query's focus is on address registration status verification. (80 words)",
        "url": 113
    },
    {
        "nl_input": "The query requires a function that returns the total supply of tokens from a smart contract. The function should be named `totalSupply`, marked as `constant` (or similar), and return an unsigned integer representing the current token supply. The supply value can be stored in variables like `numTokens`, `_totalSupply`, or simply `totalSupply`. The function should be publicly callable to fetch the total token count without modifying the contract state. (80 words)",
        "url": 114
    },
    {
        "nl_input": "The query requires a function to add a minter address to a TAU token contract after deployment, ensuring the address is valid and not already a minter. The function should be callable only by the contract owner and should return a boolean indicating success. The selected code should include checks for zero address and existing minter status, and update the minter mapping accordingly. The first code snippet meets these requirements. (80 words)",
        "url": 115
    },
    {
        "nl_input": "The query requires a function to transfer shares (tokens) to another address, adhering to the ERC-20 standard. The function should validate the sender's balance, update balances, handle new shareholders, and emit a transfer event. It must ensure the transfer amount is valid and prevent self-transfers. The solution should mirror standard token transfer logic, including checks and balance adjustments, similar to the ERC-20 `transfer` function.",
        "url": 116
    },
    {
        "nl_input": "The query requires code that implements a function to close a fund, including conditions for when the fund can be closed, transferring remaining funds, and updating the fund's state. It should handle scenarios where funding goals are met or not, possibly enabling refunds if the goal isn't reached. The function should be restricted to authorized users and emit events upon closure.",
        "url": 117
    },
    {
        "nl_input": "The query requires a function to distribute tokens to specified addresses, ensuring conditions like distribution status, token whitelisting, and supply limits are met. The function should handle token allocation based on ratios or fixed amounts, update balances, and emit events upon completion. It may include checks for authorized callers, minimum distribution thresholds, and prevent duplicate distributions. The exact implementation varies by contract, focusing on secure and efficient token distribution.",
        "url": 118
    },
    {
        "nl_input": "The query requires a function or method that can calculate and return the total sum of all fees collected up to the current point in time. The solution should track and aggregate fees from transactions or operations, possibly involving multiple addresses or accounts, and provide a way to retrieve the cumulative fee amount. The focus is on summing existing fees rather than calculating new ones.",
        "url": 119
    },
    {
        "nl_input": "The query requires code that updates the token fee when approving a transfer, specifically involving fee deduction from a transaction amount, updating balances, and transferring the remaining amount. The code should include checks for valid addresses and sufficient funds, calculate the fee, update the total supply and owner's balance, and execute the transfer. The first code snippet best matches these requirements.",
        "url": 120
    },
    {
        "nl_input": "The query requires a function to burn tokens from a sender's balance, ensuring the sender has sufficient tokens and reducing both the sender's balance and total supply accordingly. The function should include checks for valid amounts and emit an event upon burning. Only the contract owner should be able to execute this operation.",
        "url": 121
    },
    {
        "nl_input": "The query seeks examples of Solidity modifiers that use the `require` statement to enforce conditions before executing a function. The conditions include checking attempt limits, release dates, and sender authorization. The modifiers ensure functions are only called once, after a specific date, or by a designated address, respectively. The focus is on generic substitution patterns for `require()` in modifier contexts.",
        "url": 122
    },
    {
        "nl_input": "The query requires a public getter function in Solidity that retrieves multiple properties of an action (confirmations, expiration, triggered status, target address, and ETH value) from a mapping using an action ID as input. The function should be constant (view) and return all these properties in a single call. This matches the functionality shown in the first code snippet (c5259).",
        "url": 123
    },
    {
        "nl_input": "The query requires a smart contract function that allows the owner to remove a specified address from a blacklist. The function should be restricted to the owner and update the blacklist status of the target address. The expected output is a concise description of this functionality without code analysis.",
        "url": 124
    },
    {
        "nl_input": "The query requires a helper method that retrieves token details including the name, symbol, and total supply in a single function call. The method should return these three values together for convenience and efficiency. The first code snippet fulfills this requirement by providing a function `getTokenDetail` that returns all three specified values, while the other snippets only handle partial or unrelated functionality. The focus is on consolidating token information retrieval into one call.",
        "url": 125
    },
    {
        "nl_input": "The. The query seeks a function that calculates the remaining trial drops for a given token address by subtracting the used trial drops from the maximum allowed trial drops, returning 0 if no trial is available.  \n2. The query requires a function to cancel reserved tokens for a specified wallet, ensuring valid parameters and updating reserved amounts, restricted to the contract owner.  \n3. The query looks for a function that computes the number of tokens obtainable for a given ether amount, returning both tokens and excess ether.  \n\n(80 words)",
        "url": 126
    },
    {
        "nl_input": "The query requires a function that retrieves the actual stake amounts (`actualAmounts`) for all active personal stakes associated with a given address. The function should return these amounts as an array of `uint256` values. The focus is on querying stake data, not modifying or creating stakes. The first code snippet meets this need by calling `getPersonalStakes` and returning the `actualAmounts` array.",
        "url": 127
    },
    {
        "nl_input": "The query requires a function that allows a whitelisted internal application to set the ICO end date once, ensuring it can only be executed when the contract is not paused and the ICO end date hasn't been set previously. The function should enforce these conditions and update the ICO end date accordingly.",
        "url": 128
    },
    {
        "nl_input": "The query requires code that demonstrate how to set or change a controller or successor address in a smart contract, with conditions such as owner or admin permissions and address validation. The functionality should include updating the controller/successor address and emitting relevant events. The code should ensure the new address is valid (non-zero) and enforce access control through modifiers like `onlymanyowners` or `isAdmin`.",
        "url": 129
    },
    {
        "nl_input": "The query requires a function that sets the owner's share cut percentage for successful sales, ensuring it's less than 100 and emits an event upon change. The function should be restricted to the contract owner. The first code snippet meets these requirements by implementing `setOwnerCut` with a validity check and event emission, while the other snippets are unrelated to setting owner cuts.",
        "url": 130
    },
    {
        "nl_input": "The query requires code that updates or sets an access manager address in a smart contract. The function should allow changing the manager address, typically restricted to the contract owner or an authorized entity, and should include checks to ensure the new manager address is valid (not zero address). The update should be logged or return a success status. The focus is on access control management within the contract.",
        "url": 131
    },
    {
        "nl_input": "The query requires generating a large cat image using a smart contract that defines a pixel-based representation of a cat in hexadecimal format, with functions to manipulate and return the image data. The code should handle image rendering at specified coordinates and return the formatted image data. The other provided contracts are unrelated to this task. The focus is on the cat image generation functionality.",
        "url": 132
    },
    {
        "nl_input": "The query requires a function that retrieves the commitment value associated with a specified address from a smart contract. The function should take an address as input and return a uint256 value representing the commitment. The first code snippet matches this requirement by providing a `commitmentOf` function that returns the `value` associated with a miner's address. The other snippets are unrelated to the query's needs.",
        "url": 133
    },
    {
        "nl_input": "The query requires a function to change the wallet address for reserved vesting, allowing the smart-contract address to be set later. The function should be restricted to the owner, include address validation, and emit an event if applicable. The solution should combine ownership control, address validation, and flexibility for future updates.",
        "url": 134
    },
    {
        "nl_input": "The query requires a function to create or update a personal claim, where a user can set a key-value pair about themselves. The function should be publicly callable and allow the sender to modify their own claims without requiring admin or owner privileges. The claim should be stored in a way that associates it with the sender's address. The solution should focus on self-managed claims rather than admin-controlled or token-related claims. (80 words)",
        "url": 135
    },
    {
        "nl_input": "The query requires checking if a user belongs to a specific group. The suitable code should verify user membership by comparing the user's address against a group's member list or checking group-related attributes associated with the user. The expected function should return a boolean indicating membership status, possibly involving checks like group name validation or user registration status. The first code snippet best matches this requirement by checking group membership directly.",
        "url": 136
    },
    {
        "nl_input": "The query requires a function that allows the contract owner to transfer any ERC20 token from the contract to the owner's address. The function should include checks to ensure the owner is the caller and handle the token amount safely. The solution should be compatible with the ERC20 standard and may include additional safety measures like preventing transfers to the contract's own address.",
        "url": 137
    },
    {
        "nl_input": "The query requires identifying code snippets that involve checking or managing token allowances or balances in smart contracts. Specifically, it looks for functions that handle token allowances between addresses, check available tokens under certain conditions, or approve token transfers. The focus is on Ethereum smart contract functions that interact with token standards, particularly those returning or manipulating uint256 values related to token allowances or balances.",
        "url": 138
    },
    {
        "nl_input": "The query requires a function that forwards a payment from the sender to a specified address ('to'), ensuring the transfer is valid and deducting any applicable fees. The function should handle the transfer of funds, update balances accordingly, and include checks for non-zero addresses and sufficient funds. The solution should also emit relevant events for tracking the transaction.",
        "url": 139
    },
    {
        "nl_input": "The query requires a function to add an address to an accredited list, ensuring the address is valid and meets specific conditions such as non-zero value, proper vesting periods, and investment limits. The function should be restricted to the owner and may include additional checks like revokable status and burning on revocation. The solution should emit an event upon successful addition. (80 words)",
        "url": 140
    },
    {
        "nl_input": "The query requires a function to unpause a token, enabling transfers by invoking `token.unpause()` through an `unpauseToken()` method restricted to the contract owner.",
        "url": 141
    },
    {
        "nl_input": "The query requires a function to freeze multiple Ethereum addresses, with options to either freeze them indefinitely or with specific timestamps. The function should be restricted to the contract owner and include checks for valid inputs, such as non-zero addresses and matching array lengths when timestamps are provided. The function should update the frozen status of each address and emit relevant events if applicable.",
        "url": 142
    },
    {
        "nl_input": "The query requires a function to create a new \"Tuber\" entity with specified attributes (name, owner, price), store it in an array, assign a price, and transfer ownership. The function should validate the new entity's ID and emit a birth event. The code should be similar to creating a digital asset with ownership and pricing features, ensuring proper data types and storage.",
        "url": 143
    },
    {
        "nl_input": "The query requires extracting a function that returns the number of decimal places a token uses, typically implemented as a constant public function named `tokenDecimals()` that returns a `uint8` value. The expected code should directly return the token's decimal precision without additional calculations or parameters.",
        "url": 144
    },
    {
        "nl_input": "The query requires a smart contract function that allows users to redeem MTU tokens, either by converting them to ETH based on a redeem rate and time limit or by transferring the MTU tokens back to the user. The function should update the user's balance and emit an event upon redemption. The contract should also manage the total unRedeemedMTU balance.",
        "url": 145
    },
    {
        "nl_input": "The query requires a function to calculate token amount based on wei input and conversion rate(s). Key elements include:  \n1. Direct division of wei by a fixed rate  \n2. Tiered rate system (different rates for 0.1-1 ETH and \u22651 ETH ranges)  \n3. Optional excess tracking  \n4. Rate-based multiplication for token calculation  \nOutput must return numerical token value derived from wei input and predefined rate logic.",
        "url": 146
    },
    {
        "nl_input": "The query requires handling contribution amounts and cap logic in a smart contract, including checking contribution limits, enforcing minimum contributions, and managing compensation for contributors based on predefined conditions like soft and hard caps. It involves transferring tokens, updating contribution thresholds, and ensuring proper distribution of funds according to specified rules.",
        "url": 147
    },
    {
        "nl_input": "The query requires updating the symbol of a token in a smart contract, which can be done through functions that allow setting or modifying the symbol variable, typically restricted to the contract owner. The functions may include checks for ownership or emit events upon updating. The symbol can be updated individually or alongside other token information like the name.",
        "url": 148
    },
    {
        "nl_input": "The query requires a method to list all deeds (NFTs) without using arrays, as an alternative to ERC721Enumerable. The solution should efficiently track and retrieve deeds owned by an address, avoiding array-based storage to optimize gas usage and performance. The focus is on enabling deed enumeration through a mapping-based approach rather than traditional array iteration.",
        "url": 149
    },
    {
        "nl_input": "The query requires a function that changes the contract owner to `_owner`, ensuring the function is restricted to the current owner (`onlyOwner` modifier). The function should update the owner variable and may include an event to log the change. The solution should be simple, directly assigning the new owner address without additional parameters or complex logic.",
        "url": 150
    },
    {
        "nl_input": "The query requires a function that enables the contract owner to mint new tokens, specifying the recipient address and the amount to be minted. The function should update the total supply and balances, and emit transfer events. It may include checks or specific conditions for minting, such as preserving tokens or sending to a predefined address. The owner-only restriction is mandatory to ensure controlled token creation.",
        "url": 151
    },
    {
        "nl_input": "The query requires a function to set or update a token address in a smart contract, with access restricted to an authorized role (e.g., founder or owner). The function should validate the input address (e.g., non-zero check) and ensure the token address is set only once if needed. The return value may indicate success. The target contract should interact with a token interface (e.g., `ANOToken` or `Token`).",
        "url": 152
    },
    {
        "nl_input": "The query requires an internal method to create a new EtherDog with specified attributes (matronId, sireId, generation, genes, owner), validate input parameters, set cooldown, store the new EtherDog, emit a Birth event, and transfer ownership. The method should return the new EtherDog's ID. The provided code (c13772) matches this requirement by implementing these steps, including validation, storage, event emission, and ownership transfer.",
        "url": 153
    },
    {
        "nl_input": "The query requires a smart contract function that transfers all raised funds (the contract's balance) to the founders' wallet. The function should be restricted to the owner and ensure the transfer is executed securely. The ideal solution would involve checking the success of the transfer and reverting if it fails, similar to the first code snippet but specifically targeting the founders' wallet.",
        "url": 154
    },
    {
        "nl_input": "The query requires identifying a function that closes a bet and declares a champion by setting the winning team ID, marking the bet as closed, and calculating the reward for the winning choice. The function should be restricted to the contract owner and emit an event with the winning team ID and reward details. The first code snippet meets these requirements with its `saveResult` function.",
        "url": 155
    },
    {
        "nl_input": "The query requires code snippets that handle emergency or urgent situations in smart contracts, specifically functions that allow for immediate fund withdrawal or contract termination under specific conditions. The focus is on functions with modifiers like ownerOnly or conditions that trigger emergency actions such as draining funds or self-destructing the contract. The description should be concise, highlighting the urgency and specific actions like fund transfer or contract destruction.",
        "url": 156
    },
    {
        "nl_input": "The query requires an admin-restricted function to add claimants by specifying their address, claim amount, and a boolean indicating if they've claimed. The function must store these details in a struct within an array, ensuring only authorized admins can execute it.",
        "url": 157
    },
    {
        "nl_input": "The query requires a function that allows placing a bet on a dozen (first, second, or third) in a casino-like contract. The function should accept an input (0, 1, or 2) representing the selected dozen and handle the bet placement accordingly, ensuring the input is valid (0-2). The function should be payable and may include checks or interactions with other contract functions to process the bet.",
        "url": 158
    },
    {
        "nl_input": "The query requires a smart contract function that ensures:  \n1. The caller is a certified basic account from USA, China, or South Korea.  \n2. The transaction has a valid signature.  \n3. The gas price is sufficiently low.  \n4. The sent value is sufficiently high (above a dust limit).  \n\nThe most suitable code is from URL 159, which checks certification, basic account status, and minimum value, but lacks explicit gas price validation.",
        "url": 159
    },
    {
        "nl_input": "The query requires an internal function that processes a repayment amount transfer, ensuring the repayment is valid, updating the loan state, handling interest and principal amounts, and transferring collateral back to the borrower. The function should verify loan conditions, calculate interest, and manage token transfers or burns accordingly.",
        "url": 160
    },
    {
        "nl_input": "The query requires a function or modifier that enforces a condition check, such as equality assertion, single execution, or time validation, and reverts or restricts execution if the condition fails. The examples include checking value equality, limiting function calls to once, and verifying a timestamp is in the future. The focus is on conditional logic that ensures specific requirements are met before proceeding with execution.",
        "url": 161
    },
    {
        "nl_input": "The query requires a function that retrieves a 4-element array of enemy class IDs for a given address, defaulting to an initial combination if no personalized configuration exists. The data structure involves checking address-specific storage and returning either customized or predefined enemy slot identifiers as a fixed-size uint32 array.",
        "url": 162
    },
    {
        "nl_input": "The query requires a function that allows the contract owner to retrieve a player's metadata, including ID, name, address, scores, and status, during migration. The code must enforce ownership permission and return multiple player attributes for migration purposes.",
        "url": 163
    },
    {
        "nl_input": "The query seeks to determine the current halving number, which refers to the specific period or block count in a blockchain where the reward for mining new blocks is halved. The relevant code should include a function that calculates or returns the current halving number based on the blockchain's block count or similar metrics. The first code snippet (`currentHalving()`) directly addresses this by returning the halving number for the current block.",
        "url": 164
    },
    {
        "nl_input": "The query requires a smart contract function enabling the owner to withdraw arbitrary amounts of ether at any time, implemented via an `onlyOwner` modifier, a parameterized withdrawal amount, and direct transfer execution without time constraints (e.g., `withdrawEther(uint amount)`). The code must ensure unrestricted access to contract funds by the owner, excluding split transfers or ICO phase checks.",
        "url": 165
    },
    {
        "nl_input": "The query requires converting a uint256 value into a Warship structure by extracting specific components (uint128, uint32, multiple uint8, and uint16 values) through bitwise shifting and masking operations to decode the packed data into structured attributes.",
        "url": 166
    },
    {
        "nl_input": "The query requires a function restricted to the contract owner for distributing tokens to ICO investors, ensuring controlled delivery. This function must include access control (onlyOwner), specify recipient addresses and token amounts, and may involve minting, frozen periods, or predefined supply constraints. The delivery process should validate parameters (e.g., supply limits, timing) and log transactions for transparency.",
        "url": 167
    },
    {
        "nl_input": "The query requires a voting method where a user can select a valid candidate, ensuring the candidate is within allowed range, voting is within active period, and each voter's choice is recorded once. The method should track voters, update their selected candidate, and emit an event confirming the vote.",
        "url": 168
    },
    {
        "nl_input": "The query requires calculating the total pending bets by summing the `betPrice` of bets in `BET_STATE_WAITPAIR` and double the `betPrice` for bets in `BET_STATE_WAITORACLIZE`, iterating through the `bets` array. Only code from URL 169 addresses this logic.",
        "url": 169
    },
    {
        "nl_input": "The query requires a smart contract function that allows the owner to set/update a delegate address for method execution, enforcing sender ownership checks and triggering an update event. The core elements are: owner-restricted `setDelegate` function, address parameter validation, and delegation state change tracking.",
        "url": 170
    },
    {
        "nl_input": "The query requires implementing a Digix price feed update function that validates nonce increments, checks block number validity, verifies cryptographic signatures, and updates the price data (ask and bid values) securely.",
        "url": 171
    },
    {
        "nl_input": "The query requires a function to transfer an estate (token) between addresses, ensuring the current owner matches, validating the new address isn't zero/contract, updating ownership records, handling payouts/approvals, and emitting a transfer event. Key steps include ownership verification, token existence check, state updates (remove/add tokens), and event logging for transparency.",
        "url": 172
    },
    {
        "nl_input": "The query requires an internal function to finalize PvE battles by updating the warrior's state (action, cooldown, dungeon progression), generating a new warrior, and emitting a completion event, ensuring all prerequisites are met before execution.",
        "url": 173
    },
    {
        "nl_input": "The query requires retrieving a user's token balance at a specific historical block using the `balanceOfAt` method, which accepts the user's address and target block number as parameters to return the balance snapshot from that block.",
        "url": 174
    },
    {
        "nl_input": "The query requires minting tokens for pre-crowdsale purchases only before the crowdsale starts, ensuring valid investor addresses, adhering to the pre-crowdsale token cap, and triggering a purchase event. The code must enforce timing constraints (before startTime), validate inputs, manage token supply limits, and execute minting securely.",
        "url": 175
    },
    {
        "nl_input": "The query requires an ERC20 transfer function that restricts token transfers until a sale is finalized, enforced by a state-checking modifier (e.g., `require(saleCompleted)`). The finalization is triggered by a dedicated function (e.g., `finalize()`) setting a flag (e.g., `saleCompleted = true`), typically with owner-only access and conditions like sale completion thresholds or timing constraints.",
        "url": 176
    },
    {
        "nl_input": "The query requires identifying code that calculates a rate using the formula `baseRate * (100 + bonus) / 100`, where `bonus` increases based on `toFund` thresholds. The code must reference `baseRate`, apply incremental bonus percentages, and return the computed rate.",
        "url": 177
    },
    {
        "nl_input": "The query requires a smart contract that implements a time-based rate adjustment mechanism, where the rate increases incrementally over specific time intervals (days 0-6, 6-13, 13-20, 20-28, post-28) starting from a predefined `START` timestamp, with fixed numerical values assigned to each phase.",
        "url": 178
    },
    {
        "nl_input": "The query requires an internal utility function to initiate a PvP battle after validating prerequisites. The provided code examples include post-battle reward handling (pvpFinished), claim fortification (fortifyClaims), and PVE cooldown management (_triggerPVEFinish), but none directly implement the initiation logic. The desired function should focus on starting the battle (e.g., matchmaking, state transitions) once checks are confirmed, which is not explicitly covered in the given snippets.",
        "url": 179
    },
    {
        "nl_input": "The query requires a Solidity modifier that ensures a function can be executed only once, typically by checking a condition (e.g., a counter or boolean flag) to restrict repeated calls. The modifier enforces a single-use constraint, blocking subsequent executions after the initial invocation.",
        "url": 180
    },
    {
        "nl_input": "The query requires a smart contract function that accepts a contribution only if the user has passed KYC (Know Your Customer) verification. The function should check the KYC status before allowing the contribution to proceed.",
        "url": 181
    },
    {
        "nl_input": "The query requires modifying a smart contract to allow adjusting the minimum bet amount via an owner-restricted function that validates the new value is positive. The relevant code implements a `changeMinimumBetAmount` function updating `minimumBetAmount` when the input exceeds zero, ensuring only the owner can execute it.",
        "url": 182
    },
    {
        "nl_input": "The query requires a function that calculates the amount of tokens to be received based on an input amount of Ether, using a conversion rate. The code must take an investment value (in wei/weiAmount), apply a token rate (possibly derived from ETH/token ratios), and return the computed token quantity through mathematical operations like multiplication and division.",
        "url": 183
    },
    {
        "nl_input": "The query requires a description of how to retrieve gifts based on a template ID. The relevant code shows a function `getGiftsByTemplateId` that returns an array of gift IDs associated with a given template ID. The other functions (`updateGift` and `isValidGift`) are unrelated to the retrieval process. The core need is to fetch gift IDs linked to a specific template ID from a smart contract. (58 words)",
        "url": 184
    },
    {
        "nl_input": "The required function must execute post-crowdsale to finalize operations, ensuring conditions like time expiration or goal achievement are met. It should transfer funds if goals are reached or enable refunds otherwise, updating the finalization state and emitting relevant events. Checks include verifying crowdsale closure, completion status, and triggering fund distribution or refund mechanisms as needed.",
        "url": 185
    },
    {
        "nl_input": "The query seeks a process where tokens sent to a buyer are calculated using a predefined rate established during contract deployment. This involves multiplying the sent Ether by the rate, adjusting for decimals, transferring tokens to the buyer's address, and forwarding received funds to a designated wallet.",
        "url": 186
    },
    {
        "nl_input": "The query requires identifying code handling token sale processes, including purchase validation, token distribution, and stage transitions. Key elements are checking sale stages, calculating token amounts, transferring funds, updating stages, and ensuring conditions like minimum contribution and hard cap limits. Functions must manage private purchases, process payments, handle excess funds, and transition between sale phases while emitting relevant events.",
        "url": 187
    },
    {
        "nl_input": "The function must process multiple claimed tile IDs in one transaction, accepting an array of tile IDs, a fortify amount, and a flag for battle value usage. It verifies the sender's payment and battle value, then applies fortification to each specified tile, ensuring atomic execution and state updates via an external service call.",
        "url": 188
    },
    {
        "nl_input": "The function must handle private sale purchases by verifying the current stage is Private, checking token availability, calculating tokens based on weiAmount and stage rate, transferring tokens if sufficient, or adjusting tokens/wei and advancing stage if insufficient, then refunding excess ether. It enforces stage-specific conditions, manages token allocation, and updates the sale stage upon token pool depletion.",
        "url": 189
    },
    {
        "nl_input": "The query requires a secure token transfer function restricted to the owner (escrow) for private sales, ensuring valid amounts, time constraints, and restricted addresses. The code must include owner-only access, validation checks, and a dedicated transfer method for authorized token movements between specified accounts.",
        "url": 190
    },
    {
        "nl_input": "The query requires creating a poll with parameters for vote quorum, commit phase duration, and reveal phase duration, generating a unique poll ID, storing poll details (deadlines, vote counts), and emitting an event upon creation. The code must ensure sequential poll IDs, validate input constraints, and track poll lifecycle stages (commit/reveal periods).",
        "url": 191
    },
    {
        "nl_input": "The query requires confirming if `dstWalletLMNO` is initialized to a non-zero address. The code checks this via `require(dstWalletLMNO != address(0))`, ensuring it is set before executing `debitWalletLMNO`, enforced by the `onlyDSTWalletLMNO` modifier. Other code snippets are unrelated.",
        "url": 192
    },
    {
        "nl_input": "The query requires implementing a mechanism to allow accessing the bankroll slots only after a 60-day waiting period. This involves modifying the bankroll-related functions to include a time-based restriction, ensuring that withdrawals or interactions with the bankroll are permitted only after the specified duration has elapsed. The solution may need to integrate with existing bankroll management functions while enforcing the time constraint.",
        "url": 193
    },
    {
        "nl_input": "The query requires a smart contract function that allows the owner to withdraw ERC-20 tokens approved by a user and exchange them for RMC tokens. The function should transfer the approved tokens from the user to the owner's address, ensuring only the owner can execute this operation. The solution must use ERC-20 token standards for secure transfers and include checks to prevent unauthorized access or misuse.",
        "url": 194
    },
    {
        "nl_input": "The query requires determining the conditions under which a jackpot is released and identifying the recipient. The relevant code checks if a specific time-based condition is met (using `addmod(now, 0, 150) == 0`) and, if true, sends the jackpot balance to a designated ticket holder, then clears the tickets. The other code snippets provide context on jackpot value tracking and funding but do not address the release logic.",
        "url": 195
    },
    {
        "nl_input": "The query requires a function that calculates and returns the profit from selling a specified number of outcome tokens. The function should deduct fees from the profit, ensure the profit meets a minimum threshold, transfer the tokens and collateral, and update the net outcome tokens sold. The profit calculation involves market maker logic and fee computation, with checks for valid token counts and sufficient profit.",
        "url": 196
    },
    {
        "nl_input": "The query requires assigning share tokens to the authors of winning bids in a smart contract. The code should handle calculating and transferring the appropriate share amounts, updating balances, and ensuring only winning bids receive shares. The process involves verifying bid status, executing transfers, and emitting events for transparency. The solution must manage share allocation, fund distribution, and return any excess amounts to investors.",
        "url": 197
    },
    {
        "nl_input": "The query requires a function to retrieve the available tokens for a given address or phase, considering conditions like time-based steps, token allocations, or phase caps. The function should return the calculated token amount based on the specified rules, such as current phase, time constraints, or beneficiary balances. The solution must ensure the tokens are only accessible under valid conditions (e.g., active phase, verified address).",
        "url": 198
    },
    {
        "nl_input": "The query requires a function that retrieves the available inventory of a product, specifically returning the available quantity for a given product ID. The function should be public and viewable, accepting a product ID as input and returning the available count as an unsigned integer.",
        "url": 199
    },
    {
        "nl_input": "The query requires a description of a mint token function in smart contracts. The function should create new tokens and assign them to a specified address, typically with checks for valid addresses and ownership permissions. It may include events like Transfer to log the minting action and update token balances or total supply. The function can be internal or restricted to the contract owner, depending on the implementation.",
        "url": 200
    },
    {
        "nl_input": "The query requires functionality that allows the owner of a reservation to either close it early or extend its duration. This involves modifying the reservation's end time or state through owner-only functions, ensuring proper checks and state transitions are in place. The code should include conditions to validate the new end time or state changes and emit relevant events if necessary.",
        "url": 201
    },
    {
        "nl_input": "The query requires a function that allows only the owner to modify the lock period, with the change being constrained within a specific range (e.g., 1 to 30 days). The function should update the lock period variable and enforce ownership and validity checks.",
        "url": 202
    },
    {
        "nl_input": "The query requires a smart contract function that allows the owner to refund collected ETH to contributors if the soft cap is not met or KYC verification fails. The function should ensure secure transfer of ETH back to contributors and handle conditions where the fundraising target isn't achieved or KYC checks are unsuccessful.",
        "url": 203
    },
    {
        "nl_input": "The query requires a function to cancel an auction or sale, ensuring the seller is the owner, updating the auction/sale status, and emitting an event. The function should validate ownership, remove the auction/sale record, and transfer ownership back if needed. Key steps include checking seller authorization, updating state variables, and logging the cancellation.",
        "url": 204
    },
    {
        "nl_input": "The query requires a description of how a contract owner can seed a Jackpot with funds and retrieve them when the Jackpot is paid. The owner can add funds to the Jackpot balance via a `seed` function, and the funds can be returned or distributed when specific conditions are met, such as when the Jackpot is completed or paid out. The Jackpot's total value can also be checked at any time.",
        "url": 205
    },
    {
        "nl_input": "The query requires extracting the sender's information from a smart contract. The relevant functions include retrieving the sender's address (`whoAmI`), the sender's balance (`getBalance`), or detailed player info (`getMyInfo`). The sender is identified using `msg.sender`, a built-in variable in Solidity that holds the address of the function caller. The functions can return the address directly or use it to fetch associated data like balances or player details.",
        "url": 206
    },
    {
        "nl_input": "The query requires implementing a token recipient interface that includes functions for claiming or transferring tokens. The functions should handle token operations such as claiming tokens for the sender or a specified address, and minting tokens to an address with necessary checks and event emissions. The interface should ensure proper ownership and address validation during these operations.",
        "url": 207
    },
    {
        "nl_input": "The query requires a backup withdrawal function for ETH that ensures only authorized users can execute it, checks if the withdrawal conditions are met (like ICO ended or specific stages), and safely transfers the contract's ETH balance to a designated wallet or address. The function should handle edge cases like zero balance or invalid addresses and emit events for tracking.",
        "url": 208
    },
    {
        "nl_input": "The query requires a function that allows the contract owner to change or set the address of an admin. The function should include checks to ensure the new admin address is valid, not the owner, not the contract itself, and not already an admin. It should also emit an event or return a status indicating the change was successful. The admin address should be updated in the contract's state.",
        "url": 209
    },
    {
        "nl_input": "The query requires a description of an internal method that exclusively zeros out `sellerListMapping` and `sellerToPrice` for a given seller. The method should not perform any additional operations beyond these two actions. The provided code snippet from contract `c14407` demonstrates this functionality by setting `sellerToPrice[seller]` to `0` and `sellerListMapping[seller]` to `nullAddress`. This meets the query's need for a focused, internal zeroing-out operation.",
        "url": 210
    },
    {
        "nl_input": "The query requires a function to transfer LAND tokens, specifying coordinates (x, y) and the recipient's address. The function should call a transfer method with the encoded token ID derived from the coordinates. The first code snippet matches this requirement by providing a `transferLand` function that takes x, y, and address parameters, then transfers the encoded token ID to the specified address. The other snippets handle different transfer scenarios and are not relevant.",
        "url": 211
    },
    {
        "nl_input": "The query requires a function that allows the contract owner to transition from the loyalty phase to the presale phase, marking the start of the presale with a timestamp. The function should be restricted to the owner and update the state to indicate the presale has begun. The expected code should include a modifier for owner-only access and set the presale start time.",
        "url": 212
    },
    {
        "nl_input": "The query requires a function to perform housekeeping tasks, such as transferring remaining funds or self-destructing the contract, after it is no longer needed (e.g., post-upgrade). The function should be restricted to the owner and may include conditions like a time delay or state checks. Suitable options include `cleanup()` for fund transfers or `shutdown()` for contract destruction.",
        "url": 213
    },
    {
        "nl_input": "The query requires a function to add a new manager in a smart contract. The function should allow setting or enabling a manager address, with checks to ensure the address is valid and not already a manager. It should include access control (e.g., `onlyOwner` or `canManage`) and emit an event upon success. The manager's address should be stored in a mapping or state variable, and the function should handle edge cases like setting the manager to zero address.",
        "url": 214
    },
    {
        "nl_input": "The query requires a function that stakes tokens from the caller for a specific user and rewards that user with credits. The function should transfer the staked amount, update the user's credit balance, and handle the reward mechanism. The code should include parameters for the user's address, the staked amount, and any additional data, along with logic to manage the credit allocation.",
        "url": 215
    },
    {
        "nl_input": "The query requires a modifier or function that checks if a given value can be stored within a 64-bit unsigned integer (uint64). The solution should ensure the value does not exceed the maximum size of a 64-bit uint by comparing or converting the value appropriately. The first code snippet fits this requirement with a modifier that checks if a 256-bit value can be safely downcast to a 64-bit uint.",
        "url": 216
    },
    {
        "nl_input": "The query requires initializing bet data in a smart contract, including setting the ticket price and bet title. The relevant code snippet shows a function `initBet` that takes `_ticketPriceWei` and `_betTitle` as inputs, updates the contract state variables `ticketPrice` and `betTitle`, and is restricted to admin access. This matches the need to set up initial bet parameters securely.",
        "url": 217
    },
    {
        "nl_input": "The query requires a function to submit an order-ring for validation and settlement, involving multiple parameters such as address lists, numerical arguments, boolean flags, and signature components. The function should verify input data integrity, check token registration, handle ring signatures, and process the order-ring with specified fee recipients. The code should ensure proper ring size constraints and manage state transitions post-submission. The most relevant code is the first one (url 218) which matches these requirements.",
        "url": 218
    },
    {
        "nl_input": "The query requires a default approval function in a smart contract that allows a token holder to approve a spender to transfer a specified amount of tokens. The function should check if the value is zero or if the spender's allowance is zero, update the allowance, emit an approval event, and return a success status. The function parameters include the spender's address and the approved token amount.",
        "url": 219
    },
    {
        "nl_input": "The query requires a description of the steps a backer must follow to get a refund in ETH when the minimum capital (MIN_CAP) is not reached in a DevvotePrefund contract. The backer needs to: 1) approve the Devvote token contract for the refund amount, 2) call the refund function in DevvotePrefund with the same amount, and 3) call withdrawPayments to receive the ETH refund. The code snippets show similar refund mechanisms but do not fully match the exact steps described.",
        "url": 220
    },
    {
        "nl_input": "The query requires extracting the X and Y coordinates of a curve point for a public key from a smart contract. The relevant code should return two values (x and y) that represent these coordinates when given a node identifier or similar input. The first code snippet matches this requirement by returning `records[node].pubkey.x` and `records[node].pubkey.y` as bytes32 values.",
        "url": 221
    },
    {
        "nl_input": "The query requires a function that returns the current cap value from a smart contract. The function should be public, constant, and return a uint256 value representing the cap. The first code snippet meets these requirements with `function getIcoCap() public constant returns (uint256)`. The other snippets either return tokens available or a bonus rate, which do not match the cap requirement.",
        "url": 222
    },
    {
        "nl_input": "The query requires information on how to set or check the status of an Initial Coin Offering (ICO) in a smart contract. This includes activating the ICO status, updating the status based on token availability, and checking if the current time falls within the ICO period. The relevant code snippets demonstrate functions to activate ICO status, update status via token balances, and verify if the current time is within the ICO duration.",
        "url": 223
    },
    {
        "nl_input": "The query requires extracting the constant `_symbol` from a contract. The relevant code is a function that returns the `_symbol` value, specifically from the contract `c2824` which has a `symbol()` function returning the `_symbol` string. The other contracts either handle different functions or modify the symbol rather than returning it. The need is to access the constant symbol value from a contract's view function.",
        "url": 224
    },
    {
        "nl_input": "The query requires a function named `setTokenAddress` that assigns a token address to a variable. This function should be callable only by the founder and only once. It must include a check to ensure the token address hasn't been set before and should return a boolean indicating success. The function should update the token address and a flag indicating it has been set.",
        "url": 225
    },
    {
        "nl_input": "The query requires retrieving the registered EOS public key associated with a given Ethereum address. The suitable code should include a function that takes an address as input and returns the corresponding EOS key, either from storage or by querying an external source if not found. The first code snippet fits this requirement with its `getEOSKeyFor` function.",
        "url": 226
    },
    {
        "nl_input": "The query requires a function to transfer tokens from one address to another, involving checks for token ownership, balance adjustments, and authorization. The function should handle token transfers between specified addresses, ensure sufficient balances, and update allowances if needed. It may include additional conditions like transfer restrictions or owner permissions. The goal is to securely move tokens while maintaining proper accounting and authorization.",
        "url": 227
    },
    {
        "nl_input": "The query requires a function that enables batch approval for all tokens or operations, allowing multiple addresses to be approved or disapproved in a single transaction. The function should iterate through an array of addresses and set the approval status for each, ensuring no zero addresses are included and the operation is supported. This is distinct from single approvals or approvals for specific token IDs.",
        "url": 228
    },
    {
        "nl_input": "The query requires a function that burns all remaining tokens in the owner's account and adjusts the license cost. The function should be restricted to the owner, ensure proper token burning, and update the total supply accordingly. It may also include checks for paused states and require specific conditions before execution. The implementation should handle the burning process securely and emit relevant events if necessary.",
        "url": 229
    },
    {
        "nl_input": "The query requires a description of a smart contract function that allows proposing a new address or transfer, typically involving conditions like ownership or beneficiary checks, and possibly including voting or approval mechanisms. The function should handle the proposal creation, set necessary parameters (e.g., deadline, weights), and transition the contract state if applicable. The proposal may also involve validation checks or emit events for tracking.",
        "url": 230
    },
    {
        "nl_input": "The query requires a function that returns the number of matches in a contract. The suitable code should include a public view function named something like `getNumMatches` that returns the length of a `matches` array as a `uint`. The first code snippet meets this requirement exactly with `function getNumMatches() public view returns (uint) { return matches.length; }`.",
        "url": 231
    },
    {
        "nl_input": "The query requires a function that allows the release of FT tokens for core team accounts. The function should be publicly accessible and may involve checking or updating the released token status for specific addresses. The core functionality should enable token release either directly or through a timelock mechanism.",
        "url": 232
    },
    {
        "nl_input": "The query requires calculating the offset of a given block within a specific interval, likely for determining block-related rewards or halving periods. The relevant code snippet uses modulo operation to find the remainder when the block number is divided by a predefined interval, indicating the block's position within that cycle.",
        "url": 233
    },
    {
        "nl_input": "The query requires setting an expiry time in milliseconds since 1970. The suitable code should include a function that allows updating a timestamp variable (like `expiry` or `endsAt`) with a specified time value, typically restricted to the contract owner. The function may include checks (e.g., ensuring the new time is valid) and emit events upon successful updates. The focus is on time-based state modification with owner-only permissions.",
        "url": 234
    },
    {
        "nl_input": "The query requires a function to remove a contract address from a list of active contracts by updating the list and resetting its index. The function should ensure the address is valid and maintain the list's integrity by replacing the removed address with the last one in the list and reducing the list length. This operation should be restricted to the contract owner.",
        "url": 235
    },
    {
        "nl_input": "The query requires a function that changes the ownership of a product or contract, verifying permissions and updating the owner. The function should include checks for valid new owners, emit ownership change events, and clear any pending ownership candidates. It should be restricted to authorized users (e.g., current owner or approved candidates). The solution must handle both direct ownership transfers and candidate-based transfers securely.",
        "url": 236
    },
    {
        "nl_input": "The query requires a function to set or update a wallet address in a smart contract, ensuring the new address is valid (not zero address, not the contract's own address, and not the token's address). The function should be restricted to the contract owner and may include an event emission for tracking changes. The implementation should return a boolean success status or simply execute the update without a return value.",
        "url": 237
    },
    {
        "nl_input": "The query requires a failsafe mechanism to remove or abort a game, ensuring proper handling of player refunds, updating game status, and logging relevant events. The code should deactivate the game, return funds to players, and record the reason for termination (e.g., cancellation or timeout). It may also involve manual removal by an owner, transferring locked assets, and updating game state variables. The solution must ensure security and proper resource management during game termination.",
        "url": 238
    },
    {
        "nl_input": "The query requires a function that retrieves the owner of a token. The suitable code should return the token owner's address or related token information from a mapping or array, typically using a function like `tokensOf`, `releasedTokenOf`, or `balanceOf` with an `address _owner` parameter. The expected output is the token data associated with the owner, such as token IDs, counts, or release status.",
        "url": 239
    },
    {
        "nl_input": "The query requires a function that checks whether an entity was created using `createUser()` (returning `true`) or `createVirtualEntity()` (returning `false`). The function should take an entity address as input and return a boolean indicating the creation method. The first code snippet (`c22678`) matches this requirement by resolving the entity address and comparing it with the owner's entity mapping.",
        "url": 240
    },
    {
        "nl_input": "The query requires a function that enables purchasing tokens, either by accepting payments in another token or directly with Ether. The function should handle token minting, rate calculation, and transfer of funds, while ensuring compliance with sale conditions like minimum contribution and hard cap limits. It may also include beneficiary designation and optional features like gifting tokens. The function should be public and payable if dealing with Ether transactions.",
        "url": 241
    },
    {
        "nl_input": "The query requires a function that allows the contract owner to redirect a standard signature to one of several predefined functions. The function should validate that the target signature matches one of the allowed signatures before updating the mapping. The solution must include an `onlyOwner` modifier to restrict access and return a boolean indicating success. The allowed signatures are hardcoded and must be checked within the function.",
        "url": 242
    },
    {
        "nl_input": "The query requires a function that retrieves the price of TOC (Token of Choice) from a smart contract. The function should be named `GetTocPrice` or similar, be publicly callable, and return the price as a `uint256` value. The price should be fetched from a market or contract storage variable named `TocPrice` or similar. The function should not modify the contract state (use `view` or `constant`).",
        "url": 243
    },
    {
        "nl_input": "The query requires a function to cancel a specific order on a blackmarket for selling a certain quantity of an item (coke) at a specified price. The function should verify the seller's ownership, match the quantity and price, remove the order, and emit a cancellation event. It should return success status and the number of orders canceled, with an option to continue searching for matches after the first cancellation.",
        "url": 244
    },
    {
        "nl_input": "The query requires extracting the total lottery amount from a smart contract. The suitable code is from 'url 245', which provides a function `getLotteryBalance()` that returns the contract's balance, representing the total lottery amount. The other codes handle payout calculations and fee removals but do not directly provide the total lottery amount. The requirement is met by querying the contract's balance.",
        "url": 245
    },
    {
        "nl_input": "The query requires functions related to game management in smart contracts, including retrieving the total number of games, fetching game details by index, and forfeiting a game with specific conditions and state updates. The functions should handle game states, player interactions, and value transfers.",
        "url": 246
    },
    {
        "nl_input": "The query requires checking if a contract's relationship or conditions are properly validated. The relevant code should involve functions that verify conditions such as gift validity, required changes, or signed terms, returning boolean results to confirm the checks. The focus is on ensuring the contract's logic correctly assesses and returns the status of these relationships or conditions.",
        "url": 247
    },
    {
        "nl_input": "The query requires a helper function to display the amount of ETH a user has already contributed. The suitable code is the first one, which includes a function `userAlreadyBoughtEth` that returns the contribution amount for a given user address from a `contributions` mapping. This meets the need for a simple view function to check user contributions.",
        "url": 248
    },
    {
        "nl_input": "The query requires extracting an address encoded as the first argument in transaction data. The suitable code should decode or retrieve an address from transaction data, ensuring it meets the expected format (e.g., 20 bytes for Ethereum addresses). The focus is on address extraction or validation from input data.",
        "url": 249
    },
    {
        "nl_input": "The query requires determining if a given day index corresponds to a holiday by checking its value against predefined ranges or conditions in a smart contract. The suitable code should include a function that takes a day index as input and returns whether it falls within specified holiday periods or meets certain criteria to be classified as a holiday. The first code snippet is the most relevant as it directly checks day indices against holiday lists.",
        "url": 250
    },
    {
        "nl_input": "The query requires checking if an address has already invested by verifying its presence in a list of investors or a mapping of allowed investors. The solution involves either iterating through an array of investors or checking a boolean value in a mapping that indicates investment status. The address is considered invested if found in the array or if the corresponding mapping value is true.",
        "url": 251
    },
    {
        "nl_input": "The query requires extracting information about determining or transitioning between stages in a smart contract, specifically focusing on functions that check or update the current stage based on conditions like time, block number, or contribution caps. The relevant code snippets involve stage checks, transitions, and conditional logic for stage progression.",
        "url": 252
    },
    {
        "nl_input": "The query requires a smart contract function that prevents authorized wallets from withdrawing funds to a specific address, ensuring only the owner or admin can execute withdrawals with proper checks on balance and permissions. The function should include modifiers like `onlyOwner` or `onlyAdmin` and validate the withdrawal amount against the contract's balance.",
        "url": 253
    },
    {
        "nl_input": "The query requires displaying the timelock periods and the corresponding locked values from smart contracts. The relevant code should return arrays of lock times and handle calculations involving locked periods, such as adding or subtracting time intervals, and possibly checking current round locks or setting lockout periods. The focus is on retrieving and managing time-based locking mechanisms in blockchain transactions.",
        "url": 254
    },
    {
        "nl_input": "The query requires a function that allows the registry owner to withdraw surplus value (ether or tokens) from the contract. The function should be restricted to the owner/admin and should transfer the specified amount or the entire balance to the owner's address. Examples include withdrawing ZRX tokens or ether, with checks for non-zero balance and reentrancy protection. The function must ensure secure and authorized transfers.",
        "url": 255
    },
    {
        "nl_input": "The query requires setting up a whitelist functionality in a smart contract, including adding addresses to the whitelist, configuring the whitelist contract, and disabling the whitelist when needed. The operations should be restricted to the contract owner and applicable during specific stages like deployment or crowdsale.",
        "url": 256
    },
    {
        "nl_input": "The query requires a function to transfer ownership of a contract to a new Ethereum address, ensuring the new address is valid (non-zero). The function should be restricted to the current owner and may include an event to log the ownership transfer. The solution involves updating the owner variable and optionally emitting an event for transparency.",
        "url": 257
    },
    {
        "nl_input": "The query requires a function that allows the current collector or owner to transfer control of the contract to a new address (newCollector or newOwner). The function should include checks to ensure the new address is valid (non-zero) and emit an event if the transfer is successful. The transfer should be restricted to the current owner or collector, typically enforced by an `onlyOwner` modifier.",
        "url": 258
    },
    {
        "nl_input": "The query requires a function that caps a reward amount by selecting the minimum value among the reward, contract balance, and remaining daily limit. The function should adjust the reward to not exceed either the available balance or the daily limit, ensuring the payout is within feasible limits. This is demonstrated in the first code snippet where the reward is capped based on balance and daily remaining limit.",
        "url": 259
    },
    {
        "nl_input": "The query requires a description of how to transfer superOwner authority in a smart contract. The suitable code shows a function `transferSuperOwnership` that allows the current superOwner to transfer their authority to a new address, emitting an event to log the transfer. The function is restricted by the `onlyhiddenOwner` modifier, ensuring only authorized entities can execute it. The new superOwner address is updated upon successful execution.",
        "url": 260
    },
    {
        "nl_input": "The query requires a function that enables users to purchase a Dragon Ball Z hero by specifying the hero's ID and paying the current price. The function should transfer fees to the developer and the current owner, update the hero's ownership, and double the hero's price for the next purchase. The code should ensure the contract is not paused during the transaction.",
        "url": 261
    },
    {
        "nl_input": "The query requires a function that returns the total number of bronze caps produced so far. The suitable code should include a function named `producedBronzeCaps` or similar, which returns a `uint64` value representing the count of bronze caps. The function should be publicly accessible and view-only, without modifying the contract state. The expected output is a numerical value indicating the current production count of bronze caps.",
        "url": 262
    },
    {
        "nl_input": "The query seeks a function that updates both the balances map and the totalSupplyHistory. The required function should modify these two variables, typically within a contract, to reflect changes in token balances and total supply. The function may involve operations like minting or transferring tokens, ensuring the balances and total supply are accurately recorded and updated. The focus is on maintaining consistency between these two data structures during token-related transactions.",
        "url": 263
    },
    {
        "nl_input": "The query requires identifying code snippets that check if a set or funding process has been successfully completed. The relevant code should include conditions or functions that verify completion status, such as checking finalization flags, successful tranches, or specific completion conditions. The description should focus on the logic that confirms successful completion without detailing each code's internal workings.",
        "url": 264
    },
    {
        "nl_input": "The query requires a setter function for `timePerPeriod` that allows updating the time duration for a specific period. The function should be restricted to authorized roles (e.g., `onlyGovernor` or `onlyOwner`) and may include validation checks. The time can be set as an array of periods or a single duration in seconds/days. Example implementations include updating a `uint[5]` array or a `uint256` value with constraints like minimum/maximum limits.",
        "url": 265
    },
    {
        "nl_input": "The query requires a mechanism where the owner can authorize a specific address (like a crowdsale contract) to transfer tokens even during the lock-up period. This involves overriding standard transfer restrictions to allow privileged transfers by the owner or designated contracts. The solution should include functions that check ownership and conditions before permitting such transfers.",
        "url": 266
    },
    {
        "nl_input": "The query requires a function that handles the scenario where a player (player 1) concedes defeat without revealing their move, updating the game state to reflect the loss and transferring any stakes or rewards accordingly. The solution should include checks for the player's identity, update game status, and manage financial transactions if applicable.",
        "url": 267
    },
    {
        "nl_input": "The query requires a function to clean up a game by setting it to inactive, refunding player balances, and handling housekeeping tasks. The function should iterate through players, refund any positive balances, update game status, and log relevant events based on the termination reason (cancel, timeout, or abort). The refund process should handle failed transfers by accumulating unrefunded amounts. The game's active status must be set to false upon completion.",
        "url": 268
    },
    {
        "nl_input": "The query requires a function that allows the contract owner to modify the bonus amount during different phases of an ICO (Initial Coin Offering). The function should check the current phase (Pre-ICO or Main ICO), validate the new bonus value, update the bonus, and emit an event for the change. Reverts should occur if the new bonus matches the current one or if conditions are not met.",
        "url": 269
    },
    {
        "nl_input": "The query requires adding a new animal type to a game with a specified cost, ensuring only the owner can perform this action. The cost is stored in an array, and a fee is calculated and stored in another array. The operation must include a check for the owner's authority to prevent unauthorized additions. The description focuses on the functionality and security aspects of adding a new animal type in a game context.",
        "url": 270
    },
    {
        "nl_input": "The query requires a modifier that restricts function execution to when the contract is not paused. The modifier should include a condition to check the paused state and revert if the contract is paused. The provided examples show similar modifiers or functions that interact with pause states, but the exact modifier `whenNotPaused` is needed to enforce the requirement. The description should be concise, focusing on the pause state check.",
        "url": 271
    },
    {
        "nl_input": "The query requires a method to directly mint tokens to a HTLC (Hashed Timelock Contract) by specifying the recipient address and the token amount. The minting function should include checks for valid addresses, update the token supply and balances, and emit transfer events to reflect the token creation and allocation. The function should be restricted to authorized entities, typically the contract owner, to ensure secure token issuance.",
        "url": 272
    },
    {
        "nl_input": "The query requires a function to change a wallet address in a smart contract, restricted to the owner, with optional validation to ensure the new address is not zero. The function can be named `changeWallet` or similar, and should update the wallet variable (`wallet` or `tokenWallet`). Example implementations include basic assignment or adding a require statement for non-zero addresses.",
        "url": 273
    },
    {
        "nl_input": "The query requires a function that retrieves the namespace for a given address in a service locator. The function should check if the namespace is valid (based on TTL and update time) and return the namespace if valid, or an empty string if not. The provided code snippet from 'url': 274 meets this requirement by accessing the namespace storage, verifying its validity, and returning the appropriate result.",
        "url": 274
    },
    {
        "nl_input": "The query requires a smart contract function that creates a new token and transfers it to a specified recipient without any cost. The function should include checks to ensure the recipient address is valid and not the contract itself, and it should track the total number of tokens created to prevent exceeding a supply limit. The token transfer should be executed securely and update the token count accordingly.",
        "url": 275
    },
    {
        "nl_input": "The query requires a Solidity modifier named `onlyOwner` that restricts function access to the contract owner by checking if `msg.sender` matches the `owner` address. The modifier should include a `require` statement for validation and a `_;` to proceed if the condition is met. Optionally, it may include an error message like \"Not a owner\" for failed checks. The modifier can be defined with or without parentheses.",
        "url": 276
    },
    {
        "nl_input": "The query requires ensuring that ETH cannot be locked in a contract. The relevant code snippets include a modifier to prevent locking (`notLocked`), a function to withdraw ETH (`withdrawEther`), and a function to set ETH price (`setEthPrice`). The key requirement is to allow ETH withdrawal and prevent any locking mechanism, ensuring funds remain accessible.",
        "url": 277
    },
    {
        "nl_input": "The query requires a function that efficiently calls `claimAllForInvestor` with `msg.sender` as the parameter, likely to claim tokens or rewards for the sender. The function should be simple and directly invoke the claim mechanism for the investor address. The expected code should resemble a one-line call to `claimAllForInvestor(msg.sender)` within a function.",
        "url": 278
    },
    {
        "nl_input": "The query requires a function that returns the price of a specific team, identified by a team ID. The function should take the team ID as input and return the corresponding price as a uint256 value. The first code snippet matches this requirement exactly with its `getTeamPrice` function, which retrieves the current price of a team based on the provided `_teamId`. The other code snippets do not address team-specific pricing.",
        "url": 279
    },
    {
        "nl_input": "The query requires a function to update or set the next steal time or a related time parameter in a smart contract. The function should allow modifying a timestamp or time window, either by adding seconds to the current time or setting a specific duration. The solution should be internal or restricted (e.g., only owner) to ensure secure time updates. The expected output is a code snippet that adjusts the next steal time or similar time-based parameter.",
        "url": 280
    },
    {
        "nl_input": "The query requires extracting the registration date of a holder from a smart contract. The suitable code should include a function that takes an address as input and returns the registration time or date associated with that address, typically stored in a mapping or struct. The function should be constant (read-only) and return a numeric value representing the registration timestamp or block number.",
        "url": 281
    },
    {
        "nl_input": "The query requires a function that updates the reward rate for a specific token address, ensuring the new rate is positive and the token address is valid. The function should locate the token in a list of reward sources and update its reward rate accordingly. The operation should be restricted to the contract owner. The expected code should include checks for valid inputs and a mechanism to find and modify the correct reward source.",
        "url": 282
    },
    {
        "nl_input": "The query requires a description of code functionalities related to owner creation or activation in smart contracts. The provided code snippets demonstrate functions for transferring ownership to a new address, activating an owner, and ensuring the new owner's address is valid (non-zero). These functions include checks for existing ownership status and emit events or update mappings accordingly. The main goal is to securely manage ownership changes while preventing invalid or zero addresses.",
        "url": 283
    },
    {
        "nl_input": "The query requires creating a new round in a smart contract by setting a hashed salt and proof of N (saltNHash). The function should be payable, allow ownership transfer, and emit an event upon creation. It should handle both zero and non-zero value transfers, and revert if round creation fails. The code must include checks for valid ownership and successful round initialization.",
        "url": 284
    },
    {
        "nl_input": "The query requires identifying code that sets or calculates a soft or maximum cap value in a smart contract, specifically involving ether or similar cryptocurrency units. The relevant code should include functions that handle cap-related operations, such as setting a soft cap, computing a cap, or converting cap values between different units (e.g., ether to wei). The focus is on cap management within blockchain transactions.",
        "url": 285
    },
    {
        "nl_input": "The query requires a function that withdraws tokens (excluding DGZ) to a specified address (beneficiary). The function should ensure the token being withdrawn is not the DGZ token and should transfer the specified amount to the beneficiary. The solution should include a check to prevent DGZ withdrawals and log the transaction details.",
        "url": 286
    },
    {
        "nl_input": "The query requires a function that prevents a block from being sold by setting its sale status to inactive or zero. The function should verify the caller's ownership or authorization before modifying the sale status. The expected code should include checks for ownership or privileges and update the block's sale status accordingly.",
        "url": 287
    },
    {
        "nl_input": "The query requires a function that allows the message sender (msg.sender) to claim the tokens owed to them, typically involving transferring allocated tokens to their address and resetting any related allocation records. The function should be accessible by the sender and handle token calculations and transfers securely.",
        "url": 288
    },
    {
        "nl_input": "The query requires retrieving all relevant information about a specific GameItem, including its ID, name, selling price, owner, and associated game ID. The information should be returned in a structured format with these specific fields. The first code snippet (url 289) matches this requirement by providing a function that fetches these details from a GameItem struct using a token ID. The other code snippets do not address this need.",
        "url": 289
    },
    {
        "nl_input": "The query requires a smart contract function that allows users to claim segments (blocks) every 1000 UNITS, ensuring checks for eligibility, calculating entitled segments, and updating balances accordingly. The function should handle user contributions, verify withdrawal states, and execute transfers securely. The focus is on periodic claims with specific unit intervals and proper state management.",
        "url": 290
    },
    {
        "nl_input": "The query requires identifying code snippets that handle token transactions, including minting new tokens, transferring tokens between addresses, and claiming allocated tokens based on predefined conditions. The focus is on functions that manage token distribution, ensure valid recipient addresses, and update token balances accordingly. The relevant operations involve internal minting, external transfers with balance checks, and conditional token claims from allocations.",
        "url": 291
    },
    {
        "nl_input": "The query requires a description of code functionalities that facilitate the sale of presale tokens, including claiming allocated tokens, purchasing tokens during the presale, and handling token sales with dynamic pricing based on the number of tokens sold. The code should manage token transfers, track sales, and enforce sale conditions like timing and purchase limits.",
        "url": 292
    },
    {
        "nl_input": "The query requires code that prevents specific targets (addresses) from sending or receiving tokens. This involves functions to block token transactions to/from certain addresses, such as disabling receivers or removing token permissions. The solution should include checks to ensure valid addresses and enforce ownership or authorization for these restrictions.",
        "url": 293
    },
    {
        "nl_input": "The query requires a function to remove an address from a list or pool, ensuring the address exists in the list, updating the list by replacing the target address with the last element, and reducing the list length by one. The function should include checks for valid addresses and proper permissions (e.g., onlyOwner or similar modifiers). The removal should maintain list integrity and may include logging or event emission.",
        "url": 294
    },
    {
        "nl_input": "The query requires identifying the end date of a customer's term deposit. The suitable code is a function that takes a customer's address as input and returns the term deposit's end date in a numeric format (uint256). The function should be constant (read-only) and specifically query the deposit end date for the given address.",
        "url": 295
    },
    {
        "nl_input": "The query requires a function to add a CZR token lock for a specified address, including parameters for lock start time, amount, and duration in months. The function should be restricted to the contract owner, validate the amount is positive, set a default start time if not provided, store the lock details in a mapping, and emit an event. The lock should prevent transfers during the locked period.",
        "url": 296
    },
    {
        "nl_input": "The query requires identifying code snippets that handle the transfer of authority or ownership in a data layer or similar context. The suitable code should include functions that transfer control, such as data authority, super ownership, or domain ownership, typically restricted to the current owner or a privileged role. The functions should specify the new owner's address and execute the transfer through a defined method or event.",
        "url": 297
    },
    {
        "nl_input": "The query requires a function that resolves a challenge for a given `_propID` by checking if the challenge is passed, updating the proposal status, transferring rewards to the winner (either the owner or challenger), and emitting relevant events. The function should handle both successful and failed challenges, ensuring rewards are distributed correctly and the challenge is marked as resolved.",
        "url": 298
    },
    {
        "nl_input": "The query requires a function that reduces the approved token amount for a specified spender address. The function should check if the reduction value exceeds the current allowance and set it to zero if true, otherwise subtract the value. It must emit an approval event and return a success status. The solution should handle token allowance adjustments securely and efficiently.",
        "url": 299
    },
    {
        "nl_input": "The query requires a function to whitelist multiple addresses by setting their status to true in a mapping. The function should accept an array of addresses and iterate through them to update the whitelist. It should be restricted to specific callers (e.g., owner or whitelister) and may include checks for active conditions like crowdsale status. The expected output is a contract function that performs these operations.",
        "url": 300
    },
    {
        "nl_input": "The query requires identifying a function that is exclusively called from `shiftsale` and involves a purchase operation with specific modifiers like `isOpen`, `afterStart`, `hardCapNotReached`, and `aboveMinValue`, which ensures the function is only executable under certain conditions. The function should also be payable and return a boolean success status. The other provided codes with `onlyESOP` and `onlyExchange` modifiers are irrelevant to this requirement.",
        "url": 301
    },
    {
        "nl_input": "The query requires extending OpenZeppelin's `transferFrom` function to include snapshot functionality by calling `takeSnapshot` for both sender and recipient addresses before executing the standard token transfer. The solution should integrate snapshot storage seamlessly with the existing transfer logic.",
        "url": 302
    },
    {
        "nl_input": "The query requires checking the amount of tokens delegated by an owner to a spender. The relevant code should include a function that verifies or retrieves the token balance or allowance from the owner to the spender, typically using a mapping or a require statement to ensure the delegated amount is sufficient or valid. The focus is on transferring or spending tokens but specifically on the delegation check between owner and spender.",
        "url": 303
    },
    {
        "nl_input": "The query requires a function that adds intervals to a data structure, specifically a tree, where each interval has a start (`begin`), end (`end`), and associated data (`data`). The function should handle tree traversal, node creation if necessary, and interval insertion based on the interval's position relative to existing nodes. The solution should manage intervals that overlap or are adjacent to existing intervals in the tree structure.",
        "url": 304
    },
    {
        "nl_input": "The query requires code that enables token withdrawal only after the crowdsale is closed and finalized. The correct code checks both `hasClosed()` and `isFinalized` states before transferring tokens, ensuring withdrawals occur post-crowdsale completion and finalization.",
        "url": 305
    },
    {
        "nl_input": "The query requires a function that returns the token balance of a specified owner address from a smart contract. The function should be named `balanceOf`, accept an `address` parameter (named `_owner` or `tokenOwner`), and return a `uint256` or `uint` value representing the balance. The function visibility should be `public` and can include modifiers like `view` or `constant`. The balance is typically stored in a mapping (e.g., `balances` or `ownershipTokenCount`).",
        "url": 306
    },
    {
        "nl_input": "The query requires a function to update the token address in a smart contract, restricted to the owner or founder, with optional checks for valid addresses or initial setup conditions. The function should assign the new address to a token variable or wallet. Examples include updating via `Token(_tokenAddress)`, `newAddress`, or `ANOToken(_tokenAddress)` with possible state checks like `isTokenSet`.",
        "url": 307
    },
    {
        "nl_input": "The query requires updating a board's status to indicate a losing color, specifically setting it to the opposing color's win status (e.g., Black loss updates to WhiteWin, White loss updates to BlackWin). The solution must handle the color input and revert for invalid cases. The first code snippet directly addresses this by checking the losing color and updating the board status accordingly, making it the most relevant.",
        "url": 308
    },
    {
        "nl_input": "The query requires a function or condition to check if an event has ended. The suitable code should return `true` when the event's end time has passed (`now > endTime`), there are no tokens left (`tokensLeft <= 0`), or the event is finalized (`isFinalized`). The description should focus on these logical checks to determine the event's end status.",
        "url": 309
    },
    {
        "nl_input": "The query requires checking if a burner address is eligible to perform burn operations. The relevant code includes a modifier `isBurner` that checks if the address is in the `allowedBurners` list and a modifier `onlyBurnAddress` that verifies if the sender is the designated `burnAddress`. The `burnToken` function includes checks for burn conditions but does not directly address burner eligibility. The focus is on validating burner permissions through modifiers. (80 words)",
        "url": 310
    },
    {
        "nl_input": "The query requires information about handling `msg.value` in multisignature (multisig) contracts. Specifically, it seeks code examples where `msg.value` is used in functions related to multisig operations, such as depositing funds, reparametrizing multisig parameters, or sending transactions from a multisig wallet. The focus is on how the value sent with the transaction is processed or utilized within these multisig functions.",
        "url": 311
    },
    {
        "nl_input": "The query requires a smart contract function that removes or recycles rotten potatoes (likely representing expired or invalid tokens) from a user's storage, updating the user's records and transferring the removed items to a trash or disposal mechanism. The function should check the elapsed time since last recycling and calculate the amount to remove based on decay rate.",
        "url": 312
    },
    {
        "nl_input": "The query seeks the renewal interval of a product in seconds, likely requiring a function that returns the interval duration for a specified product ID. The relevant code should directly provide or calculate the interval value associated with a product, preferably in seconds. The description should focus on extracting or computing this interval from a product-related data structure or configuration.",
        "url": 313
    },
    {
        "nl_input": "The query requires a function that allows a wallet to withdraw any owed value recorded under `addressToFailedOldOwnerTransferAmount`. The function should check for a positive balance, reset the balance to zero, deduct the amount from the total failed transfers, and transfer the amount to the sender. Only the first code snippet meets these specific requirements. The other snippets are for different withdrawal scenarios. The description fits within 80 words.",
        "url": 314
    },
    {
        "nl_input": "The query requires a function that multiplies the bet amount by a specified percentage and divides by 100 to compute winnings, as shown in code 315. The other codes handle bet validation, payout limits, or odds calculation unrelated to direct percentage-based profit determination.",
        "url": 315
    },
    {
        "nl_input": "The query requires a function allowing the Owner or existing Admin to update the admin address, ensuring the new address is not the owner, contract itself, or an existing operator. The function must validate inputs, update the admin address, emit an event upon change, and return a success status.",
        "url": 316
    },
    {
        "nl_input": "The query requires a function to generate a leaderboard hash by combining a **name** (bytes32) and **admin address** via `keccak256(abi.encodePacked(name, admin))`, returning the computed bytes32 hash. The code must exclude logic for checking leaderboard presence (e.g., boolean returns) and focus solely on hash creation.",
        "url": 317
    },
    {
        "nl_input": "The query requires identifying setter methods that can only modify state variables when the contract is in an unlocked state. This is enforced through modifiers like `notLocked` which check `!locked`, ensuring state changes are permitted exclusively during unlocked conditions while restricting access via ownership controls.",
        "url": 318
    },
    {
        "nl_input": "The query requires a function to add content details (name, description, reward) to an agreement with access control (onlyBrand), reward validation, and contract state checks (notLocked), returning a success status. The code must include parameters for content metadata, enforce permission/validation modifiers, and interact with a storage mechanism (e.g., `content.put`).",
        "url": 319
    },
    {
        "nl_input": "The query requires a function to update the rate for a specific round by inputting the round number and new rate, validated by checking the round's existence. The code must modify the rate parameter of the designated round in a rounds array, restricted to authorized access (e.g., owner). Time-based or balance-triggered rate adjustments without round-specific parameters are irrelevant.",
        "url": 320
    },
    {
        "nl_input": "The query requires a function that marks an item by associating `productAccount` with a SHA3 hash of `itemPublicKey`, ensuring valid permissions, active product/brand/app statuses, and transferring fees. The code must validate ownership, check active states, enforce sender permissions, record the item hash, emit an event, and handle token transfers for both app and platform fees if applicable.",
        "url": 321
    },
    {
        "nl_input": "The query requires code that ends an auction and transfers the highest bid amount to the contract owner. This involves updating the auction state to \"Ended,\" emitting an event to log the highest bidder and bid value, and executing the fund transfer to the owner using **owner.transfer(highestBid)**.",
        "url": 322
    },
    {
        "nl_input": "The query requires a function to retrieve an owner's address by a 0-indexed position, accessing an array where owners are stored starting at index 1. The correct code returns `m_owners[ownerIndex + 1]`, adjusting the input index to match the internal 1-based storage.",
        "url": 323
    },
    {
        "nl_input": "The query requires code that sets an initial date for a token-related event (e.g., sale start) and assigns a token address, ensuring the token has no prior distribution and correct ownership. It must enforce stage-specific execution (setup phase) and validate parameters like non-zero addresses and valid timelock dates.",
        "url": 324
    },
    {
        "nl_input": "The query requires retrieving the stored ticket price value from the smart contract. The relevant code is a function `getTicketPrice()` that directly returns the `ticketPrice` variable, which is set during bet initialization via `initBet()`. The third code calculates unrelated bet states and is irrelevant. The needed information is obtained by calling the view function returning the predefined `ticketPrice`.",
        "url": 325
    },
    {
        "nl_input": "The query requires a function that executes when tokens are purchased in a token sale, enforcing conditions like sale timeframe, token availability (supply limits), valid purchase quantity (1-10 tokens), dynamic pricing tiers based on tokens sold, sufficient payment, balance updates, token transfers, and event logging. It must handle refunds for excess payment and track cumulative sales metrics (tokens sold, funds raised).",
        "url": 326
    },
    {
        "nl_input": "The query requires enabling token transfers, burning any unsold tokens, and setting the tokenOfferingAddress to zero. This involves modifying contract state variables to activate transfers, executing a burn function to eliminate unsold supply, and resetting the offering address to a null value.",
        "url": 327
    },
    {
        "nl_input": "The query requires a PlaceBet function that validates bet amounts against minimum/maximum limits, tracks block usage, checks if the sender has already played to adjust odds, generates a random number for win determination, and transfers winnings. The code uses parameters like msg.value, block.number, and sender history as implicit \"mode\" factors influencing bet outcomes.",
        "url": 328
    },
    {
        "nl_input": "The query requires determining if a transcoder is registered by checking its presence in a transcoder pool, returning a status of \"Registered\" if present and \"NotRegistered\" otherwise. The code checks membership in the pool and maps the result to the corresponding enum value, focusing on binary status identification without additional validation or state modification.",
        "url": 329
    },
    {
        "nl_input": "The query requires a function to fill a buy order with a sell order by calculating fill amounts, deducting fees, and executing trades via exchange-specific logic (e.g., EtherDelta or Zrx), ensuring token/ether transfers and balance updates while handling exchange fees and validation checks.",
        "url": 330
    },
    {
        "nl_input": "The query requires enabling the transfer of Reporter tokens by any user once trading has commenced. This involves a function that allows token transfers between addresses after trading starts, ensuring balances are updated correctly and transfer events are emitted. The solution should include checks for trading status and handle token allocations if applicable.",
        "url": 331
    },
    {
        "nl_input": "The query requires checking the available token allocation for a specified address based on predefined time steps (step1, step2, step3), summing eligible allocations from each unlocked step, and returning the total. The availability is determined by comparing the current time (`now`) with each step's timestamp.",
        "url": 332
    },
    {
        "nl_input": "The query requires a function to transfer and lock values exclusively accessible by admins, ensuring the `setLock` mechanism is restricted. The code must include admin-controlled access (e.g., `onlyOwner` modifier) on `transferAndLock` to enforce permission checks before executing transfers and locking operations, preventing unauthorized calls.",
        "url": 333
    },
    {
        "nl_input": "The query requires a Solidity function that transfers Ether to a specified beneficiary address, typically using `transfer()` with access control (e.g., `onlyOwner`), handling either the full contract balance or a specified amount, and ensuring balance checks (e.g., `require`). The beneficiary address may be predefined or passed as a parameter.",
        "url": 334
    },
    {
        "nl_input": "The query requires retrieving the address of a library's founder associated with a specific token ID by accessing the `libraryIndexToFounder` mapping, ensuring the returned address is non-zero.",
        "url": 335
    },
    {
        "nl_input": "The code must include a function enabling users to delete their own accounts by verifying their address, removing associated data (e.g., addressDirectory, userDirectory entries), and emitting a deletion event (e.g., UserDeleted). The function should validate user existence and restrict execution to the account owner via msg.sender.",
        "url": 336
    },
    {
        "nl_input": "The query requires enabling buyers to claim their purchased tokens post-purchase, typically by transferring allocated tokens from a reserved pool to their address, resetting their allocation balance, and emitting relevant events. The code should include a function (e.g., `claimTokens`) that checks the stage (e.g., trading phase), calculates the claimable amount, updates balances, and executes the transfer.",
        "url": 337
    },
    {
        "nl_input": "The query requires transferring tokens from the message sender (caller) to a specified recipient address, ensuring the transferred amount is within the sender's balance and meets a minimum threshold. The transfer must be validated through an internal function, update ledger balances, and return a success status. The process should be restricted to token holders without requiring third-party approvals or owner privileges.",
        "url": 338
    },
    {
        "nl_input": "The query requires verifying that a sale is both active (configured) and not yet concluded. This involves checking a sale's active status flag (e.g., `isSaleActive`) and ensuring the current time is within the sale's duration (e.g., via timestamp comparisons like `preSaleEnd >= now` or functions confirming the sale has not ended).",
        "url": 339
    },
    {
        "nl_input": "The total Ether required includes the purchase amount plus applicable fees. The fee is calculated as a portion of the Ether sent, deducted before processing the transaction must ensure the contract balance covers both the purchase and fee. If insufficient, the remaining Ether needed is adjusted by subtracting the contract's available balance and fee from the original amount.",
        "url": 340
    },
    {
        "nl_input": "The query requires determining the current ICO stage's bonus based on time conditions. If the ICO is in the main stage, the bonus decreases by 10% increments if the timestamp exceeds predefined stages, stopping at 0. For earlier stages (pre-ICO), fixed bonuses apply based on preset start times. The calculation uses the current timestamp to check against stage thresholds and adjusts the bonus accordingly, returning 0 if the main stage's final threshold is passed.",
        "url": 341
    },
    {
        "nl_input": "The query requires a function to finalize the crowdsale, permanently halt token minting, and enforce conditions like ownership control, state checks (e.g., crowdsale not already finalized), and automatic fund processing. It should update relevant states (e.g., `isFinalised`, `isMintingFinished`), trigger events (e.g., `MintingFinished`), and handle post-finalization logic (e.g., fund forwarding, refunds).",
        "url": 342
    },
    {
        "nl_input": "The query requires a function enabling users to claim an airdrop by verifying eligibility (stage, participation status, time constraints), issuing tokens, updating participation records, and limiting total participants. It must ensure users claim only during the airdrop period, prevent duplicate claims, and increment the participant count upon successful execution.",
        "url": 343
    },
    {
        "nl_input": "The query requires retrieving the balance of ELHT tokens held by a contract using the `balanceOf(this)` method from ERC20 interfaces, supporting token transfers with a maximum of 64 tokens. It involves checking the contract's token balance, handling ETH or ERC20 tokens, and transferring tokens to specified addresses while adhering to the token limit constraint.",
        "url": 344
    },
    {
        "nl_input": "The query requires a contract where the owner authorizes redemptions in increments of 0.001 ETH (1/1000 ETH), ensuring balance sufficiency, tracking authorized amounts per address, and enabling ETH transfers or token transfers based on redemption conditions, with owner-restricted access and unit management.",
        "url": 345
    },
    {
        "nl_input": "The query requires a smart contract function enabling the owner to transfer Ether (either partial or full balance) to a specified address (e.g., updated contract, owner, or predefined wallet), restricted by **onlyOwner** modifier, with balance validation (e.g., `require` check or failure handling). The function should use **transfer** or **send** for Ether movement.",
        "url": 346
    },
    {
        "nl_input": "The query requires ensuring that the `_oracleContract` address adheres to the `OracleInterface`, typically by assigning it to a variable of that interface type (e.g., `OracleInterface oracle = OracleInterface(_oracleContract);`) to enforce implementation of the interface's methods.",
        "url": 347
    },
    {
        "nl_input": "The query requires code that creates a trade offer using msg.value, ensuring the value is non-zero, includes parameters for offer settings or token details, and may involve fee calculations. The code must handle offer creation with checks on msg.value validity and relevant input validations.",
        "url": 348
    },
    {
        "nl_input": "The query requires a function named `balanceOfOnForHolder` that retrieves the token balance of a specific holder (address) when a conditional state (`balanceOfOn`) is active, combining balance checks with an on/off toggle mechanism.",
        "url": 349
    },
    {
        "nl_input": "The query requires a function that calculates the fundraiser's USD result by converting the contract's Ether balance using a specified exchange rate, returning the equivalent value after applying the rate and scaling adjustments.",
        "url": 350
    },
    {
        "nl_input": "The query requires tracking reductions in a token pool's balance when rewards are distributed. Relevant code subtracts the reward amount from the pool's total (e.g., `pools[_manufacturer].balance = pools[_manufacturer].balance.sub(_amount)`) and updates recipient balances, ensuring outgoing rewards are deducted from the pool and reflected in recipient allocations.",
        "url": 351
    },
    {
        "nl_input": "The query seeks code that handles deducting and distributing service/affiliate fees during a purchase transaction, ensuring balance checks, fee calculation via a fee wallet, and transferring the fee to an affiliate address while returning the remaining ethers after deduction.",
        "url": 352
    },
    {
        "nl_input": "The query requires identifying an internal function that checks if transferring a specific token is allowed, considering sender, receiver, and token ID. The function should return a boolean indicating transfer permission, possibly involving external logic contracts or specific conditions like vesting dates or exceptions. The focus is on validation before transfer, not the transfer execution itself.",
        "url": 353
    },
    {
        "nl_input": "The query requires overriding the `transferFrom` function in a MintableToken to enforce KYC checks, ensuring transfers from an address are only permitted if KYC is completed (e.g., `require(!kycRequired[_from])`), then invoking the parent contract's `transferFrom` logic.",
        "url": 354
    },
    {
        "nl_input": "The query requires changing the address associated with a specified role in a smart contract. The operation should involve verifying the caller's authorization, updating the role's address, and emitting an event if the change is successful. The new address must be valid and distinct from existing addresses, especially critical roles like owner or admin. The function should handle role-specific permissions and ensure proper role assignment and removal.",
        "url": 355
    },
    {
        "nl_input": "The query requires a function to withdraw ZRX tokens, restricted to an admin role, ensuring secure transfer from the contract's address. The code must include access control (e.g., `onlyAdmin`), reference the ZRX token address, and handle balance transfers. It should enforce checks (e.g., contract state, successful transactions) to validate withdrawal conditions, particularly when triggered by a new contract version deployment.",
        "url": 356
    },
    {
        "nl_input": "The query requires enabling token transfers only after minting is completed, enforced by a modifier that checks a `mintingFinished` flag. This flag is set via a dedicated `finishMinting` function, which locks minting and triggers the transfer allowance. The modifier restricts transfers until the minting phase is explicitly.",
        "url": 357
    },
    {
        "nl_input": "The required function must check that the softcap (tokenGenerationMin) is unmet and sale period (block.number > end_block) has ended before allowing refunds. It should verify investor's contribution, reset their balances, transfer refunded ETH, and emit relevant events. Conditions include sale not being completed and ensuring only eligible contributors can trigger the refund.",
        "url": 358
    },
    {
        "nl_input": "The query requires a function or modifier that checks if a contribution period is currently active. The conditions include: the hard cap not being reached, the period being enabled, the current time being within the start and end times. The best match is the first code snippet, which returns `true` if all these conditions are met. The other options do not fully address the time-based and status checks needed for an active contribution period.",
        "url": 359
    },
    {
        "nl_input": "The query requires an internal function that updates ICO status to \"Waiting\" or \"Closed\" when tokens in specific stages (PrivateICO, PreICO, ICO_w1, ICO_w2) are depleted, based on token balances and current phase. It must automatically transition statuses when token availability reaches zero in the active stage, finalizing with \"Closed\" if all ICO tokens are exhausted.",
        "url": 360
    },
    {
        "nl_input": "The query requires a smart contract function allowing the contract owner to whitelist addresses authorized to burn tokens. This is achieved by implementing an **`addWhitelistedBurn`** function with **`onlyOwner`** modifier, updating a mapping (e.g., `whitelistedBurn[_address] = true`) to grant burn permissions to specified addresses.",
        "url": 361
    },
    {
        "nl_input": "The query requires enabling a designated wallet to assume account ownership through a function that verifies block number constraints, transfers ownership to the pending owner, resets the pending owner address, and sets the end block to zero. This involves checks on valid block ranges and updating ownership state variables securely.",
        "url": 362
    },
    {
        "nl_input": "The query requires a smart contract function enabling users to purchase collectibles by sending Ether, with checks for valid payment amount and unfrozen accounts, executing token transfers based on current pricing.",
        "url": 363
    },
    {
        "nl_input": "The query requires retrieving the final bid amount from ended auctions, which is stored in `highestBid` after the auction state transitions to `Ended`, and the next minimal bid for ongoing auctions calculated as the current bid plus a predefined `MINIMAL_RAISE` or the starting price if no bids exist.",
        "url": 364
    },
    {
        "nl_input": "The query requires a function to create promo narco with a capped limit, enforcing checks on promo/Gen0 creation counts against predefined limits (promoCreationLimit, gen0CreationLimit) and auto-assigning ownership to COO if unprovided. The code must increment counters (promoCreatedCount, gen0CreatedCount) and trigger a creation method (_createNarco) after validation.",
        "url": 365
    },
    {
        "nl_input": "The query requires modifying ICO parameters such as bonuses, token prices, and supply through owner-restricted functions that validate input (e.g., preventing redundant updates, ensuring supply limits) and emit events upon successful changes. Adjustments depend on ICO state (Pre/Main) and operational phases (e.g., before start date).",
        "url": 366
    },
    {
        "nl_input": "The query requires a function that allows only the current override address to update the override address, ensuring exclusive permission control. The function must validate the caller's authority, update the address, emit an event, and return a boolean success status.",
        "url": 367
    },
    {
        "nl_input": "The query requires a function that approves multiple token IDs in a single transaction, checking ownership for each token before approval. The function should iterate through an array of token IDs, verify the sender owns each token, set the approved address for each token, and emit an Approval event for each approved token ID. This batch approval mechanism should be efficient and handle multiple tokens in one call.",
        "url": 368
    },
    {
        "nl_input": "The query requires a smart contract function that allows purchasing DOL tokens from a VAULT by sending ETH. The function should transfer the specified amount of DOL tokens from the VAULT to the buyer's address in exchange for ETH, ensuring the transaction is secure and only executable under certain conditions (e.g., time lock or owner permission). The transfer should update balances and emit an event for transparency.",
        "url": 369
    },
    {
        "nl_input": "The query requires a function that sends remaining tokens back to the wallet after a crowdsale ends. The function should ensure the crowdsale is finalized, transfer any remaining tokens to the specified wallet, and mark the crowdsale as completed. It may also include additional checks like verifying sale completion conditions or handling refunds if goals are not met. The function should be restricted to the owner or follow specific timing rules.",
        "url": 370
    },
    {
        "nl_input": "The query requires initiating a poll with canonical parameters (vote quorum, commit duration, reveal duration) that emits a PollCreated event with the pollID. The poll should track votes for and against, and set end dates for commit and reveal phases based on the input durations. The pollID is auto-incremented and returned upon creation.",
        "url": 371
    },
    {
        "nl_input": "The query requires a function to set an individual cap for participants in the second stage of a crowdsale. The function should be restricted to a controller or owner, updating the maximum allocation per investor in stage 2. The solution involves modifying a contract variable that limits investment amounts during this specific phase.",
        "url": 372
    },
    {
        "nl_input": "The query seeks code snippets that calculate or handle the withdrawal of tokens, specifically focusing on functions that determine withdrawable amounts by considering seller balances, token transfers, or reserve calculations. The relevant operations include transferring remaining tokens after accounting for purchased/withdrawn amounts, handling presale token transfers with supply updates, and calculating withdrawal balances after reserving a percentage of funds.",
        "url": 373
    },
    {
        "nl_input": "The query requires extracting pricefeed-specific information from smart contracts, including functions to set or retrieve price data, verify signatures, and ensure recent and valid price updates. The relevant functions involve setting price feeds with nonce and block validation, retrieving ticket prices, and fetching recent prices and decimals for multiple assets. The focus is on obtaining or updating price-related data with necessary checks and validations.",
        "url": 374
    },
    {
        "nl_input": "The query requires a function that sets a security check report URI, which should be modifiable only by the contract owner. The function should accept a string parameter representing the URI and update the `securityCheckURI` variable. The code should include an access control modifier (`onlyOwner`) to restrict function execution to the owner. The other provided code snippets are unrelated as they handle different functionalities (slashing period and symbol setting).",
        "url": 375
    },
    {
        "nl_input": "The query requires a function that calculates the number of tokens purchasable with a given amount of wei (weiAmount). The function should return the token amount, possibly considering different rates based on the weiAmount's value, and handle any excess wei. The solution should involve multiplication with a rate and may include checks for minimum wei amounts or tiered pricing.",
        "url": 376
    },
    {
        "nl_input": "The query requires a function to set the sale status of an account, allowing privileged owners to mark an address as eligible or ineligible for sales. The function should validate the account address and enforce multi-owner authorization for security. The status should be stored in a mapping for future reference. Optional features include checking sale status or configuring sale parameters, but the core need is updating the sale eligibility of a specified account.",
        "url": 377
    },
    {
        "nl_input": "The query requires a method to calculate the Developer's Cut in a game, which involves multiplying a given price by a developer's percentage (promille) and then dividing by 1000 to get the final cut. The method should be private and view-only, returning the calculated value as an unsigned integer.",
        "url": 378
    },
    {
        "nl_input": "The query requires information on additional methods or functions that extend standard token functionalities, specifically focusing on internal operations like minting tokens, adding tokens to an address, or calculating token amounts for ether. The relevant functions include `_mint`, `tokenadd`, and `howManyTokensForEther`, which handle token creation, balance updates, and conversion calculations.",
        "url": 379
    },
    {
        "nl_input": "The query requires a description of code that enforces authorization checks, ensuring only specified accounts can call certain functions. The code should include modifiers or functions that verify the caller's address against a list of authorized addresses and throw an error if unauthorized. Examples include checking against an owner, depositor, beneficiary, or a mapping of authorized addresses. The requirement is to restrict function access to predefined authorized users only.",
        "url": 380
    },
    {
        "nl_input": "The query requires a function that sets the gas cost for deposits in a smart contract, with the condition that only authorized users can modify this parameter. The function should accept a `uint8` parameter representing the gas cost and update the contract's `depositGasCost` variable accordingly. This functionality is specifically for managing deposit-related gas fees within the contract.",
        "url": 381
    },
    {
        "nl_input": "The query requires a function to transfer a specified token amount (_value) from the sender (msg.sender) to a recipient address (_to), ensuring sender authorization, handling contract-based recipients via tokenFallback, and validating token ownership or contract interactions.",
        "url": 382
    },
    {
        "nl_input": "The query requires identifying ERC20 token interaction functions enabling token transfers (via transfer/safeTransfer) restricted to contract owners and balance checks, ensuring secure management of external ERC20 tokens within contracts.",
        "url": 383
    },
    {
        "nl_input": "The query requires code that restricts token transfers based on specific conditions, such as time constraints (e.g., `now < OWNER_TRANSFER_TOKENS`), owner permissions (`onlyOwner`), and checks against blocked addresses (`congress` mapping), ensuring transfers are disabled unless all criteria are met.",
        "url": 384
    },
    {
        "nl_input": "The query requires a transfer function controlled by a `tradingOpen` modifier, enabling transfers only when trading is active (set via an admin function) or after 24 Dec 2017. The code must include a state variable (e.g., `tradingOpen`) toggled by an admin-restricted function and a modifier applied to transfer functions to enforce access based on this state.",
        "url": 385
    },
    {
        "nl_input": "The query requires a modifier that restricts function execution to when funds are not locked. The modifier should check a `locked` state variable and revert if it's true, allowing the function to proceed only when `locked` is false. This ensures actions like fund transfers can only occur when funds are unlocked. The solution should use a `require` statement for clarity and gas efficiency. (80 words)",
        "url": 386
    },
    {
        "nl_input": "The query requires an internal function for handling Ethereum (ETH) refunds during stage three of a contract. The function should verify the contract stage, check sender authorization (owner or receiver), ensure the refund amount meets a minimum contribution, record the refund amount, and emit an event for the refund transaction. The function must be restricted to specific conditions and users while processing the refund securely.",
        "url": 387
    },
    {
        "nl_input": "The query requires a smart contract function that allows sending or adding a bonus to a contract, with possible conditions like sender verification, bonus limit checks, or tracking bonus distribution. The function should handle the transfer of funds (msg.value) and may include mechanisms to update bonus pools, counts, or specific balances based on predefined rules.",
        "url": 388
    },
    {
        "nl_input": "The query requires extracting code that calculates token amounts based on given parameters. The relevant code should include functions named similarly to \"calculateTokenAmount\" or \"calculateTokensAmount\" that take input values (like amounts or values) and return computed token quantities, possibly with additional calculations or conditions. The function may involve operations like multiplication or checks for zero values, and could return single or multiple values (e.g., token amount and USD amount).",
        "url": 389
    },
    {
        "nl_input": "The query requires a function to withdraw ETH from a smart contract, specifying either a full balance transfer to the owner or a partial amount to designated addresses, with access control (e.g., `onlyOwner`). The function should handle ETH transfers securely, possibly including balance checks or splitting amounts between multiple recipients.",
        "url": 390
    },
    {
        "nl_input": "The query requires a description of smart contract functions that perform updates or modifications, specifically focusing on functions that change contract states or configurations, such as upgrading contracts, toggling features, or updating parameters, with access control mechanisms like `only_editors` or `onlyManagement` to restrict execution to authorized addresses. The functions should include validation checks and emit events to log changes. (80 words)",
        "url": 391
    },
    {
        "nl_input": "The query requires modifying a token purchase function to send additional tokens to a registered address. The solution should involve overriding the purchase process to include an extra token allocation for specified addresses, ensuring proper validation of the recipient address and token amounts, and updating balances accordingly. The implementation should handle the transfer of tokens and funds while maintaining security checks for non-zero addresses and sufficient balances.",
        "url": 392
    },
    {
        "nl_input": "The query requires extracting code snippets that define a `totalSupply` function in a smart contract, which returns the total amount of tokens as a `uint256` value. The function should be publicly accessible and may use modifiers like `constant`, `view`, or similar. The returned value can be stored in variables named `numTokens`, `totalSupply`, or `totalSupply_`. The focus is on the function signature and return type matching the query's requirements.",
        "url": 393
    },
    {
        "nl_input": "The query requires a function that can check or modify the status of a developer, typically involving setting or retrieving a boolean status for a specific address, often restricted to the contract owner. The function should emit an event when the status changes. The status could be related to developer permissions or participation in the contract. The expected output should be concise and focus on the core functionality of developer status management.",
        "url": 394
    },
    {
        "nl_input": "The query requires a function that allows any user to set rabbit data (explosive, endurance, nimble) for a specific token ID, with the condition that the action must be authorized by a signed message from the COO (Chief Operating Officer) address. The function should verify the signature, ensure the task ID hasn't been used before, and update the rabbit's attributes while emitting an event upon completion.",
        "url": 395
    },
    {
        "nl_input": "The query requires a function that allows depositing tokens to a user in a game, with checks for valid parameters and proper token transfer. The function should verify sender authorization, validate deposit amounts, and update token balances accordingly. It should also emit events for tracking deposits and ensure secure token transfers between addresses. The solution must handle different token types and include necessary safety measures like require statements to prevent invalid transactions.",
        "url": 396
    },
    {
        "nl_input": "The query requires a function that sets a pre-ICO address with a specified token price, where setting the price to 0 disables the address. The function should be restricted to the contract owner only. The focus is on managing pre-ICO addresses and their associated token prices within a smart contract.",
        "url": 397
    },
    {
        "nl_input": "The query requires code that checks if the last price update occurred more than one day ago and, if so, updates the price and records the current update time. The code should include a time comparison, price adjustment logic, and timestamp saving. The solution should focus on daily price updates with a 24-hour interval check.",
        "url": 398
    },
    {
        "nl_input": "The query requires a smart contract function that can freeze multiple accounts simultaneously. The function should accept an array of addresses and a boolean flag to freeze/unfreeze them, with checks for valid inputs and owner-only access. It should iterate through each address, update their frozen status, and emit an appropriate event. The solution must handle batch operations efficiently while ensuring security through proper access control and input validation.",
        "url": 399
    },
    {
        "nl_input": "The query requires a function that updates the payout for burritos owned by a specific address. The function should calculate the owed amount based on the total pool and individual burrito data, update the withdrawn amounts, and add the total owed to the owner's payout balance. The first code snippet meets these requirements by iterating through the owner's burritos, calculating owed amounts, updating withdrawn values, and adjusting the owner's payout balance.",
        "url": 400
    },
    {
        "nl_input": "The query requires a smart contract code snippet that enables an admin or owner to withdraw PLAT (or platform) tokens from the contract's balance. The function should include access control (e.g., `onlyOwner` or `isAdmin`), check the contract's PLAT balance, and transfer the specified amount or full balance to the admin's address. Optionally, it may emit an event to log the withdrawal.",
        "url": 401
    },
    {
        "nl_input": "The query requires checking if all contributors' tokens have been successfully distributed by verifying each contributor's token distribution status in a smart contract. The solution should iterate through all contributors and confirm that their `isTokenDistributed` flag is set to `true`, ensuring no contributor is left without tokens. If any contributor's tokens are not distributed, the function should flag the distribution as incomplete. The result should be a boolean indicating the overall distribution status. (80 words)",
        "url": 402
    },
    {
        "nl_input": "The query requires identifying and describing code segments that manage or retrieve information about contributors in a smart contract. This includes functions that list contributors, compensate them, or check their token distribution status. The focus is on operations involving contributor data handling, such as retrieving contributor IDs, processing compensations, or verifying token distributions. The provided code snippets demonstrate these functionalities related to contributor management in blockchain contracts.",
        "url": 403
    },
    {
        "nl_input": "The query requires a function that retrieves the amount of tokens authorized for withdrawal by a `_spender` from an `_owner` account. The suitable code should implement an `allowance` function that returns the remaining authorized amount from a mapping or similar structure, as seen in the second code snippet. The description should focus on checking authorized withdrawal permissions between two specified addresses. (80 words)",
        "url": 404
    },
    {
        "nl_input": "The query requires a function or mechanism that allows users to retrieve or calculate the amount of tokens they can obtain, typically in exchange for another asset like Ether or other tokens. The solution should include parameters for input amounts (e.g., wei or token values) and return the corresponding token amounts, possibly with additional details like excess amounts or transaction events. The focus is on user-facing token amount calculations or returns.",
        "url": 405
    },
    {
        "nl_input": "The query requires code that demonstrates how to start or create an auction in a smart contract, including functions to initiate the auction with parameters like duration, pricing, and ownership checks. The code should handle state transitions, emit events, and include necessary validations such as ownership and duration constraints.",
        "url": 406
    },
    {
        "nl_input": "The query requires code that re-enables or unfreezes a previously frozen state in a smart contract, allowing transactions or account operations to resume. The functionality should include removing freeze restrictions, possibly with an event or notice, and be callable by authorized roles like owners or managers.",
        "url": 407
    },
    {
        "nl_input": "The query requires a description of the finalization process in a token generation event, including steps like returning unsold tokens, minting remaining tokens to a specified wallet, stopping minting, and marking the event as finalized. The code snippets show functions for finalizing crowdsales, handling token distribution, and ending minting operations, typically executed by the contract owner. The process ensures proper token allocation and concludes the event securely. (80 words)",
        "url": 408
    },
    {
        "nl_input": "The query requires a function that calculates points for specific tournament stages (round of sixteen, quarter-finals, and semi-finals) based on team progression and bracket results. The function should iterate through teams, check their advancement status, and assign points accordingly (e.g., 60 points per team that reaches or surpasses the specified round). The output should be the total points for the middle rounds of the tournament.",
        "url": 409
    },
    {
        "nl_input": "The query requires a function that transfers all Ether from a contract to the owner's specified address, ensuring only the owner can execute it. The function should check the contract's balance and securely transfer the funds to the owner's address.",
        "url": 410
    },
    {
        "nl_input": "The query requires a function to set default parameters for a vesting schedule, including bonus percentages, lock periods, and token release timings. The function should allow configuration of whitelist vesting parameters (bonus percentage, principle lock percentage, lock periods, and early participant price) and define vesting stages with specific timestamps and token unlock percentages. Additionally, it should calculate vested tokens based on elapsed time relative to the vesting period.",
        "url": 411
    },
    {
        "nl_input": "The query requires a smart contract function that allows withdrawing all remaining ETH from the contract to cover transaction costs after all rewards have been withdrawn, ensuring the transfer is restricted to the owner and checks the contract's ETH balance before execution. The function should handle the transfer securely and efficiently.",
        "url": 412
    },
    {
        "nl_input": "The query requires a function that burns all tokens owned by the contract owner, ensuring the operation is restricted to the owner only. The function should update the token balances and total supply accordingly, and may include checks or events to confirm the burn action. The implementation should handle the complete removal of the owner's tokens from circulation.",
        "url": 413
    },
    {
        "nl_input": "The query requires utility functions in Solidity contracts, including a modifier to restrict function execution to once, a safe addition function with overflow check, and a function to return the total supply of tokens. These functions enhance security and provide essential contract functionalities.",
        "url": 414
    },
    {
        "nl_input": "The query requires a function that checks if a given amount of fuel can be sold today without exceeding the available supply. The function should return `false` if the amount would exceed the supply limit. The relevant code should compare the sum of already sold fuel and the new amount against the total supply minus reserved fuel.",
        "url": 415
    },
    {
        "nl_input": "The query requires a function to retrieve the total number of tweets for a specific round. The suitable code should return a count of tweets associated with a given round number, as demonstrated in the first code snippet which accesses `pastRoundsTweets[round]`. The other codes are irrelevant as they deal with game counts or current round details, not tweet totals.",
        "url": 416
    },
    {
        "nl_input": "The query requires a function that retrieves the allowance amount an owner has approved for a spender to transfer from their account. The function should take two address parameters (owner and spender) and return a uint256 value representing the allowance. The allowance is stored in a mapping (e.g., allowed or _approvals) that tracks approvals between addresses. The function can be public/external and view/constant.",
        "url": 417
    },
    {
        "nl_input": "The query asks for the total supply of xlmgold tokens. The provided code snippets show functions named `totalSupply()` that return the supply value from variables `numTokens`, `totalSupply`, or `_totalSupply`. The exact variable name depends on the contract implementation, but the function consistently returns the total token supply. The description should note that the total supply is retrieved via the `totalSupply()` function, which accesses a storage variable holding the supply count. (80 words)",
        "url": 418
    },
    {
        "nl_input": "The query requires a time utility function in a smart contract that can either return the current time in milliseconds, set a time window in seconds, or configure time periods. The options include functions to fetch the current timestamp, define a duration for a time window, or specify multiple time periods for different intervals.",
        "url": 419
    },
    {
        "nl_input": "The query requires a function that withdraws DGZ tokens to a specified beneficiary. The function should transfer the tokens from the contract to the beneficiary, update the tokens sold on the public round, and emit an event for the withdrawal. The function must also ensure that the crowdsale is still open before processing the withdrawal. Only the contract owner should be able to execute this function.",
        "url": 420
    },
    {
        "nl_input": "The query requires a function that adds two unsigned integers (x and y) while checking for overflow and throwing an exception if it occurs. The function should return the sum if no overflow is detected. This is typically implemented using assertions or require statements to ensure the sum is valid. The solution should be pure (no state changes) and internal (only callable within the contract).",
        "url": 421
    },
    {
        "nl_input": "The query requires code that handles the allocation of tokens for a private sale, including setting the token sale address and processing private purchases with checks for available tokens and beneficiary transfers. The code should ensure proper token distribution and stage transitions during the private sale phase.",
        "url": 422
    },
    {
        "nl_input": "The query requires a function that preallocates a liquid portion of tokens to a specified address, ensuring the allocation is within available limits and updates the remaining allocatable amount. The function should be restricted to admin access and emit an event upon successful allocation. The liquid tokens should be minted and transferred to the recipient address.",
        "url": 423
    },
    {
        "nl_input": "The query requires a function that returns the total number of Zodiacs currently in existence. The suitable code snippet is the first one, which includes a `totalSupply()` function that calculates this by returning `zodiacs.length - 1`. This meets the need to track the current count of Zodiacs.",
        "url": 424
    },
    {
        "nl_input": "The query requires information about contract constructors or initialization functions in Solidity smart contracts. Specifically, it seeks functions that set initial states, configure parameters, or start operations, typically restricted to owners or specific conditions. Examples include setting distributor addresses, starting contribution periods, or checking if contribution periods are active. The focus is on functions that initialize or manage contract states during deployment or setup phases.",
        "url": 425
    },
    {
        "nl_input": "The query requires a function to retrieve the genes of a specific hero in a transport, challenge, or train context, and to claim a hero if the user doesn't already have one. The solution should involve checking the hero's ownership and fetching the genes, with an automatic claim mechanism for users without any heroes. The first code snippet best matches this requirement by handling both gene retrieval and conditional hero claiming.",
        "url": 426
    },
    {
        "nl_input": "The query requires a function to set or update an agent (transform, transfer, or minting) with specific conditions such as owner-only access, state checks, and agent validation. The function should handle agent address assignment and ensure compliance with predefined rules (e.g., non-zero address, original supply/funds matching, or state restrictions). The agent type (transform, transfer, or minting) must be specified, and the function should emit relevant events upon successful execution.",
        "url": 427
    },
    {
        "nl_input": "The query requires a smart contract function to withdraw all Ether (this.balance) from the contract, restricted to the owner. The first code snippet meets this need with a simple `withdrawEther()` function that transfers the entire contract balance to the owner. The other snippets either split the withdrawal or handle specific trade balances, which do not fully match the requirement.",
        "url": 428
    },
    {
        "nl_input": "The query requires a description of how to mint Kin tokens. The relevant code should include a function that mints tokens by specifying an address and token amount, ensuring the address is valid, and potentially emitting a transfer event. The minting function may be restricted to certain roles like the contract owner. The focus is on the token creation and assignment process.",
        "url": 429
    },
    {
        "nl_input": "The query requires executing a periodic subscription payment, which involves verifying the subscription state, charging the specified amount from the subscriber to the service provider, updating the payment status, and confirming the execution. The code should handle authorization checks, payment fulfillment, and state updates while ensuring security against reentrancy and suspension. The function should return a success status upon completion.",
        "url": 430
    },
    {
        "nl_input": "The query requires a function that allows users and token holders to verify if Donald Trump is still the president. The code should return a boolean value indicating the current status, likely by checking a timestamp or a predefined condition similar to the `hasEnded()` function in the third code snippet, which checks if the current time exceeds a specified end time or if tokens are depleted. The solution should be simple and callable by any user.",
        "url": 431
    },
    {
        "nl_input": "The query requires a modifier or function that ensures only a specific burnable account can execute a certain action. The code should include a check that throws an exception if the caller is not the designated burn address or an authorized burner account. This is typically implemented using a `require` statement to validate the caller's address against the burn address or a list of allowed burners.",
        "url": 432
    },
    {
        "nl_input": "The query requires checking if an early purchase has been amended by verifying if the purchase index exists in a list of amended indexes. The suitable code should include a function that takes an early purchase index as input and returns a boolean indicating whether it has been amended by comparing it against a stored array of amended indexes. The other provided codes are unrelated to this specific requirement.",
        "url": 433
    },
    {
        "nl_input": "The query requires a function that marks a document with a specified ID as visible. The function should check if the document is currently invisible and update its visibility status, triggering an event to log the change. The function should be restricted to editors only. The expected code would include a visibility toggle and an event emission for tracking purposes.",
        "url": 434
    },
    {
        "nl_input": "The query seeks a function that retrieves the current round information from a smart contract. The function should return details about the ongoing round, such as its structure or status, without modifying the contract's state. It may involve checking conditions like token sales or block numbers to determine the current round. The expected output is a read-only operation providing round-specific data.",
        "url": 435
    },
    {
        "nl_input": "The query requires a function that updates a listingHash's status from 'application' to 'listing' or resolves a challenge if applicable. The suitable code should check conditions for whitelisting or challenge resolution and execute the corresponding status update or revert if neither condition is met. The first code snippet meets this requirement by handling both whitelisting and challenge resolution for a given listingHash.",
        "url": 436
    },
    {
        "nl_input": "The query requires a description of a refund poll mechanism in smart contracts, including checking refund poll dates and processing refunds when conditions are met (such as specific dates or unsuccessful sales). The refund process involves verifying eligibility, transferring the refund amount, and updating balances or investment records. The mechanism ensures refunds are only available during designated periods or under certain conditions.",
        "url": 437
    },
    {
        "nl_input": "The query requires a description of minting functions in smart contracts, which involve creating new tokens. Key aspects include:  \n- Stopping minting (`finishMinting`).  \n- Internal token minting with address validation (`_mint`).  \n- Owner-restricted minting with supply checks and balance updates (`mint`).  \nThese functions handle token creation, ownership checks, and event emissions for transparency.",
        "url": 438
    },
    {
        "nl_input": "The query requires a function to transfer tokens between addresses while checking for any dividends to be paid. The code should include token transfer logic with balance updates, allowance checks, and dividend payment verification if applicable. The function must ensure the sender has sufficient tokens and handle the transfer securely, possibly emitting events for tracking. The solution should combine transfer and dividend payment checks in a single operation.",
        "url": 439
    },
    {
        "nl_input": "The query requires a smart contract function that refunds an investor's investment. The function should reset the investor's invested amount, transfer the funds back to the investor, and optionally emit an event or update state variables to reflect the refund. The refund can be triggered by the investor or the contract owner, depending on conditions like sale success or timing. The solution should ensure proper balance updates and security checks.",
        "url": 440
    },
    {
        "nl_input": "The query requires setting a KYC (Know Your Customer) contribution cap for an address based on different KYC levels. Level 3 sets a cap of 50,000 ether, level 2 calculates a cap based on USD/ETH rate, level 1 calculates a lower cap, and non-approved addresses get a zero cap. The function must be restricted to the contract owner.",
        "url": 441
    },
    {
        "nl_input": "The query requires a function that returns the current exchange rate of LNC per Ether. The suitable code should include a function that fetches and returns this rate without any additional calculations or conditions. The function should be simple and directly provide the exchange rate value. The best match would be a function named `getRate` or similar that returns a `uint` representing the rate.",
        "url": 442
    },
    {
        "nl_input": "The query requires a function that allows updating the minimum contribution amount required to participate, ensuring the new value is greater than zero. The function should be restricted to authorized roles (e.g., management or owner) and emit an event upon successful update. The code should include validation to prevent zero or negative values.",
        "url": 443
    },
    {
        "nl_input": "The query requires a function to manually send a specified amount of tokens to a given address, ensuring the sender has privileges, the address is whitelisted, and the token amount is valid. The function should handle transfers during pre-ICO or ICO phases with appropriate checks and revert if conditions aren't met.",
        "url": 444
    },
    {
        "nl_input": "The query requires a function that returns the total number of voters who have voted for a specific proposal. The first code snippet provides this functionality by returning `proposals[_rootHash].totalVoters`, which directly answers the query. The other snippets handle voting logic but do not retrieve the count of voters for a proposal. The requirement is met by accessing a stored total voter count for a given proposal identifier.",
        "url": 445
    },
    {
        "nl_input": "The query requires a function that adds a user's address to a list of participants, ensuring no duplicates. The function should check if the address is already in the list before adding it. The solution involves iterating through the existing participants and only pushing the new address if it is not found. This ensures each participant is unique in the list. The provided code examples demonstrate similar logic for adding addresses to different types of lists.",
        "url": 446
    },
    {
        "nl_input": "The query requires a function to deauthorize or remove an issuer or authority from a smart contract. The function should update the contract state to reflect the removal, typically by setting the issuer's status to false or deleting their entry, and emit an event to log the action. The operation should be restricted to the contract owner for security. Examples include removing an issuer, a deed, or a certificate authority.",
        "url": 447
    },
    {
        "nl_input": "The query requires calculating the amount of non-vested tokens at a specific time by subtracting the vested tokens from the total granted tokens. The result should be a uint256 value representing the remaining non-vested tokens. The calculation depends on the grant details and the specified time.",
        "url": 448
    },
    {
        "nl_input": "The query requires setting up an array with vesting stages that includes specific dates and corresponding token unlock percentages. The dates should be defined relative to a starting timestamp with incremental time intervals (hours and minutes), and each stage should specify the percentage of tokens unlocked at that point (e.g., 25%, 50%, 75%, 88%, 100%). The solution should initialize these stages in a structured format.",
        "url": 449
    },
    {
        "nl_input": "The query requires a description of smart contract functions that allow users to purchase tokens by sending Ether. The functions should include checks for minimum Ether amounts, calculate the corresponding tokens based on a rate, transfer the Ether to a specified wallet, and issue/mint the tokens to the buyer. Additional features may include event logging, beneficiary checks, and ensuring the sale is active or not paused. The contracts should handle the token purchase transaction securely and efficiently.",
        "url": 450
    },
    {
        "nl_input": "The query requires a function to return the number of contributors for all campaigns. The first code snippet provides a suitable solution by returning an array of contributor IDs, which can be used to count the number of contributors. The other snippets are unrelated to counting contributors. The requirement is met by extracting and counting contributor IDs from a linked list structure.",
        "url": 451
    },
    {
        "nl_input": "The query requires a function for selling tokens during a crowd sale event. The function should handle token transfers from the contract to an investor's address, update the remaining token supply, and ensure proper transaction validation. It may include checks for sufficient balance, transfer approvals, and emit events for tracking sales. The function should be secure, with access control if needed, and integrate with the token's transfer mechanism.",
        "url": 452
    },
    {
        "nl_input": "The query requires checking if an address is valid for token transfers by ensuring it is not the zero address or the token's own address. The code should include validation to prevent transfers to these invalid addresses. This involves adding `require` statements to verify the destination address is valid before executing the transfer. The focus is on security measures to avoid sending tokens to unintended or invalid addresses.",
        "url": 453
    },
    {
        "nl_input": "The query requires a function to add an administrator address that can manage the token even when the contract is paused. The function should be callable only by the owner and should prevent duplicate administrators. The address should not be the owner or the contract itself. The function should return a boolean indicating success. \n\nBest match: URL 454's `addAdministrator` function, which checks for existing administrators and adds a new one with the required role.",
        "url": 454
    },
    {
        "nl_input": "The query requires a function that can handle and return both `address` and `bytes32` types without requiring explicit casting from the user. The function should extract or convert these types from input data, such as bytes, and return them directly. This simplifies usage by avoiding manual type conversions and supports seamless integration with other contract functions that expect these types. The solution should be efficient and work within Ethereum's assembly or Solidity constraints.",
        "url": 455
    },
    {
        "nl_input": "The query requires a private function to add a fee to an address, ensuring the fee is either initialized or incremented if the address already has a fee. The function should not be accessible publicly and should handle the fee update logic internally. The target code should match this specific functionality without involving public fee setting or processing logic.",
        "url": 456
    },
    {
        "nl_input": "The query requires identifying code snippets that implement re-entry protection mechanisms in smart contracts. Re-entry protection prevents recursive calls that could lead to vulnerabilities like the DAO attack. The focus is on functions that manage ether transfers or contract interactions with safeguards against re-entrancy, such as checks on state variables or using patterns like Checks-Effects-Interactions. The description should highlight these protective measures in under 80 words.",
        "url": 457
    },
    {
        "nl_input": "The query requires filtering a list of buyers based on whether they are investors, returning a new list containing only the addresses that match the specified investor status (true or false). The filtering process involves checking each buyer against an approved investor list and compiling the matching addresses into a new array. The result should exclude any null or zero addresses. The focus is on selective extraction from a buyer list using a boolean condition.",
        "url": 458
    },
    {
        "nl_input": "The query requires a Solidity modifier that checks if the caller (`msg.sender`) is the contract owner, following the inherited modifiers pattern. The modifier should include a `require` statement to validate ownership and use `_;` to proceed with the function execution if the condition is met. The correct implementation should ensure `msg.sender == owner`.",
        "url": 459
    },
    {
        "nl_input": "The query requires code that sets the `paused` variable to `false` in a smart contract, typically through an `unpause` function, which may include access control modifiers like `onlyManager` or `onlyOwner` and a `whenPaused` modifier to ensure the contract is paused before unpausing. Optionally, it may emit an event upon unpausing. The function should be public and directly modify the `paused` state variable.",
        "url": 460
    },
    {
        "nl_input": "The query requires identifying code snippets related to token release mechanisms in smart contracts, including functions to release team tokens, check released token amounts for specific addresses, and modifiers to ensure tokens are only released after a specified date. The focus is on time-based or conditional token release functionalities.",
        "url": 461
    },
    {
        "nl_input": "The query requires checking the number of ACE Equity Tokens a spender is authorized to spend on behalf of an owner. This involves retrieving the allowance value from a mapping that tracks approved spending limits between owner and spender addresses, typically implemented as `allowed[owner][spender]`. The result should be a uint256 value representing the remaining allowance.",
        "url": 462
    },
    {
        "nl_input": "The query requires a description of a smart contract function that distributes bonus tokens to recipients and then returns any remaining tokens back to the original coin or contract. The function should handle the transfer of tokens with bonuses and ensure proper accounting or redistribution of any leftover tokens. The focus is on the distribution logic and the return of excess tokens to the main contract or coin. (80 words)",
        "url": 463
    },
    {
        "nl_input": "The query requires a function that retrieves the token balance of a specified account (address) from a smart contract. The function should accept an address parameter and return the balance as an unsigned integer (uint or uint256). The balance should be fetched from a mapping or storage variable named `balances` indexed by the address. The function can be either `view` or `constant` and should be publicly accessible.",
        "url": 464
    },
    {
        "nl_input": "The query requires a function to transfer ownership of a specific unicorn ID, verifying the caller's approval. The code must include parameters for the unicorn ID, check authorization (e.g., via `require`), and execute ownership transfer (e.g., `clearApprovalAndTransfer`), ensuring the caller is permitted to claim ownership of the designated ID.",
        "url": 465
    },
    {
        "nl_input": "The query requires identifying code snippets that handle the paused and non-paused states of a contract, specifically functions to check the paused status (`getPaused`) and to unpause the contract (`unpause`), which should be callable only by authorized roles (e.g., `onlyManager` or `onlyOwner`) and only when the contract is paused (`whenPaused`). The functions should update the `paused` state and optionally emit events.",
        "url": 466
    },
    {
        "nl_input": "The query requires a function that transfers advisor tokens to an advisor's wallet, ensuring conditions like time locks and supply checks are met, and updating the supply and lock time accordingly. The function should be callable only by the owner and handle vesting schedules.",
        "url": 467
    },
    {
        "nl_input": "The query requires a function that enables the contract owner to transfer ERC20 tokens to a multi-signature vault. The function should be restricted to the owner and should handle the transfer of the token balance from the contract to the specified vault. The solution should ensure secure token transfer with proper access control.",
        "url": 468
    },
    {
        "nl_input": "The query requires a function that combines token transfer approval and calling another contract in a single step. The solution should approve the transfer of tokens to a specified address and then execute the transfer, ensuring both actions are performed atomically. This involves checking ownership, updating balances, and emitting relevant events, while maintaining security checks like token ownership verification and sufficient balance. The goal is to streamline the two-step process into one efficient transaction.",
        "url": 469
    },
    {
        "nl_input": "The query requires a function to transfer ownership of another contract (where the current contract is the owner) to a new address. The function should be callable only by the owner, validate the new address, and update the ownership. It may optionally emit an event for the ownership transfer. The target contract must support ownership transfer functionality.",
        "url": 470
    },
    {
        "nl_input": "The query requires a function that retrieves a list of token IDs owned by a specified address. The function should take an address as input and return an array of token IDs associated with that address. The first code snippet (`c16097`) matches this requirement by returning `uint256[]` from the `ownedTokens` mapping for the given `_owner` address. The other snippets either count tokens or transfer them, not list IDs.",
        "url": 471
    },
    {
        "nl_input": "The query requires identifying functions related to ending a crowdsale, specifically `endCrowdsale()` and `endCrowdsalePublic()`, which have been moved to a \"Steak\" contract. The focus is on functions that terminate a crowdsale, typically restricted to the owner, with conditions like checking sale status, timestamps, or funding goals, and executing related actions such as closing vaults or enabling refunds. The description should be concise, under 80 words.",
        "url": 472
    },
    {
        "nl_input": "The query requires a function that calculates the token amount based on a given wei value, applying specific conversion rates or logic. The function should accept a wei amount as input and return the corresponding token amount, potentially using different rates for different wei ranges or external rate sources. The output should be a uint256 value representing the calculated tokens. (60 words)",
        "url": 473
    },
    {
        "nl_input": "The query requires a function that allows the token owner to rename the token (updating both its name and symbol) and notify users of the change, ensuring the contract reflects the new token information. The function should be restricted to the owner only.",
        "url": 474
    },
    {
        "nl_input": "The query requires code that implements a function to purchase option tokens, either by specifying the token address or handling different option types with varying parameters. The function should support buying options with tokens or handling multiple option tiers, ensuring valid transactions and updating balances accordingly. The solution should include checks for valid inputs and proper token allocation.",
        "url": 475
    },
    {
        "nl_input": "The query requires a description of how to calculate unclaimed fees for a fund manager, including management fees based on time and asset value, and performance fees if the current share value exceeds a high-water mark. The fees are summed to determine the total unclaimed amount. The calculation involves time elapsed, gross asset value (GAV), and share price comparisons.",
        "url": 476
    },
    {
        "nl_input": "The query requires a code implementation that enforces a 3-week waiting period after a sale closes before trading can be opened. The current code snippets provided do not include this time-based restriction, only basic toggles for trading and sale states. The desired solution should incorporate a timestamp check to ensure the 3-week delay is respected before allowing trading to commence.",
        "url": 477
    },
    {
        "nl_input": "The query requires a function to purchase soldiers with specific pricing tiers: 1 soldier for 0.001 ETH, 10 for 0.008 ETH, 100 for 0.065 ETH, and 1000 for 0.5 ETH. The function must validate the payment amount and update the soldier count for the specified army. The other provided codes are unrelated (purchasing heroes or generic sales).",
        "url": 478
    },
    {
        "nl_input": "The query requires a function to add a minter to a list of authorized minters, ensuring the address is valid and not already a minter, with access restricted to the owner. The function should return a boolean indicating success. The code should include checks for non-zero addresses and prevent duplicate entries, updating the minter's status upon successful addition.",
        "url": 479
    },
    {
        "nl_input": "The query requires initiating a token distribution phase in a smart contract where owners can claim their tokens. This involves activating distribution, ensuring the token is whitelisted, checking minimum balance requirements, updating distribution records, and emitting an event to signal the start of distribution. Owners should be able to claim their allocated tokens after distribution is active.",
        "url": 480
    },
    {
        "nl_input": "The query requires a function that removes a specific deed ID from an address's list of deeds in a smart contract. The function should verify ownership, update the deed list by replacing the target deed with the last one, adjust indices, and decrement the total count. It should also clear the deed's ownership and maintain data integrity during removal. The function must be private/internal to ensure secure and controlled access.",
        "url": 481
    },
    {
        "nl_input": "The query requires a function that returns the share balance of the sender (msg.sender) from a smart contract. The function should be viewable (read-only) and return a uint or uint256 value representing the sender's share balance. The balance should be retrieved from a mapping or structure that stores share information for each address.",
        "url": 482
    },
    {
        "nl_input": "The query requires a description of submitting bid properties to reveal them in an auction system. The code snippets show functions for placing bids, checking bid validity, handling highest bids, and revealing sealed bids with conditions based on auction state, bid value, and timing. The requirements include validating bid amounts, updating highest bids, managing pending returns, and revealing bids with specific rules for different auction states (Owned, Reveal).",
        "url": 483
    },
    {
        "nl_input": "The query requires a smart contract feature that enables the contract owner to securely add a new wallet address designated for holding sale funds. The functionality should include an access control modifier (onlyOwner) and validation to ensure the wallet address is not zero before adding it to a list of sale wallets. The operation should return a boolean confirmation upon successful execution.",
        "url": 484
    },
    {
        "nl_input": "The query requires a Solidity modifier named `onlyContractor` that restricts function execution to a specified `_contractor` address by validating `msg.sender == _contractor` in a `require` statement. The modifier must enforce access control exclusively for the designated contractor, ensuring no additional conditions or roles.",
        "url": 485
    },
    {
        "nl_input": "The query requires identifying code that moves locked tokens to a team account. The suitable code should include functionality for transferring tokens from a locked state to a team address, typically involving timelock release, ownership transfer, or manual removal of locked tokens. The description should focus on token movement mechanisms specific to team accounts. (80 words)",
        "url": 486
    },
    {
        "nl_input": "The query requires adjusting the `hasEnded` function to return `true` when all tokens are sold, typically by checking if `tokensLeft` is zero or if the sale is finalized. The function should evaluate token availability or sale status to determine if the sale has concluded. The solution should prioritize token exhaustion as a termination condition, possibly alongside time-based checks or finalization flags. (80 words)",
        "url": 487
    },
    {
        "nl_input": "The query requires a function that returns the name of a token. The function should be a public view function in a smart contract, returning the token's name as a string. The first code snippet matches this requirement exactly with a `name()` function that returns a string `NAME`. The other snippets either return multiple values or a different type, making them less relevant. The focus is on a simple name retrieval function in a token contract.",
        "url": 488
    },
    {
        "nl_input": "The query requires setting the current exchange rate (ETH/USD) in a smart contract. The suitable code should include a function that updates the rate, preferably with access control (e.g., `onlyOwner`), and may involve validation or calculations based on contract state (e.g., balance or supply). The rate should be passed as a parameter (e.g., `uint256`). The most relevant code snippets allow direct rate updates with owner restrictions.",
        "url": 489
    },
    {
        "nl_input": "The query requires a SafeMath division function that safely handles uint256 division by ensuring the divisor is non-zero before performing the operation, similar to the example in code 490. The function should take two uint256 parameters, check for division by zero, perform the division, and return the result. The description should emphasize safety checks and proper handling of uint256 arithmetic. (80 words)",
        "url": 490
    },
    {
        "nl_input": "The query requires a smart contract function to distribute tokens to multiple addresses (airdrop) with specified amounts, ensuring the sender is authorized and the number of recipients matches the number of values. It should also handle conditions like time limits, participant limits, and prevent duplicate claims. The function must securely transfer tokens from a source to the recipients.",
        "url": 491
    },
    {
        "nl_input": "The query requires a function to refund ether to investors, which should be invoked only from the token contract. The function must check conditions like ICO end time, refund eligibility, and investor balance before transferring the refunded amount. It should update relevant state variables (like total raised funds and token balances) and ensure the refund is processed securely, with events logged for transparency. The refund should be restricted to the owner or under specific contract states.",
        "url": 492
    },
    {
        "nl_input": "The query requires a smart contract function for batch transferring ETH to multiple addresses. The function should distribute the sent ETH equally among all specified addresses, with checks for non-empty address lists and proper value division. The solution should handle the transfer operation securely within the Ethereum transaction context.",
        "url": 493
    },
    {
        "nl_input": "The query requires a function that allows the current owner of a smart contract to propose a change of ownership by specifying a new owner's address. The function should be restricted to the current owner (using `onlyOwner` modifier) and should store or emit the proposed new owner's address. The function may optionally emit an event to log the ownership change proposal. The exact naming of the function and parameters can vary.",
        "url": 494
    },
    {
        "nl_input": "The query requires identifying code snippets related to interface declarations in Solidity smart contracts. The relevant code should include interface-related functions or modifiers, such as setting an interface address, returning a name string, or checking operational status with a modifier. The focus is on contract functions that define or interact with interfaces or contract states.",
        "url": 495
    },
    {
        "nl_input": "The query requires a function to cancel reserved tokens for a specific wallet address, ensuring the amount is valid, the wallet is not zero, the sale hasn't ended, and the amount does not exceed the reserved balance. It should update the reserved token count and emit an event upon cancellation. The function must be restricted to the contract owner.",
        "url": 496
    },
    {
        "nl_input": "The query seeks code examples of Solidity `onlyOwner` modifiers or functions that use this modifier, which restricts access to the owner of the contract. The examples should show the modifier's implementation or its application in a function to ensure only the owner can execute certain actions. The modifier typically includes a `require` statement checking if `msg.sender` is the owner before proceeding.",
        "url": 497
    },
    {
        "nl_input": "The query requires a smart contract function that transfers tokens between addresses, including checks for valid amounts and permissions, and updates token balances accordingly. The function should handle token transfers either directly or via an owner, with possible event emissions for tracking transfers. The solution should ensure security by validating inputs and permissions before executing transfers.",
        "url": 498
    },
    {
        "nl_input": "The query requires a function that enables a token holder to authorize another address (spender) to transfer a specified amount of tokens on their behalf. The function should update the allowance mapping, emit an approval event, and return a boolean indicating success. The spender's address and the approved amount must be specified as parameters. The function should ensure proper authorization and handle zero-value approvals or resetting existing allowances.",
        "url": 499
    },
    {
        "nl_input": "The query requires a smart contract code that enables the return of funds to a curator or specified recipient. The code should include a function to verify the sender's authority (e.g., as the curator) and transfer the contract's balance or specified funds back to them. The refund mechanism should ensure secure and authorized transactions, possibly including checks for failed transfers or specific conditions (e.g., unsuccessful sale). The focus is on secure fund recovery by an authorized party.",
        "url": 500
    },
    {
        "nl_input": "The query requires identifying code snippets that demonstrate functions modifying contract state variables under specific conditions, such as access control (e.g., `onlyManager`, `isOwner`) or stage checks (e.g., `whenPaused`, `atStage`). The functions should transition the contract's state (e.g., unpausing, starting a contribution) or check conditions (e.g., verifying if an operation has started). The focus is on state management and conditional execution in smart contracts.",
        "url": 501
    },
    {
        "nl_input": "The query requires a function to transfer token balances from one address to another, ensuring proper deduction from the sender's balance and addition to the recipient's balance, with necessary checks for validity and successful execution. The function should handle token transfers securely and emit relevant events if applicable.",
        "url": 502
    },
    {
        "nl_input": "The query requires a function that allows depositing wei (Ethereum's smallest denomination) into an exchange contract. The function should handle the deposit process, potentially converting wei to tokens based on specified rates for different deposit tiers (e.g., 0.1-1 ether and 1+ ether). It may also log the deposit details, including the sender's address, token type, amount, and wallet balance. The focus is on secure and efficient wei-to-token conversion and deposit tracking.",
        "url": 503
    },
    {
        "nl_input": "The query requires a description of a function that verifies if terms and conditions have been read and understood, typically by checking a signed message from the user. The function should use cryptographic verification (e.g., `ecrecover`) to confirm the signature matches the sender's address, ensuring the user has acknowledged the terms. The expected output is a boolean indicating whether the verification is successful. The description should be concise, within 80 words.",
        "url": 504
    },
    {
        "nl_input": "The query requires determining the remaining tokens available for purchase during a token sale, considering phased pricing tiers (1-1000, 1001-3000, 3000+ tokens sold), dynamic price adjustments, and constraints like sale period, wallet balances, max/min per transaction, and total supply limits. Remaining tokens are calculated as `_totalSupply - tokensSold`, with checks against phase-specific caps and tiered pricing formulas.",
        "url": 505
    },
    {
        "nl_input": "The query requires a function enabling token transfers via `transferFrom()`, involving balance adjustments between addresses, updating allowances, and returning a success status. It must handle authorization checks, deduct tokens from the sender's allowance, update sender and receiver balances, and emit a transfer event. Optional features include snapshotting state changes before transfer. The core is ERC-20-like `transferFrom` logic ensuring secure delegated token transfers.",
        "url": 506
    },
    {
        "nl_input": "The query requires a function to cancel the sale of a block identified by coordinates (x, y), ensuring the caller is the block owner via key verification, updating the sale status, and emitting an event. The code must handle ownership checks using hashed keys and reset the \"forSale\" state.",
        "url": 507
    },
    {
        "nl_input": "The query requires a function that returns a child address based on a parent address input. The relevant code uses `returnChildAddressForParent(parent)` to fetch the child address by invoking a method from an external contract, passing the parent's address as the parameter.",
        "url": 508
    },
    {
        "nl_input": "The query requires a Solidity function accessible to all users without authorization checks. The code must be public (no access modifiers) and lack restrictions like role-based conditions or flags that disable public access. The second code snippet fulfills this by declaring a public function with no modifiers, allowing unrestricted execution.",
        "url": 509
    },
    {
        "nl_input": "The query requires a system to manage reward distribution, including validating reward amounts, transferring rewards between parties, capping rewards based on balance/daily limits, and accumulating rewards through payable transactions. Key aspects include balance adjustments, reward eligibility, and constraints to prevent exceeding available funds or predefined thresholds.",
        "url": 510
    },
    {
        "nl_input": "The query requires validating sale parameters meet specific conditions, such as ensuring the sale is a fixed price type or has a valid expiration time. The valid parameters are determined by checking if the sale kind is FixedPrice or if the expiration time is greater than zero, ensuring the sale's setup adheres to defined constraints.",
        "url": 511
    },
    {
        "nl_input": "The query requires a function that checks if a given rate value falls within a specified range defined by minimum and maximum constants (e.g., `MIN_RATE`/`MAX_RATE` or `LOW_RANGE_RATE`/`HIGH_RANGE_RATE`), returning a boolean or enforcing validation.",
        "url": 512
    },
    {
        "nl_input": "The query requires code that retrieves the token balance of a specified owner address. The relevant code must include a function (e.g., `balanceOf` or similar) returning a numeric value (e.g., `uint256` or `uint`) representing the token count associated with the owner, typically accessed via a mapping (e.g., `balances[owner]`) or array length (e.g., `ownedCoins[owner].length`).",
        "url": 513
    },
    {
        "nl_input": "The query requires a function that checks if one value is equal to or greater than another, returning a boolean. The code from URL 514 meets this by implementing `a >= b` directly, while others handle assertions or subtraction with inequality checks.",
        "url": 514
    },
    {
        "nl_input": "The query requires a smart contract function enabling the owner to claim allocated funds (via `benefitFunds` transfer with balance verification) and manage a bonus pool (by incrementally adding ETH to `bonusPool` based on conditions), both restricted to the owner's access.",
        "url": 515
    },
    {
        "nl_input": "The query requires a Solidity function to log diary entries with the current timestamp, using `now` for time recording. It should store diary content with a generated logtime, increment entry IDs sequentially, and optionally handle timestamp conversions (e.g., to milliseconds) or future time calculations (e.g., `now + seconds`). Access control via modifiers` like `callByBank` and `oneOfOwners` is expected.",
        "url": 516
    },
    {
        "nl_input": "The query requires a Solidity function to burn tokens by deducting a specified amount from the sender's balance, reducing the total supply, and emitting a burn event. It must include balance checks, use safe arithmetic operations, and update relevant state variables (e.g., balances, totalSupply, totalBurnt) while ensuring valid input values (e.g., non-zero amounts).",
        "url": 517
    },
    {
        "nl_input": "The query requires a function to set a monthly rate (in cents) for a service, likely related to energy (watt/month) or card-based billing. The code must include a public function with an owner-only modifier that updates a stored value (e.g., `centsPerMonth`) via a parameterized input.",
        "url": 518
    },
    {
        "nl_input": "The query requires a function allowing only non-repeating owner approvals to remove another owner, ensuring valid conditions: sufficient remaining owners, active unexpired request, and no prior approval. Upon meeting thresholds, the owner is removed, updates state, and emits an event.",
        "url": 519
    },
    {
        "nl_input": "The query seeks code that enables refunding investors if an ICO fails to meet its goals. Key requirements include verifying the ICO's failure (via token/amount thresholds), authorizing refund initiators (contract, manager, or investor), transferring funds to eligible accounts, resetting balances, and emitting relevant events. Conditions involve checking the ICO state (e.g., deadline passed, soft goal unmet) and ensuring only valid claims are processed.",
        "url": 520
    },
    {
        "nl_input": "The query requires a function to withdraw a consolation prize calculated based on accumulated token payouts, transferring the proportional share of the prize pool to the caller after resetting their payout balances.",
        "url": 521
    },
    {
        "nl_input": "The maximum investment in wei is derived by converting a predefined Euro cent value using the `euroCents2wei` function, which depends on the result of `getMaximumFundsInEuroCents()`. The exact value is determined by internal rate calculations and token allocation logic, ensuring compliance with stage-specific constraints and token pool availability during the sale.",
        "url": 522
    },
    {
        "nl_input": "The query requires a smart contract function that transfers a tulip (NFT) to another address without requiring recipient confirmation, directly executing the transfer if the sender owns the tulip. The code must validate sender ownership, ensure non-zero target address, and bypass approval checks or external validations.",
        "url": 523
    },
    {
        "nl_input": "The query requires a modifier ensuring functions execute only after a vesting period ends. The code must check if the current time (now) exceeds a specified end date (endDate) before allowing function execution, as seen in the modifier whenNotPaused.",
        "url": 524
    },
    {
        "nl_input": "The query requires code that enforces a minimum transaction value of 0.1 ether, applying specific rate calculations based on the input amount (0.1-1 ether or higher). The relevant code checks if the sent ether meets this threshold and assigns corresponding conversion rates for token allocation.",
        "url": 525
    },
    {
        "nl_input": "The query requires a function to withdraw dividend funds by verifying the sender's dividend shares, calculating their proportional amount from the total dividend fund, transferring the amount, updating shares and fund balances, and emitting an event. This involves checks (require/assert), share-based calculations, balance adjustments, and secure fund transfers to the sender.",
        "url": 526
    },
    {
        "nl_input": "The query requires a description of a smart contract function that ensures the calling account has sufficient tokens to approve a transfer. The function should verify ownership of the tokens before approving the transfer to another address and emit an approval event. The focus is on the `approve` or similar functions that handle token approvals with ownership checks. The description should be concise, within 80 words.",
        "url": 527
    },
    {
        "nl_input": "The query requires a Solidity function that updates the token rate (e.g., `tokensPerEthPrice` or `rate`) and is restricted to the contract owner via the `onlyOwner` modifier. The function should validate the input rate (e.g., ensuring it is greater than zero) and modify the corresponding state variable.",
        "url": 528
    },
    {
        "nl_input": "The query requires a function to distribute ERC20 tokens proportionally to holders based on predefined ratios, calculated as a portion of a target total supply. The distribution must occur once, iterate through all holders, allocate tokens using ratio/coefficient multiplication, and emit an event upon completion. The code should ensure holders receive amounts proportional to their ratios and prevent repeated distributions.",
        "url": 529
    },
    {
        "nl_input": "The query requires a function enabling the contract owner to transfer tokens from any address to the owner's address, with validations for non-zero amounts, authorization (onlyOwner), and security checks (e.g., time constraints, blocked addresses). The transfer must update balances directly via owner privileges, not standard user-initiated transfers.",
        "url": 530
    },
    {
        "nl_input": "The query requires a smart contract function for betting on a single number (0-36) with validation of bet limits (1-10 ETH), casino balance checks, random number generation, and payout of 36:1 if the guessed number matches the generated result. Invalid bets trigger refunds and error messages.",
        "url": 531
    },
    {
        "nl_input": "The query requires a mechanism to manually refund bets when an Oraclize callback is not received, ensuring checks for valid callers, bet state (e.g., pending Oraclize response), and proper state transitions upon refund. It must handle error verification (e.g., failed proof checks), update bet status, transfer funds back, and emit events for transparency, while preventing invalid refunds (e.g., completed bets or unauthorized access).",
        "url": 532
    },
    {
        "nl_input": "The query requires a function that sets a slashing period for verification, ensuring the period does not exceed a maximum limit (256) and is controlled by a specific owner or controller. The function should update the slashing period and emit an event or log the parameter update. The code should include access control (e.g., `onlyControllerOwner`) and a validation check (e.g., `require`).",
        "url": 533
    },
    {
        "nl_input": "The query requires a function to assign a timelock to a specified allocation address by validating non-zero address and future timestamp, then storing the lock duration in a mapping and emitting an event. The code must ensure the timelock is set only by authorized entities (e.g., controllers) and return a success status.",
        "url": 534
    },
    {
        "nl_input": "The query requires a smart contract function allowing the contract owner to decline token minting for a specific investor by resetting their allocated token balance, deducting the amount from the total pending mint supply, and emitting a decline event. This is achieved through an owner-restricted function that modifies storage variables and triggers an event upon execution.",
        "url": 535
    },
    {
        "nl_input": "The query requires setting a reserved wallet allocation percentage. The relevant code defines a function to update `reservedTokensPercent` via `setReservedTokensPercent`, allowing the owner to adjust the percentage value stored in a state variable.",
        "url": 536
    },
    {
        "nl_input": "The query requires a function in the Blocklord contract that updates the contract's interface address, restricted to the owner. The function should accept a new address parameter, assign it to the interface variable, and use the `onlyOwner` modifier to ensure authorization.",
        "url": 537
    },
    {
        "nl_input": "The query requires ensuring that original tokens in a contract are equally distributed to prevent large dumps, promoting long-term stability. The code should enforce fair distribution mechanisms, possibly through staged releases, whitelisting, or controlled transfers, without allowing concentrated ownership or sudden sell-offs. The focus is on healthy token longevity via equitable distribution protocols.",
        "url": 538
    },
    {
        "nl_input": "The query requires a function to safely withdraw unbought tokens back to the seller, ensuring the tokens are transferred only after verifying conditions like sale closure or ownership. The function should calculate the remaining tokens (total minus sold/withdrawn) and transfer them securely to the seller's address. This involves checks like `require` statements for sale status or ownership and updating balances or tracking withdrawals to prevent double-spending.",
        "url": 539
    },
    {
        "nl_input": "The query requires a function that updates the `whitelistedPlannedContributions` counter by subtracting a specified contribution amount and emits an event to log the update. The function should be private and handle the subtraction operation securely. The provided code snippet from URL 540 meets these requirements by using a `sub` method to deduct the `plannedContribution` from `whitelistedPlannedContributions` and emits a `WhitelistedCounterUpdated` event.",
        "url": 540
    },
    {
        "nl_input": "The query requires setting the price for summoning a hero using Ether (ETH). The relevant code involves purchasing a hero by sending ETH, where the price is specified and includes a dev fee and owner commission. The payment must match the hero's current price, and the price doubles after purchase. The description focuses on the ETH-based payment mechanism for hero summoning.",
        "url": 541
    },
    {
        "nl_input": "The query requires logging an event to track wallet interactions off-chain, specifically for deposits. The suitable code should include an event emission that records the sender, token, amount, and wallet balance. The first code snippet meets this need with its `LogWalletDeposit` event, while the others focus on wallet address changes without logging. The description should emphasize off-chain event logging for wallet deposits. (80 words)",
        "url": 542
    },
    {
        "nl_input": "The query requires a description of a game scenario where player two approves a contract (SlammerTime) to take their tokens, triggering an event to notify player one of their intent to rumble. The code should involve token transfers, contract approvals, and event broadcasting to facilitate this interaction between players. The focus is on the approval mechanism and event emission to signal player two's action to player one.",
        "url": 543
    },
    {
        "nl_input": "The query requires identifying public functions in Solidity contracts that return a string value (either a symbol or name) or implement a modifier to restrict function execution to once. The relevant functions are `symbol()` returning a string, `name()` returning a string, and a modifier `onlyOnce()` ensuring single execution. The contracts are identified by their URLs (224, 488, 961).",
        "url": 544
    },
    {
        "nl_input": "The query requires checking the ICO stage based on a given time variable. The code should compare the input time against predefined ICO start and finish times or stages to determine if the time falls within the ICO period or a specific ICO stage (e.g., PreICO or Main ICO). The result should return a boolean or update the stage variable accordingly. The focus is on time-based ICO stage validation or status retrieval.",
        "url": 545
    },
    {
        "nl_input": "The query requires identifying a function that allows token recovery by the owner without requiring beneficiary consent, but is restricted to internal use by the `buyToken` function. The function should ensure the beneficiary is valid and not the token contract itself, then transfer any remaining tokens to the beneficiary. The function must be marked as internal or only callable by specific methods like `buyToken`.",
        "url": 546
    },
    {
        "nl_input": "The query requires a smart contract function that allows the owner to modify the number of tokens available for an ICO, ensuring the new amount does not exceed 70 million tokens. The function should include checks to prevent changes after the ICO starts and emit an event to log the update. The owner's authority must be enforced, and the token supply should be validated against the total supply cap.",
        "url": 547
    },
    {
        "nl_input": "The query requires a function that retrieves the asset allowance from one holder to another. The function should take the owner's and spender's addresses as inputs and return the approved allowance amount. The allowance can be stored in a mapping or approvals structure, and the function should be viewable or constant to prevent state changes. The implementation may vary in syntax but must provide the allowance between the specified addresses.",
        "url": 548
    },
    {
        "nl_input": "The query requires a function to propose transferring ownership of the EngravedToken contract to a specified address (`_engravedAddress`), ensuring the proposal follows specific conditions or stages. The function should include checks for valid addresses and may involve a proposal deadline or cooldown period. The solution should mirror a governance or staged approach to ownership transfer.",
        "url": 549
    },
    {
        "nl_input": "The query requires a description of completing a breeding auction by bidding. The suitable code should involve functions for bidding on breeding auctions, checking ownership and breeding eligibility, handling bid amounts, transferring fees, and updating auction states. The description should cover the process from placing a bid to finalizing the auction, including validations and state transitions.",
        "url": 550
    },
    {
        "nl_input": "The query requires code that changes a minimum value (such as bet amount, withdrawal limit, or funding threshold) in a smart contract, typically restricted to specific roles like owner or escrow. The change should include validation to ensure the new value is non-zero or meets certain conditions. Examples include updating minimum bet amounts, withdrawal limits, or handling refunds if funding thresholds aren't met.",
        "url": 551
    },
    {
        "nl_input": "The query requires an internal function to clear current approval and transfer ownership of a token ID. The function must validate the new owner's address, ensure the sender is approved, and update ownership records by removing the token from the old owner and adding it to the new owner, followed by emitting a transfer event. The process should enforce security checks to prevent invalid transfers.",
        "url": 552
    },
    {
        "nl_input": "The query requires a function that allows the owner of an ICO contract to unpause the token contract. The function should be restricted to the owner and trigger the unpause action, either by calling a token's unpause method or directly modifying the paused state. The solution must ensure proper access control and state transition.",
        "url": 553
    },
    {
        "nl_input": "The query requires a smart contract function that allows placing a bid in an auction, where the bid value is sent with the transaction. The function should validate the bid, update the highest bid if applicable, and handle refunds for previous highest bidders. It may also include event emissions for bid updates. The solution should ensure the bid is placed within the auction's active period and exceeds the current highest bid.",
        "url": 554
    },
    {
        "nl_input": "The query requires a smart contract function that allows purchasing HQX tokens. The function should be payable, check if the sender's account is not frozen, ensure the sent value is greater than zero, and execute a token purchase. The contract should handle the payment and token transfer securely. The provided code snippets include similar functionalities, but the exact HQX token purchase logic needs to be implemented with proper validation and token transfer mechanisms.",
        "url": 555
    },
    {
        "nl_input": "The query requires a description of a smart contract function that handles immediate fund payouts while accounting for potential unexpected incoming funds. The function should ensure secure transfer of funds to the owner or beneficiary, possibly include checks for sufficient balance, and handle any remaining or refundable amounts. It should also maintain contract balance integrity and may include event logging or assertions for verification.",
        "url": 556
    },
    {
        "nl_input": "The query requires functionality to batch set quotas for a user with admin privileges, specifically when `openTag` is 0, and includes removing admin rights. The needed code should allow setting an admin address (non-zero), transferring admin rights, and removing an admin (with checks for valid address and admin status). The operations should be restricted to authorized users (e.g., `onlyOwner` or `onlyAdmin`).",
        "url": 557
    },
    {
        "nl_input": "The query requires a function or check to determine if a game is active. The suitable code should return a boolean indicating the game's active status based on a game identifier. The first code snippet fits this requirement with its `activeGame` function, which checks if the game exists and is active, returning `true` or `false` accordingly. The other snippets handle game initialization and modifiers but do not directly check the game's active status.",
        "url": 558
    },
    {
        "nl_input": "The query requires a function that writes or manipulates data in a pyramid grid structure, likely involving array operations for indexes and colors, with potential validation checks. The function should handle grid-based operations similar to pixel manipulation in a canvas, ensuring data integrity and possibly reverting if no changes are made. The focus is on writing/updating grid elements rather than just reading data.",
        "url": 559
    },
    {
        "nl_input": "The query requires information about token-related functions in smart contracts, specifically focusing on total supply, token conversion from ether, and decimal precision. The relevant functions include `totalSupply()` returning the number of tokens, `howManyTokensForEther()` calculating token amounts from wei, and `tokenDecimals()` providing the token's decimal precision. (58 tokens)",
        "url": 560
    },
    {
        "nl_input": "The query requires a function that calculates and returns the MET token amount equivalent to a given ETH deposit. The function should accept an ETH amount as input and return the corresponding MET value based on a conversion rate or logic. The expected output is a uint256 value representing the MET tokens for the provided ETH. The function should be viewable (read-only) and handle the ETH to MET conversion internally.",
        "url": 561
    },
    {
        "nl_input": "The query requires a function that disapproves a user's KYC (Know Your Customer) status by setting their `hasKYC` flag to false and emitting a corresponding event. The function should be restricted to a KYC manager and update the user's status in a mapping. The provided code snippet demonstrates this functionality with a `disapproveUserKYC` function that takes a user's address as input and updates their KYC status.",
        "url": 562
    },
    {
        "nl_input": "The query requires a smart contract function that unpauses the contract, changing its state from paused to unpaused. The function should include access control (e.g., `onlyManager` or `onlyOwner`) and a `whenPaused` modifier to ensure it only executes when the contract is paused. Optionally, it may emit an event (e.g., `Unpause`) or interact with a token's unpause function. The core action is setting `paused = false`.",
        "url": 563
    },
    {
        "nl_input": "The query requires a function to sell a specified amount of tokens to a contract, ensuring the transfer is validated and executed correctly. The function should check token availability, handle the transfer, and update the contract state accordingly. The amount specified is minimal (1e-18 HERE), indicating precision handling is needed. The function may also involve price calculations, balance checks, and event updates post-transaction.",
        "url": 564
    },
    {
        "nl_input": "The query requires a function that allows updating the maximum gas price, ensuring the new value is greater than zero and restricted to authorized or owner-only access. The function should assign the new gas price to a state variable. The first code snippet meets these requirements with its `updateMaxGasPrice` function, which includes a check for positive values and an `onlyOwner` modifier. The other snippets are irrelevant as they handle different functionalities.",
        "url": 565
    },
    {
        "nl_input": "The query requires a smart contract function that allows purchasing artworks triggered by a LikeCoin transfer callback. The function should handle payment, validate the transaction, transfer the artwork to the buyer, and update relevant state variables (e.g., balances, artwork counts). It must ensure the payment matches the artwork's cost and emit an event for the purchase. The solution should integrate with an existing token transfer mechanism (LikeCoin) to enable seamless artwork purchases.",
        "url": 566
    },
    {
        "nl_input": "The query requires information about ICO (Initial Coin Offering) methods in smart contracts, specifically functions related to checking ICO status, activating ICO status, and transferring tokens during an ICO. The functions should handle time validation, status updates, and secure token transfers with necessary checks. The description should be concise, focusing on the core ICO-related functionalities without detailed code analysis.",
        "url": 567
    },
    {
        "nl_input": "The query requires a function that enables a coin holder to increment the vote count for a specific option in an active ballot. The function should validate the ballot's active status, ensure the voter has sufficient balance, check the option's validity, and update the vote count accordingly. The solution should prevent double voting and track the voter's participation. The focus is on secure, transparent, and efficient ballot participation within a smart contract environment.",
        "url": 568
    },
    {
        "nl_input": "The query requires a modifier that ensures a function can only be called by the `pendingOwner` account, throwing an error if called by any other account. The modifier should include a `require` statement to check the caller's address against `pendingOwner` and proceed with `_;` if the condition is met. This enforces access control specific to the `pendingOwner` role.",
        "url": 569
    },
    {
        "nl_input": "The query requires checking if an address represents a certificate authority (CA) by verifying if the address has a non-empty lookup API in a certificate authority mapping. The suitable code snippet confirms this by checking the length of the `lookup_api` bytes for the given address. The expected output is a boolean indicating whether the address is a CA. Other provided codes are irrelevant as they involve removing a CA or checking certification status.",
        "url": 570
    },
    {
        "nl_input": "The query requires a smart contract function that distributes winnings (bounty and bonds) to all participants who provided the accepted answer. The function should handle multiple beneficiaries, calculate individual shares, and transfer the funds accordingly. It should also manage any referral bonuses or additional fees, ensuring proper allocation of the prize pool and other rewards. The solution must be implemented in Solidity for Ethereum smart contracts.",
        "url": 571
    },
    {
        "nl_input": "The query requires information about the crowdsale process and token manipulation functions in smart contracts. This includes minting tokens for pre-crowdsale investors, finalizing the crowdsale by minting remaining tokens and stopping further minting, and transferring tokens to distribution addresses while changing ownership after the crowdsale ends. The focus is on functions that handle token distribution, minting, and ownership transfer during different stages of a crowdsale.",
        "url": 572
    },
    {
        "nl_input": "The query requires identifying code snippets related to checking if a soft cap (a minimum funding target) has not been reached in a smart contract. The relevant code includes functions or modifiers that check the soft cap status, such as setting the soft cap, verifying the contribution period, or ensuring the funding goal is not met. The focus is on conditions where the raised amount is below the soft cap threshold.",
        "url": 573
    },
    {
        "nl_input": "The query requires identifying code that sets or modifies a reward divisor variable in a smart contract. The relevant code should include a function that updates the divisor value, typically with owner-only permissions. The first code snippet meets this need with a `setRewardDivisor` function that changes the `rewardDivisor` variable. The other snippets handle reward calculations or additions but do not adjust a divisor. The query focuses on divisor configuration, not reward computation or distribution.",
        "url": 574
    },
    {
        "nl_input": "The query requires a smart contract function that creates a new series or collection of items, with checks for ownership, validity of inputs, and initialization of series properties. The function should emit an event upon successful creation and handle conditions like existing series or invalid parameters. Examples include creating a series with a name and root hash, batch spawning assets, or generating promotional items with specific attributes.",
        "url": 575
    },
    {
        "nl_input": "The query requires a function that returns the number of coins owned by a specific address. The function should take an address parameter and return a numeric value representing the coin count. The function can be named `countByOwner` or `balanceOf` and should be marked as `constant` or `view` to indicate it does not modify the contract state. The return type can be `uint` or `uint256`.",
        "url": 576
    },
    {
        "nl_input": "The query requires a smart contract function that finalizes or ends a specific stage (Genesis) by transferring tokens to designated addresses, updating the stage, and ensuring only the owner can execute it. The function should include checks for the current stage and ownership permissions.",
        "url": 577
    },
    {
        "nl_input": "The query requires a function that allows a maker to propose an oracle, involving steps like checking the maker's balance, deducting a fee, and emitting an event to record the proposal. The function should handle parameters like an IPFS hash and the taker's address, and return an index for the proposed oracle. The proposal should be stored in a mapping for future reference.",
        "url": 578
    },
    {
        "nl_input": "The query requires a function to transfer ownership of a proxy contract from the current owner to a new owner, ensuring the old owner is removed. The function should include checks for valid addresses and restrict access to only the current owner. The solution should handle the ownership transfer securely and emit an event if necessary. The provided code snippets show different implementations of ownership transfer functions, which can be adapted to meet these requirements.",
        "url": 579
    },
    {
        "nl_input": "The query requires a smart contract function that allows anyone to donate tokens to a manufacturer's pool. The function should validate the manufacturer ID and token amount, transfer tokens from the donor to the pool, and emit an event for the transaction. The deposit should only proceed if the manufacturer exists and the amount is positive. The function must return a boolean indicating success.",
        "url": 580
    },
    {
        "nl_input": "The query requires a function to retrieve a user's balance. The suitable code should include a function that takes a user's address (or uses the sender's address) and returns their balance, typically using a `balanceOf` or similar method. The function should be view or constant to avoid state changes. The balance can be for tokens or ether, depending on the context. The result should be a uint representing the balance.",
        "url": 581
    },
    {
        "nl_input": "The query requires a function to revoke permission from a wallet to freeze tokens. The suitable code should modify a wallet's `canFreezeTokens` attribute to `false` and emit an event to reflect this change. The function should be restricted to the contract owner and handle one or multiple wallet addresses. The expected output is a boolean confirming the operation's success.",
        "url": 582
    },
    {
        "nl_input": "The query requires a function that handles fund transfers to a smart contract, triggered by a user or another contract. The function should include checks for sufficient balance, proper transfer execution, and possibly differentiate between transfers to contracts and regular addresses. It may also involve owner restrictions or internal handling of the transfer process. The goal is to securely move funds while ensuring transaction validity and proper execution.",
        "url": 583
    },
    {
        "nl_input": "The query requires a function that allows the contract owner to withdraw unsold tokens after an auction ends. The function should check if the auction is over and tokens remain unsold, then transfer these tokens to a specified recipient. Key features include owner-only access, post-auction timing validation, and token transfer logic. The description fits scenarios where unsold tokens need to be reclaimed post-crowdsale or auction.",
        "url": 584
    },
    {
        "nl_input": "The query requires a function that calculates the conversion of fees to tokens, considering factors like contribution amount, token supply, and pledged fees. The function should return the number of new tokens based on these inputs, with potential for future updates to the calculation logic. The preferred implementation involves detailed computation using previous and initial token supplies, as well as total pledged fees.",
        "url": 585
    },
    {
        "nl_input": "The query requires a function to approve a new borrower, which involves setting a borrower's address as approved. The suitable code should include a function that takes a borrower's address as input and updates their approval status, typically controlled by an owner or authorized sender. The function may also emit an event or return a confirmation status. The focus is on borrower approval rather than token or allowance approvals.",
        "url": 586
    },
    {
        "nl_input": "The query requires a description of how to look up the current token price in a smart contract. The suitable code should include a function that retrieves the token price, considering conditions like auction stages or pre-ICO status, and may involve calculations or updates based on predefined rules. The function should return the price directly or compute it dynamically. The description should be concise, focusing on the price retrieval mechanism.",
        "url": 587
    },
    {
        "nl_input": "The query requires a function that returns the total number of games. The suitable code should include a method like `getTotalGames()` that retrieves and returns the length of a games array or similar data structure. The description should focus on the need to count and return the total games, not individual game details or calculations. The first code snippet meets this requirement by returning `games.length`.",
        "url": 588
    },
    {
        "nl_input": "The query seeks code snippets related to interface markers in smart contracts. The requirements include functions for setting interface addresses, retrieving symbol strings, and operational modifiers. The relevant code should involve interface declarations, address assignments, and conditional checks for contract operations. The focus is on contract functionality that interacts with or verifies interfaces.",
        "url": 589
    },
    {
        "nl_input": "The query requires a getter function for the `paused` variable in a smart contract. The suitable code is the first option, which provides a public constant function `getPaused()` that returns the boolean value of `paused`. The other options are unrelated as they modify the `paused` variable rather than retrieving its value. The description should focus on the need for a simple accessor function to check the paused state. (60 words)",
        "url": 590
    },
    {
        "nl_input": "The query requires a function to check if a given key (address) is registered. The function should return a boolean or status indicating registration status by checking if the key exists in a record, allowed addresses list, or a pool. Examples include checking if the key's time is non-zero, if it's in an allowed addresses mapping, or if it's contained in a pool. The result should clearly indicate registered or not-registered status.",
        "url": 591
    },
    {
        "nl_input": "The query requires functions related to checking or modifying the status of a contract, such as sale status, action status, or ICO status. The functions should return status information (e.g., boolean, struct) or allow status updates (e.g., activating an ICO). The expected output includes status checks like `saleStatus()` or `getActionStatus()`, or status modifiers like `activateICOStatus()`.",
        "url": 592
    },
    {
        "nl_input": "The query requires checking a user's REB balance tier based on predefined thresholds. The suitable code returns a string indicating the tier (Platinum, Gold, Titanium, or Free) or if the user possesses no REB, depending on the balance amount. The balance thresholds are 1,000,000, 700,000, and 300,000 REB, with 0 indicating no REB. The function `checkBalanceTier` in the first code snippet meets this requirement.",
        "url": 593
    },
    {
        "nl_input": "The query requires creating a new promotional team with a specified name and price, assigning it to an address, and handling default values if the owner address is zero or the price is non-positive. The team creation should enforce limits on the number of promo teams and set a default price if necessary. The function should be restricted to the COO (Chief Operating Officer) role.",
        "url": 594
    },
    {
        "nl_input": "The query requires a function that pays the creator upon successful completion of a task or condition. The function should check if the task is complete and successful, then transfer funds or tokens to the creator. If unsuccessful, it should return the remaining tokens. The function may also include burning excess tokens and logging payment events. The solution should ensure only the creator is paid and prevent double payments.",
        "url": 595
    },
    {
        "nl_input": "The query requires overriding the `getRate` function to integrate with an external rate provider, enabling dynamic rate retrieval based on input parameters such as sender address, token amounts, or other relevant values. The function should return a calculated rate, potentially with bonuses or adjustments based on specific conditions or thresholds. The implementation should support both view and state-modifying operations as needed by the provider.",
        "url": 596
    },
    {
        "nl_input": "The query requires a smart contract function that transfers remaining funds to a specified wallet after the contract ends. The function should be restricted to the owner and ensure secure transfer of the contract's balance. The solution should handle the transfer in a way that either completes successfully or reverts if the transfer fails. The focus is on moving funds post-contract completion with owner-only access and transaction safety.",
        "url": 597
    },
    {
        "nl_input": "The query requires a smart contract function that allows a token-holder to authorize another address (spender) to manage their tokens by calling an `approve()` function. The function should validate ownership, update approval status, and emit an approval event. The parameters must include the spender's address and the token amount or ID. The implementation should ensure security checks, such as verifying the caller owns the tokens before granting approval.",
        "url": 598
    },
    {
        "nl_input": "The query requires determining the FARM token rate per 1 ETH based on transaction time and the FARM pricing logic. The relevant code involves functions to set or get the rate, with one contract adjusting the rate based on escrow balance and total supply. The description should focus on how the rate is calculated or updated in relation to ETH.",
        "url": 599
    },
    {
        "nl_input": "The query seeks a convenience function for immediate refunds, requiring the code to check refund eligibility, reset the sender's balance, and transfer the refunded amount. The function should be publicly accessible and may include conditions like unsuccessful sales or owner authorization. The refund process should log the transaction details.",
        "url": 600
    },
    {
        "nl_input": "The query requires a smart contract function that handles token purchases, ensuring the buyer pays the correct price, transfers the tokens, and updates balances. It should validate purchase conditions (e.g., valid buyer, sufficient funds, token availability), calculate the token amount based on the payment, transfer funds to the beneficiary, update token balances, and emit relevant events. The function may also include tiered pricing or limits on purchase quantities.",
        "url": 601
    },
    {
        "nl_input": "The query requires a function to set historical balances for a given address owner, based on snapshot indexes within a specified range. The function should validate inputs (non-zero balance, valid range) and update balances at each level of the snapshot hierarchy, ensuring the balances reflect the state at each snapshot moment. The solution must handle bitwise operations to traverse and update the historical balances efficiently.",
        "url": 602
    },
    {
        "nl_input": "The query requires a function that validates arguments for modifying signature requirement parameters. The validation should ensure the new required number of signatures is not zero and does not exceed the maximum possible (length - 2). It should return false with an error message if these conditions are not met, otherwise return true.",
        "url": 603
    },
    {
        "nl_input": "The query requires a description of how to calculate or retrieve the amount of tokens released for a vesting process. The code snippets show methods to compute vested tokens based on elapsed days, fetch vesting balances for specific addresses, and release vested tokens at scheduled intervals. The description should focus on the logic for determining vested token amounts, including time-based calculations and balance checks. Keep it concise, under 80 words.",
        "url": 604
    },
    {
        "nl_input": "The query requires a description of a Solidity function named `totalSupply` that returns the total token supply as a `uint256`. The function should be either `public` or `external` and marked as `constant`, `view`, or similar, indicating it does not modify state. The returned value can be stored in variables named `totalSupply`, `_totalSupply`, or `totalSupply_`. The function assumes the total supply will not exceed the maximum `uint256` value.",
        "url": 605
    },
    {
        "nl_input": "The query requires a function to retrieve statistical data, such as monster attributes, contribution totals, or player information, from a smart contract. The function should return numerical values or boolean states, possibly in an array or tuple format, based on the input parameters like monster ID or player address. The stats can include base attributes, supply details, or player-specific data.",
        "url": 606
    },
    {
        "nl_input": "The query requires resetting all balances to 0 and setting the state to false. This involves updating the balance of each account to zero and modifying the state (e.g., freezing or refund availability) to false. The operation should ensure no funds remain in any account and the contract reflects an inactive or reset state.",
        "url": 607
    },
    {
        "nl_input": "The query requires a token purchase function that includes anti-money laundering (AML) and Know Your Customer (KYC) checks. The code should validate the buyer's address, ensure non-zero transactions, and track token transfers while maintaining compliance with AML/KYC regulations. The function should also log purchase events and update balances accordingly.",
        "url": 608
    },
    {
        "nl_input": "The query requires a smart contract function that updates a variable (such as news, price setter, or end time) with restricted access (onlyOwner). The function should include an event emission or access control check, and return a boolean or validate input conditions. The examples show functions for setting news, a price setter address, and an end time, all requiring owner privileges and including validation or event triggers.",
        "url": 609
    },
    {
        "nl_input": "The query requires transferring the balance from a sale auction contract to the ZodiacCore contract. The suitable code should include a function that allows the contract owner to withdraw or transfer the contract's balance to another address, ensuring proper authorization and balance checks. The function should handle the transfer securely and update the contract state accordingly.",
        "url": 610
    },
    {
        "nl_input": "The query requires a function that shuts down a contract and removes it from the blockchain state. The most suitable code is the first option, which includes a `shutdown` function that uses `selfdestruct(owner)` to terminate the contract and clear its state, matching the need for complete removal from the blockchain. The other options involve cleanup or deactivation but do not fully remove the contract.",
        "url": 611
    },
    {
        "nl_input": "The query requires a function to delete or remove data, typically used for handling bugs. The suitable code should include functions that remove entries, such as clearing seller data, self-destructing a contract, or removing an address from a blacklist. The focus is on functions that eliminate or reset stored information.",
        "url": 612
    },
    {
        "nl_input": "The query requires a function that retrieves a certification document by its index for a specified student, which is a paid feature. The function should accept the student's address and the document index as parameters, return the document, and ensure the payment fee is processed before execution. The first code snippet meets these requirements with its `getCertificationDocumentAtIndex` function.",
        "url": 613
    },
    {
        "nl_input": "The query requires verifying an investor by checking if their address is registered in a smart contract. This can be done by either iterating through a list of investors or checking a mapping of allowed investors. The result should return a boolean indicating whether the address is a valid investor. The solution may involve functions like `isInvestor` or `isInvestorAllowed` that perform these checks.",
        "url": 614
    },
    {
        "nl_input": "The query requires a function that retrieves comprehensive details about a match, including team names, amounts, participants, win index, completion status, bet amounts, match number, and betting status. The function should return multiple data types (string, uints, bool) in a structured format to provide a complete snapshot of the match's current state.",
        "url": 615
    },
    {
        "nl_input": "The query requires a function that transfers tokens to a specified address but replaces `msg.sender` with another address (e.g., a predefined wallet or token bearer) as the sender. The function should ensure authorization (e.g., only the token bearer or wallet can initiate the transfer) and handle the token transfer logic securely. The solution should bypass the default `msg.sender` and use a designated address for the transfer.",
        "url": 616
    },
    {
        "nl_input": "The query requires a function that allows the contract owner to transfer out any accidentally sent ERC20 tokens, except for the token specifically intended for the contract. The function should be restricted to the owner and should exclude the contract's designated token from being transferred. The solution involves checking the token address and ensuring it is not the contract's token before proceeding with the transfer.",
        "url": 617
    },
    {
        "nl_input": "The query requires updating the `startTimestamp` property with a new `_start` value, ensuring it is less than `endTimestamp` and greater than the current time. The old value should be stored before updating, and an event should be emitted to log the change. The function must be restricted to admin access and return a boolean upon success.",
        "url": 618
    },
    {
        "nl_input": "The query requires creating a new offer with a specific setting. The code should include a function that accepts a setting parameter, validates it (e.g., ensuring it is greater than zero), and processes the offer creation. The function may also involve payment validation (e.g., requiring a non-zero value) and internal logic to finalize the offer. The solution should focus on offer creation with configurable settings, not team promotions or price setting.",
        "url": 619
    },
    {
        "nl_input": "The query requires a function to transfer a balance from the sender's address to a specified address `_to` with additional data `_data`. The function should check sender's balance, update balances, and handle the transfer with the provided data. It should return a boolean indicating success and may include checks for valid addresses and sufficient funds. The transfer should emit an event with sender, recipient, value, and data.",
        "url": 620
    },
    {
        "nl_input": "The query requires setting the current DOL prices through a smart contract function that updates the price value, restricted to the owner, with checks to ensure the new price is valid (non-zero or greater than the current price). The function names vary (`setPrice`, `setPriceRate`), but all include owner-only access and price validation.",
        "url": 621
    },
    {
        "nl_input": "The query requires a description of adding a Kin token vesting grant, which involves functions to unlock vested tokens, check vesting balances, and calculate non-vested tokens. The code snippets provided include methods for transferring vested tokens to the grantee, retrieving vesting balances, and computing the amount of tokens that are not yet vested. The description should focus on the vesting mechanism for Kin tokens, including unlocking and balance checks.",
        "url": 622
    },
    {
        "nl_input": "The query requires a smart contract function to freeze tokens by specifying a target address. The function should allow locking tokens either for a single address or multiple addresses, with optional parameters like amount and duration. It should include checks for valid addresses and sufficient balances, update the frozen state, and emit relevant events. The implementation can vary from simple boolean freezes to more complex time-based or amount-based freezing mechanisms.",
        "url": 623
    },
    {
        "nl_input": "The query requires retrieving all relevant information about a specific waifu, including the waifu's name, selling price, and owner address, based on a given token ID. The information should be returned in a structured format with these three fields. The first code snippet is the most suitable as it directly provides these details through the `getWaifu` function.",
        "url": 624
    },
    {
        "nl_input": "The query requires a function that assigns a new address to the CEO role, ensuring the new address is not zero and is only callable by the current CEO. The function should update the CEO address in the contract. The first code snippet meets these requirements with its `setCEO` function. The other snippets handle different roles (shareholder, administrator) and do not match the CEO assignment need.",
        "url": 625
    },
    {
        "nl_input": "The query requires a function that retrieves the amount of released tokens for a specified address. The suitable code is the first one, which includes a function `releasedTokenOf` that returns the `releasedTokens` value for a given `_owner` address. The other codes do not meet this requirement as they involve creating tokens or removing received tokens, not querying released tokens. The description should focus on the need to fetch released token amounts for an address.",
        "url": 626
    },
    {
        "nl_input": "The query seeks code related to handling predator attacks in a smart contract, specifically focusing on functions that manage attack callbacks, animal killings, and gas cost calculations. The desired code should include mechanisms for triggering attacks, processing results, and distributing rewards after accounting for gas expenses. The functionality should involve random number generation for determining attack outcomes and updating game states accordingly.",
        "url": 627
    },
    {
        "nl_input": "The query requires functionality to extend the ICO (Initial Coin Offering) end date. This involves modifying the smart contract to allow updating the ICO end date, typically restricted to authorized roles (e.g., owner or whitelisted addresses), with validation checks to ensure the new date is logical (e.g., after the current time and start date). The solution should include a function to set or update the ICO end date while maintaining security and pause features.",
        "url": 628
    },
    {
        "nl_input": "The query requires a function that allows a pre-approved user to take ownership of a specific color (or token) by verifying their approval status and transferring ownership from the current owner to the approved user. The function should check for valid addresses and ensure the caller is authorized before executing the transfer.",
        "url": 629
    },
    {
        "nl_input": "The query requires a function that sends pooled ETH to a specified address, calculates any unused ETH for refund, and transitions the contract to stage two. The function should include checks for contract stage, valid receiver address, and sufficient balance, with gas handling for the transfer. It should also emit an event upon successful submission and handle refunds if remaining balance exists.",
        "url": 630
    },
    {
        "nl_input": "The query requires a description of a function that retrieves connection details between entities, including their active statuses, connection data, direction, and expiration. The function should accept entity and connection addresses along with a connection type, and return a tuple with these fields. The description should be concise, within 80 words.",
        "url": 631
    },
    {
        "nl_input": "The query requires information about smart contract conditions related to locking mechanisms. Specifically, it seeks code snippets that check if a contract is not locked (using `!locked`), locks a contract (setting `locked = true`), or enforces actions when a contract is locked (using `require(locked)`). The relevant modifiers and functions include `notLocked`, `lock`, and `whenLocked`.",
        "url": 632
    },
    {
        "nl_input": "The query requires checking if a sequence can be represented in the form of 4815162342 followed by any number of zeros (e.g., 481516234200...). The relevant code should verify if the given sequence matches this pattern by comparing it to 4815162342 multiplied by a power of 10. The other provided codes do not address this specific requirement.",
        "url": 633
    },
    {
        "nl_input": "The query requires calculating a fee from the losing portion of a total pot, where the fee is a percentage of the remaining amount after deducting the winners' pot. The fee is then subtracted from the remaining amount, and the result is returned. The calculation should handle cases where the remaining amount is zero. The fee percentage is applied to the remaining amount, and the total fee is stored. The final output is the remaining amount minus the fee.",
        "url": 634
    },
    {
        "nl_input": "The query requires updating network constants if necessary, as seen in the third code snippet where `REGISTRATION_COST` is updated. The first two snippets show constant functions (`currentBonus` and `currentRound`) that fetch data without modification, indicating the need is for updating, not just reading, constants. The description focuses on modifying network constants when conditions (like owner authorization) are met. (58 words)",
        "url": 635
    },
    {
        "nl_input": "The query requires a code snippet that handles the initial token allocation to founders' addresses. The suitable code should include a function that transfers tokens to specified founder addresses, ensuring the allocation is performed only once and by the authorized owner. The code should also validate the addresses and amounts before transferring the tokens. The first provided code snippet meets these requirements by transferring tokens to founders, support, and bounty addresses while checking allocation status and owner authorization.",
        "url": 636
    },
    {
        "nl_input": "The query requires a function that creates and stores a new promise object, updates the promised token balance, and includes details like recipient address, amount, lock period, and state. The function should log the creation of the promise and return the promise object. The first code snippet meets these requirements by handling promise creation, balance updates, and logging, while the other snippets are unrelated to promise management.",
        "url": 637
    },
    {
        "nl_input": "The query requires a function to transfer tokens from an allowance, involving updating balances and allowances between addresses. The function should deduct tokens from the sender's allowance, adjust balances for both sender and receiver, and emit a transfer event. It must return a success status and handle token transfers securely, ensuring proper authorization and validation checks. The target contract should support delegated transfers where one party can transfer tokens on behalf of another.",
        "url": 638
    },
    {
        "nl_input": "The query requires a function that performs a batch transfer of a fixed value (`_value`) to multiple receivers (`_receivers`). The function should check that the receivers are not frozen, the sender has sufficient balance, and the transfer amount is valid. It should also handle the transfer logic and emit an event for each transaction. The function must ensure the number of receivers is within a specified limit (e.g., 1 to 100).",
        "url": 639
    },
    {
        "nl_input": "The query requires the total supply of a token, which can be obtained by calling the `totalSupply()` function in a smart contract. This function returns the supply as an unsigned integer (uint or uint256) from variables like `numTokens`, `_totalSupply`, or `totalSupply`. The exact variable name depends on the contract implementation.",
        "url": 640
    },
    {
        "nl_input": "The query requires a function to start a crowdsale, which should be callable only by the owner. The function should set the crowdsale state to active, record the start time or block, and potentially handle phase transitions or other initialization logic. The crowdsale should not be already started or should meet certain preconditions (like presale conclusion) before activation. Optionally, it may emit an event to signal the start.",
        "url": 641
    },
    {
        "nl_input": "The query requires code that removes or deletes a contract or its associated data. The desired functionality includes deleting auction data by ID, removing seller information from a sale list, or deactivating a contract by address while maintaining data integrity. The operation should be internal or restricted (e.g., to the owner) and may involve clearing mappings, resetting values, or adjusting array indices.",
        "url": 642
    },
    {
        "nl_input": "The query requires changing the `coldWallet2` address in a smart contract. The suitable code must include a function that updates the `coldWallet2` address, checks that the new address is not zero, and restricts access to the contract owner. The function should be named `setColdWallet2` or similar, with the parameter `_coldWallet2`, and include the `onlyOwner` modifier and a zero-address check.",
        "url": 643
    },
    {
        "nl_input": "The query requires a smart contract function that allows users to pay using mileage points. The function should check the sender's address, validate the payment amount, deduct the points from the sender's balance, and potentially mint items or heroes based on random values. The best match is the first code snippet, which implements these features, including amount validation, point deduction, and hero summoning based on random probabilities.",
        "url": 644
    },
    {
        "nl_input": "The query requires a description of how to approve a proxy for token transfers in a smart contract. The code examples show functions that handle approval by verifying ownership, transferring tokens, and emitting approval events. The key elements include checking ownership, approving the transfer, and ensuring the recipient is valid. The functions use `approve` to authorize another address to manage tokens, with checks to prevent invalid transfers. The description should focus on these core mechanisms for proxy approval in token transfers.",
        "url": 645
    },
    {
        "nl_input": "The query requires checking if a given zodiac is ready to breed by verifying two conditions: the zodiac is not currently siring (siringWithId == 0) and its cooldown period has ended (cooldownEndBlock <= current block number). The breeding readiness is determined by these internal state checks.",
        "url": 646
    },
    {
        "nl_input": "The query requires a smart contract function that allows users to deposit funds, which can be in the form of tokens or Ether, and updates the user's balance accordingly. The function should include checks like whitelisting or successful transaction completion and emit an event to log the deposit details. The deposit can be for a specific token or the native currency, with the balance being tracked and updated post-deposit.",
        "url": 647
    },
    {
        "nl_input": "The query requires a method that allows anyone to withdraw funds to a specified wallet after a locking period ends. The method should check if the locking period has concluded and ensure the withdrawal status is inactive before transferring tokens. The code should include conditions to verify the lock time and status, then execute the transfer to the designated wallet. The solution must be publicly callable and handle token transfers securely.",
        "url": 648
    },
    {
        "nl_input": "The query requires a function that concatenates two strings and returns a newly allocated string containing the combined result. The first code example demonstrates this by concatenating two string slices (`self` and `other`) into a new string, while the second example appends a uint to a string. The third example is unrelated. The core need is string concatenation with memory allocation.",
        "url": 649
    },
    {
        "nl_input": "The query requires executing a multi-signature transaction from a wallet using two signers, where one signer is the `msg.sender`. The transaction should involve verifying signatures, handling the transfer of value, and logging the transaction details. The code must support multi-signature operations, including signature verification and transaction execution, while ensuring security checks like expiration and sequence validation.",
        "url": 650
    },
    {
        "nl_input": "The query requires identifying code snippets related to unlocking or issuing tokens in smart contracts. The relevant functions include issuing tokens with optional locking, unlocking vested tokens based on grant conditions, and releasing team tokens from a timelock. The focus is on mechanisms that manage token distribution and release under specific conditions or time-based locks.",
        "url": 651
    },
    {
        "nl_input": "The query requires a function to distribute dividends to shareholders. The function should verify eligibility, calculate the dividend amount based on shares, update shareholder balances, and transfer the payment. It may include checks for valid conditions (like non-zero values or specific start times) and emit events for tracking dividend transactions. The function should handle the dividend distribution process securely and efficiently.",
        "url": 652
    },
    {
        "nl_input": "The query requires a function to disable or modify the whitelist state in a smart contract, specifically to turn off whitelist functionality or remove addresses from the whitelist. The desired code should include a public function that can be called by the owner to update the whitelist status or remove individual addresses, emitting an event if necessary. The function should return the updated whitelist state or perform the removal without a return value.",
        "url": 653
    },
    {
        "nl_input": "The query requires identifying code that ensures a function or modifier can only be executed after the presale has concluded. This involves checking conditions like presale end time, presale finalization status, or crowdsale closing time before allowing the execution of certain operations. The relevant code snippets include checks for `preSaleEnd >= now`, `isPresaleFinalized`, `presaleGoalReached()`, and `block.timestamp > CROWDSALE_CLOSING_TIME`.",
        "url": 654
    },
    {
        "nl_input": "The query requires a function to cancel any outstanding multisig call. The suitable code should include checks for authorization, verify if there is a call to cancel, and then clear the call records. The function should return status codes indicating success or failure reasons (e.g., unauthorized, nothing to cancel). The cancellation should emit events for transparency and reset the relevant storage variables to null or zero.",
        "url": 655
    },
    {
        "nl_input": "The query requires a smart contract function that allows users to withdraw their Ether, including any fees, ensuring a full refund. The function should check the user's balance, transfer the Ether back to the user, and reset their balance to zero. The refund process should be conditional, typically triggered if certain conditions (like a failed sale) are met. The function should also handle the transfer securely and emit an event if necessary.",
        "url": 656
    },
    {
        "nl_input": "The query requires public methods in a smart contract that can only be called by owners, specifically for giving or taking actions. Examples include transferring ownership, recovering ethers, or sending tokens, all restricted by an `onlyOwner` modifier. The methods must ensure only the contract owner can execute them.",
        "url": 657
    },
    {
        "nl_input": "The query requires a function that transfers tokens from an Ethereum fund deposit (ethFundDeposit) to a user. The function should check sender authorization, ensure sufficient deposit balance, execute the token transfer, and update the deposit balance accordingly. The token transfer should be secure and properly handle the reduction of the deposit amount.",
        "url": 658
    },
    {
        "nl_input": "The query requires creating tokens that are only usable during an active sale period. The sale must enforce specific conditions: tokens can only be purchased within a defined timeframe, with limits on the number of tokens per transaction (1-10), and pricing tiers based on the number of tokens sold. The sale must also ensure sufficient token supply and correct ownership before distribution.",
        "url": 659
    },
    {
        "nl_input": "The query requires a smart contract function that adds an element (address or value) to a data structure (like a set or reward pool) or updates a state variable. The function should handle address inputs and may include checks or modifiers (e.g., `onlyOwner`). The addition can be for rewards, members, or general storage. The expected output is a boolean indicating success or a state update without a return value.",
        "url": 660
    },
    {
        "nl_input": "The query requires a function that allows the contract owner to withdraw any ERC20 tokens from the contract. The function should take the token address and amount as parameters, ensure only the owner can call it, and transfer the specified tokens to the owner's address. The function should return a boolean indicating success or use a safe transfer method to handle potential failures.",
        "url": 661
    },
    {
        "nl_input": "The query requires a mechanism to seal or finalize a Crowdsale contract upon completion, ensuring all conditions are met (like time expiration or funding goals reached), transferring funds or enabling refunds accordingly, and marking the Crowdsale as finalized to prevent further actions. The solution should include checks for completion criteria, handle fund distribution or refunds, and emit events to confirm finalization.",
        "url": 662
    },
    {
        "nl_input": "The query requires extracting the `totalSupply` value from a smart contract. The code examples show different implementations of the `totalSupply` function, which returns the total token supply as a uint or uint256. The function can be marked as `constant`, `public constant`, or `public view`, but all variants serve the same purpose of retrieving the total supply. The query's need is to access this value from a contract's `totalSupply` function.",
        "url": 663
    },
    {
        "nl_input": "The query requires a function that enables a requester to cancel their adoption request for a specific cat. The function should verify the requester's identity, refund the adoption fee, and remove the request from storage, emitting an event to confirm cancellation. The first code snippet meets these requirements by checking the requester's address, transferring the price back, and clearing the adoption request.",
        "url": 664
    },
    {
        "nl_input": "The query requires a function that creates, accepts, and adds additional details to a payment request as a payer. It should validate sender and payee addresses, calculate fees, update request data, and store Bitcoin addresses. The function must ensure correct payment amounts and handle refunds. The payer must not be the main payee, and fees must match the sent value. The request ID is generated and returned after processing.",
        "url": 665
    },
    {
        "nl_input": "The query requires a function or logic to calculate the amount of tokens a sender is purchasing based on the provided payment (e.g., in ether or wei). The calculation should consider factors like exchange rates, bonuses, and hard caps, and may involve converting the payment value to tokens using a specified rate or formula. The result should return the token amount and optionally other related values like USD equivalent.",
        "url": 666
    },
    {
        "nl_input": "The query requires a description of how to handle or return variable-length arrays in Solidity smart contracts. The provided code examples demonstrate different methods for returning dynamic data, such as concatenating strings (which are dynamic arrays) or returning the length of dynamic arrays (like `games.length` or `biggestDicks.length`). The focus is on managing dynamic data structures in Solidity functions.",
        "url": 667
    },
    {
        "nl_input": "The query requires a smart contract function to set up a token sale, including parameters like initial date, token address, and ensuring proper ownership and supply conditions before activation. The function should transition the contract to a ready state upon successful setup.",
        "url": 668
    },
    {
        "nl_input": "The query requires a function that allows the contract owner to lock the contract. The function should be restricted to the owner, update the locked state, and emit an event when locked. The lock should be irreversible or toggleable, and may include conditions like checking if already locked or setting lockup times for specific addresses.",
        "url": 669
    },
    {
        "nl_input": "The query requires a function to create a company or similar entity with parameters including a name, owner address, and price. The function should validate the price, assign a unique ID, and handle ownership transfer. Optional features include setting default values for price or owner, enforcing creation limits, and emitting events upon creation. The code should be part of a smart contract with access control, such as only allowing specific roles (e.g., COO) to execute the function.",
        "url": 670
    },
    {
        "nl_input": "The query requires setting the `cooldownEndTime` for a Dog based on its current `cooldownIndex`. This involves calculating the end time using the cooldown duration (from an array `cooldowns`) divided by `secondsPerBlock`, then adding the current block number. If the `cooldownIndex` is less than 13, it should be incremented by 1. The operation is performed on a Dog struct stored in storage.",
        "url": 671
    },
    {
        "nl_input": "The query requires descriptions of smart contract functions that perform update operations, such as modifying addresses, values, or permissions. The functions include updating operation details, upgrading contract editors, and changing minting agent statuses, all involving state changes within the contracts. Each function restricts access through modifiers like `private`, `only_editors()`, or `onlyOwner`. The operations involve address assignments, value updates, and permission toggles, typically emitting events or returning statuses.",
        "url": 672
    },
    {
        "nl_input": "The query requires a description of how to assign the proceeds of a buyout, including distributing funds to the current owner, beneficiaries, referrers, and prize pools, while handling fees and bonuses. The process involves sending winnings to the current owner, dividends to beneficiaries, referral bonuses, and adding remaining funds to the prize pool or fees. It also checks for valid addresses and handles cases where referrers are absent.",
        "url": 673
    },
    {
        "nl_input": "The query requires a function that retrieves the current RDN price in WEI during an auction. The function should return the price at the time of calling, considering auction-specific conditions like bids or starting prices. The expected output is a uint256 value representing the price in WEI. The function should be viewable (constant) and handle auction logic such as minimal raises or default start prices if no bids exist.",
        "url": 674
    },
    {
        "nl_input": "The query requires a function that approves the transfer of a specified amount of tokens from the transaction creator to a recipient. The function should update the allowance and emit an approval event. The recipient's address and the token amount must be specified as parameters, and the function should return a boolean indicating success. The implementation should ensure proper authorization and state updates.",
        "url": 675
    },
    {
        "nl_input": "The query requires a modifier that ensures a function can only be executed if the crowdsale is active. The modifier should check the crowdsale's running status (e.g., `!isCrowdsaleStopped` or `running`) before allowing execution, similar to the `isRunning` modifier in the third code snippet but adjusted for crowdsale conditions. The solution should prevent execution when the crowdsale is not active.",
        "url": 676
    },
    {
        "nl_input": "The query seeks code snippets that define functions for adding or modifying access permissions, such as adding bonus members, setting access managers, or designating successors, with specific conditions or restrictions like admin or owner privileges. The functions should handle address parameters and include validation checks.",
        "url": 677
    },
    {
        "nl_input": "The query requires locking the DAICO supply until a specific date and time (2018-09-01 14:00:00), ensuring the funds cannot be accessed before the set deadline. The code should include a locking mechanism, a time-based restriction, and owner-only access to enforce the lock until the specified timestamp. The solution must prevent early unlocking and emit events for transparency.",
        "url": 678
    },
    {
        "nl_input": "The query requires adjusting gas reimbursement during transfers when the sender's account balance falls below a minimum threshold. This involves monitoring account balances and dynamically modifying gas fees to ensure successful transactions while maintaining account solvency. The solution should include conditional checks for balance levels and automatic gas adjustments to prevent failed transactions due to insufficient funds.",
        "url": 679
    },
    {
        "nl_input": "The query requires a function enabling the owner or ICO contract to transfer tokens during the ICO phase, with checks for valid recipient, sufficient balance, active token state, and authorization (e.g., `onlyOwner` or `msg.sender == ico`). It should update balances, emit transfer events, and may include ICO-specific parameters (e.g., frozen periods).",
        "url": 680
    },
    {
        "nl_input": "The query requires a function to transfer tokens from a contract's balance, involving checks for valid addresses and token amounts, updating balances, and emitting a transfer event. The function should ensure the sender is authorized and handle token deductions and additions securely.",
        "url": 681
    },
    {
        "nl_input": "The query requires a smart contract function that accepts Ether (msg.value) to purchase tokens on behalf of a user. The function should validate the transaction, calculate the token amount based on the Ether sent, transfer the tokens to the beneficiary, and handle the Ether transfer securely. Key features include input validation, token issuance, and proper fund management. The function may also emit events for transaction tracking.",
        "url": 682
    },
    {
        "nl_input": "The query requires checking if a given account is allowed to buy tokens. The relevant code is the first snippet (`contract c15078`), which includes a `require` statement to ensure the account (`msg.sender`) is not frozen before allowing the purchase. The other snippets handle token purchases but do not explicitly check account permissions. The answer is `true` if the account is not frozen, otherwise, the transaction will revert.",
        "url": 683
    },
    {
        "nl_input": "The query requires a getter function to check if a specified project has been canceled. The function should take a project ID as input and return a boolean indicating the cancellation status. The logic should handle cases where the project might inherit its status from a parent project. The expected output is a simple true/false response based on the project's cancellation state.",
        "url": 684
    },
    {
        "nl_input": "The query seeks code that checks if a market maker contract instance is open for public trading. The requirement involves verifying a public accessibility flag or status in a market maker contract, typically through a function or modifier that returns a boolean indicating whether public trading is allowed. The focus is on the `isOpenForPublic` check or similar public trading status verification.",
        "url": 685
    },
    {
        "nl_input": "The query requires a function that updates a sequence (like an array of values or checkpoints) at the next snapshot or block number. It should handle cases where the sequence is empty, a new snapshot is needed, or the value is modified within the current snapshot. The function must efficiently manage storage and avoid redundant updates. The solution should be similar to `setValue` or `updateValueAtNow` in the provided code snippets.",
        "url": 686
    },
    {
        "nl_input": "The query requires a description of the `proxyPayment()` function, which enables sending ether to a Campaign and creating CampaignTokens in a specified address. The function should handle payments, validate conditions (like contribution limits and dates), calculate token amounts based on timing, update balances, and transfer funds. It may also include bonus calculations, cap checks, and KYC requirements for large contributions. The function must ensure proper token issuance and emit relevant events.",
        "url": 687
    },
    {
        "nl_input": "The query requires a function that checks if a promise can be collected by the recipient. The conditions for collection are: the promise state must be either 'confirmed' or 'pending', and the current block timestamp must be greater than or equal to the 'lockedUntil' timestamp specified in the promise. The function should return a boolean indicating whether these conditions are met.",
        "url": 688
    },
    {
        "nl_input": "The query requires code snippets related to setting or checking start times in smart contracts, including modifiers to enforce time conditions, functions to initiate processes based on start times, and methods to update start timestamps with validation checks. The focus is on time-based controls and updates within contract functions.",
        "url": 689
    },
    {
        "nl_input": "The query requires a smart contract function that allows an admin to finalize a sale, complete token allocations, and handle fund distribution. The function should include checks for sale completion conditions, transfer remaining funds, and update sale status. It may also involve burning unsold tokens, setting reserve balances, and enabling refunds if goals aren't met. The function should be restricted to authorized users and emit events upon finalization.",
        "url": 690
    },
    {
        "nl_input": "The query requires a function to withdraw tokens from a smart contract, ensuring proper checks and transfers. The function should verify conditions like contract closure or finalization, check the sender's balance, and securely transfer tokens to the recipient. It may also handle excess tokens or specific withdrawal scenarios, such as after a sale period or based on ownership rights. The implementation should include safety checks and token transfer mechanisms.",
        "url": 691
    },
    {
        "nl_input": "The query requires a smart contract function that allows purchasing tokens or services on behalf of a specified benefactor. The function should handle payment forwarding, validate the benefactor's address, and update records of payments made by both the purchaser and benefactor. It should also ensure the transaction is reverted if invalid conditions (e.g., zero payment or zero address) are met. The function must securely transfer funds to a multisig wallet.",
        "url": 692
    },
    {
        "nl_input": "The query requires code that compresses transaction data (e.g., timestamps, IDs, team/round identifiers) into structured fields and emits events containing this compressed data during buy/reload transactions. This involves combining parameters like time, player/round IDs, and team details into encoded formats (compressedData, compressedIDs) and triggering events to log transaction details (e.g., amounts, addresses, pot allocations).",
        "url": 693
    },
    {
        "nl_input": "The query requires a smart contract function that permanently stops the minting of tokens. This should be implemented with an `onlyOwner` modifier to restrict access, set a flag to indicate minting is finished, record the stop date, and emit an event to log the action. The function must ensure minting cannot be resumed once stopped. \n\n(Note: The description is exactly 80 words.)",
        "url": 694
    },
    {
        "nl_input": "The query requires a function to add a bonus to a specific block or address. The suitable code should include parameters for specifying the block or address and the bonus amount, with checks for sufficient balance and authorization (e.g., `onlyPrimary` or `onlyOwner`). The function should update the bonus state or balance accordingly. The best match is the first code snippet, which adds a bonus to a block with coordinates (x, y) and checks the bonus balance. (80 words)",
        "url": 695
    },
    {
        "nl_input": "The query requires finding code snippets that implement a function to set or update a rate value in a smart contract. The function should allow authorized users (typically the owner) to modify the rate, possibly with validation checks to ensure the new rate falls within a specified range or meets certain conditions. The rate can be a general value or specifically related to pricing or supply calculations.",
        "url": 696
    },
    {
        "nl_input": "The query requires a function to retrieve the remaining release period of an account's frozen tokens, checking the current time against the release period end time and returning the difference if the period is ongoing, or zero if it has ended. The function should validate the target address and iterate through frozen accounts to find the matching address and stage number.",
        "url": 697
    },
    {
        "nl_input": "The query requires a function that allows users to withdraw or transfer their tokens from a smart contract. The function should check the user's token balance, reset the balance to zero after the transfer, and log the transaction details. The payout should be executed securely, ensuring the user has a positive balance before proceeding. The function should also emit an event to record the payout details, including the recipient's address, the amount transferred, and the transaction timestamp.",
        "url": 698
    },
    {
        "nl_input": "The query requires transferring token ownership after a token sale is completed. The suitable code should include a function that allows the current owner to transfer ownership to a new address, typically with checks to ensure the new owner is valid and the transfer is authorized. The function should be restricted to the owner and should update the ownership state accordingly.",
        "url": 699
    },
    {
        "nl_input": "The query requires a description of how the owner or revoke address can change the revoke address in a smart contract. The relevant code shows a function `setRevokeAddress` that allows the owner or revoke address to update the revoke address, with checks to ensure the new address is not the owner, admin, or ops. The function emits an event upon success. The other functions demonstrate owner changes but are not directly related to revoke address updates.",
        "url": 700
    },
    {
        "nl_input": "The query requires a function or modifier in a smart contract that allows an admin or bankroll to change the bankroll address. The function should have access control to ensure only authorized entities (admin or bankroll) can execute it. The code should include a mechanism to update the bankroll address securely.",
        "url": 701
    },
    {
        "nl_input": "The query seeks to identify if a presale is active by checking conditions such as current time within presale period, presale enablement status, and available presale amount. The code snippets provide functions to verify presale status based on time constraints and presale availability. The requirements involve returning a boolean indicating presale activity, considering factors like time ranges and presale enablement flags.",
        "url": 702
    },
    {
        "nl_input": "The query requires a function that allows a director to open contributions or manage contributions in a smart contract. The function should be restricted to the director's access and handle the opening or resolution of contributions, ensuring proper checks and balances are in place. The description should focus on the director's role in initiating or managing contributions within the contract.",
        "url": 703
    },
    {
        "nl_input": "The query requires information about functions that update or clone token addresses in smart contracts, specifically focusing on operations involving `clonedTokenAddress`. The relevant functions include updating a token address, creating a clone token with specified parameters, and changing a token wallet address, all restricted to the contract owner. The description should highlight these functionalities in under 80 words.",
        "url": 704
    },
    {
        "nl_input": "The query requires a smart contract function that enables self-destruct capability and transfers remaining funds to the owner before destruction. The function should include checks for ownership and handle fund transfers securely. The solution should combine self-destruct (`selfdestruct`) with a mechanism to send any remaining balance to the owner, ensuring only authorized users can trigger it.",
        "url": 705
    },
    {
        "nl_input": "The query requires a function to claim tokens from an economic reserve wallet, ensuring the claim is time-locked, vesting-stage dependent, and checks allocation limits before transferring the unlocked amount to the sender's wallet. The function should also update claimed amounts and emit an event upon distribution.",
        "url": 706
    },
    {
        "nl_input": "The query requires transferring a raised amount to a company address. The suitable code should include a function that securely transfers funds to a specified address, with checks for valid recipient and sufficient balance, and updates the balances accordingly. The function may include owner restrictions or additional data handling. The transfer should be verifiable and revert if conditions are not met.",
        "url": 707
    },
    {
        "nl_input": "The query requires a helper function that calculates the valuation of an asset in terms of ART token quantity. The function should take inputs like valuation and ART token price, perform multiplication and division operations with precision factors, and return the equivalent ART token amount. The solution should handle decimal precision adjustments to ensure accurate conversions.",
        "url": 708
    },
    {
        "nl_input": "The query requires a function that retrieves data associated with a specific ID. The function should return details like the ID and owner or other related information from a stored data structure. The expected output should include the ID and associated attributes, similar to fetching a record by its identifier.",
        "url": 709
    },
    {
        "nl_input": "The query requires counting ELHTs (a specific type of token or entity) tracked by a contract. The relevant code should include a function that returns the count of these tracked items, similar to the examples provided which return lengths of arrays or counts of items (e.g., `games.length`, `ownedCoins[_owner].length`, or `proposals[_rootHash].totalVoters`). The function should be public or constant to allow external queries.",
        "url": 710
    },
    {
        "nl_input": "The query requires initiating a user with default settings upon their first visit. This includes setting initial resource values (5 units each for 5 resources), initial map coordinates (6,6), marking the user as initiated, incrementing the total city count, and logging the resources. The initiation should only occur if the user hasn't been initiated before.",
        "url": 711
    },
    {
        "nl_input": "The query requires a method for users to exchange old proxy tokens for new tokens at a 1:2 ratio, ensuring the old tokens are transferred to the issuer and the new tokens are delivered to the user. The process must validate the user's old token balance and update balances accordingly. The first code snippet (712) matches this requirement by handling the swap, balance checks, and token transfer in a single function.",
        "url": 712
    },
    {
        "nl_input": "The query requires a description of code functionality for buying tokens from sellers. The suitable code should include token purchase logic, handling seller transactions, price calculations, and token transfers between parties. The best match involves internal functions for buying tokens, checking token counts, calculating prices/commissions, transferring funds, and updating token ownership records. The process should ensure proper token substitution, payment handling, and balance updates while preventing self-purchases.",
        "url": 713
    },
    {
        "nl_input": "The query requires a function that calculates the token amount based on the provided wei (Ether in smallest unit) and a rate, considering 18 zeros for wei decimals. The function should handle different wei ranges with varying rates and return the computed token amount. The solution should avoid any excess or additional calculations beyond the specified requirements. The output should be precise and directly derived from the input wei and rate parameters.",
        "url": 714
    },
    {
        "nl_input": "The query requires a function to remove an admin address from a smart contract. The function should verify the admin exists, ensure the caller is authorized, update the admin status, and emit an event if necessary. It should handle the removal from an admin list and prevent self-removal. The solution must be secure, with checks for valid addresses and proper permissions.",
        "url": 715
    },
    {
        "nl_input": "The query requires verifying an address through a smart contract function. The suitable code should include functionality to check or set the verification status of an address, typically restricted to the contract creator or an authorized entity. The expected output is a function that toggles or confirms address verification, ensuring only authorized users can modify the verification status.",
        "url": 716
    },
    {
        "nl_input": "The query requires a Solidity modifier that ensures a function can only be executed by the contract owner. The modifier should check if the sender (`msg.sender`) matches the owner and revert if not. Two correct implementations are provided, while one incorrectly checks for inequality (`!=`). The valid modifiers use `require(msg.sender == owner); _;` to enforce ownership.",
        "url": 717
    },
    {
        "nl_input": "The query requires extracting information about the total tokens or supply from smart contracts. The relevant code snippets include functions that return the total token supply, calculate the total price based on token count and base, and set the total supply during token creation. The focus is on functions like `totalSupply()`, `createTokens()`, and `totalPrice()` which handle token quantities or supply values.",
        "url": 718
    },
    {
        "nl_input": "The query requires a function that retrieves the type of a specified token (long or short) based on its address. The function should take a token address as input and return a value indicating the token type. The first code snippet (contract c2280) matches this requirement by providing a `getTokenType` function that returns the token type for a given address. The other snippets are unrelated to token type retrieval.",
        "url": 719
    },
    {
        "nl_input": "The query requires a function that verifies if a specified owner holds at least a certain amount of shares in a company. The function should check the owner's share balance against the required amount and ensure the amount is valid (greater than 0). The solution should involve accessing the company's shareholder data and performing a comparison to confirm ownership meets the threshold.",
        "url": 720
    },
    {
        "nl_input": "The query requires checking if an ICO (Initial Coin Offering) is active. This involves verifying the ICO status through functions that set the status to 'Active', check if the current time falls within the ICO period, or update the status based on token availability. The relevant code includes functions to activate ICO status, validate ICO timing, and adjust status based on token balances.",
        "url": 721
    },
    {
        "nl_input": "The query seeks to determine whether a token burning process was successful. The relevant code snippets involve functions that manage burning operations, including adding a burner address, executing the burn process, and verifying burner permissions. The success is indicated by return values or state changes, such as setting flags or updating supply values. The description focuses on the mechanisms and conditions that confirm a successful burn.",
        "url": 722
    },
    {
        "nl_input": "The query requires a smart contract function that enables \u0110Apps to accept Bitcoin transfers. The function should handle the transfer process, including address validation and amount checks, and may include additional features like fee calculations or game logic. The contract should be compatible with Ethereum addresses and support secure, verifiable transactions.",
        "url": 723
    },
    {
        "nl_input": "The query requires a description of how many tokens have vested, typically involving calculations based on elapsed time, vesting periods, and amounts. The code snippets show functions that compute vested tokens by comparing elapsed days to vesting days, subtracting transferred amounts, or calculating non-vested tokens. The result should indicate the vested token quantity, often returned as a numeric value (e.g., uint or uint256).",
        "url": 724
    },
    {
        "nl_input": "The query requires a function that calculates the token amount based on the provided Ether (wei) value, considering 18 zeros for wei decimals and 2 zeros for NVT. The function should apply different rates depending on the wei amount: a standard rate for 0.1 to 1 ether and a second-tier rate for 1 ether or more. The result should return the calculated token amount after applying the appropriate rate.",
        "url": 725
    },
    {
        "nl_input": "The query requires code that checks if an order has expired and throws an error if it has. The code should validate the expiration time against the current time or a specified condition to ensure the order is still valid. The focus is on implementing a require or similar check to handle expired orders appropriately.",
        "url": 726
    },
    {
        "nl_input": "The query requires a smart contract function that allows users to reclaim their Ether if their token purchase request is rejected. The function should ensure the Ether is returned when conditions like exceeding the token cap or other validations fail. The third code snippet (url: 555) meets this need by calculating and returning excess Ether (`returnAmount`) if the token purchase exceeds the maximum cap, ensuring users get their Ether back if the transaction is partially or fully rejected.",
        "url": 727
    },
    {
        "nl_input": "The query requires a description of transferring tokens within Lava balances. The suitable code should involve functions that handle token transfers between addresses, update balances accordingly, and include necessary checks like address validity and balance sufficiency. The transfer should emit events or return success status. The focus is on secure and efficient token movement within the specified balances system.",
        "url": 728
    },
    {
        "nl_input": "The query requires a description of internal functions for handling Ethereum transactions, specifically withdrawing Ether. The functions should include checks for balances, transfer Ether to specified addresses, and possibly split amounts between multiple addresses. The functions may also restrict access to the owner or other authorized parties. The goal is to securely manage Ether withdrawals within a smart contract.",
        "url": 729
    },
    {
        "nl_input": "The query requires a function that transfers ERC20 tokens using the standard `transfer` method, wrapped with an `onlyOwner` modifier to restrict access. The function should take the token address and amount as parameters, and return a boolean indicating success. The transfer should be directed to the contract owner. The provided code snippets demonstrate variations of this functionality, all enforcing the `onlyOwner` modifier and using the ERC20 `transfer` method.",
        "url": 730
    },
    {
        "nl_input": "The query requires a function that calculates the result of the expression `x * y / 2^128` (where `^` denotes exponentiation). The solution involves splitting `x` and `y` into high and low 128-bit parts, performing multiplications, and combining the results with bit shifts and additions to avoid overflow, ensuring the final result is within bounds. The `safeAdd` function is used to handle additions safely.",
        "url": 731
    },
    {
        "nl_input": "The query requires a function that checks and distributes funds after an ICO sale closes, ensuring 10% of tokens are allocated for company operating expenses and the remaining 90% for company use, while verifying sale status and deadlines. The function should handle different stages of remuneration and log events for transparency.",
        "url": 732
    },
    {
        "nl_input": "The query requires separating a function so it can be reused by derived contracts. The function should be accessible by child contracts, possibly with modifiers like `onlyOwner` or `onlyEtheraffle`, and may involve state changes or conditions like `sealed = true` or `require(frozen)`. The function should be public or external to allow inheritance and reuse.",
        "url": 733
    },
    {
        "nl_input": "The query requires a function to set the IPFS hash of an image for a couple, which should be callable only by the owner and trigger an event logging the timestamp and details of the action. The function should store the IPFS hash and notify a major event with relevant information.",
        "url": 734
    },
    {
        "nl_input": "The query requires information on how to handle funds after a crowdfunding campaign, specifically either finalizing the campaign by closing the vault if the goal is reached or enabling refunds if the goal is not met. It also needs details on executing refunds to investors when the campaign is unsuccessful. The code snippets cover these aspects: finalization, refund execution, and enabling refunds.",
        "url": 735
    },
    {
        "nl_input": "The query requires a function that allows the contract owner to start or stop trading. The function should be restricted to the owner and toggle a trading status variable. The first code snippet fits this requirement perfectly with its `startTrading` function controlled by `onlyOwner` that updates `tradingStarted`. The other snippets either lack the stop functionality or use different access controls and variable names. The ideal solution is owner-controlled trading enable/disable.",
        "url": 736
    },
    {
        "nl_input": "The query requires code snippets related to updating or tweaking game-related parameters, such as game activation status, game contract addresses, or game outcomes (e.g., win/loss conditions). The focus is on functions that modify game state or settings, including validation checks and conditional updates. Examples include activating a game, updating game contract addresses, or handling player outcomes like wins or losses. The code should involve game logic adjustments or state changes.",
        "url": 737
    },
    {
        "nl_input": "The query requires a function that allows purchasing outcome tokens from a market maker. The function should calculate the cost, including fees, transfer collateral tokens, approve the transaction, and update the net tokens sold. It must ensure the cost is within the specified maximum and emit an event upon purchase. The function should operate only when the market is funded.",
        "url": 738
    },
    {
        "nl_input": "The query seeks a function that handles withdrawals during stage three, ensuring the stage has ended and transferring the contract's balance to a specified address (e.g., creator or owner). The function should include checks for the correct stage and handle transfer failures securely. The withdrawal may involve transferring the full balance or calculated amounts based on conditions. The function should be restricted to authorized roles (e.g., `onlyCreator` or `onlyOwner`).",
        "url": 739
    },
    {
        "nl_input": "The query requires a smart contract function that allows self-upgradability for SCs (smart contracts) even after a lockdown period. The function should enable an SC to upgrade itself to a new address while maintaining security through role-based access control (e.g., `only_editors`). The upgrade process should deactivate the old SC's editing rights and activate the new SC's rights, emitting an event to log the upgrade. Lockdown features should not prevent this self-upgrade capability.",
        "url": 740
    },
    {
        "nl_input": "The query requires a smart contract function to update a whitelist, specifically by setting or changing the whitelist contract address. The function should include access control (e.g., `onlyOperator` or `only_owner`), validate the input address, and assign the new whitelist contract. The expected output is a concise description of these requirements in under 80 words.",
        "url": 741
    },
    {
        "nl_input": "The query requires a function to transfer tokens owned by the contract to another address. The function should handle token transfers securely, ensuring proper authorization (e.g., only the owner or designated wallet can initiate transfers), validate transfer conditions (e.g., positive amount, valid timing), and update balances accordingly. It should also emit events for transparency and return a success status. The transfer must deduct from the sender's balance and add to the receiver's balance.",
        "url": 742
    },
    {
        "nl_input": "The query requires a function to transfer tokens from one address (`_from`) to another (`_to`) on behalf of the sender, ensuring the transfer is authorized and the sender has sufficient balance. The function should deduct the tokens from `_from`'s balance, add them to `_to`'s balance, and emit a transfer event. Additional checks may include verifying token tradeability or taking snapshots before transferring.",
        "url": 743
    },
    {
        "nl_input": "The query seeks information on how to determine the number of tokens obtainable for a given amount of Ether (wei). The relevant code should include a function that calculates the token amount based on the Ether input, returning both the tokens and any excess value. The description should focus on the conversion logic between Ether and tokens.",
        "url": 744
    },
    {
        "nl_input": "The query requires a function that returns the composition price of a specified token ID. The function should take a token ID as input and return its corresponding price. The first code snippet (`c22031`) directly matches this need by providing a function `getCompositionPrice` that retrieves the price associated with a given token ID from a mapping. The other snippets do not address the specific requirement of fetching a price by token ID.",
        "url": 745
    },
    {
        "nl_input": "The query requires enabling public trading access in a smart contract. The suitable code should include a function that opens trading for everyone, possibly by setting a boolean flag like `tradingOpen` or `tradingStarted` to `true`, and may involve modifiers or checks to ensure public access. The function should be callable by an admin or owner role.",
        "url": 746
    },
    {
        "nl_input": "The query requires a function that checks if a document is a valid certification for a student, with the condition that this verification is a paid feature. The function should be payable and return a boolean indicating the document's validity. The code should include a fee payment requirement before executing the verification.",
        "url": 747
    },
    {
        "nl_input": "The query requires identifying code related to enabling or checking pre-sale status in smart contracts. The relevant code should include functions or modifiers that handle pre-sale conditions, such as checking time constraints (start/end times) or setting pre-sale flags. The description should focus on pre-sale activation, status verification, or time-based validation within the contract logic.",
        "url": 748
    },
    {
        "nl_input": "The query requires a function that enables refunding ETH to specified destination addresses. The function should validate the sender, adjust balances, and transfer the ETH to the intended recipients. It should handle single or multiple refunds, ensuring the transaction is secure and the contract state is updated correctly. The refund process must be conditional, typically requiring specific criteria (e.g., failed funding goals or authorized sender) before execution.",
        "url": 749
    },
    {
        "nl_input": "The query requires code snippets that demonstrate state changes or checks in smart contracts, specifically involving modifiers or functions that alter or verify contract states. Examples include setting distributor states, checking release states, or verifying funding stages. The focus is on state management within contract functions or modifiers.",
        "url": 750
    },
    {
        "nl_input": "The query requires a function that returns the number of signers for any given function. The code should track and count signers, possibly storing them in a data structure, and provide a view or internal function to retrieve the count. The solution may involve checking a proposal or function identifier and returning the associated count of signers. The count should be derived from stored data and returned as a numeric value.",
        "url": 751
    },
    {
        "nl_input": "The query asks if there is a token address set in the provided contracts. The contracts include functions to set or update a token address and a modifier to check if the token address is set. The requirements involve verifying the presence and status of a token address in the smart contracts.",
        "url": 752
    },
    {
        "nl_input": "The query requires a smart contract function that allows purchasing tokens from a reserve. The function should accept payment, transfer the tokens to the buyer, update balances, and emit relevant events. Key features include validating the buyer's address, ensuring sufficient reserve balance, calculating token amount based on payment, transferring funds to the beneficiary, and logging the transaction. The function should return a success status upon completion.",
        "url": 753
    },
    {
        "nl_input": "The query requires a function that updates statistical data (stats) for a specific token or asset, ensuring the update is restricted to authorized contracts or addresses. The function should validate the token/asset ID and modify its stats array or similar data structure. The update should be permissioned, typically through modifiers like `onlyGrantedContracts` or `restricted`.",
        "url": 754
    },
    {
        "nl_input": "The query requires a function that returns the count of \"dicks\" from a data structure. The suitable code is the first one, which has a function `howManyDicks()` that returns the length of an array `biggestDicks`. The other codes are unrelated as they count backers or player spaceships. The description should focus on retrieving the count of \"dicks\" from a stored array. (Words: 59)",
        "url": 755
    },
    {
        "nl_input": "The query requires a description of a smart contract function that handles the emission or activation of a work order, including details on cost locking, worker pool interaction, and event triggering upon successful activation. The function should accept parameters like market order index, worker pool address, application details, and callback information, and return the created work order address.",
        "url": 756
    },
    {
        "nl_input": "The query requires creating a CDP (Collateralized Debt Position) using all the Dai in the sender's balance, which needs approval. It then involves generating more Dai and reinvesting it into the CDP until either the target liquidation price is achieved or the minimum investment amount is reached. The process should be automated and handle approvals, balance checks, and reinvestment loops.",
        "url": 757
    },
    {
        "nl_input": "The query requires overriding the `_processPurchase` function from a Crowdsale contract to handle token distribution to beneficiaries. The function should update the beneficiary's token balance based on the provided token amount, ensuring proper accounting of deposited tokens. The implementation may involve adding the token amount to the beneficiary's existing balance and potentially interacting with other contracts or state variables to complete the purchase process.",
        "url": 758
    },
    {
        "nl_input": "The query requires calculating a fee charged on top of a sent value. The relevant code extracts show functions for processing a fee based on configuration, adding fees to an address, and checking fee conditions before transactions. The description should focus on fee calculation and validation, ensuring the fee is applied correctly and transactions meet the fee requirement. The result should be concise, within 80 words, and directly address the fee calculation process.",
        "url": 759
    },
    {
        "nl_input": "The query requires a function that loads and returns the Ethereum (ETH) balances of all accounts in a contract, along with the total sum of these balances. The function should iterate through each account, retrieve its balance, store these values in an array, and calculate the cumulative total. The result should be returned as an array of individual balances and the total balance.",
        "url": 760
    },
    {
        "nl_input": "The query requires checking if a specific amount of an asset or currency has been approved in the Oversight address. The relevant code involves a modifier that validates the amount and currency with the Oversight contract, ensuring the approval is verified before proceeding. The other code snippets show standard approval functions but do not directly address the Oversight validation. The focus is on the oversight mechanism for approval checks.",
        "url": 761
    },
    {
        "nl_input": "The query requires a function that distributes tokens to investors, typically restricted to the contract owner. The function should mint or transfer a specified amount of tokens to an investor's address, with checks for validity and supply limits. Options include direct minting, pre-crowdsale allocation, or investment-based token distribution. The function may also log events or enforce timing restrictions.",
        "url": 762
    },
    {
        "nl_input": "The query requires a function that processes a list of transfers by deconstructing combined amount and address data into separate fields to optimize gas usage and reduce storage of zeros on the blockchain. The function should handle the input as a single number, split it into address and amount components, store them in a structured list, and update the total distribution amount. This involves checks and efficient data handling to minimize blockchain storage costs.",
        "url": 763
    },
    {
        "nl_input": "The query requires a description of token allocation functions in smart contracts, focusing on methods that distribute tokens to addresses or specific allocations. The relevant functions include predefined allocations, internal transfers with checks, and paused-state restrictions for secure token distribution. The description should highlight the mechanisms for assigning tokens, conditions for allocation, and any security measures like pausing or ownership checks. Keep it concise within 80 words.",
        "url": 764
    },
    {
        "nl_input": "The query requires extracting the amount of tokens approved for transfer from a smart contract. The relevant code is from contract c1550, which includes a function `fillUpAllowance()` that approves the entire token balance of the contract for transfer by calling `token.approve(token, amount)`. The approved amount is the contract's token balance (`token.balanceOf(this)`). This meets the query's need to identify the approved token transfer amount.",
        "url": 765
    },
    {
        "nl_input": "The query requires an event handler that processes a token received event. The handler should validate the token sender, ensure the token matches a predefined address, check the sender's address, and update the total tokens received. The first code snippet meets these requirements by implementing checks for the token and sender addresses and incrementing the total tokens received. The other snippets handle token removal and purchase processing, which are irrelevant to the query.",
        "url": 766
    },
    {
        "nl_input": "The query requires a function allowing investors to latch FCI (Financial Commitment Instrument) themselves. The function should check if the system is paused, the revenue round is open and not withdrawable, and the investor has a positive balance before allowing the latch. The investor's stake should then be recorded for the specified round. The other provided codes about investor refunds and checks are irrelevant to this specific requirement.",
        "url": 767
    },
    {
        "nl_input": "The query requires a function that removes an existing certificate authority to prevent it from issuing new certificates. The suitable code should include a function that deletes or disables the certificate authority's address, typically restricted to the contract owner, and may emit an event to log the removal. The first code snippet meets these requirements by deleting the CA's address and logging the action.",
        "url": 768
    },
    {
        "nl_input": "The query requires a smart contract function that allows discarding or clearing stored assets or data, similar to \"throwing away a stash.\" The function should handle the removal of funds or resetting balances, potentially with conditions or ownership restrictions. Examples include draining funds to a specified address, resetting beneficiary data, or self-destructing the contract. The solution should ensure secure and controlled disposal of assets or state.",
        "url": 769
    },
    {
        "nl_input": "The query requires a smart contract function to withdraw Ether to a wallet, with options including splitting the amount between two addresses, transferring a specified amount from a trade balance, or transferring the entire contract balance to the owner. The function should ensure proper authorization and balance checks.",
        "url": 770
    },
    {
        "nl_input": "The query requires a function that checks if a sale is currently active by returning a boolean value. The function should directly indicate the sale's active status without additional conditions or modifiers, similar to the first code snippet which returns the value of `isSaleActive`. The other snippets either check for a pre-sale status or modify the sale state, which do not fully match the query's need.",
        "url": 771
    },
    {
        "nl_input": "The query requires functionality related to migrating tokens or data, including transferring a specified value to a migration agent, setting a migration destination address, and retrieving player information during migration. The code should handle balance adjustments, migration tracking, and address management while ensuring proper authorization and validation.",
        "url": 772
    },
    {
        "nl_input": "The query requires a smart contract function to withdraw funds, typically restricted to the owner or under specific conditions. The function should transfer the specified amount or the contract's balance to the owner's address, possibly emitting an event or ensuring successful transfer. Examples include withdrawing a set amount, transferring based on a proposal, or emptying the contract balance after an ICO ends. Security checks like `onlyOwner` or `icoEnded` modifiers are often used.",
        "url": 773
    },
    {
        "nl_input": "The query requires calculating the maximum number of extant nomins, which is the sum of the nomin pool and the total (circulating) supply. The relevant code should include a function that returns this sum by adding the nomin pool and total supply values. The description should focus on this calculation without analyzing individual code snippets.",
        "url": 774
    },
    {
        "nl_input": "The query requires a function that executes after a crowdsale ends to perform finalization tasks. This includes checking if the crowdsale has ended, ensuring it hasn't been finalized already, executing specific finalization logic (e.g., transferring funds, enabling refunds, or minting tokens), emitting an event to signal completion, and marking the crowdsale as finalized. The function should be restricted to the owner or specific conditions.",
        "url": 775
    },
    {
        "nl_input": "The query requires functionality to manage the paused state of NFTs, including setting the pause status (with owner-only access), checking the current pause status, and unpausing (with manager-only access when paused). The operations should include state changes, access control, and event emission.",
        "url": 776
    },
    {
        "nl_input": "The query requires a function that allows selling outcome tokens to a market maker, ensuring profit calculation, fee deduction, token transfer validation, and updating net tokens sold. The function should check for minimum profit, transfer tokens, and emit an event upon successful sale. The code must handle stages, validate transfers, and update records of sold tokens. The outcome is profit sent to the seller after fees.",
        "url": 777
    },
    {
        "nl_input": "The query requires a smart contract function that allows users to perform a free daily summon, checking if 24 hours have passed since the last summon, generating a random value to determine the hero rank, and then summoning the hero. The function should also ensure the sender's address is valid and update the timestamp for the next free summon.",
        "url": 778
    },
    {
        "nl_input": "The query requires a smart contract function that grants another address the permission to transfer a specific monster (token) using the `transferFrom()` method. This involves setting an allowance for the designated address to transfer tokens on behalf of the owner, typically through an approval mechanism or a role-based permission system. The function should ensure proper authorization and update the allowed transfer status accordingly.",
        "url": 779
    },
    {
        "nl_input": "The query requires generating a unique key for a stock by combining the market and symbol. The first code snippet demonstrates this by concatenating a 6-byte market identifier with a 6-byte symbol identifier to form a 12-byte key, which is then returned. The other code snippets are irrelevant as they deal with returning a symbol string and checking market status, not creating a composite key. The solution involves byte manipulation and assembly for efficiency.",
        "url": 780
    },
    {
        "nl_input": "The query requires a smart contract function that facilitates refunds upon KYC analysis failure. The function should check conditions like unsuccessful sale, minimum cap not reached, or sale not completed, then transfer the invested amount back to the sender, update records, and emit relevant events. The refund process must ensure security by validating sender's balance and resetting it post-transfer.",
        "url": 781
    },
    {
        "nl_input": "The query requires a modifier function that restricts access to certain functions in a contract, allowing only the Etheraffle address to call them. The modifier should include a `require` statement to check if the caller is the Etheraffle address and proceed with the function if the condition is met. This ensures that only authorized calls from the Etheraffle address can execute the modified functions.",
        "url": 782
    },
    {
        "nl_input": "The query requires a setter function for `arbitrationFeePerJuror` that updates the fee value and is restricted to a specific role (e.g., `onlyGovernor`). The function should accept a parameter for the new fee and assign it to the state variable without additional checks or events. The provided code examples show similar setter functions with role restrictions and parameter updates, but the exact match is the first example.",
        "url": 783
    },
    {
        "nl_input": "The query requires modifying the DINRegistrar contract to include a function for self-registering a DIN (Decentralized Identifier) with a resolver. The function should allow users to register their own DIN by specifying a resolver address, returning the registered DIN. The solution should ensure the function is publicly accessible and handles the registration process securely. The provided code snippets offer partial examples of similar functionalities but need adaptation for DIN registration.",
        "url": 784
    },
    {
        "nl_input": "The query requires a smart contract function that enables batch transfer of tokens from the owner's balance to multiple addresses. The function should validate input lengths, handle multiple recipients in a single transaction, and ensure only the owner can execute it. The optimal solution should efficiently loop through address-value pairs to process transfers while maintaining security checks.",
        "url": 785
    },
    {
        "nl_input": "The query requires enabling the TeamWithdraw state in a smart contract, which involves setting the state to TeamWithdraw, initializing a budget plan with specific parameters (proposal ID, budget amount, withdrawal details, and timestamps), and emitting an event to signal the state change. The contract must be in the NotReady state before this operation, and only the owner can execute it.",
        "url": 786
    },
    {
        "nl_input": "The query requires a function to set initial shareholders, ensuring the new shareholder is valid (non-zero and not the owner) and adding them to the first available slot among three predefined shareholder addresses while incrementing the shareholder count. The function should be restricted to the contract owner.",
        "url": 787
    },
    {
        "nl_input": "The query requires a function to modify gift properties, including price, description, and URL, restricted to the contract owner. The suitable code is the first option, which updates these attributes for a specified gift ID while ensuring the gift exists. The other options are unrelated as they handle wallet changes and ownership transfers. The needed functionality is encapsulated in the `updateGift` function from the first contract.",
        "url": 788
    },
    {
        "nl_input": "The query requires a function to retrieve an investor's locked token amount that is released in three batches based on time intervals. The function should return the full amount if before the delivery date, two-thirds if within 90 days after, one-third if within 180 days, and zero thereafter. The code should handle these conditions and return the appropriate locked amount for the investor.",
        "url": 789
    },
    {
        "nl_input": "The query requires a function that checks if a bag's purchase time exceeds a specified timeout period. If it does, the bag's level should be reset to 0 while keeping the original owner. The function should compare the current time with the sum of the purchase time and timeout, returning the bag's level if within the timeout or 0 otherwise. This logic is similar to the first code snippet provided.",
        "url": 790
    },
    {
        "nl_input": "The query requires a description of how to make an investment based on a pricing strategy, involving calculating token prices, setting pricing strategies, and determining token amounts from investments. The code snippets show functions for internal investment calculations, setting pricing strategies, and converting invested amounts to tokens using rates. The focus is on integrating pricing logic into investment transactions. (80 words)",
        "url": 791
    },
    {
        "nl_input": "The query requires information about both locked and unlocked tokens in smart contracts. The relevant code snippets include functions for unlocking vested tokens, locking tokens by the owner, and issuing tokens with or without locking mechanisms. The description should cover the processes of locking tokens to prevent transfers and unlocking them based on vesting schedules or admin decisions.",
        "url": 792
    },
    {
        "nl_input": "The query requires a function that allows the contract owner to set a time threshold after which a price is considered stale. The function should be restricted to the owner and update the stale time variable. The first code snippet meets this requirement with `setStaleTime(uint256 _staleTime) onlyOwner`, while the others handle price setting or price setter address changes, which are not directly relevant.",
        "url": 793
    },
    {
        "nl_input": "The query requires a function called by the owner to unpause a contract, returning it to a normal state. The function should include checks for ownership (`onlyOwner`) and paused state (`whenPaused`), set `paused` to `false`, and emit an `Unpause` event. The function must be `public`. The first two code snippets meet these requirements, while the third uses `onlyManager` instead of `onlyOwner`, which does not fully match.",
        "url": 794
    },
    {
        "nl_input": "The query requires a modifier or function that restricts token purchases to a specific time period defined by start and end dates set during contract creation. The code should include checks to ensure purchases only occur within this timeframe.",
        "url": 795
    },
    {
        "nl_input": "The query requires a function to purchase tokens during a presale event, which should include transferring funds, updating token supply, and recording the transaction. The function should validate presale conditions like time limits, minimum purchase amounts, and token supply limits, then calculate and allocate the tokens to the buyer's address while emitting a purchase event.",
        "url": 796
    },
    {
        "nl_input": "The query requires a smart contract function that allows participants to withdraw their funds if the presale fails to meet the minimum funding threshold. The function should check if the presale period has ended, verify that the total funding is below the minimum, ensure the participant has sufficient balance, and then transfer the funds back to the participant. Reverts should occur if any conditions are not met. The first code snippet best matches this requirement.",
        "url": 797
    },
    {
        "nl_input": "The query requires a function to claim all vested tokens for a user up to the current date. The function should check vesting conditions, calculate the vested amount based on elapsed time, and transfer the tokens to the user. It should also update vesting status and emit relevant events. The solution should combine vesting calculation, token transfer, and state updates in a single transaction.",
        "url": 798
    },
    {
        "nl_input": "The query requires a smart contract function that allows only the owner/minter/creator to mint new coins. The function should include checks to ensure the sender is authorized, update the total supply and the owner's balance, and may include additional safeguards like preventing reentrancy or zero-address checks. The minting process should be secure and restricted to the designated owner or minter.",
        "url": 799
    },
    {
        "nl_input": "The query requires a function to check if a crowdsale has started by verifying if the current block number has passed the predefined start block. The function should return a boolean indicating the status. The second code snippet (`contract c38774`) meets this need by comparing `block.number` with `startBlock` and returning the result. The other snippets either start the crowdsale or return a constant value without checking the block number.",
        "url": 800
    },
    {
        "nl_input": "The query requires checking if a transcoding options string is valid by verifying its length is greater than zero and divisible by a constant `VIDEO_PROFILE_SIZE`. The first code snippet meets this requirement by implementing a function `validTranscodingOptions` that performs these checks. The other snippets are unrelated, handling transcoder status and generic string length checks. The needed description focuses on validating transcoding options string length constraints. (80 words)",
        "url": 801
    },
    {
        "nl_input": "The query requires setting points for tokens between the last processed chunk and a specified amount. This involves iterating through the tokens, calculating their points, updating the points map, and managing a list of the worst-performing tokens. The process ensures the game is not finished and the specified amount does not exceed the total tokens. The last processed token index is updated after processing.",
        "url": 802
    },
    {
        "nl_input": "The query requires a function to remove or recover received foreign tokens, ensuring the token address is valid and the operation is restricted to the contract owner. The function should delete the token from storage or transfer remaining tokens to a specified beneficiary, emitting an event if necessary. The operation must validate the token address and beneficiary address, ensuring they are not zero addresses or the contract's own token address.",
        "url": 803
    },
    {
        "nl_input": "The query requires enabling early participation for addresses by whitelisting them with specific conditions, including minimum and maximum contribution caps, and ensuring the addresses are valid and not already whitelisted. The process should occur before a deadline and allow updates to existing whitelist entries.",
        "url": 804
    },
    {
        "nl_input": "The query requires a function to add a wallet address to a list of additional bonus members, ensuring the operation is restricted to the owner. The function should validate the wallet address and update its state to 'Active' in the bonus system. The solution should be implemented in a smart contract with appropriate access control.",
        "url": 805
    },
    {
        "nl_input": "The query requires creating an auction for a specified deed, including parameters like start price, end price, and duration. The auction must verify the deed's ownership, ensure valid duration, and escrow the deed. The start and end prices should fit in 128 bits, and the duration in 64 bits. The auction is created only if the caller is the deed owner or the deed contract, and the duration is at least 60 seconds.",
        "url": 806
    },
    {
        "nl_input": "The query requires adding a holder to a holders list in a smart contract, ensuring the holder is not already in the list and updating their position. The code should check if the holder exists, add them to the list if not, and record their position in the list. This functionality is similar to managing a dynamic array of holders with unique entries.",
        "url": 807
    },
    {
        "nl_input": "The query requires checking the existence of an asset or item in a smart contract context. The desired functionality involves verifying if an asset is created (owner not zero), retrieving a quote asset address, or validating a gift's existence and redemption status. The checks should return boolean values or addresses to confirm asset/item presence and validity.",
        "url": 808
    },
    {
        "nl_input": "The query requires a smart contract function to withdraw Ether, with possible conditions like ownership restriction or splitting funds between addresses. The function should transfer Ether from the contract's balance to specified recipient(s), either the full balance or a specified amount, with checks for authorization or balance limits.",
        "url": 809
    },
    {
        "nl_input": "The query requires a function to check if a pet is currently on any sponsored leaderboard, ensuring each pet can only be on one leaderboard at a time. The function should take a pet ID as input and return a boolean indicating the pet's leaderboard status. The solution involves querying a mapping or storage that tracks which pets are on leaderboards.",
        "url": 810
    },
    {
        "nl_input": "The query requires extracting transfer configuration details from a smart contract, including base amount, rate, collector address, transfer fee status, and minimum transfer amount. The relevant code is the first one, which defines a function `showTransferConfigs()` that returns these parameters by reading from a storage contract. The other codes are unrelated as they handle transfer status and execution, not configuration details.",
        "url": 811
    },
    {
        "nl_input": "The query requires a service transfer token function that is restricted to be called only by master accounts or owners. The function should transfer tokens between specified addresses with value checks and authorization limited to privileged roles.",
        "url": 812
    },
    {
        "nl_input": "The query requires a smart contract function that allows the owner to withdraw funds (house stake) while ensuring certain conditions are met, such as maintaining a minimum house stake and checking profit constraints. The function should transfer the specified amount to the owner and update the remaining stake balance. The solution should include access control (onlyOwner) and proper balance checks.",
        "url": 813
    },
    {
        "nl_input": "The query requires a function that transitions to the next phase by updating the start time, end time, and token cap, then sets the new phase as the current one. The function should also handle the token cap calculation differently for the final phase. The first code snippet meets these requirements by adjusting timestamps, calculating token caps, and emitting an event for the phase switch.",
        "url": 814
    },
    {
        "nl_input": "The query requires a function to change the stage of a crowdsale (e.g., PreICO or ICO) by accepting a stage value as input, updating the stage variable, and restricting access to the contract owner. The function should validate the input against predefined stage values and set the stage accordingly. The solution should ensure proper access control and stage transition logic.",
        "url": 815
    },
    {
        "nl_input": "The query requires a function that checks if given parameters are valid. The validation conditions include: ensuring arrays of dates and amounts are non-empty and of equal length, verifying amounts and dates are in ascending order, checking if a sale type is fixed-price or has a valid expiration time, and confirming a rate falls within specified minimum and maximum bounds. The function should return true only if all conditions are met.",
        "url": 816
    },
    {
        "nl_input": "The query requires a function that allows the contract owner to transfer ownership of any top-level domain owned by the contract. The function should be restricted to the owner and should update the domain ownership in the registry or contract state. The solution must ensure proper authorization and handle the transfer securely.",
        "url": 817
    },
    {
        "nl_input": "The query requires a description of external functions related to wineries. The most relevant code is the first one, which defines an external function `addWineryOperation` for wineries. This function adds a winery operation with details like track ID, operation ID, code, date, area code, and ICQRF code, and emits an event upon success. The other codes are unrelated to wineries. The description focuses on winery-specific operations and their logging.",
        "url": 818
    },
    {
        "nl_input": "The query requires modifying the payday function to carry over any missed payments to the next pay period instead of reverting. This involves tracking owed amounts and adding them to subsequent paychecks when a payday is missed. The solution should ensure continuity of payments by accumulating unpaid amounts and distributing them in the next eligible pay period.",
        "url": 819
    },
    {
        "nl_input": "The query requires a function where a user can sell their tokens for ETH, ensuring the contract has the necessary allowance before execution. The function should transfer tokens from the user to the contract and send the equivalent ETH to the user, with checks for sufficient balance and successful transfers. The first code snippet (`c40120`) matches this requirement by handling token sales, allowance checks, and ETH transfers.",
        "url": 820
    },
    {
        "nl_input": "The query requires a function that calculates the token amount based on an invested amount (in wei or ether) using a specific rate. The rate may vary depending on the investment tier (e.g., different rates for amounts below 1 ether and above 1 ether). The function should return the computed token amount after applying the appropriate rate to the investment. The solution should be gas-efficient and may involve internal or view functions for rate calculation. (80 words)",
        "url": 821
    },
    {
        "nl_input": "The query requires a function that subtracts two numbers and handles overflow by reverting if the subtrahend is larger than the minuend. The function should return the subtraction result only when the minuend is greater than or equal to the subtrahend, otherwise it should revert or return zero to prevent underflow. The solution should be implemented in a smart contract context.",
        "url": 822
    },
    {
        "nl_input": "The query requires a function to permanently lock the `maxSupply` at its current value, ensuring it cannot be changed in the future. The function should be restricted to the contract owner and should emit an event confirming the lock status. The provided code snippet from `contract c37567` demonstrates this functionality by setting `isMaxSupplyLocked` to `true` and emitting a `MaxSupply` event.",
        "url": 823
    },
    {
        "nl_input": "The query requires a function to claim IBC tokens, checking conditions like sale stage, funding goals, and bonus eligibility before transferring tokens to the sender. It should handle stages (ICO/Closed), validate sender balances, apply bonuses if criteria are met, and update balances and distributions. The function must emit an event upon successful claim.",
        "url": 824
    },
    {
        "nl_input": "The query requires a description of how to create or activate a special manager in a smart contract. The relevant code snippets involve functions that enable or set a manager address, with checks for validity and ownership, and update the manager's status or details in the contract's storage. The operations include verifying the address, setting permissions, and emitting events upon successful activation.",
        "url": 825
    },
    {
        "nl_input": "The query requires an initialization function that should be called after contract deployment. The function must ensure it is called by the owner, set initial values (like prices or block numbers), and mark the contract as initialized. It should also prevent re-initialization. The code examples show functions that set initial states, mint tokens, and enforce ownership checks, aligning with the need for a one-time setup post-deployment.",
        "url": 826
    },
    {
        "nl_input": "The query requires a function to send tokens from a sender to a receiver, ensuring the sender is authorized and the transfer amount is valid. The function should update the token balance after the transfer. The first code snippet matches this requirement with its `sendToken` function, which checks the sender's authority, validates the amount, transfers tokens, and adjusts the deposit balance. The other snippets handle minting and transferring without amount checks.",
        "url": 827
    },
    {
        "nl_input": "The query requires determining if the calldata specifications of two orders can match by comparing their buy and sell calldata after applying replacement patterns, returning true if they are identical. The solution involves guarded array replacements and equality checks. (50 words)",
        "url": 828
    },
    {
        "nl_input": "The query requires a function that allows the current owner of a contract to propose transferring ownership to a new address, restricted by the `onlyOwner` modifier. The function should validate the new owner's address (non-zero) and update the owner. Optionally, it may emit an event to log the ownership transfer. The solution must ensure secure and authorized ownership transfer within the contract's access control framework.",
        "url": 829
    },
    {
        "nl_input": "The query requires a function that returns the balance of a specific account. The suitable code should include a function named `balanceOf` or similar, which takes an address or token owner as input and returns the balance as a uint. The function should be public and view/constant, accessing a balances mapping or similar storage to retrieve the account's balance.",
        "url": 830
    },
    {
        "nl_input": "The query requires code that handles the payment of unpaid dividends to shareholders. The suitable code should include functions to check dividend eligibility, calculate the owed amount, transfer the dividends to the shareholder, and update the dividend records. The code should ensure that only eligible shareholders can claim their dividends and that the payment process is secure and accurate.",
        "url": 831
    },
    {
        "nl_input": "The query requires a function that retrieves the percentage of shares a user holds on a specific date. The function should accept a user identifier and a date as inputs, then return the share percentage. It should handle cases where the date is not provided (defaulting to the current date) and ensure calculations are based on the user's share balance relative to the total shares on the given date.",
        "url": 832
    },
    {
        "nl_input": "The query seeks Solidity code examples for debugging purposes in online environments like Remix and sandboxes. The examples should demonstrate simple contract functions, such as toggling a state variable, checking user contributions, or retrieving a sender's balance. The focus is on basic, reusable code snippets that can be easily tested and debugged in browser-based Solidity development tools.",
        "url": 833
    },
    {
        "nl_input": "The query requires a Solidity modifier that restricts function access to only the exchange contract by verifying the caller's address matches the exchange contract's address. The modifier should use `require(msg.sender == address(exchange))` to enforce this condition before proceeding with the function execution. This ensures only authorized calls from the exchange contract are allowed.",
        "url": 834
    },
    {
        "nl_input": "The query requires a function to unlock vested tokens and transfer them to the grantee. The suitable code should include checks for vested amounts, handle token transfers, and update vesting records. The first code snippet meets these requirements by calculating vested tokens, verifying transferable amounts, updating the grant status, and transferring tokens to the grantee. The other snippets focus on balance checks and non-vested calculations, which are not directly relevant.",
        "url": 835
    },
    {
        "nl_input": "The query requires code that handles rounding a number (specifically 1.5) toward zero and includes logic for rate calculations or bonus adjustments based on certain conditions. The relevant code should involve arithmetic operations, conditional checks, and possibly division or modulus operations to achieve the desired rounding behavior.",
        "url": 836
    },
    {
        "nl_input": "The query requires a function to retrieve or transfer ether (ETH) from a smart contract. The suitable code should include methods to check the contract's ETH balance, withdraw ETH to the owner, or convert ETH amounts. The function may involve balance checks, owner restrictions, or conversion logic specific to ETH transactions.",
        "url": 837
    },
    {
        "nl_input": "The query requires a function to retrieve a contract's address by its name. The suitable code is the first option, which includes a function `getContract` that takes a contract name as input and returns the corresponding address after verifying it exists in the contracts mapping. The other options do not meet this requirement. The description should focus on the need to fetch a contract's address using its name. (58 words)",
        "url": 838
    },
    {
        "nl_input": "The query requires information about internal balance management in smart contracts, including functions to get a user's balance, set a balance for an address, and toggle balance update functionality. The relevant code snippets involve retrieving balances, modifying balances internally, and enabling/disabling balance updates, all related to internal balance tracking within the contracts.",
        "url": 839
    },
    {
        "nl_input": "The query requires transferring ownership of an SSP record. The suitable code should include a function that transfers ownership from the current owner to a new specified address, typically with checks to ensure the new address is valid (not zero). The function should be restricted to the current owner (using `onlyOwner` modifier) and may emit an event to log the ownership transfer. The new owner's address must be non-zero.",
        "url": 840
    },
    {
        "nl_input": "The query requires a function that allows the draining or withdrawal of Ether from a contract, typically restricted to the owner or under specific conditions. The desired functionality includes transferring Ether to the owner or another specified address, with possible checks for ownership or minimum Ether amounts. Examples include emergency drains, immediate transfers, or conditional withdrawals based on contract state or sender's balance.",
        "url": 841
    },
    {
        "nl_input": "The query requires a smart contract function that issues tokens based on the Ether received. The function should calculate the token amount using the received Ether, ensure the transaction meets minimum requirements, update the token balance, and transfer the Ether to a designated wallet. It should also handle edge cases like zero address checks and hard cap limits. The tokens are minted and assigned to the sender's address upon successful Ether transfer.",
        "url": 842
    },
    {
        "nl_input": "The query requires a function that appends an unsigned integer (in decimal format) to a string. The function should convert the uint to its string representation and concatenate it to the input string, returning the combined result. The solution should handle the conversion and concatenation efficiently, ensuring the output is a valid string with the appended uint value.",
        "url": 843
    },
    {
        "nl_input": "The query requires a method to distribute DNT tokens proportionally among contributors after the contribution period ends. The method should be called by the owner, check if the period has ended, calculate compensation based on each contributor's stake, mark contributors as compensated, and transfer the calculated DNT amounts to their addresses. The distribution should be done in batches with offset and limit parameters to manage large numbers of contributors efficiently.",
        "url": 844
    },
    {
        "nl_input": "The query requires a function to remove a destroyer's privileges when they are no longer needed. The function should check if the destroyer exists, revoke their status, update the destroyers list, and log the removal. The solution should involve address verification, status update, array management, and event logging for transparency.",
        "url": 845
    },
    {
        "nl_input": "The query requires a smart contract function that allows an account to place a higher bid on a token, ensuring the new bid exceeds the current highest bid, refunds the previous highest bidder, and updates the highest bidder and bid value. The function should also emit an event for bid increase and handle token ownership checks if applicable.",
        "url": 846
    },
    {
        "nl_input": "The query requires retrieving the balance of a Faucet contract, specifically the token balance held by the contract. The suitable code should include a function that returns the balance of tokens (not native currency) from the contract's address, using an ERC20 token interface to query the balance. The expected output is a uint value representing the token balance.",
        "url": 847
    },
    {
        "nl_input": "The query requires setting the price for the EXH Token. The relevant code snippets include functions to update token prices during different stages (pre-ICO and ICO), calculate token prices based on stages, and set a new price rate by the owner. The description should focus on mechanisms for price updates, stage-based pricing, and owner-controlled price adjustments.",
        "url": 848
    },
    {
        "nl_input": "The query requires calculating the total payout per tier using the odds method, which involves multiplying the odds for a single match by the number of winners. The relevant code snippet is the first one, which defines a function `oddsTotal` that performs this calculation by taking the number of winners and a matches index as inputs and returning the product of the single match odds and the number of winners.",
        "url": 849
    },
    {
        "nl_input": "The query requires a smart contract function that allows the owner to withdraw a specified amount of funds. The function should include checks to ensure sufficient balance and may optionally specify a destination address. It must enforce the `onlyOwner` modifier to restrict access. The function should transfer the specified amount or the entire balance if zero is provided, and may emit an event upon withdrawal.",
        "url": 850
    },
    {
        "nl_input": "The query requires a function that allows the caller to create an original artwork using a specified genome, with conditions for ownership and creation limits. The function should handle fee payments and ownership transfers, ensuring only authorized users can create artworks within set constraints. The artwork creation should be tied to the provided genome data.",
        "url": 851
    },
    {
        "nl_input": "The query requires a function to transfer tokens between addresses, with possible conditions like ownership checks, token tradeability, and amount validation. The function should handle token transfers either directly or via delegation, updating balances and emitting transfer events. It may include checks for valid amounts, sender/receiver restrictions, and time constraints. The implementation can vary from simple transfers to more complex scenarios involving owner permissions or locked tokens.",
        "url": 852
    },
    {
        "nl_input": "The query requires a function that returns the array index for a given position (x, y) and throws an error if the position is off-grid (out of bounds). The function should validate the coordinates against a grid size and compute the index as `x * size + y`. This ensures the position is within bounds before returning the index.",
        "url": 853
    },
    {
        "nl_input": "The query requires extracting a 20-byte contiguous slice from a bytes data starting at a specified position. The solution involves converting each byte in the specified range into a 20-byte value by shifting and combining them. The first code snippet (c13707) demonstrates this by iterating over 20 bytes, shifting each byte to its correct position, and combining them into a bytes20 result. The other snippets handle different byte lengths or concatenation, not matching the 20-byte slice requirement.",
        "url": 854
    },
    {
        "nl_input": "The query seeks a Solidity function modifier that checks if the `msg.sender` matches a specified address or contract. The modifier should include a `require` statement to validate the sender's address against a predefined condition (e.g., a resolver contract, burn address, or oracle address) and proceed with `_;` if the condition is met. The goal is to restrict function access based on the sender's identity.",
        "url": 855
    },
    {
        "nl_input": "[\"Return an array with the weapons of the army, including counts of drones, planes, helicopters, and tanks for a given army ID.\"]",
        "url": 856
    },
    {
        "nl_input": "The query requires setting a PriceSetter address that can define the price of a token in wei. The suitable code must allow an authorized entity (like an owner) to assign an address with the permission to set token prices. The first code snippet fits this requirement as it includes a function to update the PriceSetter address, restricted by owner and access checks. The other snippets set prices directly or for specific addresses, not a PriceSetter role.",
        "url": 857
    },
    {
        "nl_input": "The query requires a description of a function that withdraws tokens from a smart contract. The function should include checks for conditions like contract closure or finalization, verify the sender's token balance, and transfer the tokens to the sender or a specified address. The function may also involve admin-only access or specific token types (e.g., ZRX). The description should be concise, within 80 words.",
        "url": 858
    },
    {
        "nl_input": "The query requires a mechanism to prevent users from submitting duplicate bets. The solution involves checking if a user has already placed a bet with the same match ID and betting price before allowing a new bet. This ensures no duplicate bets are accepted, maintaining fairness and preventing abuse. The relevant code should include a function that verifies past bets by the user against current bet parameters.",
        "url": 859
    },
    {
        "nl_input": "The query requires a function that multiplies two unsigned integers (x and y) and throws an exception if the multiplication results in an overflow. The function should return the product if no overflow occurs. The solution should include checks to ensure the operation's safety, typically by verifying that the product divided by one operand equals the other operand or using similar validation methods.",
        "url": 860
    },
    {
        "nl_input": "The query describes a modifier in Solidity, a special function that executes before the function it is applied to. The modifier checks specific conditions (e.g., time constraints or attempt limits) using `require` statements and proceeds with `_;` if conditions are met. Examples include checking sale start time, pause status, or single execution. The modifier ensures preconditions are satisfied before the main function runs.",
        "url": 861
    },
    {
        "nl_input": "The query requires checking if an angel is currently on any sponsored leaderboard, ensuring each angel can only be on one leaderboard at a time. The relevant code is the first snippet, which provides a function `angelOnLeaderboards` that returns a boolean indicating if a specified angel ID is on a leaderboard. The other code snippets are unrelated to this specific requirement.",
        "url": 862
    },
    {
        "nl_input": "The query requires identifying the maximum available amount that can be taken from an order. The most relevant code is the first one, which calculates this by comparing the remaining taker token amount with the proportional maker token balance, ensuring the amount does not exceed either limit. The other codes are unrelated, focusing on maximum funds in euros and supply comparisons. The description should highlight the order's available amount calculation using token balances and fills. (80 words)",
        "url": 863
    },
    {
        "nl_input": "The query requires a smart contract function that allows the withdrawal of funds (dev withdraw) and splits the amount equally among all owners of the contract. The function should ensure the withdrawal is permissible, calculate equal shares for each owner, transfer the shares, and emit an event logging the transaction. The first code snippet meets these requirements by using `SafeMath.div` for equal distribution and iterating through owners to transfer funds.",
        "url": 864
    },
    {
        "nl_input": "The query requires a function that transfers coins and throws errors for any failure, including when transfers are disabled, instead of returning a false flag. The function should enforce standard checks and revert transactions if conditions are not met, ensuring user errors are minimized by failing explicitly rather than silently.",
        "url": 865
    },
    {
        "nl_input": "The query requires information about setting or retrieving minimum or maximum Wei amounts in smart contracts, including validation checks and conversion rates based on Wei thresholds. The relevant code involves functions for setting minimum Wei amounts with specific conditions, converting Euro cents to Wei, and determining token amounts based on different Wei tiers.",
        "url": 866
    },
    {
        "nl_input": "The query requires identifying the current round in a smart contract context. The suitable code should return either the address or details of the current round based on conditions like token sales or round progression. The first two code snippets provide functions (`currentRound()` and `getCurrentRound()`) that fetch this information, while the third snippet modifies round rates but doesn't retrieve the current round. The need is to access the active round's data dynamically.",
        "url": 867
    },
    {
        "nl_input": "The query requires a smart contract function to publish an article with specific conditions: verifying the publisher's ownership, checking token limits, ensuring time intervals between publishes, and registering article hashes. The function should update relevant state variables and emit results or events upon successful or failed publication. The first code snippet meets these requirements by handling all specified checks and updates, while the others focus on unrelated functionalities like setting news or authorizing addresses.",
        "url": 868
    },
    {
        "nl_input": "The query requires a function that allows the contract owner to enable token transfers. The function should be restricted to the owner and update a transfer status variable. Optionally, it may include burning tokens or resetting approvals. The solution should be implemented in a smart contract with appropriate access control (e.g., `onlyOwner` modifier). The core functionality is to toggle a transfer flag (e.g., `transferIsEnabled` or `transferStatus`) to true.",
        "url": 869
    },
    {
        "nl_input": "The query requires a function that removes an admin address from a smart contract and returns `true` upon successful removal. The function should check if the address is valid, ensure the caller is authorized, and verify the admin exists before deletion. The removal should also prevent self-removal by the admin. The expected output is a boolean confirmation of the operation's success.",
        "url": 870
    },
    {
        "nl_input": "The query requires a function that allows the pendingAdmin address to finalize the process of changing the admin. The function should verify the caller is the pendingAdmin, update the admin to pendingAdmin, reset pendingAdmin to zero address, and emit an event for the admin change. This ensures a secure and transparent transition of admin rights.",
        "url": 871
    },
    {
        "nl_input": "The query requires checking if a token transfer destination is valid. The relevant code should verify transfer permissions, such as checking sender/recipient addresses, token IDs, or transfer conditions (e.g., vesting dates or exceptions). The logic may involve external contracts or internal rules to determine transfer validity. The output should be a boolean indicating whether the transfer is allowed.",
        "url": 872
    },
    {
        "nl_input": "The query requires a function to update the minting agent's status in a smart contract. The function should allow the contract owner to enable or disable an agent's minting privileges by setting their address and a boolean status. The function must include access control to restrict updates to the owner only. The desired functionality is similar to modifying a mapping that tracks minting agents' permissions.",
        "url": 873
    },
    {
        "nl_input": "The query requires determining the total tokens available for purchase at the current moment. The relevant code checks token availability based on conditions like sale phase, time constraints, and remaining supply, ensuring tokens are within sale limits and not sold out. It calculates available tokens by comparing current supply against predefined caps or limits, returning the remaining purchasable tokens if conditions are met.",
        "url": 874
    },
    {
        "nl_input": "The query requires a function that allows an admin to finalize an ownership change after a specified delay (one day). The function should verify the admin's authority and the elapsed time, then transfer ownership of multiple child contracts to a new owner, clearing the pending operation afterward. The solution should include checks for admin authorization and block number delay, followed by ownership transfers for all relevant contracts.",
        "url": 875
    },
    {
        "nl_input": "The query requires a function that stakes a certain amount of tokens by transferring them from the caller's address. The function must ensure the transfer of the specified amount and include checks to validate the transaction, such as verifying the sender's balance or permissions. The code should handle the token transfer securely and update relevant state variables accordingly.",
        "url": 876
    },
    {
        "nl_input": "The query requires a smart contract function that allows placing a bid in an auction. The function should check if the bid is placed within the allowed time, ensure the bid amount is higher than the current highest bid, refund the previous highest bidder, update the highest bidder and bid amount, and emit an event for the new highest bid. The code should handle payable transactions and manage bidder transitions securely.",
        "url": 877
    },
    {
        "nl_input": "The query requires a contract function that approves a proxy (spender) to spend a specified amount of tokens on behalf of the sender (msg.sender). The function should update the allowance and emit an Approval event. The suitable code must include parameters for the spender's address and the token amount, with checks for ownership or permissions if needed.",
        "url": 878
    },
    {
        "nl_input": "The query requires a function that allows the contract owner to update token rates or related parameters. The function should be restricted to the owner (using `onlyOwner` modifier) and should accept parameters for the new rate or token address. The update can be for token-to-ETH rates, reward rates, or token addresses, with optional validation checks. The implementation may vary but must ensure owner-only access and parameter updates.",
        "url": 879
    },
    {
        "nl_input": "The query requires a function that throws an exception when two amounts are not equal. The suitable code should compare two values and revert the transaction if they differ, ensuring strict equality validation.",
        "url": 880
    },
    {
        "nl_input": "The query requires creating a new proxy contract for an owner with a recovery mechanism. The solution involves deploying a proxy contract, setting the owner and recovery key, and logging the creation event. The owner and recovery key must be valid addresses, and the owner's timestamp is adjusted by an admin timelock. The recovery key is stored for future use. This ensures secure ownership transfer and recovery capabilities.",
        "url": 881
    },
    {
        "nl_input": "The query requires identifying a function that is potentially dangerous and should only be used in extreme cases. The relevant code is a safe multiplication function that checks for overflow, a critical operation in smart contracts where incorrect handling can lead to vulnerabilities. The description emphasizes the function's risk and restricted usage. (80 words)",
        "url": 882
    },
    {
        "nl_input": "The query requires a function that updates a successor or delegate address in a smart contract, ensuring the new address is valid and different from the current one. The function should be restricted to authorized users (e.g., admin or owner) and emit an event if the change occurs. The code examples show similar patterns for setting a successor, changing a bonus, or updating a delegate, all with checks and access controls.",
        "url": 883
    },
    {
        "nl_input": "The query requires determining profit by calculating the difference between pre- and post-adjustment cost levels in a market, derived from outcome token changes and funding. The profit is computed as `(costLevelBefore - costLevelAfter) / ONE` after adjusting net outcome tokens sold.",
        "url": 884
    },
    {
        "nl_input": "The query requires checking if a customer's transaction (Tx) for payment in MCW (likely a cryptocurrency or token) has been spent. The relevant code should verify the transaction status by checking if it has a non-zero timestamp in the transaction registry, indicating it has been processed or spent. The first code snippet (`contract c900`) fulfills this requirement by checking the `timestampPaymentKWh` in the `txRegistry` for the given transaction. \n\n(80 words)",
        "url": 885
    },
    {
        "nl_input": "The query requires setting the free memory pointer in Solidity to point beyond all accessed memory, typically using the `mstore` operation with `0x40` and `msize` in assembly. This ensures efficient memory management by marking the end of used memory. The relevant code is the first option, which demonstrates this operation within a private pure function. The other options are unrelated, dealing with contract freezing functionality.",
        "url": 886
    },
    {
        "nl_input": "The query requires the ability to quickly check Round1 status exactly once, focusing only on Round1 without considering other rounds or multiple checks. The needed functionality should verify if the current round is Round1 and perform a single check operation.",
        "url": 887
    },
    {
        "nl_input": "The query requires a function to remove an address from a whitelist in a smart contract. The function should be restricted to the contract owner and update the whitelist status of the specified address to `false`. The desired code should include the `onlyOwner` modifier and modify the whitelist mapping or state variable accordingly.",
        "url": 888
    },
    {
        "nl_input": "The query requires processing a combat transaction with sufficient gas to cover the expense. The code should include functions to handle gas costs, fees, or game forfeitures, ensuring proper gas allocation and transaction execution without failures due to insufficient gas. The focus is on managing gas expenses and transaction fees efficiently during combat or game-related operations.",
        "url": 889
    },
    {
        "nl_input": "The query requires a smart contract function that allows withdrawing a balance (either Ether or tokens) and sharing it, typically restricted to the owner or specific users. The function should transfer the balance to a designated wallet or address, ensuring proper checks (like ownership or balance availability) are in place before execution. The examples show variations like transferring contract balance, token balance, or handling trade-specific withdrawals.",
        "url": 890
    },
    {
        "nl_input": "The query requires information about air delivery functions in BioX that use token counts instead of wei amounts. Specifically, it needs details on how token amounts are handled in such functions, excluding wei-based calculations. The focus is on functions that directly manage token transfers without converting wei amounts, as seen in the `airDeliver` function which processes token counts directly.",
        "url": 891
    },
    {
        "nl_input": "The query requires a description of a smart contract function that allows qualified partners in a crowdsale to purchase tokens. The function should include checks for partner qualification, handle payment and token allocation, and possibly manage commission fees. It should ensure valid transactions, update raised amounts, and enforce caps on purchases. The function must be secure, with proper validations and event logging for transparency.",
        "url": 892
    },
    {
        "nl_input": "The query requires a Solidity modifier named `onlyOwner` that ensures a function can only be executed by the contract owner. The modifier should check if `msg.sender` equals the `owner` and revert if not. The correct implementation uses `require(msg.sender == owner); _;`. The incorrect version checks `msg.sender != owner`, which is the opposite of the intended logic. The modifier can be written with or without parentheses.",
        "url": 893
    },
    {
        "nl_input": "The query requires a function to fetch the contract size of an ERC223 token, ensuring it is nonzero to confirm it is a contract. The desired code should check the token's balance or size, similar to the provided examples but specifically for ERC223 tokens, and include a validation to ensure the contract is valid (nonzero size). The function should be viewable and return a uint representing the balance or size.",
        "url": 894
    },
    {
        "nl_input": "The query requires a function to calculate the compounded interest output based on a specified input amount and the number of payout periods. The function should apply the interest rate for each period, compound the interest, and optionally adjust for any exit tax or fees. The result should be the final amount after all compounding and adjustments.",
        "url": 895
    },
    {
        "nl_input": "The query requires identifying the second winners from all first-round winners in a competition. The relevant code involves comparing hero powers of first-round winners with random number checks to determine the second-round winners. The process includes conditional checks based on hero power comparisons and random thresholds to select the winners for the next round. The description focuses on the selection logic for second-round winners from first-round results.",
        "url": 896
    },
    {
        "nl_input": "The query requires checking if the current round is in its lock period by comparing the elapsed blocks since the round's start with the predefined locked blocks duration. The relevant code calculates this by subtracting the locked blocks from the total round length and checking if the elapsed blocks exceed this difference.",
        "url": 897
    },
    {
        "nl_input": "The query requires a code snippet that resets a purchaser's cap when a specified window duration is met. The code should check if the duration has elapsed and reset the cap accordingly, updating the purchase record with the new amount and block number if the condition is satisfied. The functionality should involve tracking purchase blocks and resetting the cap based on the elapsed time.",
        "url": 898
    },
    {
        "nl_input": "The query requires a function that sets a global activation fee, ensuring the new fee is greater than zero and different from the current fee, with an event emitted upon update. The function should be restricted to the owner's access. The fee update should return a boolean success status. This matches the first code snippet, which meets all these criteria. The other codes handle different fee mechanisms or lack the specified requirements. (80 words)",
        "url": 899
    },
    {
        "nl_input": "The query requires a function to update both sell and buy prices in a single transaction, restricted to the contract owner, without additional validation beyond ownership. The function should accept two parameters (new sell price and new buy price) and assign them to corresponding state variables.",
        "url": 900
    },
    {
        "nl_input": "The query requires a function that allows the contract owner to withdraw any ETH trapped in the contract. The function should be restricted to the owner and transfer the contract's entire balance to them. Suitable function names include `sweep()`, `withdrawEther()`, or `recoverEthers()`, all implementing `owner.transfer(this.balance)` with an `onlyOwner` modifier.",
        "url": 901
    },
    {
        "nl_input": "The query requires a function that checks if a gift exists and has not been redeemed. The suitable code is the first one, which returns true only when `gift.exists` is true and `gift.redeemed` is false. The other codes are unrelated to gift redemption checks. The description should focus on verifying gift existence and redemption status.",
        "url": 902
    },
    {
        "nl_input": "The query requires identifying a contract function that handles deposits, specifically checking for a successful completion before accepting funds. The relevant function is `deposit() public payable` which includes a `require(isFinishedSuccessfully())` check to ensure conditions are met before processing the deposit. This matches the need for a deposit function with a success verification mechanism.",
        "url": 903
    },
    {
        "nl_input": "The query requires a description of a Solidity function that computes a fixed-point exponential value using an unsafe approximation method. The function takes an unsigned integer `_x` and a precision parameter `_precision`, then performs a series of multiplications and bit shifts to approximate the exponential value, returning the result after division by a large constant. The method is marked as unsafe due to potential precision loss and overflow risks.",
        "url": 904
    },
    {
        "nl_input": "The query requires a function that allows an owner or authorized entity to add or modify special privileges for specific addresses in a smart contract. This includes setting bonus states, activating special manager roles, or adding bonuses to blocks, with checks for address validity and authorization. The function should ensure proper state updates and return success status where applicable.",
        "url": 905
    },
    {
        "nl_input": "The query requires creating a new tank type with specified attributes including start price, earnings, base health, base attack, base armor, and base speed. The tank type should be stored with these parameters and assigned a unique identifier. The function should be restricted to the contract owner. The description should be concise, focusing on the essential parameters and ownership requirement.",
        "url": 906
    },
    {
        "nl_input": "The query requires determining the current state based on a timestamp, checking conditions like start and end dates for different phases (PrivateSale, PreSale, CrowdSale phases), and returning the appropriate state (e.g., PrivateSale, Gap). The code should compare the current timestamp (`now`) with predefined phase dates and return the corresponding state if conditions are met.",
        "url": 907
    },
    {
        "nl_input": "The query requires a function named `transferOwnership` that allows the current owner to transfer ownership to a new address. The function should include checks to ensure the new owner is a valid address (not zero) and should be restricted to the current owner (`onlyOwner` modifier). Optionally, it may emit an event to log the ownership transfer. The function should update the `owner` variable with the new owner's address.",
        "url": 908
    },
    {
        "nl_input": "The query requires a description of a function that starts a game, including checks for valid arbiters, player validation, game activation, and initialization of game parameters like player slots and pot values. The function should handle game cancellation if active, manage housekeeping, and update game status and player details. The expected output is a concise summary of these requirements without code analysis.",
        "url": 909
    },
    {
        "nl_input": "The query requires code snippets that check the sender of a message (`msg.sender`) against specific conditions. The conditions include verifying the sender against a contract resolver, a predefined oracle address, or an authorization list. The snippets should use Solidity modifiers with `require` statements to enforce these checks. The goal is to ensure the sender is authorized or matches a specific contract or oracle address before proceeding with the function execution.",
        "url": 910
    },
    {
        "nl_input": "The query requires setting addresses for vested team tokens during finalization, ensuring they are non-zero and properly assigned. The relevant code involves a function that sets allocation addresses for team and contributors, validating they are not zero addresses before assignment. This ensures secure and correct distribution of vested tokens upon finalization.",
        "url": 911
    },
    {
        "nl_input": "The query requires a smart contract function that allows users to sell eggs (or tokens representing eggs) in exchange for Ethereum (ETH). The function should handle the sale process, including calculating the egg value, deducting any fees, transferring the fee to a designated address, and sending the remaining ETH to the seller. It should also update relevant state variables, such as resetting the seller's egg count and recording the transaction time.",
        "url": 912
    },
    {
        "nl_input": "The query requires a function that allows an admin to toggle the state of a prebridge feature. The function should be restricted to the contract owner or admin and should switch the prebridge state between true and false. The first code snippet meets this requirement with a `togglePrebrdige` function that modifies the `prebridge` variable and is restricted by the `onlyOwner` modifier.",
        "url": 913
    },
    {
        "nl_input": "The query requires extracting invested Ethereum from a Pre-ICO, specifically by calling a function that transfers the accumulated Ethereum to the owner after the Pre-ICO end date, ensuring the contract is in a valid state (Runned or Finished). The function should return the transferred amount.",
        "url": 914
    },
    {
        "nl_input": "The query requires a function that processes a refund based on a proposal number, refund amount, and fees. The function should check if the proposal is executable, verify sufficient funds, deduct the refund and fees from the balance, transfer the refund to the recipient, update the policy status, and emit relevant events. The refund should only proceed if all conditions are met, otherwise, it should mark the proposal as failed.",
        "url": 915
    },
    {
        "nl_input": "The query seeks code snippets related to setting minimum and maximum withdrawal limits in a smart contract. The provided code includes functions for changing the minimum withdrawal amount (`changeMinWithdraw`) and executing withdrawals (`withdrawl`, `withdraw`), but does not explicitly handle maximum withdrawal limits. The focus is on validating withdrawal amounts and updating contract states.",
        "url": 916
    },
    {
        "nl_input": "The query requires a function that returns the token balance of a specified address. The suitable code should include a `balanceOf` function that takes an address parameter and returns the balance associated with that address. The function should be constant or view to ensure it does not modify the state. The balance should be returned as an unsigned integer (uint). The provided code snippets from URLs 306 and 45 meet these requirements.",
        "url": 917
    },
    {
        "nl_input": "The query requires extracting an address from an RLPItem, ensuring the item is valid data and exactly 20 bytes long. The address is derived by decoding the RLPItem and processing it in assembly to fit the address format. The solution involves checking data validity, decoding the item, and using assembly to convert the data into an address. The other provided codes do not handle RLPItem decoding. The focus is on RLP-specific address extraction.",
        "url": 918
    },
    {
        "nl_input": "The query requires a function to remove a policy rule based on specified parameters: function signature (`_sig`), contract address (`_contract`), and group name (`_groupName`). The function must validate inputs, update policy storage, adjust limits, emit an event, and return a status code. The operation should be restricted to the contract owner and handle edge cases like non-existent groups or invalid invocations.",
        "url": 919
    },
    {
        "nl_input": "The query requires a function to restrict token transactions by setting Unix times for specified targets. The function should validate input lengths, ensure new lock times are later than existing ones, update the lock times, and emit an event for each locked target. The solution must include owner-only access control and proper parameter checks.",
        "url": 920
    },
    {
        "nl_input": "The query requires a description of a method that handles core game logic, specifically tracking a button click event and saving associated metadata. The method should validate conditions like minimum fee and game generation, update game state, calculate blocks remaining for victory, store click metadata, emit events, and return a click ID. The first code snippet (`c12408`) matches these requirements by implementing the `clickButton` function with all specified features.",
        "url": 921
    },
    {
        "nl_input": "The query requires a publicly callable function that updates the inflation rate annually. The function should enforce a minimum time interval of one year between updates and adjust the inflation rate based on predefined conditions. The adjustment should also calculate and distribute minting amounts for different pools (owner, staking, etc.) based on the updated inflation rate and predefined percentages. The function must be accessible to anyone and execute only once per year.",
        "url": 922
    },
    {
        "nl_input": "The query requires a function that calculates the remaining time until the next interest payout in Unix timestamp format, intended for end-user display rather than contract logic. The function should be read-only (public constant/view) and return the time difference in seconds or milliseconds. It should handle cases where the payout period has ended by returning zero. The focus is on providing a user-friendly time display without affecting contract operations.",
        "url": 923
    },
    {
        "nl_input": "The query requires a function that calculates and returns the price for the nth key, considering the number of keys and decimal precision. The function should take an input parameter (n) and return the computed price, possibly involving multiplication and addition operations or discount calculations. The solution should be a view or constant function in a smart contract.",
        "url": 924
    },
    {
        "nl_input": "The query requires a function that allows a specified spender to withdraw funds multiple times from an account, up to a specified value. The function should check the account balance, ensure the withdrawal amount does not exceed the balance, update the balance accordingly, and emit relevant events. It should return success status, withdrawal amount, and new balance. The spender's authorization should be verified before allowing withdrawals.",
        "url": 925
    },
    {
        "nl_input": "The query requires identifying functions related to withdrawing funds in smart contracts. The relevant functions include a simple admin-only withdrawal, a complex withdrawal based on dates and user statuses, and a function to cancel withdrawal requests. The focus is on extracting withdrawal-related functionality from the provided code snippets.",
        "url": 926
    },
    {
        "nl_input": "The query requires a function that converts all of a caller's affiliate rewards into tokens. The function should check if the caller has any referral balance, reset the balance to zero, and then convert the balance into tokens, possibly triggering a reinvestment event. The solution should handle the conversion process securely and update the relevant balances accordingly.",
        "url": 927
    },
    {
        "nl_input": "The query requires a function to transfer ownership of a Vanity URL, ensuring the new owner doesn't already have a URL and the current owner does. The function should update mappings, emit an event, and clear the previous owner's data. The first code snippet meets these requirements by checking conditions, transferring the URL, and handling mappings and events, while the other snippets are for general ownership transfer, not specific to Vanity URLs.",
        "url": 928
    },
    {
        "nl_input": "The query requires identifying internal functions in smart contracts that perform specific operations: finalizing a process with admin restrictions, returning the contract's address, and calculating an index based on input validation. The functions must be internal, have clear return types, and include necessary checks or modifiers.",
        "url": 929
    },
    {
        "nl_input": "The query requires a smart contract function for internal transfers within the AIRA system, specifically allowing a designated bot to transfer tokens between addresses after verifying the sender's balance. The function should update balances and emit a transfer event. The target code should include access control (onlyBot modifier), balance checks, and token transfer logic. The ideal solution would mirror the first code snippet (c40111) with its airaTransfer function structure.",
        "url": 930
    },
    {
        "nl_input": "The query requires a function to retrieve the balance of a specified address, supporting both native ETH and ERC20 tokens. The first code snippet meets this need by checking if the token is ETH or an ERC20 token and returning the corresponding balance. The other snippets either only handle ETH balance or a predefined token owner's balance, making them less suitable for the query's requirements.",
        "url": 931
    },
    {
        "nl_input": "The query requires information about a function or modifier that checks or sets the start of a contribution or sale in a smart contract. The relevant code should include conditions or actions related to initiating a contribution phase, such as setting a start block or time, or verifying if the current block or time meets the start condition.",
        "url": 932
    },
    {
        "nl_input": "The query requires a function that can set multiple pixels in one transaction, ensuring that the number of pixel indexes matches the number of colors provided. The function should only set pixels if they are unassigned (painter is 0x0) and revert if no pixels are set. Finally, it should check if the canvas needs to be finalized after the operation.",
        "url": 933
    },
    {
        "nl_input": "The query requires a check to ensure a function throws an error if called before the crowdsale start time. The relevant code should include a modifier or condition that verifies the current time (`now`) is greater than or equal to the `startTime` before allowing the function to proceed. This prevents execution of the function prematurely. The description focuses on the time validation requirement for crowdsale-related functions. (80 words)",
        "url": 934
    },
    {
        "nl_input": "The query requires a function that sends profits or tokens to a specified beneficiary address, ensuring proper authorization, non-zero values, and updating the total supply and balances accordingly. The function should also handle token transfers and emit relevant events. The code examples provided involve transferring tokens to beneficiaries, checking conditions, updating balances, and emitting events, which align with the query's needs for secure and authorized token distribution.",
        "url": 935
    },
    {
        "nl_input": "The query requires setting the ID of the last token eligible for a prize, ensuring it is within the token limit and updating the validation state accordingly. The code should also reset counters and distribution IDs when setting this limit. The operation must be restricted to admin access and performed only during specific validation states (Unstarted or LimitSet).",
        "url": 936
    },
    {
        "nl_input": "The query seeks code snippets related to \"Stage start conditions\" in smart contracts. The requirements include functions or modifiers that check or set conditions for starting a stage, such as verifying contribution caps, stage transitions, or time-based checks. The desired code should handle stage initialization, validation, or transition logic within a contract's lifecycle. Examples include checking if a sale has ended, transitioning stages, or ensuring a minimum start time has been reached.",
        "url": 937
    },
    {
        "nl_input": "The query requires a function that allows setting an external manager capable of calling `setInterfaceImplementer()` on behalf of an address. The manager should be assignable by a specific role (e.g., owner or via a permission check) and should trigger an event upon assignment. The manager's address must be validated, and the function should prevent duplicate assignments. The solution involves a manager mapping, access control, and event emission.",
        "url": 938
    },
    {
        "nl_input": "The query requires a function to whitelist a funder's address, ensuring it's not a zero address, and emits an event upon addition. The function should be restricted to the owner or a whitelister and can handle single or multiple addresses. Storage of whitelisted addresses and event emission are essential features.",
        "url": 939
    },
    {
        "nl_input": "The query requires a description of logic for setting limits or constraints in smart contracts, such as minimum and maximum values, validation states, or rate ranges, with checks to ensure values are within specified bounds and appropriate state transitions. The functions should include require statements for validation and emit events or update states accordingly.",
        "url": 940
    },
    {
        "nl_input": "The query requires a smart contract that creates and distributes AVALANCHE ICE tokens, including allocations for advisors, bounty, community, company, and presale. The contract should allow minting tokens to specified addresses and ensure all community contributions are managed from a designated address. The contract must include owner-only functions for initialization and token preservation, with checks to prevent invalid addresses and enforce supply limits.",
        "url": 941
    },
    {
        "nl_input": "The query seeks code that checks if a pre-sale period is active based on date or time conditions. The requirements include verifying if the current date or time falls within a specified pre-sale range, ensuring the pre-sale amount is positive, and optionally checking if pre-sale is enabled. The code should return a boolean indicating whether the pre-sale is active.",
        "url": 942
    },
    {
        "nl_input": "The query requires a function to retrieve the block numbers for all revisions of a specific blob. The function should take a blob identifier as input, iterate through each revision of the blob, and return an array of block numbers corresponding to each revision. The solution involves querying the block number for each revision ID and compiling them into a list. The first code snippet fulfills this requirement by implementing the described logic.",
        "url": 943
    },
    {
        "nl_input": "The query requires setting up a bounty pool or similar reward mechanism in a smart contract. The suitable code should allow designating an address for the bounty pool or managing funds allocated for rewards, with functions to update the pool address or distribute funds. The description should focus on functions that handle bounty pool initialization, fund allocation, or reward distribution, typically restricted to contract owners or creators. (80 words)",
        "url": 944
    },
    {
        "nl_input": "The query seeks code snippets that implement getter functions named \"getPlayer\" or similar, which retrieve player-related information such as IDs, names, addresses, scores, or other attributes from a smart contract. The functions should be public or view/constant, returning player data in various formats (e.g., tuples, single values). The focus is on accessing player-specific details stored in the contract's state.",
        "url": 945
    },
    {
        "nl_input": "The query requires a function that allows an admin to finalize a delegation after a specified time (one day). The function should be restricted to admin or owner access, verify the admin's identity, check if the waiting period has passed, execute the delegation to a new contract, and clean up the operation data. The solution should ensure proper authorization and time-based conditions before processing the delegation.",
        "url": 946
    },
    {
        "nl_input": "The query requires a function to receive WEDU tokens from another user. The suitable code should include a transfer function that accepts tokens from an external address, typically involving a `transfer` or similar operation from an ERC20 token contract. The function should validate the sender and handle the token transfer securely. The expected description is concise, focusing on the token reception mechanism without detailed code analysis.",
        "url": 947
    },
    {
        "nl_input": "The query requires obtaining the current token price based on the current stage of the contract. The relevant code should check the contract's stage and return the token price accordingly, handling cases where the auction has ended or tokens are distributed by returning zero. The solution should involve a function that dynamically calculates or retrieves the price based on the stage, ensuring it is only accessible during valid sale periods.",
        "url": 948
    },
    {
        "nl_input": "The query requires a description of a smart contract function that retrieves base statistics for monsters based on their ID, allowing for efficient storage and evolution by referencing shared base stats. The function should return an array of stats (uint8[8]) for a given monster ID, enabling gas savings and reduced transactions during evolution. The focus is on stat retrieval without storing individual monster stats.",
        "url": 949
    },
    {
        "nl_input": "The query requires a function to release purchased tokens to buyers during a mainsale, adhering to Eidoo's ICOEngineInterface. The function should handle token distribution, calculate bonuses if applicable, manage refunds for excess payments, and update remaining token balances. It should also emit events for token purchases and refunds. The code should ensure the sale is active and validate buyer and signer addresses.",
        "url": 950
    },
    {
        "nl_input": "The query requires a Solidity modifier or function that ensures only the owner, depositor, or beneficiary can execute certain actions, reverting the transaction if called by any other account. The solution should include a `require` statement to validate the caller's address against these authorized roles and emit an error message if unauthorized. The focus is on access control for specific roles.",
        "url": 951
    },
    {
        "nl_input": "The query requires a smart contract function that distributes tokens to multiple accounts (airdrops). The function should accept parameters for the token contract, recipient addresses, and corresponding token amounts. It should iterate through the recipients and transfer the specified amounts, with optional checks for equal array lengths and ownership restrictions. The function may also include additional features like multipliers or timing constraints, but the core requirement is batch token distribution to multiple addresses.",
        "url": 952
    },
    {
        "nl_input": "The query requires checking if a specified address has approval to transfer a specific Cutie (a token or asset). The relevant code should verify the approval status by comparing the address with the approved claimant for the given Cutie ID. The expected function would return a boolean indicating whether the address is approved for the transfer.",
        "url": 953
    },
    {
        "nl_input": "The query requires a modifier that ensures a function can only be called by the GDPOracle account, reverting the transaction if called by any other account. The modifier should use `require` to check if `msg.sender` matches the GDPOracle address before executing the function.",
        "url": 954
    },
    {
        "nl_input": "The query requires a function that retrieves redemption details (redemption ID, reason, and value) for a specific address and redemption index from a smart contract. The function should ensure the address is valid and the index is within bounds before returning the requested redemption information. The first code snippet meets these requirements by checking conditions and fetching the redemption data from a structured storage mapping.",
        "url": 955
    },
    {
        "nl_input": "The query requires a function to transfer animals (or tokens representing animals) from one smart contract to another, including handling ownership checks, value calculations, and batch transfers. The solution should update balances, manage animal IDs, and ensure secure value transfers between contracts. The function must verify the sender's ownership of the animals and handle the transfer process atomically.",
        "url": 956
    },
    {
        "nl_input": "The query requires a description of a smart contract function that mints new tokens. The function should include checks for valid addresses, update token balances and total supply, and emit transfer events. It should be restricted to the contract owner and handle the minting process securely, ensuring proper event logging for transparency. The function parameters typically include the recipient's address and the amount of tokens to mint.",
        "url": 957
    },
    {
        "nl_input": "The query requires a function that allows the owner to delist or disable a feature by setting a cap to zero. This involves modifying a cap-related variable (minimum or maximum) through an owner-only function to effectively remove or deactivate the listing. The solution should ensure proper authorization (onlyOwner) and handle the cap adjustment securely.",
        "url": 958
    },
    {
        "nl_input": "The query requires a function to manually start a crowdsale, restricted to the owner, which can override the scheduled start date or resume a stopped crowdsale. The function should update the crowdsale status and start time, and may include additional checks or phases if applicable. The solution should ensure only the owner can trigger this action and handle any necessary state transitions or event emissions.",
        "url": 959
    },
    {
        "nl_input": "The query requires a function that returns the deed identifier of an owner at a specified index, ensuring the index is valid and iterating through deeds to find the correct one. The function should handle ownership checks and index validation.",
        "url": 960
    },
    {
        "nl_input": "The query requires a modifier that ensures a function can be called only once by checking if the number of attempted calls (`functAttempts`) is zero before execution. The modifier should increment or track attempts to prevent subsequent calls. The provided code snippet `modifier onlyOnce(){ require(functAttempts <= 0); _; }` meets this requirement by enforcing a single call limit.",
        "url": 961
    },
    {
        "nl_input": "The query requires a function that allows changing the development fee (dev fee) in a smart contract. The function should include access control (e.g., only the owner or validator can modify it) and may include constraints like a maximum fee limit. The fee can be specified as a numeric value (e.g., `uint16` or `uint256`). The change should update the stored fee value (e.g., `DevFee` or `transferFee`). Optionally, it may emit an event to log the fee update.",
        "url": 962
    },
    {
        "nl_input": "The query requires a description of the `transferFrom` function in Solidity contracts, which transfers tokens from one address to another after checking specific conditions like transfers being allowed, dividends, or KYC requirements. The function must call the parent contract's `transferFrom` and return a boolean success status.",
        "url": 963
    },
    {
        "nl_input": "The query requires a function that allows selling a specified amount of tokens to a contract. The function should deduct the sold tokens from the total supply, transfer them to the contract, and ensure sufficient token availability before the sale. Optionally, it may include checks for the sender's authorization and handle payment transfers if applicable. The core operations involve token balance updates, transfers, and validation checks.",
        "url": 964
    },
    {
        "nl_input": "The query requires a function that enables or disables an address to be a sender of EUR-T. The function should have parameters for the address and a boolean to set the permission, and it should include access control to restrict who can call it. The function may also emit an event to log the change. The target is to manage sender permissions for EUR-T transactions securely.",
        "url": 965
    },
    {
        "nl_input": "The query requires a description of smart contract functions related to refunds. The provided code snippets include functions to enable refunds (`enable_refunds`), process refunds (`refund`) with checks for unsuccessful sales or available refunds, and transfer the refunded amount to the sender. The refund logic involves resetting balances or invested amounts and emitting events or transferring funds. The requirements focus on implementing secure and conditional refund mechanisms in smart contracts.",
        "url": 966
    },
    {
        "nl_input": "The query requires code that enables the purchase of shares, specifically involving a function to buy tokens or shares with parameters like address and value, and possibly including price calculations and transfer mechanisms. The desired functionality should handle the transaction securely, checking balances and prices, and transferring the appropriate amount of tokens or shares to the buyer.",
        "url": 967
    },
    {
        "nl_input": "The query requires a description of a smart contract function that sends an Oraclize query to an external API, checks if there's enough ETH to cover the query fee, and handles different API calls based on previous query states. The function should emit events for query status and manage query parameters like timestamps and API usage. The description should be concise, within 80 words.",
        "url": 968
    },
    {
        "nl_input": "The query requires a function that confirms an autosell operation by checking if the available tokens meet the requested amount. The function should return a boolean indicating whether the sale can proceed (true if sufficient tokens are available, false otherwise). The solution should involve an internal or public view function that validates the token amount against a predefined limit or available balance.",
        "url": 969
    },
    {
        "nl_input": "The query requires an internal method that creates a new Zodiac with specified attributes (matronId, sireId, generation, genes, owner, zodiacType), validates input parameters, initializes a Zodiac struct, stores it, emits a Birth event, transfers ownership, and returns the new Zodiac's ID. The method must handle cooldown logic and ensure data integrity through type checks.",
        "url": 970
    },
    {
        "nl_input": "The query requires a function or modifier that checks the deployment stage or ownership to execute specific actions during the setup or deployment phase of a contract. The relevant code should include conditions like `only_owner` or `at_stage(Stages.Deploying/SetUp)` to ensure proper execution timing and authorization.",
        "url": 971
    },
    {
        "nl_input": "The query requires information about the index of a newly created snapshot in a smart contract. The relevant code should include functionality that creates a snapshot and returns its index, typically involving incrementing a snapshot counter, storing snapshot details (like token counts and addresses), and emitting an event. The focus is on retrieving the index value after snapshot creation.",
        "url": 972
    },
    {
        "nl_input": "The query requires a function or method that retrieves the level of a hero or character, typically from a smart contract. The desired code should accept a hero identifier (like a token ID) and return the hero's current level as a numeric value (e.g., uint32 or uint256). The function should be viewable or callable externally to fetch the level without modifying the contract state.",
        "url": 973
    },
    {
        "nl_input": "The query requires a description of how to retrieve the total number of tokens in existence from a smart contract. The relevant code snippets show functions like `totalSupply()` returning `numTokens`, `createTokens()` setting `totalSupply`, and `tokensAvailable()` calculating available tokens based on `totalAccounted` and `tokenCapPhaseOne`. The focus is on accessing or calculating the total token supply within a contract.",
        "url": 974
    },
    {
        "nl_input": "The query requires a function to withdraw all released vesting coins to the user's balance. The function should iterate through vesting entries, calculate the released amount, update the withdrawn amount, and transfer the remaining released coins to the user's balance. The first code snippet meets this requirement by handling vesting withdrawals, while the other two snippets are unrelated as they only transfer contract balances to owners.",
        "url": 975
    },
    {
        "nl_input": "The query requires a description of the `doProxyAccounting` function, which is an internal function that handles fee pledging by the owner. It checks controller status, updates window final block, pledges fees, and creates tokens if specified. The function emits a log event for contributions and ensures token generation for the owner if the pledged amount converts to tokens. The description focuses on the fee and token management aspects of the function.",
        "url": 976
    },
    {
        "nl_input": "The query requires a function that enables marketing contributors to withdraw their reward tokens. The function should verify the contributor's reward balance, transfer the specified tokens, update the remaining rewards, and record the transaction. It should include checks for valid token amounts and ensure only authorized contributors or owners can execute the withdrawal. The function should also emit an event to log the withdrawal details.",
        "url": 977
    },
    {
        "nl_input": "The query requires a smart contract function that releases vested tokens back to the Hut34 wallet. The function should check vesting conditions, update the release date, and transfer the vested tokens to the specified wallet. The ideal solution involves validating the release time, updating vesting state, and executing the token transfer in a single transaction.",
        "url": 978
    },
    {
        "nl_input": "The query requires setting or updating a token's symbol in a smart contract. The code snippets show functions to set the symbol directly (`setSymbol`), retrieve the symbol (`symbol`), or update both the name and symbol simultaneously (`setTokenInformation`). The functions may include access control modifiers like `onlyOwner` and emit events for updates. The symbol is typically stored as a `bytes32` or `string` variable within the contract.",
        "url": 979
    },
    {
        "nl_input": "The query requires a smart contract function that enables token transfers only after trading has started. The function should check if trading is active before allowing the transfer of tokens from one address to another. The transfer should be conditional on the trading status and may include additional checks like token availability or pause state. The function must return a boolean indicating success and emit relevant transfer details.",
        "url": 980
    },
    {
        "nl_input": "The query requires code that checks if the sender is a whitelisted agent and reverts the transaction if not. The desired functionality involves a modifier or function that enforces this access control, specifically verifying `msg.sender` against a predefined `whiteListAgent` address. The other provided codes (disabling whitelists or removing addresses from whitelists) are not relevant to this requirement.",
        "url": 981
    },
    {
        "nl_input": "The query requires a smart contract function that adjusts an inflation rate starting at 100, decreasing by 30 annually until it reaches 10, then decreasing by 0.5 thereafter. The function should update the rate based on time intervals and apply the new rate to minting calculations for pools, owners, and staking. The adjustment logic must handle the rate change thresholds (100 and 10) and ensure annual updates.",
        "url": 982
    },
    {
        "nl_input": "The query requires a function to transfer tokens from one user address to another, ensuring proper authorization and balance updates. The function should handle token transfers between specified addresses, check for valid amounts, and possibly include ownership or permission checks. The transfer should deduct tokens from the sender's balance and add them to the recipient's balance, emitting a transfer event if applicable. Authorization may involve checks like sender validation or owner-only restrictions.",
        "url": 983
    },
    {
        "nl_input": "The query requires code that removes an auction from public visibility and returns the associated token to the seller. The solution should involve canceling the auction, transferring the token back to the seller, and updating the auction state to reflect the removal. The code should ensure the auction is no longer accessible or visible to the public after the operation.",
        "url": 984
    },
    {
        "nl_input": "The query requires a function to approve minting a specified `_amount` of tokens to a designated `_owner`, ensuring validations for non-zero address, positive amount, no overflow in locked tokens and total supply, adherence to supply cap, and updating lock details with a duration. It must emit an event and return a boolean upon success.",
        "url": 985
    },
    {
        "nl_input": "The query requires a function that returns the contract's balance as the jackpot value if incomplete, otherwise returns a stored final value. The code must check a completion status variable and conditionally return either the current balance or the finalized amount.",
        "url": 986
    },
    {
        "nl_input": "The query requires determining the ETH received from selling BOB, calculated as the minimum between the available contract balance (divided by buy price) and the input BOB amount (divided by units), multiplied by the buy price. The code enforces valid transfers and ensures the contract's balance covers the transaction.",
        "url": 987
    },
    {
        "nl_input": "The query requires a modifier ensuring that the deposit function is only accessible by the contract owner or addresses explicitly granted deposit access. The modifier checks if the caller is the owner or has `depositAccess` permission, enforcing access control mechanism for deposit-related operations.",
        "url": 988
    },
    {
        "nl_input": "The code checks if an address is allowed to bypass the global freeze by verifying if the account is marked as frozen in the `frozenAccount` mapping. If `frozenAccount[account]` returns `false`, the address is not frozen and can bypass the freeze. The logic relies on per-account freezing rather than a global freeze mechanism.",
        "url": 989
    },
    {
        "nl_input": "The query requires a description of how to handle a callback from Oraclize for generating and verifying a random number in a smart contract. The callback should check the sender's address, validate the bet state, verify the random number proof, and process the bet outcome based on the generated random numbers, including handling wins, losses, and potential errors. The contract should also manage gas prices for Oraclize queries if specified.",
        "url": 990
    },
    {
        "nl_input": "The query requires a function that allows the contract owner to update the exchange rate between TCR and ETH. The function should be restricted to the owner and accept a new rate value as input. The rate update should directly modify the stored rate variable. The function should not include additional conditions or calculations beyond the basic rate update.",
        "url": 991
    },
    {
        "nl_input": "The query requires a description of how to check if an account is frozen in a smart contract. The relevant code snippets show functions to check frozen status (`checkFrozenAccounts`), freeze a single account (`freezeAccount`), or freeze multiple accounts (`freezeAccounts`). The key feature is accessing the `frozenAccount` mapping to determine or set the frozen state of an address. The query focuses on verifying the frozen status of an account.",
        "url": 992
    },
    {
        "nl_input": "The query requires a smart contract function that allows the owner to send any transaction, similar to a multi-signature setup, to handle transfers of pledges or tokens between campaigns or DACs. The function should ensure owner privileges and support token transfers, possibly including checks or conditions for successful transactions.",
        "url": 993
    },
    {
        "nl_input": "The query seeks a functionality to disable or nullify a contract, typically restricted to the owner. The suitable code should include a function that sets a state (like `nullified = true`) or triggers self-destruction (`selfdestruct`). Examples include a `nullify` function to disable the contract or a `shutdown` function to destroy it. The `disableWhitelist` function is less relevant as it only modifies a whitelist state.",
        "url": 994
    },
    {
        "nl_input": "The query requires a function that allows only the major/actual owner wallet to remove a minor owner. The function should validate that the minor owner address is valid, check the minor owner's share, and transfer their share (10%) back to the major owner while ensuring the major owner's total share does not exceed 90%. The function must include access control restricted to the owner.",
        "url": 995
    },
    {
        "nl_input": "The query requires retrieving the value of a node. The suitable code for this is the first option, which includes a function `getNodeValue(bytes32 nodeId)` that returns the value of a specified node by querying an index lookup and node-to-index mapping. The function is part of a contract that interfaces with a library (`GroveLib`) to fetch the node value. The description focuses on node value retrieval without additional data like public keys or balances.",
        "url": 996
    },
    {
        "nl_input": "The query requires identifying who can transfer tokens, specifying that only the owner and distributors have this permission. The code snippets show that token transfers are restricted to the owner (via `onlyOwner` modifier) and authorized distributors (checked via `distributors[msg.sender]`). Additionally, distributors must meet certain conditions like token whitelisting and balance requirements. The description should highlight these roles and their transfer permissions concisely.",
        "url": 997
    },
    {
        "nl_input": "The query requires a function to set a charity address in a smart contract, restricted to the owner. The function should update the charity address and may include access control modifiers like `onlyOwner`. The desired code should resemble the first example, which directly sets the `charityAddress` with an owner-only restriction. The other examples, while similar, set different addresses (signer or treasury) and do not match the charity address requirement. (80 words)",
        "url": 998
    },
    {
        "nl_input": "The query requires a function that can set or retrieve a server-side address in a smart contract. The function should allow updating the address with checks or return the current contract's address. Options include setting an admin or signer address with ownership restrictions or returning the contract's own address. The function must ensure security by validating the new address and emitting events for changes.",
        "url": 999
    }
]