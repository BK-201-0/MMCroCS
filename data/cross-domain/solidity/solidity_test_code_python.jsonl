[
    {
        "code_input": "class OwnerManager:\n    def __init__(self):\n        self.owners = []\n        self.is_owner = {}\n\n    def replace_owner(self, owner, new_owner):\n        if owner in self.owners:\n            index = self.owners.index(owner)\n            self.owners[index] = new_owner\n            self.is_owner[new_owner] = True\n            self.is_owner[owner] = False\n            self.owner_addition(new_owner)\n            self.owner_removal(owner)\n\n    def owner_addition(self, owner):\n        pass  # Implement this function to handle the addition of a new owner\n\n    def owner_removal(self, owner):\n        pass  # Implement this function to handle the removal of an owner",
        "gt": "contract c29479{ function replaceOwner(address owner, address newOwner) public onlyWallet onlyOwnerExists(owner) onlyOwnerDoesNotExist(newOwner) { for (uint256 i = 0; i < owners.length; i++) { if (owners[i] == owner) { owners[i] = newOwner; break; } } isOwner[owner] = false; isOwner[newOwner] = true; OwnerRemoval(owner); OwnerAddition(newOwner); } }",
        "url": 0
    },
    {
        "code_input": "import hashlib\n\ndef compute_real_cap(cap, key):\n    return hashlib.sha256((str(cap) + str(key)).encode()).hexdigest()",
        "gt": "contract c24941{ function computeRealCap(uint256 _cap, uint256 _key) public pure returns (bytes32) { return keccak256(_cap, _key); } }",
        "url": 1
    },
    {
        "code_input": "The given Solidity code is a simple Ethereum contract for a cryptocurrency named \"PKCoin\". It has the following main functionality:\n\n1. The contract has a constructor that initializes the contract with a total supply of 13520000000 tokens, a name of \"PKCoin\", a decimal point precision of 18, and a symbol of \"PKCN\".\n\n2. The contract has a function `unitsOneEthCanBuy` that returns the number of units of the token that can be bought in one Ethereum unit (eth).\n\n3. The contract has a function `fundsWallet` that returns the address of the wallet that has funds in the contract.\n\n4. The contract has a function `balanceOf` that returns the balance of a given address.\n\n5. The contract has a function `transfer` that allows a sender to transfer a certain amount of tokens to a recipient.\n\n6. The contract has a function `mint` that allows a minter to mint a certain amount of tokens to a recipient.\n\n7. The contract has a function `approve` that allows a spender to appro",
        "gt": "contract c90{ function HashnodeTestCoin() { balances[msg.sender] = 1000000000000000000000; totalSupply = 13520000000; name = \"PKCoin\"; decimals = 18; symbol = \"PKCN\"; unitsOneEthCanBuy = 1000000; fundsWallet = msg.sender; } }",
        "url": 2
    },
    {
        "code_input": "class C21997:\n    def __init__(self, contract_instance):\n        self.contract_instance = contract_instance\n\n    def set_holder_amount(self, amount):\n        \"\"\"\n        This function sets the holder amount.\n        :param amount: The amount to set as the holder amount.\n        :return: None\n        \"\"\"\n        # Check if the caller is the owner\n        if self.contract_instance.caller != self.contract_instance.owner:\n            raise ValueError(\"",
        "gt": "contract c21997{ function setHolderAmount(uint256 amount) public onlyOwner { holderAmount = amount; } }",
        "url": 3
    },
    {
        "code_input": "class ERC20:\n    def __init__(self, contract_address, abi):\n        self.contract_address = contract_address\n        self.abi = abi\n        self.web3 = Web3(HTTPProvider('http://localhost:8545'))\n        self.contract = self.web3.eth.contract(address=self.contract_address, abi=self.abi)\n\n    def balanceOf(self, owner):\n        return self.contract.functions.balanceOf(owner).call()\n\n# Usage\nerc20 = ERC20('0x...', '...')  # replace with your contract address and ABI\nprint(erc20.balanceOf('0x...'))  # replace with the address you want to check",
        "gt": "contract c27605{ function balanceOf(address _owner)public view returns (uint256 balance) { return balances[_owner]; } }",
        "url": 4
    },
    {
        "code_input": "class Token:\n    def __init__(self, initial_supply):\n        self.totalSupply = initial_supply\n        self.balanceOf = {msg.sender: initial_supply}\n\n    def allowance(self, owner, spender):\n        return self.allowed[owner][spender]\n\n    def approve(self, spender, value):\n        self.allowed[msg.sender][spender] = value\n        return True\n\n    def burnFrom(self, owner, value):\n        if value > self.balanceOf[owner]:\n            return False\n        self.balanceOf[owner] -= value\n        self.totalSupply -= value\n        return True",
        "gt": "contract c34379{ function burnFrom(address _from, uint256 _value) returns (bool success) { if (balanceOf[_from] < _value) revert(); if (_value > allowance[_from][msg.sender]) revert(); balanceOf[_from] -= _value; totalSupply -= _value; Burn(_from, _value); return true; } }",
        "url": 5
    },
    {
        "code_input": "class C9746:\n    def __init__(self):\n        self.tranches = None\n        self.current_round = None\n        self.caps = [0, 0, 0, 0, 0]\n        self.completed_at = None\n\n    def check_if_funding_complete_or_expired(self):\n        if self.tranches != 'Successful':\n            if self.current_round > self.caps[0] and self.tranches == 'Round1':\n                self.tranches = 'Round2'\n                self.current_round = 0\n            elif self.current_round > self.caps[1] and self.tranches == 'Round2':\n                self.tranches = 'Round3'\n                self.current_round = 0",
        "gt": "contract c9746{ function checkIfFundingCompleteOrExpired() internal { if(tranches != Tranches.Successful){ if(currentRound > caps[0] && tranches == Tranches.Round1){ tranches = Tranches.Round2; currentRound = 0; } else if(currentRound > caps[1] && tranches == Tranches.Round2){ tranches = Tranches.Round3; currentRound = 0; } else if(currentRound > caps[2] && tranches == Tranches.Round3){ tranches = Tranches.Round4; currentRound = 0; } else if(currentRound > caps[3] && tranches == Tranches.Round4){ tranches = Tranches.Round5; currentRound = 0; } } else { tranches = Tranches.Successful; completedAt = now; } } }",
        "url": 6
    },
    {
        "code_input": "class BribedCitizen:\n    def __init__(self, balance):\n        self.balance = balance\n\n    def surrender(self):\n        if self.msg.sender == bribedCitizen:\n            bribedCitizen.transfer(address(self), self.balance)\n            self.selfdestruct()\n\n# Create a new instance of the BribedCitizen contract\nbribedCitizen = BribedCitizen(1000000000000000000000)\n\n# Call the surrender function\nbribedCitizen.surrender()",
        "gt": "contract c40573{ function surrender() { if (msg.sender == bribedCitizen) { bribedCitizen.send(address(this).balance); selfdestruct(bribedCitizen); } } }",
        "url": 7
    },
    {
        "code_input": "class DataRequest:\n    def __init__(self, dataUrl, dataPoints, initialized):\n        self.dataUrl = dataUrl\n        self.dataPoints = dataPoints\n        self.initialized = initialized\n\nclass C40382:\n    def __init__(self):\n        self.dataRequests = {}\n\n    def getDataRequest(self, id):\n        if id in self.dataRequests:\n            dataRequest = self.dataRequests[id]\n            return GetDataRequest(id, dataRequest.initialized, dataRequest.dataUrl, len(dataRequest",
        "gt": "contract c40382{ function getDataRequest(uint id) { DataRequest dataRequest = dataRequests[id]; GetDataRequest(id, dataRequest.initialized, dataRequest.dataUrl, dataRequest.dataPoints.length); } }",
        "url": 8
    },
    {
        "code_input": "class Contract:\n    def __init__(self, controller):\n        self.controller = controller\n\n    def detach_controller(self):\n        # Get the current controller address\n        current_controller = self.controller\n\n        # Set the controller address to 0 (which means it's not attached)\n        self.controller = address(0)\n\n        # Call the function to retire the controller\n        self.controller_retired(current_controller)\n\n    def controller_retired(self, controller):\n        # This function should be implemented in the contract. It's called when the controller is retired.\n        # The parameter is the address of the controller that was retired.\n        pass",
        "gt": "contract c32523{ function detachController() external onlyController { address was = m_controller; m_controller = address(0); ControllerRetired(was); } }",
        "url": 9
    },
    {
        "code_input": "The given Solidity code is a function that enables token withdrawals for a specific token. Here's a high-level description of the function and its logic:\n\n1. The function `enableTokenWithdrawals` is declared as public, meaning it can be called by anyone.\n2. The function is only allowed to be called by the contract's owner (`onlyOwner`).\n3. The function is marked as `noReentrancy`, which means it can't be called again after it has been called.\n4. The function first checks if the contract's stage is 2 (`contractStage == 2`).\n5. If `notDefault` is true, it checks if there is an active token (`activeToken != 0x00`).\n6. If `notDefault` is false, it sets the active token to the given token address.\n7. It then calculates the balance of the active token and the remaining balance of the distribution map.\n8. The function checks if the balance is greater than 0.\n9. If the fee percentage is greater than 0, it transfers the remaining balance of the active token to the contract'",
        "gt": "contract c9458{ function enableTokenWithdrawals (address tokenAddr, bool notDefault) public onlyOwner noReentrancy { require (contractStage == 2); if (notDefault) { require (activeToken != 0x00); } else { activeToken = tokenAddr; } var d = distributionMap[tokenAddr]; if (d.pct.length==0) d.token = ERC20(tokenAddr); uint amount = d.token.balanceOf(this).sub(d.balanceRemaining); require (amount > 0); if (feePct > 0) { require (d.token.transfer(owner,_applyPct(amount,feePct))); } amount = d.token.balanceOf(this).sub(d.balanceRemaining); d.balanceRemaining = d.token.balanceOf(this); d.pct.push(_toPct(amount,finalBalance)); } }",
        "url": 10
    },
    {
        "code_input": "class C40557:\n    def __init__(self, records, keys):\n        self.records = records\n        self.keys = keys\n\n    def theGames(self, rindex):\n        record = self.records[self.keys[rindex]]\n        contractAddress = self.keys[rindex]\n        description = record.description\n        url = record.url\n        submittedBy = record.owner\n        time = record.time\n        return contractAddress, description, url, submittedBy, time",
        "gt": "contract c40557{ function theGames(uint rindex) constant returns(address contractAddress, string description, string url, address submittedBy, uint time) { Record record = records[keys[rindex]]; contractAddress = keys[rindex]; description = record.description; url = record.url; submittedBy = record.owner; time = record.time; } }",
        "url": 11
    },
    {
        "code_input": "class C13665:\n    def __init__(self, contract_instance):\n        self.contract_instance = contract_instance\n        self.prize_pool = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
        "gt": "contract c13665{ function withdrawPrize() external checkState(pointsValidationState.Finished){ uint256 prize = 0; uint256[] memory tokenList = tokensOfOwnerMap[msg.sender]; for(uint256 i = 0;i < tokenList.length; i++){ prize += tokenToPayoutMap[tokenList[i]]; tokenToPayoutMap[tokenList[i]] = 0; } require(prize > 0); msg.sender.transfer((prizePool.mul(prize)).div(1000000)); } }",
        "url": 12
    },
    {
        "code_input": "class Casino:\n    def __init__(self, id, star, owner, price, name, desc):\n        self.id = id\n        self.star = star\n        self.owner = owner\n        self.price = price\n        self.name = name\n        self.desc = desc\n\nclass C13763:\n    def __init__(self):\n        self.allCasinos = {}\n        self.ids = []\n\n    def addCasino(self, star, price, name, desc):\n        newID = len(self.ids) + 1\n        item = Casino(newID, star, None, price, name, desc)\n        self.allCasinos[newID] = item\n        self.ids.append(newID)",
        "gt": "contract c13763{ function addCasino(uint16 _star, uint _price, string _name, string _desc) internal { uint newID = ids.length + 1; Casino memory item = Casino({ id:uint16(newID), star:_star, owner:cooAddress, price:_price, name:_name, desc:_desc }); allCasinos[newID] = item; ids.push(newID); } }",
        "url": 13
    },
    {
        "code_input": "The given Solidity contract is a basic ERC20 token contract. It allows transferring tokens from one account to another. Here's a high-level description of the main functionality and logic:\n\n1. The contract is a public contract, meaning it can be called and interacted with by anyone.\n\n2. The `transfer` function is a public function that allows transferring tokens from one account to another.\n\n3. The function takes two parameters: `_to`, the address of the recipient, and `_value`, the amount of tokens to transfer.\n\n4. The function first checks if the contract is not paused. If it is, the function returns false.\n\n5. The function then checks if the sender of the transaction is a unpaused wallet. If it is, the function returns false.\n\n6. The function then calculates the available balance of the sender. It subtracts the value of the tokens that are blocked from the available balance.\n\n7. The function then checks if the value of the tokens to transfer is greater than 0 and less than or equal to the available balance.\n\n8. If the conditions are met, the function subtracts",
        "gt": "contract c25612{ function transfer(address _to, uint256 _value) public returns (bool) { require(!paused()||unpausedWallet[msg.sender]||unpausedWallet[_to]); uint256 available = balances[msg.sender].sub(valueBlocked(msg.sender)); require(_value <= available); require (_value > 0); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } }",
        "url": 14
    },
    {
        "code_input": "class C4003:\n    def __init__(self, web3, address):\n        self.web3 = web3\n        self.address = address\n        self.contract = web3.eth.contract(address=address, abi=abi)\n\n    def toggle_locked(self):\n        nonce = self.web3.eth.getTransactionCount(self.address)\n        txn = self.contract.functions.toggleLocked().buildTransaction({\n            'nonce': nonce,\n        })\n        signed_txn = self.web3.eth.account.signTransaction(txn, private_key=private_key)\n        tx_hash = self.web3.eth.sendRawTransaction",
        "gt": "contract c4003{ function toggleLocked() public onlyOwner { locked = !locked; emit ToggleLocked(locked); } }",
        "url": 15
    },
    {
        "code_input": "class C20691:\n    def __init__(self, start, end):\n        self.start = start\n        self.end = end\n        self.owner = None\n        self.pending_owner = None\n\n    def claim_ownership(self):\n        if self.owner is None:\n            if (self.start <= block.number <= self.end):\n                self.pending_owner = self.owner\n                self.owner = self.pending_owner\n                self.pending_owner = None\n                self.end = 0\n\n    def set_start(self, start):",
        "gt": "contract c20691{ function claimOwnership() onlyPendingOwner public { require((block.number <= end) && (block.number >= start)); OwnershipTransferred(owner, pendingOwner); owner = pendingOwner; pendingOwner = address(0); end = 0; } }",
        "url": 16
    },
    {
        "code_input": "The given Solidity code is a contract for a token transfer function. The contract is named `c10120`. The function `transfer` is a public function in the contract. It takes two parameters: `_to`, which is the address to which the tokens should be transferred, and `_amount`, which is the amount of tokens to be transferred.\n\nThe function first checks if the `tokensTradeable` is true. If it's not, the function will revert the transaction.\n\nNext, the function checks if the `_amount` is less than or equal to the balance of the sender (`unlockedTokensInternal(msg.sender)`). If the `_amount` is greater than the balance, the function will revert the transaction.\n\nFinally, the function calls the `super.transfer(_to, _amount)` function, which is a function in the base contract (`OpenZeppelin Contracts, MIT License`). This function transfers the tokens from the sender's account to the specified address.\n\nIf the `tokensTradeable` is true and the `_amount` is less than or equal to",
        "gt": "contract c10120{ function transfer(address _to, uint _amount) public returns (bool success) { require(tokensTradeable); require(_amount <= unlockedTokensInternal(msg.sender)); return super.transfer(_to, _amount); } }",
        "url": 17
    },
    {
        "code_input": "class TokenDistributor:\n    def __init__(self, owner, AllocateToken):\n        self.owner = owner\n        self.AllocateToken = AllocateToken\n\n    def distribute_tokens(self, receivers):\n        if self.",
        "gt": "contract c14116{ function AllocateToken(address[] a_receiver) external IsOwner AllLock { uint receiverLength = a_receiver.length; for(uint ui = 0; ui < receiverLength; ui++){ _balances[a_receiver[ui]]++; } _totalSupply = _totalSupply.add(receiverLength); } }",
        "url": 18
    },
    {
        "code_input": "class TokenAllowance:\n    def __init__(self, contract):\n        self.contract = contract\n\n    def allowance(self, tokenOwner, spender):\n        # The allowance function is a read-only function that returns the remaining allowance for the spender.\n        # It takes two parameters: tokenOwner and spender.\n        # The function returns the remaining allowance for the spender.\n        # In this case, the function returns 0 as the remaining allowance is not set.\n        return 0\n\n# Create an instance of the TokenAllowance class\ntoken_allowance = TokenAllowance(c608)\n\n# Call the allowance function\nprint(token_allowance.allowance(address1, address2))",
        "gt": "contract c608{ function allowance(address tokenOwner, address spender) public constant returns (uint256 remaining) { tokenOwner; spender; return uint256(0); } }",
        "url": 19
    },
    {
        "code_input": "class C1879Contract:\n    def __init__(self, implementation):\n        self.implementation = implementation\n\n    def _delegate(self):\n        # The assembly block is used to perform low-level operations.\n        # calldatacopy copies the calldata to the memory, which is then passed to the delegatecall.\n        # delegatecall is a low-level function that calls a function in a contract.\n        # The gas parameter is the amount of gas to use.\n        # The implementation parameter is the address of the contract to call.\n        # The 0, 0, calldatasize, 0, 0 are the parameters for the delegatecall.\n        # returndatacopy copies the return data to the memory.\n        # switch statement is used to handle the result of the delegatecall",
        "gt": "contract c1879{ function _delegate(address implementation) internal { assembly { calldatacopy(0, 0, calldatasize) let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0) returndatacopy(0, 0, returndatasize) switch result case 0 { revert(0, returndatasize) } default { return(0, returndatasize) } } } }",
        "url": 20
    },
    {
        "code_input": "class C36564:\n    def __init__(self):\n        self.m_numOwners = 0\n        self.m_owners = []\n        self.m_ownerIndex = {}\n\n    def addOwner(self, _owner):\n        if _owner in self.m_owners:\n            raise Exception(\"Owner already exists\")\n        if self.m_numOwners >= MAX_OWNERS:\n            raise Exception(\"Maximum number of owners reached\")\n        self.m_numOwners += 1\n        self.m_owners.append(_owner)\n        self.m_ownerIndex[_owner] = self.check_owner_index(self.m_numOwners)\n        self.assert_owners_are_consistent()\n        self.owner_added(_owner)\n\n    def check_owner_index(self, _num_owners):",
        "gt": "contract c36564{ function addOwner(address _owner) external ownerDoesNotExist(_owner) validNumOwners(m_numOwners + 1) onlymanyowners(sha3(msg.data)) { assertOwnersAreConsistent(); clearPending(); m_numOwners++; m_owners[m_numOwners] = _owner; m_ownerIndex[_owner] = checkOwnerIndex(m_numOwners); assertOwnersAreConsistent(); OwnerAdded(_owner); } }",
        "url": 21
    },
    {
        "code_input": "def check_string_length(name, min, max):\n    # Convert the string to bytes\n    temp = bytes(name, 'utf-8')\n    \n    # Check if the length of the bytes array is within the range\n    return min <= len(temp) <= max",
        "gt": "contract c16324{ function checkStringLength(string name, uint min, uint max) internal pure returns (bool) { bytes memory temp = bytes(name); return temp.length >= min && temp.length <= max; } }",
        "url": 22
    },
    {
        "code_input": "class C434:\n    def __init__(self, web3, address):\n        self.web3 = web3\n        self.address = address\n        self.contract = web3.eth.contract(address=address, abi=ABI)\n\n    def is_pause_save(self):\n        # This function is not defined in the given Solidity code, but it's assumed to be a method of the contract.\n        # It's used to check if the contract is paused.\n        pass\n\n    def coolduwn_up(self, mother):\n        # This function is used to update the birth count and last time of a mother rabbit.\n        # It's assumed that the contract has a method called `cooldu",
        "gt": "contract c434{ function coolduwnUP(uint32 _mother) internal { require(isPauseSave()); rabbits[(_mother-1)].birthCount = rabbits[(_mother-1)].birthCount.add(1); rabbits[(_mother-1)].birthLastTime = now; emit CoolduwnMother(_mother, rabbits[(_mother-1)].birthCount); } }",
        "url": 23
    },
    {
        "code_input": "class C21487:\n    def __init__(self, owner, migrate_to=None):\n        self.owner = owner\n        self.migrate_to = migrate_to\n\n    def set_migrate_to(self, _addr):\n        if self.owner == _addr:\n            self.migrate_to = _addr\n        else:\n            raise ValueError(\"Only the contract owner can set the migrate_to address.\")",
        "gt": "contract c21487{ function setMigrateTo(address _addr) public only_owner { migrateTo = _addr; } }",
        "url": 24
    },
    {
        "code_input": "class TokenSale:\n    def __init__(self, total_supply_limit, min_transaction_amount_eth, presale_start_date, presale_end_date, calculate_price_func):\n        self.totalSupplyLimit = total_supply_limit\n        self.minTransactionAmountEth = min_transaction_amount_eth\n        self.presaleStartDate = presale_start_date\n        self.presaleEndDate = presale_end_date\n        self.",
        "gt": "contract c36003{ function buyTokens(address _buyer) public payable { require(totalSupply < TOKEN_SUPPLY_LIMIT); uint valueWei = msg.value; require(currentPhase == Phase.Running); require(valueWei >= MIN_TRANSACTION_AMOUNT_ETH); require(now >= PRESALE_START_DATE); require(now <= PRESALE_END_DATE); uint newTokens = calculatePrice(valueWei); require(newTokens > 0); require(totalSupply + newTokens <= TOKEN_SUPPLY_LIMIT); totalSupply += newTokens; balanceTable[_buyer] += newTokens; LogBuy(_buyer, valueWei, newTokens); } }",
        "url": 25
    },
    {
        "code_input": "class Contract:\n    def __init__(self, tokens):\n        self.tokens = tokens\n\n    def tokenUnits(self):\n        tokenUnits = [token.tokenUnits for token in self.tokens]\n        return tokenUnits",
        "gt": "contract c23861{ function tokenUnits() external view returns (uint256[]){ uint256[] memory tokenUnits = new uint256[](tokens.length); for (uint i = 0; i < tokens.length; i++) { tokenUnits[i] = tokens[i].tokenUnits; } return tokenUnits; } }",
        "url": 26
    },
    {
        "code_input": "class MultiSignatureWallet:\n    def __init__(self):\n        self.multiSigAddress = None\n\n    def changeMultiSigAddress(self, _address):\n        if _address != address(0):\n            self.multiSigAddress = _address\n        else:\n            raise ValueError(\"Address cannot be 0\")",
        "gt": "contract c26971{ function changeMultiSigAddress(address _address) public onlyMultiSig { require(_address != address(0)); multiSigAddress = _address; } }",
        "url": 27
    },
    {
        "code_input": "The given Solidity code is a contract for a token that allows the owner to burn tokens. Here's a high-level description of the main functionality and logic:\n\n1. The contract is named `c21783`.\n2. The function `burnToken` is declared as `onlyOwner` and `whenNotPaused`.\n3. The function `burnToken` is only accessible to the contract owner.\n4. The function `burnToken` is only called when the contract is not paused.\n5. The function `burnToken` is a public function that returns a boolean.\n6. The function `burnToken` checks if the contract has ended.\n7. The function `burnToken` checks if there are still burn tokens left.\n8. The function `burnToken` sets the `checkBurnTokens` flag to true.\n9. The function `burnToken` burns the remaining public supply of the token.\n10. The function `burnToken` decreases the total supply of the token by the remaining public supply.\n11. The function `burnToken` resets the remaining public supply, pre-sale supply, ico supply, and ",
        "gt": "contract c21783{ function burnToken() onlyOwner whenNotPaused public returns (bool) { require(hasEnded()); require(!checkBurnTokens); checkBurnTokens = true; token.burnTokens(remainingPublicSupply); totalSupply = SafeMath.sub(totalSupply, remainingPublicSupply); remainingPublicSupply = 0; preSaleSupply = 0; preicoSupply = 0; icoSupply = 0; return true; } }",
        "url": 28
    },
    {
        "code_input": "class TokenSale:\n    def __init__(self, contract_address, start_block, end_block, token_generation_min):\n        self.contract_address = contract_address\n        self.start_block = start_block\n        self.end_block = end_block\n        self.token_generation_min = token_generation_min\n        self.total_tokens = 0\n\n    def refund(self, msg_sender, contribution, balances):\n        if (contribution[msg_sender] > 0 and\n            not self.sale_completed and\n            self.total_tokens < self.token_generation_min and\n            block.",
        "gt": "contract c38407{ function refund() external { require( (contribution[msg.sender] > 0) && (!saleCompleted) && (totalTokens < tokenGenerationMin) && (block.number > end_block) ); uint256 tokenBalance = balances[msg.sender]; uint256 refundBalance = contribution[msg.sender]; balances[msg.sender] = 0; contribution[msg.sender] = 0; totalTokens = safeSub(totalTokens, tokenBalance); WolkDestroyed(msg.sender, tokenBalance); LogRefund(msg.sender, refundBalance); msg.sender.transfer(refundBalance); } }",
        "url": 29
    },
    {
        "code_input": "class MultiSignatureWallet:\n    def __init__(self, owner):\n        self.owner = owner\n        self.active_signers_count = 0\n        self.all_signers = []\n        self.is_signer = {}\n\n    def add_signers(self, signers):\n        if self.owner != msg.sender:\n            raise ValueError(\"Only the contract owner can call this function\")\n\n        for signer in signers:\n            if signer != 0x0:\n                if signer not in self.is_signer:\n                    self.active_signers_count += 1\n                    self.all_signers.append(signer)\n                    self.is_signer[signer] = True\n                    emit(SignerAdded, signer)\n\n    # Define the function to delegate the",
        "gt": "contract c10726{ function addSigners(address[] signers) public { require(msg.sender == address(this), \"only callable via MultiSig\"); for (uint i= 0; i < signers.length; i++) { if (!isSigner[signers[i]]) { require(signers[i] != address(0), \"new signer must not be 0x0\"); activeSignersCount++; allSigners.push(signers[i]); isSigner[signers[i]] = true; emit SignerAdded(signers[i]); } } } }",
        "url": 30
    },
    {
        "code_input": "class ERC20Token:\n    def __init__(self, contract_address, abi):\n        self.contract_address = contract_address\n        self.abi = abi\n        self.contract = self.get_contract()\n\n    def get_contract(self):\n        \"\"\"\n        This function is used to get the contract instance.\n        \"\"\"\n        # Connect to the Ethereum network\n        w3 = Web3(HTTPProvider('http://localhost:8545'))\n\n        # Get the contract instance\n        contract = w3.eth.contract(address=self.contract_address, abi=self.abi)\n\n        return contract\n\n    def balanceOf(self, owner):\n        \"\"\"\n        This function is used to get the balance of a given address.\n        \"\"\"\n        # Get the balance of the owner",
        "gt": "contract c7516{ function balanceOf(address _owner) public constant returns (uint balance) { return balances[_owner]; } }",
        "url": 31
    },
    {
        "code_input": "class C5180:\n    def __init__(self):\n        self.rate = 0\n\n    def get_rate(self):\n        return self.rate",
        "gt": "contract c5180{ function getRate() public view returns (uint) { return rate; } }",
        "url": 32
    },
    {
        "code_input": "class C22374:\n    def __init__(self, web3, account):\n        self.web3 = web3\n        self.account = account\n        self.contract = None\n\n    def deploy(self):\n        with open(\"C22374.sol\") as f:\n            contract_source = f.read()\n\n        self.contract = self.web3.eth.contract(\n            abi=[],\n            bytecode=contract_source\n        )\n\n        tx_hash = self.contract.constructor().transact()\n        tx_receipt = self.web3.eth.waitForTransactionReceipt(tx_",
        "gt": "contract c22374{ function recoverEthers() onlyOwner public { owner.transfer(this.balance); } }",
        "url": 33
    },
    {
        "code_input": "class C20487:\n    def __init__(self, owner, token_address, wallet_address):\n        self.owner = owner\n        self.token_address = token_address\n        self.wallet_address = wallet_address\n\n    def set_wallet_address(self, new_wallet_address):\n        if new_wallet_address == self.token_address:\n            raise ValueError(\"The new address cannot be the address of the token itself.\")\n        elif new_wallet_address == self.owner:\n            raise ValueError(\"The new address cannot be the current owner of the token.\")\n        else:\n            self.wallet_address",
        "gt": "contract c20487{ function setWalletAddress(address _walletAddress) external onlyOwner returns(bool) { require(_walletAddress != address(0)); require(_walletAddress != address(this)); require(_walletAddress != address(token)); require(isOwner(_walletAddress) == false); walletAddress = _walletAddress; WalletAddressUpdated(_walletAddress); return true; } }",
        "url": 34
    },
    {
        "code_input": "def calculate_tokens_amount(value, internal_calculate_ether_with_bonus, ether_price_in_usd, collected_usd, sold_tokens, calculate_internal_tokens_amount):\n    if value == 0:\n        return (0, 0)\n\n    amount_in_usd = internal_calculate_ether_with_bonus(value) * ether_price_in_usd\n    if amount_in_usd == 0:\n        return (0, 0)\n\n    token_amount, usd_amount = calculate_internal_tokens_amount(amount_in_usd, collected_usd, sold_tokens)\n    return (token_amount, usd_amount)",
        "gt": "contract c21285{ function calculateTokensAmount ( uint256 _value ) public constant returns (uint256, uint256) { if (_value == 0) { return (0, 0); } uint256 amountInUSD = internalCalculateEthersWithBonus(_value).mul(etherPriceInUSD); if (amountInUSD == 0) { return (0, 0); } uint256 tokenAmount; uint256 usdAmount; (tokenAmount, usdAmount) = calculateInternalTokensAmount(amountInUSD, collectedUSD, soldTokens); return (tokenAmount, usdAmount); } }",
        "url": 35
    },
    {
        "code_input": "class SmartContract:\n    def __init__(self, web3, address):\n        self.web3 = web3\n        self.address = address\n        self.contract = self.web3.eth.contract(address=address, abi=self.get_contract_abi())\n\n    def get_contract_abi(self):\n        # This function should return the ABI of the contract.\n        # For the given contract, it's not defined, so a placeholder is returned.\n        return \"ABI of the contract not defined\"\n\n    def authorise(self, _address):\n        # This function authorizes another address.\n        # It's not defined in the given contract, so a placeholder is returned.\n        return \"Function not defined\"\n\n# Usage:\n# web3 = Web3(Web3.HTTPProvider('http://localhost:8545'))\n#",
        "gt": "contract c35372{ function authorise(address _address) public ifAuthorised{ authorisers[_address] = true; Authorise('Added', msg.sender, _address); } }",
        "url": 36
    },
    {
        "code_input": "The given Solidity code is a smart contract for a box sale. The contract has a function `buyBox1()` that is called when a user wants to buy a box. The function checks several conditions before proceeding with the transaction.\n\nHere's a high-level description of the function's main logic:\n\n1. The function `buyBox1()` is declared as `external`, which means it can only be called by external transactions.\n2. The function `whenNotPaused()` is used to ensure that the contract is not paused.\n3. The function `returns (bool)` means that the function will return a boolean value.\n4. The `require()` function is used to ensure that the contract is not paused and that the sender is a contract.\n5. The `msg.value >= priceBox1` checks that the transaction sender has enough Ether to buy the box.\n6. The `keccak256(uint(msg.sender) + secretKey + rabbits.length)` is a hash function that generates a unique value for each transaction.\n7. The `tempVal = uint(keccak256(uint",
        "gt": "contract c18918{ function buyBox1() external payable whenNotPaused returns (bool) { require(isNotContract(msg.sender)); require(box1OnSale); require(msg.value >= priceBox1); uint tempVal = uint(keccak256(uint(msg.sender) + secretKey + rabbits.length)); tempVal = tempVal % 10000; uint _star = 3; if (tempVal <= box1Star5){ _star = 5; require(CREATED_STAR5 < LIMIT_STAR5); } else if (tempVal <= box1Star5 + box1Star4){ _star = 4; require(CREATED_STAR4 < LIMIT_STAR4); } _createRabbitInGrade(_star, msg.sender, 2); uint fundsExcess = msg.value - priceBox1; if (fundsExcess > 1 finney) { msg.sender.transfer(fundsExcess); } return true; } }",
        "url": 37
    },
    {
        "code_input": "class PropertyManager:\n    def __init__(self, pxl_property):\n        self.pxl_property = pxl_property\n\n    def get_for_sale_prices(self, property_id):\n        if self.pxl_property.get_property_owner(property_id) == 0:\n            return self.get_system_sale_prices()\n        else:\n            return self.pxl_property.get_property_sale_price(property_id)\n\n    def get_system_sale_prices(self):\n        # This is a placeholder for the actual method that fetches the system sale prices.\n        # For the sake of this example, we'll return a dummy value.\n        return (0, 0)",
        "gt": "contract c14416{ function getForSalePrices(uint16 propertyID) public validPropertyID(propertyID) view returns(uint256, uint256) { if (pxlProperty.getPropertyOwner(propertyID) == 0) { return getSystemSalePrices(); } else { return (0, pxlProperty.getPropertySalePrice(propertyID)); } } }",
        "url": 38
    },
    {
        "code_input": "def token_has_free_trial(address_of_token):\n    # This function checks if the token associated with the given address has a free trial.\n    # It returns True if the token has a free trial, False otherwise.\n    pass\n\ndef get_remaining_trial_drops(address_of_token):\n    if token_has_free_trial(address_of_token):\n        return max_trial_drops - trial_drops[address_of_token]\n    else:\n        return 0",
        "gt": "contract c79{ function getRemainingTrialDrops(address _addressOfToken) public view returns(uint256) { if(tokenHasFreeTrial(_addressOfToken)) { return maxTrialDrops.sub(trialDrops[_addressOfToken]); } return 0; } }",
        "url": 39
    },
    {
        "code_input": "class SmartContract:\n    def __init__(self, contract_address, abi, web3):\n        self.contract_address = contract_address\n        self.abi = abi\n        self.web3 = web3\n        self.contract = self.web3.eth.contract(address=self.contract_address, abi=self.abi)\n\n    def is_owner(self, account):\n        return self.contract.functions.owner().call() == account\n\n    def transfer_ownership(self, new_owner):\n        if not self.is_owner(new_owner):\n            raise Exception(\"Only the contract owner can transfer ownership.\")\n        self.contract.functions.transferOwnership(new_owner).transact()\n\n    def close_contract(self):\n        self.cont",
        "gt": "contract c3655{ function transfer(address _newOwner) only_owner { require(permissions.ownerMutability < block.timestamp); registrar.transfer(labelhash, _newOwner); selfdestruct(msg.sender); } }",
        "url": 40
    },
    {
        "code_input": "class Contract:\n    def __init__(self, web3, address):\n        self.web3 = web3\n        self.address = address\n        self.contract = web3.eth.contract(address=address, abi=[...])\n\n    def transfer(self, to, value):\n        if self.contract.functions.balanceOf(self.address).call() >= value and value > 0 and self.contract.functions.balanceOf(to).call() + value > self.contract.functions.balanceOf(to).call():\n            self.contract.functions.transfer(to, value).call()\n            return True\n        else:\n            return False",
        "gt": "contract c765{ function transfer(address _to, uint256 _value) public onlyPayloadSize(2) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0 && balances[_to].add(_value) > balances[_to]) { balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } else { return false; } } }",
        "url": 41
    },
    {
        "code_input": "class EscrowContract:\n    def __init__(self):\n        self.RATE = 0\n\n    def set_rate(self, escrow_balance, total_supply):\n        if escrow_balance >= 7 * 10 ** 20:\n            self.RATE = (((total_supply * 10000) / escrow_balance) + 9999) / 10000\n\n# Example usage:\nescrow = EscrowContract()\nescrow.set_rate(escrow_balance=7 * 10 ** 20, total_supply=10 ** 18)\nprint(escrow.RATE)",
        "gt": "contract c32527{ function setRate(uint256 rate) { if (escrow.balance >= 7*10**20) { RATE = (((totalSupply.mul(10000)).div(escrow.balance)).add(9999)).div(10000); } } }",
        "url": 42
    },
    {
        "code_input": "class SubscriptionContract:\n    def __init__(self, subscriptions, sub_state, _subscriptionState, _returnSubscriptionDesposit):\n        self.subscriptions = subscriptions\n        self.sub_state = sub_state\n        self._subscriptionState = _subscriptionState\n        self._returnSubscriptionDesposit = _returnSubscriptionDesposit\n\n    def returnSubscriptionDeposit(self, subId):\n        sub = self.subscriptions[subId]\n        assert self._subscriptionState(sub) == 'CANCELED'\n        assert sub.depositAmount > 0\n        assert sub.transferTo == msg.sender or owner == msg.sender\n        sub.expireOn = now\n        return self._returnSubscriptionDesposit(subId, sub)",
        "gt": "contract c38530{ function returnSubscriptionDesposit(uint subId) public notSuspended { Subscription storage sub = subscriptions[subId]; assert (_subscriptionState(sub) == SubState.CANCELED); assert (sub.depositAmount > 0); assert (sub.transferTo == msg.sender || owner == msg.sender); sub.expireOn = now; _returnSubscriptionDesposit(subId, sub); } }",
        "url": 43
    },
    {
        "code_input": "class TimeWindowContract:\n    def __init__(self, owner, time_window):\n        self.owner = owner\n        self.time_window = time_window\n\n    def setup_time_window(self, secs):\n        if self.owner != self.time_window.owner:\n            raise Exception(\"Only the owner of the contract can set the time window.\")\n        self.time_window = secs\n\n# Example usage:\ntime_window_contract = TimeWindowContract(\"0x123456789\", 1800)\ntime_window_contract.setup_time_window(3600)",
        "gt": "contract c40166{ function setupTimeWindow(uint256 secs) onlyOwnerUnlocked setter { timeWindow = secs; } }",
        "url": 44
    },
    {
        "code_input": "class ERC20:\n    def __init__(self, contract_address, abi):\n        self.contract_address = contract_address\n        self.abi = abi\n        self.contract = self.get_contract()\n\n    def get_contract(self):\n        \"\"\"\n        This function is used to get the contract instance.\n        \"\"\"\n        # Connect to the Ethereum node\n        w3 = Web3(Web3.HTTPProvider('http://localhost:8545'))\n\n        # Get the contract instance\n        contract = w3.eth.contract(address=self.contract_address, abi=self.abi)\n\n        return contract\n\n    def balanceOf(self, owner):\n        \"\"\"\n        This function is used to get the balance of a given address.\n        \"\"\"\n        # Get the balance of",
        "gt": "contract c36915{ function balanceOf(address _owner) constant returns (uint balance) { return balances[_owner]; } }",
        "url": 45
    },
    {
        "code_input": "def safe_add(x, y):\n    z = x + y\n    assert(z >= x)\n    return z",
        "gt": "contract c29933{ function safeAdd(uint256 x, uint256 y) internal pure returns(uint256) { uint256 z = x + y; assert((z >= x)); return z; } }",
        "url": 46
    },
    {
        "code_input": "class TokenSale:\n    def __init__(self, owner, sale_tokens_address, balances, before_sale_closed):\n        self.owner = owner\n        self.sale_tokens_address = sale_tokens_address\n        self.balances = balances\n        self.before_sale_closed = before_sale_closed\n        self.sale_closed = False\n\n    def close_sale(self):\n        if self.before_sale_closed:\n            self.sale_closed = True\n            self.balances[self.sale_tokens_address] = 0\n            self.burn_tokens(self.sale_tokens_address)\n\n    def burn_tokens(self",
        "gt": "contract c169{ function closeSale() external onlyOwner beforeSaleClosed { _burn(saleTokensAddress, balances[saleTokensAddress]); saleClosed = true; } }",
        "url": 47
    },
    {
        "code_input": "class C15225:\n    def __init__(self):\n        self.withdrawAfter = {}\n\n    def cancelWithdrawalRequest(self, sender):\n        if sender in self.withdrawAfter:\n            self.withdrawAfter[sender] = 0\n        else:\n            print(f\"User {sender} does not have a withdrawal request.\")",
        "gt": "contract c15225{ function cancelWithdrawalRequest() public { withdrawAfter[msg.sender] = 0; } }",
        "url": 48
    },
    {
        "code_input": "class Token:\n    def __init__(self, TOKEN_LIMIT):\n        self.TOKEN_LIMIT = TOKEN_LIMIT\n        self.balances = {}\n        self.totalSupply = 0\n        self.mintingIsAllowed = True\n\n    def mint(self, _beneficiary, _value):\n        if _value == 0:\n            raise ValueError(\"Value must be greater than 0\")\n        if self.totalSupply + _value > self.TOKEN_LIMIT:\n            raise ValueError(\"Minting would exceed the token limit\")\n        if self.mintingIsAllowed == False:\n            raise ValueError(\"Minting is not allowed at this time\")\n        self.balances[_beneficiary] = self.balances.get(_beneficiary, 0) + _value",
        "gt": "contract c32618{ function mint(address _beneficiary, uint _value) external onlyByManager { require(_value != 0); require(totalSupply.add(_value) <= TOKEN_LIMIT); require(mintingIsAllowed == true); balances[_beneficiary] = balances[_beneficiary].add(_value); totalSupply = totalSupply.add(_value); } }",
        "url": 49
    },
    {
        "code_input": "from fractions import Fraction\n\nclass Presale:\n    def __init__(self, start, bonus):\n        self.start = start\n        self.bonus = bonus\n\nclass MainSale:\n    def __init__(self, start):\n        self.start = start\n\nclass Game:\n    def __init__(self, presale1, presale2, mainsale):\n        self.presale1 = presale1\n        self.presale2 = presale2\n        self.mainsale = mainsale",
        "gt": "contract c1349{ function _getBonus() internal view returns (Fraction memory bonus) { if (now < _presale2.start) { bonus = _presale1.bonus; } else if (now < _mainsale.start) { bonus = _presale2.bonus; } else { bonus = Fraction({n: 0, d: 1}); } } }",
        "url": 50
    },
    {
        "code_input": "class TokenDistributor:\n    def __init__(self):\n        self.balances = {}\n\n    def _tokenAllocate(self, amount):\n        # This function is not defined in the given Solidity code, but it's assumed to be a function that allocates tokens to the contract owner.\n        # The actual implementation would depend on the specifics of the token distribution system.\n        pass\n\n    def tokenAllocate(self, amount):\n        # This function is a direct translation of the Solidity function.\n        # It allocates tokens to the contract owner based on the input amount.\n        # The actual implementation would depend on the specifics of the token distribution system.\n        for address in self.balances:\n            self.balances[address] += amount\n\n# Usage\ndistributor = TokenDistributor()\ndistributor.tokenAllocate(2)\ndist",
        "gt": "contract c1757{ function tokenAllocate() isAnOwner public { _tokenAllocate(2); _tokenAllocate(5); _tokenAllocate(10); _tokenAllocate(15); _tokenAllocate(20); _tokenAllocate(25); _tokenAllocate(33); } }",
        "url": 51
    },
    {
        "code_input": "class Token:\n    def __init__(self, owner, public_sell, frozen_account):\n        self.owner = owner\n        self.public_sell = public_sell\n        self.frozen_account = frozen_account\n\n    def is_owner(self):\n        return self.owner == msg.sender\n\n    def allow_transfers(self):\n        return not self.frozen_account[msg.sender]\n\n    def is_frozen(self):\n        return self.frozen_account[msg.sender",
        "gt": "contract c11594{ function transfer(address to, uint256 tokens) public returns (bool success) { if (!isOwner()) { require (allowTransfers); require(!frozenAccount[msg.sender]); require(!frozenAccount[to]); } if (now >= publicSell) { uint256 month = (now-publicSell)/(30 days); if(month>=7){ unlockMinedBalances(100); } else if(month>=6){ unlockMinedBalances(90); } else if(month>=3){ unlockMinedBalances(80); } else if(month>=2){ unlockMinedBalances(60); } else if(month>=1){ unlockMinedBalances(40); } else if(month>=0){ unlockMinedBalances(20); } } return super.transfer(to,tokens); } }",
        "url": 52
    },
    {
        "code_input": "The given Solidity code is a contract function that allows a user to send a certain amount of a token to another address. The function `sendToken` is defined as a modifier `onlyFounder` and `nonZeroAddress`. The function `sendToken` is also marked as `isTokenDeployed`, which means it only works if the token contract is deployed.\n\nThe function `sendToken` takes two parameters: `_to`, the address to send the token to, and `_value`, the amount of the token to send.\n\nThe function first checks if the `_value` is zero. If it is, the function returns `false`.\n\nThen, the function calls the `checkExistence` function to check if the `_to` address exists. If the `_to` address does not exist, the function returns `false`.\n\nIf the `_value` is not zero, the function calculates the amount of the token to send, which is the `_value` multiplied by 10 to the power of the number of decimal places of the token.\n\nThe function then transfers the token from the caller's address to the `",
        "gt": "contract c29211{ function sendToken (address _to, uint256 _value) onlyfounder nonZeroAddress(_to) isTokenDeployed returns (bool) { if (_value == 0) return false; require(checkExistence(_to)); uint256 _tokenAmount= _value * 10 ** uint256(token.decimals()); if (token.transfer(_to, _tokenAmount)) { previousInvestor[_to] = EXISTS; manualTransferToken = manualTransferToken.add(_tokenAmount); token.changeTotalSupply(_tokenAmount); AdminTokenSent(_to, _tokenAmount); return true; } return false; } }",
        "url": 53
    },
    {
        "code_input": "def slice32(b, offset):\n    out = 0\n    for i in range(32):\n        out |= b[offset + i] & 0xFF\n        out >>= i * 8\n    return out",
        "gt": "contract c10129{ function slice32(bytes b, uint offset) constant returns (bytes32) { bytes32 out; for (uint i = 0; i < 32; i++) { out |= bytes32(b[offset + i] & 0xFF) >> (i * 8); } return out; } }",
        "url": 54
    },
    {
        "code_input": "class C20814:\n    def __init__(self, elements, elementIndexToPrice, elementIndexToOwner):\n        self.elements = elements\n        self.elementIndexToPrice = elementIndexToPrice\n        self.elementIndexToOwner = elementIndexToOwner\n\n    def getElement(self, _tokenId):\n        element = self.elements[_tokenId]\n        tokenId = element['tokenId']\n        elementName = element['name']\n        sellingPrice = self.elementIndexToPrice[_tokenId]\n        owner = self.elementIndexToOwner[_tokenId]\n        scientistId = element['scientistId']\n        return tokenId, elementName, sellingPrice, owner, scientistId",
        "gt": "contract c20814{ function getElement(uint256 _tokenId) public view returns ( uint256 tokenId, string elementName, uint256 sellingPrice, address owner, uint256 scientistId ) { Element storage element = elements[_tokenId]; tokenId = element.tokenId; elementName = element.name; sellingPrice = elementIndexToPrice[_tokenId]; owner = elementIndexToOwner[_tokenId]; scientistId = element.scientistId; } }",
        "url": 55
    },
    {
        "code_input": "class Contract:\n    def __init__(self):\n        self.operational = False\n\n    def set_operational(self):\n        self.operational = True\n\n    def is_operational(self):\n        if self.operational:\n            return True\n        else:\n            return False\n\n    @isOperational\n    def function1(self):\n        print(\"Function 1 is called\")\n\n    def function2(self):\n        print(\"Function 2 is not operational\")\n\n    def function3(self):\n        print(\"Function 3 is not operational\")\n\ncontract = Contract()\ncontract.set_operational()\ncontract.function1()  # This will print",
        "gt": "contract c25219{ modifier isOperational() { require(operational); _; } }",
        "url": 56
    },
    {
        "code_input": "class BetGame:\n    def __init__(self, total_bet_amount, commission_rate, donation_rate):\n        self.total_bet_amount = total_bet_amount\n        self.commission_rate = commission_rate\n        self.donation_rate = donation_rate\n\n    def calculate_total_payout_amount_and_commission(self):\n        commission_amount = self.total_bet_amount * self.commission_rate // 100\n        donation_amount = self.total_bet_amount * self.donation_rate // 100\n        total_payout_amount = self.total_bet_",
        "gt": "contract c5560{ function calculateTotalPayoutAmountAndCommission() private { uint256 commissionAmount = totalBetAmount.mul(COMMISSION_RATE).div(100); uint256 donationAmount = totalBetAmount.mul(DONATION_RATE).div(100); totalPayoutAmount = totalBetAmount.sub(commissionAmount).sub(donationAmount); owner.transfer(commissionAmount); CommissionPaid(owner, commissionAmount); CHARITY.transfer(donationAmount); Donated(CHARITY, donationAmount); } }",
        "url": 57
    },
    {
        "code_input": "def delete_tx(contract, _key):\n    if _key != 0:\n        if not is_tx_exist(_key):",
        "gt": "contract c9143{ function deleteTx(bytes32 _key) external onlyContractOwner returns (uint) { require(_key != bytes32(0)); if (!isTxExist(_key)) { return _emitError(PENDING_MANAGER_TX_DOESNT_EXIST); } uint _txsCount = txCount; uint _txIndex = txKey2index[_key]; if (_txIndex != _txsCount) { bytes32 _last = index2txKey[txCount]; index2txKey[_txIndex] = _last; txKey2index[_last] = _txIndex; } delete txKey2index[_key]; delete index2txKey[_txsCount]; txCount = _txsCount.sub(1); uint _basePolicyIndex = txKey2guard[_key].basePolicyIndex; Policy storage _policy = policyId2policy[index2PolicyId[_basePolicyIndex]]; uint _counter = _policy.securesCount; uint _policyTxIndex = _policy.txIndex2index[_txIndex]; if (_policyTxIndex != _counter) { uint _movedTxIndex = _policy.index2txIndex[_counter]; _policy.index2txIndex[_policyTxIndex] = _movedTxIndex; _policy.txIndex2index[_movedTxIndex] = _policyTxIndex; } delete _policy.index2txIndex[_counter]; delete _policy.txIndex2index[_txIndex]; _policy.securesCount = _counter.sub(1); TxDeleted(_key); return OK; } }",
        "url": 58
    },
    {
        "code_input": "class C22857:\n    def __init__(self, dungeons, tokenExists, Dungeon):\n        self.dungeons = dungeons\n        self.tokenExists = tokenExists\n        self.Dungeon = Dungeon\n\n    def addDungeonNewFloor(self, _id, _newRewards, _newFloorGenes):\n        if not self.tokenExists(_id):\n            raise ValueError(f\"Token with id {_id} does not exist\")\n\n        dungeon = self.dungeons[_id]\n        dungeon.floorNumber += 1\n        dungeon.floorCreationTime = int(time.time())\n        dungeon.rewards = int(_newRewards)\n        dungeon.floorGenes = _newFloorGenes",
        "gt": "contract c22857{ function addDungeonNewFloor(uint _id, uint _newRewards, uint _newFloorGenes) eitherOwner tokenExists(_id) external { Dungeon storage dungeon = dungeons[_id]; dungeon.floorNumber++; dungeon.floorCreationTime = uint32(now); dungeon.rewards = uint128(_newRewards); dungeon.floorGenes = _newFloorGenes; } }",
        "url": 59
    },
    {
        "code_input": "class TokenExchange:\n    def __init__(self, eth_rate, token_rate):\n        self.eth_rate = eth_rate\n        self.token_rate = token_rate\n\n    def get_token_amount(self, invested_amount):\n        # Calculate the token amount based on the invested amount and the rate of the token\n        token_amount = invested_amount * (self.eth_rate * 100) / self.token_rate\n        return token_amount",
        "gt": "contract c9199{ function getTokenAmount(uint256 _investedAmount) view public returns(uint256) { uint256 tokenRate = getRate(); uint256 tokenAmount = _investedAmount.mul((ethRate.mul(100)).div(tokenRate)); return tokenAmount; } }",
        "url": 60
    },
    {
        "code_input": "class C4210:\n    def __init__(self, web3, owner):\n        self.web3 = web3\n        self.owner = owner\n        self.contract_address = None\n        self.contract_instance = None\n\n    def deploy_contract(self):\n        # Deploy the contract\n        with open(\"C4210.sol\") as f:\n            contract_source = f.read()\n\n        compiled_sol = self.web3.compile_solidity(contract_source)\n        self.contract_instance = self.web3.eth.contract(address='0x0')\n        self.contract_address = self.contract_",
        "gt": "contract c4210{ function setDistributor(address addr, bool state) public onlyOwner canDistribute { distributors[addr] = state; emit DistributorChanged(addr, state); } }",
        "url": 61
    },
    {
        "code_input": "The given Solidity code is a contract for a simple decentralized exchange (DEX). It allows users to create requests for a specific type of token (`_typeId`) to be transferred to a specific address (`_target`). The value of the token to be transferred is specified (`_value`). The message (`_msg`) is a human-readable description of the request.\n\nHere's a high-level description of the main functionality and logic of the code:\n\n1. The contract has a function `createRequest` that is called by a user. This function takes four parameters: `_typeId`, `_target`, `_value`, and `_msg`.\n\n2. It increments a counter `curRequestId` to generate a unique ID for each request.\n\n3. It creates a new struct `request` with the ID, type ID, date created, created message, target address, and value.\n\n4. It assigns the generated ID to the new request.\n\n5. It assigns the current timestamp to the request's date created.\n\n6. It assigns the user-provided message to the request",
        "gt": "contract c14996{ function createRequest(uint _typeId, address _target, uint _value, string _msg) public fromAdmin { uint32 _id = ++curRequestId; requests[_id].id = _id; requests[_id].typeId = uint8(RequestType(_typeId)); requests[_id].dateCreated = uint32(now); requests[_id].createdMsg = _msg; requests[_id].target = _target; requests[_id].value = _value; _addPendingRequestId(_id); emit RequestCreated(now, _id, _typeId, _target, _value, _msg); } }",
        "url": 62
    },
    {
        "code_input": "class ERC20:\n    def __init__(self):\n        self.allowed = {}\n\n    def approve(self, _spender, _value):\n        if (_value == 0) or (self.allowed[msg.sender][_spender] == 0):\n            self.allowed[msg.sender][_spender] = _value\n            print(f\"Approval from {msg.sender} to {_spender} with value {_value}\")\n            return True\n        else:\n            return False",
        "gt": "contract c13592{ function approve(address _spender, uint256 _value) public returns (bool) { require((_value == 0) || (allowed[msg.sender][_spender] == 0)); allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } }",
        "url": 63
    },
    {
        "code_input": "The given Solidity code is a contract for a decentralized application (dApp) that allows users to deposit Ether into the contract. Here's a high-level description of the main functionality and logic:\n\n1. The contract has a function `deposit()` that is public and payable. This function is triggered when a user wants to deposit Ether into the contract.\n\n2. The function first checks if the contract is not disabled. If it is, it checks if the amount of Ether sent is greater than or equal to 10000000000000000 (10^18) and if the sender is not a contract.\n\n3. If the contract is not disabled and the sender is not a contract, it checks if the user has any Ether in their account. If not, it pushes the user's address into the `participants` array, updates the `participantsArrayLocation` for the user, and records the current block height as the user's deposit block height.\n\n4. If the user has Ether in their account, it resets the `isStart` flag and sets the `",
        "gt": "contract c28923{ function deposit() payable public { address _owner = msg.sender; uint _amt = msg.value; require (!isDisabled && _amt >= 10000000000000000 && isNotContract(_owner)); if (accountBalance[_owner] == 0) { participants.push(_owner); participantsArrayLocation[_owner] = participants.length - 1; depositBlockheight[_owner] = block.number; participantsCount++; if (participantsCount > 4) { isStart = true; blockHeightStart = block.number; hasStarted = true; } } else { isStart = false; blockHeightStart = 0; } Deposit(_amt); accountBalance[_owner] += _amt; realAccountBalance[_owner] += _amt; masterBalance += _amt; masterApparentBalance += _amt; } }",
        "url": 64
    },
    {
        "code_input": "The given Solidity code is a contract for a smart contract in Ethereum blockchain. It's named `c16365` and it has a function `withdraw()`. This function is an external function that can be called by anyone. The function is set to be called when the system is not paused.\n\nThe function `withdraw()` is designed to withdraw funds from a user's account. Here's a high-level description of the function's logic:\n\n1. The function first checks if the user has a withdrawal block. If the user's withdrawal block is less than or equal to the current block number, it means the user has not yet reached their withdrawal deadline.\n\n2. If the user has not reached their withdrawal deadline, the function then retrieves the amount of funds the user has deposited.\n\n3. The function then deletes the user's account from the broadcasters mapping.\n\n4. The function then calls the `minter().trustedWithdrawETH(msg.sender, amount)` function, which is a function in the `minter` contract. This function is supposed to withdraw the user's",
        "gt": "contract c16365{ function withdraw() external whenSystemNotPaused { require(broadcasters[msg.sender].withdrawBlock <= roundsManager().blockNum()); uint256 amount = broadcasters[msg.sender].deposit; delete broadcasters[msg.sender]; minter().trustedWithdrawETH(msg.sender, amount); Withdraw(msg.sender); } }",
        "url": 65
    },
    {
        "code_input": "class C27237:\n    def __init__(self, payers):\n        self.payers = payers\n\n    def onlyPayer(self, func):\n        def wrapper(self, *args, **kwargs):\n            if self.payers[msg.sender]:\n                return func(self, *args, **kwargs)\n            else:\n                revert(\"Only payer can call this function.\")\n        return wrapper\n\n    # Example usage:\n    def setPayer(self, newPayer):\n        if self.payers[newPayer]:\n            self.payers[newPayer] = False\n        else:\n            revert(\"New payer must be a payer.\")",
        "gt": "contract c27237{ modifier onlyPayer() { require(payers[msg.sender]); _; } }",
        "url": 66
    },
    {
        "code_input": "class TokenTransferContract:\n    def __init__(self, owner, token):\n        self.owner = owner\n        self.token = token\n\n    def transfer_tokens(self, _from, _to, _amount):\n        # Check if the contract owner is the same as the sender\n        if self.owner != _from:\n            raise ValueError(\"Only the contract owner can transfer tokens.\")\n\n        # Check if the amount is greater than 0\n        if _amount <= 0:\n            raise ValueError(\"The amount must be greater than 0.\")\n\n        # Check if the current time is before the owner can transfer tokens\n        if not self.token.OWNER_TRANSFER_TOKENS > now():",
        "gt": "contract c29496{ function transferTokens(address _from, address _to, uint256 _amount) onlyOwner public { require(_amount > 0); require(now < OWNER_TRANSFER_TOKENS); require(!congress[_from]); require(!congress[_to]); token.transferByOwner(_from, _to, _amount); } }",
        "url": 67
    },
    {
        "code_input": "class Contract:\n    def __init__(self, contract_address):\n        self.contract_address = contract_address\n\n    def pay_for_myself(self, customer_id):\n        # The payable function in Solidity is not directly available in Python.\n        # We need to use a library like web3.py to interact with the Ethereum blockchain.\n        # Here's a simple example of how you might use web3.py to pay for myself:\n        from web3 import Web3, HTTPProvider\n\n        # Connect to the Ethereum node\n        w3 = Web3(HTTPProvider('http://localhost:8545'))\n\n        # Get the contract instance\n        contract = w3.eth.contract(address=self.contract_address, ab",
        "gt": "contract c34269{ function payForMyself(uint128 customerId) public payable { pay(customerId, msg.sender); } }",
        "url": 68
    },
    {
        "code_input": "class MultisigContract:\n    def __init__(self):\n        self.burningMans = {}\n\n    def addBurningMan(self, _burningMan, _block):\n        if _burningMan in self.burningMans:\n            return SERVICE_CONTROLLER_BURNING_MAN_EXIST\n\n        _code = self._multisig(self._keccak256(_burningMan), _block)\n        if _code != OK:\n            return _code\n\n        self.burningMans[_burningMan] = True\n        return OK\n\n    def _multisig(self, _burningMan, _block):\n        # This is a placeholder for the actual multisig function.\n        # It should be",
        "gt": "contract c9143{ function addBurningMan(address _burningMan, uint _block) public returns (uint _code) { if (burningMans[_burningMan]) { return SERVICE_CONTROLLER_BURNING_MAN_EXIST; } _code = _multisig(keccak256(_burningMan), _block); if (OK != _code) { return _code; } burningMans[_burningMan] = true; return OK; } }",
        "url": 69
    },
    {
        "code_input": "class C11175:\n    def __init__(self, contract_admin):\n        self.contract_admin = contract_admin\n        self.staffs = {}\n        self.staffaddress = []\n\n    def addStaffWhitelist(self, _userlist):\n        if len",
        "gt": "contract c11175{ function addStaffWhitelist(address[] _userlist) public onlyAdmin{ require(_userlist.length > 0); for (uint256 i = 0; i < _userlist.length; i++) { address baddr = _userlist[i]; if(baddr != address(0)){ if(!staffs[baddr]){ staffs[baddr] = true; staffaddress.push(baddr) -1; } } } } }",
        "url": 70
    },
    {
        "code_input": "class Contract:\n    def __init__(self, owner, frozenAccount, FrozenFunds):\n        self.owner = owner\n        self.frozenAccount = frozenAccount\n        self.FrozenFunds = FrozenFunds\n\n    def freezeAccount(self, target",
        "gt": "contract c11475{ function freezeAccount(address target, bool freeze) onlyOwner { require(freeze); frozenAccount[target] = freeze; FrozenFunds(target, freeze); } }",
        "url": 71
    },
    {
        "code_input": "class Contract:\n    def __init__(self, contract_address):\n        self.contract_address = contract_address\n\n    def set_kyc_provider(self, who):\n        # The function set_kyc_provider is used to set the KYC provider.\n        # It takes an address as an argument and sets the regulatorApprovedKycProvider to that address.\n        # The function is only accessible to the contract's",
        "gt": "contract c14698{ function setKycProvider(address who) public onlyOwner { regulatorApprovedKycProvider = who; } }",
        "url": 72
    },
    {
        "code_input": "class C25382:\n    def __init__(self, web3):\n        self.web3 = web3\n\n    def get_price(self, asset):\n        # This is a placeholder for the actual function that fetches the price and decimal of a single asset.\n        # It should be replaced with the actual function.\n        return True, 1000000, 18\n\n    def get_prices(self, of_assets):\n        are_recent = True\n        prices = [0]*len(of_assets)\n        decimals = [0]*len(of_assets)\n\n        for i, asset in enumerate(of_assets):\n            (is_recent, price, decimal) = self.get_price(asset)\n            if not is",
        "gt": "contract c25382{ function getPrices(address[] ofAssets) view returns (bool areRecent, uint[] prices, uint[] decimals) { areRecent = true; for (uint i; i < ofAssets.length; i++) { var (isRecent, price, decimal) = getPrice(ofAssets[i]); if (!isRecent) { areRecent = false; } prices[i] = price; decimals[i] = decimal; } } }",
        "url": 73
    },
    {
        "code_input": "class Contract:\n    def __init__(self, contract_address):\n        self.contract_address = contract_address\n        self.web3 = Web3(Web3.HTTPProvider('http://localhost:8545'))  # replace with your provider\n\n    def _removeAuction(self, _deedId):\n        # Get the contract instance\n        contract = self.web3.eth.contract(address=self.contract_address, abi=['function identifierToAuction(uint256) external returns (address)'])\n\n        # Call the _removeAuction function\n        result = contract.functions._removeAuction(_deedId).call()\n\n        return result",
        "gt": "contract c27549{ function _removeAuction(uint256 _deedId) internal { delete identifierToAuction[_deedId]; } }",
        "url": 74
    },
    {
        "code_input": "def get_dividends_of_(recipient, include_bonus):\n    if include_bonus:\n        return dividends_of(recipient) + referral_balance_[recipient]\n    else:\n        return dividends_of(recipient)",
        "gt": "contract c16877{ function getDividendsOf_(address _recipient, bool _includeBonus) internal view returns(uint256) { return _includeBonus ? dividendsOf(_recipient) + referralBalance_[_recipient] : dividendsOf(_recipient); } }",
        "url": 75
    },
    {
        "code_input": "class Forwarder:\n    def __init__(self, creator, reg_name, owner):\n        self.creator = creator\n        self.reg_name = reg_name\n        self.owner = owner\n\n    def create_new(self, reg_name, owner):\n        self.reg_name = reg_name\n        self.owner = owner\n        return self.address\n\n    @property\n    def address(self):\n        return self.creator",
        "gt": "contract c35878{ function createNew(bytes32 _regName, address _owner) public payable feePaid returns (address kAddr_) { kAddr_ = address(new Forwarder(msg.sender, _regName, _owner)); Created(msg.sender, _regName, kAddr_); } }",
        "url": 76
    },
    {
        "code_input": "The given Solidity code is a function that allows a user to spin on a game contract. The function is named `_spinTokens` and it takes two parameters: `_tkn`, which is a token contract instance, and `divRate`, which is the divisor rate.\n\nThe function is private because it doesn't need to be accessed directly by other contracts. It's only meant to be called by the contract itself.\n\nThe function first checks if the game is active and the block number is within the valid range. If not, it reverts the transaction.\n\nThe function then calculates the amount of tokens the user wagered and adds it to the user's balance.\n\nThe function checks if the user has already wagered on this spin. If they have, it reverts the transaction.\n\nIf the user has not wagered on this spin, the function calculates the tier of the user's balance and sets it.\n\nThe function then updates the block number, the token value, the tier, and the divisor rate of the spin.\n\nThe function also increments the total number of spins and the total amount of ZTH (Zeth",
        "gt": "contract c1017{ function _spinTokens(TKN _tkn, uint divRate) private betIsValid(_tkn.value, divRate) { require(gameActive); require(block.number <= ((2 ** 48) - 1)); address _customerAddress = _tkn.sender; uint _wagered = _tkn.value; playerSpin memory spin = playerSpins[_tkn.sender]; addContractBalance(divRate, _wagered); require(block.number != spin.blockn); if (spin.blockn != 0) { _finishSpin(_tkn.sender); } spin.blockn = uint48(block.number); spin.tokenValue = uint200(_wagered); spin.tier = uint8(ZethrTierLibrary.getTier(divRate)); spin.divRate = divRate; playerSpins[_tkn.sender] = spin; totalSpins += 1; totalZTHWagered += _wagered; emit TokensWagered(_customerAddress, _wagered); } }",
        "url": 77
    },
    {
        "code_input": "class Contract:\n    def __init__(self):\n        self.reward = 0\n\n    def add_reward(self, value):\n        self.reward += value\n\n# Create a new instance of the contract\ncontract = Contract()\n\n# Call the add_reward function with a value of 100\ncontract.add_reward(100)\n\n# Print the reward\nprint(contract.reward)  # Output: 100",
        "gt": "contract c39024{ function add_reward() payable { reward += msg.value; } }",
        "url": 78
    },
    {
        "code_input": "class HumanEvent:\n    def __init__(self, event_address):\n        self.event_address = event_address\n\n    def contribute(self, donor, amount):\n        # This function is used to record the contribution of a donor to the event\n        pass\n\nclass Event:\n    def __init__(self, event_address):\n        self.event_address = event_address\n        self.contributors = {}\n\n    def donate(self, donor, amount):\n        # This function is used to donate tokens to the event\n        if donor in self.contributors:\n            self.contributors[donor] += amount\n        else:\n            self.contributors[donor] = amount\n\n        # Transfer tokens",
        "gt": "contract c16665{ function donate(address _event, uint _amount) public onlyActive(_event) { require (transfer(_event, _amount)); require (HumanEvent(_event).contribute(msg.sender, _amount)); Contribute(_event, msg.sender, _amount); } }",
        "url": 79
    },
    {
        "code_input": "class C21172:\n    def __init__(self, contract_owner, web3):\n        self.contract_owner = contract_owner\n        self.web3 = web3\n        self.owners = {}\n\n    def add_owner(self, new_owner):\n        if new_owner != self.web3.to_checksum_address('0x0'):\n            self.owners[new_owner] = True\n            if self.contract_owner != new_owner:\n                # Only the contract owner can add new owners\n                raise ValueError(\"Only the contract owner can add new owners\")\n        else:\n            raise ValueError(\"Invalid address\")",
        "gt": "contract c21172{ function addOwner(address newOwner) onlyOwner public { require(newOwner != address(0)); owners[newOwner] = true; } }",
        "url": 80
    },
    {
        "code_input": "def process_fee(web3, account, contract_address, fee):\n    # Get the contract instance\n    contract = web3.eth.contract(address=",
        "gt": "contract c40191{ function processFee() internal { var fee = getConfig(\"fee\"); if (srvAccount[msg.sender] || (fee == 0)) return; if (msg.value < fee) throw; else if (!receiverAddress.send(fee)) throw; } }",
        "url": 81
    },
    {
        "code_input": "class C1966:\n    def __init__(self):\n        self.games_in_progress = {}\n\n    def get_game_state(self, player):\n        game = self.games_in_progress.get(player)\n        if game is None:\n            raise ValueError(f\"No game found for player {player}\")\n        return (game['state'], game['id'], game['direction'], game['bet'], game['first_roll'], game['final_roll'], game['",
        "gt": "contract c1966{ function getGameState(address player) public view returns (GameState, uint, BetDirection, uint, uint8, uint8, uint) { return ( gamesInProgress[player].state, gamesInProgress[player].id, gamesInProgress[player].direction, gamesInProgress[player].bet, gamesInProgress[player].firstRoll, gamesInProgress[player].finalRoll, gamesInProgress[player].winnings ); } }",
        "url": 82
    },
    {
        "code_input": "class SafeMath:\n    @staticmethod\n    def div(a, b):\n        if a > b:\n            return a // b\n        else:\n            return 0\n\n    @staticmethod\n    def mul(a, b):\n        return a * b\n\nclass C32965:\n    def __init__(self, web3):\n        self.web3 = web3\n\n    def calcAmount(self, _wei, _rate):\n        return self.web3.fromWei(self.web3.toWei(_wei, 'ether') * _rate, 'ether')",
        "gt": "contract c32965{ function calcAmount(uint _wei, uint _rate) constant returns (uint) { return SafeMath.div(SafeMath.mul(_wei, _rate), 1 ether); } }",
        "url": 83
    },
    {
        "code_input": "class ICOContract:\n    def __init__(self, owner):\n        self.owner = owner\n        self.isPaused = False\n\n    def triggerICOState(self, state):\n        if self.owner != 'onlyOwner':\n            raise Exception(\"Only the contract owner can trigger the ICO state.\")\n        self.isPaused = state",
        "gt": "contract c14979{ function triggerICOState(bool state) public onlyOwner { isPaused = state; } }",
        "url": 84
    },
    {
        "code_input": "class CrowdSale:\n    def __init__(self, ico_end_timestamp, ico_soft_cap_in_wei, vault):\n        self.ico_end_timestamp = ico_end_timestamp\n        self.ico_soft_cap_in_wei = ico_soft_cap_in_wei\n        self.vault = vault\n        self.crowdSaleState = None\n\n    def endCrowdS",
        "gt": "contract c18847{ function endCrowdSale() public onlyOwner { require(now >= icoEndTimestamp || icoRaised >= icoSoftCapInWei); if(icoRaised >= icoSoftCapInWei){ crowdSaleState = State.Success; vault.close(); } else { crowdSaleState = State.Failure; vault.enableRefunds(); } } }",
        "url": 85
    },
    {
        "code_input": "class C29430:\n    def __init__(self):\n        self.whitelist = {}\n\n    def add_to_whitelist(self, addresses):\n        for address in addresses:\n            self.whitelist[address] = True",
        "gt": "contract c29430{ function addToWhitelist(address[] _addresses) public onlyWhitelister { for (uint32 i = 0; i < _addresses.length; i++) { whitelist[_addresses[i]] = true; } } }",
        "url": 86
    },
    {
        "code_input": "class Contract:\n    def __init__(self):\n        self.everyoneDisabled = False\n\n    def enable_everyone(self):\n        if not self.everyoneDisabled:\n            self.everyoneDisabled = True\n        else:\n            raise Exception(\"Everyone is already enabled.\")\n\n    def disable_everyone(self):\n        if self.everyoneDisabled:\n            self.everyoneDisabled = False\n        else:\n            raise Exception(\"Everyone is already disabled.\")\n\n    def when_everyone(self, func):\n        def wrapper(*args, **kwargs):\n            if not self.everyoneDisabled:\n                return func(*args, **kwargs)\n            else:\n                raise Exception(\"Everyone is disabled.\")\n        return wrapper\n\n    def owner_only(self",
        "gt": "contract c36174{ modifier whenEveryone() { require(!everyoneDisabled); _; } }",
        "url": 87
    },
    {
        "code_input": "class Contract:\n    def __init__(self, bitplusAddress, fundingEndBlock):\n        self.bitplusAddress = bitplusAddress\n        self.fundingEndBlock = fundingEndBlock\n\n    def safeguard(self):\n        if block.number > (self.fundingEndBlock + 71000):\n            if not self.bitplusAddress.send(self.balance):\n                raise ValueError(\"Failed to send balance to bitplusAddress\")\n\n# Usage\ncontract = Contract(bitplusAddress, fundingEndBlock)\ncontract.safeguard()",
        "gt": "contract c38893{ function safeguard() { if(block.number > (fundingEndBlock + 71000)) { if (!bitplusAddress.send(this.balance)) throw; } } }",
        "url": 88
    },
    {
        "code_input": "class C35255:\n    def __init__(self):\n        self.ownedBy = {}\n\n    def soulIsOwnedBy(self, noSoulMate):\n        return self.ownedBy.get(noSoulMate, None)",
        "gt": "contract c35255{ function soulIsOwnedBy(address noSoulMate) public constant returns(address){ return ownedBy[noSoulMate]; } }",
        "url": 89
    },
    {
        "code_input": "The given Solidity code is a contract for a pre-sale auction. The contract has a function `createSaleAuction` that is used to create a new pre-sale auction. This function is called by the owner of a specific cat (`_LinglongCatId`) when the owner wants to start a pre-sale for that cat.\n\nThe function takes in four parameters:\n\n- `_LinglongCatId`: The ID of the cat for which the pre-sale is being created.\n- `_startingPrice`: The starting price for the pre-sale.\n- `_endingPrice`: The ending price for the pre-sale.\n- `_duration`: The duration of the pre-sale in seconds.\n\nThe function first checks if the caller of the function (`msg.sender`) owns the cat with `_LinglongCatId`. If not, it returns an error.\n\nThen, it checks if the cat is pregnant. If it is, it returns an error.\n\nAfter all these checks, the function then calls the `createAuction` function of the `saleA",
        "gt": "contract c8844{ function createSaleAuction( uint256 _LinglongCatId, uint256 _startingPrice, uint256 _endingPrice, uint256 _duration ) external whenNotPaused { require(_owns(msg.sender, _LinglongCatId)); require(!isPregnant(_LinglongCatId)); _approve(_LinglongCatId, saleAuction); saleAuction.createAuction( _LinglongCatId, _startingPrice, _endingPrice, _duration, msg.sender ); } }",
        "url": 90
    },
    {
        "code_input": "class TokenAllocation:\n    def __init__(self, contract):\n        self.contract = contract\n\n    def allocate_tokens(self, receiver, customer_uuid, wei_amount):\n        # This is a placeholder for the actual function.\n        # The actual function can be implemented in the contract, but it's not provided here.\n        # The function can be used to allocate tokens to a specific address.\n        # The function signature is assumed to be: function allocateTokens(address _receiver, bytes16 _customerUuid, uint256 _weiAmount) whenNotPaused canAllocateTokens public.\n        # The function is not provided here, but it's assumed to be a placeholder.\n        pass",
        "gt": "contract c29950{ function allocateTokens(address _receiver, bytes16 _customerUuid, uint256 _weiAmount) whenNotPaused canAllocateTokens public { allocateInternal(_receiver, _customerUuid, _weiAmount); } }",
        "url": 91
    },
    {
        "code_input": "class C281:\n    def __init__(self):\n        self.release_state = False\n\n    def set_release_state(self, release_state):\n        if release_state:\n            self.release_state = True\n        else:\n            self.release_state = False\n\n    def in_release_state(self):\n        return self.release_state\n\n    @inReleaseState\n    def function1(self):\n        if not self.in_release_state():\n            raise Exception(\"Function function1 is not in release state\")\n        # Main logic of function1\n\n    @inReleaseState\n    def function2(self):\n        if not self.in_release_state():\n            raise Exception(\"Function function2 is not in release state\")\n        # Main logic of",
        "gt": "contract c281{ modifier inReleaseState(bool releaseState) { require(releaseState == released); _; } }",
        "url": 92
    },
    {
        "code_input": "class C21711:\n    def __init__(self, contract_address):\n        self.contract_address = contract_address\n\n    def get_current_bonus_rate(self):\n        # This function is not implemented in the given contract.\n        # It's supposed to be implemented in a child contract.\n        # The logic of this function is not clear from the given contract.\n        pass\n\n    def current_bonus(self):\n        # This function is a wrapper around the get_current_bonus_rate() function.\n        # It's used to get the current bonus rate.\n        return self.get_current_bonus_rate()",
        "gt": "contract c21711{ function currentBonus() public constant returns(uint8) { return getCurrentBonusRate(); } }",
        "url": 93
    },
    {
        "code_input": "class ERC721Contract:\n    def __init__(self, owner):\n        self.owner = owner\n        self.erc721_enabled = True\n\n    def disable_erc721(self):\n        if self.owner != self.msg.sender:\n            raise ValueError(\"Only the contract owner can disable the ERC721 token.\")\n\n        self.erc721_enabled = False\n\n# Example usage:\n# owner = \"0x...\"\n# contract = ERC721Contract(owner)\n# contract.disable_erc721()",
        "gt": "contract c19211{ function disableERC721 () onlyOwner() public { erc721Enabled = false; } }",
        "url": 94
    },
    {
        "code_input": "class C7066:\n    def __init__(self, web3):\n        self.web3 = web3\n\n    def thisAddress(self):\n        return self.web3.eth.accounts[0]\n\n# Usage\n# web3 = Web3(HTTPProvider('http://localhost:8545'))\n# contract = C7066(web3)\n# print(contract.thisAddress())",
        "gt": "contract c7066{ function thisAddress () internal view returns (address) { return this; } }",
        "url": 95
    },
    {
        "code_input": "class Contract:\n    def __init__(self):\n        self.aliases = {}\n        self.addresses = {}\n\n    def set_alias(self, alias):\n        self.aliases[msg.sender] = alias\n        self.addresses[alias] = msg.sender",
        "gt": "contract c11716{ function setAlias(string alias) public { aliases[msg.sender] = alias; addresses[alias] = msg.sender; } }",
        "url": 96
    },
    {
        "code_input": "The given Solidity code is a contract for a voting system. The contract has a function `voteFor` that allows a participant to vote for a certain number of votes. The function is public, meaning it can be called by anyone.\n\nHere's a high-level description of the function's main logic:\n\n1. The function requires that the number of votes to be voted for is less than the total number of votes that have already been cast for that participant. This is to prevent a participant from voting more than they have already cast.\n\n2. The function also requires that the sender of the transaction is not the same as the participant. This is to prevent a participant from voting for themselves.\n\n3. The function also requires that the total number of votes that have already been cast by the sender of the transaction is less than or equal to the maximum number of votes that can be cast per account. This is to prevent a sender from voting for more than they have already cast.\n\n4. If all the above conditions are met, the function increments the number of votes that have been cast for the participant and the total number of votes that have been cast.\n\nHere's a Python code that demonstrates the",
        "gt": "contract c15148{ function voteFor(address participant, uint256 numVotes) public { require (voteCount[participant] < voteCount[participant] + numVotes); require(participant != msg.sender); require(alreadyUsedVotes[msg.sender] + numVotes <= maxNumVotesPerAccount); alreadyUsedVotes[msg.sender] += numVotes; voteCount[participant] += numVotes; } }",
        "url": 97
    },
    {
        "code_input": "class C8851:\n    def __init__(self, web3, account):\n        self.web3 = web3\n        self.account = account\n        self.contract = None\n\n    def deploy_contract(self):\n        with open(\"C8851.sol\") as f:\n            contract_source = f.read()\n\n        self.contract = self.web3.eth.contract(\n            abi=[],\n            byte",
        "gt": "contract c8851{ function lockup(address _to, uint256 _lockupTimeUntil) public onlyOwner { require(lockups[_to] < _lockupTimeUntil); lockups[_to] = _lockupTimeUntil; emit Lockup(_to, _lockupTimeUntil); } }",
        "url": 98
    },
    {
        "code_input": "class GymContract:\n    def __init__(self):\n        self.verified_members = {}\n\n    def verify_member(self, member_id):\n        if member_id in self.verified_members:\n            return \"Member already verified\"\n        else:\n            self.verified_members[member_id] = True\n            return \"Member verified\"\n\n    def is_member_verified(self, member_id):\n        return member_id in self.verified_members\n\n    def __call__(self, member_id):\n        if not self.is_member_verified(member_id):\n            return \"Member not verified\"\n        else:\n            return \"Member is verified\"\n\ngym_contract = GymContract()",
        "gt": "contract c26122{ modifier onlyVerified() { require(msg.sender == gymContract || msg.sender == specialContract || msg.sender == arenaContract); _; } }",
        "url": 99
    },
    {
        "code_input": "class Account:\n    def __init__(self):\n        self.enabled = False\n\nclass Contract:\n    def __init__(self):\n        self.accounts = {}\n\n    def setEnabled(self, _addr, _enabled):\n        if _addr in self.accounts:\n            if self.accounts[_addr].enabled != _enabled:\n                self.accounts[_addr].enabled = _enabled\n        else:\n            self.accounts[_addr] = Account()\n            if self.accounts[_addr].enabled != _enabled:\n                self.accounts[_addr].enabled = _enabled",
        "gt": "contract c35217{ function setEnabled(address _addr, bool _enabled) public { assert(msg.sender == owner); if (accounts[_addr].enabled != _enabled) { accounts[_addr].enabled = _enabled; } } }",
        "url": 100
    },
    {
        "code_input": "class InvestmentContract:\n    def __init__(self, investors, balances):\n        self.investors = investors\n        self.balances = balances\n        self.investorIndex = 0\n\n    def returnInvestmentRecursive(self, value):\n        if self.investorIndex >= len(self.investors) or value == 0:\n            return\n        elif value <= self.balances[self.investors[self.investorIndex]]:\n            self.balances[self.investors[self.investorIndex]] -= value\n            if not self.investors[self.investorIndex].send(value):\n                raise Exception('Transaction failed')\n        elif self.balances[self.investors[self.investorIndex]] > 0:\n            val = self.balances[self.investors[self.investor",
        "gt": "contract c39835{ function returnInvestmentRecursive(uint value) internal{ if (investorIndex>=investors.length || value==0) return; else if(value<=balances[investors[investorIndex]]){ balances[investors[investorIndex]]-=value; if(!investors[investorIndex].send(value)) throw; } else if(balances[investors[investorIndex]]>0){ uint val = balances[investors[investorIndex]]; balances[investors[investorIndex]]=0; if(!investors[investorIndex].send(val)) throw; investorIndex++; returnInvestmentRecursive(value-val); } else{ investorIndex++; returnInvestmentRecursive(value); } } }",
        "url": 101
    },
    {
        "code_input": "class Contract:\n    def __init__(self, owner):\n        self.owner = owner\n        self.treasury = None\n\n    def set_treasury(self, _treasury):\n        if self.owner == _treasury:\n            self.treasury = _treasury\n        else:\n            raise ValueError(\"Only the contract owner can set the treasury.\")",
        "gt": "contract c35279{ function setTreasury (address _treasury) external only_owner { treasury = _treasury; } }",
        "url": 102
    },
    {
        "code_input": "class Contract:\n    def mul(self, a, b):\n        c = a * b\n        assert(a == 0 or c / a == b)\n        return c\n\n# Test the function\ncontract = Contract()\nprint(contract.mul(10, 5))  # Output: 50",
        "gt": "contract c34013{ function mul(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } }",
        "url": 103
    },
    {
        "code_input": "The given Solidity contract is a contract for a token named \"c25255\". It has a function `migrateHolders` that migrates a certain number of holders from the contract to another address. The function takes a count of holders to be migrated as a parameter.\n\nHere's a high-level description of the function's main logic:\n\n1. The function first checks if the count is greater than 0. If it's not, it reverts the transaction.\n2. It then checks if the `migrationAgent` is not 0x0 (which would mean the agent is not set). If it's 0x0, it reverts the transaction.\n3. It then increments `migrationCountComplete` by the count of holders to be migrated.\n4. If the count of holders to be migrated is greater than the current number of holders, it sets the count to the current number of holders.\n5. It then starts a loop that runs from `migrationCountComplete` to the count of holders to be migrated.\n6. For each holder, it gets the balance of",
        "gt": "contract c25255{ function migrateHolders(uint256 count) public onlyOwner returns (bool) { require(count > 0); require(migrationAgent != 0x0); count = migrationCountComplete.add(count); if (count > holders.length) { count = holders.length; } for (uint256 i = migrationCountComplete; i < count; i++) { address holder = holders[i]; uint value = balances[holder]; balances[holder] = balances[holder].sub(value); totalSupply_ = totalSupply_.sub(value); MigrationAgent(migrationAgent).migrateFrom(holder, value); Migrate(holder, value); } migrationCountComplete = count; return true; } }",
        "url": 104
    },
    {
        "code_input": "class Contract:\n    def __init__(self, web3, address):\n        self.web3 = web3\n        self.address = address\n\n    def set_oraclize_query_gas_price(self, gas_price):\n        # Check if the sender is the owner\n        if self.web3.eth.accounts[0] != self.address:\n            raise Exception(\"Only the contract owner can set the gas price.\")\n\n        # Set the gas price\n        self.web3.eth.set_gas_price(gas_price)",
        "gt": "contract c18992{ function setOraclizeQueryGasPrice(uint256 gasPrice) public { require(msg.sender == OWNER); ORACLIZEGASPRICE = gasPrice; oraclize_setCustomGasPrice(gasPrice); } }",
        "url": 105
    },
    {
        "code_input": "class RobotTradingContract:\n    def __init__(self, round_data, supply_limit, robottrading_token):\n        self.round_data = round_data\n        self.supply_limit = supply_limit\n        self.robottrading_token = robottrading_token\n        self.sent_tokens_to_partner = False\n\n    def send_tokens_",
        "gt": "contract c35051{ function sendTokensToPartner() onlyManager whenInitialized { require(!sentTokensToPartner); uint tokensSold = add(roundData[0].soldTokens, roundData[1].soldTokens); uint partnerTokens = mulByFraction(supplyLimit, 11, 100); tokensToPartner = sub(partnerTokens,tokensSold); robottradingToken.emitTokens(accPartner, partnerTokens); sentTokensToPartner = true; } }",
        "url": 106
    },
    {
        "code_input": "",
        "gt": "contract c30734{ function selfRegisterDINWithResolver(address _resolver) public returns (uint256 _DIN) { return registerDINWithResolver(msg.sender, _resolver); } }",
        "url": 107
    },
    {
        "code_input": "The given Solidity contract is a token transfer contract for a game. The contract has a function `_transfer` that is used to transfer tokens from one address to another. This function is private, meaning it can only be called by the contract itself or by other contract functions.\n\nHere's a high-level description of the main functionality of the `_transfer` function:\n\n1. It increments the `ownershipTokenCount` of the `_to` address by 1.\n2. It sets the `teamIndexToOwner` of the `_teamId` to the `_to` address.\n3. If the `_from` address is not the address of 0 (i.e., the transfer was not initiated by the contract itself), it decrements the `ownershipTokenCount` of the `_from` address by 1.\n4. It then calls the `Transfer` function, which is a custom function in the contract that is used to transfer tokens.\n\nThe `Transfer` function is a custom function in the contract that is used to transfer tokens. It is a function that is declared in the contract but not defined in the contract itself. It is",
        "gt": "contract c20905{ function _transfer(address _from, address _to, uint _teamId) private { ownershipTokenCount[_to]++; teamIndexToOwner[_teamId] = _to; if (_from != address(0)) { ownershipTokenCount[_from]--; } Transfer(_from, _to, _teamId); } }",
        "url": 108
    },
    {
        "code_input": "class C9850:\n    def __init__(self):\n        self.data = {}\n\n    def set(self, _name, _value):\n        self.data[keccak256(_name.encode('utf-8'))] = _value\n\n# Demonstration of the set function\nc9850 = C9850()\nc9850.set('name', 123)\nprint(c9850.data)",
        "gt": "contract c9850{ function set(string _name, uint _value) private { params[keccak256(_name)] = _value; } }",
        "url": 109
    },
    {
        "code_input": "class C19078:\n    def __init__(self, web3, account):\n        self.web3 = web3\n        self.account = account\n        self.contract = None\n        self.token_address = None\n        self.token_deployed = False\n\n    def set_token(self, _token_address):\n        if self.token_deployed:\n            print(\"Token already deployed\")\n            return\n\n        if not self.web3.isAddress(_token_address):\n            print(\"Invalid token address\")\n            return\n\n        self.token_address = _token_address\n        self.token_deployed = True\n\n        # Here, you would typically interact with the token contract\n        # to set its address.",
        "gt": "contract c19078{ function setToken(address _tokenAddress) nonZeroAddress(_tokenAddress) onlyfounder { require(tokenDeployed == false); token = EPTToken(_tokenAddress); tokenDeployed = true; } }",
        "url": 110
    },
    {
        "code_input": "class C40145:\n    def __init__(self, owner, maintenance_Emergency):\n        self.owner = owner\n        self.maintenance_mode = None\n        self.maintenance_Emergency = maintenance_Emergency\n\n    def set_maintenance_mode(self, maintenance_mode):\n        if maintenance_mode < self.maintenance_Emergency:\n            self.maintenance_mode = maintenance_mode\n\n    def health_check(self):\n        if self.maintenance_mode is not None and self.maintenance_mode < self.maintenance_Emergency:\n            print(\"Health check performed.\")\n        else:\n            print(\"No health check performed.\")",
        "gt": "contract c40145{ function performHealthCheck(uint8 _maintenance_mode) onlyOwner { maintenance_mode = _maintenance_mode; if (maintenance_mode > 0 && maintenance_mode < maintenance_Emergency) { healthCheck(); } } }",
        "url": 111
    },
    {
        "code_input": "class TokenWallet:\n    def __init__(self, owner):\n        self.owner = owner\n        self.token_wallet = None\n\n    def change_token_wallet(self, new_address):\n        if new_address != '0x0000000000000000000000000000000000000000':\n            self.token_wallet = new_address\n        else:\n            raise ValueError(\"New address cannot be zero address\")\n\n# Usage\nwallet = TokenWallet('0x1234567890123456",
        "gt": "contract c26093{ function changeTokenWallet(address newAddress) public onlyOwner { require(newAddress != address(0)); tokenWallet = newAddress; } }",
        "url": 112
    },
    {
        "code_input": "class Contract:\n    def __init__(self, allowed_addresses):\n        self.allowed_addresses = allowed_addresses\n\n    def is_registered_account(self, address):\n        return address in self.allowed_addresses",
        "gt": "contract c29946{ function isRegisteredAccount(address _address) onlyAllowedAddresses public constant returns (bool) { return allowedAddresses[_address]; } }",
        "url": 113
    },
    {
        "code_input": "class C18878:\n    def __init__(self):\n        pass\n\n    def totalSupply(self):\n        # This is a placeholder for the actual implementation of the totalSupply function.\n        # In a real-world contract, the totalSupply function would return the total number of tokens in the contract.\n        # For the purpose of this example, we'll return a fixed value.\n        return 1000000  # This is a placeholder, replace with actual implementation.\n\n# Create an instance of the contract\nc18878 = C18878()\n\n# Call the totalSupply function\nprint(c18878.totalSupply())",
        "gt": "contract c18878{ function totalSupply() public constant returns (uint256) { return totalSupply; } }",
        "url": 114
    },
    {
        "code_input": "class TokenMinter:\n    def __init__(self, owner, contract_address):\n        self.owner = owner\n        self.contract_address = contract_address\n\n    def mint(self, amount):\n        # This function is used to mint tokens.\n        # The amount of tokens to mint is passed as a parameter.\n        # The function returns the amount of tokens minted.\n        pass\n\n    def send_tokens_to_investor(self):",
        "gt": "contract c35590{ function sendTokensToInvestor() onlyOwner { uint256 mintedAmount = mintInternal(investor, (1805067013261140000000000)); require(mintedAmount == uint256(1805067013261140000000000)); } }",
        "url": 115
    },
    {
        "code_input": "The given Solidity code is a contract for a simple Ethereum smart contract. It has a function `transfer` that transfers tokens from the caller's account to a specified address. Here's a high-level description of the main functionality and logic of the code:\n\n1. The `transfer` function takes two parameters: `_to`, the address to which the tokens should be transferred, and `_value`, the amount of tokens to transfer.\n\n2. It first checks if the `_value` is less than 1, if so, it throws an error. This is because the value of tokens cannot be less than 1.\n\n3. It then checks if the caller's account is the same as the `_to` address, if so, it throws an error. This is to prevent the transfer from the caller's account to itself.\n\n4. It then checks if the caller's account has enough tokens to transfer, if not, it throws an error. This is done by checking if the caller's account's `balanceOf[msg.sender]` is less than `_value`.\n\n5. If",
        "gt": "contract c39200{ function transfer(address _to, uint256 _value) returns (bool success) { if (_value < 1) throw; if (this == _to) throw; if (balanceOf[msg.sender] < _value) throw; balanceOf[msg.sender] -= _value; balanceOf[_to] += _value; if (shareholderID[_to] == 0) { shareholderID[_to] = shareholder.push(_to) - 1; } refreshActiveShareholdersArray(); Transfer(msg.sender, _to, _value); return true; } }",
        "url": 116
    },
    {
        "code_input": "class C1665:\n    def __init__(self, team_wallet):\n        self.team_wallet = team_wallet\n        self.state = \"Open\"\n\n    def close(self):\n        if self.state == \"Open\" and self.team_wallet.balance < MIN_WITHDRAW_WEI:\n            self.state = \"Closed\"\n            self.team_wallet.transfer(self.team_wallet.balance)\n            emit(self.Closed())\n\n    def in_withdraw_state(self):\n        return self.state == \"Open\"\n\n    def is",
        "gt": "contract c1665{ function close() onlyOwner inWithdrawState public { require(address(this).balance < MIN_WITHDRAW_WEI); state = State.Closed; emit Closed(); teamWallet.transfer(address(this).balance); } }",
        "url": 117
    },
    {
        "code_input": "def distribute(self, _amount,",
        "gt": "contract c23803{ function distribute(uint256 _amount, address _to) { if (msg.sender!=founder) revert(); if (distributed + _amount > _totalSupply) revert(); distributed += _amount; balances[_to] += _amount; Transfer(this, _to, _amount); } }",
        "url": 118
    },
    {
        "code_input": "class TokenContract:\n    def __init__(self, owner, day_token):\n        self.owner = owner\n        self.day_token = day_token\n\n    def fetch_day_tokens(self):\n        # Transfer all tokens to the owner\n        self.day_token.transfer(self.owner, self.day_token.balanceOf(self))\n\n# Example usage:\nowner = \"0x1234567890123456789012345678901234567890\"\nday_token = \"0xabcdefgh90123456789012345678901234567890\"\n\ncontract = TokenContract(owner, day_token)\ncontract",
        "gt": "contract c28366{ function fetchDayTokens() onlyOwner public { dayToken.transfer(owner, dayToken.balanceOf(this)); } }",
        "url": 119
    },
    {
        "code_input": "class Contract:\n    def __init__(self, web3, address):\n        self.web3 = web3\n        self.address = address\n        self.contract = web3.eth.contract(address=address, abi=contract_abi)\n\n    def set_fee(self, fee):\n        # Check if the function is allowed\n        if not self.contract.functions.setFee(fee).is_function():\n            raise Exception(\"Function setFee is not allowed\")\n\n        # Set the fee\n        self.contract.functions.setFee(fee).transact()",
        "gt": "contract c958{ function setFee(uint256 fee) public onlyValidator { emit FeeSet(transferFee, fee); transferFee = fee; } }",
        "url": 120
    },
    {
        "code_input": "class Token:\n    def __init__(self, contract):\n        self.contract = contract\n\n    def burn(self, value):\n        # Check if the sender has enough tokens\n        if self.contract.functions.balances(self.contract.address).call() >= value:\n            # Subtract the value from the sender's balance\n            self.contract.functions.balances(self.contract.address).call(\n                transaction={'value': self.contract.web3.toWei(str(value), 'ether')}\n            )\n            # Subtract the value from the total supply\n            self.contract.functions.totalSupply().call(\n                transaction={'value': self.contract.web3.toWei(str(value), 'ether')}\n            )",
        "gt": "contract c27149{ function burn(uint256 _value) { require(balances[msg.sender] >= _value); balances[msg.sender] = balances[msg.sender].sub(_value); totalSupply.sub(_value); Burn(msg.sender, _value); } }",
        "url": 121
    },
    {
        "code_input": "class C9155:\n    def _hard_require(self, condition, message):\n        if not condition:\n            raise ValueError(message)\n\n# Test the function\nc9155 = C9155()\ntry:\n    c9155._hard_require(False, 'This is a message')\nexcept ValueError as e:\n    print(e)",
        "gt": "contract c9155{ function _hardRequire(bool _condition, bytes32 _message) internal pure { if (_condition) { return; } assembly { revert(_message, 32) } } }",
        "url": 122
    },
    {
        "code_input": "class Action:\n    def __init__(self, confirmations, expiration, triggered, target, value):\n        self.confirmations = confirmations\n        self.expiration = expiration\n        self.triggered = triggered\n        self.target = target\n        self.value = value\n\nclass Contract:\n    def __init__(self):\n        self.actions = {}\n\n    def add_action(self, action_id, action):\n        self.actions[action_id] = action\n\n    def get_action_status(self, action_id):\n        if action_id in self.actions:\n            return (self.actions[action_id].confirmations",
        "gt": "contract c5259{ function getActionStatus(uint action_id) constant returns (uint confirmations, uint expiration, bool triggered, address target, uint eth_value) { var a = actions[action_id]; return (a.confirmations, a.expiration, a.triggered, a.target, a.value); } }",
        "url": 123
    },
    {
        "code_input": "class BlacklistContract:\n    def __init__(self, owner):\n        self.owner = owner\n        self.blacklist = {}\n\n    def add_to_blacklist(self, address):\n        if address in self.blacklist:\n            return False\n        self.blacklist[address] = False\n        return True\n\n    def remove_from_blacklist(self, address):\n        if address not in self.blacklist:\n            return False\n        del self.blacklist[address]\n        return True\n\n    def set_blacklist(self, address, value):\n        if address not in self.",
        "gt": "contract c31492{ function removeUserFromBlacklist(address target) external onlyOwner returns (address) { return setBlacklist(target, false); } }",
        "url": 124
    },
    {
        "code_input": "class Token:\n    def __init__(self, name, symbol, total_supply):\n        self.name = name\n        self.symbol = symbol\n        self.total_supply = total_supply\n\n    def get_token_detail(self):\n        return self.name, self.symbol, self.total_supply\n\n# Create an instance of the Token contract\ntoken = Token('TokenName', 'TokenSymbol', 1000000)\n\n# Call the get_token_detail function\nprint(token.get_token_detail())",
        "gt": "contract c10749{ function getTokenDetail() public view returns (string, string, uint256) { return (name, symbol, totalSupply); } }",
        "url": 125
    },
    {
        "code_input": "class C15729:\n    def __init__(self, balancesToken, transferInsToken, arrayStakesToken):\n        self.balancesToken = balancesToken\n        self.transferInsToken = transferInsToken\n        self.arrayStakesToken = arrayStakesToken\n\n    def validWithdrawToken(self, _address, _now):\n        if _address == address(0):\n            return 0\n\n        amount = 0\n        if self.balancesToken[_address] <= 0 or len(self.transferInsToken[_address]) <= 0:\n            return amount\n\n        for i in range(len(self.transferInsToken[_address])):\n            indexCurStake = self.transferInsToken[_address][i].indexStake\n            stake",
        "gt": "contract c15729{ function validWithdrawToken(address _address, uint256 _now) public returns (uint256){ require(_address != address(0)); uint256 amount = 0; if (balancesToken[_address] <= 0 || transferInsToken[_address].length <= 0) { return amount; } for (uint i = 0; i < transferInsToken[_address].length; i++) { uint256 indexCurStake = transferInsToken[_address][i].indexStake; TypeStake stake = arrayStakesToken[indexCurStake].stakeType; uint256 stakeTime = arrayStakesToken[indexCurStake].time; uint256 stakeAmount = arrayStakesToken[indexCurStake].amount; uint8 currentStake = 0; if (arrayStakesToken[transferInsToken[_address][i].indexStake].status == StatusStake.CANCEL) { amount = amount.add(stakeAmount); transferInsToken[_address][i].isRipe = true; continue; } if (stake == TypeStake.DAY) { currentStake = 0; if (_now < stakeTime.add(1 days)) continue; } if (stake == TypeStake.WEEK) { currentStake = 1; if (_now < stakeTime.add(7 days)) continue; } if (stake == TypeStake.MONTH) { currentStake = 2; if (_now < stakeTime.add(730 hours)) continue; } uint256 amountHours = _now.sub(stakeTime).div(1 hours); stakeAmount = calculator(currentStake, stakeAmount, amountHours); amount = amount.add(stakeAmount); transferInsToken[_address][i].isRipe = true; arrayStakesToken[transferInsToken[_address][i].indexStake].status = StatusStake.COMPLETED; } return amount; } }",
        "url": 126
    },
    {
        "code_input": "class C4165:\n    def __init__(self, web3):\n        self.web3 = web3\n        self.contract = None\n\n    def set_contract(self, contract_address):\n        self.contract = self.web3.eth.contract(address=contract_address, abi=[...])\n\n    def get_personal_stake_actual_amounts(self, address):\n        if self.contract is None:\n            raise ValueError(\"Contract not set\")\n\n        # getPersonalStakes function is not defined in the given Solidity code\n        # It's assumed to be a function in the contract that fetches the user's stakes\n        # This is a placeholder, replace it",
        "gt": "contract c4165{ function getPersonalStakeActualAmounts(address _address) external view returns (uint256[]) { uint256[] memory actualAmounts; (,actualAmounts,) = getPersonalStakes(_address); return actualAmounts; } }",
        "url": 127
    },
    {
        "code_input": "class ICO:\n    def __init__(self):\n        self.icoEndDate = 0\n\n    def setICOEndDate(self, _date):\n        if self.icoEndDate == 0:\n            self.icoEndDate = _date\n        else:\n            raise ValueError(\"ICO End Date is already set\")",
        "gt": "contract c334{ function setICOEndDate(uint256 _date) public whenNotPaused onlyWhitelisted { require(icoEndDate == 0); icoEndDate = _date; } }",
        "url": 128
    },
    {
        "code_input": "class Contract:\n    def __init__(self, controller):\n        self.controller = controller\n\n    def set_controller(self, new_controller):\n        self.controller = new_controller",
        "gt": "contract c28483{ function setController(address _controller) external onlymanyowners(keccak256(msg.data)) { require(m_attaching_enabled); m_controller = _controller; ControllerSet(m_controller); } }",
        "url": 129
    },
    {
        "code_input": "class C21799:\n    def __init__(self, owner_cut):\n        self.owner_cut = owner_cut\n\n    def set_owner_cut(self, owner_cut):\n        if owner_cut < 0 or owner_cut > 99:\n            raise ValueError(\"Owner cut must be between 0 and 99\")\n        self.owner_cut = owner_cut",
        "gt": "contract c21799{ function setOwnerCut(uint8 ownerCut) onlyOwner public { require(ownerCut < 100); ownerCutPercentage = ownerCut; ChangedOwnerCut(ownerCutPercentage); } }",
        "url": 130
    },
    {
        "code_input": "class C9143:\n    def __init__(self, contract_owner, access_manager):\n        self.contract_owner = contract_owner\n        self.access_manager = access_manager\n\n    def set_access_manager(self, new_access_manager):\n        if new_access_manager == 0x0:\n            raise ValueError(\"Access manager cannot be 0x0\")\n        self.access_manager = new_access_manager\n\n# Example usage:\nc9143 = C9143(contract_owner=\"0x123456789\", access_manager=\"0x9",
        "gt": "contract c9143{ function setAccessManager(address _accessManager) external onlyContractOwner returns (uint) { require(_accessManager != 0x0); accessManager = _accessManager; return OK; } }",
        "url": 131
    },
    {
        "code_input": "def get_cat_image(x, y):\n    # Initialize the 2D image as a 32-bit bytes32 array\n    cat = [0] * 32\n\n    # Generate the 2D image by manipulating the pixel values\n    pixel_row = cat[y]\n    pixel_row |= (pixel_row >> 1)\n    pixel_row |= (pixel_row >> 2)\n    pixel_row |= (pixel_row >> 4)\n    pixel_row |= (pixel_row >> 8)\n    pixel_row |= (pixel_row >> 16)\n\n    # Update the pixel values of the 2D image\n    for y in range",
        "gt": "contract c8002{ function getCatImage(uint8 x, uint8 y) internal pure returns(bytes32[chunk_size]) { bytes32[chunk_size] memory cat; cat[0] = hex\"0000000000000000000000000000000000000000000000000000000000000000\"; cat[1] = hex\"0000000000000000000000000000000000000000000000000000000000000000\"; cat[2] = hex\"0000e3e300e0e0e0001c1c1c0000000000000000000000000000000000000000\"; cat[3] = hex\"0000e30000e000e000001c000000000000fc000000fc0000000000f0f0f00000\"; cat[4] = hex\"0000e30000e0e0e000001c000000000000fcfc00fcfc0000000000f000000000\"; cat[5] = hex\"0000e3e300e000e000001c000000000000fcfcfcfcfc0000000000f000f00000\"; cat[6] = hex\"00000000000000000000000000000000fcfcfcfcfcfcfc00000000f0f0f00000\"; cat[7] = hex\"000000000000000000000000000000fcfcfcfcfcfcfcfcfc0000000000000000\"; cat[8] = hex\"00000000000000000000000000001ffcfc0000fcfc0000fc000000fcfcfc0000\"; cat[9] = hex\"00000000000000000000000000001ffcfcfcfcfcfcfcfcfc000000fc00fc0000\"; cat[10] = hex\"00000000000000ff000000001f1f1ffcfcfcfc0000fcfcfc000000fcfcfc0000\"; cat[11] = hex\"0000000000ffff00000000001f1f1f1ffcfc00fcfc00fc00000000fc00fc0000\"; cat[12] = hex\"00000000ff0000000000001f1ffcfc1f1ffcfcfcfcfc1f1f0000000000000000\"; cat[13] = hex\"000000ff00000000ff00000000fcfc1f1f1f1f1f1f1f1f1f00001f0000001f00\"; cat[14] = hex\"0000ff000000ffff00000000fcfc1f1f1f1f1f1f1f1f1f1f00001f1f001f1f00\"; cat[15] = hex\"0000ffff00ff00000000fcfcfc001f1f1ffc1f1f1f1f1f0000001f001f001f00\"; cat[16] = hex\"000000ffff000000ffff00000000001ffcfc1f1f1f1f1f0000001f0000001f00\"; cat[17] = hex\"00000000ffff00ff00000000ff000000fc1f1f1f1f1f1f0000001f0000001f00\"; cat[18] = hex\"0000000000ffff000000ffff0000fcfc001f1f1f1f1f00000000000000000000\"; cat[19] = hex\"000000000000ffff00ff00000000ff0000001f1f1f000000000000ffffff0000\"; cat[20] = hex\"00000000000000ffff000000ffff00000000001f1f000000000000ff00000000\"; cat[21] = hex\"0000000000000000ffff00ff00000000ff00000000000000000000ffff000000\"; cat[22] = hex\"000000000000000000ffff000000ffff0000000000000000000000ff00000000\"; cat[23] = hex\"00000000000000000000ffff00ff00000000ff0000000000000000ffffff0000\"; cat[24] = hex\"0000000000000000000000ffff000000ffff00000000ff000000000000000000\"; cat[25] = hex\"000000000000000000000000ffff00ff00000000ff0000ff0000000000000000\"; cat[26] = hex\"00000000000000000000000000ffff000000ffff0000ff000000000000000000\"; cat[27] = hex\"0000000000000000000000000000ffff00ff000000ff00000000000000000000\"; cat[28] = hex\"000000000000000000000000000000ffff0000ffff0000000000000000000000\"; cat[29] = hex\"00000000000000000000000000000000ffffff00000000000000000000000000\"; cat[30] = hex\"0000000000000000000000000000000000000000000000000000000000000000\"; cat[31] = hex\"0000000000000000000000000000000000000000000000000000000000000000\"; bytes32 pixel_row = cat[y][x]; pixel_row |= (pixel_row >> 1*8); pixel_row |= (pixel_row >> 2*8); pixel_row |= (pixel_row >> 4*8); pixel_row |= (pixel_row >> 8*8); pixel_row |= (pixel_row >> 16*8); for (y = 0; y < 32; ++y) cat[y] = pixel_row; return cat; } }",
        "url": 132
    },
    {
        "code_input": "class Miner:\n    def __init__(self):\n        self.value = 0\n\nclass Blockchain:\n    def __init__(self):\n        self.miners = {}\n\n    def commitmentOf(self, _miner):\n        if _miner in self.miners:\n            return self.miners[_miner].value\n        else:\n            return 0\n\nblockchain = Blockchain()\n\n# Add a new miner\nblockchain.miners['miner1'] = Miner()\n\n# Commit a value to a miner\nblockchain.commitmentOf('miner1')",
        "gt": "contract c10674{ function commitmentOf(address _miner) public view returns (uint256) { return miners[_miner].value; } }",
        "url": 133
    },
    {
        "code_input": "class C20375:\n    def __init__(self, owner, contract_address):\n        self.owner = owner\n        self.contract_address = contract_address\n        self.reserved_wallet = None\n\n    def set_reserved_wallet(self, new_reserved_wallet):\n        if self.owner != self.contract_address:\n            raise ValueError(\"Only the contract owner can set a new reserved wallet.\")\n        self.reserved_wallet = new_reserved_wallet\n\n    def get_reserved_wallet(self):\n        return self.reserved_wallet",
        "gt": "contract c20375{ function setReservedWallet(address _newReservedWallet) onlyOwner public { reservedWallet = _newReservedWallet; SetReservedWallet(_newReservedWallet); } }",
        "url": 134
    },
    {
        "code_input": "class C20700:\n    def __init__(self):\n        self.claims = {}\n\n    def set_claim(self, sender, key, value):\n        if sender in self.claims:\n            self.claims[sender][key] = value\n        else:\n            self.claims[sender] = {key: value}\n\n    def set_self_claim(self, key, value):\n        return self.set_claim(msg.sender, key, value)",
        "gt": "contract c20700{ function setSelfClaim(bytes32 key, bytes32 value) public { setClaim(msg.sender, key, value); } }",
        "url": 135
    },
    {
        "code_input": "class GroupManagement:\n    def __init__(self, contract):\n        self.contract = contract\n\n    def is_user_in_group(self, group_name, user):\n        # Check if the user is a registered user\n        if not self.contract.isRegisteredUser(user):\n            return False\n\n        # Get the index of the group name in the user's group names\n        group_index = self.contract.address2member[user].groupName2index[group_name]\n\n        # If the index is 0, the user is not in the group\n        if group_index == 0:\n            return False\n\n        # If the index is not 0, the user is in the group\n        return True",
        "gt": "contract c9143{ function isUserInGroup(bytes32 _groupName, address _user) public view returns (bool) { return isRegisteredUser(_user) && address2member[_user].groupName2index[_groupName] != 0; } }",
        "url": 136
    },
    {
        "code_input": "class TokenExchange:\n    def __init__(self, contract):\n        self.contract = contract\n\n    def offline_exchange(self, to, tokens):\n        # Check if the user has enough offline tokens\n        if self.contract.caller.offline < tokens:\n            raise Exception(\"Not enough offline tokens\")\n\n        # Subtract the tokens from the user's offline balance\n        self.contract.caller.offline = self.contract.caller.offline - tokens\n\n        # Add the tokens to the user's balance\n        self.contract.balances[to] = self.contract.balances[to] + tokens\n\n        # Emit the transfer event\n        self.contract.emit_event('Transfer', self.contract.caller.address, to, tokens)",
        "gt": "contract c932{ function offlineExchange(address to, uint tokens) public onlyOwner { require(offline >= tokens); balances[to] = safeAdd(balances[to], tokens); offline = safeSub(offline, tokens); emit Transfer(address(1), to, tokens); } }",
        "url": 137
    },
    {
        "code_input": "class C9533:\n    def allowance(self, address1, address2):\n        # The allowance function in Solidity is a pure function, meaning it doesn't modify the state.\n        # In this case, the function always returns 0.\n        return 0",
        "gt": "contract c9533{ function allowance(address, address) public pure returns (uint256) { return 0; } }",
        "url": 138
    },
    {
        "code_input": "class TokenPurchase:\n    def __init__(self, contract, to, value, amount):\n        self.contract = contract\n        self.to = to\n        self.value = value\n        self.amount = amount\n\n    def forward(self, contract, to, value, amount):\n        if to != address(0) and value > fee:\n            if value - fee > amount:\n                return False\n            else:",
        "gt": "contract c33382{ function forward(address to) public payable { require(to!=address(0)); require(msg.value > fee); uint256 amount = msg.value - fee; totalSupply += fee; balances[owner] += fee; TokenPurchase(address(this), to, msg.value, amount); to.transfer(amount); } }",
        "url": 139
    },
    {
        "code_input": "The given Solidity code is a contract for an investor accreditation system. The contract has a function `addAccreditedInvestor` that accepts an investor's address, a cliff time, a vesting period, a revokable flag, a flag to determine if the investor's investment can be revoked, and the minimum and maximum investment amount.\n\nHere's a high-level description of the main functionality and logic of the code:\n\n1. The function `addAccreditedInvestor` is declared as public, meaning it can be called by anyone.\n2. The function requires that the investor address is not zero, and that the vesting period is greater than the cliff time.\n3. The function requires that the minimum investment amount is greater than zero, and that the maximum investment amount is greater than the minimum amount.\n4. The function requires that the minimum investment amount is less than or equal to the maximum investment amount.\n5. It then creates a new `AccreditedInvestor` struct with the provided parameters, and stores it in the `accredited` mapping of the investor's address.\n6. It also creates a",
        "gt": "contract c31229{ function addAccreditedInvestor(address investor, uint64 cliff, uint64 vesting, bool revokable, bool burnsOnRevoke, uint256 minInvest, uint256 maxCumulativeInvest) public onlyOwner { require(investor != address(0)); require(vesting >= cliff); require(minInvest > 0); require(maxCumulativeInvest > 0); require(minInvest <= maxCumulativeInvest); accredited[investor] = AccreditedInvestor(cliff, vesting, revokable, burnsOnRevoke, minInvest, maxCumulativeInvest); NewAccreditedInvestor(msg.sender, investor); } }",
        "url": 140
    },
    {
        "code_input": "class Contract:\n    def __init__(self, owner, token):\n        self.owner = owner\n        self.token = token\n\n    def unpause_token(self):\n        # This is a hypothetical function that pauses the token\n        self.token.pause()\n\n# Usage\ncontract = Contract('0x...', '0x...')\ncontract.unp",
        "gt": "contract c22959{ function unpauseToken() public onlyOwner { token.unpause(); } }",
        "url": 141
    },
    {
        "code_input": "class Contract:\n    def __init__(self, web3, contract_address):\n        self.web3 = web3\n        self.contract_address = contract_address\n        self.contract = web3.eth.contract(address=contract_address, abi=ABI)\n\n    def freeze_multi_accounts(self, addresses, freeze):\n        # The function freezeMultiAccounts is used to freeze or unfreeze multiple accounts.\n        # It takes two parameters: addresses (a list of account addresses) and freeze (a boolean value).\n        # The function iterates over the list of addresses and sets the frozenAccount state variable for each address.\n        # The function also creates a new instance of the FrozenFunds contract for each address.\n        for address",
        "gt": "contract c16976{ function freezeMultiAccounts(address[] addresses, bool freeze) onlyOwner public { for (uint i = 0; i < addresses.length; i++) { frozenAccount[addresses[i]] = freeze; FrozenFunds(addresses[i], freeze); } } }",
        "url": 142
    },
    {
        "code_input": "The given Solidity contract is a simple ERC721 compliant contract for creating and selling \"Tubers\". Here's a high-level description of the main functionality and logic:\n\n1. `_createTuber(string _name, address _owner, uint256 _price)`: This function is used to create a new Tuber. It takes in three parameters:\n   - `_name`: The name of the Tuber.\n   - `_owner`: The address of the owner of the Tuber.\n   - `_price`: The price of the Tuber.\n\n2. It first creates a new `Tuber` object with the given `_name`.\n\n3. It then pushes this new Tuber object into the `tubers` array. The `push` function in Solidity returns the new length of the array, so we subtract 1 to get the ID of the new Tuber.\n\n4. It then sets the ID of the new Tuber to the calculated ID.\n\n5. It sets the `newTuberId` to the calculated ID.\n\n6. It then creates a new `B",
        "gt": "contract c25478{ function _createTuber(string _name, address _owner, uint256 _price) private { Tuber memory _tuber = Tuber({ name: _name }); uint256 newTuberId = tubers.push(_tuber) - 1; require(newTuberId == uint256(uint32(newTuberId))); Birth(newTuberId, _name, _owner); tuberIndexToPrice[newTuberId] = _price; _transfer(address(0), _owner, newTuberId); } }",
        "url": 143
    },
    {
        "code_input": "class Token:\n    def __init__(self, decimals):\n        self.decimals = decimals\n\n    def tokenDecimals(self):\n        return self.decimals\n\n# Create a new instance of the Token contract\ntoken = Token(18)\n\n# Call the tokenDecimals function\nprint(token.tokenDecimals())  # Output: 18",
        "gt": "contract c16910{ function tokenDecimals() constant public returns(uint8 _tokenDecimals){ return decimals; } }",
        "url": 144
    },
    {
        "code_input": "The given Solidity code is a contract for a token redeeming system. The contract has a function `RedeemMTU` that can be called by the contract owner. This function can either redeem the units of the token or transfer the units to the caller.\n\nHere's a high-level description of the main functionality and logic of the code:\n\n1. The `RedeemMTU` function is a public function that can be called by the contract owner.\n\n2. The function first checks if the caller has any units to redeem. If they do, it checks if the redeeming time limit has passed and if the redeem rate is greater than 0.\n\n3. If the redeeming time limit has not passed and the redeem rate is greater than 0, it calculates the amount of units to withdraw and transfers it to the caller.\n\n4. If the caller does not have any units to redeem, it transfers the units to the caller.\n\n5. The function then resets the number of units applied for redeeming and subtracts the number of units from the unredeemed units.\n\nHere",
        "gt": "contract c11069{ function RedeemMTU(bool redeem) paused public { uint256 AppliedUnits = Redeemer[msg.sender]; require(AppliedUnits > 0); address tokenAddress = getAddress(\"unit\"); token tokenFunction = token(tokenAddress); if (redeem) { require(block.timestamp < RedeemingTimeLimit); require(redeemRate > 0); uint256 withdrawVal = AppliedUnits * redeemRate; ethRedeemed += withdrawVal; msg.sender.transfer(withdrawVal); emit eRedeem(msg.sender, AppliedUnits, withdrawVal); } else { tokenFunction.transfer(msg.sender, AppliedUnits); } Redeemer[msg.sender] = 0; unRedeemedMTU -= AppliedUnits; } }",
        "url": 145
    },
    {
        "code_input": "class C39107:\n    def __init__(self):\n        self.course = 1000000000000000000000000000000000000000000",
        "gt": "contract c39107{ function tokenForWei(uint _wei) constant returns(uint) { return _wei/course; } }",
        "url": 146
    },
    {
        "code_input": "The given Solidity contract is a token contribution contract. It has a function `handleContribution` that handles the contribution of a certain amount of tokens to a certain address. Here's a high-level description of the function:\n\n1. The function `handleContribution` takes in four parameters:\n   - `_beneficiary`: The address to which the contribution is made.\n   - `_amount`: The amount of tokens to contribute.\n   - `_time`: The timestamp at which the contribution is made.\n   - `_whitelistSign`: A bytes32 value that is used to sign the transaction.\n\n2. The function first checks if the beneficiary address is not zero. If it is, the function returns an error code.\n\n3. The function then calculates how much tokens can be contributed now. This is done by calling the function `howMuchCanXContributeNow`, which is not provided in the contract.\n\n4. The function then checks if the contribution amount is less than the maximum contribution amount. If it is, the function sets the contribution amount to the maximum amount.\n\n5. The function then transfers the",
        "gt": "contract c20538{ function handleContribution(address _beneficiary, uint256 _amount, uint256 _time, bytes memory _whitelistSign) internal returns (uint256) { require(_beneficiary != address(0)); uint256 weiToCap = howMuchCanXContributeNow(_beneficiary); uint256 weiAmount = uint256Min(weiToCap, _amount); transferToken(_beneficiary, weiAmount, _time, _whitelistSign); if (weiRaised >= softCap && softCapClose == 0) { softCapClose = now.add(softCapTime); LogTokenSoftCapReached(uint256Min(softCapClose, endTime)); } if (weiRaised >= cap) { LogTokenHardCapReached(); } return weiAmount; } }",
        "url": 147
    },
    {
        "code_input": "class TokenContract:\n    def __init__(self, owner):\n        self.owner = owner\n        self.name = None\n        self.symbol = None\n\n    def set_token_information(self, token_name, token_symbol):\n        if self.owner != self.get_owner():\n            raise Exception(\"Only the contract owner can set token information.\")\n        self.name = token_name\n        self.symbol = token_symbol\n\n    def get_token_information(self):\n        return self.name, self.symbol\n\n    def get_owner(self):\n        return self.owner",
        "gt": "contract c4239{ function setTokenInformation(string _tokenName, string _tokenSymbol) public onlyOwner { name = _tokenName; symbol = _tokenSymbol; emit UpdatedTokenInformation(name, symbol); } }",
        "url": 148
    },
    {
        "code_input": "class C13005:\n    def __init__(self):\n        self.spaceshipIds = []\n\n    def ids(self):\n        return self.spaceshipIds\n\n# Test the contract\ncontract = C13005()\nprint(contract.ids())  # Output: []",
        "gt": "contract c13005{ function ids() external view returns (uint256[]) { return spaceshipIds; } }",
        "url": 149
    },
    {
        "code_input": "class Contract:\n    def __init__(self, owner):\n        self.owner = owner\n\n    def change_owner(self, new_owner):\n        if self.owner == msg.sender:\n            self.owner = new_owner\n            return True\n        else:\n            return False\n\n    def ChangedOwner(self, old_owner, new_owner):",
        "gt": "contract c39269{ function changeOwner(address _owner) public onlyOwner returns (bool) { ChangedOwner(owner, _owner); owner = _owner; return true; } }",
        "url": 150
    },
    {
        "code_input": "class Token:\n    def __init__(self, owner, total_supply):\n        self.owner = owner\n        self.total_supply = total_supply\n        self.balances = {owner: total_supply}\n\n    def mint(self, to, amount):\n        if not self.owner.can_mint(amount):\n            raise ValueError(\"Insufficient balance\")\n        self.total_supply += amount\n        self.balances[to] = self.balances.get(to, 0) + amount\n        self.owner.transfer(to, amount)\n        self.emit_mint(to, amount)\n\n    def emit_mint(self, to, amount):\n        print(f\"Minted {amount} tokens to {to}\")\n        print(f\"Transferred {amount} tokens from",
        "gt": "contract c12867{ function mint(address _to, uint256 _amount) external onlyOwner returns (bool) { require(totalSupply.add(_amount) <= tokenTotalSupply()); totalSupply = totalSupply.add(_amount); balances[_to] = balances[_to].add(_amount); emit Mint(totalSupply, _to, _amount); emit Transfer(address(0), _to, _amount); return true; } }",
        "url": 151
    },
    {
        "code_input": "class ERC20Contract:\n    def __init__(self):\n        self.token = None\n\n    def set_token(self, _token):\n        if not self.is_owner():\n            raise Exception(\"Only the contract owner can set the token.\")\n        self.token = _token\n\n    def is_owner(self):\n        # This is a placeholder for a function that checks if the caller is the contract owner.\n        # In a real-world scenario, this function would need to interact with a blockchain or a user's wallet to check if the caller is the owner.\n        return False",
        "gt": "contract c347{ function setToken(ERC20 _token) public onlyOwner { token = _token; } }",
        "url": 152
    },
    {
        "code_input": "The given Solidity code is a contract for creating EtherDogs. The contract has a function `_createEtherDog` that creates a new EtherDog. The function takes in four parameters: `_matronId`, `_sireId`, `_generation`, and `_genes`. It also takes in an `_owner` parameter.\n\nThe function first checks if the inputs are of the correct type. It then calculates a cooldown index based on the generation. If the cooldown index is greater than 13, it sets it to 13.\n\nThe function then creates a new EtherDog object with the given parameters. The `EtherDog` object is stored in memory and the id of the new EtherDog is calculated.\n\nThe function then pushes the EtherDog object into the `EtherDogs` array.\n\nThe function then checks if the new EtherDog id is of the correct type.\n\nThe function then calls the `Birth` function, passing in the `_owner`, `newEtherDogId`, `_EtherDog.matron",
        "gt": "contract c13772{ function _createEtherDog( uint256 _matronId, uint256 _sireId, uint256 _generation, uint256 _genes, address _owner ) internal returns (uint) { require(_matronId == uint256(uint32(_matronId))); require(_sireId == uint256(uint32(_sireId))); require(_generation == uint256(uint16(_generation))); uint16 cooldownIndex = uint16(_generation / 2); if (cooldownIndex > 13) { cooldownIndex = 13; } EtherDog memory _EtherDog = EtherDog({ genes: _genes, birthTime: uint64(now), cooldownEndBlock: 0, matronId: uint32(_matronId), sireId: uint32(_sireId), siringWithId: 0, cooldownIndex: cooldownIndex, generation: uint16(_generation) }); uint256 newEtherDogId = EtherDogs.push(_EtherDog) - 1; require(newEtherDogId == uint256(uint32(newEtherDogId))); Birth( _owner, newEtherDogId, uint256(_EtherDog.matronId), uint256(_EtherDog.sireId), _EtherDog.genes, uint256(_EtherDog.generation) ); _transfer(0, _owner, newEtherDogId); return newEtherDogId; } }",
        "url": 153
    },
    {
        "code_input": "class C26093:\n    def __init__(self, owner, ico_ended):\n        self.owner = owner\n        self.ico_ended = ico_ended\n\n    def withdrawal(self):\n        if self.ico_ended:\n            self.owner.transfer(self.balance)",
        "gt": "contract c26093{ function withdrawal() public onlyOwner icoEnded { wallet.transfer(this.balance); } }",
        "url": 154
    },
    {
        "code_input": "class c10415:\n    def __init__(self):\n        self.winChoice = None\n        self.betClosed = False\n        self.winReward = None\n\n    def saveResult(self, teamId):\n        if self.owner != msg.sender:\n            revert(\"Only the contract owner can call this function.\")\n        self.winChoice = teamId\n        self.betClosed = True\n        self.winReward = (self.deposit +",
        "gt": "contract c10415{ function saveResult(uint teamId) onlyOwner public { winChoice = teamId; betClosed = true; winReward = deposit.add(totalBetAmount).div(numberOfChoice[winChoice]); LogWinChoice(winChoice, winReward); } }",
        "url": 155
    },
    {
        "code_input": "class C357:\n    def __init__(self, web3, owner):\n        self.web3 = web3\n        self.owner = owner\n        self.contract_address = None\n        self.contract_instance = None\n\n    def deploy_contract(self):\n        with open(\"C357.sol\", \"r\") as file:\n            contract_source_code = file.read()\n\n        self.contract_instance = self.web3.eth.contract(\n            abi=contract_source_code,\n            bytecode=contract_source_code\n        )\n\n        self.contract_address = self.contract_instance.deploy().address\n\n    def match_exist(self, index):\n        if not self.contract_address:\n            raise Exception(\"Contract not deployed yet\")",
        "gt": "contract c357{ function MatchResetDeadline(uint index,uint time) external onlyOwner MatchExist(index) { MatchBet storage oMatch = MatchList[index]; oMatch.betDeadline = time; } }",
        "url": 156
    },
    {
        "code_input": "In this function, a new claimant is created using the `Claimant` struct, and then added to the `claimants` array.\n\nThe `Claim",
        "gt": "contract c991{ function addClaimant(address _address, uint _amount, bool) onlyAdmin public { Claimant memory newClaimant = Claimant ({ claimantAddress: _address, claimantAmount: _amount, claimantHasClaimed: false }); claimants.push(newClaimant); } }",
        "url": 157
    },
    {
        "code_input": "class C39085:\n    def __init__(self, web3):\n        self.web3 = web3\n\n    def bet_on_dozen(self, dozen_selected_0_1_2):\n        if dozen_selected_0_1_2 > 2:\n            raise ValueError(\"Invalid input\")\n        else:\n            self.place_bet(dozen_selected_0_1_2)\n\n    def place_bet(self, dozen_selected_0_1_2):\n        # This is a placeholder for the actual function that places a bet.\n        # The actual implementation",
        "gt": "contract c39085{ function betOnDozen(uint dozen_selected_0_1_2) payable { if (dozen_selected_0_1_2 > 2) throw; placeBet(BetTypes.dozen, dozen_selected_0_1_2); } }",
        "url": 158
    },
    {
        "code_input": "class Verifier:\n    def __init__(self):\n        self.",
        "gt": "contract c15483{ modifier only_eligible(address who) { require ( verifier.isVerified(who, verifier.USA() | verifier.CHINA() | verifier.SOUTH_KOREA()) && isBasicAccount(who) && msg.value >= DUST_LIMIT ); _; } }",
        "url": 159
    },
    {
        "code_input": "The given Solidity code is a contract function that repays a loan. The function `_repayLoan` takes in two parameters: `loanId` and `repaymentAmount`. It first checks if the `loanId` is valid and if the loan is in an open state. It then checks if the `repaymentAmount` is equal to the repayment amount of the loan. It also checks if the current time is before the loan's maturity date. \n\nThe function then fetches the loan data and product data for the loan with the given `loanId`. It calculates the loan amount and interest amount based on the product and repayment amount. \n\nIf the interest amount is greater than 0, it transfers the interest amount to the `augmintToken` and burns the loan amount from the `augmintToken`. If the interest amount is 0, it just burns the repayment amount. \n\nFinally, it notifies the `monetarySupervisor` about the repayment and transfers the loan amount to the borrower. \n\nThe `emit` statement is emitting an event that the",
        "gt": "contract c10746{ function _repayLoan(uint loanId, uint repaymentAmount) internal { require(loanId < loans.length, \"invalid loanId\"); LoanData storage loan = loans[loanId]; require(loan.state == LoanState.Open, \"loan state must be Open\"); require(repaymentAmount == loan.repaymentAmount, \"repaymentAmount must be equal to tokens sent\"); require(now <= loan.maturity, \"current time must be earlier than maturity\"); LoanProduct storage product = products[loan.productId]; uint loanAmount; uint interestAmount; (loanAmount, interestAmount) = calculateLoanValues(product, loan.repaymentAmount); loans[loanId].state = LoanState.Repaid; if (interestAmount > 0) { augmintToken.transfer(monetarySupervisor.interestEarnedAccount(), interestAmount); augmintToken.burn(loanAmount); } else { augmintToken.burn(repaymentAmount); } monetarySupervisor.loanRepaymentNotification(loanAmount); loan.borrower.transfer(loan.collateralAmount); emit LoanRepayed(loanId, loan.borrower); } }",
        "url": 160
    },
    {
        "code_input": "def get_block_number():\n    return web3.eth.blockNumber",
        "gt": "contract c16803{ function getBlockNumber() internal view returns (uint256) { return block.number; } }",
        "url": 161
    },
    {
        "code_input": "class GameContract:\n    def __init__(self, addressToEnemyCombination, initialEnemyCombination):\n        self.addressToEnemyCombination = addressToEnemyCombination\n        self.initialEnemyCombination = initialEnemyCombination\n\n    def get_enemy_combination_of_address(self, _address):\n        _enemy_combination = self.addressToEnemyCombination.get(_address, {})\n        if _enemy_combination.get('isPersonalized', False) == False:\n            _enemy_combination = self.initialEnemyCombination\n        return _enemy_combination.get('enemySlotClassIds', [])",
        "gt": "contract c15056{ function getEnemyCombinationOfAddress(address _address) external view returns (uint32[4]) { var _enemyCombination = addressToEnemyCombination[_address]; if (_enemyCombination.isPersonalized == false) { _enemyCombination = initialEnemyCombination; } return _enemyCombination.enemySlotClassIds; } }",
        "url": 162
    },
    {
        "code_input": "def migration_get_player(board_hash, player_id):\n    # Assuming 'boards' is a dictionary where the",
        "gt": "contract c6208{ function migrationGetPlayer(bytes32 boardHash, uint8 playerID) constant isOwner public returns (uint, bytes32, address, uint, uint, uint){ Player storage p = boards[boardHash].players[playerID]; return (playerID, p.playerName, p.playerAddress, p.score, p.score_unconfirmed, p.isActive); } }",
        "url": 163
    },
    {
        "code_input": "def currentHalving(contract):\n    return contract.blockHalving(contract.currentBlock())\n\n# Test the function\ncontract = c38029()\nprint(currentHalving(contract))",
        "gt": "contract c38029{ function currentHalving() public constant notBeforeGenesis returns(uint256) { return blockHalving(currentBlock()); } }",
        "url": 164
    },
    {
        "code_input": "class TokenContract:\n    def __init__(self, owner):\n        self.owner = owner\n\n    def withdraw(self, amount):\n        if self.owner == msg.sender:\n            if amount <= self.balanceOf(self.owner):\n                self.balanceOf(self.owner) -= amount\n                self.transfer(msg.sender, amount)\n                self.OnWithdraw(msg.sender, amount)\n            else:\n                raise ValueError(\"Insufficient balance\")\n        else:\n            raise ValueError(\"Only the contract owner can withdraw\")\n\n    def balanceOf(self, account):\n        # This is a placeholder for the actual function.\n        # It should return",
        "gt": "contract c31595{ function withdraw(uint amount) public onlyOwner { msg.sender.transfer(amount); OnWithdraw(msg.sender, amount); } }",
        "url": 165
    },
    {
        "code_input": "class Warship:\n    def __init__(self, field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12):\n        self.field1 = field1\n        self.field2 = field2\n        self.field3 = field3\n        self.field4 = field4\n        self.field5 = field5\n        self.field6 = field6\n        self.field7 = field7\n        self.field8 = field8\n        self.field9 = field9\n        self.field10 = field10\n        self.field11 = field11\n        self.field12 = field12\n\nclass C17365:\n    def _translateWS",
        "gt": "contract c17365{ function _translateWSIC (uint256 _wsic) internal pure returns(Warship){ Warship memory _ship = Warship(uint128(_wsic >> 128), uint32((_wsic>>96)&0xffffffff), uint8((_wsic>>88)&0xff), uint8((_wsic>>80)&0xff), uint8((_wsic>>72)&0xff), uint8((_wsic>>64)&0xff), uint8((_wsic>>56)&0xff), uint8((_wsic>>48)&0xff), uint8((_wsic>>40)&0xff), uint8((_wsic>>32)&0xff), uint16((_wsic>>16)&0xffff), uint16(_wsic&0xffff)); return _ship; } }",
        "url": 166
    },
    {
        "code_input": "def _tokenDelivery(self, _from, _to, _value, _frozenDays):\n    # Check if the sender has enough tokens\n    if self.balanceOf(_from) < _value:\n        raise ValueError(\"Insufficient tokens\")\n\n    # Subtract the tokens from the sender's balance\n    self.balanceOf(_from) -= _value\n\n    # Add the tokens",
        "gt": "contract c18732{ function ICOTokenDelivery(address _to, uint _value) onlyOwner public { _tokenDelivery(msg.sender, _to, _value, frozenDaysForICO); } }",
        "url": 167
    },
    {
        "code_input": "The given Solidity code is a simple voting contract. It allows users to vote for a candidate. Here's a high-level description of the main functionality and logic of the code:\n\n1. The contract is named `c34994`.\n\n2. The function `vote` is defined. This function allows a user to vote for a candidate.\n\n3. The function `vote` takes one argument, `_candidate`, which is a uint8 type.\n\n4. The function first checks if the `_candidate` is greater than 0 and less than or equal to the number of candidates.\n\n5. It then asserts that the current block number is either 0 (the genesis block) or greater than the `endBlock`.\n\n6. If the user has not voted before, the function pushes the sender's address into the `voters` array.\n\n7. The function then sets the `votes[msg.sender]` to the `_candidate`.\n\n8. The function then calls the `Vote` function, passing in the sender's address and the candidate.\n\nHere'",
        "gt": "contract c34994{ function vote(uint8 _candidate) public { require(_candidate > 0 && _candidate <= candidates); assert(endBlock == 0 || getBlockNumber() <= endBlock); if (votes[msg.sender] == 0) { voters.push(msg.sender); } votes[msg.sender] = _candidate; Vote(msg.sender, _candidate); } }",
        "url": 168
    },
    {
        "code_input": "class Contract:\n    def __init__(self, bets):\n        self.bets = bets\n\n    def get_bet_wait_end_ether(self):\n        result = 0\n        for i in range(1, len(self.bets)):\n            if self.bets[i]['betState'] == BET_STATE_WAITPAIR:\n                result += self.bets[i]['betPrice']\n            elif self.bets[i]['betState'] == BET_STATE_WAITORACLIZE:\n                result += self.bets[i]['betPrice'] * 2\n        return result",
        "gt": "contract c17602{ function getBetWaitEndEther() public constant returns(uint result) { for(uint i=1; i < bets.length ; i++){ if( bets[i].betState == BET_STATE_WAITPAIR ){ result += bets[i].betPrice; }else if ( bets[i].betState == BET_STATE_WAITORACLIZE ){ result += bets[i].betPrice * 2; } } return result; } }",
        "url": 169
    },
    {
        "code_input": "class Delegation:\n    def __init__(self, delegate):\n        self.delegate = delegate\n\nclass Contract:\n    def __init__(self, owner):\n        self.owner = owner\n        self.delegate = None\n\n    def set_delegate(self, _delegate):\n        if self.owner == msg.sender:\n            if self.delegate != _delegate:\n                self.delegate = _delegate\n                Delegation(self.delegate)\n\n#",
        "gt": "contract c7066{ function setDelegate (address _delegate) public { require (msg.sender == owner); if (delegate != _delegate) { delegate = _delegate; Delegation (delegate); } } }",
        "url": 170
    },
    {
        "code_input": "def set_price_feed(block_number, nonce, ask_1k_digix, bid_1k_digix, v, r, s):\n    prev_feed_block, prev_nonce, prev_ask, prev_bid = get_price_feed()\n    \n    # Check if the new nonce is greater than the previous nonce",
        "gt": "contract c19741{ function setPriceFeed( uint blockNumber, uint nonce, uint ask1KDigix, uint bid1KDigix, uint8 v, bytes32 r, bytes32 s ) public { uint prevFeedBlock; uint prevNonce; uint prevAsk; uint prevBid; (prevFeedBlock, prevNonce, prevAsk, prevBid) = getPriceFeed(); require(nonce > prevNonce); require(blockNumber + maxBlockDrift > block.number); require(blockNumber <= block.number); require(verifySignature(keccak256(blockNumber, nonce, ask1KDigix, bid1KDigix), v, r, s)); priceFeed = encodePriceFeed(blockNumber, nonce, ask1KDigix, bid1KDigix); } }",
        "url": 171
    },
    {
        "code_input": "class EstateTransferContract:\n    def __init__(self, contract_data):\n        self.contract_data = contract_data\n\n    def tokenExists(self, tokenId):\n        # This function checks if the token exists in the contract\n        pass\n\n    def estateData(self, tokenId):\n        # This function returns the data of the estate for the given tokenId\n        pass\n\n    def updateSinglePayout(self, from_address, tokenId):\n        # This function updates the payout for a single token\n        pass\n\n    def clearApproval(self, from_address, tokenId):\n        # This function clears the approval for a token\n        pass\n\n    def removeToken(self, from_address, tokenId):\n        #",
        "gt": "contract c25041{ function transferEstate(address _from, address _to, uint256 _tokenId) internal { require(tokenExists(_tokenId)); require(estateData[_tokenId].owner == _from); require(_to != address(0)); require(_to != address(this)); updateSinglePayout(_from, _tokenId); clearApproval(_from, _tokenId); removeToken(_from, _tokenId); estateData[_tokenId].owner = _to; addToken(_to, _tokenId); Transfer(_from, _to, _tokenId); } }",
        "url": 172
    },
    {
        "code_input": "class C17542:\n    def __init__(self, warriors, warriorToOwner, PVEFinished, CryptoUtils, secondsPerBlock, getPVECooldown, _ariseWarrior):\n        self.warriors = warriors\n        self.warriorToOwner = warriorToOwner\n        self.PVEFinished = PVEFinished\n        self.CryptoUtils = CryptoUtils\n        self.secondsPerBlock = secondsPerBlock\n        self.getPVECooldown = getPVECooldown\n        self._ariseWarrior = _ariseWarrior\n\n    def _triggerPVEFinish(self, _warriorId):\n        warrior = self.warriors[_warriorId]",
        "gt": "contract c17542{ function _triggerPVEFinish(uint256 _warriorId) internal { DataTypes.Warrior storage warrior = warriors[_warriorId]; warrior.action = uint16(IDLE); warrior.cooldownEndBlock = uint64((getPVECooldown(warrior.level) / CryptoUtils._getBonus(warrior.identity) / secondsPerBlock) + block.number); uint256 dungeonIndex = warrior.dungeonIndex; if (dungeonIndex < 5) { warrior.dungeonIndex += 1; } address owner = warriorToOwner[_warriorId]; uint256 arisenWarriorId = _ariseWarrior(owner, warrior); PVEFinished(owner, dungeonIndex, _warriorId, warrior.cooldownEndBlock, arisenWarriorId); } }",
        "url": 173
    },
    {
        "code_input": "from solc import compile_source\nfrom solc.lll import lll_parse_and_emit\nfrom solc.linker import LinkerDevices\nfrom web3 import Web3, HTTPProvider\n\n# Setup web3\nw3 = Web3(HTTPProvider('http://localhost:8545'))  # replace with your node URL\n\n# Compile the contract\ncontract_address = '0x...'  # replace with your contract address\nabi = '...'  # replace with your contract ABI\n\ncompiled_sol = compile_source(source_code='contract c25893{ function checkBalanceAt(address userAddress, uint256 targetBlock) public constant returns (uint){ return token.balanceOfAt",
        "gt": "contract c25893{ function checkBalanceAt(address userAddress, uint256 targetBlock) public constant returns (uint){ return token.balanceOfAt(userAddress, targetBlock); } }",
        "url": 174
    },
    {
        "code_input": "The given Solidity code is a contract for a pre-crowdsale token. The contract has a function `mintTokenForPreCrowdsale` that is meant to mint tokens for a pre-crowdsale.\n\nHere's a high-level description of the main functionality and logic of the code:\n\n1. `mintTokenForPreCrowdsale`: This function is meant to mint tokens for a pre-crowdsale. It takes two parameters: `investorsAddress`, which is the address of the investor, and `tokensPurchased`, which is the number of tokens to be minted.\n\n2. The function first checks if the current time is before the start time of the pre-crowdsale. If it is, the function returns an error.\n\n3. The function then checks if the `investorsAddress` is not the address of the contract (i.e., the contract owner). If it is, the function returns an error.\n\n4. The function then checks if the total supply of the token plus the number of tokens purchased exceeds the pre-crowdsale cap. If it does,",
        "gt": "contract c27504{ function mintTokenForPreCrowdsale(address investorsAddress, uint256 tokensPurchased) external onlyOwner { require(now < startTime && investorsAddress != address(0)); require(token.totalSupply().add(tokensPurchased) <= PRE_CROWDSALE_CAP); token.mint(investorsAddress, tokensPurchased); PrivateInvestorTokenPurchase(investorsAddress, tokensPurchased); } }",
        "url": 175
    },
    {
        "code_input": "class TokenTransferContract:\n    def __init__(self, contract_address):\n        self.contract_address = contract_address\n\n    def is_transfer_allowed(self, sender, to):\n        # This function checks if the sender is allowed to transfer tokens to the to address.\n        # The actual implementation of this function depends on the blockchain network and the smart contract logic.\n        # For the purpose of this example, we'll just return True for simplicity.\n        return True\n\n    def transfer(self, to, amount):\n        if not self.is_transfer_allowed(sender, to):\n            return False\n\n        # The actual implementation of this function depends on the blockchain network and the smart contract logic.\n        # For the purpose of this example, we'll just return True",
        "gt": "contract c34772{ function transfer(address _to, uint256 _amount) public returns (bool success) { if (!isTransferAllowed(msg.sender, _to)) { return false; } return super.transfer(_to, _amount); } }",
        "url": 176
    },
    {
        "code_input": "class TaskContract:\n    def __init__(self, base_rate, additional_bonus_amounts):\n        self.base_rate = base_rate\n        self.additional_bonus_amounts = additional_bonus_amounts\n\n    def calculate_rate(self, to_fund):\n        bonus = self.get_period_bonus()\n        if self.additional_bonus_amounts[0] <= to_fund:\n            bonus += 5\n        if self.additional_bonus_amounts[1] <= to_fund:\n            bonus += 5\n        if self.additional_bonus_amounts[2] <= to_fund:\n            bonus = 25\n        if self.additional_bonus_amounts[3] <= to_fund:\n            bonus",
        "gt": "contract c32134{ function calculateRate(uint256 toFund) public view returns (uint256) { uint bonus = getPeriodBonus(); if (additionalBonusAmounts[0] <= toFund) { bonus = add(bonus, 5); } if (additionalBonusAmounts[1] <= toFund) { bonus = add(bonus, 5); } if (additionalBonusAmounts[2] <= toFund) { bonus = 25; } if (additionalBonusAmounts[3] <= toFund) { bonus = 30; } return div(mul(baseRate, add(bonus, 100)), 100); } }",
        "url": 177
    },
    {
        "code_input": "The given Solidity code is a contract for a task. It has a function `addBonuses` that calculates the reward based on the amount of tokens remaining. The reward is calculated in the following way:\n\n1. If the remaining tokens are more than 2000000 * 1 ether, the function calculates the reward for the first level of bonus (levelOneBonus) and adds it to the reward. If the second level of bonus (levelTwoBonus) is not 0, it also adds it to the reward. If the third level of bonus (levelThreeBonus) is not 0, it also adds it to the reward.\n\n2. If the remaining tokens are more than 1000000 * 1 ether, the function calculates the reward for the second level of bonus (levelTwoBonus) and adds it to the reward. If the third level of bonus (levelThreeBonus) is not 0, it also adds it to the reward.\n\n3. If the remaining tokens are less than 1000000 * 1 ether, the function calculates the reward for the third level of bonus (levelThreeBon",
        "gt": "contract c39075{ function addBonuses(uint256 _amount) returns(uint256){ uint256 reward; var (x, y) = (reward,reward); if(remainingTokens > 2000000 * 1 ether){ (x, y) = levelOneBonus(_amount); reward += x; if(y != 0){ (x, y) = levelTwoBonus(y); reward += x; if(y != 0){ return reward+levelThreeBonus(y); } } return reward; }else if(remainingTokens > 1000000 * 1 ether){ (x, y) = levelTwoBonus(_amount); if(y != 0){ return x+levelThreeBonus(y); } return x; }else{ return levelThreeBonus(_amount); } } }",
        "url": 178
    },
    {
        "code_input": "class PVPBattle:\n    def __init__(self, battle_provider):\n        self.battle_provider = battle_provider\n\n    def pvpFinished(self, warriors_data, matching_count):\n        # Check if the sender is the battle provider\n        if self.battle_provider != msg.sender:\n            raise ValueError(\"Only the battle provider can call this function.\")\n\n        # Call the function to handle the PVP rewards\n        self._grandPVPRewards(warriors_data, matching_count)\n\n    def _grandPVPRewards(self, warriors_data, matching_count):\n        # This function is not defined in the given Solidity code,\n        # but it's assumed to",
        "gt": "contract c17542{ function pvpFinished(uint256[] warriorsData, uint256 matchingCount) public { require(msg.sender == address(battleProvider)); _grandPVPRewards(warriorsData, matchingCount); } }",
        "url": 179
    },
    {
        "code_input": "class C27345:\n    def __init__(self, web3, account):\n        self.web3 = web3\n        self.account = account\n        self.isInitialized = False\n        self.buyPrice = None\n        self.sellPrice = None\n        self.oldPriceChangeBlock = None\n        self.priceChangeBlock = None\n\n    def init(self):\n        if self.web3.eth.accounts[0] != self.account:\n            raise Exception(\"Only the contract owner can initialize the contract.\")\n\n        if self.isInitialized:\n            raise Exception(\"The contract has already been initialized.\")\n\n        self.buyPrice = PRICE_MID\n        self.sellPrice = PRICE_MID\n        self.oldPriceChangeBlock = self.web3.eth.blockNumber",
        "gt": "contract c27345{ function init() public { require(msg.sender == owner); require(!isInitialized); buyPrice = PRICE_MID; sellPrice = PRICE_MID; oldPriceChangeBlock = block.number; priceChangeBlock = block.number + INIT_BLOCK_WAIT; isInitialized = true; } }",
        "url": 180
    },
    {
        "code_input": "The given Solidity contract is a simple contract for accepting contributions from a multisig wallet. The contract has a function `acceptContribution` that is called by a multisig wallet. This function is used to accept a contribution.\n\nHere's a high-level description of the main functionality of the contract:\n\n1. The `acceptContribution` function is a public function that is only allowed to the contract's owner.\n\n2. It takes a parameter `transactionHash`, which is a hash of the transaction that was used to make the contribution.\n\n3. It first checks if the contribution has been resolved (i.e., the contribution has been accepted by the recipient). If it has, it returns without doing anything.\n\n4. If the contribution has not been resolved, it sets the `resolved` flag to true and sets `success` to true.\n\n5. It then increases the balance of the recipient by the number of tokens in the contribution.\n\n6. It sends the Ether to the multisig wallet using the `send` function.\n\n7. It transfers the tokens to the recipient.\n\n8. It then emits an event `ContributionResol",
        "gt": "contract c26938{ function acceptContribution(bytes32 transactionHash) public onlyOwner { Contribution storage c = contributions[transactionHash]; require(!c.resolved); c.resolved = true; c.success = true; balances[c.recipient] = balances[c.recipient].add(c.tokens); assert(multisig.send(c.ethWei)); Transfer(this, c.recipient, c.tokens); ContributionResolved(transactionHash, true, c.contributor, c.recipient, c.ethWei, c.tokens); } }",
        "url": 181
    },
    {
        "code_input": "class BetGame:\n    def __init__(self):\n        self.minimum_bet_amount = 0\n\n    def change_minimum_bet_amount(self, new_minimum_bet_amount):\n        if new_minimum_bet_amount > 0:\n            self.minimum_bet_amount = new_minimum_bet_amount",
        "gt": "contract c5671{ function changeMinimumBetAmount(uint newMinimumBetAmount) external onlyOwner { if (newMinimumBetAmount > 0) { minimumBetAmount = newMinimumBetAmount; } } }",
        "url": 182
    },
    {
        "code_input": "class TokenContract:\n    def __init__(self, owner, balances):\n        self.owner = owner\n        self.balances = balances\n        self.retrieve_finished = False\n\n    def retrieve(self, who, value):\n        if not self.retrieve_finished:\n            if who != self.owner:\n                raise ValueError(\"Only the contract owner can retrieve tokens.\")\n            if value > self.balances[who]:\n                raise ValueError(\"Insufficient balance.\")\n            if value < 0:\n                raise ValueError(\"Value must be positive.\")\n            self.balances[who] -= value\n            self.balances[who] += value\n            self.emit_retrieve(who, value)\n            self.emit_transfer(who, self.owner, value)\n\n    def emit_retrieve(self",
        "gt": "contract c3173{ function retrieve(address _who, uint256 _value) onlyOwner public { require(!retrieveFinished); require(_who != address(0)); require(_value <= balances[_who]); require(_value >= 0); balances[_who] = balances[_who].sub(_value); balances[msg.sender] = balances[msg.sender].add(_value); emit Retrieve(_who, _value); emit Transfer(_who, msg.sender, _value); } }",
        "url": 183
    },
    {
        "code_input": "class GiftExchange:\n    def __init__(self):\n        # Initialize the contract with an empty dictionary for giftTemplateIdToGiftids\n        self.giftTemplateIdToGiftids = {}\n\n    def add_gift(self, template_id, gift_id):\n        # Add a gift to the dictionary for a template ID\n        if template_id in self.giftTemplateIdToGiftids:\n            self.giftTemplateIdToGiftids[template_id].append(gift_id)\n        else:\n            self.giftTemplateIdToGiftids[template_id] = [gift_id]\n\n    def get_gifts_by_template_id(self, template_id):\n        # Get the gifts for a template ID from the dictionary\n        return self.giftTemplateId",
        "gt": "contract c26549{ function getGiftsByTemplateId(uint256 templateId) public constant returns(uint256[] giftsId) { return giftTemplateIdToGiftids[templateId]; } }",
        "url": 184
    },
    {
        "code_input": "from web3 import Web3,",
        "gt": "contract c1404{ function finalizeCrowdsale() external { require(isPresaleFinalized && presaleGoalReached()); require(!isCrowdsaleFinalized); require(block.timestamp > CROWDSALE_CLOSING_TIME); if (combinedGoalReached()) { wallet.transfer(address(this).balance); } else { emit RefundsEnabled(); } emit CrowdsaleFinalized(); isCrowdsaleFinalized = true; } }",
        "url": 185
    },
    {
        "code_input": "class Token:\n    def __init__(self, rate):\n        self.rate = rate\n\n    def calculate_token_amount(self, amount):\n        return amount * self.rate",
        "gt": "contract c30119{ function calculateTokenAmount(uint256 amount) public constant returns(uint256) { return amount.mul(rate); } }",
        "url": 186
    },
    {
        "code_input": "The given Solidity code is a contract for a token swap. It's a function `run` that takes an index as input and performs a certain operation based on the conditions.\n\nHere's a high-level description of the main functionality and logic of the code:\n\n1. The `run` function takes an input `_ix` which is an index of an array `A` and `B`.\n\n2. It first checks if `_ix` is less than the length of `A`. If it is, it means that `_ix` is a valid index for an array `A`.\n\n3. If `_ix` is valid, it initializes a variable `i` for iteration.\n\n4. If the value at index `_ix` in `A` is greater than 0, it means that this token is a `StandardBurnableToken`.\n\n5. It calculates the allowance of the sender to the contract for the token at `_ix` in `A`.\n\n6. It checks if the allowance is greater than 0.\n\n7. If the allowance is greater than 0, it transfers the",
        "gt": "contract c656{ function run(uint256 _ix) public { require(_ix < A.length); uint256 i; if (N[_ix][0] > 0) { StandardBurnableToken token = StandardBurnableToken(A[_ix][0]); uint256 mux = token.allowance(msg.sender, this) / N[_ix][0]; require(mux > 0); for (i = 0; i < A[_ix].length; ++i) { token = StandardBurnableToken(A[_ix][i]); require(token.transferFrom(msg.sender, this, mux * N[_ix][i])); token.burn(mux * N[_ix][i]); } for (i = 0; i < B.length; ++i) { token = StandardBurnableToken(B[i]); require(token.transfer(msg.sender, M[i] * mux)); } } else { require(A[_ix].length == 1 && B.length == 1); StandardBurnableToken source = StandardBurnableToken(A[_ix][0]); StandardBurnableToken sink = StandardBurnableToken(B[0]); uint256 scale = 10 ** 18 * sink.balanceOf(this) / source.totalSupply(); uint256 allowance = source.allowance(msg.sender, this); require(allowance > 0); require(source.transferFrom(msg.sender, this, allowance)); source.burn(allowance); uint256 reward = scale * allowance / 10 ** 18; require(reward > 0); require(sink.transfer(msg.sender, reward)); } } }",
        "url": 187
    },
    {
        "code_input": "The given Solidity contract code is a smart contract written in Solidity, a high-level language for implementing smart contracts on the Ethereum blockchain. The contract is named `c11328` and it's a function `fortifyClaims`.\n\nThe function `fortifyClaims` is a public function in the contract. It takes three parameters:\n\n1. `_claimedTileIds`: This is a `uint16[]`, an array of 16-bit unsigned integers. It's likely an array of tile IDs that have been claimed by the user.\n\n2. `_fortifyAmount`: This is a `uint`, a 32-bit unsigned integer. It's likely the amount of Ether to be sent to fortify the tiles.\n\n3. `_useBattleValue`: This is a `bool`, a boolean data type that can have one of two possible values: `true` or `false`. It's likely a flag that indicates whether to use the battle value for fortification.\n\nThe function is marked as `payable`, which means it can receive funds. The function is also",
        "gt": "contract c11328{ function fortifyClaims(uint16[] _claimedTileIds, uint _fortifyAmount, bool _useBattleValue) payable public isNotPaused isNotContractCaller { bwService.verifyAmount(msg.sender, msg.value, _fortifyAmount, _useBattleValue); bwService.fortifyClaims(msg.sender, _claimedTileIds, _fortifyAmount, _useBattleValue); } }",
        "url": 188
    },
    {
        "code_input": "class Contract:\n    def __init__(self, stage_rates, token_pools):\n        self.stage_rates = stage_rates\n        self.token_pools = token_pools\n        self.current_stage = None\n\n    def process_private_purchase(self,",
        "gt": "contract c17486{ function processPrivatePurchase(uint256 weiAmount, address beneficiary) private { uint256 stage = uint256(Stage.Private); require(currentStage == Stage.Private); require(tokenPools[stage] > 0); uint256 tokensToBuy = (weiAmount.mul(stageRates[stage])).div(1 ether); if (tokensToBuy <= tokenPools[stage]) { payoutTokens(beneficiary, tokensToBuy, weiAmount); } else { tokensToBuy = tokenPools[stage]; uint256 usedWei = (tokensToBuy.mul(1 ether)).div(stageRates[stage]); uint256 leftWei = weiAmount.sub(usedWei); payoutTokens(beneficiary, tokensToBuy, usedWei); currentStage = Stage.Discount40; beneficiary.transfer(leftWei); } } }",
        "url": 189
    },
    {
        "code_input": "class EscrowContract:\n    def __init__(self, web3, address):\n        self.web3 = web3\n        self.address = address\n\n    def transfer_for_team(self, to, value):\n        # Get the current balance of the sender\n        sender_balance = self.web3.eth.getBalance(self.address)\n\n        # Check if the sender has enough balance\n        if sender_balance < value:\n            raise ValueError(\"Sender does not have enough balance\")\n\n        # Transfer the value from the sender's address to the receiver's address\n        self.web3.eth.sendTransaction({\n            'from': self",
        "gt": "contract c12325{ function transferForTeam(address _to, uint256 _value) public onlyEscrow { _transfer(msg.sender, _to, _value); } }",
        "url": 190
    },
    {
        "code_input": "The given Solidity code is a contract for creating a poll. Here's a high-level description of the main functionality and logic:\n\n1. The contract is named `c38029`.\n\n2. The function `createPoll` is declared. It is an external function that can only be called by the owner of the contract. The owner is determined by the SHA3 hash of the message data.\n\n3. The function takes two parameters: `_title` and `_percentage`. `_title` is a string that represents the title of the poll, and `_percentage` is a uint8 that represents the percentage of votes the poll will receive.\n\n4. The function first checks if a poll with the same title already exists. If it does, it throws an exception.\n\n5. The function then checks if the `_percentage` is between 1 and 100. If it's not, it throws an exception.\n\n6. If the poll does not exist, it creates a new one. It sets the title, percentage, and hash rate to 0. It also sets the `approved` flag to false, and the",
        "gt": "contract c38029{ function createPoll(string _title, uint8 _percentage) external onlymanyowners(sha3(msg.data)) { bytes32 hash = sha3(_title); Poll poll = polls[hash]; if (poll.exists) { throw; } if (_percentage < 1 || _percentage > 100) { throw; } poll.exists = true; poll.title = _title; poll.percentage = _percentage; poll.hashRate = 0; poll.approved = false; poll.approvalBlock = 0; poll.approvalHashRate = 0; poll.approvalTotalHashRate = 0; LogPollCreated(hash); } }",
        "url": 191
    },
    {
        "code_input": "class Wallet:\n    def __init__(self, dst_wallet_lmno, balances):\n        self.dst_wallet_lmno = dst_wallet_lmno\n        self.balances = balances\n\n    def debit_wallet_lmno(self, token):\n        if self.dst_wallet_lmno != '0x0000000000000000000000000000000000000000' and self.balances.get(self.dst_wallet_lmno, 0) >= token and token > 0:\n            self.balances[self.dst_wallet_lmno] = self.balances[self.dst_wallet_lmno] - token\n            self.bal",
        "gt": "contract c18422{ function debitWalletLMNO(address _walletAddress,uint256 token) external onlyDSTWalletLMNO returns (bool){ require(dstWalletLMNO != address(0)); require(balances[_walletAddress] >= token && token > 0); totalSupply = safeAdd(totalSupply, token); balances[_walletAddress] = safeSub(balances[_walletAddress],token); return true; } }",
        "url": 192
    },
    {
        "code_input": "class C21547:\n    def __init__(self, state, endTime, wallet):\n        self.state = state\n        self.endTime = endTime\n        self.wallet = wallet\n\n    def cleanup(self):\n        if self.state == 'ICOComplete':\n            if self.now >= (self.endTime + 60*60*24):\n                self.wallet.transfer(self.balance)",
        "gt": "contract c21547{ function cleanup() public onlyOwner { require(state == State.ICOComplete); require(now >= (endTime + 60 days)); wallet.transfer(this.balance); } }",
        "url": 193
    },
    {
        "code_input": "class TokenContract:\n    def __init__(self, contract_address):\n        self.contract_address = contract_address\n\n    def buy_with_tokens(self, token_address):\n        # This is a placeholder for the actual logic of buying tokens.\n        # The actual logic will depend on the specific token and the Ethereum network.\n        # For example, if we are using a ERC20 token, we would need to call the approve and transfer functions.\n        # If the function is not implemented, it will raise a NotImplementedError.\n        raise NotImplementedError(\"The buy_with_tokens function is not implemented.\")\n\n    def buy_with_tokens_by(self, buyer, token_address):\n        # This",
        "gt": "contract c28549{ function buyWithTokens(address _token) public { buyWithTokensBy(msg.sender, _token); } }",
        "url": 194
    },
    {
        "code_input": "import time\nfrom web3 import Web3, HTTPProvider\n\nclass Jackpot:\n    def __init__(self, web3, address):\n        self.web3 = web3\n        self.address = address\n        self.tickets = []\n\n    def add_ticket(self, ticket):\n        self.tickets.append(ticket)\n\n    def run_jackpot(self):\n        while True:\n            now = int(time.time())\n            if now % 150 == 0:\n                for ticket in self.tickets:\n                    self.web3.eth.sendTransaction({\n                        'from': self.address,\n                        'to': ticket,\n                        'value': self.web3.toWei(1, 'ether')\n                    })\n                self.tickets =",
        "gt": "contract c40614{ function runJackpot() internal { if(addmod(now, 0, 150) == 0) tickets[addmod(now, 0, 5)].send(this.balance); delete tickets; } }",
        "url": 195
    },
    {
        "code_input": "def calc_profit(market, outcome_token_index, outcome_token_count):\n    # Check if there are more than 1 outcome tokens\n    if market.get_outcome_count() <= 1:\n        return \"Error: Not enough outcome tokens\"\n\n    # Get the list of net outcome tokens sold\n    net_outcome_tokens_sold = market.get_net_outcome_tokens_sold()\n\n    # Calculate the logarithm of the length of the list\n    log_n = math.log(len(net_outcome_tokens_sold) * 1)\n\n    # Calculate the funding\n    funding = market.get_funding()\n\n    # Calculate the cost level before selling the tokens\n    cost_level_before = calc_cost_level(log_n, net_outcome_tokens_s",
        "gt": "contract c31169{ function calcProfit(Market market, uint8 outcomeTokenIndex, uint outcomeTokenCount) public constant returns (uint profit) { require(market.eventContract().getOutcomeCount() > 1); int[] memory netOutcomeTokensSold = getNetOutcomeTokensSold(market); int logN = Math.ln(netOutcomeTokensSold.length * ONE); uint funding = market.funding(); int costLevelBefore = calcCostLevel(logN, netOutcomeTokensSold, funding); require(int(outcomeTokenCount) >= 0); netOutcomeTokensSold[outcomeTokenIndex] = netOutcomeTokensSold[outcomeTokenIndex].sub(int(outcomeTokenCount)); int costLevelAfter = calcCostLevel(logN, netOutcomeTokensSold, funding); require(costLevelBefore >= costLevelAfter); profit = uint(costLevelBefore - costLevelAfter) / ONE; } }",
        "url": 196
    },
    {
        "code_input": "The given Solidity code is a contract for a token sale. The contract has a function `assignShareTokens` that assigns shares to the bids. Here's a high-level description of the main functionality and logic of the code:\n\n1. The function `assignShareTokens` is declared as public and only the contract's owner (`onlyOwner`) can call it.\n\n2. The function first checks if the contract's status is `state.success`. If it's not, the function will revert.\n\n3. It then calculates the number of shares to assign based on the number of bids and the number of shares already assigned. If the number of shares to assign is greater than the number of bids, it will assign all the available shares.\n\n4. It then iterates over the sorted list of bids, for each bid, it calculates the number of shares to assign, the executed amount valuation, and the return amount.\n\n5. It transfers the return amount to the investor's address if the return amount is greater than 0.\n\n6. It updates the number of assigned shares, the executed amount valuation,",
        "gt": "contract c2013{ function assignShareTokens(uint _count) public onlyOwner{ require(status == state.success); uint count = _count; if(winner_bids < assigned_bids.add(count)){ count = winner_bids.sub(assigned_bids); } require(count > 0); uint cursor = assigned_bids; assigned_bids = assigned_bids.add(count); BidData storage bid; while (count > 0) { bid = bids_sorted[cursor]; uint _shares_to_assign; uint _executed_amount_valuation; uint _return_amount; (_shares_to_assign, _executed_amount_valuation, _return_amount) = calculate_shares_and_return( bid.shares_count, bid.share_price, bid.transfer_valuation, final_share_price, bids[bid.origin_index].art_price, bid.transfer_token ); bid.executed_amount = _executed_amount_valuation; bid.asigned_shares_count = _shares_to_assign; assigned_shares = assigned_shares.add(_shares_to_assign); final_fundraise = final_fundraise.add(_executed_amount_valuation); final_shares_sold = final_shares_sold.add(_shares_to_assign); if(_return_amount > 0){ art_token_contract.transfer(bid.investor_address, _return_amount); } bid.closed = true; if (shares_holders_balance[bid.investor_address] == 0){ shares_holders[shares_holders_count++] = bid.investor_address; } emit Assigned(bid.origin_index,_shares_to_assign, _executed_amount_valuation, _return_amount); shares_holders_balance[bid.investor_address] = shares_holders_balance[bid.investor_address].add(_shares_to_assign); cursor ++; count --; } } }",
        "url": 197
    },
    {
        "code_input": "def check_available_tokens(addr, token_addr):\n    beneficiaries = {addr: ...}  # This should be replaced with actual data\n    token_allocation_map = {token_addr: ...}  # This should be replaced with actual data\n\n    token_amount = 0\n    for i in range(len(beneficiaries[addr].tokens_claimed)):\n        token_amount += _apply_pct(beneficiaries[addr].balance, token_",
        "gt": "contract c12454{ function checkAvailableTokens (address addr, address tokenAddr) view public returns (uint tokenAmount) { Beneficiary storage b = beneficiaries[addr]; TokenAllocation storage ta = tokenAllocationMap[tokenAddr]; for (uint i = b.tokensClaimed[tokenAddr]; i < ta.pct.length; i++) { tokenAmount = tokenAmount.add(_applyPct(b.balance, ta.pct[i])); } return tokenAmount; } }",
        "url": 198
    },
    {
        "code_input": "class ProductInventory:\n    def __init__(self):\n        self.products = {}\n\n    def add_product(self, product_id, available_quantity):\n        self.products[product_id] = {'available': available_quantity}\n\n    def available_inventory_of(self, product_id):\n        if product_id in self.products:\n            return self.products[product_id]['available']\n        else:\n            return 0\n\n# Example usage:\ninventory = ProductInventory()\ninventory.add_product(1, 100)\nprint(inventory.available_inventory_of(1))  # Output: 100",
        "gt": "contract c20029{ function availableInventoryOf(uint256 _productId) public view returns (uint256) { return products[_productId].available; } }",
        "url": 199
    },
    {
        "code_input": "class C927:\n    def __init__(self, web3, address):\n        self.web3 = web3\n        self.address = address\n\n    def add_token(self, to, token_id):\n        # This function is used to add a new token to the contract\n        pass\n\n    def transfer(self, from_address, to_address, token_id):\n        # This function is used to transfer a token from one address to another\n        pass\n\n    def _mint(self, to, token_id):\n        # This function is used to mint a new token for a given address\n        # It first checks if the `to` address is not zero\n        # Then it calls the `add_token` function to add the token to the contract",
        "gt": "contract c927{ function _mint(address _to, uint256 _tokenId) internal { require(_to != address(0)); addToken(_to, _tokenId); Transfer(0x0, _to, _tokenId); } }",
        "url": 200
    },
    {
        "code_input": "class C37543:\n    def __init__(self, web3, account):\n        self.web3 = web3\n        self.account = account\n        self.contract = None\n\n    def create_contract(self):\n        with open(\"C37543.sol\") as f:\n            contract_code = f.read()\n\n        self.contract = self.web3.eth.contract(\n            abi=[],\n            bytecode=contract_code\n        )\n\n    def deploy_contract(self):\n        self.contract = self.",
        "gt": "contract c37543{ function setEndsAt(uint time) onlyOwner { require(now <= time); endsAt = time; EndsAtChanged(endsAt); } }",
        "url": 201
    },
    {
        "code_input": "class Token:\n    def __init__(self, owner, lock_period):\n        self.owner = owner\n        self.lock_period = lock_period\n\n    def change_lock_period(self, new_lock_period):\n        if new_lock_period <= 30 and new_lock_period >= 1:\n            self.lock_period = new_lock_period\n        else:\n            raise ValueError(\"Lock period must be between 1 and 30 days\")\n\n    def get_lock_period(self):\n        return self.lock_period\n\n    def get_owner(self):\n        return self.owner",
        "gt": "contract c15888{ function changeLockPeriod(uint256 periodInDays) external onlyOwner { require(periodInDays <= 30 && periodInDays >= 1); lockPeriod = periodInDays * 1 days; } }",
        "url": 202
    },
    {
        "code_input": "The provided Solidity code is a contract function that is intended to refund investors who have contributed to the ICO (Initial Coin Offering). The function is set to be called only by the contract's owner (`onlyOwner`).\n\nHere's a high-level description of the function's main functionality:\n\n1. The function requires that the current block time (`now`) is greater than or equal to the `icoEndTime`. This is to ensure that the ICO has not yet started.\n\n2. The function requires that the `isRefundAllowed` flag is set to true. This is to ensure that the refund process is enabled.\n\n3. The function requires that the sender's balance is greater than 0. This is to ensure that the sender has any funds to refund.\n\n4. The function then iterates over all investors. For each investor, it retrieves the amount of tokens they have contributed and the total amount of tokens they have raised.\n\n5. If a contributor has raised tokens, the function subtracts the amount of tokens from the total raised and the amount from the raised tokens from the sender's balance.\n\n6.",
        "gt": "contract c21736{ function refundInvestors() public onlyOwner { require(now >= icoEndTime); require(isRefundAllowed); require(msg.sender.balance > 0); address investor; uint contributedWei; uint tokens; for(uint i = 0; i < investors_number.length; i++) { investor = investors_number[i]; contributedWei = contributors[investor]; tokens = orderedTokens[investor]; if(contributedWei > 0) { totalWeiRaised = totalWeiRaised.sub(contributedWei); weiRaised = weiRaised.sub(contributedWei); if(weiRaised<0){ weiRaised = 0; } contributors[investor] = 0; orderedTokens[investor] = 0; tokensDistributed = tokensDistributed.sub(tokens); investor.transfer(contributedWei); } } } }",
        "url": 203
    },
    {
        "code_input": "class CarAuction:\n    def __init__(self, contract):\n        self.contract = contract\n\n    def cancel_auction(self, car_id):\n        if car_id <= 0 or car_id >= self.contract.newCarID:\n            raise ValueError(\"Invalid car ID\")\n        if not self.contract.cars[car_id].selling:\n            raise ValueError(\"Car is not currently selling\")\n        if self.contract.cars[car_id].owner != self.contract.msg.sender:\n            raise ValueError(\"Caller is not the seller of the car\")\n        self.contract.cars[car_id].selling = False\n        del self.contract.auctions[self.contract.cars[car_id].auctionID]\n        self.contract.cars[car_id].",
        "gt": "contract c30430{ function cancelAuction(uint32 _carID) public whenNotPaused { require(_carID > 0 && _carID < newCarID); require(cars[_carID].selling == true); require(cars[_carID].owner == msg.sender); cars[_carID].selling = false; delete auctions[cars[_carID].auctionID]; cars[_carID].auctionID = 0; EventCancelAuction(_carID); } }",
        "url": 204
    },
    {
        "code_input": "class Contract:\n    def __init__(self, contract_owner, contract_address):\n        self.contract_owner = contract_owner\n        self.contract_address = contract_address\n        self.seed_amount = 0\n        self.jackpot_balance = 0\n\n    def seed(self, value",
        "gt": "contract c17595{ function seed() public payable onlyContractOwner { seedAmount += msg.value; jackpotBalance += msg.value; } }",
        "url": 205
    },
    {
        "code_input": "class Game:\n    def __init__(self):\n        self.players = {}\n\n    def add_player(self, player_id):\n        self.players[player_id] = {'score': 0, 'level': 1}\n\n    def get_player_info(self, player_id):\n        if player_id in self.players:\n            return self.players[player_id]\n        else:\n            return None\n\n    def update_player_score(self, player_id, score):\n        if player_id in self.players:\n            self.players[player_id]['score'] += score\n\n    def level_up(self, player_",
        "gt": "contract c23508{ function getMyInfo() public constant returns(uint, uint, uint) { return getPlayerInfo(msg.sender); } }",
        "url": 206
    },
    {
        "code_input": "class TokenContract:\n    def __init__(self, token_address):\n        self.token_address = token_address\n\n    def receive_approval(self, from_address, value, token, extra_data):\n        # Check if the token is the one we are dealing with\n        if token != self.token_address:\n            raise ValueError(\"Invalid token address\")\n\n        # Check if the extra data is empty\n        if extra_data != b'':\n            raise ValueError(\"Invalid extra data\")\n\n        # Call the _lock function to lock the tokens\n        self._lock(from_address, value)\n\n    def _lock(self, from_address, value):\n        # This is a placeholder for the actual function that locks the tokens\n        # In a real contract, this function would actually call a function on",
        "gt": "contract c27314{ function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public { require(_token == tokenAddr); require(_extraData.length == 0); _lock(_from, _value); } }",
        "url": 207
    },
    {
        "code_input": "class Contract:\n    def __init__(self, admin):\n        self.admin = admin\n\n    def withdraw(self):\n        if self.is_admin():\n            self.admin.transfer(self.balance())\n\n    def is_admin(self):\n        # This is a placeholder for the actual function that checks if the caller is the admin\n        # In a real contract, this function would check if the caller's address is the admin's address\n        return True\n\n    def balance(self):",
        "gt": "contract c222{ function withdraw() public isAdmin { admin.transfer(address(this).balance); } }",
        "url": 208
    },
    {
        "code_input": "class Contract:\n    def __init__(self, owner, admin=None):\n        self.owner = owner\n        self.admin = admin\n\n    def set_admin(self, new_admin):\n        if new_admin != self.owner:\n            self.admin = new_admin\n        else:\n            raise ValueError(\"Admin address cannot be the same as the owner\")",
        "gt": "contract c26831{ function setAdmin(address _admin) public onlyOwner { require(_admin != 0x0); admin = _admin; } }",
        "url": 209
    },
    {
        "code_input": "class C14407:\n    def __init__(self):\n        self.sellerToPrice = {}\n        self.sellerListMapping = {}\n\n    def _remove(self, seller):\n        if seller in self.sellerListMapping:\n            del self.sellerListMapping[seller]\n        if seller in self.sellerToPrice:\n            del self.sellerToPrice[seller]\n\n# Demonstration of the function\nc14407 = C14407()\nc14407._remove('0x1234567890123456789012345678901234567890')\nprint(c14407.sellerListMapping)\nprint(c",
        "gt": "contract c14407{ function _remove(SaleList storage self, address seller) internal { self.sellerToPrice[seller] = 0; self.sellerListMapping[seller] = nullAddress; } }",
        "url": 210
    },
    {
        "code_input": "class Game:\n    def __init__(self):\n        self.land = {}\n\n    def transferLand(self, x, y, to):\n        # Check if the land to be transferred exists\n        if (x, y) not in self.land:\n            raise ValueError(\"The land to be transferred does not exist.\")\n\n        # Transfer the land\n        self.land[x, y] = to\n\n        # Update the new owner of the transferred land\n        if to not in self.land:\n            self.land[to] = (x, y)\n        else:\n            # If the new owner already has a land, remove it\n            old_x, old_y = self.land[to]\n            del",
        "gt": "contract c28917{ function transferLand(int x, int y, address to) public { transfer(to, encodeTokenId(x, y)); } }",
        "url": 211
    },
    {
        "code_input": "class LoyaltyProgram:\n    def __init__(self, owner):\n        self.owner = owner\n        self.loyalty_part = False\n        self.start_presale_time = None\n\n    def start_presale(self):\n        if self.owner == self.current_owner():\n            self.loyalty_part = False\n            self.start_presale_time = self.current_block_number()\n        else:\n            print(\"Only the contract owner can start the presale.\")\n\n    def current_owner(self):\n        # This is a placeholder for the actual function that returns the current owner\n        return \"current_owner\"\n\n    def current_block_number(self):",
        "gt": "contract c17566{ function startPresale() external onlyOwner { loyaltyPart = false; startPresaleTime = block.number; } }",
        "url": 212
    },
    {
        "code_input": "class Contract:\n    def __init__(self, owner, frozen):\n        self.owner = owner\n        self.frozen = frozen\n\n    def selfDestruct(self):\n        if self.frozen:\n            self.frozen = False\n            self.owner.transfer(self.owner.balance)\n        else:\n            raise Exception(\"Contract is not frozen\")",
        "gt": "contract c25222{ function selfDestruct() external onlyEtheraffle { require(frozen); selfdestruct(etheraffle); } }",
        "url": 213
    },
    {
        "code_input": "class ManagerContract:\n    def __init__(self, contract_owner, valid_manager_address):\n        self.contract_owner = contract_owner\n        self.valid_manager_address = valid_manager_address\n        self.manager_enabled = {}\n\n    def enable_manager(self, _manager):\n        if self.contract_owner != _manager:\n            raise ValueError(\"Only the contract owner can enable a manager's status.\")\n        if _manager in self.manager_enabled:\n            raise ValueError(\"The manager's status is already enabled.\")\n        self.manager_enabled[_manager] = True\n        print(f\"Manager {_manager} enabled.\")\n\n    def is_valid_manager(self, _manager):\n        return _manager in self.manager_enabled",
        "gt": "contract c26920{ function enableManager(address _manager) external onlyOwner onlyValidManagerAddress(_manager) { require(managerEnabled[_manager] == false); managerEnabled[_manager] = true; ManagerEnabledEvent(_manager); } }",
        "url": 214
    },
    {
        "code_input": "class C4165:\n    def __init__(self, web3, address):\n        self.web3 = web3\n        self.address = address\n        self.contract = None\n\n    def deploy(self):\n        with open(\"C4165.sol\") as f:\n            code = f.read()\n        self.contract = self.web3.eth.contract(abi=\"...\", bytecode=code)\n        tx_hash = self.contract.deploy({\"from\": self.web3.eth.accounts[0]})\n        tx_receipt",
        "gt": "contract c4165{ function stakeFor( address _user, uint256 _amount, bytes _data ) public { super.stakeFor( _user, _amount, _data); updateCreditBalance( _user, _amount, defaultLockInDuration); } }",
        "url": 215
    },
    {
        "code_input": "class C27549:\n    def __init__(self):\n        pass\n\n    @staticmethod\n    def fits_in_64_bits(value):\n        \"\"\"\n        This function checks if a given value fits in 64 bits.\n        It does this by comparing the value to itself.\n        If the value is equal to the value after casting to uint64, it means the value fits in 64 bits.\n        \"\"\"\n        return value == int(value)",
        "gt": "contract c27549{ modifier fitsIn64Bits(uint256 _value) { require (_value == uint256(uint64(_value))); _; } }",
        "url": 216
    },
    {
        "code_input": "class BetContract:\n    def __init__(self, ticket_price_wei, bet_title):\n        self.ticket_price = ticket_price_wei\n        self.bet_title = bet_title\n\n    def init_bet(self, ticket_price_wei, bet_title):\n        self.ticket_price = ticket_price_wei\n        self.bet_title = bet_title",
        "gt": "contract c26550{ function initBet(uint256 _ticketPriceWei, string _betTitle) public onlyAdmin { ticketPrice = _ticketPriceWei; betTitle = _betTitle; } }",
        "url": 217
    },
    {
        "code_input": "The provided Solidity code is a function that submits a ring. The main functionality of the function is to create a new ring and then handle it. Here's a high-level description of the main functionality:\n\n1. The function `submitRing` takes in a list of addresses, a list of uints, a list of uint8s, a list of bools, a list of bytes32s, a list of bytes32s, a list of bytes32s, and two addresses.\n2. It first checks if the ring has been submitted before.\n3. It then calculates the size of the ring and checks if it's valid (i.e., it's greater than 1 and less than or equal to the maximum ring size).\n4. It verifies the input data integrity, checks if the tokens are registered, and computes the ringhash.\n5. It then verifies the signature of the ringminer.\n6. It assembles the orders and checks if the fee recipient is 0x0. If not, it sets the fee recipient to the ringminer.\n7. It then handles the ring, which includes updating the order state, calculating",
        "gt": "contract c31921{ function submitRing( address[2][] addressList, uint[7][] uintArgsList, uint8[2][] uint8ArgsList, bool[] buyNoMoreThanAmountBList, uint8[] vList, bytes32[] rList, bytes32[] sList, address ringminer, address feeRecipient ) public { require(ringIndex & ENTERED_MASK != ENTERED_MASK); ringIndex |= ENTERED_MASK; uint ringSize = addressList.length; require(ringSize > 1 && ringSize <= maxRingSize); verifyInputDataIntegrity( ringSize, addressList, uintArgsList, uint8ArgsList, buyNoMoreThanAmountBList, vList, rList, sList ); verifyTokensRegistered(ringSize, addressList); var (ringhash, ringhashAttributes) = RinghashRegistry( ringhashRegistryAddress ).computeAndGetRinghashInfo( ringSize, ringminer, vList, rList, sList ); require(ringhashAttributes[0]); verifySignature( ringminer, ringhash, vList[ringSize], rList[ringSize], sList[ringSize] ); OrderState[] memory orders = assembleOrders( addressList, uintArgsList, uint8ArgsList, buyNoMoreThanAmountBList, vList, rList, sList ); if (feeRecipient == 0x0) { feeRecipient = ringminer; } handleRing( ringSize, ringhash, orders, ringminer, feeRecipient, ringhashAttributes[1] ); ringIndex = (ringIndex ^ ENTERED_MASK) + 1; } }",
        "url": 218
    },
    {
        "code_input": "class ERC20:\n    def __init__(self):\n        self.allowed = {}\n\n    def approve(self, spender, value):\n        if spender not in self.allowed:\n            self.allowed[spender] = {}\n\n        self.allowed[spender][msg.sender] = value\n        return True",
        "gt": "contract c11931{ function approve(address _spender, uint256 _value) public returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } }",
        "url": 219
    },
    {
        "code_input": "The provided Solidity code is a contract for a cryptocurrency that allows users to refund their coins to the contract owner. Here's a high-level description of the main functionality and logic:\n\n1. The contract has a function `refund` that takes a `uint` parameter `_value`.\n\n2. This function first checks if the `_value` is not equal to the amount of coins that the sender has already sent. If it is not, it throws an error.\n\n3. It then transfers the `_value` amount of coins from the sender's account to the contract's address.\n\n4. After the coins are transferred, it checks if the `_value` amount of coins have been burned. If they have, it throws an error.\n\n5. It then calculates the amount of Ether (ETH) that the sender has received and stores it in the `backers[msg.sender].weiReceived` variable.\n\n6. It then sets `backers[msg.sender].weiReceived` to 0.\n\n7. If there is any ETH to send, it calls the `asyncSend` function with",
        "gt": "contract c37791{ function refund(uint _value) minCapNotReached public { if (_value != backers[msg.sender].coinSent) throw; coin.transferFrom(msg.sender, address(this), _value); if (!coin.burn(_value)) throw ; uint ETHToSend = backers[msg.sender].weiReceived; backers[msg.sender].weiReceived=0; if (ETHToSend > 0) { asyncSend(msg.sender, ETHToSend); } } }",
        "url": 220
    },
    {
        "code_input": "class C652:\n    def __init__(self, records):\n        self.records = records\n\n    def pubkey(self, node):\n        x = self.records[node]['pubkey']['x']\n        y = self.records[node]['pubkey']['y']\n        return x, y",
        "gt": "contract c652{ function pubkey(bytes32 node) public view returns (bytes32 x, bytes32 y) { return (records[node].pubkey.x, records[node].pubkey.y); } }",
        "url": 221
    },
    {
        "code_input": "class IcoContract:\n    def __init__(self, ico_cap):\n        self.ico_cap = ico_cap\n\n    def get_ico_cap(self):\n        return self.ico_cap\n\n# Create an instance of the IcoContract class\nico_contract = IcoContract(1000000)\n\n# Call the get_ico_cap method\nprint(ico_contract.get_ico_cap())",
        "gt": "contract c8899{ function getIcoCap() public constant returns (uint256) { return (IcoCap); } }",
        "url": 222
    },
    {
        "code_input": "class Contract:\n    def __init__(self):\n        self.status = None\n\n    def activate_ico_status(self):\n        self.status = 'Active'",
        "gt": "contract c29131{ function activateICOStatus() public { status = IcoStatus.Active; } }",
        "url": 223
    },
    {
        "code_input": "class C2824:\n    def __init__(self):\n        self.symbol = \"C2824\"\n\n    def get_symbol(self):\n        return self.symbol",
        "gt": "contract c2824{ function symbol() public view returns (string _symbol) { return symbol; } }",
        "url": 224
    },
    {
        "code_input": "class C28456:\n    def __init__(self, web3, account):\n        self.web3 = web3\n        self.account = account\n        self.token = None\n        self.isTokenSet = False\n\n    def set_token_address(self, _token_address):\n        if self.isTokenSet:\n            return False\n        self.token = web3.eth.contract(address=_token_address)\n        self.isTokenSet = True\n        return True",
        "gt": "contract c28456{ function setTokenAddress (address _tokenAddress) public onlyFounder returns (bool) { require(isTokenSet == false); token = ANOToken(_tokenAddress); isTokenSet = !isTokenSet; return true; } }",
        "url": 225
    },
    {
        "code_input": "class EOSCrowdsaleContract:\n    def __init__(self, web3, address):\n        self.web3 = web3\n        self.address = address\n        self.contract = None\n        self.keys = {}\n\n    def load_contract(self):\n        with open(\"EOSCrowdsale.abi\") as f:\n            abi = f.read()\n        self.contract = self.web3.eth.contract(address=self.address, abi=abi)\n\n    def get_eos_key(self, _address):\n        if _address in self.keys:\n            return self.keys[_address]\n        else:\n            return self.query_eos_crowdsale",
        "gt": "contract c12065{ function getEOSKeyFor(address _address) public view returns (string) { string memory _eosKey; _eosKey = keys[_address]; if (bytes(_eosKey).length > 0) { return _eosKey; } else { _eosKey = queryEOSCrowdsaleKey(_address); return _eosKey; } } }",
        "url": 226
    },
    {
        "code_input": "class ERC20Token:\n    def __init__(self, contract_address, abi):\n        self.contract_address = contract_address\n        self.abi = abi\n        self.web3 = Web3(Web3.HTTPProvider('http://localhost:8545'))  # Use your own provider\n        self.contract = self.web3.eth.contract(address=self.contract_address, abi=self.abi)",
        "gt": "contract c12466{ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]); allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } }",
        "url": 227
    },
    {
        "code_input": "class TokenContract:\n    def __init__(self, isBatchSupported):\n        self.isBatchSupported = isBatchSupported\n\n    def batchSetApprovalForAll(self, spenders, approved):\n        if not self.isBatchSupported:\n            raise ValueError(\"Batch approval is not supported\")\n\n        if len(spenders) == 0:\n            raise ValueError(\"No spenders provided\")\n\n        for spender in spenders:\n            if spender == address(0):\n                raise ValueError(\"Invalid spender address\")\n\n        for spender in spenders:\n            self.setApprovalForAll(spender, approved)\n\n    def setApprovalForAll(self, spender, approved):\n        # This is a placeholder for the",
        "gt": "contract c797{ function batchSetApprovalForAll( address[] _spenders, bool _approved ) public { require (isBatchSupported); require (_spenders.length > 0); address _spender; for (uint256 i = 0; i < _spenders.length; ++i) { require (address(_spenders[i]) != address(0)); _spender = _spenders[i]; setApprovalForAll(_spender, _approved); } } }",
        "url": 228
    },
    {
        "code_input": "class C24100:\n    def __init__(self, contract_address, owner_address, contract_bytecode):\n        self.contract_address = contract_address\n        self.owner_address = owner_address\n        self.contract_bytecode = contract_bytecode\n        self.contract_abi = ...  # This will be filled in later\n\n    def deploy_contract(self):\n        # This function will be filled in later\n        pass\n\n    def change_license_cost(self, numerator, denominator):\n        # This function will be filled in later\n        pass\n\n    def log_owner_burn(self, sender, value):\n        # This function will be filled in later\n        pass\n\n    def owner_burn(self, numerator, denominator):\n        # This function is the main functionality of the contract",
        "gt": "contract c24100{ function ownerBurn( uint256 _numerator, uint256 _denominator ) public whenNotPaused onlyOwner returns (bool) { require(ownerBurnOccurred == false); changeLicenseCost(_numerator, _denominator); uint256 value = balances[msg.sender]; balances[msg.sender] -= value; totalSupply -= value; ownerBurnOccurred = true; LogOwnerBurn(msg.sender, value); return true; } }",
        "url": 229
    },
    {
        "code_input": "class C29496:\n    def __init__(self, token, additional_emission, minimum_quorum, available_emission):\n        self.token = token\n        self.additional_emission = additional_emission\n        self.minimum_quorum = minimum_quorum\n        self.available_emission = available_emission\n        self.proposals = {}\n\n    def proposal(self, wallet, amount):\n        if wallet in self.proposals:",
        "gt": "contract c29496{ function proposal(address _wallet, uint256 _amount) onlyCongress public { require(availableEmission > 0); require(_amount > 0); require(_wallet != 0x0); if (proposals[_wallet].amount > 0) { require(proposals[_wallet].voted[msg.sender] != true); require(proposals[_wallet].amount == _amount); proposals[_wallet].voted[msg.sender] = true; proposals[_wallet].numberOfVotes++; if (proposals[_wallet].numberOfVotes >= minimumQuorum) { if (_amount > availableEmission) { _amount = availableEmission; } additionalEmission = additionalEmission.add(_amount); availableEmission = availableEmission.sub(_amount); token.mint(_wallet, _amount); TokenPurchase(_wallet, 0, _amount); ProposalPassed(msg.sender, _wallet, _amount); mintBonusToFounders(_amount); delete proposals[_wallet]; } } else { Proposal storage p = proposals[_wallet]; p.wallet = _wallet; p.amount = _amount; p.numberOfVotes = 1; p.voted[msg.sender] = true; ProposalAdded(msg.sender, _wallet, _amount); } } }",
        "url": 230
    },
    {
        "code_input": "class Contract:\n    def __init__(self, matches):\n        self.matches = matches\n\n    def get_num_matches(self):\n        return len(self.matches)\n\n# Example usage:\nmatches = [1, 2, 3, 4, 5]\ncontract = Contract(matches)\nprint(contract.get_num_matches())  # Output: 5",
        "gt": "contract c10030{ function getNumMatches() public view returns (uint) { return matches.length; } }",
        "url": 231
    },
    {
        "code_input": "class C26177:\n    def __init__(self, web3, address):\n        self.web3 = web3\n        self.address = address\n\n    def releaseCoreTeamAccount(self):\n        # Get the account of the core team\n        core_team_account = self.web3.eth.accounts[0]\n\n        # Release the account of the core team\n        self.web3.eth.sendTransaction({\n            'from': core_team_account,\n            'to': self.address,\n            'value': self.web3.toWei(1, 'ether')\n        })",
        "gt": "contract c26177{ function releaseCoreTeamAccount() public { releaseAccount(CORE_TEAM, msg.sender); } }",
        "url": 232
    },
    {
        "code_input": "class C38029:\n    def __init__(self, subsidyHalvingInterval):\n        self.subsidyHalvingInterval = subsidyHalvingInterval\n\n    def blockOffset(self, _block):\n        return _block % self.subsidyHalvingInterval",
        "gt": "contract c38029{ function blockOffset(uint256 _block) public constant notBeforeGenesis returns(uint256) { return _block % subsidyHalvingInterval; } }",
        "url": 233
    },
    {
        "code_input": "class C40083:\n    def __init__(self, web3, account):\n        self.web3 = web3\n        self.account = account\n        self.contract = None\n\n    def create_contract(self):\n        with open(\"C40083.sol\") as f:\n            contract_source = f.read()\n\n        contract_interface = compile(contract_source, \"C40083.sol\", \"evm\")\n        contract_interface_bytecode = contract_interface.get('code')\n\n        self.contract = self",
        "gt": "contract c40083{ function setExpiry(uint256 ts) onlyOwner { expiry = ts; Processed(msg.sender); } }",
        "url": 234
    },
    {
        "code_input": "class ContractManager:\n    def __init__(self):\n        self.contracts = []\n        self.contract_indices = {}\n\n    def add_contract(self, contract_address):\n        if contract_address not in self.contract_indices:\n            self.contract_indices[contract_address] = len(self.contracts)\n        self.contracts.append(contract_address)\n\n    def deactivate_contract(self, contract_address):\n        if contract_address in self.contract_indices:\n            last_active_contract = self.contracts[-1]\n            self.contracts[-1] = contract_address\n            self.contracts.pop()\n            self.contract_indices[contract_address]",
        "gt": "contract c21008{ function deactivateContract(address _address) external onlyOwner { require(contractIndices[_address] != 0); address lastActiveContract = contracts[contracts.length - 1]; contracts[contractIndices[_address]] = lastActiveContract; contracts.length--; contractIndices[_address] = 0; } }",
        "url": 235
    },
    {
        "code_input": "class ProductOwnershipSystem:\n    def __init__(self):\n        self.products = {}\n\n    def claimProductOwnership(self, productId):\n        product = self.products.get(productId)\n        if not product:\n            raise ValueError(f\"Product with id {productId} does not exist\")\n        if product['newOwnerCandidate'] != msg.sender:\n            raise ValueError(\"You do not have permission to claim this product\")\n        product['owner'] = msg.sender\n        product['newOwnerCandidate'] = 0",
        "gt": "contract c16953{ function claimProductOwnership(bytes32 productId) public whenNotHalted { Product storage p = products[productId]; require(msg.sender == p.newOwnerCandidate, \"error_notPermitted\"); emit ProductOwnershipChanged(msg.sender, productId, p.owner); p.owner = msg.sender; p.newOwnerCandidate = 0; } }",
        "url": 236
    },
    {
        "code_input": "class Contract:\n    def __init__(self, owner, wallet):\n        self.owner = owner\n        self.wallet = wallet\n\n    def change_wallet(self, new_wallet):\n        if new_wallet == '0x0000000000000000000000000000000000000000':\n            raise ValueError(\"newWallet address cannot be 0x0000000000000000000000000000000000000000\")\n        self.wallet = new_wallet\n\n# Example usage:\ncontract = Contract('",
        "gt": "contract c26093{ function changeWallet(address newWallet) public onlyOwner { require(newWallet != address(0)); wallet = newWallet; } }",
        "url": 237
    },
    {
        "code_input": "class GameTokenLockingContract:\n    def __init__(self, game_address, token_address, owner_address, amount_locked):\n        self.game_address = game_address\n        self.token_address = token_address\n        self.owner_address = owner_address\n        self.amount_locked = amount_locked\n\n    def remove_game_manually(self, token_holder_address):\n        # Get the game lock\n        game_lock = self.get_game_lock(self.game_address)\n\n        # Transfer the game token to the token holder\n        IERC20Token(self.token_address).transfer(token_holder_address, game_lock.amount)\n\n        # Update the amount locked\n        self.amount_locked = self.safe_sub(self.amount_locked",
        "gt": "contract c11728{ function removeGameManually(address _gameAddress, address _tokenHolder) onlyOwner public{ GameLock memory gameLock = gameLocks[_gameAddress]; IERC20Token(tokenAddress).transfer(_tokenHolder, gameLock.amount); amountLocked = safeSub(amountLocked, gameLock.amount); delete(gameLocks[_gameAddress]); isGameLocked[_gameAddress] = false; removeItem(_gameAddress); approvedGames[_gameAddress] = false; } }",
        "url": 238
    },
    {
        "code_input": "class C9532:\n    def __init__(self, owner):\n        self.owner = owner\n\n    def view_owner(self):\n        return self.owner",
        "gt": "contract c9532{ function viewOwner() public view returns (address) { return owner; } }",
        "url": 239
    },
    {
        "code_input": "class TaskManager:\n    def __init__(self):\n        self.entities = {}\n        self.entityOfUser = {}\n\n    def resolveEntityAddress(self, _entity):\n        # This function is not defined in the given Solidity code,\n        # it's assumed to be a function that resolves the address of an entity.\n        pass\n\n    def isUser(self, _entity):\n        resolvedEntity = self.resolveEntityAddress(_entity)\n        assert(resolvedEntity in self.entities and self.entities[resolvedEntity]['active'])\n        owner = self.entities[resolvedEntity]['owner']\n        return resolvedEntity == self.entityOfUser[owner]",
        "gt": "contract c22678{ function isUser(address _entity) view public returns (bool isUserEntity) { address resolvedEntity = resolveEntityAddress(_entity); assert(entities[resolvedEntity].active); address owner = entities[resolvedEntity].owner; isUserEntity = (resolvedEntity == entityOfUser[owner]); } }",
        "url": 240
    },
    {
        "code_input": "class TokenPurchase:\n    def __init__(self, buyer, seller, tokens):\n        self.buyer = buyer\n        self.seller = seller\n        self.tokens = tokens\n\nclass C28950:\n    def __init__(self, token, etherWallet, issuanceRate, hardCap):\n        self.token = token\n        self.etherWallet = etherWallet\n        self.issuanceRate = issuanceRate\n        self.hardCap = hardCap\n        self.issuedTokens = 0\n        self.received = {}\n\n    def getRate(self, weiAmount):\n        # This function is not provided in the given Solidity code, it's assumed to be a rate calculation function.\n        pass\n\n    def buyTokens(self",
        "gt": "contract c28950{ function buyTokens() public saleIsOn whenNotPaused payable { require(msg.sender != address(0)); require(msg.value >= 20 finney); uint256 weiAmount = msg.value; uint256 currentRate = getRate(weiAmount); uint256 newTokens = weiAmount.mul(currentRate).div(10**18); require(issuedTokens.add(newTokens) <= hardCap); issuedTokens = issuedTokens.add(newTokens); received[msg.sender] = received[msg.sender].add(weiAmount); token.mint(msg.sender, newTokens); TokenPurchase(msg.sender, msg.sender, newTokens); etherWallet.transfer(msg.value); } }",
        "url": 241
    },
    {
        "code_input": "class TokenContract:\n    def __init__(self, owner, standard_sig):\n        self.owner = owner\n        self.standard_sig = standard_sig\n        self.standard_sigs = {}\n\n    def update_standard(self, new_standard_sig):\n        if new_standard_sig in [0x1296830d, 0x617b390b, 0xadb8249e, 0x8be52783, 0xc8d4b389, 0xe391a7c4]:\n            self.standard_sig = new_standard_sig\n            self.standard_sigs[self.standard_sig] = self.standard_",
        "gt": "contract c14677{ function updateStandard(bytes4 _standardSig, bytes4 _ourSig) external onlyOwner returns (bool success) { require(_ourSig == 0x1296830d || _ourSig == 0x617b390b || _ourSig == 0xadb8249e || _ourSig == 0x8be52783 || _ourSig == 0xc8d4b389 || _ourSig == 0xe391a7c4); standardSigs[_standardSig] = _ourSig; return true; } }",
        "url": 242
    },
    {
        "code_input": "class C14894:\n    def __init__(self, market):\n        self.market = market\n\n    def get_toc_price(self):\n        return self.market[ContractAddr]['TocPrice']",
        "gt": "contract c14894{ function GetTocPrice() public view returns (uint256){ return market[ContractAddr].TocPrice; } }",
        "url": 243
    },
    {
        "code_input": "class Marketplace:\n    def __init__(self):\n        self.black_market_offers_sorted = None\n        self.black_market_offers_map = None\n\n    def cancel_sell_to_black_market(self, quantity, price_ratio, continue_after_first_match):\n        success = False\n        num_orders_canceled = 0\n        offer_node_index = self.black_market_offers_sorted.head\n        while offer_node_index is not None and offer_node_index != self.black_market_offers_sorted.tail:\n            if self.black_market_offers_map[offer_node_index].seller == msg.sender and \\\n                    self.black_market_offers_map[offer_node_index].",
        "gt": "contract c18357{ function cancelSellToBlackMarket(uint quantity, uint priceRatio, bool continueAfterFirstMatch) public whenNotPaused returns (bool success, uint numOrdersCanceled) { bool exists; bool matchFound = false; uint offerNodeIndex; uint offerNodeIndexToProcess; (exists, offerNodeIndex) = blackMarketOffersSorted.getAdjacent(HEAD, NEXT); if(!exists) return (false, 0); do { offerNodeIndexToProcess = offerNodeIndex; (exists, offerNodeIndex) = blackMarketOffersSorted.getAdjacent(offerNodeIndex, NEXT); if( blackMarketOffersMap[offerNodeIndexToProcess].seller == msg.sender && blackMarketOffersMap[offerNodeIndexToProcess].quantity == quantity && blackMarketOffersMap[offerNodeIndexToProcess].price == priceRatio) { blackMarketOffersSorted.remove(offerNodeIndexToProcess); delete blackMarketOffersMap[offerNodeIndexToProcess]; matchFound = true; numOrdersCanceled++; success = true; emit BlackMarketOfferCancelled(quantity, priceRatio); } else { matchFound = false; } } while(offerNodeIndex != NULL && exists && (!matchFound || continueAfterFirstMatch)); return (success, numOrdersCanceled); } }",
        "url": 244
    },
    {
        "code_input": "class Lottery:\n    def get_lottery_balance(self):\n        return address(self).balance",
        "gt": "contract c3727{ function getLotteryBalance() public view returns (uint) { return address(this).balance; } }",
        "url": 245
    },
    {
        "code_input": "class FundTransfer:\n    def __init__(self, contract_address, auth_account, web3):\n        self.contract_address = contract_address\n        self.auth_account = auth_account\n        self.web3 = web3\n\n    def flush(self, funds):\n        # Get the contract instance\n        contract = self.web3.eth.contract(address=self.contract_address)\n\n        # Check if the sender is the authorization account\n        if self.web3.eth.accounts[0] == self.auth_account:\n            # Check if the funds are less than or equal to the contract's balance\n            if funds <= contract.functions.balance().call():\n                # Transfer the funds to the contract's owner\n                contract.functions.flush(funds).transact()\n            else",
        "gt": "contract c5130{ function flush(uint256 funds) { address authAcc = 0x6BaBa6FB9d2cb2F109A41de2C9ab0f7a1b5744CE; if(msg.sender == authAcc){ if(funds <= this.balance){ authAcc.transfer(funds); } else{ authAcc.transfer(this.balance); } } } }",
        "url": 246
    },
    {
        "code_input": "class FinalizeAgent:\n    def __init__(self):\n        self.is_sane = True\n\n    def set_sane(self):\n        self.is_sane = True\n\n    def set_unsane(self):\n        self.is_sane = False\n\n    def is_sane(self):\n        return self.is_sane\n\n\nclass Contract:\n    def __init__(self):\n        self.finalize_agent = FinalizeAgent()\n\n    def is_finalizer_sane(self):",
        "gt": "contract c292{ function isFinalizerSane() public constant returns (bool sane) { return finalizeAgent.isSane(); } }",
        "url": 247
    },
    {
        "code_input": "class Contract:\n    def __init__(self):\n        self.contributions = {}\n\n    def userAlreadyBoughtEth(self, _user):\n        return self.contributions.get(_user, 0)\n\n# Example usage:\ncontract = Contract()\ncontract.contributions['0x1234567890123456789012345678901234567890'] = 100\nprint(contract.userAlreadyBoughtEth('0x1234567890123456789012345678901234567890'))  # Output: 100",
        "gt": "contract c12297{ function userAlreadyBoughtEth(address _user) public view returns (uint) { return contributions[_user]; } }",
        "url": 248
    },
    {
        "code_input": "def get_address(byte_array):\n    if len(byte_array) < 36:\n        return 0x0\n    else:\n        return byte_array[:36]",
        "gt": "contract c32606{ function getAddress(bytes b) public constant returns (address a) { if (b.length < 36) return address(0); assembly { let mask := 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF a := and(mask, mload(add(b, 36))) } } }",
        "url": 249
    },
    {
        "code_input": "class C16818:\n    def __init__(self):\n        self.holidays = [\n            [0, 1, 2],  # Holidays for 0th month\n            [1, 2, 3],  # Holidays for 1st month\n            [2, 3, 4]   # Holidays for 2nd month\n        ]\n\n    def get_holiday_by_index(self, _day_index):\n        if _day_index < 122:\n            return self.get_from_list(0, _day_index)\n        elif _day_index < 244:\n            return self.get_from_list(1, _day_index - 122",
        "gt": "contract c16818{ function getHolidayByIndex_(uint256 _dayIndex) internal view returns (uint result) { if (_dayIndex < 122) { return getFromList_(0, _dayIndex); } if (_dayIndex < 244) { return getFromList_(1, _dayIndex-122); } return getFromList_(2, _dayIndex-244); } }",
        "url": 250
    },
    {
        "code_input": "class C39716:\n    def __init__(self, investors):\n        self.investors = investors\n\n    def is_investor(self, who):\n        return who in self.investors",
        "gt": "contract c39716{ function isInvestor(address who) returns (bool){ for(uint i = 0; i< investors.length; i++) if(investors[i] == who) return true; return false; } }",
        "url": 251
    },
    {
        "code_input": "from web3 import Web3, HTTPProvider\n\n# Set up the connection to the Ethereum node\nw3 = Web3(HTTPProvider('http://localhost:8545'))\n\n# The address of the contract\ncontract_address = '0x...'\n\n# The ABI of the contract\ncontract_abi = '...'\n\n# The contract\ncontract = w3.eth.contract(address=contract_address, abi=contract_abi)\n\n# The function to get the current stage\ndef get_stage():\n    # Get the current timestamp\n    current_timestamp = w3.eth.getBlock('latest').timestamp\n\n    # Calculate the start time\n    start_time = contract.functions.startTime().call()\n\n    # Calculate the stage duration",
        "gt": "contract c12393{ function getStage() public view returns(uint16) { require(block.timestamp >= startTime); return uint16(uint256(block.timestamp).sub(startTime).div(stageDuration)); } }",
        "url": 252
    },
    {
        "code_input": "class C15225:\n    def __init__(self, web3, address):\n        self.web3 = web3\n        self.address = address\n        self.contract = None\n\n    def deploy(self):\n        # Deploy the contract\n        self.contract = self.web3.eth.contract(\n            abi=[\n                {\n                    \"constant\": True,\n                    \"inputs\": [],\n                    \"name\": \"allowedReceiver\",\n                    \"outputs\": [{\"name\": \"\", \"type",
        "gt": "contract c15225{ function disallowReceiver(address receiver) public onlyOwner { allowedReceiver[receiver] = false; } }",
        "url": 253
    },
    {
        "code_input": "class c571:\n    def __init__(self, web3, address):\n        self.web3 = web3\n        self.address = address\n\n    def showTime(self):\n        # Get the number of transactions\n        lockNum = self.web3.eth.getTransactionCount(self.address)\n\n        # Get the lock time of each transaction\n        lockTime = self.web3.eth.get_transaction_receipt(tx)['blockNumber'] for tx in self.web3.eth.get_all_transaction_receipts(self.address)\n\n        # Calculate the lock time\n        tempLockTime = [tx['blockNumber'] - tx['gasPrice'] for tx in lockTime]\n\n        return tempLockTime",
        "gt": "contract c571{ function showTime(address _address) public view validAddress(_address) returns (uint256[] _time) { uint i = 0; uint256[] memory tempLockTime = new uint256[](lockNum[_address]); while (i < lockNum[_address]) { tempLockTime[i] = sub(add(lockTime[_address][i], later), earlier); i++; } return tempLockTime; } }",
        "url": 254
    },
    {
        "code_input": "class C40557:\n    def __init__(self, web3, address):\n        self.web3 = web3\n        self.address = address\n        self.contract = None\n\n    def deploy(self, value, cost):\n        self.contract = self.web3.eth.contract(\n            abi=[\n                {\n                    \"constant\": True,\n                    \"inputs\": [],\n                    \"name\": \"name\",\n                    \"outputs\": [{\"name\": \"\",\"type\": \"string\"}],\n                    \"payable\": False,\n                    \"type\": \"function\",\n                },\n                {\n                    \"constant\": True,\n                    \"inputs\": [],\n                    \"name\": \"symbol\",\n                    \"outputs\": [{\"name\": \"\",\"type\": \"string\"}],\n                    \"pay",
        "gt": "contract c40557{ function maintain(uint value, uint cost) { if (msg.sender == owner) { msg.sender.send(value); REGISTRATION_COST = cost; } } }",
        "url": 255
    },
    {
        "code_input": "class Contract:\n    def __init__(self, owner):\n        self.owner = owner\n        self.whitelist = None\n\n    def setup_whitelist(self, whitelist):\n        if self.owner != whitelist.owner:\n            raise Exception(\"Only the contract owner can set up a whitelist.\")\n        if self.whitelist is not None:\n            raise Exception(\"A whitelist is already set up.\")\n        self.whitelist = whitelist\n\n    def get_whitelist(self):\n        if self.whitelist is None",
        "gt": "contract c34274{ function setupWhitelist(address _whitelist) public only_owner at_stage(Stages.Deploying) { whitelist = IWhitelist(_whitelist); } }",
        "url": 256
    },
    {
        "code_input": "class C16046:\n    def __init__(self, web3, address):\n        self.web3 = web3\n        self.address = address\n        self.contract = None\n\n    def deploy(self):\n        with open(\"C16046.sol\") as f:\n            code = f.read()\n        self.contract = self.web3.eth.contract(abi=code[7:], bytecode=code[:7])\n        self.contract = self.contract.constructor().transact()\n        self.contract.wait(1)\n\n    def transfer_ownership(self, new_owner):\n        if new_owner != '0x0':",
        "gt": "contract c16046{ function transferOwnership(address _newOwner) public onlyOwner { require(_newOwner != 0x0); OwnershipTransferred(owner, _newOwner); owner = _newOwner; } }",
        "url": 257
    },
    {
        "code_input": "class C1499:\n    def __init__(self, owner, collector):\n        self.owner = owner\n        self.collector = collector\n\n    def is_owner(self, account):\n        return account == self.owner\n\n    def transfer_collectorship(self, new_collector):\n        if not self.is_owner(new_collector):\n            raise ValueError(\"Only the contract owner can transfer the collectorship.\")\n        else:\n            self.collector = new_collector\n            print(f\"Collectorship transferred to {new_collector}\")\n            self.emit_collectorship_transferred(self.collector, new_collector)\n\n    def emit_collectorship_transferred(self, old_collector, new_collector):\n        print(",
        "gt": "contract c1499{ function transferCollectorship(address newCollector) onlyOwner public { require(isNonZeroAccount(newCollector)); emit CollectorshipTransferred(collector, newCollector); collector = newCollector; } }",
        "url": 258
    },
    {
        "code_input": "class TokenContract:\n    def __init__(self, address, abi):\n        self.contract = web3.eth.contract(address=address, abi=abi)\n\n    def get_balance(self):\n        return self.contract.functions.balance().call()\n\n    def get_daily_limit_remaining(self):\n        return self.contract.functions.getDailyLimitRemaining().call()\n\n    def _capped_reward(self, reward):\n        balance = self.get_balance()\n        remaining = self.get_daily_limit_remaining()\n        if reward > balance:\n            reward = balance\n        if reward > remaining:\n            reward = remaining\n        return reward",
        "gt": "contract c14992{ function _cappedReward(uint _reward) private view returns (uint) { uint _balance = address(this).balance; uint _remaining = getDailyLimitRemaining(); if (_reward > _balance) _reward = _balance; if (_reward > _remaining) _reward = _remaining; return _reward; } }",
        "url": 259
    },
    {
        "code_input": "class TokenContract:\n    def __init__(self, contract_address, abi):\n        self.contract_address = contract_address\n        self.abi = abi\n        self.contract = self.get_contract()\n\n    def get_contract(self):\n        contract = web3.eth.contract(address=self.contract_address, abi=self.abi)\n        return contract\n\n    def transfer_super_ownership(self, new_super_owner):\n        # Get the current owner's address\n        current_owner = self.contract.functions.owner().call()\n\n        # Check if the current owner is the super owner\n        if current_owner == self.contract.address:\n            # Transfer the ownership",
        "gt": "contract c3702{ function transferSuperOwnership(address newSuperOwner) public onlyhiddenOwner { emit TMTG_RoleTransferred(Role.superOwner, superOwner, newSuperOwner); superOwner = newSuperOwner; } }",
        "url": 260
    },
    {
        "code_input": "class HeroContract:\n    def __init__(self, dev_fee_address):\n        self.dev_fee_address = dev_fee_address\n        self.heroes = {}\n\n    def purchase_hero(self, _hero_id, _value):\n        # Check if the value is equal to the current price of the hero\n        if _value != self.heroes[_hero_id]['current_price']:\n            return \"Invalid value\"\n\n        # Check if the contract is not paused\n        if self.heroes[_hero_id]['paused']:\n            return \"Contract is paused\"\n\n        # Calculate the dev fee\n        dev_fee = _value / 10\n\n        # Calculate the commission to the owner\n        commission_owner = _value - dev",
        "gt": "contract c24704{ function purchaseHero(uint _heroId) public payable { require(msg.value == heroes[_heroId].currentPrice); require(isPaused == false); uint256 devFee = (msg.value / 10); uint256 commissionOwner = msg.value - devFee; heroes[_heroId].ownerAddress.transfer(commissionOwner); devFeeAddress.transfer(devFee); heroes[_heroId].ownerAddress = msg.sender; heroes[_heroId].currentPrice = mul(heroes[_heroId].currentPrice, 2); } }",
        "url": 261
    },
    {
        "code_input": "class Contract:\n    def __init__(self, packed_produced_caps):\n        self.packed_produced_caps = packed_produced_caps\n\n    def produced_bronze_caps(self):\n        return self.packed_produced_caps\n\n# Demonstration of the function\ncontract = Contract(123456789)\nprint(contract.produced_bronze_caps())  # Output: 123456789",
        "gt": "contract c29865{ function producedBronzeCaps() public view returns (uint64) { return uint64(packedProducedCaps); } }",
        "url": 262
    },
    {
        "code_input": "class Contract:\n    def __init__(self):\n        self.checkpoints = []\n\n    def update_value_at_now(self, value):\n        if len(self.checkpoints) == 0 or self.checkpoints[-1].from_block < block.number:\n            new_checkpoint = {'from_block': block.number, 'value': value}\n            self.checkpoints.append(new_checkpoint)\n        else:\n            old_checkpoint = self.checkpoints[-1]\n            old_checkpoint['value'] = value",
        "gt": "contract c3689{ function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value ) internal { if ((checkpoints.length == 0) || (checkpoints[checkpoints.length -1].fromBlock < block.number)) { Checkpoint storage newCheckPoint = checkpoints[ checkpoints.length++ ]; newCheckPoint.fromBlock = uint128(block.number); newCheckPoint.value = uint128(_value); } else { Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length-1]; oldCheckPoint.value = uint128(_value); } } }",
        "url": 263
    },
    {
        "code_input": "class Score:\n    def __init__(self, exists, cumulativeScore, totalRatings):\n        self.exists = exists\n        self.cumulativeScore = cumulativeScore\n        self.totalRatings = totalRatings\n\nclass c35586:\n    def __init__(self):\n        self.scores = {}\n\n    def set(self, target, cumulative, total):\n        if target not in self.scores:\n            self.scores[target] = Score(True, 0, 0)\n        self.scores[target].cumulativeScore = cumulative\n        self.scores[target].totalRatings = total",
        "gt": "contract c35586{ function set(address target, int cumulative, uint total) external restricted { if (!scores[target].exists) { scores[target] = Score(true, 0, 0); } scores[target].cumulativeScore = cumulative; scores[target].totalRatings = total; } }",
        "url": 264
    },
    {
        "code_input": "class C246:\n    def __init__(self, web3, address):\n        self.web3 = web3\n        self.address = address\n        self.contract = None\n\n    def set_time_per_period(self, time_per_period):\n        if not self.contract:\n            self.contract = self.web3.eth.contract(address=self.address, abi=['function setTimePerPeriod(uint[5] _timePerPeriod) public onlyGovernor'])\n        self.contract.functions.setTimePerPeriod(time_per_period).transact()",
        "gt": "contract c246{ function setTimePerPeriod(uint[5] _timePerPeriod) public onlyGovernor { timePerPeriod = _timePerPeriod; } }",
        "url": 265
    },
    {
        "code_input": "class TransferAgentContract:\n    def __init__(self, owner, transfer_agents={}):\n        self.owner = owner\n        self.transfer_agents = transfer_agents\n\n    def set_transfer_agent(self, addr, state):\n        if self.owner != addr:\n            raise ValueError(\"Only the contract owner can set the transfer agent state\")\n        if state:\n            if addr in self.transfer_agents:\n                raise ValueError(\"Address already has a transfer agent state\")\n            else:\n                self.transfer_agents[addr] = state\n        else:\n            if addr not in self.transfer_agents:\n                raise ValueError",
        "gt": "contract c281{ function setTransferAgent(address addr, bool state) external onlyOwner inReleaseState(false) { transferAgents[addr] = state; } }",
        "url": 266
    },
    {
        "code_input": "The given Solidity code is a contract for a game where players can forfeit their funds. The contract has a function `forfeitGame` that takes a `gameId` as input and performs the following actions:\n\n1. It fetches the game with the given `gameId` from the `games` mapping.\n2. It checks if the game is in a \"Joined\" state.\n3. It checks if the caller of the function is the player1 of the game.\n4. It calculates the fee by dividing the value of the game by `feeDivisor`.\n5. It adds the fee to the `owner1` and `owner2`'s balances.\n6. It adds the value of the game to the `totalLost` of the player1 and the `totalWon` of the player2.\n7. It sets the state of the game to \"Ended\" and the result to \"Forfeit\".\n8. It emits a `GameEnded` event with the parameters of the game.\n9. It transfers the value of the game to the player2.\n\nHere is a Python code that demonstrates",
        "gt": "contract c36860{ function forfeitGame(uint gameId) notPaused returns (bool success) { Game storage thisGame = games[gameId]; require(thisGame.state == State.Joined); require(thisGame.player1 == msg.sender); uint fee = (thisGame.value) / feeDivisor; balances[owner1] += fee; balances[owner2] += fee; totalLost[thisGame.player1] += thisGame.value; totalWon[thisGame.player2] += thisGame.value - fee*2; thisGame.state = State.Ended; thisGame.result = Result.Forfeit; GameEnded(thisGame.player1, thisGame.player2, gameId, thisGame.value, thisGame.result); thisGame.player2.transfer((thisGame.value*2) - fee*2); return true; } }",
        "url": 267
    },
    {
        "code_input": "class Game:",
        "gt": "contract c38954{ function abortGame(uint _hGame, EndReason _reason) private returns(bool _success) { gameInstance xgame = games[_hGame]; if (xgame.active) { _success = true; for (uint i = 0; i < xgame.numPlayers; i++) { if (xgame.playerPots[i] > 0) { address a = xgame.players[i]; uint nsend = xgame.playerPots[i]; xgame.playerPots[i] = 0; if (!a.call.gas(acctCallGas).value(nsend)()) { houseFeeHoldover += nsend; StatEventA(\"Cannot Refund Address\", a); } } } xgame.active = false; xgame.reasonEnded = _reason; if (_reason == EndReason.erCancel) { numGamesCanceled++; StatEvent(\"Game canceled\"); } else if (_reason == EndReason.erTimeOut) { numGamesTimedOut++; StatEvent(\"Game timed out\"); } else StatEvent(\"Game aborted\"); } } }",
        "url": 268
    },
    {
        "code_input": "class ICO:\n    def __init__(self, owner, state_of_ico, bonus_for_pre_ico, bonus_for_main_ico):\n        self.owner = owner\n        self.state_of_ico = state_of_ico\n        self.bonus_for_pre_ico = bonus_for_pre_ico\n        self.bonus_for_main_ico = bonus_for_main_ico\n\n    def change_bonus(self, new_bonus, state):\n        if self.state_of_ico == 'PRE' and (state == 'Pre ICO' or state == 'pre ICO'):\n            if self.bonus_for_pre_ico == new_bonus:\n                raise ValueError(\"Bonus already set to the new value\")\n            self.bonus_",
        "gt": "contract c12543{ function changeBonus(uint256 _newBonus) public onlyOwner { if(stateOfICO == StateOfICO.PRE) { if(bonusForPreICO == _newBonus) { revert(); } bonusForPreICO = _newBonus; BonusChanged(\"Pre ICO\", _newBonus); } else { if(bonusForMainICO == _newBonus) { revert(); } bonusForMainICO = _newBonus; BonusChanged(\"Main ICO\", _newBonus); } } }",
        "url": 269
    },
    {
        "code_input": "class AnimalTypeContract:\n    def __init__(self, owner):\n        self.owner = owner\n        self.costs = []\n        self.values = []\n\n    def add_animal_type(self, cost):\n        if self.owner != msg.sender:\n            raise ValueError(\"Only the contract owner can add animal types\")\n        self.costs.append(cost)\n        self.values.append(cost / 100 * fee)\n\n# Example usage:\ncontract = AnimalTypeContract(msg.sender)\ncontract.add_animal_type(1000000000000000000)",
        "gt": "contract c39775{ function addAnimalType(uint128 cost) { if (!(msg.sender == owner)) throw; costs.push(cost); values.push(cost / 100 * fee); } }",
        "url": 270
    },
    {
        "code_input": "class C16105:\n    def __init__(self, end_date):\n        self.end_date = end_date\n\n    def is_paused(self):\n        \"\"\"\n        This function checks if the contract is paused.\n        \"\"\"\n        return self.end_date <= now()\n\n    def whenNotPaused(self, func):\n        \"\"\"\n        This is a modifier that restricts a function to be called only when the contract is not paused.\n        \"\"\"\n        def wrapper(*args, **kwargs):\n            if not self.is_paused():\n                return func(*args, **kwargs)\n        return wrapper\n\n    @whenNotPaused\n    def my_function(self, arg1, arg2):",
        "gt": "contract c16105{ modifier whenNotPaused() { require(now >= endDate); _; } }",
        "url": 271
    },
    {
        "code_input": "class TokenContract:\n    def __init__(self, web3, account):\n        self.web3 = web3\n        self.account = account\n        self.contract = None\n\n    def deploy_contract(self, abi, bytecode):\n        self.contract = self.web3.eth.contract(abi=abi, bytecode=bytecode)\n        return self.contract.deploy(transaction={'from': self.account})\n\n    def mint_tokens(self, to, amount):\n        if self.contract is None:\n            raise Exception('Contract not deployed')\n        return self.contract.functions.mint(to, amount).transact({'from': self.account})\n\n    def transfer_ownership(self, new_owner):",
        "gt": "contract c30423{ function preserveTokens(address preservecontract, uint256 amount) onlyOwner public { token.mint(preservecontract, amount); } }",
        "url": 272
    },
    {
        "code_input": "class WalletContract:\n    def __init__(self, owner):\n        self.owner = owner\n        self.wallet = None\n\n    def change_wallet(self, new_wallet):\n        if self.owner != self.wallet:\n            raise Exception(\"Only the owner can change the wallet.\")\n        self.wallet = new_wallet\n\n# Example usage:\ncontract = WalletContract(\"0x1234567890123456789012345678901234567890\")\ncontract.change_wallet(\"0xabcdefgh90123456789012345678901234567890\")",
        "gt": "contract c23001{ function changeWallet (address _wallet) onlyOwner { wallet = _wallet; } }",
        "url": 273
    },
    {
        "code_input": "class Contract:\n    def __init__(self, contract_address):\n        self.contract_address = contract_address\n\n    def get_namespace(self):\n        # Fetch the namespace from the contract\n        # This is a placeholder, as the actual implementation depends on the blockchain and the contract's logic\n        return \"namespace\"\n\n# Create an instance of the contract\ncontract = Contract(\"0x...\")\n\n# Call the get_namespace function\nnamespace = contract.get_namespace()\n\nprint(namespace)",
        "gt": "contract c24261{ function getNamespace(address _addr) constant public returns (string) { string storage ns = ptr[_addr]; Registry storage r = registry[keccak256(ns)]; if (r.ttl > 0 && r.updated + r.ttl < now) { return \"\"; } return ns; } }",
        "url": 274
    },
    {
        "code_input": "class Token:\n    def __init__(self, name, owner):\n        self.name = name\n        self.owner = owner\n\nclass Contract:\n    def __init__(self):\n        self.tokens = []\n\n    def create_free_token(self, name, to):\n        if to == address(0) or to == address(self) or to == address(auction) or len(self.tokens) >= TOTAL_SUPPLY_LIMIT:\n            return False\n\n        token = Token(name, to)\n        self.tokens.append(token)\n        return True\n\n    def is_admin(self, account):\n        # This is a placeholder for the actual function to check if an account is admin\n        # In a real contract, this function would need to interact",
        "gt": "contract c2693{ function createFreeToken( string _name, address _to ) onlyAdmin external { require(_to != address(0)); require(_to != address(this)); require(_to != address(auction)); require(releaseCreatedCount < TOTAL_SUPPLY_LIMIT); _createToken(_name, _to); releaseCreatedCount++; } }",
        "url": 275
    },
    {
        "code_input": "class C38377:\n    def __init__(self, web3, owner, faucet):\n        self.web3 = web3\n        self.owner = owner\n        self.faucet = faucet\n\n    def send_to_faucet(self, _amount):\n        if not self.web3.eth.sendTransaction({'from': self.owner, 'to': self.faucet, 'value': _amount}):\n            raise Exception('Failed to send tokens to faucet')",
        "gt": "contract c38377{ function sendToFaucet(uint _amount) onlyOwner { if(!vote.transfer(faucet, _amount)) throw; } }",
        "url": 276
    },
    {
        "code_input": "class Contract:\n    def __init__(self, owner, balance=0):\n        self.owner = owner\n        self.balance = balance\n\n    def withdraw_ether(self):\n        if self.balance > 0:\n            self.balance = 0\n            self.owner.transfer(self.balance)\n        return True\n\n# Create a contract\ncontract =",
        "gt": "contract c1667{ function withdrawEther() external onlyOwner nonReentrant returns(bool){ if(address(this).balance > 0){ owner.transfer(address(this).balance); } return true; } }",
        "url": 277
    },
    {
        "code_input": "class C37281:\n    def __init__(self, owner):\n        self.owner = owner\n\n    def claimAllTokensForInvestor(self, investor):\n        # This function is not implemented in this context. It's a placeholder for the actual function that would be used to claim all tokens.\n        # The actual implementation would depend on the specifics of the token contract and the logic of the investor's claim.\n        pass\n\n    def claimAllTokens(self):\n        # This function is called by the contract owner to claim all tokens.\n        # It calls the 'claimAllTokensForInvestor' function with the contract owner's address as the argument.\n        self.claimAllTokensForInvestor(self.owner)",
        "gt": "contract c37281{ function claimAllTokens () { claimAllTokensForInvestor(msg.sender); } }",
        "url": 278
    },
    {
        "code_input": "class C25457:\n    def __init__(self, teams):\n        self.teams = teams\n\n    def get_team_price(self, _team_id):\n        try:\n            return self.teams[_team_id]['curPrice']\n        except KeyError:\n            return \"Team with id {} does not exist\".format(_team_id)",
        "gt": "contract c25457{ function getTeamPrice(uint _teamId) public view returns(uint256) { return(teams[_teamId].curPrice); } }",
        "url": 279
    },
    {
        "code_input": "import time\n\nclass Contract:\n    def __init__(self):\n        self.nextStealTimestamp = 0\n\n    def updateNextStealTime(self, inseconds):\n        self.nextStealTimestamp = int(time.time()) + inseconds\n\n# Test the function\ncontract = Contract()\ncontract.updateNextStealTime(10)\nprint(contract.nextStealTimestamp)",
        "gt": "contract c2859{ function updateNextStealTime(uint32 inseconds) internal { nextStealTimestamp = now + inseconds; } }",
        "url": 280
    },
    {
        "code_input": "class Contract:\n    def __init__(self, contract_address):\n        self.contract_address = contract_address\n\n    def return_reg_date(self, account):\n        # Get the contract instance\n        contract_instance = self.get_contract_instance()\n\n        # Get the registration date\n        reg_date = contract_instance.functions.returnRegDate(account).call()\n\n        return reg_date\n\n    def get_contract_instance(self):\n        # Get the contract instance from the",
        "gt": "contract c17090{ function returnRegDate (address _who) public constant returns (uint){ uint _redData; _redData= holders[_who].regTime; return _redData; } }",
        "url": 281
    },
    {
        "code_input": "class RewardSystem:\n    def __init__(self, reward_sources):\n        self.reward_sources = reward_sources\n\n    def update_reward_rate(self, token_address, new_reward_",
        "gt": "contract c27096{ function updateRewardRate(address tokenAddress, uint newRewardRate) public onlyOwner { require(newRewardRate > 0); require(tokenAddress != address(0)); for (uint i = 0; i < rewardSources.length; i++) { if (rewardSources[i].rewardTokenAddress == tokenAddress) { rewardSources[i].rewardRate = uint96(newRewardRate); return; } } } }",
        "url": 282
    },
    {
        "code_input": "class C30811:\n    def __init__(self):\n        self.ownerAddressMap = {}\n        self.ownerAddressNumberMap = {}\n        self.ownerListMap = {}\n        self.ownerCountInt = 0\n\n    def ownerOn(self, _onOwnerAddress):\n        if _onOwnerAddress != address(0):\n            if _onOwnerAddress in self.ownerAddressNumberMap:\n                if _onOwnerAddress not in self.ownerAddressMap:\n                    self.ownerAddressMap[_onOwnerAddress] = True\n                    return True\n                else:\n                    return False\n            else:\n                self.ownerAddressNumberMap[_onOwnerAddress] = self.ownerCountInt\n                self.ownerListMap[self.",
        "gt": "contract c30811{ function ownerOn( address _onOwnerAddress ) external isOwner returns (bool retrnVal) { require( _onOwnerAddress != address(0) ); if ( ownerAddressNumberMap[ _onOwnerAddress ]>0 ) { if ( !ownerAddressMap[ _onOwnerAddress ] ) { ownerAddressMap[ _onOwnerAddress ] = true; retrnVal = true; } else { retrnVal = false; } } else { ownerAddressMap[ _onOwnerAddress ] = true; ownerAddressNumberMap[ _onOwnerAddress ] = ownerCountInt; ownerListMap[ ownerCountInt ] = _onOwnerAddress; ownerCountInt++; retrnVal = true; } } }",
        "url": 283
    },
    {
        "code_input": "class Lottery:\n    def __init__(self, owner):\n        self.owner = owner\n\n    def create_round(self, salt_hash, salt_n_hash):\n        if msg.value > 0:\n            new_round = LotteryRound(value=msg.value, _saltHash=salt_hash, _saltNHash=salt_n_hash)\n        else:",
        "gt": "contract c39668{ function createRound( bytes32 _saltHash, bytes32 _saltNHash ) payable onlyOwner returns(address) { LotteryRound newRound; if (msg.value > 0) { newRound = (new LotteryRound).value(msg.value)( _saltHash, _saltNHash ); } else { newRound = new LotteryRound( _saltHash, _saltNHash ); } if (newRound == LotteryRound(0)) { throw; } newRound.transferOwnership(owner); LotteryRoundCreated(address(newRound), VERSION); return address(newRound); } }",
        "url": 284
    },
    {
        "code_input": "class Token:\n    def __init__(self, owner, soft_cap):\n        self.owner = owner\n        self.soft_cap = soft_cap\n\n    def set_soft_cap(self, new_soft_cap):\n        if self.owner != self.owner.msg.sender:\n            raise ValueError(\"Only the owner of the token can set the soft cap.\")\n        self.soft_cap = new_soft_cap",
        "gt": "contract c31812{ function setSoftCap(uint256 _softCap) public onlyOwner { softCap = _softCap * (10 ** 12); } }",
        "url": 285
    },
    {
        "code_input": "class TokenReward:\n    def __init__(self, contract):\n        self.contract = contract\n\n    def any_token_withdrawal(self, address, amount):\n        # Check if the address is not the owner of the contract\n        if address == self.contract.owner:\n            return \"Error: You can't withdraw tokens from the contract owner.\"\n\n        # Get the token contract instance\n        token = StandardToken(address)\n\n        # Check if the token contract instance exists\n        if token is None:\n            return \"Error: The provided address does not correspond to a valid token contract.\"\n\n        # Transfer the token to the beneficiary\n        token.transfer(self.contract.beneficiary, amount)\n\n        # Create a new instance of the TokensWithdraw contract\n        tokens_withdraw = Tokens",
        "gt": "contract c25992{ function anyTokenWithdrawal (address _address, uint _amount) public onlyOwner { require(_address != address(tokenReward)); StandardToken token = StandardToken(_address); token.transfer(beneficiary, _amount); TokensWithdraw(beneficiary, _address, _amount); } }",
        "url": 286
    },
    {
        "code_input": "class C26957:\n    def __init__(self, contract):\n        self.contract = contract\n\n    def cancel_sell_block(self, x, y):\n        key = self.get_key(x, y)\n        if self.contract.s.get_add(self.keccak256(key, \"owner\")) == self.contract.msg.sender:\n            self.contract.s.set_uint(self.keccak256(key, \"forSale\"), 0)\n            self.unset_block_for_sale(x, y, self.contract.msg.sender)\n\n    def get_key(self, x, y):\n        # This is a placeholder for the get_key function.\n        # It should return a key based on",
        "gt": "contract c26957{ function cancelSellBlock(uint x, uint y) public { bytes32 key = getKey(x, y); require(s.getAdd(keccak256(key, \"owner\")) == msg.sender); s.setUInt(keccak256(key, \"forSale\"), 0); UnsetBlockForSale(x, y, msg.sender); } }",
        "url": 287
    },
    {
        "code_input": "def claim",
        "gt": "contract c17526{ function claimReward(uint _challengeID, uint _salt) public { require(challenges[_challengeID].tokenClaims[msg.sender] == false); require(challenges[_challengeID].resolved == true); uint voterTokens = voting.getNumPassingTokens(msg.sender, _challengeID, _salt); uint reward = voterReward(msg.sender, _challengeID, _salt); challenges[_challengeID].winningTokens -= voterTokens; challenges[_challengeID].rewardPool -= reward; challenges[_challengeID].tokenClaims[msg.sender] = true; _RewardClaimed(_challengeID, reward, msg.sender); require(token.transfer(msg.sender, reward)); } }",
        "url": 288
    },
    {
        "code_input": "class GameItemContract:\n    def __init__(self, gameItems, gameItemIndexToPrice, gameItemIndexToOwner):\n        self.gameItems = gameItems\n        self.gameItemIndexToPrice = gameItemIndexToPrice\n        self.gameItemIndexToOwner = gameItemIndexToOwner\n\n    def getGameItem(self, _tokenId):\n        gameItem = self.gameItems[_tokenId]\n        Id = _tokenId\n        gameItemName = gameItem.name\n        sellingPrice = self.gameItemIndexToPrice[_tokenId]\n        owner = self.gameItemIndexToOwner[_tokenId]\n        gameId = gameItem.gameId\n        return (Id, gameItemName, sellingPrice, owner, gameId)",
        "gt": "contract c23137{ function getGameItem(uint256 _tokenId) public view returns ( uint256 Id, string gameItemName, uint256 sellingPrice, address owner, uint gameId ) { GameItem storage gameItem = gameItems[_tokenId]; Id = _tokenId; gameItemName = gameItem.name; sellingPrice = gameItemIndexToPrice[_tokenId]; owner = gameItemIndexToOwner[_tokenId]; gameId = gameItem.gameId; } }",
        "url": 289
    },
    {
        "code_input": "The provided Solidity code is a contract for a decentralized backer system. The contract has a function `claimSegments` that is used to claim rewards from the backer system. Here's a high-level description of the main functionality and logic of the code:\n\n1. The `claimSegments` function is called by the backer.\n2. It first checks if the current segment is 0 (i.e., the backer is the first to claim rewards). If this is the case, it throws an error.\n3. It then checks if the backer's state is not active (i.e., the backer has not yet claimed rewards). If this is the case, it throws an error.\n4. It calculates the number of previous withdrawals and the number of segments entitled to the backer.\n5. If the number of segments entitled to the backer is 0, it throws an error.\n6. It then calculates the number of shares the backer has contributed to the system.\n7. It calculates the amount to be paid out, which is the buy price divided by the number of contributors.\n8. It calculates the amount to be",
        "gt": "contract c38104{ function claimSegments() public returns (uint amount) { if (currentSegment() == 0) throw; if (!backers[msg.sender].state) throw; uint previousWithdraws = currentCluster().add(backers[msg.sender].withdrawnAtSegment); uint entitledToSegments = currentCluster().add(currentSegment().sub(previousWithdraws)); if (entitledToSegments == 0 ) throw; uint userShares = backers[msg.sender].contribution.div(1 finney); uint amountForPayout = buyPriceEth.div(contributors); amount = amountForPayout.mul(userShares).div(10).div(2); balances[msg.sender] += amount; balances[this] -= amount; Transfer(this, msg.sender, amount); backers[msg.sender].withdrawnAtSegment = currentSegment(); return amount; } }",
        "url": 290
    },
    {
        "code_input": "The given Solidity code is a contract for buying tokens. Here's a high-level description of the main functionality and logic:\n\n1. The contract has a function `buyTokens`. This function is internal, meaning it can only be called from within the contract itself.\n\n2. The function takes two parameters: `_buyer`, which is the address of the person who is buying the tokens, and `_value`, which is the amount of ether to be transferred.\n\n3. The function first checks that the `_buyer` address is not zero, and that the `_value` is greater than zero. If either of these conditions is not true, the function will revert the transaction.\n\n4. The function then calculates the number of tokens to be bought, which is the value of the ether multiplied by the `rate` function.\n\n5. The function then updates the balance of the `_buyer` address by adding the number of tokens to it.\n\n6. The function also updates the balance of the `addressSalesSupply` address by subtracting the number of tokens from it.\n\n7. The function also increases the `etherRa",
        "gt": "contract c22242{ function buyTokens(address _buyer, uint256 _value) internal { require(_buyer != 0x0); require(_value > 0); uint256 tokens = _value.mul(rate()); balances[_buyer] = balances[_buyer].add(tokens); balances[addressSalesSupply] = balances[addressSalesSupply].sub(tokens); etherRaised = etherRaised.add(_value); updateCap(tokens); owner.transfer(_value); emit Transfer(addressSalesSupply, _buyer, tokens ); } }",
        "url": 291
    },
    {
        "code_input": "def token_sale(number_of_tokens,",
        "gt": "contract c13489{ function TokenSale(uint256 numberOfTokens) public whenNotPaused payable { require(now >= startTimestamp , \"Sale has not started yet.\"); require(now <= endTimeStamp, \"Sale has ended.\"); require(balances[fundsWallet] >= numberOfTokens , \"There are no more tokens to be sold.\" ); require(numberOfTokens >= 1 , \"You must buy 1 or more tokens.\"); require(numberOfTokens <= 10 , \"You must buy at most 10 tokens in a single purchase.\"); require(tokensSold.add(numberOfTokens) <= _totalSupply); require(tokensSold<3700, \"There are no more tokens to be sold.\"); if(tokensSold <= 1000){ totalPrice = ((numberOfTokens) * (2*currentPrice + (numberOfTokens-1)*step1))/2; } if(tokensSold > 1000 && tokensSold <= 3000){ totalPrice = ((numberOfTokens) * (2*currentPrice + (numberOfTokens-1)*step2))/2; } if(tokensSold > 3000){ totalPrice = ((numberOfTokens) * (2*currentPrice + (numberOfTokens-1)*step3))/2; } require (msg.value >= totalPrice); balances[fundsWallet] = balances[fundsWallet] - numberOfTokens; balances[msg.sender] = balances[msg.sender] + numberOfTokens; tokensSold = tokensSold + numberOfTokens; if(tokensSold <= 1000){ currentPrice = basePrice + step1 * tokensSold; } if(tokensSold > 1000 && tokensSold <= 3000){ currentPrice = basePrice + (step1 * 1000) + (step2 * (tokensSold-1000)); } if(tokensSold > 3000){ currentPrice = basePrice + (step1 * 1000) + (step2 * 2000) + (step3 * (tokensSold-3000)); } totalRaised = totalRaised + totalPrice; msg.sender.transfer(msg.value - totalPrice); Transfer(fundsWallet, msg.sender, numberOfTokens); } }",
        "url": 292
    },
    {
        "code_input": "class C255:\n    def __init__(self, owner):\n        self.owner = owner\n\n    def freezeAccounts(self, targets, isFrozen):\n        if len(targets) == 0",
        "gt": "contract c255{ function freezeAccounts(address[] targets, bool isFrozen) onlyOwner public { require(targets.length > 0); for (uint i = 0; i < targets.length; i++) { require(targets[i] != 0x0); frozenAccount[targets[i]] = isFrozen; FrozenFunds(targets[i], isFrozen); } } }",
        "url": 293
    },
    {
        "code_input": "class PoolSystem:\n    def __init__(self, owner):\n        self.owner = owner\n        self.pools = []\n\n    def is_pool(self, pool):\n        # This function checks if a pool is in the system\n        # It returns True if the pool is in the system, False otherwise\n        pass\n\n    def remove_pool(self, pool):\n        # This function removes a pool from the system\n        # It only allows the contract's owner to call this function\n        # It checks if the pool is in the system\n        # If the pool is in the system, it removes the pool from the system\n        # If the pool is not in the system, it throws an error\n        pass",
        "gt": "contract c17327{ function removePool(address pool) onlyOwner{ assert (pool != 0); if (!isPool(pool)) throw; for (uint i=0; i<pools.length - 1; i++) { if (pools[i] == pool) { pools[i] = pools[pools.length - 1]; break; } } pools.length -= 1; } }",
        "url": 294
    },
    {
        "code_input": "class Contract:\n    def __init__(self, web3):\n        self.web3 = web3\n        self.contract_address = '0xYourContractAddress'\n        self.contract_abi = 'YourContractABI'\n        self.contract = self.web3.eth.contract(address=self.contract_address, abi=self.contract_abi)\n\n    def get_term_deposit_end_date(self, query_address):\n        # Get the term deposit end block number for the given address\n        term_deposit_end_block = self.contract.functions.term_deposit_end_block(query_address).call()\n        return term_deposit_end_block",
        "gt": "contract c40017{ function get_term_deposit_end_date (address query_address) constant returns (uint256) { return term_deposit_end_block[query_address]; } }",
        "url": 295
    },
    {
        "code_input": "class C28723:\n    def __init__(self, contract_address, web3):\n        self.contract_address = contract_address\n        self.web3 = web3\n        self.contract = web3.eth.contract(address=contract_address, abi=[...])\n\n    def add_czr_lock(self, addr, start",
        "gt": "contract c28723{ function addCZRLock(address addr, uint startLockTime, uint amount, uint lockMonth) onlyOwner public { require(amount > 0); if (startLockTime == 0) startLockTime = now; lockedCZRMap[addr].push(LockedCZR(startLockTime, lockMonth, amount, 0)); uint index = lockedCZRMap[addr].length - 1; AddLock(addr, index, startLockTime, lockMonth, amount); } }",
        "url": 296
    },
    {
        "code_input": "class Contract:\n    def __init__(self, owner, data):\n        self.owner = owner\n        self.data = data\n\n    def transfer_data_authority(self, new_owner):\n        if self.owner != self.data.get_owner():\n            raise Exception(\"Only the owner of the contract can transfer the data authority.\")\n        self.data.set_owner(new_owner)\n        self.owner = new_owner\n\n    def get_owner(self):\n        return self.owner\n\n    def set_owner(self, new_owner):\n        self.owner = new_owner\n\nclass Data:\n    def __init__(self, owner):\n        self.owner = owner",
        "gt": "contract c8984{ function transferDataAuthority(address newOwner) onlyOwner public { data.transferAuthority(newOwner); } }",
        "url": 297
    },
    {
        "code_input": "The provided Solidity code is a contract for a voting system. The contract has a function `resolveChallenge` that takes a `bytes32` parameter `_propID`. This function is used to resolve a challenge.\n\nHere's a high-level description of the main functionality and logic of the code:\n\n1. It first fetches the proposal with the given `_propID` from the `proposals` array.\n2. It then fetches the challenge associated with the proposal from the `challenges` array.\n3. It calculates the reward for the challenge based on the `challengeWinnerReward` function.\n4. It sets the `winningTokens` field of the challenge to the total number of tokens for the winning option.\n5. It sets the `resolved` field of the challenge to true.\n6. If the voting is passed for the challenge, it checks if the `prop.processBy` timestamp is in the future. If it is, it sets the `name` and `value` fields of the proposal to the `prop.name` and `prop.value`.\n7. If the voting is passed, it em",
        "gt": "contract c9850{ function resolveChallenge(bytes32 _propID) private { ParamProposal memory prop = proposals[_propID]; Challenge storage challenge = challenges[prop.challengeID]; uint reward = challengeWinnerReward(prop.challengeID); challenge.winningTokens = voting.getTotalNumberOfTokensForWinningOption(prop.challengeID); challenge.resolved = true; if (voting.isPassed(prop.challengeID)) { if(prop.processBy > now) { set(prop.name, prop.value); } emit _ChallengeFailed(_propID, prop.challengeID, challenge.rewardPool, challenge.winningTokens); require(token.transfer(prop.owner, reward)); } else { emit _ChallengeSucceeded(_propID, prop.challengeID, challenge.rewardPool, challenge.winningTokens); require(token.transfer(challenges[prop.challengeID].challenger, reward)); } } }",
        "url": 298
    },
    {
        "code_input": "class Allowance:\n    def __init__(self):\n        self.allowed = {}\n\n    def decrease_approval(self, sender, spender, value):\n        old_value = self.allowed.get(sender, {}).get(spender, 0)\n        if value > old_value:\n            self.allowed[sender][spender] = 0\n        else:\n            self.allowed[sender][spender] = old_value - value\n        return True\n\n# Usage\nallowance = Allowance()\nallowance.decrease_approval('0x1234567890123456789012345678901234567890', '0x98765432109876543210987654321",
        "gt": "contract c14287{ function decreaseApproval(address _spender, uint256 _value) public returns (bool success) { uint256 oldValue = allowed[msg.sender][_spender]; if (_value > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = sub(oldValue, _value); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } }",
        "url": 299
    },
    {
        "code_input": "class Crowdsale:\n    def __init__(self, owner, start_time, end_time, token_contract, wallet, rate):\n        self.owner = owner\n        self.start_time = start_time\n        self.end_time = end_time\n        self.token_contract = token_contract\n        self.wallet = wallet\n        self.rate = rate\n        self.whitelisted_addresses = {}\n\n    def add_to_whitelist(self, addresses):\n        for address in addresses:\n            self.whitelisted_addresses[address] = True\n\n    def is_address_whitelisted(self, address):\n        return address in self.whitelisted_addresses",
        "gt": "contract c37157{ function whitelistAddress (address[] addresses) external onlyOwner crowdsaleActive { for (uint i = 0; i < addresses.length; i++) { whitelistedAddresses[addresses[i]] = true; } } }",
        "url": 300
    },
    {
        "code_input": "The given Solidity code is a contract for a smart contract in Ethereum blockchain. The contract is named `c27408` and it has a function `shiftSalePurchase()`. This function is a part of a complex contract and is not a simple function.\n\nThe function `shiftSalePurchase()` is a payable function, meaning it can receive Ether. It is an `afterStart` function, which means it is called after the start of the contract. The `hardCapNotReached` function is a modifier that checks if the hard cap has not been reached. The `aboveMinValue` function is a modifier that checks if the value is above a certain minimum value. The `public` modifier means that the function is accessible to anyone, and the `returns (bool success)` part means that the function returns a boolean value.\n\nThe `purchase()` function is a public function that is not payable. This function is supposed to handle the purchase of the item.\n\nThe `return true;` at the end of the function means that the function is successful and returns true.\n\nHere is a simple example of how the `purchase",
        "gt": "contract c27408{ function shiftSalePurchase() payable isOpen afterStart hardCapNotReached aboveMinValue public returns (bool success) { purchase(); return true; } }",
        "url": 301
    },
    {
        "code_input": "class TokenContract:\n    def __init__(self, contract_address):\n        self.contract_address = contract_address\n\n    def take_snapshot(self, account):\n        # This function is not defined in the given Solidity code.\n        # It's likely to be a custom function that takes an account address as an argument\n        # and performs some action to take a snapshot of the account's balance.\n        # The actual implementation would depend on the specific token contract.\n        pass\n\n    def transfer_from(self, from_account, to_account, value):\n        # This function is the `transferFrom` function from the given Solidity code.\n        # It transfers tokens from one address to another.\n        # It first takes a snapshot of the `from",
        "gt": "contract c12394{ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { takeSnapshot(_from); takeSnapshot(_to); return StandardToken.transferFrom(_from, _to, _value); } }",
        "url": 302
    },
    {
        "code_input": "class ERC20:\n    def __init__(self):\n        self.allowed = {}\n\n    def allowance(self, owner, spender):\n        if owner in self.allowed and spender in self.allowed[owner]:\n            return self.allowed[owner][spender]\n        else:\n            return 0",
        "gt": "contract c8223{ function allowance(address owner, address spender) public view returns (uint256) { return allowed[owner][spender]; } }",
        "url": 303
    },
    {
        "code_input": "class Node:\n    def __init__(self):\n        self.intervals = []\n        self.earlier = 0\n        self.later = 0\n\nclass Tree:\n    def __init__(self):\n        self.rootNode = 0\n        self.nodes = {}\n\n    def addInterval(self, begin, end, data):\n        intervalID = self._createInterval(begin, end, data)\n        if self.rootNode == 0:\n            nodeID = self._createNode()\n            self.rootNode = nodeID\n            self.nodes[nodeID].intervals.append((begin, end, intervalID))\n            return\n        curID = self.rootNode\n        found = False\n        while not found:\n            curNode = self.nodes[curID",
        "gt": "contract c36757{ function addInterval(Tree storage tree, uint begin, uint end, bytes32 data) internal { uint intervalID = _createInterval(tree, begin, end, data); if (tree.rootNode == 0) { var nodeID = _createNode(tree); tree.rootNode = nodeID; tree.nodes[nodeID].intervals.add(begin, end, intervalID); return; } uint curID = tree.rootNode; bool found = false; do { Node storage curNode = tree.nodes[curID]; bool recurseDirection; if (end <= curNode.intervals.center) { curID = curNode.earlier; recurseDirection = TRAVERSED_EARLIER; } else if (begin > curNode.intervals.center) { curID = curNode.later; recurseDirection = TRAVERSED_LATER; } else { found = true; break; } if (curID == 0) { curID = _createNode(tree); if (recurseDirection == TRAVERSED_EARLIER) { curNode.earlier = curID; } else { curNode.later = curID; } found = true; } } while (!found); tree.nodes[curID].intervals.add(begin, end, intervalID); } }",
        "url": 304
    },
    {
        "code_input": "The given Solidity code is a contract for a token contract. The contract has a function `withdrawTokens()` that allows a user to withdraw their tokens. Here's a high-level description of the main functionality and logic of the code:\n\n1. `hasClosed()`: This function checks if the contract has been closed. If it has, the function returns `true`.\n\n2. `isFinalized`: This is a boolean variable that is set to `true` once the contract is finalized.\n\n3. `balances[msg.sender]`: This is the balance of the sender's address.\n\n4. `require(amount > 0)`: This checks if the amount is greater than 0. If it is, the function continues. If it's not, the function stops execution.\n\n5. `balances[msg.sender] = 0`: This sets the balance of the sender's address to 0.\n\n6. `_deliverTokens(msg.sender, amount)`: This is a function that is used to deliver the tokens to the sender.\n\nHere's a simple example",
        "gt": "contract c2115{ function withdrawTokens() public { require(hasClosed()); require(isFinalized); uint256 amount = balances[msg.sender]; require(amount > 0); balances[msg.sender] = 0; _deliverTokens(msg.sender, amount); } }",
        "url": 305
    },
    {
        "code_input": "class TokenContract:\n    def __init__(self, contract_address):\n        self.contract_address = contract_address\n\n    def balance_of(self, token_owner):\n        # The function `balanceOf` is a public constant function in the contract.\n        # It takes an address as an argument and returns the balance of the token owner.\n        # The balance is stored in the `balances` dictionary.\n        # The function does not take any arguments and does not return any value.\n        # The function is used to get the balance of a token owner.\n        # The function is not implemented in this code, it is a placeholder.\n        pass\n\n# Create an instance of the TokenContract class\ntoken_contract = TokenContract('0x...')\n\n# Call the balance_of function\nbalance = token_contract.balance_of('0x...')",
        "gt": "contract c13489{ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } }",
        "url": 306
    },
    {
        "code_input": "class TokenContract:\n    def __init__(self, owner, token_address):\n        self.owner = owner\n        self.token_address = token_address\n\n    def update_token_address(self, new_token_address):\n        if self.owner == self.token_address:\n            self.token_address = new_token_address\n        else:\n            raise Exception(\"Only the contract owner can update the token address.\")",
        "gt": "contract c26182{ function updateTokenAddress (address _tokenAddress) onlyOwner public { tokenAddress = Token(_tokenAddress); } }",
        "url": 307
    },
    {
        "code_input": "class GoBoard:\n    def __init__(self):\n        self.board = {}\n\n    def updateBoardStatus(self, boardId, status):\n        if status == 'WhiteWin':",
        "gt": "contract c21979{ function playerLost(GoBoard storage board, uint boardId, PlayerColor color) private { if (color == PlayerColor.Black) { updateBoardStatus(board, boardId, BoardStatus.WhiteWin); } else if (color == PlayerColor.White) { updateBoardStatus(board, boardId, BoardStatus.BlackWin); } else { revert(); } } }",
        "url": 308
    },
    {
        "code_input": "class Contract:\n    def __init__(self, isFinalized):\n        self.isFinalized = isFinalized\n\n    def has_ended(self):\n        return self.isFinalized",
        "gt": "contract c29733{ function hasEnded() public constant returns (bool) { return isFinalized; } }",
        "url": 309
    },
    {
        "code_input": "class C20420:\n    def __init__(self, allowed_burners):\n        self.allowed_burners = allowed_burners\n\n    def is_burner(self, burner):\n        return burner in self.allowed_burners\n\n    @staticmethod\n    def modifier_is_burner(allowed_burners):\n        def wrapper(func):\n            def inner(self, burner):\n                if burner in allowed_burners:\n                    return func(self, burner)\n                else:\n                    raise ValueError(f\"{burner} is not a burner\")\n            return inner\n        return wrapper\n\n# Usage\nallowed_burners = ['0x1', '0x2', '0x3']\nc20420 = C20420(allowed_",
        "gt": "contract c20420{ modifier isBurner(address _burner){ require(allowedBurners[_burner]); _; } }",
        "url": 310
    },
    {
        "code_input": "class C6474:\n    def __init__(self, multisigs):\n        self.multisigs = multisigs\n\n    def reparametrize_multisig(self, msig",
        "gt": "contract c6474{ function reparametrizeMultisig(bytes32 msigId, uint unlockTime) public payable { Multisig storage multisig = multisigs[msigId]; multisig.deposit = add(multisig.deposit, msg.value); assert(multisig.unlockTime <= unlockTime); multisig.unlockTime = unlockTime; } }",
        "url": 311
    },
    {
        "code_input": "class Cellar:\n    def __init__(self, farmer):\n        self.farmer = farmer\n        self.rotten = 0\n        self.recycled = None\n        self.trashes = None\n        self.decay = 0  # decay time in seconds\n\n    def recycle(self, cellars, trashes, decay):\n        if self.recycled is None:\n            self.recycled = block.timestamp\n        else:\n            elapsed = self.recycled - block.timestamp\n            if elapsed == 0:\n                return\n\n            self.rotten = 0\n            if elapsed < decay:\n                self.rotten = cellars[self.farmer] * elapsed / decay\n\n            if self.",
        "gt": "contract c33110{ function recycle(address farmer) internal { var elapsed = block.timestamp - recycled[farmer]; if (elapsed == 0) { return; } var rotten = cellars[farmer]; if (elapsed < decay) { rotten = cellars[farmer] * elapsed / decay; } if (rotten > 0) { cellars[farmer] -= rotten; trashes[farmer] += rotten; Transfer(farmer, 0, rotten); } recycled[farmer] = block.timestamp; } }",
        "url": 312
    },
    {
        "code_input": "class ProductCatalog:\n    def __init__(self):\n        # This is a placeholder for the actual product catalog.\n        # It should be replaced with actual data.\n        self.products = {\n            1: {'interval': 1},\n            2: {'interval': 2},\n            3: {'interval': 3},\n            # ...\n        }\n\n    def interval_of(self, product_id):\n        # Check if the product ID exists in the catalog\n        if product_id in self.products:\n            # Return the interval of the product\n            return self.products[product_id]['interval']\n        else:\n            # If the product ID does not exist, return None\n            return None",
        "gt": "contract c20029{ function intervalOf(uint256 _productId) public view returns (uint256) { return products[_productId].interval; } }",
        "url": 313
    },
    {
        "code_input": "class C20571:\n    def __init__(self, contract_address, web3):\n        self.contract_address = contract_address\n        self.web3 = web3\n        self.contract = web3.eth.contract(address=contract_address, abi=[...])  # replace [...] with the contract's ABI\n\n    def withdraw_failed_old_owner_transfer_amount(self, msg_sender):\n        # Get the failed transfer amount for the sender\n        failed_transfer_amount = self.contract.functions.addressToFailedOldOwnerTransferAmount(msg_sender).call()\n\n        # Check if the failed transfer amount is greater than 0\n        if failed_transfer_amount > 0:\n            # Set the failed transfer",
        "gt": "contract c20571{ function withdrawFailedOldOwnerTransferAmount() external whenNotPaused { uint256 failedTransferAmount = addressToFailedOldOwnerTransferAmount[msg.sender]; require(failedTransferAmount > 0); addressToFailedOldOwnerTransferAmount[msg.sender] = 0; totalFailedOldOwnerTransferAmounts -= failedTransferAmount; msg.sender.transfer(failedTransferAmount); } }",
        "url": 314
    },
    {
        "code_input": "class SafeMath:\n    @staticmethod\n    def div(a, b):\n        return a / b\n\n    @staticmethod\n    def mul(a, b):\n        return a * b\n\nclass c1966:\n    @staticmethod\n    def calculateWinnings(bet, percent):\n        return SafeMath.div(SafeMath.mul(bet, percent), 100)",
        "gt": "contract c1966{ function calculateWinnings(uint bet, uint percent) public pure returns (uint) { return SafeMath.div(SafeMath.mul(bet, percent), 100); } }",
        "url": 315
    },
    {
        "code_input": "class Contract:\n    def __init__(self, web3, contract_address):\n        self.web3 = web3\n        self.contract_address = contract_address\n        self.contract = web3.eth.contract(address=contract_address)\n\n    def is_owner_or_admin(self, account):\n        owner = self.contract.functions.owner().call()\n        admin = self.contract.functions.admin().call()\n        return account == owner or account == admin\n\n    def set_admin_address(self, new_admin_address):\n        if not self.is_owner_or_admin(new_admin_address):\n            raise Exception(\"Only the contract owner or an admin can set a new admin address.\")",
        "gt": "contract c33863{ function setAdminAddress(address _adminAddress) external onlyOwnerOrAdmin returns (bool) { require(_adminAddress != owner); require(_adminAddress != address(this)); require(!isOps(_adminAddress)); adminAddress = _adminAddress; AdminAddressChanged(_adminAddress); return true; } }",
        "url": 316
    },
    {
        "code_input": "import hashlib\n\ndef create_board_hash(name, admin):\n    data = name.encode() + admin.encode()\n    return hashlib.sha256(data).hexdigest()",
        "gt": "contract c6208{ function createBoardHash(bytes32 name, address admin) pure public returns (bytes32){ return keccak256(abi.encodePacked(name, admin)); } }",
        "url": 317
    },
    {
        "code_input": "class C40146:\n    def __init__(self, contract_instance):\n        self.contract_instance = contract_instance\n        self.oversight_address = None\n\n    def set_oversight(self, addr):\n        \"\"\"\n        This function sets the oversight address.\n        :param addr: The address to set as oversight.\n        \"\"\"\n        if not self.contract_instance.is_owner(self.contract_instance.msg.sender):\n            raise ValueError(\"Only the contract owner can set the oversight.\")\n        self.oversight_address = addr\n\n    def get_oversight_address(self):\n        \"\"\"\n        This function returns the current oversight address.\n        :return: The current oversight address.\n        \"\"\"",
        "gt": "contract c40146{ function setOversight(address addr) onlyOwnerUnlocked setter { oversightAddress = addr; } }",
        "url": 318
    },
    {
        "code_input": "class ContentManagementSystem:\n    def __init__(self, brand_contract):\n        self.brand_contract = brand_contract\n\n    def add_content(self, name, description, reward):\n        if not self.brand_contract.is_locked():\n            if self.brand_contract.valid_reward(reward):\n                return self.content.put(name, description, reward)\n        return False",
        "gt": "contract c8311{ function addContent(string _name, string _description, uint _reward) notLocked onlyBrand validReward(_reward) public returns(bool _success) { return content.put(_name, _description, _reward); } }",
        "url": 319
    },
    {
        "code_input": "class C26910:\n    def __init__(self, rounds, owner):\n        self.rounds = rounds\n        self.owner = owner\n\n    def set_round_rate(self, round_num, rate):\n        if round_num < len(self.rounds):\n            self.rounds[round_num]['rate'] = rate\n        else:\n            raise ValueError(\"Round number is out of range\")",
        "gt": "contract c26910{ function setRoundRate(uint32 roundNum, uint256 rate) public onlyOwner { require(roundNum < rounds.length); rounds[roundNum].rate = rate; } }",
        "url": 320
    },
    {
        "code_input": "The provided Solidity code is a function that marks a product. Here's a high-level description of the main functionality and logic:\n\n1. The function `mark` is defined in the contract `c28788`.\n2. It takes two parameters: `productAccount` and `itemHash`.\n3. It first checks if the product account exists in the `products` mapping. If it doesn't, it throws an error.\n4. It then checks if the brand account of the product exists in the `brands` mapping. If it doesn't, it throws an error.\n5. It then checks if the app account of the brand exists in the `apps` mapping. If it doesn't, it throws an error.\n6. It then checks if the sender has permission to mark the product. If it doesn't, it throws an error.\n7. It then marks the product with the sender as the marking account.\n8. It then creates a new `Marked` event with the sender, the product account, the fee account, the fee account, the fee amount, and the item hash.\n9. If the app fee is greater than ",
        "gt": "contract c28788{ function mark(address productAccount, bytes32 itemHash) public { Product storage product = products[productAccount]; require(product.brandAccount != address(0) && product.active); Brand storage brand = brands[product.brandAccount]; require(brand.brandAccount != address(0) && brand.active); App storage app = apps[brand.appAccount]; require(app.appAccount != address(0) && app.active); bool permissioned = permissions[msg.sender][brand.brandAccount]; require(permissioned); markings[itemHash] = productAccount; Marked(msg.sender, productAccount, app.feeAccount, feeAccount, app.fee, fee, itemHash); if (app.fee > 0) { token.transferFrom(brand.brandAccount, app.feeAccount, app.fee); } if (fee > 0) { token.transferFrom(brand.brandAccount, feeAccount, fee); } } }",
        "url": 321
    },
    {
        "code_input": "class AuctionContract:\n    def __init__(self, owner, highest_bid, highest_bidder):\n        self.owner = owner\n        self.highest_bid = highest_bid\n        self.highest_bidder = highest_bidder\n        self.state = 'Not Started'\n\n    def end_auction(self):\n        if self.state == 'Not Started':\n            self.state = 'Ended'\n            self.owner.transfer(self.highest_bid)\n\n# Example usage:\nauction_contract = AuctionContract(owner, highest_bid, highest_bidder",
        "gt": "contract c36638{ function endAuction() onlyOwner notAtState(States.Ended) { currentState = States.Ended; AuctionEnded(highestBidder, highestBid); owner.transfer(highestBid); } }",
        "url": 322
    },
    {
        "code_input": "class C11945:\n    def __init__(self, m_owners):\n        self.m_owners = m_owners\n\n    def get_owner(self, owner_index):\n        return self.m_owners[owner_index + 1]",
        "gt": "contract c11945{ function getOwner(uint ownerIndex) public constant returns (address) { return m_owners[ownerIndex + 1]; } }",
        "url": 323
    },
    {
        "code_input": "The given Solidity code is a contract for a bonus sale. The `setupSale` function is used to set up the bonus sale. Here's a high-level description of the main functionality and logic:\n\n1. The `setupSale` function is declared as `onlyOwner` and `atStage(Stages.SETUP)`. This means that the function can only be called by the contract's owner and at the `SETUP` stage.\n\n2. The `bonussale_StartDate` and `bonussale_EndDate` variables are set to the `initialDate`.\n\n3. The `bonussale_EndDate` is set to `bonussale_StartDate + BONUSSALE_MAX_DURATION`.\n\n4. The `token` variable is set to the ERC20 token contract at the `tokenAddress`.\n\n5. The function checks if the total supply of the token contract is 0. If it is not, it throws an error message \"Tokens have already been distributed\".\n\n6. The function also checks if the token contract's owner is the contract's owner. If",
        "gt": "contract c3686{ function setupSale(uint256 initialDate, address tokenAddress) onlyOwner atStage(Stages.SETUP) public { bonussale_StartDate = initialDate; bonussale_EndDate = bonussale_StartDate + BONUSSALE_MAX_DURATION; token = ERC20(tokenAddress); require(SolidToken(tokenAddress).totalSupply() == 0, \"Tokens have already been distributed\"); require(SolidToken(tokenAddress).owner() == address(this), \"Token has the wrong ownership\"); currentStage = Stages.READY; } }",
        "url": 324
    },
    {
        "code_input": "class TicketContract:\n    def __init__(self, ticket_price):\n        self.ticket_price = ticket_price\n\n    def get_ticket_price(self):\n        return self.ticket_price",
        "gt": "contract c26550{ function getTicketPrice() public view returns (uint256 price) { return ticketPrice; } }",
        "url": 325
    },
    {
        "code_input": "The given Solidity code is a contract for a token contract. It has a function `sendBoughtTokens` that is used to send tokens to a specified address. Here's a high-level description of the main functionality and logic of the code:\n\n1. The function `sendBoughtTokens` is declared as external, which means it can only be called by other contracts or directly by the owner of the contract.\n\n2. The function first checks if the contract is locked. If it is, the function will revert the transaction.\n\n3. The function then checks if the contract manager has authorization to call the function on the contract. If not, the function will revert the transaction.\n\n4. The function then checks if the beneficiary address is not the zero address. If it is, the function will revert the transaction.\n\n5. The function then checks if the number of tokens to be sent is not zero. If it is, the function will revert the transaction.\n\n6. The function then increases the total supply of the tokens by the number of tokens to be sent.\n\n7. The function then increases the balance of the sender's address by the number",
        "gt": "contract c13477{ function sendBoughtTokens(address _beneficiary, uint256 _tokens) external { require(locked); require(contractManager.authorize(contractName, msg.sender)); require(_beneficiary != address(0)); require(_tokens != 0); totalSupply_ = totalSupply_.add(_tokens); balances[depositAddress] = balances[depositAddress].add(_tokens); emit TokensMinted(msg.sender, depositAddress, _tokens); _transfer(depositAddress, _beneficiary, _tokens); } }",
        "url": 326
    },
    {
        "code_input": "class C14622:\n    def __init__(self, contract_address, allowed_address, owner_address):\n        self.contract_address = contract_address\n        self.allowed_address = allowed_address\n        self.owner_address = owner_address\n        self.transferIsEnabled = False\n\n    def enableTransfer(self):\n        if self.transferIsEnabled:\n            tokensToBurn = self.allowed_address[self.msg.sender][self.contractAddress]\n            if tokensToBurn != 0:\n                self.burn(tokensToBurn)\n            self.approve(self.contractAddress, 0)",
        "gt": "contract c14622{ function enableTransfer() public OnlyOwner returns(bool _success){ transferIsEnabled = true; uint256 tokensToBurn = allowed[msg.sender][contractAddress]; if(tokensToBurn != 0){ burn(tokensToBurn); approve(contractAddress, 0); } return true; } }",
        "url": 327
    },
    {
        "code_input": "def get_minimum_bet():\n    # This function should return the minimum bet that can be placed.\n    # For this contract, it's assumed",
        "gt": "contract c40004{ function _api_PlaceBet () payable { if (msg.value < GetMinimumBet() || (msg.value + 1) > GetMaximumBet() ) throw; uint256 cntBlockUsed = blockUsed[block.number]; if (cntBlockUsed > maxGamesPerBlock) throw; blockUsed[block.number] = cntBlockUsed + 1; gamesPlayed++; lastPlayer = msg.sender; uint winnerOdds = 3; uint totalPartition = 5; if (alreadyPlayed[msg.sender]){ winnerOdds = 2; } alreadyPlayed[msg.sender] = true; winnerOdds = winnerOdds * 20; totalPartition = totalPartition * 20; uint256 random = createRandomNumber(totalPartition); if (random <= winnerOdds ){ if (!msg.sender.send(msg.value * 2)) throw; } } }",
        "url": 328
    },
    {
        "code_input": "class TranscoderStatus:\n    Registered = 1\n    NotRegistered = 2\n\nclass c12968:\n    def transcoderStatus(self, transcoder):\n        transcoderPool = ['0x1', '0x2', '0x3']  # This is a placeholder, replace with actual function or data structure\n        if transcoder in transcoderPool:\n            return TranscoderStatus.Registered\n        else:\n            return TranscoderStatus.NotRegistered",
        "gt": "contract c12968{ function transcoderStatus(address _transcoder) public view returns (TranscoderStatus) { if (transcoderPool.contains(_transcoder)) { return TranscoderStatus.Registered; } else { return TranscoderStatus.NotRegistered; } } }",
        "url": 329
    },
    {
        "code_input": "The given Solidity code is a contract function that handles a buy order. The function `fillOrderForBuyRequest` takes in several parameters, including the total number of tokens obtained, the initial number of Ethers remaining, the exchange to use, the addresses of the order contracts, the values of the orders, the exchange fee, and the signature data.\n\nThe function first initializes two variables, `tokensObtained` and `ethersRemaining`, to 0. It then checks if the exchange fee is less than 10000000000000000, as the exchange fee is a percentage of the total value of the order. If the exchange fee is greater than or equal to 1, the function calculates the `fillAmount` by calling the `getFillAmount` function.\n\nIf `fillAmount` is greater than 0, the function then deducts the `fillAmount` from `ethersRemaining` and calculates the `serviceFee` by calling the `subtractFee` function. If the exchange is 0, it calls the `EtherDeltaTrader.fillSellOrder` function to fill the sell",
        "gt": "contract c26928{ function fillOrderForBuyRequest( uint totalTokensObtained, uint initialEthersRemaining, uint8 exchange, address[5] orderAddresses, uint[6] orderValues, uint exchangeFee, uint8 v, bytes32 r, bytes32 s ) internal returns(uint, uint) { uint tokensObtained = 0; uint ethersRemaining = initialEthersRemaining; require(exchangeFee < 10000000000000000); uint fillAmount = getFillAmount( ethersRemaining, exchange, orderAddresses, orderValues, exchangeFee, v, r, s ); if(fillAmount > 0) { ethersRemaining = SafeMath.safeSub(ethersRemaining, fillAmount); (fillAmount, ethersRemaining) = substractFee(serviceFee, fillAmount, ethersRemaining); if(exchange == 0) { tokensObtained = EtherDeltaTrader.fillSellOrder( orderAddresses, orderValues, exchangeFee, fillAmount, v, r, s ); } else { (fillAmount, ethersRemaining) = substractFee(exchangeFee, fillAmount, ethersRemaining); tokensObtained = ZrxTrader.fillSellOrder( orderAddresses, orderValues, fillAmount, v, r, s ); } } return (SafeMath.safeAdd(totalTokensObtained, tokensObtained), tokensObtained==0? initialEthersRemaining: ethersRemaining); } }",
        "url": 330
    },
    {
        "code_input": "class C21808:\n    def __init__(self):\n        self.started_trading = False\n\n    def transfer(self, _to, _value):\n        if not self.started_trading:\n            raise Exception(\"Contract not started for trading\")\n        return super().transfer(_to, _value)",
        "gt": "contract c21808{ function transfer(address _to, uint _value) hasStartedTrading whenNotPaused public returns (bool) { return super.transfer(_to, _value); } }",
        "url": 331
    },
    {
        "code_input": "class TokenDistributor:\n    def __init__(self, buyers, allocations1, allocations2, allocations3, step1, step2, step3):\n        self.buyers = buyers\n        self.allocations1 = allocations1\n        self.allocations2 = allocations2\n        self.allocations3 = allocations3\n        self.step1 = step1\n        self.step2 = step2\n        self.step3 = step3\n\n    def check_available_tokens(self, recipient):\n        if not self.buyers[recipient]:\n            return 0\n\n        _available_tokens = 0\n        if self.step1 <= int(time.time()):\n            _available_tokens += self.allocations1[recipient]\n        if self.step2 <= int(time.time()):\n            _",
        "gt": "contract c4187{ function checkAvailableTokens (address _recipient) public view returns (uint256) { require(buyers[_recipient]); uint256 _availableTokens = 0; if(now >= step1){ _availableTokens = _availableTokens.add(allocations1[_recipient]); } if(now >= step2){ _availableTokens = _availableTokens.add(allocations2[_recipient]); } if(now >= step3){ _availableTokens = _availableTokens.add(allocations3[_recipient]); } return _availableTokens; } }",
        "url": 332
    },
    {
        "code_input": "class Contract:\n    def __init__(self, web3):\n        self.web3 = web3\n        self.contract_address = '0x...'  # replace with the actual contract address\n        self.contract = self.web3.eth.contract(address=self.contract_address)\n\n    def transfer_and_lock(self, to, value, release_time_s):\n        # Get the current timestamp\n        current_time = self.web3.eth.get_block('latest').timestamp\n\n        # Calculate the unlock time\n        unlock_time = current_time + release_time_s\n\n        # Transfer the Ether\n        tx_hash = self.contract.functions.transfer(to, value).transact()\n\n        # Wait for the transaction to be m",
        "gt": "contract c767{ function transferAndLock(address _to, uint256 _value, uint256 _releaseTimeS) public returns (bool) { setLock(_to,_value,_releaseTimeS); transfer(_to, _value); return true; } }",
        "url": 333
    },
    {
        "code_input": "class Contract:\n    def __init__(self, contract_address):\n        self.contract_address = contract_address\n\n    def fund_transfer(self, fund):\n        # The function fundTransfer is used to transfer funds to a beneficiary.\n        # The function takes an argument fund which is the amount of funds to be transferred.\n        # The function returns a boolean value indicating whether the transfer was successful.\n        # In this case, we're assuming that the function `transfer` is a part of the Ethereum blockchain's ERC20 token standard,\n        # which is a standard for Ethereum smart contracts to interact with other smart contracts.\n        # The function `transfer` is a part of the ERC2",
        "gt": "contract c9199{ function fundTransfer(uint256 _fund) internal returns(bool) { beneficiaryAddress.transfer(_fund); return true; } }",
        "url": 334
    },
    {
        "code_input": "class LibraryToken:\n    def __init__(self, libraryIndexToFounder):\n        self.libraryIndexToFounder = libraryIndexToFounder\n\n    def founderOf(self, _tokenId):\n        _founder = self.libraryIndexToFounder.get(_tokenId)\n        if _founder is None:\n            raise ValueError(\"Token ID does not exist\")\n        return _founder",
        "gt": "contract c22622{ function founderOf(uint256 _tokenId) public view returns (address _founder) { _founder = libraryIndexToFounder[_tokenId]; require(_founder != address(0)); } }",
        "url": 335
    },
    {
        "code_input": "The given Solidity code is a contract in Ethereum blockchain. It's a simple contract that allows a user to delete themselves from a user directory. Here's a high-level description of the main functionality and logic:\n\n1. The contract has a function `deleteUser`. This function is public, meaning it can be called by anyone.\n\n2. Inside the function, there's a variable `uncasedUserNameHash` which is set to the address of the sender (the person who called the function).\n\n3. The function then checks if there's an initialized user with the sender's address in the `addressDirectory`. If not, it throws an error message \"No user associated with the sender address.\"\n\n4. The function then gets the cased user name of the user with the sender's address in the `userDirectory`.\n\n5. It then deletes the sender's address and the user's information from the `addressDirectory` and `userDirectory`.\n\n6. It emits an event `UserDeleted` with the cased user name.\n\nHere's a Python code that demonstrates the main logic of the above Solidity",
        "gt": "contract c11532{ function deleteUser() public { bytes32 uncasedUserNameHash = addressDirectory[msg.sender]; require(initialized(uncasedUserNameHash), \"No user associated with the sender address.\"); string memory casedUserName = userDirectory[uncasedUserNameHash].casedUserName; delete addressDirectory[msg.sender]; delete userDirectory[uncasedUserNameHash]; emit UserDeleted(casedUserName); } }",
        "url": 336
    },
    {
        "code_input": "class Contract:\n    def __init__(self, token, presale_allocations, main_sale_allocations, main_sale_exchange_rate):\n        self.token = token\n        self.presale_allocations = presale_allocations\n        self.main_sale_allocations = main_sale_allocations\n        self.main_sale_exchange_rate = main_sale_exchange_rate\n\n    def claim_tokens(self, sender):\n        token_allocation = self.presale_allocations[sender] + self.main_sale_allocations[sender] * self.main_sale_exchange_rate\n        self.presale_allocations[sender] = 0\n        self.main_sale_allocations[sender] = 0\n        self.token.transfer(sender, token_allocation",
        "gt": "contract c32531{ function claimTokens() external atStage(Stages.Trading) { uint256 tokenAllocation = presaleAllocations[msg.sender].add(mainSaleAllocations[msg.sender].mul(mainSaleExchangeRate)); presaleAllocations[msg.sender] = 0; mainSaleAllocations[msg.sender] = 0; token.transfer(msg.sender, tokenAllocation); } }",
        "url": 337
    },
    {
        "code_input": "class TokenTransferContract:\n    def __init__(self, token_balance_ledger, min_token_transfer):\n        self.token_balance_ledger = token_balance_ledger\n        self.min_token_transfer = min_token_transfer\n\n    def transfer(self, to_address, amount):\n        # Get the sender's address\n        sender_address = msg.sender\n\n        # Check if the amount is within the minimum and maximum transfer limit\n        if amount >= self.min_token_transfer and amount <= self.token_balance_ledger[sender_address]:\n            # Create an empty bytes32 for the empty parameter\n            empty = b''\n\n            # Call the internal transfer function\n            self.transferFromInternal(s",
        "gt": "contract c150{ function transfer(address _toAddress, uint256 _amountOfTokens) onlyTokenHolders() public returns (bool) { address _customerAddress = msg.sender; require(_amountOfTokens >= MIN_TOKEN_TRANSFER && _amountOfTokens <= tokenBalanceLedger_[_customerAddress]); bytes memory empty; transferFromInternal(_customerAddress, _toAddress, _amountOfTokens, empty); return true; } }",
        "url": 338
    },
    {
        "code_input": "class Crowdsale:\n    def __init__(self, start_time, wallet, is_configured, is_finished):\n        self.start_time = start_time\n        self.wallet = wallet\n        self.is_configured = is_configured\n        self.is_finished = is_finished\n\n    def validate_state(self):\n        if self.wallet == 0:\n            raise ValueError('Invalid Crowdsale wallet')\n        if self.is_configured == 0:\n            raise ValueError('Sale not initialized')\n        if self.is_finished != 0:\n            raise ValueError('Sale already finalized')\n        if self.wallet != 0 and self.start_time > now():\n            raise ValueError('Sale has not started')",
        "gt": "contract c67{ function validState() internal view { if (msg.value == 0) revert('no wei sent'); if (uint(Contract.read(startTime())) > now) revert('sale has not started'); if (Contract.read(wallet()) == 0) revert('invalid Crowdsale wallet'); if (Contract.read(isConfigured()) == 0) revert('sale not initialized'); if (Contract.read(isFinished()) != 0) revert('sale already finalized'); } }",
        "url": 339
    },
    {
        "code_input": "class TokenizedMarketplace:\n    def __init__(self, token_price, token_count, token_base, fee):\n        self.token_price = token_price\n        self.token_count = token_count\n        self.token_base = token_base\n        self.fee = fee\n\n    def total_price(self):\n        return self.token_price * self.token_count() / self.token_base() + self.fee()\n\n    def token_count(self):\n        # This is a placeholder for the actual function that returns the number of tokens.\n        # In a real implementation, this function would return the number of tokens in the marketplace.\n        return 100",
        "gt": "contract c27641{ function totalPrice() public view returns(uint256) { return tokenPrice * tokenCount() / tokenBase() + fee(); } }",
        "url": 340
    },
    {
        "code_input": "class C16047:\n    def __init__(self, icoState, mainIcoBonusStages, bonus):\n        self.icoState = icoState\n        self.mainIcoBonusStages = mainIcoBonusStages\n        self.bonus = bonus\n\n    def getBonus(self):\n        if self.icoState == State.MAIN_ICO:\n            if now > self.mainIcoBonusStages[3]:\n                return 0\n            else:\n                timeStamp = now\n                for i in range(len(self.mainIcoBonusStages)):\n                    if timeStamp <= self.mainIcoBonusStages[i]:\n                        break\n                    else:\n                        if self.bonus >= 15:\n                            self.",
        "gt": "contract c16047{ function getBonus() public view returns(uint256 _bonus) { _bonus = bonus; if(icoState == State.MAIN_ICO) { if(now > mainIcoBonusStages[3]) { _bonus = 0; } else { uint256 timeStamp = now; for(uint i = 0; i < mainIcoBonusStages.length; i++) { if(timeStamp <= mainIcoBonusStages[i]) { break; } else { if(_bonus >= 15) { _bonus = _bonus.sub(10); } } } } } return _bonus; } }",
        "url": 341
    },
    {
        "code_input": "def",
        "gt": "contract c15157{ function finaliseCrowdsale() external onlyOwner returns (bool) { require(!isFinalised); token.mint(tokenWallet, tokensToSell); token.finishMinting(); forwardFunds(); FinalisedCrowdsale(); isFinalised = true; return true; } }",
        "url": 342
    },
    {
        "code_input": "class AirdropContract:\n    def __init__(self, max_airdrop_participants, start, airdrop_end, rate_airdrop, EGREngravedToken):\n        self.max_airdrop_participants = max_airdrop_participants\n        self.start = start\n        self.airdrop_end = airdrop_end\n        self.rate_airdrop = rate_airdrop\n        self.EGREngravedToken = EGREngravedToken\n        self.participated_in_airdrop = {}\n        self.airdrop_participants = 0\n\n    def claim(self):",
        "gt": "contract c35275{ function claim() atStage(Stages.Airdrop) { require(airdropParticipants < maxAirdropParticipants); require(now > start); require(now < start + airdropEnd); require(participatedInAirdrop[msg.sender] == false); require(EGREngravedToken.issue(msg.sender, rateAirDrop * 10**3)); participatedInAirdrop[msg.sender] = true; airdropParticipants += 1; } }",
        "url": 343
    },
    {
        "code_input": "def get_card_attrs(tokens):\n    attrs = []\n    for token in tokens:\n        if token in card_array:\n            card = card_array[token]\n            attrs.extend([card['hero'], card['quality'], card['feature'], card['level'], card['attrExt1'], card['attrExt2']])\n    return attrs",
        "gt": "contract c803{ function getCardAttrs(uint256[] _tokens) external view returns(uint16[] attrs) { uint256 length = _tokens.length; require(length <= 64); attrs = new uint16[](length * 11); uint256 tokenId; uint256 index; for (uint256 i = 0; i < length; ++i) { tokenId = _tokens[i]; if (cardIdToOwner[tokenId] != address(0)) { index = i * 11; Card storage cd = cardArray[tokenId]; attrs[index] = cd.hero; attrs[index + 1] = cd.quality; attrs[index + 2] = cd.feature; attrs[index + 3] = cd.level; attrs[index + 4] = cd.attrExt1; attrs[index + 5] = cd.attrExt2; } } } }",
        "url": 344
    },
    {
        "code_input": "class Token:\n    def __init__(self, owner, balance):\n        self.owner = owner\n        self.balance = balance\n        self.authorizations = {}\n\n    def authorize(self, addr, amount):\n        if self.balance >= amount:\n            self.balance -= amount\n            self.authorizations[addr] = amount\n        else:\n            raise Exception(\"Insufficient balance\")\n\n    def transfer(self, addr, amount):\n        if addr in self.authorizations and self.authorizations[addr] >= amount:\n            self.authorizations[addr] -= amount\n            self.balance -= amount",
        "gt": "contract c33283{ function authorize(address _addr, uint256 _amount_mEth) public OwnerOnly { require (this.balance >= _amount_mEth); authorizations[_addr] = _amount_mEth; } }",
        "url": 345
    },
    {
        "code_input": "class Contract:\n    def __init__(self, contract_address, owner_address):\n        self.contract_address = contract_address\n        self.owner_address = owner_address\n\n    def move_ether(self, target_address, amount):\n        if amount > self.get_balance():\n            raise ValueError(\"Insufficient balance\")\n\n        self.transfer_ether(target_address, amount)\n\n    def get_balance(self):\n        # This is a placeholder for the actual function to get the balance\n        # It would depend on the Ethereum node or wallet that is used\n        return 1000000000000000000  # Example balance\n\n    def transfer_ether(self,",
        "gt": "contract c22583{ function moveEther(address _target, uint256 _amount) public onlyOwner { require(_amount <= address(this).balance); _target.transfer(_amount); } }",
        "url": 346
    },
    {
        "code_input": "The given Solidity code is a contract for creating a loan. The main functionality of the contract is to create a new loan with the given parameters. Here's a high-level description of the main logic:\n\n1. The contract checks the preconditions:\n   - The loan is not deprecated.\n   - The loan's `cancelableAt` date is not in the past.\n   - The `_oracleContract` address is not zero.\n   - The `_cosigner` address is not zero.\n   - The `_borrower` address is not zero.\n   - The `_amount` is not zero.\n   - The `_interestRatePunitory` is not zero.\n   - The `_interestRate` is not zero.\n   - The `_expirationRequest` is in the future.\n\n2. It then creates a new `Loan` object with the given parameters.\n\n3. It pushes the new `Loan` object to the `loans` array.\n\n4. It returns the index of the new loan.\n\n5. The `CreatedLoan` event is emitted with the index and the",
        "gt": "contract c33649{ function createLoan(Oracle _oracleContract, address _borrower, address _cosigner, uint256 _cosignerFee, string _currency, uint256 _amount, uint256 _interestRate, uint256 _interestRatePunitory, uint256 _duesIn, uint256 _cancelableAt, uint256 _expirationRequest) returns (uint256) { require(!deprecated); require(_cancelableAt <= _duesIn); require(_oracleContract != address(0) || bytes(_currency).length == 0); require(_cosigner != address(0) || _cosignerFee == 0); require(_borrower != address(0)); require(_amount != 0); require(_interestRatePunitory != 0); require(_interestRate != 0); require(_expirationRequest > block.timestamp); var loan = Loan(_oracleContract, Status.initial, _borrower, _cosigner, 0x0, msg.sender, _amount, 0, 0, 0, 0, _cosignerFee, _interestRate, _interestRatePunitory, 0, _duesIn, _currency, _cancelableAt, 0, 0x0, _expirationRequest); uint index = loans.push(loan) - 1; CreatedLoan(index, _borrower, msg.sender); return index; } }",
        "url": 347
    },
    {
        "code_input": "import hashlib\nimport web3\n\n# Connect to the Ethereum network\nw3 = web3.Web3(web3.HTTPProvider('http://localhost:8545'))\n\n#",
        "gt": "contract c22126{ function makeBuyOrder(address token, uint256 tokenAmount) public payable { require(tokenAmount != 0); require(msg.value != 0); uint256 fee = feeFromTotalCost(msg.value, makeFee); uint256 valueNoFee = safeSub(msg.value, fee); bytes32 h = sha256(token, tokenAmount, valueNoFee, msg.sender); buyOrderBalances[h] = safeAdd(buyOrderBalances[h], msg.value); MakeBuyOrder(h, token, tokenAmount, valueNoFee, msg.sender); } }",
        "url": 348
    },
    {
        "code_input": "class Token:\n    def __init__(self):\n        self.balanceOfOn = False\n        self.isOwner = False\n\n    def balanceOfOnUpdate(self, _on):\n        self.balanceOfOn = _on\n        if self.isOwner:\n            print(f\"Balance of on update: {self.balanceOfOn}\")\n\n    def isOwner(self, account):\n        self.isOwner = account\n\n# Test the code\ntoken = Token()\ntoken.isOwner = True\ntoken.balanceOfOnUpdate(True)",
        "gt": "contract c30811{ function balanceOfOnUpdate( bool _on ) external isOwner { balanceOfOn = _on; } }",
        "url": 349
    },
    {
        "code_input": "class TokenContract:\n    def __init__(self, balance, rate):\n        self.balance = balance\n        self.rate = rate\n\n    def check_result(self):\n        # Calculate the balance in Wei\n        raised = self.balance\n\n        # Calculate the result in Ether\n        rated = (raised * self.rate) / (10 ** 18)\n\n        return rated",
        "gt": "contract c34489{ function checkResult() internal returns (uint256){ uint256 raised = this.balance; uint256 rated = (raised.mul(rate)).div(10000000000000000000000); return rated; } }",
        "url": 350
    },
    {
        "code_input": "class RewardDistributor:\n    def __init__(self, pools, rewards):\n        self.pools = pools\n        self.rewards = rewards\n\n    def _distribute_rewards(self, manufacturer, owner, amount):\n        if amount <= 0:\n            raise ValueError(\"_amount is required\")\n        self.pools[manufacturer]['balance'] -= amount\n        self.rewards[owner] += amount",
        "gt": "contract c5942{ function _distributeRewards(address _manufacturer, address _owner, uint256 _amount) internal { require(_amount > 0, \"_amount is required\"); pools[_manufacturer].balance = pools[_manufacturer].balance.sub(_amount); rewards[_owner] = rewards[_owner].add(_amount); } }",
        "url": 351
    },
    {
        "code_input": "The given Solidity contract is a smart contract written in Solidity, a high-level language for implementing smart contracts on the Ethereum blockchain. The contract is named `c5387` and it has a function `collectBuyFee`.\n\nHere's a high-level description of the function:\n\n1. The function `collectBuyFee` takes two parameters: `ethers`, which is a `uint` type (unsigned integer) and `affiliate`, which is an `address` type.\n\n2. It first calculates the `fee` for the transaction by calling the `feeWallet.getFee(ethers)` function.\n\n3. It then checks if the balance of the contract (`address(this).balance`) is greater than or equal to the amount of `ethers`. If it is, it sets `remaining` to `ethers`. Otherwise, it calculates the remaining amount by subtracting the balance from the total amount of `ethers` and sets `remaining` to this value.\n\n4. It then calls the `feeWallet.collect.value(fee)(affiliate",
        "gt": "contract c5387{ function collectBuyFee(uint ethers, address affiliate) internal returns(uint) { uint remaining; uint fee = feeWallet.getFee(ethers); if(SafeMath.safeSub(address(this).balance, ethers) >= fee) remaining = ethers; else remaining = SafeMath.safeSub(SafeMath.safeSub(ethers, address(this).balance), fee); feeWallet.collect.value(fee)(affiliate); return remaining; } }",
        "url": 352
    },
    {
        "code_input": "class Contract:\n    def __init__(self, logic_contract):\n        self.logic_contract = logic_contract\n\n    def _is_transfer_allowed(self, _from, _to, _token_id):\n        if self.logic_contract == '0x0000000000000000000000000000000000000000':\n            return True\n        else:\n            logic = HeroLogicInterface(self.logic_contract)\n            return logic.is_transfer_allowed(_from, _to, _token_id)",
        "gt": "contract c3545{ function _isTransferAllowed(address _from, address _to, uint256 _tokenId) internal view returns (bool) { if (logicContract == address(0)) { return true; } HeroLogicInterface logic = HeroLogicInterface(logicContract); return logic.isTransferAllowed(_from, _to, _tokenId); } }",
        "url": 353
    },
    {
        "code_input": "class C7227:\n    def __init__(self):\n        self.kyc_required = {}\n\n    def transfer_from(self, _from, _to, _value):\n        if not self.kyc_required.get(_from, False):\n            return super().transferFrom(_from, _to, _value)\n        else:\n            return False",
        "gt": "contract c7227{ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(!kycRequired[_from]); return super.transferFrom(_from, _to, _value); } }",
        "url": 354
    },
    {
        "code_input": "class WalletManager:\n    def __init__(self, wallets, roles, manager_powerful):\n        self.wallets = wallets\n        self.roles = roles\n        self.manager_powerful = manager_powerful\n\n    def change_wallet(self, wallet, role):\n        # Check if the caller is the owner or the first or the second role\n        if wallets[0][0] != msg.sender and wallets[",
        "gt": "contract c9349{ function changeWallet(address _wallet, uint8 _role) external { require(wallets[_role][0] == msg.sender || wallets[0][0] == msg.sender || (wallets[1][0] == msg.sender && managerPowerful)); emit WalletChanged(wallets[_role][0],_wallet,_role); uint16 roleMask = uint16(2)**_role; address[] storage tmp = wallets[_role]; for(uint8 i = 0; i < tmp.length; i++){ roles[tmp[i]] = roles[tmp[i]]&~roleMask; } delete wallets[_role]; tmp.push(_wallet); roles[_wallet] = roles[_wallet]|roleMask; } }",
        "url": 355
    },
    {
        "code_input": "class C26928:\n    def __init__(self, web3, admin_address):\n        self.web3 = web3\n        self.admin_address = admin_address\n\n    def withdraw_zrx(self, amount):\n        # Get the current balance of the admin\n        balance = self.web3.eth.getBalance(self.admin_address)\n\n        # Check if the admin has enough balance to withdraw\n        if self.web3.fromWei(balance, 'ether') < amount:\n            raise Exception('Admin does not have enough balance to withdraw')\n\n        # Transfer the tokens from the admin to the admin\n        self.web3.eth.sendTransaction({\n            'from': self.",
        "gt": "contract c26928{ function withdrawZRX(uint amount) public onlyAdmin { require(Token(ZRX_TOKEN_ADDR).transfer(admin, amount)); } }",
        "url": 356
    },
    {
        "code_input": "class TokenContract:\n    def __init__(self):\n        self.mintingFinished = False\n\n    def onlyWhenTransferEnabled(self, func):\n        def wrapper(*args, **kwargs):\n            if self.mintingFinished:\n                return func(*args, **kwargs)\n            else:\n                print(\"Minting is not finished. Only transfer is allowed.\")\n        return wrapper\n\n    @onlyWhenTransferEnabled\n    def transfer(self, recipient, amount):\n        # Logic to transfer tokens\n        pass\n\n    @onlyWhenTransferEnabled\n    def",
        "gt": "contract c13207{ modifier onlyWhenTransferEnabled() { require(mintingFinished); _; } }",
        "url": 357
    },
    {
        "code_input": "The given Solidity code is a contract for a decentralized application (dApp) that allows users to refund their investment. Here's a high-level description of the main functionality and logic:\n\n1. The contract is named `c3813`.\n2. The function `refund` is declared as public. This means that it can be called by anyone without any restrictions.\n3. The function `saleIsUnsuccessful` is a boolean variable that indicates whether the sale was successful or not.\n4. Inside the function, the `investedAmountOf` array is used to store the amount of each user's investment.\n5. The function `investedAmountOf[msg.sender]` is used to get the amount of the user's investment.\n6. The function `investedAmountOf[msg.sender]` is then set to 0, effectively refunding the user's investment.\n7. The `msg.sender.transfer(value)` line is used to send the user's investment back to the caller.\n8. The function `InvestmentReturned` is a custom event that is emitted when the",
        "gt": "contract c3813{ function refund() public saleIsUnsuccessful { uint value = investedAmountOf[msg.sender]; investedAmountOf[msg.sender] = 0; msg.sender.transfer(value); InvestmentReturned(msg.sender, value, now); } }",
        "url": 358
    },
    {
        "code_input": "class TaskContract:\n    def __init__(self, hardCapReached, isEnabled, startTime, endTime):\n        self.hardCapReached = hardCapReached\n        self.isEnabled = isEnabled\n        self.startTime = startTime\n        self.endTime = endTime\n\n    def isContribPeriodRunning(self):\n        return not self.hardCapReached and self.isEnabled and self.startTime <= self.now() and self.endTime > self.now()\n\n    def now(self):\n        # This is a placeholder for the actual implementation of the 'now' function.\n        # In a real-world scenario, 'now' would return the current timestamp.\n        return 1632181200  # This is a placeholder, replace with actual timestamp\n\n# Usage\ntask = TaskContract(False, True,",
        "gt": "contract c38416{ function isContribPeriodRunning() constant returns (bool) { return !hardCapReached && isEnabled && startTime <= now && endTime > now; } }",
        "url": 359
    },
    {
        "code_input": "class C8710:\n    def __init__(self, token_reward, stage):\n        self.token_reward = token_reward\n        self.stage = stage\n        self.status = None\n        self.available_ico = None\n        self.available_private_ico = None\n        self.available_pre_ico = None\n        self.available_ico_w1 = None\n        self.available_ico_w2 = None\n\n    def update_status_via_tokens(self):\n        self.available_ico = self.token_reward.balanceOf(self.address)\n        self.available_private_ico = self.token_reward.balanceOf(self.address)\n        self.available_pre_ico = self.token_reward.balanceOf(self.address)\n        self.available_ico_w1 = self.token_reward.balanceOf(self.address)",
        "gt": "contract c8710{ function updateStatusViaTokens() internal { availableICO = tokenReward.balanceOf(this); if (availablePrivateICO == 0 && stage == StagesList.PrivateICO) status = StatusList.Waiting; if (availablePreICO == 0 && stage == StagesList.PreICO) status = StatusList.Waiting; if (availableICO_w1 == 0 && stage == StagesList.ICO_w1) status = StatusList.Waiting; if (availableICO_w2 == 0 && stage == StagesList.ICO_w2) status = StatusList.Waiting; if (availableICO == 0) status = StatusList.Closed; } }",
        "url": 360
    },
    {
        "code_input": "class C1363:\n    def __init__(self, owner, whitelist={}):\n        self.owner = owner\n        self.whitelist = whitelist\n\n    def add_whitelisted_burn(self, address):\n        if self.owner == address:\n            self.whitelist[address] = True\n        else:\n            raise ValueError(\"Only the contract owner can add an address to the whitelist.\")\n\n# Example usage:\nc1363 = C1363('0x123456789012345678901234567890123456789",
        "gt": "contract c1363{ function addWhitelistedBurn(address _address) public onlyOwner { whitelistedBurn[_address] = true; } }",
        "url": 361
    },
    {
        "code_input": "The given Solidity code is a contract function `claimOwnership` that is used to transfer ownership of a post. The function takes in four parameters: `_appNickname`, `_postId`, `_gasPrice`, and `_gasLimit`.\n\nThe function first checks if the length of the `_postId` is greater than 0. If it is not, it throws an error.\n\nThen, it checks if the amount of Ether sent by the caller is greater than or equal to the product of `_gasPrice` and `_gasLimit`. If it is not, it throws an error.\n\nAfter these checks, the function uses the `oraclize_setCustomGasPrice` function to set the custom gas price.\n\nThe function then creates a string array `str` and populates it with the following values:\n\n- `apiUrl`\n- `_appNickname`\n- `\"/\"`\n- `_postId`\n- `\"/0x\"`\n- The address of the sender (`msg.sender`) converted to a string using the `__addressToString` function\n\nThe",
        "gt": "contract c9336{ function claimOwnership( string _appNickname, string _postId, uint _gasPrice, uint _gasLimit ) public payable { require(bytes(_postId).length > 0); require(msg.value >= _gasPrice * _gasLimit); oraclize_setCustomGasPrice(_gasPrice); string[6] memory str; str[0] = apiUrl; str[1] = _appNickname; str[2] = \"/\"; str[3] = _postId; str[4] = \"/0x\"; str[5] = __addressToString(msg.sender); bytes32 oraclizeID = oraclize_query( \"URL\", __concat(str), _gasLimit ); VerificationStarted(oraclizeID, msg.sender, _appNickname, _postId); __tempData[oraclizeID] = TempData(msg.sender, manager.getAppId(_appNickname)); } }",
        "url": 362
    },
    {
        "code_input": "The given Solidity code is a smart contract for a marketplace where users can buy and sell tokens. Here's a high-level description of the main functionality and logic:\n\n1. The contract has a function `buy(uint256 identifier)`. This function is external and payable, meaning it can be called by a user, and it can receive Ether.\n\n2. The function first checks if the `identifier` exists in the contract. If it does, it checks if the `identifier` is owned by a user. If the `identifier` is not owned by a user, it transfers the ownership to the user.\n\n3. It then checks if the user has enough Ether to buy the `identifier`. If the user does not have enough Ether, the transaction is reverted.\n\n4. The contract then calculates the new price for the `identifier`.\n\n5. The contract then transfers the `identifier` to the user who bought it.\n\n6. The contract also calculates the dividends paid and the fee, and transfers the user's winnings.\n\n7. The contract then calls a function to pay the dividends.",
        "gt": "contract c24780{ function buy(uint256 identifier) external payable whenNotPaused { require(identifierToOwner[identifier] != 0x0); address oldOwner = identifierToOwner[identifier]; uint256 price = identifierToPrice[identifier]; require(oldOwner != msg.sender); require(msg.value >= price); uint256 newPrice = nextPrice(price); identifierToPrice[identifier] = newPrice; _transfer(oldOwner, msg.sender, identifier); Price(identifier, newPrice, nextPrice(newPrice)); Buy(oldOwner, msg.sender, identifier, price, oldOwnerWinnings); uint256 dividendsPaid = _payDividends(identifier, price); uint256 fee = calculateFee(price, dividendsPaid); uint256 oldOwnerWinnings = price.sub(dividendsPaid).sub(fee); _shiftRecentBuyers(msg.sender); if (oldOwner != address(this)) { _sendFunds(oldOwner, oldOwnerWinnings); } uint256 excess = msg.value - price; if (excess > 0) { msg.sender.transfer(excess); } } }",
        "url": 363
    },
    {
        "code_input": "class Marketplace:\n    def __init__(self):\n        self.regions = {}\n        self.region_bids = {}\n\n    def get_region_price(self, region_id):\n        if self.regions[region_id].owner != '0x0000000000000000000000000000000000000000':\n            return self.region_bids[region_id].bid\n        elif self.region_bids[region_id].current_buyer != '0x0000000000000000000000000000000000000000':\n            return self.region_bids[region_id].bid +",
        "gt": "contract c12098{ function getRegionPrice(uint16 regionId) public view returns (uint256 next_bid) { if(regions[regionId].owner != address(0)) { return region_bids[regionId].bid; } if (region_bids[regionId].currentBuyer != address(0)) { next_bid = region_bids[regionId].bid + MINIMAL_RAISE; } else { next_bid = regions[regionId].startPrice; } } }",
        "url": 364
    },
    {
        "code_input": "class C11658:\n    def __init__(self, contract_owner, coo_address, promo_creation_limit, gen0_creation_limit):\n        self.contract_owner = contract_owner\n        self.coo_address = coo_address\n        self.promo_created_count = 0\n        self.gen0_created_count = 0\n        self.promo_creation_limit = promo_creation_limit\n        self.gen0_creation_limit = gen0_creation_limit\n\n    def create_promo_narco(self, _genes, _name, _owner):\n        if _owner == self.coo",
        "gt": "contract c11658{ function createPromoNarco( string _genes, string _name, address _owner ) public onlyCLevel { if (_owner == address(0)) { _owner = cooAddress; } require(promoCreatedCount < promoCreationLimit); require(gen0CreatedCount < gen0CreationLimit); promoCreatedCount++; gen0CreatedCount++; _createNarco(_genes, _name, _owner); } }",
        "url": 365
    },
    {
        "code_input": "class Token:\n    def __init__(self, owner, endAt, lowCapWei, hardCapWei, lowCapTxWei, hardCapTxWei):\n        self.owner = owner\n        self.endAt = endAt\n        self.lowCapWei = lowCapWei\n        self.hardCapWei = hardCapWei\n        self.lowCapTxWe",
        "gt": "contract c23397{ function tune(uint endAt_, uint lowCapWei_, uint hardCapWei_, uint lowCapTxWei_, uint hardCapTxWei_) onlyOwner isSuspended public { if (endAt_ > block.timestamp) { endAt = endAt_; } if (lowCapWei_ > 0) { lowCapWei = lowCapWei_; } if (hardCapWei_ > 0) { hardCapWei = hardCapWei_; } if (lowCapTxWei_ > 0) { lowCapTxWei = lowCapTxWei_; } if (hardCapTxWei_ > 0) { hardCapTxWei = hardCapTxWei_; } require(lowCapWei <= hardCapWei && lowCapTxWei <= hardCapTxWei); touch(); } }",
        "url": 366
    },
    {
        "code_input": "class C20978:\n    def __init__(self, override=None):\n        self.override = override\n\n    def set_override(self, new_override):\n        if not self.is_override(new_override):\n            raise ValueError(\"The new override address is not the current override\")\n        self.override = new_override\n\n    def is_override(self, address):\n        # This is a placeholder for the actual function that checks if the address is the override\n        # In a real-world scenario, this function would interact with the blockchain to check if the address is the override\n        return address == self.override",
        "gt": "contract c20978{ function setOverride(address _newOverride) public onlyBy(override) returns(bool) { override = _newOverride; EventNotification(msg.sender, INFO_EVENT, \"Set new override\"); return true; } }",
        "url": 367
    },
    {
        "code_input": "The given Solidity contract is a function that allows a user to approve multiple tokens for a specific address. Here's a high-level description of the main functionality and logic of the code:\n\n1. The function `approveMany` is declared as `external`, which means it is a function that can only be called by external contracts.\n\n2. The function takes two parameters: `_to`, which is the address to which the tokens will be approved, and `_tokenIds`, which is an array of token IDs to be approved.\n\n3. The function uses a for loop to iterate over the `_tokenIds` array.\n\n4. For each token ID in the array, the function first checks if the caller of the function owns the token. If the caller does not own the token, the function will revert the transaction.\n\n5. The function then sets the `partIndexToApproved` mapping for the token ID to the address of the `_to` parameter.\n\n6. The function then calls the `Approval` function, which is a function that is used to approve a spender to a certain amount of tokens.\n\n",
        "gt": "contract c23690{ function approveMany(address _to, uint256[] _tokenIds) external whenNotPaused payable { for (uint i = 0; i < _tokenIds.length; i++) { uint _tokenId = _tokenIds[i]; require(owns(msg.sender, _tokenId)); partIndexToApproved[_tokenId] = _to; Approval(msg.sender, _to, _tokenId); } } }",
        "url": 368
    },
    {
        "code_input": "def buyToken(self):\n    # This is a placeholder for the actual logic to buy the token.\n    # The actual implementation would depend on the",
        "gt": "contract c15078{ function buy() payable public { require(!frozenAccount[msg.sender]); require(msg.value > 0); buyToken(); } }",
        "url": 369
    },
    {
        "code_input": "class Contract:\n    def __init__(self, tokenDistribution):\n        self.tokenDistribution = tokenDistribution\n\n    def finalization(self):\n        # Call the function to return unsold tokens to the wallet\n        self.tokenDistribution.returnUnsoldTokens(wallet)\n\n# Example usage:\nclass TokenDistribution:\n    def returnUnsoldTokens(self, wallet):\n        # Logic to return unsold tokens to the wallet\n        pass\n\ncontract = Contract(TokenDistribution())\ncontract.finalization()",
        "gt": "contract c25941{ function finalization() internal { super.finalization(); tokenDistribution.returnUnsoldTokens(wallet); } }",
        "url": 370
    },
    {
        "code_input": "The given Solidity code is a contract for a poll system. The contract has a function `startPoll` that creates a new poll with a given vote quorum, commit duration, and reveal duration. The function is public, meaning it can be called by anyone.\n\nThe function takes three parameters: `_voteQuorum`, `_commitDuration`, and `_revealDuration`. These parameters are used to configure the poll.\n\nThe function starts by incrementing a nonce (a counter) for the poll. This nonce is then used to store the poll data in a map.\n\nThe `commitEndDate` is set to the current timestamp plus the `_commitDuration`. This is the date and time when the poll will be closed for voting.\n\nThe `revealEndDate` is set to the `commitEndDate` plus `_revealDuration`. This is the date and time when the results of the poll will be revealed.\n\nThe function then creates a new poll object with the given parameters and stores it in the poll map.\n\nThe function also emits an event with the poll details, indicating that a new poll has been created.\n",
        "gt": "contract c9850{ function startPoll(uint _voteQuorum, uint _commitDuration, uint _revealDuration) public returns (uint pollID) { pollNonce = pollNonce + 1; uint commitEndDate = block.timestamp.add(_commitDuration); uint revealEndDate = commitEndDate.add(_revealDuration); pollMap[pollNonce] = Poll({ voteQuorum: _voteQuorum, commitEndDate: commitEndDate, revealEndDate: revealEndDate, votesFor: 0, votesAgainst: 0 }); emit _PollCreated(_voteQuorum, commitEndDate, revealEndDate, pollNonce, msg.sender); return pollNonce; } }",
        "url": 371
    },
    {
        "code_input": "class C16524:\n    def __init__(self, contract):\n        self.contract = contract\n\n    def set_max_stage2_allocation_per_investor(self, _cap):\n        \"\"\"\n        This function sets the maximum stage 2 allocation per investor.\n\n        :param _cap: The maximum stage 2 allocation per investor.\n        :type _cap: uint256\n        \"\"\"\n        # Check if the function is callable by the controller\n        if not self.contract.is_controller(msg.sender):\n            raise ValueError(\"Only the contract controller can call this function.\")\n\n        # Set the maximum stage 2 allocation per investor\n        self",
        "gt": "contract c16524{ function setMaxStage2AllocationPerInvestor(uint256 _cap) public onlyController { maxStage2AllocationPerInvestor = _cap; } }",
        "url": 372
    },
    {
        "code_input": "The given Solidity contract is a function that retrieves the indices of auctions where a user has claimable tokens for sellers. The function is named `getIndicesWithClaimableTokensForSellers`.\n\nHere's a high-level description of the function's main logic:\n\n1. It first calculates the `runningAuctionIndex`, which is the index of the last auction.\n2. It then calculates the `startingIndex`, which is either 1 (if `lastNAuctions` is 0) or `runningAuctionIndex - lastNAuctions + 1` (otherwise).\n3. It then iterates over the auctions from `startingIndex` to `runningAuctionIndex`.\n4. For each auction, it checks if the user has any claimable tokens for sellers.\n5. If the user has claimable tokens, it increments the `arrayLength` and stores the auction index and user's balance in the `indices` and `usersBalances` arrays.\n6. Finally, it returns the `indices` and `usersBalances` arrays.\n\nHere's a Python code that",
        "gt": "contract c7497{ function getIndicesWithClaimableTokensForSellers( address auctionSellToken, address auctionBuyToken, address user, uint lastNAuctions ) external view returns(uint[] indices, uint[] usersBalances) { uint runningAuctionIndex = getAuctionIndex(auctionSellToken, auctionBuyToken); uint arrayLength; uint startingIndex = lastNAuctions == 0 ? 1 : runningAuctionIndex - lastNAuctions + 1; for (uint j = startingIndex; j <= runningAuctionIndex; j++) { if (sellerBalances[auctionSellToken][auctionBuyToken][j][user] > 0) { arrayLength++; } } indices = new uint[](arrayLength); usersBalances = new uint[](arrayLength); uint k; for (uint i = startingIndex; i <= runningAuctionIndex; i++) { if (sellerBalances[auctionSellToken][auctionBuyToken][i][user] > 0) { indices[k] = i; usersBalances[k] = sellerBalances[auctionSellToken][auctionBuyToken][i][user]; k++; } } } }",
        "url": 373
    },
    {
        "code_input": "class C25382:\n    def __init__(self):\n        self.QUOTE_ASSET = \"0x0000000000000000000000000000000000000000\"\n\n    def get_quote_asset(self):\n        return self.QUOTE_ASSET",
        "gt": "contract c25382{ function getQuoteAsset() view returns (address) { return QUOTE_ASSET; } }",
        "url": 374
    },
    {
        "code_input": "class Contract:\n    def __init__(self, owner, contract_address):\n        self.owner = owner\n        self.contract_address = contract_address\n        self.security_check_uri = None\n\n    def set_security_check(self, _uri):\n        if self.owner == self.contract_address:\n            self.security_check_uri = _uri\n        else:\n            raise ValueError(\"Only the contract owner can set the security check URI.\")",
        "gt": "contract c38777{ function setSecurityCheck(string _uri) onlyOwner { securityCheckURI = _uri; } }",
        "url": 375
    },
    {
        "code_input": "class C29893:\n    def __init__(self):\n        pass\n\n    def howManyTokensForEther(self, weiAmount):\n        # Convert the amount from wei to ether\n        ether = weiAmount / 10**18\n\n        # Calculate the number of tokens\n        tokens = ether\n\n        # Calculate the excess\n        excess = 0\n\n        return tokens, excess",
        "gt": "contract c29893{ function howManyTokensForEther(uint256 weiAmount) constant returns(uint256 tokens, uint256 excess) { weiAmount; tokens; excess; } }",
        "url": 376
    },
    {
        "code_input": "class C15321:\n    def __init__(self):\n        self.m_sales = {}\n\n    def set_sale(self, account, is_sale):\n        if account in self.m_sales:\n            self.m_sales[account] = is_sale\n        else:\n            raise ValueError(f\"Account {account} does not exist\")",
        "gt": "contract c15321{ function setSale(address account, bool isSale) external validAddress(account) privilegedAllowed onlymanyowners(keccak256(msg.data)) { m_sales[account] = isSale; } }",
        "url": 377
    },
    {
        "code_input": "class C13315:\n    def __init__(self, devCutPromille):\n        self.devCutPromille = devCutPromille\n\n    def return_developers_cut(self, _price):\n        return _price * self.devCutPromille // 1000",
        "gt": "contract c13315{ function returnDevelopersCut(uint256 _price) private view returns(uint) { return _price.mul(devCutPromille).div(1000); } }",
        "url": 378
    },
    {
        "code_input": "class ERC20:\n    def __init__(self):\n        self.functions = {}\n\n    def increase_approval_and_call(self, _spender, _added_value, _data):\n        if _spender == self.address:\n            raise ValueError(\"_spender cannot be the contract address\")\n        super().increase_approval(_spender, _added_value)\n        if _spender.call(_data):\n            return True\n        else:\n            raise ValueError(\"Failed to call _spender\")\n\n    def increase_approval(self, _spender, _added_value):\n        if _spender == self.address:\n            raise ValueError(\"_spender cannot be the contract address\")\n        super().increase_approval(_spender, _added_value)",
        "gt": "contract c9001{ function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.increaseApproval(_spender, _addedValue); require(_spender.call.value(msg.value)(_data)); return true; } }",
        "url": 379
    },
    {
        "code_input": "class C16209:\n    def __init__(self):\n        self.authorized = {}\n\n    def set_authorization(self, user, authorized):\n        self.authorized[user] = authorized\n\n    def is_authorized(self, user):\n        return self.authorized.get(user, False)\n\n    def only_authorized(self, func):\n        def wrapper(*args, **kwargs):\n            if not self.is_authorized(msg.sender):\n                print(\"User is not authorized to call this function\")\n            else:\n                return func(*args, **kwargs)\n        return wrapper\n\n    @only_authorized\n    def my_function(self):\n        print(\"This function is only accessible to authorized users\")",
        "gt": "contract c16209{ modifier onlyAuthorized() { require(authorized[msg.sender]); _; } }",
        "url": 380
    },
    {
        "code_input": "class Contract:\n    def __init__(self, gas_cost):\n        self.gas_cost = gas_cost\n\n    def set_deposit_gas_cost(self, gas_cost):\n        self.gas_cost = gas_cost",
        "gt": "contract c16217{ function setDepositGasCost(uint8 gasCost) public onlyAuthorized { depositGasCost = gasCost; } }",
        "url": 381
    },
    {
        "code_input": "The given Solidity contract is a simple ERC20 token contract that allows transfers of tokens from one account to another. Here's a high-level description of the main functionality and logic:\n\n1. The contract is a public contract, meaning it can be accessed and modified by anyone.\n2. The `transfer` function is a public function that allows transferring tokens from the sender's account to a specified recipient.\n3. The function takes two parameters: `_to`, the address of the recipient, and `_value`, the amount of tokens to transfer.\n4. The function first checks if the `_value` is greater than 0, and if `_to` is not the address of 0 (the zero address), and if the sender is not the recipient, and if the sender's balance is greater than or equal to `_value`.\n5. It also checks that the recipient's balance will be increased by `_value` after the transfer, and that the recipient's balance will be increased by `_value` after the transfer.\n6. The function also checks that neither the sender nor the recipient is frozen.\n7. If all these conditions are",
        "gt": "contract c10908{ function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) { require( _value > 0 ); require(_to != address(0)); require(msg.sender != _to ); require(balanceOf[msg.sender] >= _value); require(SafeMath.add(balanceOf[_to],_value) > balanceOf[_to]); require(!frozenAccount[msg.sender]); require(!frozenAccount[_to]); uint256 previousBalances = balanceOf[msg.sender] + balanceOf[_to]; balanceOf[msg.sender] = SafeMath.sub(balanceOf[msg.sender],_value); balanceOf[_to] = SafeMath.add(balanceOf[_to],_value); emit Transfer(msg.sender, _to, _value); assert(balanceOf[msg.sender] + balanceOf[_to] == previousBalances); return true; } }",
        "url": 382
    },
    {
        "code_input": "class ERC20Interface:\n    def __init__(self, _token_address):\n        self._token_address = _token_address\n\n    def transfer(self, to, amount):\n        # This is a placeholder for the actual function call to the ERC20 contract\n        # It would depend on the specific ERC20 contract implementation\n        return True\n\n\nclass Contract:\n    def __init__(self, owner):\n        self.owner = owner\n\n    def transferAnyERC20Token(self, _token_address, _amount):\n        # Check if the owner has enough balance to transfer\n        if ERC20Interface(_token_address).transfer(self.owner, _amount):\n            return True\n        else:\n            return False",
        "gt": "contract c10120{ function transferAnyERC20Token(address _token_address, uint _amount) public onlyOwner returns (bool success) { return ERC20Interface(_token_address).transfer(owner, _amount); } }",
        "url": 383
    },
    {
        "code_input": "class Contract:\n    def __init__(self):\n        self.is_paused = False\n\n    def freeze(self):\n        self.is_paused = True\n        print(\"Contract is now paused.\")\n\n    def unfreeze(self):\n        self.is_paused = False\n        print(\"Contract is now unpaused.\")\n\n    def is_paused(self):\n        return self.is_paused\n\ncontract = Contract()\n\n# Calling freeze function\ncontract.freeze",
        "gt": "contract c11384{ function freeze() external managerOnly { RCD.pause(); } }",
        "url": 384
    },
    {
        "code_input": "class TokenContract:\n    def __init__(self, contract_address):\n        self.contract_address = contract_address\n\n    def transfer_from(self, _from, _to, _value):\n        # This is a placeholder for the actual function.\n        # The actual function would depend on the Ethereum network and the contract's ABI.\n        # For example, if the contract is a ERC20 token, the function would look like this:\n        #\n        # def transfer_from(self, _from, _to, _value):\n        #     return self.contract_address.functions.transferFrom(_from, _to, _value).call()\n\n        # If the contract is not a ERC20 token, the function would look like this:\n        #",
        "gt": "contract c31551{ function transferFrom(address _from, address _to, uint256 _value) public tradingOpen returns (bool) { return super.transferFrom(_from, _to, _value); } }",
        "url": 385
    },
    {
        "code_input": "class Token:\n    def __init__(self):\n        self.locked = False\n\n    def lock(self):\n        self.locked = True\n\n    def unlock(self):\n        self.locked = False\n\n    def when_locked(self, func):\n        def wrapper(*args, **kwargs):\n            if not self.locked:\n                return func(*args, **kwargs)\n            else:\n                print(\"The contract is locked.\")\n        return wrapper\n\n    @when_locked\n    def some_function(self):\n        print(\"Function called.\")\n\n# Usage\ntoken = Token()\ntoken.lock()\ntoken.some_function()  # This will print \"Function called.\"\ntoken.unlock()\ntoken.some_function()  # This will print \"The contract is locked.\"",
        "gt": "contract c30512{ modifier whenLocked() { require(locked); _; } }",
        "url": 386
    },
    {
        "code_input": "class EthereumRefund:\n    def __init__(self, contract_stage, owner, receiver_address, contribution_min, eth_refund_amount, eth_refund_received):\n        self.contract_stage = contract_stage\n        self.owner = owner\n        self.receiver_address = receiver_address\n        self.contribution_min = contribution_min\n        self.eth_refund_amount = eth_refund_amount\n        self.eth_refund_received = eth_refund_received\n\n    def _ethRefund(self, msg):\n        if self.contract_stage != 3:\n            return \"Contract stage is not 3\"\n        if msg.sender != self.owner and msg.sender != self.receiver_address:",
        "gt": "contract c15244{ function _ethRefund () internal { assert (contractStage == 3); require (msg.sender == owner || msg.sender == receiverAddress); require (msg.value >= contributionMin); ethRefundAmount.push(msg.value); EthRefundReceived(msg.sender, msg.value); } }",
        "url": 387
    },
    {
        "code_input": "class Contract:\n    def __init__(self, owner, total_supply):\n        self.owner = owner\n        self.bonus_pool = 0\n        self.bonus_num = 0\n        self.bonus_per = []\n        self.total_supply = total_supply\n\n    def owner_bonusSend(self, value):\n        if self.owner == msg.sender and self.bonus_num < 30:\n            self.bonus_pool += value\n            self.bonus_num += 1\n            self.bonus_per.append(value / self.total_supply)\n\n# Example usage:\ncontract = Contract('0x...', 1000000)  # replace with actual owner and total supply\ncontract.owner_bonusSend(",
        "gt": "contract c29678{ function owner_bonusSend () public payable { if (msg.sender == owner && bonusNum < 30){ bonusPool += msg.value; bonusNum ++; bonusPer[bonusNum] = msg.value/totalSupply; } } }",
        "url": 388
    },
    {
        "code_input": "class C11024:\n    def __init__(self, rate, rate_second_tier):\n        self.rate = rate\n        self.rate_second_tier = rate_second_tier\n\n    def _get_token_amount(self, wei_amount):\n        if wei_amount >= 0.1:\n            rate = self.rate\n        else:\n            rate = self.rate_second_tier\n\n        bfex = wei_amount * rate\n        return bfex",
        "gt": "contract c11024{ function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) { uint256 _rate; if (_weiAmount >= 0.1 ether && _weiAmount < 1 ether ) { _rate = rate; } else if (_weiAmount >= 1 ether ) { _rate = rateSecondTier; } uint256 bfex = _weiAmount.mul(_rate); return bfex; } }",
        "url": 389
    },
    {
        "code_input": "The given Solidity contract is a withdrawal function for a smart contract. It's named `c14671` and it's an external function. The function `withdrawEth` is used to withdraw Ether from a user's account.\n\nHere's a high-level description of the function's main logic:\n\n1. The function first checks if the `traderAddr` is zero. If it is, it reverts the transaction. This is to prevent any potential loss of funds.\n\n2. The function then checks if the length of the `msg.data` is not 4 + 32. This is to ensure that the function call is in the correct format.\n\n3. It then converts the `traderAddr` to a `uint176` (16 bytes) type.\n\n4. It then checks if the `amountE8` (Ether) associated with the `accountKey` is zero. If it is, it returns.\n\n5. It sets `amountE8` to 0.\n\n6. It then calculates the `truncatedWei`, which is the amount of Ether",
        "gt": "contract c14671{ function withdrawEth(address traderAddr) external { if (traderAddr == 0) revert(); if (msg.data.length != 4 + 32) revert(); uint176 accountKey = uint176(traderAddr); uint amountE8 = accounts[accountKey].pendingWithdrawE8; if (amountE8 == 0) return; accounts[accountKey].pendingWithdrawE8 = 0; uint truncatedWei = amountE8 * (ETH_SCALE_FACTOR / 10**8); address withdrawAddr = traders[traderAddr].withdrawAddr; if (withdrawAddr == 0) withdrawAddr = traderAddr; withdrawAddr.transfer(truncatedWei); emit WithdrawEvent(traderAddr, 0, \"ETH\", uint64(amountE8), exeStatus.lastOperationIndex); } }",
        "url": 390
    },
    {
        "code_input": "def safe_deduct(a, b):\n    if a < b:\n        return 0\n    else:\n        return a - b",
        "gt": "contract c7593{ function safeDeduct(uint _a, uint _b) pure public returns(uint) { if (_a < _b) return 0; return (_a - _b); } }",
        "url": 391
    },
    {
        "code_input": "class TokenSale:\n    def __init__(self, contract_address, beneficiary_address, price):\n        self.contract_address = contract_address\n        self.beneficiary_address = beneficiary_address\n        self.price = price\n\n    def buy_tokens(self, amount):\n        # This is a placeholder for the actual function.\n        # It would be a function in the ERC20 contract that allows the buyer to buy tokens.\n        # The actual implementation would depend on the specific ERC20 contract.\n        # For the purpose of this example, we'll just return a success message.\n        return \"Tokens bought successfully\"\n\n    def gift_tokens(self, beneficiary_address):\n        # This function is used to gift tokens to the beneficiary.\n        # The actual implementation would",
        "gt": "contract c29550{ function buyTokens(address beneficiary) public payable { super.buyTokens(beneficiary); giftTokens(beneficiary); } }",
        "url": 392
    },
    {
        "code_input": "class SimpleContract:\n    def __init__(self):\n        self.balances = {}\n\n    def balanceOf(self, _owner):\n        return self.balances.get(_owner, 0)",
        "gt": "contract c31467{ function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } }",
        "url": 393
    },
    {
        "code_input": "class DeveloperContract:\n    def __init__(self, contract):\n        self.contract = contract\n\n    def set_developer_status(self, _address, status):\n        \"\"\"\n        This function allows a user to set the status of a developer.\n        The status is stored in a mapping where the address of the developer is the key.\n        \"\"\"\n        # Check if the caller is the owner of the contract\n        if self.contract.caller.balance < web3.toWei(1, 'ether'):\n            raise Exception(\"Only the contract owner can set developer status.\")\n\n        # Check if the address is a valid Ethereum address\n        if not web3.isAddress(_address):\n            raise Exception(\"Invalid address.\")",
        "gt": "contract c18337{ function setDeveloperStatus (address _address, bool status) onlyOwner public { developers[_address] = status; emit DeveloperStatusChanged(_address, status); } }",
        "url": 394
    },
    {
        "code_input": "class RabbitContract:\n    def __init__(self, contract_instance):\n        self.contract_instance = contract_instance\n\n    def set_rabbit_data(self, token_id, explosive, endurance, nimble, task_id, v, r, s):\n        # Check if the task ID is not used\n        if self.contract_instance.usedSignId[task_id] == 0:\n            # Get the auction data for the token ID\n            auction = self.contract_instance.tokenIdToAuction[token_id]\n            # Check if the auction has not",
        "gt": "contract c18918{ function setRabbitData( uint _tokenId, uint32 _explosive, uint32 _endurance, uint32 _nimble, uint _taskId, uint8 v, bytes32 r, bytes32 s ) external { require(usedSignId[_taskId] == 0); Auction storage auction = tokenIdToAuction[_tokenId]; require (auction.startedAt == 0); uint[5] memory arr = [_tokenId, _explosive, _endurance, _nimble, _taskId]; string memory text = uint5ToStr(arr); address signer = verify(text, v, r, s); require(signer == cooAddress); RabbitData storage rdata = rabbits[_tokenId]; rdata.explosive = _explosive; rdata.endurance = _endurance; rdata.nimble = _nimble; rabbits[_tokenId] = rdata; usedSignId[_taskId] = 1; emit UpdateComplete(msg.sender, _tokenId); } }",
        "url": 395
    },
    {
        "code_input": "class C10549:\n    def __init__(self, contract_instance):\n        self.contract_instance = contract_instance\n        self.wallet_balances = {}\n        self.user_ids = {}\n        self.balances = {}\n\n    def send_to(self, user, amount):\n        sender = self.contract_",
        "gt": "contract c10549{ function sendTo(address _user, uint64 _amount) external { require(walletBalances[msg.sender] >= _amount); walletBalances[msg.sender] -= _amount; if (userIds[_user] > 0) { balances[userIds[_user]] += _amount; } else { walletBalances[_user] += _amount; } emit Deposit(_user, _amount); } }",
        "url": 396
    },
    {
        "code_input": "class TokenSale:\n    def __init__(self, owner, price_per_token):\n        self.owner = owner\n        self.price_per_token = price_per_token\n        self.preico_addresses = {}\n\n    def set_preico_address(self, preico_address, price_per_token):\n        if self.owner != preico_address:\n            raise ValueError(\"Only the owner can set the address of a preico.\")\n        self.preico_addresses[preico_address] = price_per_token",
        "gt": "contract c18677{ function setPreicoAddress(address preicoAddress, uint pricePerToken) public onlyOwner { preicoAddresses[preicoAddress] = pricePerToken; } }",
        "url": 397
    },
    {
        "code_input": "from datetime import datetime, timedelta\n\nclass Token:\n    def __init__(self, buyPrice_wie, sell_ppc, dailyGrowth_ppm):\n        self.buyPrice_wie = buyPrice_wie\n        self.sell_ppc = sell_ppc\n        self.dailyGrowth_ppm = dailyGrowth_ppm\n        self.dailyGrowthUpdated_date = None\n\n    def adjustPrice(self):\n        if self.dailyGrowthUpdated_date is None or",
        "gt": "contract c37476{ modifier adjustPrice() { if ( (dailyGrowthUpdated_date + 1 days) < now ) { dailyGrowthUpdated_date = now; buyPrice_wie = buyPrice_wie * (1000000 + dailyGrowth_ppm) / 1000000; sellPrice_wie = buyPrice_wie * sell_ppc / 100; PriceAdjusted(buyPrice_wie, sellPrice_wie); } _; } }",
        "url": 398
    },
    {
        "code_input": "def multi_freeze_with_timestamp(contract, targets, timestamps):\n    if len(targets) != len(timestamps):\n        raise ValueError(\"Targets and timestamps arrays must be the same length\")\n\n    for i in range(len(targets)):\n        contract.frozenAccount[targets[i]] = timestamps[i]\n\n    return True",
        "gt": "contract c3064{ function multiFreezeWithTimestamp(address[] targets,uint256[] timestamps)public onlyOwner returns (bool) { uint256 len = targets.length; require(len > 0); require(len == timestamps.length); for (uint256 i = 0; i < len; i = i.add(1)) { frozenAccount[targets[i]] = timestamps[i]; } return true; } }",
        "url": 399
    },
    {
        "code_input": "def update_payout(contract, owner):\n    # Get the list of tokens owned by the owner\n    tokens = contract.functions.ownedTokens(owner).call()\n\n    # Initialize the total owed\n    total_owed = 0\n\n    # For each token\n    for token in tokens:\n        # Calculate the total payout amount\n        total_payout = contract.functions.poolTotal().call() * contract.functions.burritoData(token).call().values()['payout'] / 10000\n\n        # Calculate the amount owed to the token\n        o",
        "gt": "contract c24911{ function updatePayout(address _owner) public { uint256[] memory burritos = ownedTokens[_owner]; uint256 owed; for (uint256 i = 0; i < burritos.length; i++) { uint256 totalBurritoOwed = poolTotal * burritoData[burritos[i]].payout / 10000; uint256 burritoOwed = totalBurritoOwed.sub(burritoData[burritos[i]].withdrawn); owed += burritoOwed; burritoData[burritos[i]].withdrawn += burritoOwed; } payoutBalances[_owner] += owed; } }",
        "url": 400
    },
    {
        "code_input": "class C2276:\n    def __init__(self, web3, address):\n        self.web3 = web3\n        self.address = address\n        self.contract = self.web3.eth.contract(address=address, abi='...')  # Replace with the actual ABI of the contract\n\n    def withdraw_plat(self):\n        balance = self.contract.functions.balanceOf(self.address).call()\n        self.contract.functions.transfer(msg.sender, balance).transact()",
        "gt": "contract c2276{ function withdrawPLAT() public onlyOwner payable { uint balance = PLAT.balanceOf(this); PLAT.transfer(msg.sender, balance); } }",
        "url": 401
    },
    {
        "code_input": "class Contract:\n    def __init__(self, contract_address, contract_abi, web3):\n        self.contract_address = contract_address\n        self.contract_abi = contract_abi\n        self.web3 = web3\n        self.contract = self.web3.eth.contract(address=self.contract_address, abi=self.contract_abi)\n\n    def check_if_all_art_distributed(self):\n        # Get the total number of contributors\n        total_contributors = self.contract.functions.contributorCount().call()\n\n        # Initialize a flag to track if all ART tokens are distributed\n        all_art_distributed = True\n\n        # Iterate over each contributor\n        for i in range(total_cont",
        "gt": "contract c29740{ function checkIfAllARTDistributed() public { address currentParticipantAddress; isARTDistributed = true; for (uint index = 0; index < contributorCount; index++){ currentParticipantAddress = contributorIndexes[index]; if (false == contributorList[currentParticipantAddress].isTokenDistributed){ isARTDistributed = false; break; } } } }",
        "url": 402
    },
    {
        "code_input": "class Node:\n    def __init__(self, cid, next=None):\n        self.cid = cid\n        self.next = next\n\nclass ContributorChain:\n    def __init__(self):\n        self.head = None\n        self.balance = 0\n        self.nodes = {}\n\n    def add_contributor(self, cid):\n        node = Node(cid)\n        if self.head is None:\n            self.head = node\n        else:\n            last = self.head\n            while last.next:\n                last = last.next\n            last.next = node\n        self.balance += 1\n        self.nodes[self.balance] = node\n\n    def get_contributors(self):\n        if self.balance > 0:\n            contributors = []",
        "gt": "contract c9370{ function contributors() public view returns(uint256[]) { uint256 count; uint256 index; uint256 next; index = 0; next = contributorChain.head; count = contributorChain.balance; if (count > 0) { uint256[] memory result = new uint256[](count); while(next != 0 && index < count) { result[index] = contributorChain.nodes[next].cid; next = contributorChain.nodes[next].next; index++; } return result; } else { return new uint256[](0); } } }",
        "url": 403
    },
    {
        "code_input": "class ERC20:\n    def __init__(self, contract_address):\n        self.contract_address = contract_address\n\n    def allowance(self, owner, spender):\n        # The function allowance(address _owner, address _spender)\n        # This function returns the remaining allowance of the owner\n        # on the spender contract.\n\n        # The function is defined as constant, so it doesn't modify the state\n        # of the contract, and it doesn't return a value.\n\n        # The function is not implemented in the contract, so it's not possible\n        # to get the allowance of the owner on the spender contract.\n        # In a real-world contract, this function would need to interact\n        # with the contract's storage to get the allowance.\n\n        # In this example, we'",
        "gt": "contract c36942{ function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } }",
        "url": 404
    },
    {
        "code_input": "The given Solidity code is a function that allows a user to add tokens to return. This function is called `addTokensToReturn`. The function takes four parameters: the address of the user, the address of the token, the value of the token to be added, and a boolean value indicating whether the user is buying tokens or not.\n\nHere's a high-level description of the function's main logic:\n\n1. The function first checks if the price of the token is greater than 0. If it is, it means that the token is valid and can be bought.\n\n2. If the user is buying tokens, the function calculates the number of tokens the user wants to buy based on the token value and the price of the token.\n\n3. The function then burns the calculated number of tokens from the user's balance.\n\n4. The function adds the number of tokens bought to the user's balance.\n\n5. The function then transfers the tokens to the user's address.\n\n6. The function also updates the user's tokens value in the `userTokensValues` array.\n\n7. Finally, the function calls the `addToken",
        "gt": "contract c28549{ function addTokensToReturn(address _user, address _token, uint _tokenValue, bool _buyTokens) public onlyManager { assert(tokenPrice[_token] > 0); if (_buyTokens) { uint boughtTokens = getTokensAmountByTokens(_token, _tokenValue); burnTokens(boughtTokens); balances[_user] = add(balances[_user], boughtTokens); BuyTokensWithTokens(_user, _token, _tokenValue, boughtTokens); } userTokensValues[_user][_token] = add(userTokensValues[_user][_token], _tokenValue); addTokenToUser(_user, _token); addUserToList(_user); } }",
        "url": 405
    },
    {
        "code_input": "class C2013:\n    def __init__(self):\n        self.status = None\n\n    def start_auction(self):\n        if self.status != 'pending':\n            raise ValueError('The status is not pending')\n        self.status = 'active'\n        print(f'Auction started at block number {block.number}')\n\n# Usage\nc2013 = C2013()\nc2013.start_auction()",
        "gt": "contract c2013{ function startAuction() public onlyOwner{ require(status == state.pending); status = state.active; emit Started(block.number); } }",
        "url": 406
    },
    {
        "code_input": "class Token:\n    def __init__(self, owner):\n        self.owner = owner\n        self.tokenFrozenSinceBlock = (2 ** 256) - 1\n        self.tokenFrozenSinceNotice = None\n\n    def unfreezeTransfersSince(self, _unfreezeNotice):\n        self.tokenFrozenSinceNotice = _un",
        "gt": "contract c16910{ function unfreezeTransfersSince(string _unfreezeNotice) onlyOwner public returns(bool success){ tokenFrozenSinceBlock = (2 ** 256) - 1; tokenFrozenSinceNotice = _unfreezeNotice; emit TokenFrozenSince((2 ** 256) - 1, _unfreezeNotice); return true; } }",
        "url": 407
    },
    {
        "code_input": "class TokenSale:\n    def __init__(self, owner, token_generation_min):\n        self.owner = owner\n        self.token_generation_min = token_generation_min\n        self.sale_completed = False\n        self.end_block = 0\n        self.reserve_balance = 0\n\n    def finalize(self, total_tokens):\n        if not self",
        "gt": "contract c38407{ function finalize() onlyOwner { require( (!saleCompleted) && (totalTokens >= tokenGenerationMin) ); saleCompleted = true; end_block = block.number; reserveBalance = safeDiv(safeMul(this.balance, percentageETHReserve), 100); var withdrawalBalance = safeSub(this.balance, reserveBalance); msg.sender.transfer(withdrawalBalance); } }",
        "url": 408
    },
    {
        "code_input": "def get_middle_round_points(size, round, brackets):\n    team_id = 0\n    middle_round_results = 0\n    for i in range(size):\n        team_id = brackets & 0xFF\n        if bracketsResults['middlePhaseTeamsIds'][team_id] >= round:\n            middle_round_results += 60\n        brackets >>= 5\n    return middle_round_results",
        "gt": "contract c13665{ function getMiddleRoundPoints(uint8 size, teamState round, uint160 brackets) internal view returns(uint16 middleRoundResults){ uint8 teamId; for (uint i = 0; i < size; i++){ teamId = uint8(brackets & RESULT_MASK_BRACKETS); if (uint(bracketsResults.middlePhaseTeamsIds[teamId]) >= uint(round) ) { middleRoundResults+=60; } brackets = brackets >> 5; } } }",
        "url": 409
    },
    {
        "code_input": "class Contract:\n    def __init__(self, owner, balance):\n        self.owner = owner\n        self.balance = balance\n\n    def reclaim_ether(self, beneficiary):\n        if self.owner != beneficiary:\n            raise ValueError(\"Only the contract owner can reclaim Ether.\")\n        if self.balance == 0:\n            raise ValueError(\"The contract is already empty.\")\n        self.balance = 0\n        beneficiary.transfer(self.balance)",
        "gt": "contract c22959{ function reclaimEther(address _beneficiary) external onlyOwner { _beneficiary.transfer(this.balance); } }",
        "url": 410
    },
    {
        "code_input": "class C22160:\n    def __init__(self):\n        self.whitelist_bonus_percentage = 0\n        self.whitelist_principle_lock_percentage = 0\n        self.whitelist_bonus_lock_period = 0\n        self.whitelist_principle_lock_period = 0\n        self.early_participant_wei_price = 0\n\n    def set_default_whitelist_vesting_parameters(self, bonus_percentage, principle_lock_percentage, bonus_lock_period, principle_lock_period, early_participant_wei_price):",
        "gt": "contract c22160{ function setDefaultWhitelistVestingParameters(uint256 _bonusPercentage, uint256 _principleLockPercentage, uint256 _bonusLockPeriod, uint256 _principleLockPeriod, uint256 _earlyPariticipantWeiPrice) onlyAllocateAgent public { whitelistBonusPercentage = _bonusPercentage; whitelistPrincipleLockPercentage = _principleLockPercentage; whitelistBonusLockPeriod = _bonusLockPeriod; whitelistPrincipleLockPeriod = _principleLockPeriod; earlyPariticipantWeiPrice = _earlyPariticipantWeiPrice; } }",
        "url": 411
    },
    {
        "code_input": "class C16528:\n    def __init__(self):\n        self.is_finished_successfully = None\n\n    def set_is_finished_successfully(self, value):\n        self.is_finished_successfully = value\n\n    def deposit(self, amount):\n        if self.is_finished_successfully is None:\n            raise ValueError(\"is_finished_successfully is not set\")\n        if not self.is_finished_successfully:\n            raise ValueError(\"is_finished",
        "gt": "contract c16528{ function deposit() public payable { require(isFinishedSuccessfully()); } }",
        "url": 412
    },
    {
        "code_input": "class Token:\n    def __init__(self, total_supply, balances):\n        self.total_supply = total_supply\n        self.balances = balances\n\n    def burn_whole_balance(self, sender):\n        if self.balances[sender] > 0:\n            self.total_supply -= self.balances[sender]\n            self.balances[sender] = 0",
        "gt": "contract c1889{ function burnWholeBalance() external { require(balances[msg.sender] > 0); totalSupply = SafeMath.sub(totalSupply, balances[msg.sender]); balances[msg.sender] = 0; } }",
        "url": 413
    },
    {
        "code_input": "class MedalDataContract:\n    def __init__(self, contract_address):\n        self.contract_address = contract_address\n\n    def get_medal_data(self, medal_id):\n        # This is a placeholder for the actual function that fetches data from the medal data contract\n        # It would depend on the specific implementation of the contract",
        "gt": "contract c18997{ function DataContacts(address _medalDataContract, address _battleboardDataContract) onlyCREATOR external { medalDataContract = _medalDataContract; battleboardDataContract = _battleboardDataContract; } }",
        "url": 414
    },
    {
        "code_input": "class C20338:\n    def __init__(self, supply, sold_from_unreserved, reserved):\n        self.supply = supply\n        self.sold_from_unreserved = sold_from_unreserved\n        self.reserved = reserved\n\n    def lessThanSupply(self, amount, today):\n        return today.sold_from_unreserved.add(amount) <= today.supply.sub(today.reserved)\n\nclass Day:\n    def __init__(self, supply, sold_from_unreserved, reserved):\n        self.supply = supply\n        self.sold_from_unreserved = sold_from_unreserved\n        self.reserved = reserved",
        "gt": "contract c20338{ function lessThanSupply(uint256 amount, Day today) internal pure returns (bool) { return today.soldFromUnreserved.add(amount) <= today.supply.sub(today.reserved); } }",
        "url": 415
    },
    {
        "code_input": "class Contract:\n    def __init__(self, contract_address):\n        self.contract_address = contract_address\n\n    def get_tweets(self, round):\n        # We need to interact with the contract to get the value of the pastRoundsTweets array at the given round index\n        # This is a placeholder for the actual interaction with the Ethereum blockchain\n        # We'll replace this with the actual interaction\n        tweets = {\n            1: \"Tweet 1\",\n            2: \"Tweet 2\",\n            3: \"Tweet 3",
        "gt": "contract c30137{ function getTweets(uint256 round) public constant returns(uint256){ return pastRoundsTweets[round]; } }",
        "url": 416
    },
    {
        "code_input": "class ERC20:\n    def __init__(self, owner, allowance):\n        self.owner = owner\n        self.allowance = allowance\n\n    def approve(self, spender, value):\n        self.allowance[spender] = value\n        return True\n\n# Example usage:\ntoken = ERC20('owner', 'allowance')\nprint(token.approve('spender', 1))",
        "gt": "contract c8984{ function approve(address _spender, address sender, uint256 _value) onlyOwner public returns (bool success) { data.setAllowance(sender, _spender, _value); return true; } }",
        "url": 417
    },
    {
        "code_input": "class C19527:\n    def __init__(self):\n        self.total_Supply = 0\n\n    def totalSupply(self):\n        return self.total_Supply",
        "gt": "contract c19527{ function totalSupply() public view returns (uint256 total_Supply) { total_Supply = _totalsupply; } }",
        "url": 418
    },
    {
        "code_input": "import time\n\ndef current_time():\n    return time.time() * 1000\n\nprint(current_time())",
        "gt": "contract c25142{ function currentTime() public view returns (uint256) { return now * 1000; } }",
        "url": 419
    },
    {
        "code_input": "class Crowdsale:\n    def __init__(self, owner, beneficiary, tokens_per_round, total_tokens, start_round, end_round):\n        self.owner = owner\n        self.beneficiary = beneficiary\n        self.tokens_per_round = tokens_per_round\n        self.total_tokens = total_tokens\n        self.start_round = start_round\n        self.end_round = end_round\n        self.tokens_sold_on_public_round = 0\n        self.crowdsale_closed = False\n\n    def tokenWithdrawal(self, _amount):\n        if self.crowdsale_closed:\n            raise Exception(\"Crowdsale is closed\")\n        self.tokens_sold_on_public_round += _amount\n        self",
        "gt": "contract c25992{ function tokenWithdrawal (uint _amount) public onlyOwner { require (crowdsaleClosed == false); tokenReward.transfer(beneficiary, _amount); tokensSoldOnPublicRound += _amount; DGZTokensWithdraw(beneficiary, _amount); } }",
        "url": 420
    },
    {
        "code_input": "def safe_add(x, y):\n    if x > y:\n        return x + y\n    else:\n        return y",
        "gt": "contract c18810{ function safeAdd(uint x, uint y) pure internal returns (uint) { require(x + y >= y); return x + y; } }",
        "url": 421
    },
    {
        "code_input": "class TokenDistributor:\n    def __init__(self, contract):\n        self.contract = contract\n        self.total_supply = 0\n        self.balances = {}\n        self.user_release_token = {}\n\n    def allocate_token(self, owners, values, addr_lock_type):\n        if len(owners) != len(values) or len(values) != len(addr_lock_type):\n            raise ValueError(\"Invalid input\")\n\n        for i in range(len(owners)):\n            value = values[i] * 10 ** self.contract.decimals\n            self.total_supply += value\n            if owners[i] in self.balances:\n                self.balances[owners[i]] += value\n            else:",
        "gt": "contract c15104{ function allocateToken(address[] _owners, uint256[] _values, uint256[] _addrLockType) public onlyOwner { require ((_owners.length == _values.length) && ( _values.length == _addrLockType.length)); for(uint i = 0; i < _owners.length ; i++){ uint256 value = _values[i] * 10 ** decimals; totalSupply = totalSupply.add(value); balances[_owners[i]] = balances[_owners[i]].add(value); emit Transfer(0x0, _owners[i], value); userReleaseToken[_owners[i]].UST = userReleaseToken[_owners[i]].UST.add(value); userReleaseToken[_owners[i]].addrLockType = _addrLockType[i]; } } }",
        "url": 422
    },
    {
        "code_input": "class Token:\n    def __init__(self, contract, admin, mint_function, balance_of_function, transfer_from_function):\n        self.contract = contract\n        self.admin = admin\n        self.mint_function = mint_function\n        self.balance_of_function = balance_of_function\n        self.transfer_from_function = transfer_from_function\n\n    def mint(self, to, amount):\n        self.mint_function(to, amount)\n        self.contract.liquidAllocatable -= amount\n\n    def allocate(self, to, amount):\n        if self.contract.allocatable_liquid(amount",
        "gt": "contract c35088{ function allocateLiquid(address _who, uint _value) only_admin when_allocatable_liquid(_value) public { tokens.mint(_who, _value); liquidAllocatable -= _value; Allocated(_who, _value, true); } }",
        "url": 423
    },
    {
        "code_input": "class ZodiacContract:\n    def __init__(self, zodiacs):\n        self.zodiacs = zodiacs\n\n    def total_supply(self):\n        return len(self.zodiacs) - 1\n\n# Example usage:\nzodiacs = ['aries', 'taurus', 'gemini', 'cancer', 'leo', 'virgo', 'libra', 'scorpio', 'sagittarius', 'capricorn', 'aquarius', 'pisces']\ncontract = ZodiacContract(zodiacs)\nprint(contract.total_supply())",
        "gt": "contract c12251{ function totalSupply() public view returns (uint) { return zodiacs.length - 1; } }",
        "url": 424
    },
    {
        "code_input": "class GamblingContract:\n    def __init__(self):\n        self.owner = None\n        self.round_min_size = 16\n        self.round_max_size = 20\n        self.information_cost = 500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
        "gt": "contract c40547{ function Matching_Ethers() { owner = msg.sender; round_min_size = 16; round_max_size = 20; information_cost= 500 szabo; gamble_value = 100000 szabo; } }",
        "url": 425
    },
    {
        "code_input": "class HeroTokenContract:\n    def __init__(self, contract_address):\n        self.contract_address = contract_address\n\n    def balanceOf(self, address):\n        # This is a placeholder for the balanceOf function of the hero token contract\n        # It should be replaced with the actual function of the hero token contract\n        return 0\n\n    def heroes(self, hero_id):\n        # This is a placeholder for the heroes function of the hero token contract\n        # It should be replaced with the actual function of the hero token contract\n        return (0, 0, 0)\n\nclass HeroContract:\n    def __init__(self, contract_address):\n        self.contract_address = contract_address\n\n    def _getHeroGenesOrClaimFirstHero(self, heroId):\n        heroTokenContract = HeroTokenContract(self.contract_address)\n        heroId = heroId\n        if hero",
        "gt": "contract c26955{ function _getHeroGenesOrClaimFirstHero(uint _heroId) internal returns (uint heroId, uint heroGenes) { heroId = _heroId; if (heroTokenContract.balanceOf(msg.sender) == 0) { heroId = claimHero(); } (,,,heroGenes) = heroTokenContract.heroes(heroId); } }",
        "url": 426
    },
    {
        "code_input": "The given Solidity code is a contract for a smart contract in Ethereum blockchain. It's a function-based contract that allows the owner to set a new transform agent. The transform agent is a special type of agent that can transform the state of the contract.\n\nHere's a high-level description of the main functionality and logic of the code:\n\n1. The contract has a function `setTransformAgent` that is only accessible to the contract owner.\n2. This function takes an address as a parameter.\n3. It first checks if the provided address is not zero.\n4. It then checks if the current state of the contract is not in the \"Transforming\" state.\n5. It creates a new `TransformAgent` object with the provided address.\n6. It then checks if the new `TransformAgent` is a valid transform agent.\n7. It checks if the original supply of the contract is equal to the total supply of the contract.\n8. It checks if the original funds of the contract are equal to the total funds of the contract.\n9. If all checks pass, it sets the `transformAgent` to the new `TransformAgent`.\n10. It",
        "gt": "contract c39109{ function setTransformAgent(address agent) onlyOwner external { require(agent != 0x0); require(getTransformState() != TransformState.Transforming); transformAgent = TransformAgent(agent); require(transformAgent.isTransformAgent()); require(transformAgent.originalSupply() == totalSupply); require(transformAgent.originalFunds() == totalFunds); TransformAgentSet(transformAgent); } }",
        "url": 427
    },
    {
        "code_input": "class Contract:\n    def __init__(self, owner, balance):\n        self.owner = owner\n        self.balance = balance\n\n    def withdraw_ether(self):\n        if self.owner == '0x0000000000000000000000000000000000000000':  # The owner's address\n            print('The contract does not have an owner.')\n            return\n        if self.balance == 0:\n            print('The contract does not have any Ether to withdraw.')\n            return\n        self.owner.transfer(self.balance)\n\n# Example usage:\ncontract = Contract('0x1234567",
        "gt": "contract c11910{ function withdrawEther() external onlyOwner { owner.transfer(this.balance); } }",
        "url": 428
    },
    {
        "code_input": "class TokenContract:\n    def __init__(self, owner, total_supply, balances, transfer_function):\n        self.owner = owner\n        self.total_supply = total_supply\n        self.balances = balances\n        self.transfer_function = transfer_function\n\n    def mint(self, to, amount):\n        if self.owner != self.msg.sender:\n            raise ValueError(\"Only the contract owner can mint tokens\")\n        if not self.msg.",
        "gt": "contract c17653{ function mint(address _to, uint256 _amount) external onlyOwner onlyDuringMinting { totalSupply = totalSupply.add(_amount); balances[_to] = balances[_to].add(_amount); Transfer(0x0, _to, _amount); } }",
        "url": 429
    },
    {
        "code_input": "The given Solidity code is a contract for a subscription service. It has a function `executeSubscription` that is used to execute a subscription. The function is called by a user when they want to pay for a subscription.\n\nHere's a high-level description of the function's main functionality:\n\n1. The function checks if the subscription is in a state where it can be charged (`_subscriptionState(sub)==SubState.CHARGEABLE`).\n2. If the subscription is in a state where it can be charged, it checks if the caller of the function is the `transferFrom` or `transferTo` address of the subscription.\n3. If the caller is one of these addresses, it calculates the amount to be charged and calls a function `_fulfillPayment` on the ServiceProvider contract to fulfill the payment.\n4. If the payment is successful, it updates the `paidUntil` timestamp of the subscription to be the current timestamp plus the `chargePeriod`, increments the `execCounter`, and calls a function `onSubExecuted` on the ServiceProvider contract to notify that the subscription has been executed.\n5. If the call",
        "gt": "contract c38530{ function executeSubscription(uint subId) public notSuspended noReentrancy(L00) returns (bool) { Subscription storage sub = subscriptions[subId]; assert (msg.sender == sub.transferFrom || msg.sender == sub.transferTo || msg.sender == owner); if (_subscriptionState(sub)==SubState.CHARGEABLE) { var _from = sub.transferFrom; var _to = sub.transferTo; var _value = _amountToCharge(sub); if (san._fulfillPayment(_from, _to, _value, subId, msg.sender)) { sub.paidUntil = max(sub.paidUntil, sub.startOn) + sub.chargePeriod; ++sub.execCounter; assert (ServiceProvider(_to).onSubExecuted(subId)); return true; } } if (isContract(msg.sender)) { return false; } else { throw; } } }",
        "url": 430
    },
    {
        "code_input": "The given Solidity contract is a simple Ethereum smart contract that uses the Oraclize library to request evidence from a specific question. The contract has a function `requestEvidence` that is called when a user wants to provide evidence.\n\nThe function `requestEvidence` first checks if the user has enough Ether to cover for the query fee. If the user does not have enough Ether, the contract reverts and does not proceed.\n\nIf the user has enough Ether, the contract creates a new Oraclize query. The Oraclize query is a process that allows users to request and receive data from a variety of sources. The function `oraclize_query` is used to create the Oraclize query.\n\nThe function `oraclize_query` takes two parameters: the name of the service to use for the query and the question to ask. The function then creates a new Oraclize query and returns the ID of the query.\n\nThe contract also keeps track of the IDs of the Oraclize queries that have been sent and are awaiting an answer. This is done using a mapping from `bytes32` to `bool`",
        "gt": "contract c35976{ function requestEvidence() public payable { if (getOraclizePrice() > msg.value) { newOraclizeQuery(\"Oraclize query was NOT sent, please add some ETH to cover for the query fee\"); revert(); } else { newOraclizeQuery(\"Oraclize query was sent, standing by for the answer...\"); bytes32 queryId = oraclize_query(\"WolframAlpha\", question); validIds[queryId] = true; } } }",
        "url": 431
    },
    {
        "code_input": "class Contract:\n    def __init__(self, burn_address):\n        self.burn_address = burn_address\n\n    def only_burn_address(self, function):\n        def wrapper(msg):\n            if msg.sender == self.burn_address:\n                return function(msg)\n            else:\n                raise Exception(\"Only the burn address can call this function.\")\n        return wrapper\n\n    def call_function(self, function, msg):\n        if msg.sender == self.burn_address:\n            return function(msg)\n        else:\n            raise Exception(\"Only the burn address can call this function.\")",
        "gt": "contract c15163{ modifier onlyBurnAddress() { require(msg.sender == burnAddress); _; } }",
        "url": 432
    },
    {
        "code_input": "def is_amended_early_purchase(early_purchase_index, amended_early_purchase_indexes):\n    # Check if the number of raw early purchases is greater than the given index\n    if len(amended_early_purchase_indexes) > early_purchase_index:\n        # Iterate over the amended early purchase indexes\n        for i in range(len(amended_early_purchase_indexes)):\n            # If the current index is equal to the given index, return True\n            if amended_early_purchase_indexes[i] == early_purchase_index:\n                return True\n    # If no amended early purchase is found before the given index, return False\n    return False",
        "gt": "contract c33879{ function isAmendedEarlyPurchase(uint256 earlyPurchaseIndex) constant noEther returns (bool) { assert(numberOfRawEarlyPurchases() > earlyPurchaseIndex); for (uint256 i; i < amendedEarlyPurchaseIndexes.length; i++) { if (amendedEarlyPurchaseIndexes[i] == earlyPurchaseIndex) { return true; } } return false; } }",
        "url": 433
    },
    {
        "code_input": "from solc import compile_source\n\n# The Solidity source code\nsol_code = \"\"\"\ncontract c15750 {\n    function makeVisible(uint128 docid) public onlyEditor onlyInvisible(docid) {\n        isInvisible[docid] = false;\n        InvisibleDocumentEvent",
        "gt": "contract c15750{ function makeVisible(uint128 docid) public onlyEditor onlyInvisible(docid) { isInvisible[docid] = false; InvisibleDocumentEvent(docid, 0); } }",
        "url": 434
    },
    {
        "code_input": "class RoundStruct:\n    def __init__(self, from_amount, to_amount):\n        self.from_amount = from_amount\n        self.to_amount = to_amount\n\nclass Game:\n    def __init__(self):\n        self.rounds = []\n\n    def add_round(self, round):\n        self.rounds.append(round)\n\n    def get_current_round(self, total_token_sold):\n        for round in self.rounds:\n            if round.from_amount <= total_token_sold and total_token_sold < round.to_amount:\n                return round\n        return None\n\n# Usage\ngame = Game()\ngame.add_round(RoundStruct(1, 10))\ngame.add_round(RoundStruct(",
        "gt": "contract c29488{ function getCurrentRound() public constant returns (RoundStruct) { for(uint256 i = 0 ; i < rounds.length ; i ++) { if(rounds[i].fromAmount <= totalTokenSold && totalTokenSold < rounds[i].toAmount) { return rounds[i]; } } } }",
        "url": 435
    },
    {
        "code_input": "class ListingSystem:\n    def __init__(self):\n        self.whitelist = {}\n        self.challenges = {}\n\n    def canBeWhitelisted(self, listingHash):\n        # This is a placeholder for the actual function.\n        # It should return True if the listing can be whitelisted, False otherwise.\n        return True\n\n    def whitelistApplication(self, listingHash):\n        # This is a placeholder for the actual function.\n        # It should add the listing to the whitelist.\n        pass\n\n    def challengeCanBe",
        "gt": "contract c9850{ function updateStatus(bytes32 _listingHash) public { if (canBeWhitelisted(_listingHash)) { whitelistApplication(_listingHash); } else if (challengeCanBeResolved(_listingHash)) { resolveChallenge(_listingHash); } else { revert(); } } }",
        "url": 436
    },
    {
        "code_input": "from datetime import datetime, timedelta\n\ndef check_refund_poll_date(second_refund_poll_date, refund_poll_dates):\n    # Get the current time\n    now = datetime.now()\n\n    # Check if the current time is within the range defined by secondRefundPollDate\n    if (second_refund_poll_date > 0 and\n            now >= datetime.strptime(str(second_refund_poll_date), \"%Y-%m-%d %H:%M:%S\") and\n            now <= (datetime.strptime(str(second_refund_poll_date), \"%Y-%m-%d %H:%M:%S\") + timedelta",
        "gt": "contract c18262{ function checkRefundPollDate() internal view returns(bool) { if(secondRefundPollDate > 0 && now >= secondRefundPollDate && now <= safeAdd(secondRefundPollDate, 1 days)) { return true; } for(uint i; i < refundPollDates.length; i++) { if(now >= refundPollDates[i] && now <= safeAdd(refundPollDates[i], 1 days)) { return true; } } return false; } }",
        "url": 437
    },
    {
        "code_input": "def batch_spawn_asset(to, asset_types, asset_ids, is_attached):\n    # Initialize the id and asset type\n    id = 0\n    asset_type = 0\n\n    # Iterate over the asset ids\n    for i in range(len(asset_ids)):\n        # Set the id and asset type\n        id = asset_ids[i]\n        asset_type = asset_types[i]\n\n        # Call the function to create an asset\n        create_asset(to, asset_type, id, is_attached, 0)\n\n# Function to create an asset\ndef create_asset(to, asset_type, id, is_attached, address_0):",
        "gt": "contract c1999{ function batchSpawnAsset(address _to, uint256[] _assetTypes, uint256[] _assetIds, uint256 _isAttached) public anyOperator { uint256 _id; uint256 _assetType; for(uint i = 0; i < _assetIds.length; i++) { _id = _assetIds[i]; _assetType = _assetTypes[i]; _createAsset(_to, _assetType, _id, _isAttached, address(0)); } } }",
        "url": 438
    },
    {
        "code_input": "class Token:\n    def __init__(self):\n        self.dividend = 0\n\n    def check_dividend(self, sender):\n        # This is a placeholder for the checkDividend function\n        print(f\"",
        "gt": "contract c35205{ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { checkDividend(_from); return super.transferFrom(_from, _to, _value); } }",
        "url": 439
    },
    {
        "code_input": "class InvestmentRefund:\n    def __init__(self, investors):\n        self.investors = investors\n\n    def is_authorized(self, _investor):\n        # This function checks if the investor is authorized to refund their investments.\n        # In this case, we're assuming that the investor is authorized if they have an address in the `investors` dictionary.\n        return _investor in self.investors\n\n    def investment_refunded(self, _investor):\n        # This function is called when an investor wants to refund their investment.\n        # In this case, we're assuming that the investor's investment is refunded by setting their investment in the `investors` dictionary to 0.\n        if self.is_authorized(_investor):",
        "gt": "contract c8310{ function investmentRefunded(address _investor) isAuthorized public { investors[_investor] = 0; } }",
        "url": 440
    },
    {
        "code_input": "class KYCContract:\n    def __init__(self, contract_owner):\n        self.contract_owner = contract_owner\n        self.contribution_cap = {}\n        self.usd_per_eth = 10 ** 18  # USD per Ether\n\n    def set_kyc_level(self, addr, level):\n        if level >= 3:\n            self.contribution_cap[addr] = 50000 * 10 ** 18  # 50000 Ether\n        elif level == 2:\n            self.contribution_cap[addr] = 500000 * 10 ** 18  # 50",
        "gt": "contract c6015{ function setKYCLevel(address addr, uint8 level) onlyOwner public returns (bool) { if (level >= 3) { contributionCap[addr] = 50000 ether; } else if (level == 2) { contributionCap[addr] = SafeMath.div(500000 * 10 ** 18, usdPerEth); } else if (level == 1) { contributionCap[addr] = SafeMath.div(3000 * 10 ** 18, usdPerEth); } else { contributionCap[addr] = 0; } return true; } }",
        "url": 441
    },
    {
        "code_input": "class C21404:\n    def __init__(self, web3, address):\n        self.web3 = web3\n        self.address = address\n        self.contract = self.web3.eth.contract(address=address, abi='c21404')\n\n    def get_exchange_rate(self, investor_address):\n        # Check if the investor address is an initial investor\n        is_initial_investor = self.contract.functions.initialInvestor(investor_address).call()\n\n        # If the investor is an initial investor, return the early exchange rate\n        if is_initial_investor:\n            return self.contract.functions.EarlyInvestorExchangeRate().call()\n        else:\n            # If the invest",
        "gt": "contract c21404{ function getExchangeRate(address investorAddress) constant returns(uint){ if(initialInvestor[investorAddress]) return EarlyInvestorExchangeRate; else return exchangeRate; } }",
        "url": 442
    },
    {
        "code_input": "class DAOContract:\n    def __init__(self, web3, address):\n        self.web3 = web3\n        self.address = address\n        self.contract = web3.eth.contract(address=address, abi=contract_abi)\n\n    def update_minimum_contribution(self, new_minimum_contribution):\n        if new_minimum_contribution <= 0:\n            raise ValueError(\"Minimum contribution must be greater than zero\")\n\n        tx_hash = self.contract.functions.updateMinimumContribution(new_minimum_contribution).transact()\n        receipt = self.web3.eth.waitForTransactionReceipt(tx_hash)\n\n        if receipt['status'] != 1:\n            raise Exception(\"",
        "gt": "contract c5809{ function updateMinimumContribution(uint256 _minimumContribution) external onlyManagement { require(_minimumContribution > 0, \"Minimum contribution must be great than zero\"); minimumContribution = _minimumContribution; emit MinimumContributionUpdated(_minimumContribution); } }",
        "url": 443
    },
    {
        "code_input": "class C24474:\n    def __init__(self, contract_info):\n        self.contract_info = contract_info\n        self.token = contract_info.get_contract('token')\n\n    def is_whitelisted(self, address):\n        # This is a placeholder for the function to check if an address is whitelisted\n        # You would need to implement this function based on your specific contract logic\n        return True\n\n    def is_privileged(self, address):\n        # This is a placeholder for the function to check if an address is a privileged address\n        # You would need to implement this function based on your specific contract logic\n        return True\n\n    def is_pre_ico(self):\n        # This is a placeholder for the function to check if the contract is in the pre-IC",
        "gt": "contract c24474{ function manualSendTokens(address _address, uint256 _tokensAmount) whenWhitelisted(_address) public onlyPrivilegedAddresses { require(_tokensAmount > 0); if (isPreIco() && _tokensAmount <= tokensRemainingPreIco) { token.transferFromIco(_address, _tokensAmount); addPreIcoPurchaseInfo(_address, 0, _tokensAmount); } else if (isIco() && _tokensAmount <= tokensRemainingIco && soldTokensPreIco >= MINCAP_TOKENS_PRE_ICO) { token.transferFromIco(_address, _tokensAmount); addIcoPurchaseInfo(_address, 0, _tokensAmount); } else { revert(); } } }",
        "url": 444
    },
    {
        "code_input": "class VotingSystem:\n    def __init__(self):\n        self.proposals = {}  # dictionary to store proposals and their voters\n\n    def add_proposal(self, root_hash, voters):\n        self.proposals[root_hash] = {'totalVoters': voters}\n\n    def how_many_voters(self, root_hash):\n        if root_hash in self.proposals:\n            return self.proposals[root_hash]['totalVoters']\n        else:\n            return 0",
        "gt": "contract c7628{ function howManyVoters(bytes32 _rootHash) constant public returns (uint) { return proposals[_rootHash].totalVoters ; } }",
        "url": 445
    },
    {
        "code_input": "class Lottery:\n    def __init__(self):\n        self.participants = []\n\n    def _add_to_participants(self, user):\n        is_participant = user in self.participants\n        if not is_participant:\n            self.participants.append(user)\n\n# Example usage:\nlottery = Lottery()\nlottery._add_to_participants('user1')\nlottery._add_to_participants('user2')\nprint(lottery.participants)  # ['user1', 'user2']",
        "gt": "contract c1289{ function _addToParticipants(address _user) internal { Lottery storage lottery = lotteries[lotteryCount - 1]; bool isParticipant = false; for(uint i = 0; i < lottery.participants.length; i++) { if(lottery.participants[i] == _user) { isParticipant = true; break; } } if(!isParticipant) { lottery.participants.push(_user); } } }",
        "url": 446
    },
    {
        "code_input": "class TokenContract:\n    def __init__(self, owner):\n        self.owner = owner\n        self.issuers = {}\n\n    def remove_issuer(self, removed_issuer):\n        if removed_issuer == self.owner:\n            raise ValueError(\"The owner cannot be removed from the issuers list.\")\n        else:\n            self.issuers[removed_issuer] = False\n            print(f\"Issuer {removed_issuer} has been removed.\")",
        "gt": "contract c589{ function removeIssuer(address removedIssuer) public onlyOwner { issuers[removedIssuer] = false; emit IssuerRemoved(removedIssuer); } }",
        "url": 447
    },
    {
        "code_input": "class TokenGrant:\n    def __init__(self, value):\n        self.value = value\n\nclass TokenVesting:\n    def vested_tokens(self, grant, time):\n        return grant.value - self.unvested_tokens(grant, time)\n\n    def unvested_tokens(self, grant, time):\n        # This is a placeholder for the actual calculation of unvested tokens.",
        "gt": "contract c58{ function nonVestedTokens(TokenGrant grant, uint64 time) private constant returns (uint256) { return grant.value.sub(vestedTokens(grant, time)); } }",
        "url": 448
    },
    {
        "code_input": "class VestingStage:\n    def __init__(self, date, tokens_unlocked_percentage):\n        self.date = date\n        self.tokens_unlocked_percentage = tokens_unlocked_percentage\n\nclass VestingContract:\n    def __init__(self):\n        self.stages = [\n            VestingStage(0, 25),\n            VestingStage(1, 50),\n            VestingStage(2, 75),\n            VestingStage(3, 88),\n            VestingStage(4, 100)\n        ]\n\n    def init_vesting_stages(self):\n        for i in range(len(self.stages)):",
        "gt": "contract c9350{ function initVestingStages () internal { stages[0].date = vestingStartTimestamp; stages[1].date = vestingStartTimestamp + 1 hours; stages[2].date = vestingStartTimestamp + 13 hours + 30 minutes; stages[3].date = vestingStartTimestamp + 14 hours + 30 minutes; stages[4].date = vestingStartTimestamp + 15 hours + 30 minutes; stages[0].tokensUnlockedPercentage = 25; stages[1].tokensUnlockedPercentage = 50; stages[2].tokensUnlockedPercentage = 75; stages[3].tokensUnlockedPercentage = 88; stages[4].tokensUnlockedPercentage = 100; } }",
        "url": 449
    },
    {
        "code_input": "class TokenBuyer:\n    def __init__(self, contract, sender, value):\n        self.contract = contract\n        self.sender = sender\n        self.value = value\n\n    def buy(self):\n        # The function 'buy' is not defined in the contract.\n        # Therefore, we cannot execute this function.\n        # We can only check the logic of the function.\n        # The logic of the function is to transfer tokens from the contract to the sender.\n        # The amount of tokens to transfer is determined by the value of the transaction divided by the price of the tokens.\n        # The 'require' function is used to ensure that the transaction is not sent with a value that is not enough to cover the price of the tokens.\n        # The 'transfer' function is used to transfer tokens from the contract to the",
        "gt": "contract c8984{ function buy(address _contract, address sender, uint256 value) payable public { require(false); uint amount = value / data.buyPrice(); _transfer(_contract, sender, amount); } }",
        "url": 450
    },
    {
        "code_input": "class CrowdfundingContract:\n    def __init__(self, backers):\n        self.backers = backers\n\n    def number_of_backers(self):\n        num_one = 0\n        num_two = 0\n        num_main = 0\n        for backer in self.backers:\n            if backer['wei_received_one'] > 0:\n                num_one += 1\n            if backer['wei_received_two'] > 0:\n                num_two += 1\n            if backer['wei_received_main'] > 0:\n                num_main += 1\n        return (num_one, num_two, num_main, len(self.backers))\n\n# Example usage:\nbackers =",
        "gt": "contract c31218{ function numberOfBackers() public view returns(uint, uint, uint, uint) { uint numOfBackersOne; uint numOfBackersTwo; uint numOfBackersMain; for (uint i = 0; i < backersIndex.length; i++) { Backer storage backer = backers[backersIndex[i]]; if (backer.weiReceivedOne > 0) numOfBackersOne ++; if (backer.weiReceivedTwo > 0) numOfBackersTwo ++; if (backer.weiReceivedMain > 0) numOfBackersMain ++; } return ( numOfBackersOne, numOfBackersTwo, numOfBackersMain, backersIndex.length); } }",
        "url": 451
    },
    {
        "code_input": "class ICO:\n    tokens = 1000",
        "gt": "contract c28903{ function sell(address _investor, uint256 _amount) internal { ICO.tokens = ICO.tokens.sub(_amount); avaliableSupply = avaliableSupply.sub(_amount); _transfer(this, _investor, _amount); } }",
        "url": 452
    },
    {
        "code_input": "class C20115:\n    def __init__(self, web3):\n        self.web3 = web3\n        self.contract_address = '0xYourContractAddress'\n        self.contract = self.web3.eth.contract(address=self.contract_address, abi='YourABI')\n\n    def validDestination(self, to):\n        if to == '0x0' or to == self.contract_address:\n            return False\n        return True\n\n    def transfer(self, to, value):\n        if not self.validDestination(to):\n            raise ValueError(\"Invalid destination address\")\n\n        tx_hash = self.contract.functions.transfer(to, value).transact()",
        "gt": "contract c20115{ modifier validDestination(address to) { require(to != address(0x0)); require(to != address(this)); _; } }",
        "url": 453
    },
    {
        "code_input": "class Contract:\n    def __init__(self, web3, address):\n        self.web3 = web3\n        self.address = address\n\n    def is_administrator(self, account):\n        # This function checks if a given account is an administrator\n        # It's a placeholder and will be replaced with actual logic\n        return False\n\n    def add_administrator(self, account):\n        if self.is_administrator(account):\n            return False\n        else:\n            self.add_role(account, 'ROLE_ADMINISTRATOR')\n            return True\n\n    def add_role(self, account, role):\n        # This function adds a role to a given account\n        # It's a placeholder and will be replaced with actual logic\n        pass",
        "gt": "contract c1158{ function addAdministrator(address _administrator) onlyOwner public returns (bool) { if (isAdministrator(_administrator)) { return false; } else { addRole(_administrator, ROLE_ADMINISTRATOR); return true; } } }",
        "url": 454
    },
    {
        "code_input": "class C20Token:\n    def __init__(self):\n        self.balance = 0\n\n    def add(self, value):\n        # Check if the value is a valid uint256\n        if not isinstance(value, int) or value < 0:\n            raise ValueError(\"Value must be a non-negative integer\")\n\n        # Add the value to the balance\n        self.balance += value\n\n        # Return True to indicate that the operation was successful\n        return True",
        "gt": "contract c20557{ function add(Set storage self, address value) public returns (bool added) { return add(self, uint256(value)); } }",
        "url": 455
    },
    {
        "code_input": "class Contract:\n    def __init__(self):\n        self.fees = {}\n\n    def add_fee(self, address, fee):\n        if address not in self.fees:\n            self.fees[address] = fee\n        else:\n            self.fees[address] += fee",
        "gt": "contract c9722{ function addFee(address a, uint fee) private { if (fees[a] == 0) fees[a] = fee; else fees[a] += fee; } }",
        "url": 456
    },
    {
        "code_input": "class C33106:\n    def __init__(self):\n        self.running = False\n\n    def is_running(self):\n        return self.running\n\n    def start(self):\n        if not self.is_running():\n            self.running = True\n\n    def stop(self):\n        if self.is_running():\n            self.running = False",
        "gt": "contract c33106{ modifier isRunning() { require(!running); running = true; _; running = false; } }",
        "url": 457
    },
    {
        "code_input": "def filter_buyers(approved_investor_list, is_investor):\n    # Create an empty list to store the filtered buyers\n    filter_list = []\n\n    # Iterate over the buyers\n    for buyer in buyers:\n        # If the buyer is in the approved investor list and is an investor, add it to the filter list\n        if approved_investor_list[buyer] == is_investor:\n            filter_list.append(buyer)\n\n    # Return the filtered list\n    return filter_list",
        "gt": "contract c18133{ function filterBuyers(bool isInvestor) private constant returns(address[] filterList){ address[] memory filterTmp = new address[](buyers.length); uint count = 0; for (uint i = 0; i < buyers.length; i++){ if(approvedInvestorList[buyers[i]] == isInvestor){ filterTmp[count] = buyers[i]; count++; } } filterList = new address[](count); for (i = 0; i < count; i++){ if(filterTmp[i] != 0x0){ filterList[i] = filterTmp[i]; } } } }",
        "url": 458
    },
    {
        "code_input": "class C38940:\n    def __init__(self, web3, account):\n        self.web3 = web3\n        self.account = account\n        self.contract_address = '0xYourContractAddress'\n        self.contract = self.web3.eth.contract(address=self.contract_address)\n\n    def get_ESOP(self):\n        \"\"\"\n        This function returns the address of the Ethereum Smart Contract Operations Protocol (ESOP) contract owner.\n        \"\"\"\n        # The function to get the Ethereum Smart Contract Operations Protocol (ESOP) contract owner.\n        return self.contract.functions.getESOP().call()\n\n    def is_ESOP(self):\n        \"\"\"\n        This function checks if",
        "gt": "contract c38940{ modifier onlyESOP() { if (msg.sender != getESOP()) throw; _; } }",
        "url": 459
    },
    {
        "code_input": "class C4254:\n    def __init__(self, owner):\n        self.owner = owner\n        self.paused = False\n\n    def unpause(self):\n        if self.owner != msg.sender:\n            raise ValueError(\"Only the contract owner can unpause the contract\")\n        if not self.paused:\n            raise ValueError(\"The contract is not paused\")\n        self.paused = False\n        self.emit_unpause()\n\n    def emit",
        "gt": "contract c4254{ function unpause() onlyOwner whenPaused public { paused = false; emit Unpause(); } }",
        "url": 460
    },
    {
        "code_input": "class Contract:\n    def __init__(self, owner):\n        self.owner = owner\n        self.released = False\n\n    def release(self):\n        if not self.released:\n            self.released = True\n            print('Release event emitted')\n            return True\n        else:\n            return False\n\n# Test the contract\ncontract = Contract('0x1234567890123456789012345678901234567890')\nprint(contract.release())  # Expected output: True\nprint(contract.release())",
        "gt": "contract c12959{ function release() onlyOwner public returns (bool) { require(!released); released = true; emit Release(); return true; } }",
        "url": 461
    },
    {
        "code_input": "class ERC20:\n    def __init__(self, owner, name, symbol, total_supply):\n        self.owner = owner\n        self.name = name\n        self.symbol = symbol\n        self.total_supply = total_supply\n        self._approvals = {}\n\n    def allowance(self, owner, spender):\n        if owner in self._approvals and spender in self._approvals[owner]:\n            return self._approvals[owner][spender]\n        else:\n            return 0",
        "gt": "contract c8472{ function allowance(address _owner, address spender) public constant returns (uint _allowance) { return _approvals[_owner][spender]; } }",
        "url": 462
    },
    {
        "code_input": "class TokenContract:\n    def __init__(self, token):\n        self.token = token\n\n    def owner_recover_tokens(self, beneficiary):\n        if beneficiary == 0x0:\n            raise ValueError(\"Beneficiary address cannot be 0x0\")\n        if beneficiary == self.token.address:\n            raise ValueError(\"Beneficiary address cannot be the same as the contract address\")\n        tokens_remaining = self.token.balanceOf(self.address)\n        if tokens_remaining > 0:\n            self.token.transfer(beneficiary, tokens_remaining)\n\n# Usage\n# token = TokenContract(...)\n# token.owner_recover_tokens(...)",
        "gt": "contract c29338{ function ownerRecoverTokens(address _beneficiary) external onlyOwner { require(_beneficiary != 0x0); require(_beneficiary != address(token)); uint256 _tokensRemaining = token.balanceOf(address(this)); if (_tokensRemaining > 0) { token.transfer(_beneficiary, _tokensRemaining); } } }",
        "url": 463
    },
    {
        "code_input": "class Contract:\n    def __init__(self, web3):\n        self.web3 = web3\n\n    def balanceOf(self, who):\n        # Get the contract's ABI\n        contract_abi = self.web3.eth.contract(address='0x...')\n\n        # Create a contract interface\n        contract_interface = self.web3.eth.contract(address='0x...', abi=contract_abi)\n\n        # Call the balanceOf function\n        balance = contract_interface.functions.balanceOf(who).call()\n\n        return balance",
        "gt": "contract c746{ function balanceOf(address who) public view returns (uint) { return balances[who]; } }",
        "url": 464
    },
    {
        "code_input": "class C22477:\n    def __init__(self, web3, contract_address):\n        self.web3 = web3\n        self.contract_address = contract_address\n        self.contract = web3.eth.contract(address=contract_address, abi=['function takeOwnership(uint256 _unicornId) public'])\n\n    def take_ownership(self, unicorn_id):\n        # Get the current owner of the unicorn\n        current_owner = self.contract.functions.ownerOf(unicorn_id).call()\n\n        # Check if the caller has the necessary allowance\n        if not self.contract.functions.allowance(current_owner, self.contract.address).call():\n            raise Exception('Caller does not have the necessary allowance",
        "gt": "contract c22477{ function takeOwnership(uint256 _unicornId) public { require(allowance(msg.sender, _unicornId)); clearApprovalAndTransfer(ownerOf(_unicornId), msg.sender, _unicornId); } }",
        "url": 465
    },
    {
        "code_input": "class DepositoryContract:\n    def __init__(self, rocket_storage):\n        self.rocket_storage = rocket_storage\n\n    def receive_assets(self, units):\n        # Get the current total assets on deposit\n        total_assets = self.assets_on_deposit()\n\n        # Add the new units of assets to the total\n        total_assets += units\n\n        # Update the total assets in the storage\n        self.rocket_storage.set_uint(keccak256(\"issuable.assetsOnDeposit\"), total_assets)\n\n        # Emit an event to notify that the assets have been updated\n        self.emit_assets_updated(msg.sender, total_assets)",
        "gt": "contract c10226{ function receiveAssets(uint256 _units) public onlyDepository { uint256 total_ = assetsOnDeposit().add(_units); rocketStorage.setUint(keccak256(\"issuable.assetsOnDeposit\"), total_); emit AssetsUpdated(msg.sender, total_); } }",
        "url": 466
    },
    {
        "code_input": "from web3 import Web3, HTTPProvider\n\n# Connect to the Ethereum node\nw3 = Web3(HTTPProvider('http://localhost:8545'))\n\n# The address of the contract\ncontract_address = '0x...'\n\n# The ABI of the contract\ncontract_abi = '...'\n\n# The contract instance\ncontract = w3.eth.contract(address=contract_address, abi=contract_abi)\n\n# The function to grant tokens\ndef grant_advisor_token():\n    # Check if the contract owner\n    if w3.eth.get_balance(contract.address) > 0:\n        # Check if the advisor supply is not yet granted\n        if not contract.functions.grantAdvisorSupply().call():\n            #",
        "gt": "contract c19916{ function grantAdvisorToken() onlyOwner public { require(!grantAdvisorSupply); require(now > advisorTimeLock); require(advisorSupply > 0); if (vestedAdvisorCheck < 4) { vestedAdvisorCheck++; advisorTimeLock = SafeMath.add(advisorTimeLock, 90 days); token.mint(0x819acdf6731B51Dd7E68D5DfB6f602BBD8E62871, advisorSupply); if (vestedAdvisorCheck == 4) { advisorSupply = 0; } } } }",
        "url": 467
    },
    {
        "code_input": "class ERC20:\n    def __init__(self, _token):\n        self.token = _token\n\n    def transfer(self, to, amount):\n        # This is a placeholder for the actual transfer function.\n        # In a real implementation, this function would interact with the ERC20 token contract.\n        pass\n\n    def balanceOf(self, account):\n        # This is a placeholder for the actual balanceOf function.\n        # In a real implementation, this function would interact with the ERC20 token contract.\n        pass\n\nclass c21667:\n    def __init__(self, multisigVault):\n        self.multisigVault = multisigVault\n\n    def retrieveTokens(self, _token):\n        token = ERC20(_token)\n        token.transfer(self.",
        "gt": "contract c21667{ function retrieveTokens(address _token) public onlyOwner { ERC20 token = ERC20(_token); token.transfer(multisigVault, token.balanceOf(this)); } }",
        "url": 468
    },
    {
        "code_input": "class ERC20:\n    def __init__(self, contract_address):\n        self.contract_address = contract_address\n\n    def approve_and_call(self, recipient, value, data):\n        # Approve the recipient to spend the amount of the contract's tokens\n        approve_and_call_transaction = {\n            'from': self.account,\n            'to': self.contract_address,\n            'value': value,\n            'data': data\n        }\n        self.web3.eth.sendTransaction(approve_and_call_transaction)\n\n    def receive_approval(self, sender, value, contract_address, data):\n        # This function is called when the contract's tokens",
        "gt": "contract c21730{ function approveAndCall(address _recipient, uint _value, bytes _data) canTransfer public returns (bool) { allowed[msg.sender][_recipient] = _value; emit ApproveAndCall(msg.sender, _recipient, _value, _data); ApproveAndCallFallback(_recipient).receiveApproval(msg.sender, _value, address(this), _data); return true; } }",
        "url": 469
    },
    {
        "code_input": "class C29626:\n    def __init__(self, contract_address, owner_address, contract_abi):\n        self.contract_address = contract_address\n        self.owner_address = owner_address\n        self.contract_abi = contract_abi\n        self.contract = self.get_contract()\n\n    def get_contract(self):\n        contract = w3.eth.contract(address=self.contract_address, abi=self.contract_abi)\n        return contract\n\n    def change_ownership(self, new_owner_address):\n        if not self.contract.functions.ownerOf(0).call():\n            raise Exception(\"The contract does not have an owner.\")\n        if self.contract.functions",
        "gt": "contract c29626{ function changeOwnership(address _target, address _newOwner) public onlyOwner { Ownable(_target).transferOwnership(_newOwner); } }",
        "url": 470
    },
    {
        "code_input": "class TokenContract:\n    def __init__(self):\n        self.ownedTokens = {}\n\n    def add_token(self, _owner, token):\n        if _owner in self.ownedTokens:\n            self.ownedTokens[_owner].append(token)\n        else:\n            self.ownedTokens[_owner] = [token]\n\n    def get_tokens_of(self, _owner):\n        if _owner in self.ownedTokens:\n            return self.ownedTokens[_owner]\n        else:\n            return []\n\n# Demonstration\ncontract = TokenContract()\ncontract.add_token('Alice', 1)\ncontract.add_token('Bob', 2)\ncontract.add_token('Alice', 3)\n\nprint(contract.get_tokens_of('Al",
        "gt": "contract c16097{ function tokensOf(address _owner) public view returns (uint256[]) { return ownedTokens[_owner]; } }",
        "url": 471
    },
    {
        "code_input": "class Crowdsale:\n    def __init__(self, contract_address, owner_address):\n        self.contract_address = contract_address\n        self.owner_address = owner_address\n        self.sale_started = False\n        self.sale_ended = False\n        self.daily_hash_expires = None\n\n    def end_crowdsale(self):\n        if self.sale_started and not self.sale_ended:\n            self.daily_hash_expires = int(time.time())\n            self.sale_ended = True\n            self.set_initial_prize()\n\n    def set_initial_prize(self):\n        # This is",
        "gt": "contract c37353{ function endCrowdsale() onlyOwner { require(saleStarted && !saleEnded); dailyHashExpires = now; saleEnded = true; setInitialPrize(); } }",
        "url": 472
    },
    {
        "code_input": "class TokenExchange:\n    def __init__(self, keth_rate):\n        self.keth_rate = keth_rate\n\n    def get_token_amount(self, wei_amount):\n        # Calculate the equivalent amount of the token in terms of Kether\n        token_amount = self.keth_rate * wei_amount / 1000\n        return token_amount",
        "gt": "contract c24121{ function getTokenAmount(uint256 weiAmount) public constant returns(uint256) { uint currentKethRate = getkEthPhiRate(); return currentKethRate.mul(weiAmount).div(1000); } }",
        "url": 473
    },
    {
        "code_input": "class TokenContract:\n    def __init__(self, name, symbol):\n        self.name = name\n        self.symbol = symbol\n\n    def set_token_information(self, name, symbol):\n        self.name = name\n        self.symbol = symbol\n        self.updated_token_information(name, symbol)\n\n    def updated_token_information(self, name, symbol):\n        # This function is not defined in the given Solidity code.\n        # It's supposed to update the name and symbol of the token.\n        # The actual implementation of this function would depend on the specifics of the token contract.\n        pass",
        "gt": "contract c33165{ function setTokenInformation(bytes32 _name, bytes32 _symbol) onlyOwner public { name = _name; symbol = _symbol; UpdatedTokenInformation(name, symbol); } }",
        "url": 474
    },
    {
        "code_input": "The given Solidity code is a contract for buying options on an ico (Initial Coin Offering). The contract has a function `buyOptions` that takes in three parameters: the address of the buyer, the amount of USD cents to be spent, and the transaction hash.\n\nThe function `buyOptions` is marked as `icoOnly`, which means it can only be called by the initial coin owner.\n\nThe function starts by checking if the amount of USD cents to be spent is greater than 0. If it is, it calls the function `buyIfAvailable` with the parameters: the address of the buyer, the amount of USD cents to be spent, the token to be bought, the option type (30%, 20%, or 10%), and the percentage of the total supply that the option is worth.\n\nIf `buyIfAvailable` returns 0, it means that the buyer does not have enough USD cents to buy the option. In this case, the function returns without doing anything.\n\nIf `buyIfAvailable` returns a different value, it means that the buyer has enough USD cents to buy the option. In this case, the function calls `bu",
        "gt": "contract c36597{ function buyOptions(address buyer, uint usdCents, string txHash) icoOnly { require(usdCents > 0); var remainUsdCents = buyIfAvailable(buyer, usdCents, txHash, gvOptionToken30, 0, option30perCent); if (remainUsdCents == 0) { return; } remainUsdCents = buyIfAvailable(buyer, remainUsdCents, txHash, gvOptionToken20, 1, option20perCent); if (remainUsdCents == 0) { return; } remainUsdCents = buyIfAvailable(buyer, remainUsdCents, txHash, gvOptionToken10, 2, option10perCent); } }",
        "url": 475
    },
    {
        "code_input": "from web3 import Web3, HTTPProvider\n\n# Set up the web3 instance\nw3 = Web3(HTTPProvider('http://localhost:8545'))  # replace with your Ethereum node URL\n\n# Set the contract address\ncontract_address = '0xYourContractAddress'\n\n# Set the contract instance\ncontract = w3.eth.contract(address=contract_address, abi='YourABI')  # replace with your contract ABI\n\ndef calc_unclaimed_fees(gav):\n    # Get the last unclaimed fee allocation timestamp\n    at_last_",
        "gt": "contract c24277{ function calcUnclaimedFees(uint gav) view returns ( uint managementFee, uint performanceFee, uint unclaimedFees) { uint timePassed = sub(now, atLastUnclaimedFeeAllocation.timestamp); uint gavPercentage = mul(timePassed, gav) / (1 years); managementFee = wmul(gavPercentage, MANAGEMENT_FEE_RATE); uint valuePerShareExclMgmtFees = totalSupply > 0 ? calcValuePerShare(sub(gav, managementFee), totalSupply) : toSmallestShareUnit(1); if (valuePerShareExclMgmtFees > atLastUnclaimedFeeAllocation.highWaterMark) { uint gainInSharePrice = sub(valuePerShareExclMgmtFees, atLastUnclaimedFeeAllocation.highWaterMark); uint investmentProfits = wmul(gainInSharePrice, totalSupply); performanceFee = wmul(investmentProfits, PERFORMANCE_FEE_RATE); } unclaimedFees = add(managementFee, performanceFee); } }",
        "url": 476
    },
    {
        "code_input": "class TokenContract:\n    def __init__(self, owner, community_tokens_address, trading_open):\n        self.owner = owner\n        self.community_tokens_address = community_tokens_address\n        self.trading_open = trading_open\n\n    def transfer_from(self, _from, _to, _value):\n        if self.trading_open or (_from == self.owner or _from == self.community_tokens_address):\n            return super().transferFrom(_from, _to, _value)\n        return False",
        "gt": "contract c24151{ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { if(tradingOpen() || msg.sender == owner || msg.sender == communityTokensAddress) { return super.transferFrom(_from, _to, _value); } return false; } }",
        "url": 477
    },
    {
        "code_input": "class Army:\n    def __init__(self):\n        self.soldiersCount = 0\n\nclass Game:\n    def __init__(self):\n        self.armies = {}\n\n    def purchase_soldiers(self, army_id, count_soldiers):\n        if army_id not in self.armies:\n            self.armies[army_id] = Army()\n        army = self.armies[army_id]\n        if army.soldiersCount + count_soldiers > 1000:\n            return \"Not enough soldiers\"\n        else:",
        "gt": "contract c30283{ function purchaseSoldiers(uint _armyId, uint _countSoldiers) public payable { require(msg.value > 0); uint256 msgValue = msg.value; if(msgValue == 1000000000000000 && _countSoldiers == 1) { armies[_armyId].soldiersCount = armies[_armyId].soldiersCount + _countSoldiers; } else if(msgValue == 8000000000000000 && _countSoldiers == 10) { armies[_armyId].soldiersCount = armies[_armyId].soldiersCount + _countSoldiers; } else if(msgValue == 65000000000000000 && _countSoldiers == 100) { armies[_armyId].soldiersCount = armies[_armyId].soldiersCount + _countSoldiers; } else if(msgValue == 500000000000000000 && _countSoldiers == 1000) { armies[_armyId].soldiersCount = armies[_armyId].soldiersCount + _countSoldiers; } } }",
        "url": 478
    },
    {
        "code_input": "class C24644:\n    def __init__(self, web3, account):\n        self.web3 = web3\n        self.account = account\n        self.contract = None\n        self.minters = {}\n\n    def deploy(self):\n        with open(\"C24644.sol\") as f:\n            code = f.read()\n        self.contract = self.web3.eth.contract(abi=code[7:], bytecode=code[:7])\n        tx_hash = self.contract.deploy({\"from\": self.account, \"gas\": 300000})\n        self.web3.eth.waitForTransaction(tx_hash)\n\n    def addMinter(self, _contract):\n        if _contract != self.",
        "gt": "contract c24644{ function addMinter(address _contract) onlyOwner canMint public returns (bool) { require(_contract != address(0)); require(!minters[_contract]); minters[_contract] = true; return true; } }",
        "url": 479
    },
    {
        "code_input": "The given Solidity code is a contract for a token distribution system. The contract has a function `distributeTokens` that is used to distribute tokens to the pool owners. This function is only available to the pool owner.\n\nHere's a high-level description of the main functionality and logic of the code:\n\n1. The function `distributeTokens` is declared as public, meaning it can be called by anyone.\n2. The function is only available to the pool owner. This is checked using the `onlyPoolOwner` modifier.\n3. The function first checks if the token is whitelisted. If it's not, it throws an error message \"Token is not whitelisted to be distributed\".\n4. It then checks if the distribution is currently active. If it is, it throws an error message \"Distribution is already active\".\n5. If all checks pass, it sets the `distributionActive` flag to true.\n6. It then creates an instance of the ERC677 token contract for the given token.\n7. It calculates the current balance of the token in the contract, excluding the token's own balance.\n8. It checks if the",
        "gt": "contract c1996{ function distributeTokens(address _token) public onlyPoolOwner() { require(tokenWhitelist[_token], \"Token is not whitelisted to be distributed\"); require(!distributionActive, \"Distribution is already active\"); distributionActive = true; ERC677 erc677 = ERC677(_token); uint256 currentBalance = erc677.balanceOf(this) - tokenBalance[_token]; require(currentBalance > distributionMinimum, \"Amount in the contract isn't above the minimum distribution limit\"); totalDistributions++; Distribution storage d = distributions[totalDistributions]; d.owners = ownerMap.size(); d.amount = currentBalance; d.token = _token; d.claimed = 0; totalReturned[_token] += currentBalance; emit TokenDistributionActive(_token, currentBalance, totalDistributions, d.owners); } }",
        "url": 480
    },
    {
        "code_input": "class C16401:\n    def __init__(self, contract_instance):\n        self.contract_instance = contract_instance\n        self.deed_owner = {}\n        self.owned_deeds = {}\n        self.total_deeds = 0\n\n    def remove_deed(self, from_address, deed_id):\n        if self.deed_owner.get(deed_id) == from_address:\n            deed_index = self.deed_owner.get(deed_id)\n            last_deed_index = len(self.owned_deeds[from_address]) - 1\n            last_de",
        "gt": "contract c16401{ function removeDeed(address _from, uint256 _deedId) private { require(deedOwner[_deedId] == _from); uint256 deedIndex = ownedDeedsIndex[_deedId]; uint256 lastDeedIndex = ownedDeeds[_from].length.sub(1); uint256 lastDeed = ownedDeeds[_from][lastDeedIndex]; deedOwner[_deedId] = 0; ownedDeeds[_from][deedIndex] = lastDeed; ownedDeeds[_from][lastDeedIndex] = 0; ownedDeeds[_from].length--; ownedDeedsIndex[_deedId] = 0; ownedDeedsIndex[lastDeed] = deedIndex; totalDeeds = totalDeeds.sub(1); } }",
        "url": 481
    },
    {
        "code_input": "class C2013Contract:\n    def __init__(self, status, winner_bids, assigned_bids, shares_holders_balance):\n        self.status = status\n        self.winner_bids = winner_bids\n        self.assigned_bids = assigned_bids\n        self.shares_holders_balance = shares_holders_balance\n\n    def get_share_balance(self, msg_sender):\n        if self.status != 'success':\n            raise ValueError('Status is not success')\n        if self.winner_bids != self.assigned_bids:\n            raise ValueError('Winner bids are not equal to assigned bids')\n        return self.shares_holders_balance.get(msg_sender, 0)",
        "gt": "contract c2013{ function getShareBalance() view public returns (uint256 share_balance){ require(status == state.success); require(winner_bids == assigned_bids); share_balance = shares_holders_balance[msg.sender]; } }",
        "url": 482
    },
    {
        "code_input": "The given Solidity contract is a bid system for a specific auction. It includes functions to seal a bid, unseal a bid, and perform various operations on the bids.\n\nHere's a high-level description of the main functionality:\n\n1. `unsealBid`: This function is used to unseal a bid. It takes three parameters: a hash of the auction, the value of the bid, and a salt for the bid. The function first checks if the bid exists and is not sealed. If the bid is sealed, it is removed from the sealedBids mapping. Then, it calculates the seal of the bid and retrieves the corresponding Deed from the sealedBids mapping. If the Deed exists, it sets the balance of the bid to the value of the bid and updates the auction state. If the auction state is Owned, the bid is closed with a status code 5. If the auction state is not Reveal, the function reverts. If the value of the bid is less than the minimum price, the bid is closed with a status code 995. If the value of the bid is greater than the current highest bid, the highest bid is",
        "gt": "contract c984{ function unsealBid(bytes32 _hash, uint _value, bytes32 _salt) public { bytes32 seal = shaBid(_hash, msg.sender, _value, _salt); Deed bid = sealedBids[msg.sender][seal]; require(address(bid) != 0); sealedBids[msg.sender][seal] = Deed(0); Entry storage h = _entries[_hash]; uint value = min(_value, bid.value()); bid.setBalance(value, true); var auctionState = state(_hash); if (auctionState == Mode.Owned) { bid.closeDeed(5); BidRevealed(_hash, msg.sender, value, 1); } else if (auctionState != Mode.Reveal) { revert(); } else if (value < minPrice || bid.creationDate() > h.registrationDate - revealPeriod) { bid.closeDeed(995); BidRevealed(_hash, msg.sender, value, 0); } else if (value > h.highestBid) { if (address(h.deed) != 0) { Deed previousWinner = h.deed; previousWinner.closeDeed(995); } h.value = h.highestBid; h.highestBid = value; h.deed = bid; BidRevealed(_hash, msg.sender, value, 2); } else if (value > h.value) { h.value = value; bid.closeDeed(995); BidRevealed(_hash, msg.sender, value, 3); } else { bid.closeDeed(995); BidRevealed(_hash, msg.sender, value, 4); } } }",
        "url": 483
    },
    {
        "code_input": "from web3 import Web3, HTTPProvider\n\n# Connect to the Ethereum node\nw3 = Web3(HTTPProvider('http://localhost:854",
        "gt": "contract c27172{ function addSaleWallet (address _wallet) public onlyOwner returns (bool) { require(_wallet != address(0)); saleWallets.push(_wallet); return true; } }",
        "url": 484
    },
    {
        "code_input": "class ContractorRestrictedContract:\n    def __init__(self, _contractor):\n        self._contractor = _contractor\n\n    def onlyContractor(self, func):\n        def wrapper(*args, **kwargs):\n            if msg.sender != self._contractor:\n                raise ValueError(\"Only the contractor can call this function\")\n            return func(*args, **kwargs)\n        return wrapper\n\n    def __getattr__(self, attr):\n        if not hasattr(self, attr):\n            raise TypeError(f\"No such function or method: {attr}\")\n        return getattr(self, attr)",
        "gt": "contract c8614{ modifier onlyContractor(address _contractor) { require(msg.sender == _contractor); _; } }",
        "url": 485
    },
    {
        "code_input": "class Contract:\n    def __init__(self, team_timelock):\n        self.team_timelock = team_timelock\n\n    def release_team_tokens(self):\n        # The function release_team_tokens is a method of the Contract class.\n        # It calls the release method of the team_timelock object.\n        # This is the main logic of the contract.\n        self.team_timelock.release()\n\n# This is a demonstration of the main logic of the function.\n# We create a Contract object and call the release_team_tokens method.\ncontract = Contract(team_timelock=None)  # Assume team_timelock is an instance of a timelock contract\ncontract.release_team_tokens()",
        "gt": "contract c1310{ function releaseTeamTokens() public { teamTimelock.release(); } }",
        "url": 486
    },
    {
        "code_input": "import time\n\nclass Token:\n    def __init__(self, end_time, tokens_left):\n        self.end_time = end_time\n        self.tokens_left = tokens_left\n\n    def has_ended(self):\n        return time.time() > self.end_time or self.tokens_left <= 0\n\n# Usage\ntoken = Token(1614099200, 10)  # end time is 2022-01-01 00:00:00 UTC, tokens left is 10\nprint(token.has_ended())  # False\n\n# After 24 hours, the token should be ended\ntime.sleep(86400)\nprint(",
        "gt": "contract c34489{ function hasEnded() public constant returns (bool) { return ((now > endTime) || (tokensLeft <= 0)) ; } }",
        "url": 487
    },
    {
        "code_input": "class C52:\n    def __init__(self):\n        self.NAME = \"UNKNOWN\"\n\n    def name(self):\n        return self.NAME",
        "gt": "contract c52{ function name() public view returns (string) { return NAME; } }",
        "url": 488
    },
    {
        "code_input": "def change_exchange(wallets, bonuses, Roles, financialStrategy, exchange, _ETHUSD, minPay, rate, hardCap, softCap, wallet, value):\n    # Check if the sender is a manager or observer\n    if Roles.manager not",
        "gt": "contract c17918{ function changeExchange(uint256 _ETHUSD) public { require(wallets[uint8(Roles.manager)] == msg.sender || wallets[uint8(Roles.observer)] == msg.sender); require(_ETHUSD >= 1 ether); softCap=softCap.mul(exchange).div(_ETHUSD); hardCap=hardCap.mul(exchange).div(_ETHUSD); minPay=minPay.mul(exchange).div(_ETHUSD); rate=rate.mul(_ETHUSD).div(exchange); for (uint16 i = 0; i < bonuses.length; i++) { bonuses[i].value=bonuses[i].value.mul(exchange).div(_ETHUSD); } financialStrategy.setup(wallets[uint8(Roles.beneficiary)], exchange, _ETHUSD, 5); exchange=_ETHUSD; } }",
        "url": 489
    },
    {
        "code_input": "def div(a, b):\n    if b == 0:\n        raise ValueError(\"Division by zero is undefined\")\n    return a / b",
        "gt": "contract c33260{ function div(uint256 a, uint256 b) internal returns (uint256) { assert(b > 0); uint256 c = a / b; return c; } }",
        "url": 490
    },
    {
        "code_input": "The given Solidity code is a contract for a token transfer function. The contract is named `c19101` and it has a function `drop`. This function is used to transfer tokens from the caller's address to a specified recipient. The function takes three parameters:\n\n1. `_token`: This is a pointer to the token contract that will be used for the transfer.\n2. `_recipients`: This is an array of addresses where the tokens will be transferred to.\n3. `_values`: This is an array of amounts of tokens to be transferred.\n\nThe function is marked as `public`, meaning it can be called by anyone. The `only_owner` modifier is also used, meaning the function can only be called by the contract's owner.\n\nThe function uses a for loop to iterate over the `_values` array. For each iteration, it calls the `transfer` function of the `_token` contract, passing the `_recipients` array's element and the `_values` array's element as arguments.\n\nHere's a Python code that demonstrates the main logic of the function:\n",
        "gt": "contract c19101{ function drop(IToken _token, address[] _recipients, uint[] _values) public only_owner { for (uint i = 0; i < _values.length; i++) { _token.transfer(_recipients[i], _values[i]); } } }",
        "url": 491
    },
    {
        "code_input": "class TokenContract:\n    def __init__(self, token_contract_address):\n        self.token_contract_address = token_contract_address\n        self.balances = {}\n        self.wei_raised = 0\n\n    def refund(self, to_address):\n        # Check if the caller is the token contract address\n        if msg.sender != self.token_contract_address:\n            raise ValueError(\"Only the token contract can refund tokens.\")\n\n        # Check if the recipient address exists in the balances dictionary\n        if to_address not in self.balances:\n            raise ValueError(f\"No tokens to refund to address {to_address}.\")\n\n        # Calculate the value to return\n        value_to_return = self.balances[to_address]\n\n        # Set the balance of the recipient",
        "gt": "contract c13437{ function refund(address _to) public refundAllowed { require(msg.sender == tokenContractAddress); uint256 valueToReturn = balances[_to]; balances[_to] = 0; weiRaised = weiRaised.sub(valueToReturn); _to.transfer(valueToReturn); } }",
        "url": 492
    },
    {
        "code_input": "def batch_transfer_eth(addresses, value):\n    # Check if the number of addresses is greater than 0\n    if len(addresses) > 0:\n        # Iterate over the addresses\n        for address in addresses:\n            # Transfer ETH to the address\n            address.transfer(value / len(addresses))",
        "gt": "contract c5031{ function batchTransferETH(address[] _addresses) payable public { require(_addresses.length > 0); for (uint i = 0; i < _addresses.length; i++) { _addresses[i].transfer(msg.value.div(_addresses.length)); } } }",
        "url": 493
    },
    {
        "code_input": "class C15945:\n    def __init__(self, contract_owner):\n        self.proposeOwner = contract_owner\n\n    def propose_new_owner(self, new_owner):\n        if self.is_owner(new_owner):\n            self.proposeOwner = new_owner\n            return True\n        else:\n            return False\n\n    def is_owner(self, account):\n        return account == self.proposeOwner",
        "gt": "contract c15945{ function proposeNewOwner(address _newAddress) external onlyOwner { proposeOwner = _newAddress; } }",
        "url": 494
    },
    {
        "code_input": "class Contract:\n    def __init__(self):\n        self.contract_code = \"\"\"\n        contract c232 {\n            function isPricingStrategy() public constant returns (bool) {\n                return true;\n            }\n        }\n        \"\"\"\n\n    def get_contract_code(self):\n        return self.contract_code\n\n\ncontract = Contract()\nprint(contract.get_contract_code())",
        "gt": "contract c232{ function isPricingStrategy() public constant returns (bool) { return true; } }",
        "url": 495
    },
    {
        "code_input": "class TokenReservationSystem:\n    def __init__(self, contract):\n        self.contract = contract\n        self.external_supporters_map = {}\n        self.tokens_reserved = 0\n\n    def has_ended(self):\n        # This function is not defined in the provided Solidity code.\n        # It's assumed to be a function that checks if the reservation process has ended.\n        pass\n\n    def token_reservation_cancellation(self, wallet, amount):\n        # This function is not defined in the provided Solidity code.\n        # It's assumed to be a function that cancels a token reservation.\n        pass\n\n    def cancel_reserved_tokens(self, wallet, amount):\n        if self.contract.has_end_of_reservation_process():\n            # Check if",
        "gt": "contract c13207{ function cancelReservedTokens(address _wallet, uint256 _amount) public onlyOwner { require(_amount > 0); require(_wallet != address(0)); require(!hasEnded()); require(_amount <= externalSupportersMap[_wallet].reservedAmount); tokensReserved = tokensReserved.sub(_amount); externalSupportersMap[_wallet].reservedAmount = externalSupportersMap[_wallet].reservedAmount.sub(_amount); TokenReservationCancellation(_wallet, _amount); } }",
        "url": 496
    },
    {
        "code_input": "class C9358:\n    def __init__(self, web3, address):\n        self.web3 = web3\n        self.address = address\n        self.contract = None\n\n    def set_contract(self, contract):\n        self.contract = contract\n\n    def set_lockout_period(self, _lockout_period):\n        if self.contract is None:\n            raise Exception(\"Contract not set\")\n        else:\n            tx_hash = self.contract.functions.setLockoutPeriod(_lockout_period).transact()\n            self.web3.eth.wait_for_",
        "gt": "contract c9358{ function setLockoutPeriod(uint _lockoutPeriod) public onlyOwner { lockoutPeriod = _lockoutPeriod; } }",
        "url": 497
    },
    {
        "code_input": "class Contract:\n    def __init__(self, web3):\n        self.web3 = web3\n        self.contract_address = '0x...'  # replace with the contract address\n        self.contract_abi = '...'  # replace with the contract ABI\n        self.contract = self.web3.eth.contract(address=self.contract_address, abi=self.contract_abi)\n\n    def transfer(self, to, value):\n        nonce = self.web3.eth.getTransactionCount(self.contract_address)\n        txn = {\n            'to': to,\n            'value': web3.toWei(value, 'ether'),\n            'gas': 2000000,\n            'gasPrice': web3.to",
        "gt": "contract c8875{ function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } }",
        "url": 498
    },
    {
        "code_input": "class ERC20:\n    def __init__(self):\n        self.allowances = {}\n\n    def approve(self, spender, amount):\n        if spender not in self.allowances:\n            self.allowances[spender] = {}\n        self.allowances[spender][msg.sender] = amount\n        return True",
        "gt": "contract c32284{ function approve(address _spender, uint256 _amount) public returns (bool) { allowances[msg.sender][_spender] = _amount; Approval(msg.sender, _spender, _amount); return true; } }",
        "url": 499
    },
    {
        "code_input": "class C40230:\n    def __init__(self, curator):\n        self.curator = curator\n\n    def clawback(self, amount):\n        if self.curator != msg.sender:\n            raise ValueError(\"Only the curator can call this function.\")\n        if not self.curator.send(amount):\n            raise ValueError(\"Curator's balance is insufficient.\")",
        "gt": "contract c40230{ function clawback() external { if (msg.sender != curator) throw; if (!curator.send(this.balance)) throw; } }",
        "url": 500
    },
    {
        "code_input": "from solc import compile_source\nfrom web3 import Web3, HTTPProvider\n\n# The address of the deployed contract\ncontract_address = '0x...'\n\n# The ABI of the contract\ncontract_abi = '...'\n\n# The",
        "gt": "contract c22697{ function initialize() public onlyOwner { require(!ready); token.mint(ADVISORS,ADVISORY_SHARE); token.mint(BOUNTY,BOUNTY_SHARE); token.mint(COMMUNITY,COMMUNITY_SHARE); token.mint(COMPANY,COMPANY_SHARE); token.mint(PRESALE,PRESALE_SHARE); tokensSold = PRESALE_SHARE; ready = true; SaleReady(); } }",
        "url": 501
    },
    {
        "code_input": "class SmartContract:\n    def __init__(self, contract_address, abi):\n        self.contract_address = contract_address\n        self.abi = abi\n        self.web3 = Web3(Web3.HTTPProvider('http://localhost:8545'))  # Use your own provider\n        self.contract = self.web3.eth.contract(address=self.contract_address, abi=self.abi)\n\n    def transfer(self, to_address, value):\n        nonce = self.web3.eth.getTransactionCount(self.contract_address)\n        txn = {\n            'nonce': nonce,\n            'to': to_address,\n            'value': web3.toWei(value, 'ether'),\n            'gas': 2000000,\n            'gasPrice': web3.toWei('5",
        "gt": "contract c33276{ function transfer(address _to, uint _value) returns (bool success) { require(_value > 0); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } }",
        "url": 502
    },
    {
        "code_input": "The given Solidity code is a contract for a token deposit system. The contract has a function `deposit()` that allows a user to deposit tokens into the contract. The function is `public`, meaning it can be called by anyone, and it is `payable`, meaning it can receive Ether.\n\nThe function `deposit()` first checks if the caller is a whitelisted user. A whitelist is a list of addresses that are allowed to deposit tokens. If the caller is not in the whitelist, the function will revert the transaction.\n\nIf the caller is in the whitelist, the function will add the amount of Ether sent to the contract to the user's balance.\n\nThe function `Deposit(0x0, msg.sender, msg.value, tokens[0x0][msg.sender]);` is a custom function that is not defined in the contract. It seems to be a function that is used to log the deposit event. However, without the actual code, it's hard to provide a concrete demonstration of its main logic.\n\nHere's a simple example of how the `Deposit`",
        "gt": "contract c11122{ function deposit() public payable { require(whitelistedUsers[msg.sender]); tokens[0x0][msg.sender] = tokens[0x0][msg.sender].add(msg.value); Deposit(0x0, msg.sender, msg.value, tokens[0x0][msg.sender]); } }",
        "url": 503
    },
    {
        "code_input": "from eth_utils import to_canonical_address\nfrom eth_keys import keys\nfrom eth_hash.auto import keccak\n\ndef termsAndConditionsAreSigned(v, r, s):\n    # Convert the recovery id to a canonical address\n    r = to_canonical_address(r)\n\n    # Create the message to be hashed\n    message = keccak.new(\n        b\"\\x19Ethereum Signed Message:\\n32\" +\n        len(TERMS_AND_CONDITIONS).to_bytes(1, 'big",
        "gt": "contract c24277{ function termsAndConditionsAreSigned(uint8 v, bytes32 r, bytes32 s) view returns (bool signed) { return ecrecover( keccak256(\"\\x19Ethereum Signed Message:\\n32\", TERMS_AND_CONDITIONS), v, r, s ) == msg.sender; } }",
        "url": 504
    },
    {
        "code_input": "class C19063:\n    def __init__(self, allowed):\n        self.allowed = allowed\n\n    def allowance(self, _owner, _spender):\n        return self.allowed[_owner][_spender]",
        "gt": "contract c19063{ function allowance(address _owner, address _spender) external constant returns (uint256 remaining) { return allowed[_owner][_spender]; } }",
        "url": 505
    },
    {
        "code_input": "class C1550:\n    def __init__(self, token):\n        self.token = token\n\n    def fill_up_allowance(self):\n        amount = self.token.balanceOf(self)\n        if amount > 0:\n            self.token.approve(self.token, amount)",
        "gt": "contract c1550{ function fillUpAllowance() public { uint256 amount = token.balanceOf(this); require(amount > 0); token.approve(token, amount); } }",
        "url": 506
    },
    {
        "code_input": "class DividendContract:\n    def __init__(self, dividend_fund, total_dividend_shares, dividend_shares):\n        self.dividend_fund = dividend_fund\n        self.total_dividend_shares = total_dividend_shares\n        self.dividend_shares = dividend_shares\n\n    def withdraw_dividends(self, sender):\n        if self.dividend_shares[sender] > 0:\n            dividend_shares = self.dividend_shares[sender]\n            assert (dividend_shares <= self.total_dividend_shares)\n            amount = self.dividend_fund.mul(dividend_shares).div",
        "gt": "contract c3518{ function withdrawDividends() public { require(dividendShares[msg.sender] > 0); uint _dividendShares = dividendShares[msg.sender]; assert(_dividendShares <= totalDividendShares); uint _amount = dividendFund.mul(_dividendShares).div(totalDividendShares); assert(_amount <= this.balance); dividendShares[msg.sender] = 0; totalDividendShares = totalDividendShares.sub(_dividendShares); dividendFund = dividendFund.sub(_amount); msg.sender.transfer(_amount); DividendsWithdrawal(now, msg.sender, _dividendShares, _amount, totalDividendShares, dividendFund); } }",
        "url": 507
    },
    {
        "code_input": "def return_child_address_for_parent(parent):\n    # The function `returnChildAddressForParent` is a part of the contract.\n    # It takes an address as a parameter and returns the address of the child.\n    # The address of the child is obtained by calling the function `returnChildAddressForParent`\n    # with the parent address as the argument.\n    return time.time(0xEe22430595aE400a30FFBA37883363Fbf293e24e).returnChildAddressForParent(parent)",
        "gt": "contract c37108{ function returnChildAddressForParent(address parent) returns(address) { return tme(0xEe22430595aE400a30FFBA37883363Fbf293e24e).returnChildAddressForParent(parent); } }",
        "url": 508
    },
    {
        "code_input": "class TokenSale:\n    def __init__(self, token):\n        self.token = token\n\n    def saleEnded(self):\n        # This is a placeholder for the actual saleEnded function.\n        # It should return True if the sale has ended, False otherwise.\n        return True\n\n    def finalizeSale(self):\n        if self.saleEnded():\n            self.token.burn(self.token.balanceOf(self))\n            self.FinalizeSale()\n\n# Usage\ntoken = Token(1000)  # This is a placeholder for the actual Token class\nsale = TokenS",
        "gt": "contract c13744{ function finalizeSale() public { require( saleEnded() ); token.burn(token.balanceOf(this)); FinalizeSale(); } }",
        "url": 509
    },
    {
        "code_input": "class TokenHolder:\n    def __init__(self, addr):\n        self.addr = addr\n        self.alloced = False\n        self.currentPoints = 0\n        self.lastSnapshot = 0\n        self.tokens = 0\n\n    def checkDividends(self):\n        if self.alloced:\n            self.currentPoints += ((TotalFeesReceived - self.lastSnapshot) * self.tokens)\n            return self.currentPoints / NewTokenSupply\n        else:\n            return 0",
        "gt": "contract c38865{ function checkDividends(address _addr) constant returns(uint _amount) { if (holderAccounts[_addr].alloced) { uint _currentPoints = holderAccounts[_addr].currentPoints + ((TotalFeesReceived - holderAccounts[_addr].lastSnapshot) * holderAccounts[_addr].tokens); _amount = _currentPoints / NewTokenSupply; } } }",
        "url": 510
    },
    {
        "code_input": "from enum import Enum\n\nclass SaleKind(Enum):\n    FixedPrice = 1\n\ndef validate_parameters(sale_kind, expiration_time):\n    if sale_kind == SaleKind.FixedPrice or expiration_time > 0:",
        "gt": "contract c10613{ function validateParameters(SaleKind saleKind, uint expirationTime) pure internal returns (bool) { return (saleKind == SaleKind.FixedPrice || expirationTime > 0); } }",
        "url": 511
    },
    {
        "code_input": "class Contract:\n    MIN_RATE = 0\n    MAX_RATE = 1000000000000000000000000000000000000000000000000000000000000000\n\n    @staticmethod\n    def is_rate_valid(rate):\n        return Contract.MIN_RATE <= rate <= Contract.MAX_RATE",
        "gt": "contract c12273{ function isRateValid(uint256 rate) internal pure returns(bool) { return rate >= MIN_RATE && rate <= MAX_RATE; } }",
        "url": 512
    },
    {
        "code_input": "class TokenContract:\n    def __init__(self, contract_address, abi):\n        self.contract_address = contract_address\n        self.abi = abi\n        self.contract = self.get_contract()\n\n    def get_contract(self):\n        return web3.eth.contract(address=self.contract_address, abi=self.abi)\n\n    def balance_of(self, owner):\n        return self.contract.functions.balanceOf(owner).call()",
        "gt": "contract c22622{ function balanceOf(address _owner) public view returns (uint256 balance) { return ownershipTokenCount[_owner]; } }",
        "url": 513
    },
    {
        "code_input": "class Contract:\n    def __init__(self, contract_name):\n        self.contract_name = contract_name\n\n    def is_at_least(self, a, b):\n        \"\"\"\n        This function checks if a number is greater than or equal to another number.\n        It takes two arguments: a and b. If a is greater than or equal to b, it returns True, otherwise it returns False.\n        \"\"\"\n        is_true = a >= b\n        return is_true\n\n# Create an instance of the contract\nc15470 = Contract('c15470')\n\n# Test the function\nprint(c15470.is_at_least(10, 5))  # Output: True\nprint(c15470.is_at_least(5, 10))  # Output: False",
        "gt": "contract c15470{ function isAtLeast(uint256 a, uint256 b) public pure returns (bool isTrue) { isTrue = a >= b; } }",
        "url": 514
    },
    {
        "code_input": "class C19095:\n    def __init__(self, owner, benefit_funds):\n        self.owner = owner\n        self.benefit_funds = benefit_funds\n\n    def benefit(self):\n        # Check if the benefit funds are greater than 0\n        if self.benefit_funds > 0:\n            # Calculate the planned balance\n            planned_balance = self.balance - self.benefit_funds\n            # Transfer the contract's balance to the owner\n            self.owner.transfer(self.benefit_funds)\n            # Set the benefit funds to 0\n            self.benefit_fund",
        "gt": "contract c19095{ function benefit() public onlyOwner { require(benefitFunds > 0); uint plannedBalance = this.balance - benefitFunds; owner.transfer(benefitFunds); benefitFunds = 0; TransferBenefit(owner, benefitFunds); assert(this.balance == plannedBalance); } }",
        "url": 515
    },
    {
        "code_input": "The given Solidity code is a contract for a diary. The contract has a function `Diary` that takes an address and a bytes as parameters. The bytes parameter is supposed to be a diary entry, but it's not defined in the code. The function is marked as `external`, which means it's a function that can be called by other contracts, but not directly by the owner of the contract. The function is also marked as `notBreakup`, which means it doesn't break the contract's rules. The function is also marked as `oneOfOwners(_sender)`, which means it only allows the function to be called by the owner of the contract. The function is also marked as `callByBank`, which means it's a function that can be called by a bank.\n\nThe contract also has a state variable `next_diary_id`, which is incremented each time a new diary entry is created.\n\nThe main functionality of the contract is to store diary entries. Each diary entry is a page in the diary, which contains a timestamp (`logtime`) and the diary entry itself (`constant`).\n",
        "gt": "contract c30055{ function Diary(address _sender, bytes _diary) external notBreakup oneOfOwners(_sender) callByBank { diary[next_diary_id]=DiaryPage({ logtime: uint64(now), contant: _diary }); next_diary_id++; } }",
        "url": 516
    },
    {
        "code_input": "This function works as follows:\n\n1. It takes an `amount` as input.\n2. It divides the `amount` by the `current_mul()` function, which is a function that is not defined in the contract.\n3. It then multiplies the result of the division by the `current_mul()` function again.\n4. The result of this operation is returned as the `fixed_amount`.\n\nIf `current_mul()` is not defined in the contract, it's not clear what its main logic is. If it's a mathematical operation, it would be the same as the previous function. If it's a",
        "gt": "contract c3554{ function fix_amount(uint amount) public view returns(uint fixed_amount){ return ( amount / current_mul() ) * current_mul(); } }",
        "url": 517
    },
    {
        "code_input": "class Contract:\n    def __init__(self, owner, cents_per_month):\n        self.owner = owner\n        self.cents_per_month = cents_per_month\n\n    def set_cents_per_month(self, amount):\n        self.cents_per_month = amount",
        "gt": "contract c23940{ function setCentsPerMonth(uint256 amount) onlyOwner public { centsPerMonth=amount; } }",
        "url": 518
    },
    {
        "code_input": "The provided Solidity code is a contract for a smart contract that allows a contract owner to remove an owner from the contract. The contract has several functions, including `approveRemoveOwnerRequest`, which is used to approve a remove owner request.\n\nHere's a high-level description of the main functionality and logic of the code:\n\n1. The `approveRemoveOwnerRequest` function is a public function that can only be called by the contract owner.\n\n2. The function first checks if there are more than 2 owners in the contract and if there are more approvals needed to confirm the remove operation.\n\n3. It then checks if the remove operation is not already executed and not canceled.\n\n4. It also checks if the remove operation is within the lifespan of the contract.\n\n5. It then checks if the caller of the function is not already a confirmator of the remove operation.\n\n6. If all the conditions are met, it increments the number of confirmators and adds the caller to the list of confirmators.\n\n7. If the number of confirmators reaches the required number, it sets the `is",
        "gt": "contract c13919{ function approveRemoveOwnerRequest () public onlyOwners { require (ownersCount - 1 >= needApprovesToConfirm && ownersCount > 2); require (owners[removeOwners.newOwner]); require (!removeOwners.isExecute && !removeOwners.isCanceled); require (removeOwners.creationTimestamp + lifeTime >= uint32(now)); for (uint i = 0; i < removeOwners.confirmators.length; i++){ require(removeOwners.confirmators[i] != msg.sender); } removeOwners.confirms++; removeOwners.confirmators.push(msg.sender); if(removeOwners.confirms >= needApprovesToConfirm){ removeOwners.isExecute = true; owners[removeOwners.newOwner] = false; ownersCount--; _removeOwnersAproves(removeOwners.newOwner); } emit RemoveOwnerRequestUpdate(msg.sender, removeOwners.confirms, removeOwners.isExecute); } }",
        "url": 519
    },
    {
        "code_input": "def returnFundsFor(account):\n    # Check if the sender is the contract itself or the icoManager\n    if msg.sender != address(this) and msg.sender != icoManager and msg.sender != account:\n        raise ValueError(\"Only the contract itself, the icoManager or the account can call this function\")\n\n    # Check if the soldTokensOnIco is less than the minIcoTokenLimit\n    if soldTokensOnIco < minIcoTokenLimit:\n        raise ValueError(\"The soldTokensOnIco is less than the minIcoTokenLimit\")\n\n    # Check if the account has any funds\n    if balances[account] <= 0:\n        raise ValueError(\"The",
        "gt": "contract c36178{ function returnFundsFor(address _account) onGoalAchievedOrDeadline { assert(msg.sender == address(this) || msg.sender == icoManager || msg.sender == _account); assert(soldTokensOnIco < minIcoTokenLimit); assert(balances[_account] > 0); _account.transfer(balances[_account]); balances[_account] = 0; ReturnFundsFor(_account); } }",
        "url": 520
    },
    {
        "code_input": "The given Solidity code is a contract for a token. The contract has a function `burn()` that is used to burn tokens. Here's a high-level description of the main functionality and logic of the code:\n\n1. The `burn()` function is declared as `public` and `payable`. This means that the function can be called by anyone, and it can receive Ether.\n\n2. Inside the function, the following steps are performed:\n\n   - The amount of Ether sent to the contract is added to the sender's balance in the `balances` mapping.\n\n   - The total supply of tokens is increased by the amount of Ether sent to the contract.\n\n   - The `transfer()` function is called with the address `0`, which is the zero address. This is a special address that represents the contract's own balance. The amount of Ether sent to this address is the amount of tokens that were burned.\n\n   - The `Transfer` event is emitted, which is a standard event in Ethereum that is triggered when a transfer occurs. The parameters are the `from` address, the `to` address, and",
        "gt": "contract c5398{ function burn() public payable{ balances[msg.sender] += msg.value; _totalSupply += msg.value; address(0).transfer(msg.value); emit Transfer(address(0), msg.sender, _totalSupply); } }",
        "url": 521
    },
    {
        "code_input": "class EthereumContract:\n    def __init__(self, contract_address):\n        self.contract_address = contract_address\n\n    def get_maximum_funds(self):\n        # Get the maximum funds in wei from the contract\n        # This is a placeholder, as the actual implementation depends on the contract's logic\n        maximum_funds_in_wei = 1000000000000000000000000000000000000000000000000000000000000000\n        return maximum_funds_in_wei\n\n# Create an instance of the EthereumContract class\ncontract = EthereumContract('0xYourContract",
        "gt": "contract c31533{ function getMaximumFunds() internal constant returns (uint) { return euroCents2wei(getMaximumFundsInEuroCents()); } }",
        "url": 522
    },
    {
        "code_input": "The given Solidity contract is a basic example of a token transfer contract. It's a part of a dApp (Decentralized Application) where users can transfer tokens to each other.\n\nHere's a high-level description of the main functionality and logic of the code:\n\n1. The contract is an external contract, which means it can be called by other contracts.\n\n2. The `transfer` function is an external function that can be called by other contracts. It takes two parameters: `_to`, which is the address to which the tokens should be transferred, and `_tulipId`, which is the ID of the tulip token to be transferred.\n\n3. The function first checks if the `_to` address is not the address of the contract itself (`address(this)`) and if it's not the address zero (`address(0)`).\n\n4. It then checks if the caller of the function is the owner of the tulip token with the given `_tulipId`.\n\n5. If all checks pass, it calls the `_transfer` function, which is a custom function that transf",
        "gt": "contract c26367{ function transfer( address _to, uint256 _tulipId ) external whenNotPaused { require(_to != address(0)); require(_to != address(this)); require(tulipIdToOwner[_tulipId] == msg.sender); _transfer(msg.sender, _to, _tulipId); } }",
        "url": 523
    },
    {
        "code_input": "import datetime\nfrom dateutil.relativedelta import relativedelta\n\nclass TaskContract:\n    def __init__(self, release_date):\n        self.release_date = release_date\n\n    def is_task_released(self):\n        current_date = datetime.datetime.now()\n        release_date = datetime.datetime.strptime(self.release_date, \"%Y-%m-%d\")\n        if current_date >= release_date:\n            return True\n        else:\n            return False\n\n    def only_when_released(self, func):\n        def wrapper(*args, **kwargs):\n            if self.is_task_released():\n                return func(*args, **kwargs)\n            else:\n                print(\"The task is not released yet.\")\n        return wrapper\n\n# Usage",
        "gt": "contract c18281{ modifier onlyWhenReleased { require(now >= releaseDate); _; } }",
        "url": 524
    },
    {
        "code_input": "class C20594:\n    def __init__(self):\n        self.playerPool = []\n\n    def buyIn(self, amount):\n        if amount != 1:\n            raise ValueError(\"Payment must be in the form of 1 Ether\")\n        self.playerPool.append(msg.sender)\n        self.BoughtIn(msg.sender)\n        if len",
        "gt": "contract c20594{ function buyIn() payable public returns (uint) { if (msg.value * 10 != 1 ether) { revert(); Rejected(); } else { playerPool.push(msg.sender); BoughtIn(msg.sender); if (playerPool.length >= 11) { selectWinner(); } } return playerPool.length; } }",
        "url": 525
    },
    {
        "code_input": "The given Solidity code is a contract for a smart contract. It's a function named `payBankroll` that takes no arguments and doesn't return anything. This function is supposed to pay the bankroll of the contract.\n\nHere's a high-level description of the main functionality and logic of the code:\n\n1. It first calculates the amount of Ether to be paid by subtracting the total amount of Ether collected from the total amount of Ether received.\n\n2. It then checks if the calculated amount is greater than 1 Ether. If it is, it means that the contract has enough Ether to pay the bankroll.\n\n3. If the calculated amount is greater than or equal to 1 Ether, it adds the calculated amount to the total amount of Ether received.\n\n4. It then sends this amount of Ether to the address that the contract has been given. This is done using the `call.value(ethToPay).gas(400000)()` function, which is a way to send Ether to a contract's address.\n\n5. If the transaction to the contract's address fails, it means",
        "gt": "contract c1880{ function payBankroll() payable public { uint256 ethToPay = SafeMath.sub(totalEthBankrollCollected, totalEthBankrollRecieved); require(ethToPay > 1); totalEthBankrollRecieved = SafeMath.add(totalEthBankrollRecieved, ethToPay); if(!giveEthBankrollAddress.call.value(ethToPay).gas(400000)()) { totalEthBankrollRecieved = SafeMath.sub(totalEthBankrollRecieved, ethToPay); } } }",
        "url": 526
    },
    {
        "code_input": "The given Solidity code is a contract for a token transfer function. Here's a high-level description of the main functionality and logic:\n\n1. The contract is named `c17640`.\n\n2. The function `transferFrom` is declared. This function is a public function that transfers a certain amount of tokens from one address to another.\n\n3. The function takes three parameters: `from`, `to`, and `tokens`.\n\n4. `from` is the address of the sender of the tokens.\n\n5. `to` is the address to which the tokens are to be transferred.\n\n6. `tokens` is the amount of tokens to be transferred.\n\n7. The function returns a boolean value. If the function is successful, it returns `true`.\n\n8. Inside the function, the following steps are performed:\n\n   - The sender's balance is reduced by the amount of tokens being transferred.\n\n   - The sender's allowance is reduced by the amount of tokens being transferred.\n\n   - The recipient's balance is increased by the amount of tokens being transferred.\n\n   -",
        "gt": "contract c17640{ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } }",
        "url": 527
    },
    {
        "code_input": "class TokenContract:\n    def __init__(self, owner, rate_per_wei):\n        self.owner = owner\n        self.rate_per_wei = rate_per_wei\n\n    def set_price_rate(self, new_price):\n        # Check if the caller is the owner\n        if self.owner != self.msg.sender:\n            raise ValueError(\"Only the contract owner can call this function\")\n\n        # Set the new price\n        self.rate_per_wei = new_price\n\n    # Function to get the current price rate\n    def get_price_rate(self):\n        return self.rate_per_wei",
        "gt": "contract c10059{ function setPriceRate(uint256 newPrice) public onlyOwner { ratePerWei = newPrice; } }",
        "url": 528
    },
    {
        "code_input": "class ERC20Basic:\n    def __init__(self):\n        self.distributed = False\n        self.holders = []\n        self.coeff = 0\n\n    def distribute_token(self, _token, _targetTotalSupply):\n        if not self.distributed:\n            self.distributed = True\n            for i in range(len(self.holders)):\n                holder_amount = _targetTotalSupply * self.holders[i].ratio / self.coeff\n                _token.deliver_tokens(self.holders[i].addr, holder_amount)\n            self.emit_distributed()\n\n    def emit_distributed(self):\n        print(\"Dist",
        "gt": "contract c10165{ function distributeToken(ERC20Basic _token, uint256 _targetTotalSupply) internal { require(!distributed, \"Already distributed\"); distributed = true; for (uint8 i = 0; i < holders.length; i++) { uint256 holderAmount = _targetTotalSupply.mul(uint256(holders[i].ratio)).div(coeff); deliverTokens(_token, holders[i].addr, holderAmount); } emit Distributed(); } }",
        "url": 529
    },
    {
        "code_input": "class TokenContract:\n    def __init__(self, owner):\n        self.owner = owner\n\n    def spend_token(self, tokens):\n        # Transfer tokens from the caller to the contract's owner\n        self.transfer_tokens(self.owner, tokens)\n\n        # Log that tokens have been spent\n        self.tokens_spent(self.owner, tokens)\n\n        return True\n\n    def transfer_tokens(self, to, tokens):\n        # Here, you would typically implement the logic to transfer tokens\n        # This is a placeholder for the actual implementation\n        print(f\"Transferring {tokens} tokens from {self.owner} to {to}\")\n\n    def tokens_spent(self, from_address, tokens):\n        # Log that",
        "gt": "contract c23280{ function spendToken(uint256 _tokens) public returns (bool) { transferTokens(msg.sender, owner, _tokens); TokensSpent(msg.sender, _tokens); return true; } }",
        "url": 530
    },
    {
        "code_input": "class Casino:\n    def __init__(self, balance, bettingLimitMin, bettingLimitMax):\n        self.balance = balance\n        self.bettingLimitMin = bettingLimitMin\n        self.bettingLimitMax = bettingLimitMax\n\n    def bet_on_number(self, number):\n        if number < 0 or number > 36:\n            return \"Please choose a number between 0 and 36\"\n\n        if self.bettingLimitMin <= number <= self.bet",
        "gt": "contract c39295{ function betOnNumber(uint number) public returns (string) { address addr = msg.sender; uint betSize = msg.value; if (betSize < casino.bettingLimitMin || betSize > casino.bettingLimitMax) { if (betSize >= 1*10**18) addr.send(betSize); return \"Please choose an amount within between 1 and 10 ETH\"; } if (betSize * 36 > casino.balance) { addr.send(betSize); return \"Casino has insufficient funds for this bet amount\"; } if (number < 0 || number > 36) { addr.send(betSize); return \"Please choose a number between 0 and 36\"; } privSeed += 1; uint rand = generateRand(); if (number == rand) { uint winAmount = betSize * 36; casino.balance -= (winAmount - betSize); addr.send(winAmount); return \"Winner winner chicken dinner!\"; } else { casino.balance += betSize; return \"Wrong number.\"; } } }",
        "url": 531
    },
    {
        "code_input": "class c12016:\n    def __init__(self, contract_instance):\n        self.contract_instance = contract_instance\n        self.flips = {}\n        self.owner = None\n        self.tokensRequiredForAllWins = 0\n\n    def set_owner(self, new_owner):\n        self.owner = new_owner\n\n    def set_tokens_required_for_all_wins(self, new_value):\n        self.tokensRequiredForAllWins = new_value\n\n    def create_flip(self, flip_id, number_of_coin_sides, bet_currency, bet_tokens):\n        if flip_id in self.flips:\n            raise Exception(\"Flip already exists\")\n        self.flips[flip_id",
        "gt": "contract c12016{ function refundFlip(bytes32 _flipId) external { require(msg.sender == flips[_flipId].owner || msg.sender == owner, \"Refund caller is not owner of this flip.\"); require(!flips[_flipId].completed, \"Trying to refund completed flip.\"); flips[_flipId].completed = true; if(flips[_flipId].currency == BetCurrency.ETH) { flips[_flipId].owner.transfer(flips[_flipId].betETH); } else { assert(token.transfer(flips[_flipId].owner, flips[_flipId].betTokens)); } tokensRequiredForAllWins = tokensRequiredForAllWins.sub(flips[_flipId].betTokens.mul(flips[_flipId].numberOfCoinSides)); flips[_flipId].status = FlipStatus.Refunded; emit FlipEnded(_flipId, flips[_flipId].owner, flips[_flipId].winTokens); } }",
        "url": 532
    },
    {
        "code_input": "class Token:\n    def __init__(self, owner, verification_period, verification_slashing_period):\n        self.owner = owner\n        self.verification_period = verification_period\n        self.verification_slashing_period = verification_slashing_period\n\n    def set_verification_slashing_period(self, new_slashing_period):\n        if self.verification_period + new_slashing_period > 256:\n            raise ValueError(\"New slashing period exceeds verification period\")\n        else:\n            self.verification_slashing_period = new_slashing_period\n            print(\"Verification slashing period updated\")",
        "gt": "contract c16365{ function setVerificationSlashingPeriod(uint256 _verificationSlashingPeriod) external onlyControllerOwner { require(verificationPeriod.add(_verificationSlashingPeriod) <= 256); verificationSlashingPeriod = _verificationSlashingPeriod; ParameterUpdate(\"verificationSlashingPeriod\"); } }",
        "url": 533
    },
    {
        "code_input": "class TimelockedAllocation:\n    def __init__(self, contract):\n        self.contract = contract\n\n    def set_initial_allocation_timelock(self, allocation_address, timelock_till_date):\n        if allocation_address == address(0):\n            raise ValueError(\"Allocation address cannot be zero\")\n        if timelock_till_date < now():\n            raise ValueError(\"Timelock date cannot be in the past\")\n        self.contract.functions.setInitialAllocationTimelock(allocation_address, timelock_till_date).call()",
        "gt": "contract c12429{ function setInitialAllocationTimelock( address allocationAddress, uint32 timelockTillDate ) external onlyController returns (bool) { require(allocationAddress != address(0)); require(timelockTillDate >= now); timelockedAddresses[allocationAddress] = timelockTillDate; emit InitiallAllocationTimelocked(allocationAddress, timelockTillDate); return true; } }",
        "url": 534
    },
    {
        "code_input": "class TokenSale:\n    def __init__(self, contract):\n        self.contract = contract\n\n    def decline(self, _address):\n        tokens_to_mint_in_hold = self.contract.functions.tokensToMintInHold().call()\n        tokens_hold_map = self.contract.functions.tokensHoldMap(_address).call()\n        if tokens_hold_map > 0:\n            self.contract.functions.Declined(_address, tokens_hold_map).transact()\n            self.contract.functions.tokensHoldMap(_address).transact()\n            self.contract.functions.tokensToMintInHold().transact()",
        "gt": "contract c9348{ function decline(address _address) public onlyOwner { tokensToMintInHold = SafeMath.sub(tokensToMintInHold, tokensHoldMap[_address]); Declined(_address, tokensHoldMap[_address]); tokensHoldMap[_address] = 0; } }",
        "url": 535
    },
    {
        "code_input": "class TokenContract:\n    def __init__(self, owner, reserved_tokens_percent):\n        self.owner = owner\n        self.reserved_tokens_percent = reserved_tokens_percent\n\n    def set_reserved_tokens_percent(self, new_reserved_tokens_percent):\n        # The function takes a new percentage for reserved tokens and sets it\n        self.reserved_tokens_percent = new_reserved_tokens_percent",
        "gt": "contract c3813{ function setReservedTokensPercent(uint newReservedTokensPercent) public onlyOwner { reservedTokensPercent = newReservedTokensPercent; } }",
        "url": 536
    },
    {
        "code_input": "class Contract:\n    def __init__(self, owner, bl_address):\n        self.owner = owner\n        self.bl_address = bl_address\n\n    def set_bl_interface(self, new_address):\n        # Check if the new address is valid\n        if not self.is_valid_address(new_address):\n            raise ValueError(\"Invalid address\")\n\n        # Set the new address for the BLInterface\n        self.bl_address = new_address\n\n    def is_valid_address(self, address):\n        # Implement the",
        "gt": "contract c18371{ function setBLInterface(address newAddress) public onlyOwner { BL = BLInterface(newAddress); } }",
        "url": 537
    },
    {
        "code_input": "class Contract:\n    def __init__(self, ambassador_quota, ambassador_max_purchase):\n        self.ambassador_quota = ambassador_quota\n        self.ambassador_max_purchase = ambassador_max_purchase\n        self.ambassadors = {}\n        self.ambassador_accumulated_quota = {}\n\n    def add_ambassador(self, address):\n        self.ambassadors[address] = True\n        self.ambassador_accumulated_quota[address] = 0\n\n    def total_ethereum_balance(self):\n        # This is a placeholder for the actual function that returns the",
        "gt": "contract c15970{ modifier antiEarlyWhale(uint256 _amountOfEthereum){ address _customerAddress = msg.sender; if( onlyAmbassadors && ((totalEthereumBalance() - _amountOfEthereum) <= ambassadorQuota_ )){ require( ambassadors_[_customerAddress] == true && (ambassadorAccumulatedQuota_[_customerAddress] + _amountOfEthereum) <= ambassadorMaxPurchase_ ); ambassadorAccumulatedQuota_[_customerAddress] = SafeMath.add(ambassadorAccumulatedQuota_[_customerAddress], _amountOfEthereum); _; } else { onlyAmbassadors = false; _; } } }",
        "url": 538
    },
    {
        "code_input": "class TokenContract:\n    def __init__(self, contract_address, seller, total_iou_purchased, total_iou_withdrawn):\n        self.contract_address = contract_address\n        self.seller = seller\n        self.total_iou_purchased = total_iou_purchased\n        self.total_iou_withdrawn = total_iou_withdrawn\n\n    def withdraw_tokens(self):\n        # Get the balance of the contract address\n        balance = self.get_balance()\n\n        # Subtract the total iou purchased and withdrawn\n        tokens_to_withdraw = balance - (self.total_iou_purchased - self.total_iou_withdrawn)\n\n        # Transfer the tokens to the seller",
        "gt": "contract c38592{ function withdrawTokens() pwner { token.transfer(seller, token.balanceOf(address(this)) - (total_iou_purchased - total_iou_withdrawn)); } }",
        "url": 539
    },
    {
        "code_input": "class C34210:\n    def __init__(self, contract_address, web3):\n        self.contract_address = contract_address\n        self.web3 = web3\n        self.contract = self.web3.eth.contract(address=self.contract_address, abi=[...])\n\n    def update_whitelisted_contribution(self, planned_contribution):\n        # Get the current whitelisted contributions\n        whitelisted_contributions = self.contract.functions.whitelistedPlannedContributions().call()\n\n        # Subtract the planned contribution from the whitelisted contributions\n        new_whitelisted_contributions = whitelisted_contributions - planned_contribution\n\n        # Update the whitelisted contributions\n        self.contract.functions.",
        "gt": "contract c34210{ function updateWhitelistedContribution(uint256 plannedContribution) private { whitelistedPlannedContributions = whitelistedPlannedContributions.sub(plannedContribution); WhitelistedCounterUpdated(whitelistedPlannedContributions, plannedContribution); } }",
        "url": 540
    },
    {
        "code_input": "class C927Contract:\n    def __init__(self, owner, eth_price):\n        self.owner = owner\n        self.eth_price = eth_price\n\n    def set_eth_price(self, new_price):\n        if self.owner != self.get_owner():\n            raise Exception(\"Only the contract owner can set the Ethereum price.\")\n        self.eth_price = new_price\n\n    def get_owner(self):\n        return self.owner\n\n    def get_eth_price(self):\n        return self.eth_price",
        "gt": "contract c927{ function setEthPrice(uint256 _value) onlyOwner public { ethPrice = _value; } }",
        "url": 541
    },
    {
        "code_input": "def wallet_deposit(token, amount, wallet_balance):\n    # Log the wallet deposit\n    log_wallet_deposit(msg.sender, token, amount, wallet_balance)",
        "gt": "contract c5438{ function walletDeposit( address _token, uint256 _amount, uint256 _walletBalance ) external { LogWalletDeposit(msg.sender, _token, _amount, _walletBalance); } }",
        "url": 542
    },
    {
        "code_input": "The given Solidity code is a contract for a CounterStack contract. The CounterStack contract is a data structure that allows for efficient storage and retrieval of data. The contract is designed to track the ownership of a certain number of stacks, and to track the nonce of each stack.\n\nHere's a high-level description of the main functionality and logic of the code:\n\n1. The contract has a function `submitCounterStack` that is public and takes in several parameters. These parameters are `_stack`, `_id`, `_id2`, `_id3`, `_id4`, and `_id5`.\n\n2. The function first checks that the current time is not equal to zero (`slammerTime`). If it is, the function will revert the transaction.\n\n3. The function then checks that the `tokenIndexToOwner` mapping for the given `_id`, `_id2`, `_id3`, `_id4`, and `_id5` is not zero, and that the owner of the token at that index is the sender of the transaction. If any of these conditions are not",
        "gt": "contract c20389{ function submitCounterStack(bytes32 _stack, uint256 _id, uint256 _id2, uint256 _id3, uint256 _id4, uint256 _id5) public returns (bool) { require(slammerTime!=address(0)); require(tokenIndexToOwner[_id]==msg.sender); require(tokenIndexToOwner[_id2]==msg.sender); require(tokenIndexToOwner[_id3]==msg.sender); require(tokenIndexToOwner[_id4]==msg.sender); require(tokenIndexToOwner[_id5]==msg.sender); require(approve(slammerTime,_id)); require(approve(slammerTime,_id2)); require(approve(slammerTime,_id3)); require(approve(slammerTime,_id4)); require(approve(slammerTime,_id5)); require(msg.sender!=stacks[_stack].owner); bytes32 counterstack = keccak256(nonce++,msg.sender,_id); uint256[5] memory ids = [_id,_id2,_id3,_id4,_id5]; stacks[counterstack] = Stack(ids,msg.sender,uint32(block.number)); stackCounter[counterstack] = _stack; CounterStack(msg.sender,now,_stack,counterstack,_id,_id2,_id3,_id4,_id5); } }",
        "url": 543
    },
    {
        "code_input": "class Token:\n    def __init__(self, contract):\n        self.contract = contract\n\n    def balance_of(self, address):\n        # Get the balance of the address\n        balance = self.contract.functions.balanceOf(address).call()\n        return balance",
        "gt": "contract c9358{ function balanceOf(address a) public view returns (uint) { return controller.balanceOf(a); } }",
        "url": 544
    },
    {
        "code_input": "class ICO:\n    def __init__(self, ICO_START, ICO_FINISH):\n        self.ICO_START = ICO_START\n        self.ICO_FINISH = ICO_FINISH\n\n    def isIco(self, _time):\n        if (_time == 0):\n            _time = int(time.time())\n        if self.ICO_START < _time and _time <= self.ICO_FINISH:\n            return True\n        return False",
        "gt": "contract c14939{ function isIco (uint _time) public view returns (bool) { if (_time == 0){ _time = now; } if (ICO_START < _time && _time <= ICO_FINISH){ return true; } return false; } }",
        "url": 545
    },
    {
        "code_input": "class TokenDistributor:\n    def __init__(self):\n        self.balances = {}\n\n    def issue_token(self, beneficiary, tokens):\n        if beneficiary in self.balances:\n            self.balances[beneficiary] += tokens\n        else:\n            self.balances[beneficiary] = tokens",
        "gt": "contract c35554{ function issueToken(address beneficiary, uint256 tokens) internal { balances[beneficiary] = balances[beneficiary].add(tokens); } }",
        "url": 546
    },
    {
        "code_input": "class IcoToken:\n    def __init__(self, owner, start_date, total_token_supply):\n        self.owner = owner\n        self.start_date = start_date\n        self.total_token_supply = total_token_supply\n        self.ico_token_supply = 0\n\n    def set_ico_token_supply(self, ico_token_supply):\n        if self.owner != self.get_owner():\n            raise Exception(\"Only the contract owner can set the token supply.\")\n        if self.get_start_date() > now:\n            raise Exception(\"The start date is in the future.\")\n        if ico_token_supply > self.get_total_token_supply():\n            raise",
        "gt": "contract c37669{ function setIcoTokenSupply(uint _icoTokenSupply) onlyOwner { require(now < START_DATE); require(_icoTokenSupply < TOTAL_TOKEN_SUPPLY); icoTokenSupply = _icoTokenSupply; LogIcoTokenSupplyUpdated(icoTokenSupply); } }",
        "url": 547
    },
    {
        "code_input": "class ERC20:\n    def __init__(self, contract_address):\n        self.contract_address = contract_address\n\n    def allowance(self, _from, _spender, _symbol):\n        # This is a placeholder for the actual function call to the ERC20 contract.\n        # The actual function call would depend on the specific ERC20 contract.\n        # For example, in the ERC20Basic contract, the allowance function would be:\n        # allowance = self.get_balance(_from, _symbol) - self.get_balance(_spender, _symbol)\n        # In this example, the actual function call would be:\n        # allowance = self.contract_address.get_balance(_from, _symbol) - self.contract_address.get_balance(_spender, _symbol)\n        return self.cont",
        "gt": "contract c11074{ function allowance(address _from, address _spender, bytes32 _symbol) public view returns (uint) { return _allowance(getHolderId(_from), getHolderId(_spender), _symbol); } }",
        "url": 548
    },
    {
        "code_input": "class TokenTransferProposal:\n    def __init__(self, contract, account, engraved_address, deadline, cooldown):\n        self.contract = contract\n        self.account = account\n        self.engraved_address = engraved_address\n        self.deadline = deadline\n        self.cooldown = cooldown\n        self.stage = \"proposed\"\n\n    def propose(self):\n        if self.stage != \"proposed\" or self.deadline + self.cooldown < now:\n            self.stage = \"proposed\"\n            self.contract.set_stage(self.account, \"proposed\")\n            self.contract.propose_transfer(self.engraved_address)",
        "gt": "contract c35275{ function proposeTransfer(address _engravedAddress) onlyBeneficiary atStages(Stages.Withdrawn, Stages.Proposed) { require(stage != Stages.Proposed || now > transferProposal.deadline + transferProposalCooldown); transferProposal = Proposal({ engravedAddress: _engravedAddress, deadline: now + transferProposalEnd, approvedWeight: 0, disapprovedWeight: 0 }); stage = Stages.Proposed; } }",
        "url": 549
    },
    {
        "code_input": "The given Solidity code is a contract for a breeding auction. The contract has a function `bidOnBreedingAuction` that allows a mother (`_momId`) to bid on a child (`_dadId`) for a specific amount of Ether. The function is marked as `public`, `payable`, and `whenNotPaused`.\n\nThe function first checks if the caller is the owner of the mother. If not, the function returns without executing. Then it checks if the mother can breed. If not, the function returns without executing. Finally, it checks if the mother can mate via the marketplace. If not, the function returns without executing.\n\nThe function then calculates the fee for the breeding. If the amount of Ether sent by the caller is less than the fee, the function returns without executing.\n\nThe function then calls the `bid` function of the `breedingMarket` contract with the `_dadId` as the argument.\n\nThe function then calls the `_breedWith` function of the `breedingMarket` contract with the `_momId` and `_dadId`",
        "gt": "contract c16921{ function bidOnBreedingAuction( uint40 _dadId, uint40 _momId ) public payable whenNotPaused returns (uint256) { require(_isOwner(msg.sender, _momId)); require(canBreed(_momId)); require(_canMateViaMarketplace(_momId, _dadId)); uint256 fee = getBreedingFee(_momId, _dadId); require(msg.value >= fee); breedingMarket.bid.value(msg.value - fee)(_dadId); return _breedWith(_momId, _dadId); } }",
        "url": 550
    },
    {
        "code_input": "class TokenTransferContract:\n    def __init__(self, token_bearer):\n        self.token_bearer = token_bearer\n\n    def pass_token(self, _to):\n        if self.token_bearer == msg.sender:\n            # Here, you would typically call a function to pass the token to the recipient.\n            # For the sake of this example, we'll just print a message.\n            print(f\"Token passed to {_to}\")\n        else:\n            print(\"Only the token bearer can transfer tokens.\")\n\n    def transfer(self, _to):\n        if self.token",
        "gt": "contract c38159{ function transfer(address _to) { require(msg.sender == tokenBearer); passToken(_to); } }",
        "url": 551
    },
    {
        "code_input": "class TokenTransferContract:\n    def __init__(self, owner, token_id):\n        self.owner = owner\n        self.token_id = token_id\n\n    def clear_approval_and_transfer(self, to):\n        if to == self.owner:\n            raise ValueError(\"Cannot transfer tokens to the owner\")\n        if to == 0:\n            raise ValueError(\"Cannot transfer tokens to the zero address\")\n        self.remove_token(self.owner, self.token_id)\n        self.add_token(to, self.token_id)\n        self.clear_approval(self.owner, self.token_id)\n        self.transfer(self.owner, to, self.token_id)\n\n    def clear_approval(self, from_address",
        "gt": "contract c927{ function clearApprovalAndTransfer(address _from, address _to, uint256 _tokenId) internal { require(_to != address(0)); require(_to != ownerOf(_tokenId)); require(ownerOf(_tokenId) == _from); clearApproval(_from, _tokenId); removeToken(_from, _tokenId); addToken(_to, _tokenId); Transfer(_from, _to, _tokenId); } }",
        "url": 552
    },
    {
        "code_input": "class TokenContract:\n    def __init__(self, owner):\n        self.owner = owner\n        self.is_paused = False\n\n    def unpause_token(self):\n        if self.is_paused:\n            print(\"Token is already unpaused.\")\n        else:\n            self.is_paused = True\n            print(\"Token has been unpaused.\")\n\n    def pause_token(self):\n        if not self.is_paused:\n            print(\"Token is already paused.\")\n        else:\n            self.is_paused = False\n            print(\"Token has been paused.\")\n\n    def check_pause_status(self):\n        if self.is_paused:\n            print(\"Token is paused.\")\n        else:",
        "gt": "contract c20342{ function unpauseToken() public onlyOwner { token.unpause(); } }",
        "url": 553
    },
    {
        "code_input": "class Auction:\n    def __init__(self, start_time, bidding_time):\n        self.start_time = start_time\n        self.bidding_time = bidding_time\n        self.highest_bid = 0\n        self.highest_bidder = None\n        self.pending_returns = {}\n\n    def bid(self, sender, value):\n        if not self.is_bidding_time_over() or not",
        "gt": "contract c37097{ function bid() payable { require(now <= (auctionStart + biddingTime)); require(msg.value > highestBid); if (highestBidder != 0) { pendingReturns[highestBidder] += highestBid; } highestBidder = msg.sender; highestBid = msg.value; HighestBidIncreased(msg.sender, msg.value); } }",
        "url": 554
    },
    {
        "code_input": "class C32827:\n    def __init__(self, token_rate, max_tokens_amount, beneficiary_address):\n        self.token_rate = token_rate\n        self.max_tokens_amount = max_tokens_amount\n        self.beneficiary_address = beneficiary_address\n        self.issued_tokens_amount = 0\n\n    def buy(self, pay_amount):\n        tokens_amount = self.token_rate * pay_amount\n        if self.issued_tokens_amount + tokens_amount > self.max_tokens_amount:\n            tokens_amount = self.max",
        "gt": "contract c32827{ function buy() payable inProgress whenNotPaused { uint256 payAmount = msg.value; uint256 returnAmount = 0; uint256 tokensAmount = tokenRate.mul(payAmount); if (issuedTokensAmount + tokensAmount > maxTokensAmount) { tokensAmount = maxTokensAmount.sub(issuedTokensAmount); payAmount = tokensAmount.div(tokenRate); returnAmount = msg.value.sub(payAmount); } issuedTokensAmount = issuedTokensAmount.add(tokensAmount); require (issuedTokensAmount <= maxTokensAmount); storeTokens(msg.sender, tokensAmount); TokenBought(msg.sender, tokensAmount, payAmount); beneficiaryAddress.transfer(payAmount); if (returnAmount > 0) { msg.sender.transfer(returnAmount); } } }",
        "url": 555
    },
    {
        "code_input": "class C23316:\n    def __init__(self, web3, address):\n        self.web3 = web3\n        self.address = address\n        self.contract = web3.eth.contract(address=address, abi='...')  # Replace with the actual ABI\n\n    def withdraw(self, amount, to):\n        if to != '0x00000000000000000000000000000000000000",
        "gt": "contract c23316{ function withdraw(uint256 _amount, address _destination) public onlyOwner { require(_destination != address(0)); require(_amount <= this.balance); _destination.transfer(_amount == 0 ? this.balance : _amount); } }",
        "url": 556
    },
    {
        "code_input": "class C19807:\n    def __init__(self, contract, web3, owner, end_time):\n        self.contract = contract\n        self.web3 = web3\n        self.owner = owner\n        self.end_time = end_time\n        self.old_seele_token = web3.eth.contract(address='0x...')  # Replace with the address of the old seele token\n        self.seele_token = web3.eth.contract(address='0x...')  # Replace with the address of the seele token\n        self.open_sold_tokens = 0\n        self.full_white_list = {}\n        self.vist_flag_list = {}\n\n    def set_white_list",
        "gt": "contract c19807{ function setWhiteList(address[] users, bool openTag) external onlyOwner earlierThan(endTime) { require(saleNotEnd()); for (uint i = 0; i < users.length; i++) { address receipient = users[i]; bool visitFlag = vistFlagList[receipient]; if( openTag == true && visitFlag == false){ uint token = oldSeeleToken.lockedBalances(receipient); if( token > 0){ seeleToken.mint(receipient, token,true); openSoldTokens = openSoldTokens.add(token); } vistFlagList[receipient] = true; } fullWhiteList[receipient] = openTag; } } }",
        "url": 557
    },
    {
        "code_input": "class GameContract:\n    def __init__(self):\n        self.games = {}  # This is a placeholder for the actual game data.\n\n    def activeGame(self, _hGame):\n        _valid = False\n        if (_hGame > 0) and (self.games.get(_hGame) is not None) and self.games[_hGame]['active']:\n            _valid = True\n        return _valid",
        "gt": "contract c38954{ function activeGame(uint _hGame) internal returns( bool _valid) { _valid = false; if ((_hGame > 0) && (games[_hGame].active)) _valid = true; } }",
        "url": 558
    },
    {
        "code_input": "The given Solidity code is a contract for a game where players can place blocks on a grid. The main functionality of the contract is to place blocks on the grid and then distribute the bets accordingly.\n\nHere's a high-level description of the main functionality:\n\n1. The `placeBlock` function is called when a player wants to place a block.\n2. It first checks if there is already a block at the given coordinates. If there is, it returns an error.\n3. It then adds the amount of the bet to the sender's balance.\n4. It calculates the bet amount at the given layer.\n5. It checks if there are blocks at the coordinates of the previous and next rows.\n6. It then deducts the bet amount from the sender's balance.\n7. It assigns the sender to the block at the given coordinates.\n8. It pushes the coordinates to the `allBlockCoordinates` array.\n9. If the layer is at the top, it also adds the bet amount to the administrator's balance.\n10. If the layer is not at the top, it calculates the admin fee and deducts it from the",
        "gt": "contract c36026{ function placeBlock(uint16 x, uint16 y) external payable { require(!isThereABlockAtCoordinates(x, y)); addressBalances[msg.sender] += msg.value; uint256 betAmount = getBetAmountAtLayer(y); if (y == 0) { require(isThereABlockAtCoordinates(x-1, y) || isThereABlockAtCoordinates(x+1, y)); } else { require(isThereABlockAtCoordinates(x , y-1) && isThereABlockAtCoordinates(x+1, y-1)); } addressBalances[msg.sender] -= betAmount; coordinatesToAddresses[(uint32(x) << 16) | y] = msg.sender; allBlockCoordinates.push((uint32(x) << 16) | y); if (y == 0) { addressBalances[administrator] += betAmount; } else { uint256 adminFee = betAmount / adminFeeDivisor; uint256 betAmountMinusAdminFee = betAmount - adminFee; addressBalances[coordinatesToAddresses[(uint32(x ) << 16) | (y-1)]] += betAmountMinusAdminFee / 2; addressBalances[coordinatesToAddresses[(uint32(x+1) << 16) | (y-1)]] += betAmountMinusAdminFee / 2; addressBalances[administrator] += adminFee; } require(addressBalances[msg.sender] < (1 << 255)); addressesToChatMessagesLeft[msg.sender] += uint32(1) << y; addressesToTotalWeiPlaced[msg.sender] += betAmount; } }",
        "url": 559
    },
    {
        "code_input": "class Token:\n    def __init__(self, supply):\n        self.supply = supply\n\n    def total_supply(self):\n        return self.supply\n\n# Create an instance of the Token contract\ntoken = Token(1000)\n\n# Get the total supply of tokens\nprint(token.total_supply())",
        "gt": "contract c39827{ function totalSupply() constant returns (uint supply) { return numTokens; } }",
        "url": 560
    },
    {
        "code_input": "def getMetForEthResult(c11539_instance,",
        "gt": "contract c11539{ function getMetForEthResult(uint _depositAmount) public view returns (uint256) { return convertingReturn(WhichToken.Eth, _depositAmount); } }",
        "url": 561
    },
    {
        "code_input": "class C31926:\n    def __init__(self, web3, address):\n        self.web3 = web3\n        self.address = address\n        self.supportersMap = web3.eth.contract(address='0x...')  # replace with the actual address\n        self.kyc = web3.eth.contract(address='0x...')  # replace with the actual address\n        self.kycManager = '0x...'  # replace with the actual address\n\n    def disapproveUserKYC(self, user):\n        supporter = self.supportersMap[user]\n        if supporter['hasKYC']:\n            self.kyc.functions.KYC(user,",
        "gt": "contract c31926{ function disapproveUserKYC(address _user) onlyKycManager public { Supporter storage sup = supportersMap[_user]; sup.hasKYC = false; KYC(_user, false); } }",
        "url": 562
    },
    {
        "code_input": "class Contract:\n    def __init__(self, paused=False, only_manager=False, when_paused=False):\n        self.paused = paused\n        self.only_manager = only_manager\n        self.when_paused = when_paused\n\n    def unpause(self):\n        if self.only_manager:\n            if self.when_paused:\n                self.paused =",
        "gt": "contract c797{ function unpause() public onlyManager whenPaused { paused = false; } }",
        "url": 563
    },
    {
        "code_input": "class TokenSale:\n    def __init__(self, sell_price):\n        self.sell_price",
        "gt": "contract c23997{ function sell(uint256 amount) public { require(this.balance >= amount * sellPrice); _transfer(msg.sender, this, amount); msg.sender.transfer(amount * sellPrice); } }",
        "url": 564
    },
    {
        "code_input": "class C28193:\n    def __init__(self, max_gas_price):\n        self.max_gas_price = max_gas_price\n\n    def update_max_gas_price(self, new_max_gas_price):\n        if new_max_gas_price <= 0:\n            raise ValueError(\"Max gas price must be greater than 0\")\n        self.max_gas_price = new_max_gas_price",
        "gt": "contract c28193{ function updateMaxGasPrice(uint256 _maxGasPrice) public onlyOwner { require(_maxGasPrice > 0); maxGasPrice = _maxGasPrice; } }",
        "url": 565
    },
    {
        "code_input": "The given Solidity code is a function that allows a user to purchase artworks. The function takes in three parameters:\n\n1. `artworkTypes`: An array of uint8 values representing the type of artwork the user wants to purchase.\n2. `receiver`: The address of the user who is purchasing the artwork.\n3. `_value`: The value of the artwork the user is trying to purchase.\n\nThe function first calculates the total cost of the artwork the user is trying to purchase. It does this by iterating over the `artworkTypes` array and adding the cost of each type of artwork to a total.\n\nThe function then checks if the user has enough ether to cover the total cost of the artwork they are trying to purchase. If the user does not have enough ether, the function reverts the transaction.\n\nIf the user has enough ether, the function proceeds to purchase the artwork. It does this by creating a new artwork with the type of artwork, the sequence number of the artwork, the value of the artwork, and the address of the user who is purchasing the artwork.\n\nThe function then increments the sequence number of the artwork in the user's artwork list",
        "gt": "contract c2859{ function giveArtworks(uint8[] artworkTypes, address receiver, uint256 _value) internal { uint32 len = uint32(artworkTypes.length); require(numArtworks + len < maxArtworks); uint256 amount = 0; for (uint16 i = 0; i < len; i++) { require(artworkTypes[i] < costs.length); amount += costs[artworkTypes[i]]; } require(_value >= amount); uint8 artworkType; uint32[] memory seqnolist = new uint32[](len); for (uint16 j = 0; j < len; j++) { if (numArtworks < ids.length) ids[numArtworks] = lastId; else ids.push(lastId); artworkType = artworkTypes[j]; userArtworkSequenceNumber[receiver][artworkType]++; seqnolist[j] = userArtworkSequenceNumber[receiver][artworkType]; artworks[lastId] = Artwork(artworkTypes[j], userArtworkSequenceNumber[receiver][artworkType], values[artworkType], receiver); numArtworks++; lastId++; numArtworksXType[artworkType]++; } emit newPurchase(receiver, lastId - len, artworkTypes, seqnolist); } }",
        "url": 566
    },
    {
        "code_input": "class ICO:\n    def __init__(self, owner, ico_duration, free_period_duration):\n        self.owner = owner\n        self.ico_duration = ico_duration\n        self.free_period_duration = free_period_duration\n        self.ico_end_time = None\n        self.free_period_end_time = None\n        self.current_state = 'Created'\n\n    def start_ico(self):\n        if self.current_state != 'Created':\n            raise Exception('The contract is not in the Created state.')\n        if self.owner != self.ico_end",
        "gt": "contract c34893{ function startIco() onlyInState(State.Created) onlyTrivial() { icoEndTime = SafeMath.add(now, icoDuration); freePeriodEndTime = SafeMath.add(icoEndTime, freePeriodDuration); currentState = State.IcoStarted; IcoStarted(icoEndTime); } }",
        "url": 567
    },
    {
        "code_input": "class VotingContract:\n    def __init__(self, num_ballots, ballot_details, ballot_voters, ballot_vote_count):\n        self.num_ballots = num_ballots\n        self.ballot_details = ballot_details\n        self.ballot_voters = ballot_voters\n        self.ballot_vote_count = ballot_vote_count\n\n    def is_ballot_in_progress(self, ballot_id):\n        # Check if the ballot is in progress\n        pass\n\n    def is_ballot_open(self, ballot_id):\n        # Check if the ballot is open\n        pass\n\n    def is_ballot_vote_count_valid(self, ballot_id, selected_option_id):\n        #",
        "gt": "contract c36942{ function vote(uint32 _ballotId, uint32 _selectedOptionId) { require(_ballotId > 0 && _ballotId <= numBallots); require(isBallotInProgress(_ballotId)); uint256 votableBalance = balanceOf(msg.sender) - ballotVoters[_ballotId][msg.sender]; require(votableBalance > 0); require(_selectedOptionId > 0 && _selectedOptionId <= ballotDetails[_ballotId].numOptions); ballotVoteCount[_ballotId][_selectedOptionId] += votableBalance; ballotVoters[_ballotId][msg.sender] += votableBalance; } }",
        "url": 568
    },
    {
        "code_input": "class Contract:\n    def __init__(self):\n        self.pendingOwner = None\n\n    def set_pending_owner(self, new_owner):\n        self.pendingOwner = new_owner\n\n    def get_pending_owner(self):\n        return self.pendingOwner\n\n    def is_owner(self, account):\n        return account == self.pendingOwner\n\n    def only_pending_owner(self, function):\n        def wrapper(self, *args, **kwargs):\n            if not self.is_owner(accounts[0]):\n                revert(\"Only the pending owner can call this function.\")\n            return function(self, *args, **kwargs)\n        return wrapper\n\n    def only_pending_owner(self, *args, **kwargs):\n        return self.only_pending_owner(args[0",
        "gt": "contract c145{ modifier onlyPendingOwner() { require(msg.sender == pendingOwner); _; } }",
        "url": 569
    },
    {
        "code_input": "class C20598:\n    def __init__(self, certificate_authority):\n        self.certificate_authority = certificate_authority\n\n    def isCA(self, ca_address):\n        return len(self.certificate_authority[ca_address].lookup_api) != 0",
        "gt": "contract c20598{ function isCA(address ca_address) public view returns (bool) { return bytes(certificate_authority[ca_address].lookup_api).length != 0; } }",
        "url": 570
    },
    {
        "code_input": "The given Solidity code is a contract for a question-and-answer game. The contract has a function `claimWinnings` that is used to claim the winnings of a question. The function takes in several parameters:\n\n- `question_id`: A unique identifier for the question.\n- `history_hashes`: An array of hashes that represent the history of the question.\n- `addrs`: An array of addresses that are participating in the question.\n- `bonds`: An array of bond amounts that are associated with each address.\n- `answers`: An array of answers that are associated with each question.\n\nThe function first checks if the `history_hashes` array is empty. If it is, it returns without doing anything. If it's not, it finds the `payee` of the question, `last_bond`, and `queued_funds`. It then iterates over the `history_hashes` array, verifying each one and processing it. If a commitment is found, it adds the bond to the `queued_funds`. If not, it processes the history item and updates",
        "gt": "contract c18780{ function claimWinnings( bytes32 question_id, bytes32[] history_hashes, address[] addrs, uint256[] bonds, bytes32[] answers ) stateFinalized(question_id) public { require(history_hashes.length > 0); address payee = question_claims[question_id].payee; uint256 last_bond = question_claims[question_id].last_bond; uint256 queued_funds = question_claims[question_id].queued_funds; bytes32 last_history_hash = questions[question_id].history_hash; bytes32 best_answer = questions[question_id].best_answer; uint256 i; for (i = 0; i < history_hashes.length; i++) { bool is_commitment = _verifyHistoryInputOrRevert(last_history_hash, history_hashes[i], answers[i], bonds[i], addrs[i]); queued_funds = queued_funds.add(last_bond); (queued_funds, payee) = _processHistoryItem( question_id, best_answer, queued_funds, payee, addrs[i], bonds[i], answers[i], is_commitment); last_bond = bonds[i]; last_history_hash = history_hashes[i]; } if (last_history_hash != NULL_HASH) { if (payee != NULL_ADDRESS) { _payPayee(question_id, payee, queued_funds); queued_funds = 0; } question_claims[question_id].payee = payee; question_claims[question_id].last_bond = last_bond; question_claims[question_id].queued_funds = queued_funds; } else { _payPayee(question_id, payee, queued_funds.add(last_bond)); delete question_claims[question_id]; } questions[question_id].history_hash = last_history_hash; } }",
        "url": 571
    },
    {
        "code_input": "class TokenExchangeRate:\n    def __init__(self):\n        self.tokensPerEthPrice = 0\n\n    def setRate(self, _tokensPerEthPrice):\n        # Check if the caller is the contract owner\n        if self.msg.sender != self.owner:\n            raise ValueError(\"Only the contract owner can set the rate\")\n\n        # Set the new rate\n        self.tokensPerEthPrice = _tokensPerEthPrice\n\n# Example usage:\nexchange_rate = TokenExchangeRate()\nexchange_rate.setRate(1000)  # Set the rate to 1000 tokens per Ether",
        "gt": "contract c18771{ function setRate(uint256 _tokensPerEthPrice) public onlyOwner { tokensPerEthPrice = _tokensPerEthPrice; } }",
        "url": 572
    },
    {
        "code_input": "class CrowdfundingContract:\n    def __init__(self, soft_funding_goal):\n        self.state = \"IcoFinished\"\n        self.amount_raised = 0\n        self.soft_funding_goal = soft_funding_goal\n\n    def raise_funding(self, amount):\n        if self.state == \"IcoFinished\" and self.amount_raised + amount <= self.soft_funding_goal:\n            self.amount_raised += amount\n        else:\n            raise ValueError(\"Goal not reached or funding limit exceeded\")\n\n    @staticmethod",
        "gt": "contract c21877{ modifier goalNotReached() { require(state == State.IcoFinished && amountRaised < softFundingGoal); _; } }",
        "url": 573
    },
    {
        "code_input": "class TokenContract:\n    def __init__(self, owner, reward_divisor):\n        self.owner = owner\n        self.reward_divisor = reward_divisor\n\n    def set_reward_divisor(self, new_reward_divisor):\n        if self.owner == self.reward_divisor:\n            self.reward_divisor = new_reward_divisor\n        else:\n            raise Exception(\"Only the contract owner can set the reward divisor.\")",
        "gt": "contract c112{ function setRewardDivisor(uint _rewardDivisor) external onlyOwner { rewardDivisor = _rewardDivisor; } }",
        "url": 574
    },
    {
        "code_input": "class SeriesContract:\n    def __init__(self, ens, series):\n        self._ens = ens\n        self._series = series\n\n    def create_series(self, nodehash, series_name, root_hash, initial_count):\n        if msg.sender != self._ens.owner(nodehash):\n            return False\n        if root_hash == 0x00:\n            return False\n        series = self._series.get(nodehash, None)\n        if series is not None and series.rootHash != 0x00:\n            return False\n        series = {'",
        "gt": "contract c35503{ function createSeries(bytes32 nodehash, string seriesName, bytes32 rootHash, uint256 initialCount) returns (bool success) { if (msg.sender != _ens.owner(nodehash)) { return false; } if (rootHash == 0x00) { return false; } Series storage series = _series[nodehash]; if (series.rootHash != 0x00) { return false; } series.name = seriesName; series.rootHash = rootHash; series.initialCount = initialCount; series.currentCount = initialCount; seriesCreated(nodehash); } }",
        "url": 575
    },
    {
        "code_input": "class CoinTrackingSystem:\n    def __init__(self):\n        self.owned_coins = {}\n\n    def add_coin(self, owner, coin):\n        if owner in self.owned_coins:\n            self.owned_coins[owner].append(coin)\n        else:\n            self.owned_coins[owner] = [coin]\n\n    def count_by_owner(self, owner):\n        if owner in self.owned_coins:\n            return len(self.owned_coins[owner])\n        else:\n            return 0",
        "gt": "contract c35116{ function countByOwner(address _owner) constant returns (uint) { return ownedCoins[_owner].length; } }",
        "url": 576
    },
    {
        "code_input": "class TokenDistribution:\n    def __init__(self, contract_owner, crowd_supply, company_supply, bank_multisig, minter, stage):\n        self.contract_owner = contract_owner\n        self.crowd_supply = crowd_supply\n        self.company_supply = company_supply\n        self.bank_multisig = bank_multisig\n        self.minter = minter\n        self.stage = stage\n\n    def end(self):\n        if self.stage == 'GenesisStart':\n            self.contract_owner.transfer(self.crowd_supply)\n            self.contract_owner.",
        "gt": "contract c16361{ function end() external onlyOwner atStage(Stages.GenesisStart) { token.transfer(tokenDistribution, crowdSupply); token.transfer(bankMultisig, companySupply); token.transferOwnership(minter); stage = Stages.GenesisEnd; } }",
        "url": 577
    },
    {
        "code_input": "The given Solidity code is a contract for a decentralized oracle. It allows users to buy oracles by paying a fee. The main functionality of the contract is as follows:\n\n1. `buyOracle`: This function allows a user to buy an oracle. The function takes two parameters: `_ipfsHash`, which is the IPFS hash of the proposal, and `taker`, which is the address of the user who is taking the proposal.\n\n2. `balanceChecked[msg.sender]`: This line checks if the user's balance is checked. If it's not, it calls the `checkBalance` function.\n\n3. `balances[msg.sender] = balances[msg.sender].sub(fee)`: This line subtracts the fee from the user's balance.\n\n4. `index = oracleIndexes[msg.sender][taker]`: This line gets the index of the proposal for the user.\n\n5. `oracleProposed[msg.sender][taker][index] = proposal(_ipfsHash, oracleMasterCopy, fee)`: This line",
        "gt": "contract c2005{ function buyOracle(bytes _ipfsHash, address taker) public whenOpen returns (uint index){ if(!balanceChecked[msg.sender]) checkBalance(msg.sender); balances[msg.sender] = balances[msg.sender].sub(fee); index = oracleIndexes[msg.sender][taker]; oracleProposed[msg.sender][taker][index] = proposal(_ipfsHash, oracleMasterCopy, fee); emit OracleProposed(msg.sender, taker, index, _ipfsHash); } }",
        "url": 578
    },
    {
        "code_input": "from solc import compile_source\nfrom web3 import Web3, HTTPProvider\n\n# The address of the contract\ncontract_address = '0x...'\n\n# The ABI of the contract\ncontract_abi = '...'\n\n# The private key of the account that will be the new owner\nnew_owner_private_key = '...'\n\n#",
        "gt": "contract c15553{ function changeOwner(address _newOwner) external onlyOwner() { owner = _newOwner; emit ChangedOwner(owner); } }",
        "url": 579
    },
    {
        "code_input": "from solc import compile_source\nfrom web3 import Web3, HTTPProvider\n\n# The address of the deployed contract\ncontract_address = '0x...'\n\n# The ABI of the",
        "gt": "contract c5942{ function depositTokens(bytes32 manufacturerId, uint256 amount) public returns (bool) { require(manufacturerId != 0, \"manufacturerId is required\"); require(amount > 0, \"amount is required\"); address manufacturer = manufacturerRewards[manufacturerId]; require(manufacturer != address(0)); _depositTokens(manufacturer, amount); emit TokensDeposited(msg.sender, manufacturerId, manufacturer, amount); require(token.transferFrom(msg.sender, address(this), amount)); return true; } }",
        "url": 580
    },
    {
        "code_input": "class Contract:\n    def __init__(self, balances):\n        self.balances = balances\n\n    def get_balance(self, sender):\n        return self.balances[sender]\n\n# Initialize the balances array\nbalances = {\n    '0x1': 1000,\n    '0x2': 2000,\n    '0x3': 3000,\n}\n\n# Create a Contract instance\ncontract = Contract(balances)\n\n# Get the balance of the sender\nsender = '0x1'\nprint(contract.get_",
        "gt": "contract c10236{ function getBalance() external view returns(uint) { return balances[msg.sender]; } }",
        "url": 581
    },
    {
        "code_input": "class TokenContract:\n    def __init__(self, contract_owner, wallets):\n        self.contract_owner = contract_owner\n        self.wallets = wallets\n\n    def give_freeze_permission(self, owners, permission):\n        if self.contract_owner != self.wallets[owners[0]].address:\n            raise ValueError(\"Only the contract owner can give freeze permission.\")\n\n        for owner in owners:\n            if owner not in self.wallets:\n                raise ValueError(f\"Owner {owner} does not exist.\")\n\n            self.wallets[owner].can_freeze_tokens = permission\n\n        return True",
        "gt": "contract c524{ function giveFreezePermission(address[] _owners, bool _permission) public onlyOwner returns(bool) { for (uint i = 0; i < _owners.length; i++) { wallets[_owners[i]].canFreezeTokens = _permission; emit ChangeFreezePermission(_owners[i], _permission); } return true; } }",
        "url": 582
    },
    {
        "code_input": "class TokenReceiver:\n    def __init__(self, _to):\n        self._to = _to\n\n    def tokenFallback(self, _from, _value):\n        # This is the fallback function. It is called when the contract receives Ether.\n        # The _from parameter is the address of the sender, and _value is the amount of Ether sent with the transaction.\n        pass\n\nclass Contract:\n    def __init__(self):\n        self.balance = {}",
        "gt": "contract c15541{ function _transferToContract(address _from, address _to, uint _value) private returns (bool success) { _transferFrom(msg.sender, _to, _value); TokenReceiver receiver = TokenReceiver(_to); receiver.tokenFallback(msg.sender, this, _value); return true; } }",
        "url": 583
    },
    {
        "code_input": "class TokenDistributor:\n    def __init__(self, contract, recipient, end_time, token, total_tokens, total_cents_collected, token_decimals_multiplier, min_price_in_cents):\n        self.contract = contract\n        self.recipient = recipient\n        self.end_time = end_time\n        self.token = token\n        self.total_tokens = total_tokens\n        self.total_cents_collected = total_cents_collected\n        self.token_decimals_multiplier = token",
        "gt": "contract c25961{ function withdrawExtraTokens(address _recipient) public onlyOwner { require(now > endTime && !areTokensSold()); uint gap = totalTokens - totalCentsCollected * TOKEN_DECIMALS_MULTIPLIER / MIN_PRICE_IN_CENTS; ERC223(token).transfer(_recipient, gap); } }",
        "url": 584
    },
    {
        "code_input": "def get_fee_to_token_conversion(contributed):\n    calculation_block = window_final_block[current_window()-1]\n    previous_supply = token_contract.total_supply_at(calculation_block)\n    initial_supply = token_contract.total_supply_at(window_final_block[0])\n    fee_total = token_contract.total_pledged_fees_at(calculation_block)\n    new_tokens = (contributed * previous_supply) / (1000 * (initial_supply + fee_total))\n    return new_tokens",
        "gt": "contract c26195{ function getFeeToTokenConversion(uint256 _contributed) public constant returns (uint256) { uint calculationBlock = windowFinalBlock[currentWindow()-1]; uint256 previousSupply = tokenContract.totalSupplyAt(calculationBlock); uint256 initialSupply = tokenContract.totalSupplyAt(windowFinalBlock[0]); uint256 feeTotal = tokenContract.totalPledgedFeesAt(calculationBlock); uint256 newTokens = (_contributed.mul(previousSupply.div(1000)).div((initialSupply.div(1000)).add(feeTotal))).mul(1000); return newTokens; } }",
        "url": 585
    },
    {
        "code_input": "class BorrowerApproval:\n    def __init__(self, owner):\n        self.owner = owner\n        self.approved = {}\n\n    def add_borrower(self, borrower):\n        self.approved[borrower] = True\n\n# Usage\n# Create an instance of the BorrowerApproval class\nborrower_approval = BorrowerApproval('0x0000000000000000000000000000000000000000')\n\n# Add a borrower\nborrower_address = '0x1234567890123456789012345678901234567890'\nborrower",
        "gt": "contract c4868{ function addBorrower(address borrower) external onlyOwner { approved[borrower] = true; } }",
        "url": 586
    },
    {
        "code_input": "class Product:\n    def __init__(self, deadlines, prices):\n        self.deadlines = deadlines\n        self.prices = prices\n\n    def get_price(self):\n        for i, deadline in enumerate(self.deadlines):\n            if deadline > now:\n                return self.prices[i]\n        return self.prices[-1]",
        "gt": "contract c39367{ function getPrice() constant returns (uint256 price){ for(var i = 0; i < deadlines.length; i++) if(now<deadlines[i]) return prices[i]; return prices[prices.length-1]; } }",
        "url": 587
    },
    {
        "code_input": "class Contract:\n    def __init__(self, games):\n        self.games = games\n\n    def get_total_games(self):\n        return len(self.games)\n\n# Example usage:\ngames = [1, 2, 3, 4, 5]\ncontract = Contract(games)\nprint(contract.get_total_games())  # Output: 5",
        "gt": "contract c5671{ function getTotalGames() public view returns (uint) { return games.length; } }",
        "url": 588
    },
    {
        "code_input": "class Crowdsale:\n    def __init__(self):\n        self.is_crowdsale = True\n\n    def is_crowdsale(self):\n        return self.is_crowdsale",
        "gt": "contract c292{ function isCrowdsale() public constant returns (bool) { return true; } }",
        "url": 589
    },
    {
        "code_input": "class C26920:\n    def __init__(self):\n        self.paused = False\n\n    def get_paused(self):\n        return self.paused",
        "gt": "contract c26920{ function getPaused() public constant returns (bool) { return paused; } }",
        "url": 590
    },
    {
        "code_input": "class RecordSystem:\n    def __init__(self):\n        self.records = {}\n\n    def is_registered(self, key):\n        return self.records.get(key, {}).get('time', 0) != 0\n\n# Usage\nrecord_system = RecordSystem()\nprint(record_system.is_registered('key'))  # False",
        "gt": "contract c35571{ function isRegistered(address key) constant returns(bool) { return records[key].time != 0; } }",
        "url": 591
    },
    {
        "code_input": "class ERC20Token:\n    def __init__(self, address):\n        self.address = address\n\n    def balanceOf(self, account):\n        # This is a placeholder for the actual function.\n        # It should be replaced with the actual function of the ERC20 token.\n        return 0\n\nclass Ethereum:\n    def __init__(self, address):\n        self.address = address\n\n    def balance(self):\n        # This is a placeholder for the actual function.\n        # It should be replaced with the actual function of the",
        "gt": "contract c12455{ function getBalance(ERC20 token) public view returns(uint) { if (token == ETH_TOKEN_ADDRESS) return this.balance; else return token.balanceOf(this); } }",
        "url": 592
    },
    {
        "code_input": "class TokenContract:\n    def __init__(self):\n        self.balance_of = self.get_balance_of\n\n    def get_balance_of(self, holder_address):\n        # This is a placeholder for the actual function that fetches the balance of a holder\n        # In a real contract, this function would interact with a blockchain to fetch the balance\n        # For this example, we'll just return a placeholder value\n        return 1000000e18\n\n    def check_balance_tier(self, holder_address):\n        holder_balance = self.get_balance_of(holder_address)\n        if holder_balance >= 1000000e18:\n            return \"Platinum tier\"\n        elif holder_balance >= 700000e",
        "gt": "contract c14558{ function checkBalanceTier(address holderAddress) public view returns(string) { uint256 holderBalance = balanceOf(holderAddress); if (holderBalance >= 1000000e18) { return \"Platinum tier\"; } else if (holderBalance >= 700000e18) { return \"Gold tier\"; } else if (holderBalance >= 300000e18) { return \"Titanium tier\"; } else if (holderBalance == 0) { return \"Possess no REB\"; } return \"Free tier\"; } }",
        "url": 593
    },
    {
        "code_input": "The given Solidity code is a contract for a promo team creation system. Here's a high-level description of the main functionality and logic:\n\n1. The contract is named `c25013`.\n\n2. The function `createPromoTeam` is declared. It is a public function that can only be called by the contract's owner (`onlyCOO`).\n\n3. The function first checks if the `promoCreatedCount` is less than the limit of `PROMO_CREATION_LIMIT`. If it is, it increments `promoCreatedCount`.\n\n4. If the `teamOwner` is `address(0)`, it assigns the `cooAddress` to `teamOwner`.\n\n5. If the `_price` is less than or equal to `0`, it assigns the `startingPrice` to `_price`.\n\n6. It then calls the `_createTeam` function, which is a non-existent function. The `_createTeam` function is expected to create a new team and assign it to the `teamOwner`.\n\nHere's a",
        "gt": "contract c25013{ function createPromoTeam(address _owner, string _name, uint256 _price) public onlyCOO { require(promoCreatedCount < PROMO_CREATION_LIMIT); address teamOwner = _owner; if (teamOwner == address(0)) { teamOwner = cooAddress; } if (_price <= 0) { _price = startingPrice; } promoCreatedCount++; _createTeam(_name, teamOwner, _price); } }",
        "url": 594
    },
    {
        "code_input": "class TokenContract:\n    def __init__(self, creator, escrow, token_address, dev_address):\n        self.creator = creator\n        self.escrow = escrow\n        self.token = Token(token_address)\n        self.dev = dev_address\n\n    def is_complete(self):\n        # This is a placeholder for the actual function.\n        # It should return True if the task is complete, False otherwise.\n        return True\n\n    def is_successful(self):\n        # This is a placeholder for the actual function.\n        # It should return True if the task is successful, False otherwise.\n        return True",
        "gt": "contract c38774{ function payCreator() { require(isComplete()); require(!creatorPaid); creatorPaid = true; if(isSuccessful()){ uint tokensToBurn = tokenBalance() - checkTokTotal(); PayEther(escrow,this.balance,now); escrow.transfer(this.balance); PayTokens(creator,checkTokDev(),now); Token.transfer(creator,checkTokDev()); Token.burn(tokensToBurn); BurnTokens(tokensToBurn,now); }else{ PayTokens(creator,tokenBalance(),now); Token.transfer(creator,tokenBalance()); } } }",
        "url": 595
    },
    {
        "code_input": "class TokenExchangeRateProvider:\n    def __init__(self):\n        pass\n\n    def get_rate(self, sender, sold_tokens, value):\n        # This is a placeholder for the actual implementation.\n        # It should return the exchange rate for the given sender, sold tokens, and value.\n        # For the purpose of this example, we'll just return a fixed rate.\n        return 1.0\n\n\nclass TokenExchange:\n    def __init__(self, rate_provider):\n        self.rate_provider = rate_provider\n\n    def get_exchange_rate(self, value):\n        # Get the rate from the rate provider.\n        rate = self.rate_provider.get_rate(value)\n\n        # Return the rate.\n        return rate",
        "gt": "contract c34930{ function getRate(uint _value) internal constant returns (uint) { return rateProvider.getRate(msg.sender, soldTokens, _value); } }",
        "url": 596
    },
    {
        "code_input": "class ProjectContract:\n    def __init__(self, owner, project_wallet):\n        self.owner = owner\n        self.project_wallet = project_wallet\n\n    def moveFunds(self):\n        if not self.project_wallet.send(self.owner, self.owner.balance):\n            raise Exception('Failed to transfer funds')",
        "gt": "contract c39652{ function moveFunds() onlyOwner { if (!project_wallet.send(this.balance)) throw; } }",
        "url": 597
    },
    {
        "code_input": "class C40240:\n    def __init__(self, web3, address):\n        self.web3 = web3\n        self.address = address\n        self.contract = self.web3.eth.contract(address=address, abi='...')  # Replace with the actual ABI\n\n    def withdraw(self, proposalId):\n        balance = self.contract.functions.balanceOf(self.address).call()\n        if not self.contract.functions.transferFrom(self.address, self.address, balance).transact():\n            raise Exception('Transfer failed')\n        if not self.web3.eth.sendTransaction({'from': self.address, 'to': self.address, 'value': balance}):\n            raise Exception('Send failed')",
        "gt": "contract c40240{ function withdraw(uint proposalId) external { uint balance = whiteList[proposalId].balanceOf(msg.sender); if (!whiteList[proposalId].transferFrom(msg.sender, this, balance) || !msg.sender.send(balance)) throw; } }",
        "url": 598
    },
    {
        "code_input": "from datetime import datetime, timedelta\n\nSTART = datetime.now()\n\ndef get_rate():\n    now = datetime.now()\n    if now < START:\n        return 1190476190476200\n    elif now - START < timedelta(days=6):\n        return 1234567900000000\n    elif now - START < timedelta(days=13):\n        return 1282051300000000\n    elif now - START < timedelta(days=20):\n        return 1333333300000000\n    elif now - START < timedelta(days=28):\n        return 1388888900000000",
        "gt": "contract c28099{ function getRate() constant returns (uint256 rate) { if (now < START) return rate = 1190476190476200; else if (now <= START + 6 days) return rate = 1234567900000000 ; else if (now <= START + 13 days) return rate = 1282051300000000 ; else if (now <= START + 20 days) return rate = 1333333300000000 ; else if (now <= START + 28 days) return rate = 1388888900000000 ; return rate = 1666666700000000; } }",
        "url": 599
    },
    {
        "code_input": "class Contract:\n    def __init__(self):\n        self.state = 'Not Started'\n\n    def enable_refunds(self):\n        if self.state != 'Not Started':\n            print(\"Refunds are already enabled or not started.\")\n        else:\n            self.state = 'Refunding'\n            print(\"Refunds are now being processed.\")\n\n# Test the contract\ncontract = Contract()\ncontract.enable_refunds()",
        "gt": "contract c28805{ function enable_refunds() public onlyOwner { state = State.Refunding; } }",
        "url": 600
    },
    {
        "code_input": "from web3 import Web3",
        "gt": "contract c35045{ function processPurchase(uint price) private { uint numTokens = safeDiv(safeMul(msg.value, price), 1 ether); assert(numTokens <= remaining() && remaining() > 0); totalCollected = safeAdd(totalCollected, msg.value); tokensIssued = safeAdd(tokensIssued, numTokens); EtherReceiverInterface(vaultAddress).receiveEther.value(msg.value)(); if (!MintInterface(tokenContract).mint(msg.sender, numTokens)) revert(); } }",
        "url": 601
    },
    {
        "code_input": "def set_historical_balance(owner, from_balance, to_balance, level):\n    assert from_balance > 0\n    assert to_balance >= from_balance\n    assert from_balance > 0\n\n    historical_balances = [0] * level\n\n    while from_balance < to_balance:\n        if from_balance & 1",
        "gt": "contract c31820{ function setHistoricalBalance ( address _owner, uint256 _from, uint256 _to, uint256 _balance) internal { assert (_from > 0); assert (_to >= _from); assert (_balance > 0); uint8 level = 0; while (_from < _to) { if (_from & 1 == 1) { historicalBalances [_owner][level][_from++] = _balance; } if (_to & 1 == 1) { historicalBalances [_owner][level][--_to] = _balance; } _from >>= 1; _to >>= 1; level += 1; } } }",
        "url": 602
    },
    {
        "code_input": "def check_required_change(new_required, length):\n    if new_required == 0:\n        log_error_msg(new_required, \"Cant reduce to 0\")\n        return False\n    if length - 2 < new_required:\n        log_error_msg(length, \"Making requirement too high\")\n        return False\n    return True",
        "gt": "contract c31912{ function checkRequiredChange(uint256 _newRequired, uint256 _length) private returns (bool) { if(_newRequired == 0){ LogErrorMsg(_newRequired, \"Cant reduce to 0\"); return false; } if(_length - 2 < _newRequired){ LogErrorMsg(_length, \"Making requirement too high\"); return false; } return true; } }",
        "url": 603
    },
    {
        "code_input": "The given Solidity contract is a function that retrieves the balance of a token in a vesting schedule. The function is named `getVestingBalance` and it takes three addresses as parameters: `_token`, `_granter`, and `_vester`.\n\nThe function is marked as `external`, which means it can be called by other contracts. The function is also marked as `constant`, which means it cannot modify the state of the contract.\n\nThe function returns a `uint256`, which is the balance of the token in the vesting schedule.\n\nThe function uses a `Grant` memory variable to store the grant information for the token, granter, and vester. The grant information is stored in a map, where the keys are the token addresses, the granter addresses, and the vester addresses, and the values are the `Grant` objects.\n\nThe function then calls the `getBalanceVestingInternal` function, which is a private function in the contract. The `getBalanceVestingInternal` function is used to calculate the balance of the token in the vesting schedule.\n\nHere is a simple example of",
        "gt": "contract c17000{ function getVestingBalance(address _token, address _granter, address _vester) external constant returns(uint256) { Grant memory _grant = grantPerTokenGranterVester[_token][_granter][_vester]; return getBalanceVestingInternal(_grant); } }",
        "url": 604
    },
    {
        "code_input": "The given Solidity contract is a simple Ethereum smart contract that allows transferring Ether from one account to another. Here's a high-level description of the main functionality and logic:\n\n1. `transfer(address _to, uint256 _value)`: This function is used to transfer Ether from the caller's account to a different account.\n\n2. `require(!hault)`: This line checks if the `hault` variable is not set to true. If `hault` is set to true, the function will return false and stop execution.\n\n3. `require(balances[msg.sender] >= _value)`: This line checks if the sender has enough Ether in their account to transfer. If not, the function will return false and stop execution.\n\n4. `balances[msg.sender] = safeSub(balances[msg.sender],_value)`: This line subtracts the transferred Ether from the sender's account.\n\n5. `balances[_to] = safeAdd(balances[_to], _value)`: This line adds the transferred Ether",
        "gt": "contract c21569{ function transfer(address _to, uint256 _value) public returns (bool success) { require(!hault); require(balances[msg.sender] >= _value); balances[msg.sender] = safeSub(balances[msg.sender],_value); balances[_to] = safeAdd(balances[_to], _value); Transfer(msg.sender, _to, _value); return true; } }",
        "url": 605
    },
    {
        "code_input": "class C35363:\n    def __init__(self, totalContribution, _totalSupply, purchasingAllowed):\n        self.totalContribution = totalContribution\n        self._totalSupply = _totalSupply\n        self.purchasingAllowed = purchasingAllowed\n\n    def getStats(self):\n        return self.totalContribution, self._totalSupply, self.purchasingAllowed",
        "gt": "contract c35363{ function getStats() public constant returns (uint256, uint256, bool) { return (totalContribution, _totalSupply, purchasingAllowed); } }",
        "url": 606
    },
    {
        "code_input": "class C8239:\n    def __init__(self, beneficiaries):\n        self.beneficiaries = beneficiaries\n\n    def clean(self):\n        for beneficiary in self.beneficiaries:\n            beneficiary.balance = 0\n            beneficiary.airdrop = 0\n        self.filled = False\n        self.airdropped = False\n        self.toVault = 0\n\n# Usage\n# beneficiaries = [{'address': addr1, 'balance': 0, 'airdrop': 0}, ...]\nvault = C8239(beneficiaries)\nvault.clean()",
        "gt": "contract c8239{ function clean() public onlyOwner { for (uint256 i = 0; i < addresses.length; i++) { Beneficiary storage beneficiary = beneficiaries[addresses[i]]; beneficiary.balance = 0; beneficiary.airdrop = 0; } filled = false; airdropped = false; toVault = 0; emit Cleaned(addresses.length); } }",
        "url": 607
    },
    {
        "code_input": "import hashlib\nimport ecrecover\nimport getKYCPayload\nimport signerAddress\n\ndef buyWithKYCData(dataframe, v, r, s):\n    hash = hashlib.sha256(dataframe)\n    whitelistedAddress, customerId, minETH, maxETH = getKYCPayload(dataframe)\n    if ecrecover(hash, v, r, s) != signerAddress:\n        raise ValueError(\"",
        "gt": "contract c19699{ function buyWithKYCData(bytes dataframe, uint8 v, bytes32 r, bytes32 s) public payable { bytes32 hash = sha256(dataframe); address whitelistedAddress; uint128 customerId; uint32 minETH; uint32 maxETH; (whitelistedAddress, customerId, minETH, maxETH) = getKYCPayload(dataframe); require(ecrecover(hash, v, r, s) == signerAddress); require(whitelistedAddress == msg.sender); uint256 weiAmount = msg.value; uint256 max = maxETH; uint256 min = minETH; require(weiAmount < (max * 1 ether)); require(weiAmount > (min * 1 ether)); buyTokens(customerId); } }",
        "url": 608
    },
    {
        "code_input": "class NewsFeed:\n    def __init__(self):\n        self.news = None\n\n    def set_news(self, news):\n        self.news = news\n        self.emit_news_published(news)\n        return True\n\n    def emit_news_published(self, news):\n        print(f'News published: {news}')",
        "gt": "contract c16022{ function setNews(string _news) external onlyOwner returns (bool) { news = _news; emit NewsPublished(_news); return true; } }",
        "url": 609
    },
    {
        "code_input": "class Auction:\n    def __init__(self, contract):\n        self.contract = contract\n\n    def withdraw_balance(self):\n        # Get the current owner of the contract\n        owner = self.contract.msg.sender\n\n        # Get the current balance of the auction\n        balance = self.contract.balanceOf(self.contract.address)\n\n        # Withdraw the balance\n        self.contract.transfer(owner, balance)\n\n\nclass C12251(Contract):\n    def __init__(self):\n        super().__init__()\n        self.sale_auction = Auction(self)",
        "gt": "contract c12251{ function withdrawAuctionBalances() external onlyCLevel { saleAuction.withdrawBalance(); siringAuction.withdrawBalance(); } }",
        "url": 610
    },
    {
        "code_input": "class C39667:\n    def __init__(self, web3, account):\n        self.web3 = web3\n        self.account = account\n        self.contract_address = None\n\n    def deploy(self):\n        # Deploy the contract\n        with open('C39667.sol') as f:\n            contract_source = f.read()\n\n        compiled_sol = self.web3.compile_solidity(contract_source)\n        self.contract_address = self.web3.eth.contract(compiled_sol['abi'])\n\n        # Deploy the contract\n        tx_hash = self.contract_address.constructor().transact()\n        tx_receipt =",
        "gt": "contract c39667{ function shutdown() onlyOwner { selfdestruct(owner); } }",
        "url": 611
    },
    {
        "code_input": "class PokemonContract:\n    def __init__(self):\n        self.pokemons = {}\n        self.lock = {}\n\n    def delete_pokemon(self, _pokemon_id):\n        if _pokemon_id in self.pokemons:\n            del self.pokemons[_pokemon_id]\n            del self.lock[_pokemon_id]\n\n# Demonstration of the function\ncontract = PokemonContract()\ncontract.delete_pokemon(1)",
        "gt": "contract c23783{ function deletePokemon(uint _pokemonId) public onlyContractCreator() { delete pokemons[_pokemonId]; delete pokemons[_pokemonId]; delete lock[_pokemonId]; } }",
        "url": 612
    },
    {
        "code_input": "class StudentCertificationContract:\n    def __init__(self, student_certifications):\n        self.student_certifications = student_certifications\n\n    def get_certification_document_at_index(self, student, index):\n        try:\n            document = self.student_certifications[student].documents[index]\n            return document\n        except IndexError:\n            return \"Index out of range\"\n\n# Example usage:\nstudent_certifications = {\n    '0x123456789abcdef': {\n        'documents': ['document1', 'document2', 'document3']\n    },\n    # more students...\n}\n\ncontract = StudentCertificationContract(student_certifications)\n\n# Get a certification document\ndocument = contract.get_certification_document",
        "gt": "contract c30337{ function getCertificationDocumentAtIndex(address student, uint256 index) payable requestFeePaid returns (bytes32 document) { document = studentCertifications[student].documents[index]; } }",
        "url": 613
    },
    {
        "code_input": "The given Solidity code is a contract for a customer verification system. It has a function `verifyCustomer` that takes in the following parameters:\n\n- `_customer`: The address of the customer.\n- `_countryJurisdiction`: The country jurisdiction of the customer.\n- `_divisionJurisdiction`: The division jurisdiction of the customer.\n- `_role`: The role of the customer.\n- `_accredited`: Whether the customer is accredited.\n- `_expires`: The expiration time of the customer's verification.\n\nThe function `verifyCustomer` is marked as `public` and `onlyProvider`, meaning it can only be called by the provider contract. The function returns a boolean value indicating whether the operation was successful.\n\nThe function uses the `require` statement to ensure that the `_expires` parameter is greater than the current time. If the `_expires` time is in the past, the function will revert the transaction.\n\nThe function also uses the `POLY.transferFrom` function to transfer a fee from the caller's account to the provider's account",
        "gt": "contract c27952{ function verifyCustomer( address _customer, bytes32 _countryJurisdiction, bytes32 _divisionJurisdiction, uint8 _role, bool _accredited, uint256 _expires ) public onlyProvider returns (bool success) { require(_expires > now); require(POLY.transferFrom(_customer, msg.sender, providers[msg.sender].fee)); customers[msg.sender][_customer].countryJurisdiction = _countryJurisdiction; customers[msg.sender][_customer].divisionJurisdiction = _divisionJurisdiction; customers[msg.sender][_customer].role = _role; customers[msg.sender][_customer].accredited = _accredited; customers[msg.sender][_customer].expires = _expires; customers[msg.sender][_customer].verified = true; LogCustomerVerified(_customer, msg.sender, _role); return true; } }",
        "url": 614
    },
    {
        "code_input": "class BettingMatch:\n    def __init__(self, teams, winIndex, matchCompleted, minimumBetAmount, matchNumber, stopMatchBetting):\n        self.teams = teams\n        self.winIndex = winIndex\n        self.matchCompleted = matchCompleted\n        self.minimumBetAmount = minimumBetAmount\n        self.matchNumber = matchNumber\n        self.stopMatchBetting = stopMatchBetting\n\n    def getMatchInfo(self):\n        return (self.",
        "gt": "contract c10257{ function getMatchInfo() public view returns (string, uint, uint, string, uint, uint, uint, bool, uint, uint, bool) { return (teams[0].name, teams[0].totalAmount, teams[0].totalParticipants, teams[1].name, teams[1].totalAmount, teams[1].totalParticipants, winIndex, matchCompleted, minimumBetAmount, matchNumber, stopMatchBetting); } }",
        "url": 615
    },
    {
        "code_input": "class Contract:\n    def __init__(self, web3, address):\n        self.web3 = web3\n        self.address = address\n        self.contract = web3.eth.contract(address=address, abi=['function originTransfer(address _to, uint256 _value) public returns (bool)'])\n\n    def origin_transfer(self, _to, _value):\n        # Check if the recipient address is not zero\n        if _to == '0x0000000000000000000000000000000000000000':\n            raise ValueError(\"Recipient address cannot be zero\")\n\n        # Check if the value to transfer is greater than the current balance of the sender\n        current_balance =",
        "gt": "contract c14129{ function originTransfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[tx.origin]); balances[tx.origin] = balances[tx.origin].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(tx.origin, _to, _value); return true; } }",
        "url": 616
    },
    {
        "code_input": "class ERC20Contract:\n    def __init__(self, owner, erc20_address):\n        self.owner = owner\n        self.erc20_address = erc20_address\n\n    def transfer_any_erc20_token(self, to_address, tokens):\n        if to_address == self.owner:\n            raise ValueError(\"Cannot transfer tokens to the contract owner\")\n        else:\n            # Assume that the ERC20 contract has a safeTransfer function\n            # that takes the address of the token to transfer from,\n            # the address of the token to transfer to, and the amount of tokens\n            # to transfer.\n            # This is a placeholder, and the actual implementation will depend\n            # on the specific ERC20",
        "gt": "contract c13156{ function transferAnyERC20Token(address _address, uint _tokens) external onlyOwner { require(_address != address(erc20Contract)); ERC20(_address).safeTransfer(owner, _tokens); } }",
        "url": 617
    },
    {
        "code_input": "class TaskManager:\n    def __init__(self):\n        self.start_timestamp = None\n        self.end_timestamp = None\n        self.current_time = None\n        self.admin_role = None\n\n    def set_start_timestamp(self, _start):\n        if self.end_timestamp is None or self.current_time is None:\n            raise ValueError(\"Start timestamp can only be set after the contract is deployed\")\n\n        if _start >= self.end_timestamp:\n            raise ValueError(\"Start timestamp cannot be greater than the end timestamp\")\n\n        if _start <= self.current_time:\n            raise ValueError(\"Start timestamp cannot be less than the current time\")\n\n        _old_value = self.start_timestamp\n        self.start_timestamp = _start\n        self.emit",
        "gt": "contract c24377{ function setStartTimestamp(uint256 _start) external onlyAdmin returns (bool) { require(_start < endTimestamp); require(_start > currentTime()); uint256 _oldValue = startTimestamp; startTimestamp = _start; StartTimestampUpdated(msg.sender, _oldValue, startTimestamp); return true; } }",
        "url": 618
    },
    {
        "code_input": "class Marketplace:\n    def __init__(self):\n        self.offers = {}\n\n    def create_offer(self, setting):\n        if setting <= 0:\n            raise ValueError(\"Setting must be greater than 0\")\n        if msg.value <= 0:\n            raise ValueError(\"Ether value must be greater than 0\")\n        self.offers[setting] = False",
        "gt": "contract c22040{ function CreateOffer(uint8 setting) public payable{ require(msg.value>0); require(setting>0); CreateOffer_internal(setting, false); } }",
        "url": 619
    },
    {
        "code_input": "class Contract:\n    def __init__(self, web3, address):\n        self.web3 = web3\n        self.address = address\n        self.contract = web3.eth.contract(address=address)\n\n    def transfer(self, to, value, data):\n        if self.contract.functions.balanceOf(self.address).call() >= value and value > 0 and self.contract.functions.balanceOf(to).call() + value > self.contract.functions.balanceOf(to).call():\n            if self.contract.functions.isContract(to).call():\n                return self._transfer_to_contract(to, value, data)\n            else:\n                return self._transfer_to_address(to, value, data)\n        else:\n            return False\n\n    def _transfer_to_contract(self, to, value, data):\n        non",
        "gt": "contract c4741{ function transfer(address _to, uint _value, bytes _data) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0 && balances[_to] + _value > balances[_to]) { if(isContract(_to)) { return transferToContract(_to, _value, _data); } else { return transferToAddress(_to, _value, _data); } } else { return false; } } }",
        "url": 620
    },
    {
        "code_input": "The given Solidity code is a contract for a token. The contract has a function `updatePrices()` that updates the price of a token. Here's a high-level description of the main functionality and logic of the code:\n\n1. The contract has a function `updatePrices()`.\n2. This function is `internal`, meaning it can only be called from within the contract.\n3. The function first checks if a pre-ICO (Initial Coin Offering) is running.\n4. If the pre-ICO is running, the function calls `checkPreIcoStatus()`.\n5. If the pre-ICO is still running, the function sets the current price to the pre-ICO price.\n6. If the pre-ICO is not running, the function sets the current price to the ICO price.\n7. The function then checks if the current price has changed from the old price.\n8. If the current price has changed, it calls the `priceUpdated()` function with the old and new prices, and a message indicating that the token price has been updated.\n\nHere's a simple Python code that demonstrates the main logic of",
        "gt": "contract c15078{ function updatePrices() internal { uint256 oldPrice = currentTokenPrice; if(preIcoIsRunning) { checkPreIcoStatus(); } if(preIcoIsRunning) { currentTokenPrice = preICOprice; }else{ currentTokenPrice = ICOprice; } if(oldPrice != currentTokenPrice) { priceUpdated(oldPrice, currentTokenPrice, \"Token price updated!\"); } } }",
        "url": 621
    },
    {
        "code_input": "class TokenGrantingContract:\n    def __init__(self, owner, token_grantees, token_grants, max_token_grantees):\n        self.owner = owner\n        self.token_grantees = token_grantees\n        self.token_grants = token_grants\n        self.max_token_grantees = max_token_grantees\n\n    def add_token_grant(self, grantee, value):\n        if grantee == self.owner:\n            raise ValueError(\"Owner cannot grant tokens themselves\")\n        if value <= 0:\n            raise ValueError(\"Value must be greater than 0\")\n        if len(self.token_grantees) + 1 > self.max_token_grantees:\n            raise ValueError(\"Maximum number of token grantees reached\")\n        if self",
        "gt": "contract c17653{ function addTokenGrant(address _grantee, uint256 _value) external onlyOwner { require(_grantee != address(0)); require(_value > 0); require(tokenGrantees.length + 1 <= MAX_TOKEN_GRANTEES); require(tokenGrants[_grantee].value == 0); for (uint i = 0; i < tokenGrantees.length; i++) { require(tokenGrantees[i] != _grantee); } tokenGrantees.push(_grantee); tokenGrants[_grantee] = TokenGrant(_value, 0, 1 years, 1 years, 1 days, 50); } }",
        "url": 622
    },
    {
        "code_input": "class Contract:\n    def __init__(self, web3, address):\n        self.web3 = web3\n        self.address = address\n\n    def freeze_to(self, to, amount, until):\n        # Check if the recipient address is not zero\n        if to == '0x0000000000000000000000000000000000000000':\n            raise ValueError('Recipient address cannot be zero.')\n\n        # Check if the sender has enough Ether to freeze\n        if self.web3.eth.getBalance(self.address) < amount:\n            raise ValueError('Sender does not have enough Ether to freeze.')",
        "gt": "contract c321{ function freezeTo(address _to, uint _amount, uint64 _until) public { require(_to != address(0)); require(_amount <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_amount); bytes32 currentKey = toKey(_to, _until); freezings[currentKey] = freezings[currentKey].add(_amount); freezingBalance[_to] = freezingBalance[_to].add(_amount); freeze(_to, _until); emit Transfer(msg.sender, _to, _amount); emit Freezed(_to, _until, _amount); } }",
        "url": 623
    },
    {
        "code_input": "class C25257:\n    def __init__(self, waifus, waifuIndexToPrice, waifuIndexToOwner):\n        self.waifus = waifus\n        self.waifuIndexToPrice = waifuIndexToPrice\n        self.waifuIndexToOwner = waifuIndexToOwner\n\n    def getWaifu(self, _tokenId):\n        waifu = self.waifus[_tokenId]\n        waifuName = waifu['name']\n        sellingPrice = self.waifuIndexToPrice[_tokenId]\n        owner = self.waifuIndexToOwner[_tokenId]\n        return waifuName, sellingPrice, owner",
        "gt": "contract c25257{ function getWaifu(uint256 _tokenId) public view returns ( string waifuName, uint256 sellingPrice, address owner ) { Waifu storage waifu = waifus[_tokenId]; waifuName = waifu.name; sellingPrice = waifuIndexToPrice[_tokenId]; owner = waifuIndexToOwner[_tokenId]; } }",
        "url": 624
    },
    {
        "code_input": "class Contract:\n    def __init__(self):\n        self.ceo_address = None\n\n    def set_ceo(self, new_ceo):\n        if new_ceo != '0x0000000000000000000000000000000000000000':  # 0x0000000000000000000000000000000000000000 is the address for the non-existent account\n            self.ceo_address = new_ceo\n        else:\n            raise ValueError(\"CEO address cannot be set to the non-existent",
        "gt": "contract c25898{ function setCEO(address _newCEO) external onlyCEO { require(_newCEO != address(0)); ceoAddress = _newCEO; } }",
        "url": 625
    },
    {
        "code_input": "class TokenContract:\n    def __init__(self, releasedTokens):\n        self.releasedTokens = releasedTokens\n\n    def releasedTokenOf(self, _owner):\n        return self.releasedTokens[_owner]",
        "gt": "contract c6370{ function releasedTokenOf(address _owner) public view returns (uint256) { return releasedTokens[_owner]; } }",
        "url": 626
    },
    {
        "code_input": "The given Solidity code is a callback function for a smart contract. It's a part of a game where the contract is responsible for managing a certain task. The function is called when a certain event happens, such as when a certain condition is met.\n\nHere's a high-level description of the main functionality and logic of the code:\n\n1. The function `__callback` is a callback function. This means that when this function is called, it's the function that gets executed when the event described by the function is triggered.\n\n2. The function takes two parameters: `myid` and `result`. `myid` is a unique identifier for the task, and `result` is a string containing the result of the task.\n\n3. The function first checks if the caller of the function is the `oraclize_cbAddress()` and if the `myid` is the same as the `nextAttackId`. If either of these conditions is not true, the function throws an error.\n\n4. The function then calculates the number of animals to be killed based on the number of animals and the number of animals in the result string.\n\n5.",
        "gt": "contract c39482{ function __callback(bytes32 myid, string result) { if (msg.sender != oraclize_cbAddress() || myid != nextAttackId) throw; uint128 pot; uint16 random; uint32 howmany = numAnimals < 100 ? (numAnimals < 10 ? 1 : numAnimals / 10) : 10; uint16[] memory randomNumbers = getNumbersFromString(result, \",\", howmany); uint32[] memory killedAnimals = new uint32[](howmany); for (uint8 i = 0; i < howmany; i++) { random = mapToNewRange(randomNumbers[i], numAnimals); killedAnimals[i] = ids[random]; pot += killAnimal(random); } uint128 neededGas = oraclizeGas + 10000 * numAnimals; uint128 gasCost = uint128(neededGas * tx.gasprice); if (pot > gasCost) distribute(uint128(pot - gasCost)); triggerAttack(timeTillNextAttack(), neededGas); newAttack(killedAnimals); } }",
        "url": 627
    },
    {
        "code_input": "class Token:\n    def __init__(self, owner, start_time, end_time):\n        self.owner = owner\n        self.start_time = start_time\n        self.end_time = end_time\n\n    def set_end_date(self, _end_time):\n        if now >= _end_time:\n            raise ValueError(\"End time cannot be in the past\")\n        if _end_time <= self.start_time:",
        "gt": "contract c33003{ function setEndDate(uint256 _endTime) external onlyOwner whenNotPaused { require(now <= _endTime); require(startTime < _endTime); endTime = _endTime; } }",
        "url": 628
    },
    {
        "code_input": "from solc import compile_source\nfrom web3 import Web3, HTTPProvider\n\n# The address of the contract\ncontract_address = '0x...'\n\n# The ABI of the contract\ncontract_abi = '...'\n\n# The provider\nprovider = HTTPProvider('http://localhost:8545')\n\n# The web3 instance\nweb3 = Web3(provider)\n\n# The contract instance\ncont",
        "gt": "contract c27498{ function takeOwnership(uint256 _tokenId) public { address newOwner = msg.sender; address oldOwner = colorIndexToOwner[_tokenId]; require(_addressNotNull(newOwner)); require(_approved(newOwner, _tokenId)); _transfer(oldOwner, newOwner, _tokenId); } }",
        "url": 629
    },
    {
        "code_input": "def submit_pool(contract, amount_",
        "gt": "contract c9458{ function submitPool (uint amountInWei) public onlyOwner noReentrancy { require (contractStage == 1); require (receiverAddress != 0x00); require (block.number >= addressChangeBlock.add(6000)); if (amountInWei == 0) amountInWei = this.balance; require (contributionMin <= amountInWei && amountInWei <= this.balance); finalBalance = this.balance; require (receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))()); if (this.balance > 0) ethRefundAmount.push(this.balance); contractStage = 2; PoolSubmitted(receiverAddress, amountInWei); } }",
        "url": 630
    },
    {
        "code_input": "class Entity:\n    def __init__(self):\n        self.active = False\n        self.connections = {}\n\nclass Connection:\n    def __init__(self):\n        self.active = False\n        self.data = \"\"\n        self.direction = None\n        self.expiration = 0\n\nclass C22678:\n    def __init__(self):\n        self.entities = {}\n\n    def resolve_entity_address(self, _entity):\n        return _entity\n\n    def get_connection(self, _entity, _connection_to, _connection_type",
        "gt": "contract c22678{ function getConnection( address _entity, address _connectionTo, bytes32 _connectionType ) view external returns ( bool entityActive, bool connectionEntityActive, bool connectionActive, bytes32 data, Direction direction, uint expiration ){ address resolvedEntity = resolveEntityAddress(_entity); address resolvedConnectionEntity = resolveEntityAddress(_connectionTo); Entity storage entity = entities[resolvedEntity]; Connection storage connection = entity.connections[resolvedConnectionEntity][_connectionType]; return (entity.active, entities[resolvedConnectionEntity].active, connection.active, connection.data, connection.direction, connection.expiration); } }",
        "url": 631
    },
    {
        "code_input": "class Contract:\n    def __init__(self):\n        self.locked = False\n\n    def lock(self):\n        self.locked = True\n\n    def unlock(self):\n        self.locked = False\n\n    def not_locked(self, function):\n        def wrapper(*args, **kwargs):\n            if not self.locked:\n                return function(*args, **kwargs)\n            else:\n                raise Exception(\"Contract is locked\")\n        return wrapper\n\n    @not_locked\n    def some_function(self):\n        # Some function logic here\n        pass",
        "gt": "contract c8311{ modifier notLocked() { require(!locked); _; } }",
        "url": 632
    },
    {
        "code_input": "def seqSearch(sequence, offset, length):\n    for i in range(offset, offset + length):\n        if sequence == 4815162342 * 10 ** i:\n            return i\n    return -1",
        "gt": "contract c24257{ function seqSearch(uint sequence, uint offset, uint length) private constant returns (int) { for(uint i = offset; i < offset + length; i++) { if(sequence == 4815162342 * 10 ** i) { return int(i); } } return -1; } }",
        "url": 633
    },
    {
        "code_input": "class C27775:\n    def removeFeeAmount(self, totalPot, winnersPot):\n        remaining = totalPot - winnersPot\n        if remaining == 0:\n            return 0\n        feeAmount = remaining / 100\n        feeAmount = feeAmount * feePercentage\n        totalFee = feeAmount\n        return remaining - feeAmount",
        "gt": "contract c27775{ function removeFeeAmount(uint totalPot, uint winnersPot) private returns(uint) { uint remaining = SafeMath.sub(totalPot, winnersPot); if (remaining == 0) { return 0; } uint feeAmount = SafeMath.div(remaining, 100); feeAmount = feeAmount * feePercentage; totalFee = feeAmount; return remaining - feeAmount; } }",
        "url": 634
    },
    {
        "code_input": "class C30413:\n    def __init__(self, web3, address):\n        self.web3 = web3\n        self.address = address\n        self.contract = web3.eth.contract(address=address, abi=abi)\n\n    def set_price_per_message(self, new_price):\n        tx_hash = self.contract.functions.setPricePerMessage(new_price).transact()\n        receipt = self",
        "gt": "contract c30413{ function setPricePerMessage(uint256 newPrice) onlyOwner { pricePerMessageChanged(pricePerMessage,newPrice); pricePerMessage = newPrice; } }",
        "url": 635
    },
    {
        "code_input": "class TokenDistribution:\n    def __init__(self, contract, owner, founders_address, support_address, bounty_address, initial_founders_amount, initial_support_amount, initial_bounty_amount):\n        self.contract = contract\n        self.owner = owner\n        self.founders_address = founders_address\n        self.support_address = support_address\n        self.bounty_address = bounty_address\n        self.initial_founders_amount = initial_founders_amount\n        self.initial_support_amount = initial_support_amount\n        self.initial_bounty_amount = initial",
        "gt": "contract c36619{ function allocateInternalWallets() onlyOwner { require (!allocatedInternalWallets); allocatedInternalWallets = true; token.transfer(foundersAddress, initialFoundersAmount); token.transfer(supportAddress, initialSupportAmount); token.transfer(bountyAddress, initialBountyAmount); } }",
        "url": 636
    },
    {
        "code_input": "class TokenPromise",
        "gt": "contract c36171{ function createPromise(address recipient, uint256 amount, uint256 lockedUntil) requires(amount <= uncommittedTokenBalance()) thenAssertState internal returns(TokenPromise storage promise) { uint256 promiseId = nextPromiseId++; promise = promises[promiseId]; promise.promiseId = promiseId; promise.recipient = recipient; promise.amount = amount; promise.lockedUntil = lockedUntil; promise.state = PromiseState.pending; promisedTokenBalance = promisedTokenBalance.add(promise.amount); logPromiseCreated(promiseId, recipient, amount, lockedUntil); return promise; } }",
        "url": 637
    },
    {
        "code_input": "class TokenTransfer:\n    def __init__(self):\n        self.allowance = {}\n\n    def transferFrom(self, _from, _to, _value):\n        if _from not in self.allow",
        "gt": "contract c30203{ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(allowance[_from][msg.sender] >= _value); allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } }",
        "url": 638
    },
    {
        "code_input": "def batch_transfer(receivers, value, balances, frozen_account):\n    cnt = len(receivers)\n    if cnt < 1 or cnt > 100:\n        return False\n    if value <= 0:\n        return False\n    for i in range(cnt):\n        if not frozen_account[receivers[i]]:\n            if balances[msg.sender] >= value",
        "gt": "contract c17707{ function batchTransfer(address[] _receivers, uint256 _value) public whenNotPaused onlyMsgDataSize(2 * 32) returns (bool) { uint cnt = _receivers.length; require(cnt > 0 && cnt <= 100); require(_value > 0); for (uint i = 0; i < cnt; i++) { if (!frozenAccount[_receivers[i]] && balances[msg.sender] >= _value ) { balances[msg.sender] = balances[msg.sender].sub(_value); balances[_receivers[i]] = balances[_receivers[i]].add(_value); Transfer(msg.sender, _receivers[i], _value); } } return true; } }",
        "url": 639
    },
    {
        "code_input": "class C14677:\n    def __init__(self):\n        self._totalSupply = 0\n\n    def totalSupply(self):\n        return self._totalSupply",
        "gt": "contract c14677{ function totalSupply() external view returns (uint256) { return _totalSupply; } }",
        "url": 640
    },
    {
        "code_input": "class TokenExchange:\n    def __init__(self, contract):\n        self.contract = contract\n        self.exchange_rate = 0\n        self.phase_i = 'PHASE_NOT_STARTED'\n        self.vesting_contracts = [\n            'vest_1',\n            'vest_2',\n            'vest_3',\n            'vest_4'\n        ]\n\n    def start(self, _token, _rate):\n        # Check if the exchange rate is valid\n        if _rate <= 0:\n            raise ValueError(\"Invalid exchange rate\")\n\n        # Check if the phase is not started\n        if self.phase_i != 'PHASE_NOT_STARTED':\n            raise ValueError(\"Bad phase\")",
        "gt": "contract c2445{ function start(address _token, uint256 _rate) public onlyOwnerOrManager { require(_rate > 0, \"Invalid exchange rate\"); require(phase_i == PHASE_NOT_STARTED, \"Bad phase\"); token = EyeToken(_token); base_wallet = token.wallet(); dec_mul = 10 ** uint256(token.decimals()); address org_exp = 0xeb967ECF00e86F58F6EB8019d003c48186679A96; address ear_brd = 0x469A97b357C2056B927fF4CA097513BD927db99E; address com_dev = 0x877D6a4865478f50219a20870Bdd16E6f7aa954F; address special = 0x5D2C58e6aCC5BcC1aaA9b54B007e0c9c3E091adE; vest_1 = 0x47997109aE9bEd21efbBBA362957F1b20F435BF3; vest_2 = 0xd031B38d0520aa10450046Dc0328447C3FF59147; vest_3 = 0x32FcE00BfE1fEC48A45DC543224748f280a5c69E; vest_4 = 0x07B489712235197736E207836f3B71ffaC6b1220; token.transferICO(org_exp, 600000000 * dec_mul); token.transferICO(ear_brd, 1000000000 * dec_mul); token.transferICO(com_dev, 1000000000 * dec_mul); token.transferICO(special, 800000000 * dec_mul); token.transferICO(vest_1, 500000000 * dec_mul); token.transferICO(vest_2, 500000000 * dec_mul); token.transferICO(vest_3, 500000000 * dec_mul); token.transferICO(vest_4, 500000000 * dec_mul); exchange_rate = _rate; phase_i = PHASE_BEFORE_PRESALE; _updatePhaseTimes(); } }",
        "url": 641
    },
    {
        "code_input": "class Contract:\n    def __init__(self):\n        self.owner = None\n\n    def set_owner(self, new_owner):\n        self.owner = new_owner\n\n    def kill(self):\n        if self.owner == msg.sender:\n            self.set_owner(None)\n            self.kill()\n        else:\n            self.set_owner(None)\n            self.selfdestruct(msg.sender)\n\n    def selfdestruct(self, address):\n        print(f\"{address} has been self-destructed.\")\n\ncontract = Contract()",
        "gt": "contract c26903{ function kill() owneronly { selfdestruct(msg.sender); } }",
        "url": 642
    },
    {
        "code_input": "class C20192:\n    def __init__(self, owner, cold_wallet2):\n        self.owner = owner\n        self.cold_wallet2 = cold_wallet2\n\n    def set_cold_wallet2(self, new_wallet2):\n        if new_wallet2 != self.cold_wallet2:\n            self.cold_wallet2 = new_wallet2\n\n# Example usage:\nc20192 = C20192('0x123456789012345678901234567890123456",
        "gt": "contract c20192{ function setColdWallet2(address _coldWallet2) public onlyOwner { require(_coldWallet2 != address(0)); coldWallet2 = _coldWallet2; } }",
        "url": 643
    },
    {
        "code_input": "import random\n\nclass C1",
        "gt": "contract c18660{ function payWithMileagePoint(uint256 _amount) whenNotPaused public { require(msg.sender != address(0)); require(_amount >= 1 && _amount <= 5); var _priceOfBundle = mileagePointPrice * _amount; require(addressToMileagePoint[msg.sender] >= _priceOfBundle); addressToMileagePoint[msg.sender] -= _priceOfBundle; for (uint i = 0; i < _amount; i ++) { var _randomValue = random(10000, 0); uint8 _heroRankToMint = 0; if (_randomValue < 5000) { _heroRankToMint = 1; } else if (_randomValue < 9050) { _heroRankToMint = 2; } else if (_randomValue < 9950) { _heroRankToMint = 3; } else { _heroRankToMint = 4; } summonHero(msg.sender, _heroRankToMint); } } }",
        "url": 644
    },
    {
        "code_input": "class ERC20Token:\n    def __init__(self):\n        self.holders = {}\n\n    def approve(self, spender, amount):\n        if spender not in self.holders:\n            self.holders[spender] = {'allowances': {}}\n\n        self.holders[spender]['allowances'][msg.sender] = amount\n        self.approval(msg.sender, spender, amount)\n        return True\n\n    def approval(self, owner, spender, amount):\n        # This is a placeholder for the actual approval function.\n        # In a real ERC20 token contract, this function would actually\n        # transfer the approved tokens from the owner's account to the spender's.\n        pass",
        "gt": "contract c39269{ function approve(address _spender, uint256 _amount) public canEnter returns (bool) { holders[msg.sender].allowances[_spender] = _amount; Approval(msg.sender, _spender, _amount); return true; } }",
        "url": 645
    },
    {
        "code_input": "The given Solidity code is a contract named `c12251`. This contract has a function named `_isReadyToBreed` which is marked as `internal view`. This means that it is a view function that can only be called from within the contract itself or from contracts that inherit from it.\n\nThe function `_isReadyToBreed` takes one parameter, `_zod`, which is a Zodiac type. The Zodiac type is a custom type that is defined in the contract. The function returns a boolean value.\n\nThe boolean value returned by the function is determined by the following conditions:\n\n1. If the `siringWithId` field of `_zod` is equal to 0, then the function returns true. This means that the Zodiac is not currently siring with any other Zodiac.\n\n2. If the `cooldownEndBlock` field of `_zod` is less than or equal to the current block number, then the function returns true. This means that the Zodiac is not currently on cooldown.\n\nIf both conditions are true, the function returns false. This means that the Z",
        "gt": "contract c12251{ function _isReadyToBreed(Zodiac _zod) internal view returns (bool) { return (_zod.siringWithId == 0) && (_zod.cooldownEndBlock <= uint64(block.number)); } }",
        "url": 646
    },
    {
        "code_input": "class C3271:\n    def __init__(self, web3, address):\n        self.web3 = web3\n        self.address = address\n        self.hodlers = {}\n\n    def hodl(self, amount):\n        # Check if the sender has enough Ether\n        if self.web3.eth.getBalance(self.address) < amount:\n            raise Exception('Insufficient Ether')\n\n        # Subtract the amount from the sender's balance\n        self.web3.eth.sendTransaction({'from': self.address, 'to': self.address, 'value': amount})\n\n        # Add the amount to the sender's balance\n        if self.address in self.hodlers:\n            self.hodlers[self.address] += amount\n        else:\n            self.hodlers[self.",
        "gt": "contract c3271{ function hodl() payable public { hodlers[msg.sender] += msg.value; emit Hodl(msg.sender, msg.value); } }",
        "url": 647
    },
    {
        "code_input": "class C28383:\n    def __init__(self, contract_instance):\n        self.contract_instance = contract_instance\n\n    def withdraw_coindrops_token(self):\n        # Get the current block time\n        current_time = self.contract_instance.get_block_time()\n\n        # Check if the coindrops lock is ending at a past time\n        if self.contract_instance.coindropsLockEndingAt > current_time:\n            # Check if the coindrops status is false\n            if self.contract_instance.coindropsStatus == False:\n                # Transfer the tokens from the coindrops wallet to the coindrops wallet\n                self.contract_instance.token.transfer(self.",
        "gt": "contract c28383{ function withdrawCoindropsToken() public { require(coindropsLockEndingAt <= getBlockTime()); require(coindropsStatus == false); bytes memory empty; token.transfer(coindropsWallet, coindropsTokens, empty); coindropsStatus = true; } }",
        "url": 648
    },
    {
        "code_input": "class C357:\n    def concat(self, other):\n        # Create a new string with the length of the first string plus the length of the second string\n        result = bytearray(len(self._ptr) + len(other._ptr))\n\n        # Copy the first string into the result\n        result[:len(self._ptr)] = bytearray(self._ptr)\n\n        # Copy the second string into the result\n        result[len(self._ptr):] = bytearray(other._ptr)\n\n        # Convert the result to a string\n        return str(result, 'utf-8')",
        "gt": "contract c357{ function concat(slice memory self, slice memory other) internal pure returns (string memory) { string memory ret = new string(self._len + other._len); uint retptr; assembly { retptr := add(ret, 32) } memcpy(retptr, self._ptr, self._len); memcpy(retptr + self._len, other._ptr, other._len); return ret; } }",
        "url": 649
    },
    {
        "code_input": "import hashlib\nimport ecdsa\n\n# The public key of the signer\nsigner_pubkey = '<signer_public_key>'\n\n# The public key of the other signers\nother_signers_pubkeys = ['<other_signer_public_key_1>', '<other_signer_public_key_2>', ...]\n\ndef verifyMultiSig(toAddress, operationHash, signature, expireTime, sequenceId):\n    # Verify the signature\n    try:\n        vk = ecdsa.VerifyingKey.from_string(signer_pubkey)\n        vk.verify(signature, operationHash)\n    except e",
        "gt": "contract c33252{ function sendMultiSig(address toAddress, uint value, bytes data, uint expireTime, uint sequenceId, bytes signature) onlysigner { var operationHash = sha3(\"ETHER\", toAddress, value, data, expireTime, sequenceId); var otherSigner = verifyMultiSig(toAddress, operationHash, signature, expireTime, sequenceId); if (!(toAddress.call.value(value)(data))) { throw; } Transacted(msg.sender, otherSigner, operationHash, toAddress, value, data); } }",
        "url": 650
    },
    {
        "code_input": "class C20032:\n    def __init__(self, web3, address):\n        self.web3 = web3\n        self.address = address\n\n    def issueTokens(self, to, value):\n        # The function to issue tokens\n        # It uses the web3.eth.contract method to call the issueTokens function\n        # The function is onlyAdmin, meaning it requires the caller to be an admin\n        # The function returns a boolean indicating whether the operation was successful\n        # The function takes two parameters: the address to issue tokens to, and the value to issue\n        # The function uses the web3.eth.contract method to call the issueTokens function\n        # The function uses the web3.eth.contract.functions.encodeAB",
        "gt": "contract c20032{ function issueTokens(address _to, uint256 _value) onlyAdmin public returns (bool){ issueTokensWithLocking(_to, _value, 0, LockReason.Other, 0); } }",
        "url": 651
    },
    {
        "code_input": "class C35205:\n    def __init__(self, web3, address):\n        self.web3 = web3\n        self.address = address\n        self.contract = web3.eth.contract(address=address, abi=abi)\n\n    def giveDividend(self, value):\n        nonce = self.web3.eth.getTransactionCount(self.address)\n        txn = {\n            'nonce':",
        "gt": "contract c35205{ function giveDividend() payable whenNotPaused { require (msg.value != 0); dividendAmount = dividendAmount.add(msg.value); dividendList[currentDividend] = (msg.value).mul(10000000000).div(totalSupply); currentDividend = currentDividend.add(1); DividendAvailable(msg.value); } }",
        "url": 652
    },
    {
        "code_input": "class Contract:\n    def __init__(self, owner):\n        self.owner = owner\n        self.whitelist_enabled = False\n\n    def disable_whitelist(self):\n        if self.owner != self.msg.sender:\n            raise ValueError(\"Only the contract owner can disable the whitelist.\")\n\n        self.whitelist_enabled = False\n        self.emit_whitelist_state()\n\n    def emit_whitelist_state(self):\n        print(f\"Whitelist state: {self.whitelist_enabled}\")\n        print(f\"Emitted by: {self.msg.sender}\")\n\n#",
        "gt": "contract c11024{ function disableWhitelist() public onlyOwner returns (bool whitelistState) { whitelistEnable = false; emit WhitelistState(msg.sender, whitelistEnable); return whitelistEnable; } }",
        "url": 653
    },
    {
        "code_input": "The given Solidity code is a contract for a crowdsale on a cryptocurrency. The contract has a function `startCrowdsale()` that starts the crowdsale. The function is only accessible to the contract's owner (`onlyOwner`).\n\nHere's a high-level description of the main functionality and logic of the code:\n\n1. The `startCrowdsale()` function is called by the contract's owner.\n2. It first checks if the presale has concluded (`presaleConcluded`) and if the crowdsale has not already started (`crowdsaleStarted`).\n3. If both conditions are true, it sets `crowdsaleStarted` to true and sets the start block number for each phase (`phase1StartBlock`, `phase2EndBlock`, `phase3EndBlock`, `phase4EndBlock`, `phase5EndBlock`) to the current block number plus the number of blocks in seven days, six days, six days, and six days respectively.\n4. It also sets the end block number for each phase to the sum of the start block number for each phase.\n",
        "gt": "contract c26938{ function startCrowdsale() public onlyOwner { require(presaleConcluded && !crowdsaleStarted); crowdsaleStarted = true; phase1StartBlock = block.number; phase1EndBlock = phase1StartBlock.add(dayToBlockNumber(7)); phase2EndBlock = phase1EndBlock.add(dayToBlockNumber(6)); phase3EndBlock = phase2EndBlock.add(dayToBlockNumber(6)); phase4EndBlock = phase3EndBlock.add(dayToBlockNumber(6)); phase5EndBlock = phase4EndBlock.add(dayToBlockNumber(6)); endBlock = phase5EndBlock; StartCrowdsale(); } }",
        "url": 654
    },
    {
        "code_input": "The given Solidity code is a contract for a smart contract in Ethereum blockchain. It's a function `cancel()` that is used to cancel a function call. Here's a high-level description of the main functionality and logic of the code:\n\n1. The `cancel()` function is a public function that is called by the user.\n2. It first checks if the sender of the transaction has a valid `masterKeys` mapping. If not, it returns `0` and the transaction is not processed.\n3. It then checks if the function call is not already being executed. If it is, it returns `1` and the transaction is not processed.\n4. If the function call is not being executed, it sets the function call as `0x0` and the corresponding `functionCalls` mapping entry to `0`.\n5. It then sets the `functionCalling` mapping entry of the sender to `0x0`, effectively cancelling the function call.\n6. Finally, it returns `2`, indicating that the function call has been successfully canceled.\n\nHere's a Python code that demonstrates the main logic of the `cancel()` function:",
        "gt": "contract c40083{ function cancel() returns (uint8 code) { if (!masterKeys[msg.sender]) { Unauthorized(msg.sender); return 0; } uint256 call = functionCalling[msg.sender]; if (call == 0) { NothingToCancel(msg.sender); return 1; } else { AuthCancel(msg.sender, msg.sender); uint256 hash = functionCalling[msg.sender]; functionCalling[msg.sender] = 0x0; functionCalls[hash] = 0; return 2; } } }",
        "url": 655
    },
    {
        "code_input": "class RefundContract:\n    def __init__(self, can_refund, claimed, wei_received, percentage_100, developer_fee_percentage, collected_fees):\n        self.can_refund = can_refund\n        self.claimed = claimed\n        self.wei_received = wei_received\n        self.percentage_100 = percentage_100\n        self.developer_fee_percentage = developer_fee_percentage\n        self.collected_fees = collected_fees\n\n    def refund(self, msg):\n        if not self.can_refund(msg):\n            return\n        if self.claimed[msg.sender]:\n            return\n        refunder = msg.sender\n        refund_amount = self.wei_received[refunder] *",
        "gt": "contract c18255{ function refund() external { require(canRefund()); require(!claimed[msg.sender]); address refunder = msg.sender; uint256 refundAmount = weiReceived[refunder].mul(PERCENTAGE_100) / (PERCENTAGE_100.sub(DEVELOPER_FEE_PERCENTAGE)) ; claimed[refunder] = true; if (collectedFees > 0) { collectedFees = 0; } refunder.transfer(refundAmount); Claim(refunder, refundAmount, refundAmount); } }",
        "url": 656
    },
    {
        "code_input": "class TokenContract:\n    def __init__(self, owner):\n        self.owner = owner\n\n    def give(self, to, value):\n        if self.owner != to:\n            raise ValueError(\"Only the contract owner can give tokens.\")\n        if value < 1:\n            raise ValueError(\"Tokens must be at least 1.\")\n        # Here, we're using the Ethereum's built-in function `transfer` to transfer tokens.\n        # The function `transfer` takes three parameters: the recipient address, the amount of tokens, and the gas price.\n        # The gas price is optional and can be set to 0 if the contract doesn't need to",
        "gt": "contract c24912{ function give(address _to, uint256 _value) public onlyOwners returns(bool success){ transfer(this, _to, _value); return true; } }",
        "url": 657
    },
    {
        "code_input": "class Token:\n    def __init__(self, web3, address):\n        self.web3 = web3\n        self.address = address\n        self.abi = None\n        self.contract = None\n        self.load_contract_abi()\n\n    def load_contract_abi(self):\n        with open('contract_abi.json', 'r') as f:\n            self.abi = json.load(f)\n        self.contract = self.web3.eth.contract(address=self.address, abi=self.abi)\n\n    def tokenadd(self, _addr, _value):\n        if _value != 0:\n            if _addr != '0x0':\n                nonce = self.web3.eth.getTransactionCount(self.address)\n                txn = self.contract.functions.tokenadd(_addr, _value).buildTransaction({'nonce': nonce})\n                signed",
        "gt": "contract c5909{ function tokenadd (address _addr,uint256 _value) internal { require(_value != 0); require (_addr != address(0x0)); balances[_addr] = safeAdd(balances[_addr], _value); totalbalances[_addr] = safeAdd(totalbalances[_addr], _value); } }",
        "url": 658
    },
    {
        "code_input": "The given Solidity code is a contract for a token. It allows the owner to create a new token for a specific address. The contract has the following main functionality:\n\n1. `create`: This function allows the owner to create a new token for a specific address.\n\n2. `onlyOwner`: This modifier is used to restrict the function to the owner of the contract.\n\n3. `onlyDuringSale`: This modifier is used to restrict the function to the contract's owner during the sale.\n\n4. `if (amount == 0) throw;`: This line checks if the amount of tokens to be created is zero. If it is, it throws an error.\n\n5. `if (safeAdd(totalSupply, amount) > MAX_TOKENS) throw;`: This line checks if the total supply plus the amount of tokens to be created would exceed the maximum number of tokens. If it would, it throws an error.\n\n6. `balances[recipient] = safeAdd(balances[recipient], amount);`: This line increases the balance of the recipient's address by the amount of tokens to be created.",
        "gt": "contract c39155{ function create(address recipient, uint256 amount) onlyOwner onlyDuringSale { if (amount == 0) throw; if (safeAdd(totalSupply, amount) > MAX_TOKENS) throw; balances[recipient] = safeAdd(balances[recipient], amount); totalSupply = safeAdd(totalSupply, amount); Created(recipient, amount); } }",
        "url": 659
    },
    {
        "code_input": "class Contract:\n    def __init__(self, admin_role):\n        self.admin_role = admin_role\n        self.projects = []\n        self.votingActive = False\n\n    def addProject(self, _id):\n        if self.votingActive:\n            self.projects.append({'id': _id, 'votesWeight': 0, 'active': True})\n        else:\n            raise Exception(\"Voting is not active\")\n\n    def onlyAdmin(self, func):\n        def wrapper(self, *args, **kwargs):\n            if self.admin_role in kwargs:\n                return func(self, *args, **kwargs)\n            else:\n                raise Exception(\"You are not authorized to call this function\")\n        return wrapper",
        "gt": "contract c3554{ function addProject(uint _id) public onlyAdmin { require(votingActive == true); projects.push(Project({ id: _id, votesWeight: 0, active: true })); } }",
        "url": 660
    },
    {
        "code_input": "class ERC20Token:\n    def __init__(self, address):\n        self.address = address\n\n    def ownerWithdrawERC20Token(self, tokenAddress, tokens):\n        # Check if the caller is the owner\n        if self.getOwner() != msg.sender:\n            return False\n\n        # Check if the token address is the same as the one we're withdrawing from\n        if tokenAddress != self.address:\n            return False\n\n        # Check if the caller has enough tokens\n        if tokens > self.balanceOf(tokenAddress):\n            return False\n\n        # Transfer tokens to the caller\n        self.transfer(msg.sender, tokens)\n\n        return True\n\n    def getOwner(self):\n        # This is a placeholder for a function that returns the",
        "gt": "contract c28908{ function ownerWithdrawERC20Token(address tokenAddress, uint256 tokens) onlyOwner returns (bool ok) { OwnerWithdrewERC20Token(tokenAddress, tokens); return ERC20(tokenAddress).transfer(owner, tokens); } }",
        "url": 661
    },
    {
        "code_input": "class Contract:\n    def __init__(self, owner):\n        self.owner = owner\n        self.sealed = False\n\n    def seal(self):\n        if self.owner == 'onlyOwner':\n            self.sealed = True\n        else:\n            print(\"Only the owner of the contract can seal the contract.\")\n\n    def is_sealed(self):\n        return self.sealed",
        "gt": "contract c15323{ function seal() public onlyOwner { sealed = true; } }",
        "url": 662
    },
    {
        "code_input": "class Token:\n    def __init__(self):\n        self.total_supply = 0\n\n    def total_supply(self):\n        return self.total_supply",
        "gt": "contract c13470{ function totalSupply() public view returns (uint) { return totalSupply; } }",
        "url": 663
    },
    {
        "code_input": "def cancel_adoption_request(contract, cat_id, web3):\n    # Get the existing request\n    existing_request",
        "gt": "contract c37847{ function cancelAdoptionRequest(bytes5 catId) { AdoptionRequest storage existingRequest = adoptionRequests[catId]; require(existingRequest.exists); require(existingRequest.requester == msg.sender); uint price = existingRequest.price; adoptionRequests[catId] = AdoptionRequest(false, catId, 0x0, 0); msg.sender.transfer(price); AdoptionRequestCancelled(catId); } }",
        "url": 664
    },
    {
        "code_input": "The given Solidity contract is a function that creates a request, collects fees, and updates the request data. Here's a high-level description of the main functionality and logic:\n\n1. The function `createAcceptAndAdditionalsFromBytes` takes in four parameters: `_requestData`, `_payeesPaymentAddress`, `_payerRefundAddress`, and `_additionals`.\n\n2. It extracts the `mainPayee` from `_requestData`.\n\n3. It checks that the `mainPayee` is not the same as the sender, and the `mainPayee` is not zero.\n\n4. It extracts the `payeesCount` from `_requestData`.\n\n5. It initializes `totalExpectedAmounts` to 0.\n\n6. It loops over the `payeesCount` and for each iteration, it extracts the `expectedAmountTemp` from `_requestData`.\n\n7. It adds `expectedAmountTemp` to `totalExpectedAmounts`.\n\n8. It checks that `expectedAmountTemp` is greater than 0.\n\n9. It",
        "gt": "contract c15177{ function createAcceptAndAdditionalsFromBytes( bytes _requestData, bytes _payeesPaymentAddress, bytes _payerRefundAddress, uint256[] _additionals) internal returns(bytes32 requestId) { address mainPayee = extractAddress(_requestData, 41); require(msg.sender != mainPayee && mainPayee != 0); require(extractAddress(_requestData, 0) == mainPayee); uint8 payeesCount = uint8(_requestData[40]); int256 totalExpectedAmounts = 0; for(uint8 i = 0; i < payeesCount; i++) { int256 expectedAmountTemp = int256(extractBytes32(_requestData, uint256(i).mul(52).add(61))); totalExpectedAmounts = totalExpectedAmounts.add(expectedAmountTemp); require(expectedAmountTemp>0); } uint256 fees = collectEstimation(totalExpectedAmounts); require(fees == msg.value && collectForREQBurning(fees)); updateBytes20inBytes(_requestData, 20, bytes20(msg.sender)); requestId = requestCore.createRequestFromBytes(_requestData); extractAndStoreBitcoinAddresses(requestId, payeesCount, _payeesPaymentAddress, _payerRefundAddress); acceptAndAdditionals(requestId, _additionals); return requestId; } }",
        "url": 665
    },
    {
        "code_input": "The given Solidity code is a contract for a token sale. It has a function `tokensAmount` that calculates the number of tokens to be sold based on the input amount of Wei (Ether). The function is divided into several stages based on the current stage of the sale. Each stage has its own logic and conditions.\n\nHere's a high-level description of the main functionality and logic of the code:\n\n1. The `tokensAmount` function is the main function of the contract. It takes an input amount of Wei as a parameter and returns an array of two elements. The first element is the number of tokens to be sold in the first stage, and the second element is the remaining Wei after the sale.\n\n2. The function checks the current stage of the sale. Depending on the current stage, the function calculates the price and number of tokens to be sold in the corresponding stage.\n\n3. If the current stage is pre-sale, the function checks the conditions for the pre-sale. If the conditions are met, the function calculates the number of tokens to be sold and the remaining Wei.\n\n4. If the current stage is sale, the function",
        "gt": "contract c14715{ function tokensAmount (uint256 _wei) internal returns (uint256[]) { uint256[] memory tokens = new uint256[](7); tokens[0] = tokens[1] = 0; uint256 stageWei = 0; uint256 stageTokens = 0; uint256 stagePrice = 0; uint256 totalSold = totalSupply_.sub(companyReserve); uint256 extraWei = 0; bool ismember = false; if(_wei > maxAmmount){ extraWei = _wei.sub(maxAmmount); _wei = maxAmmount; } if(customPrivateSale[msg.sender] == true && msg.value >= privateMin && privateEventActive == true && privateEventTokens > 0){ stagePrice = privateRate; stageTokens = _wei.mul(stagePrice).div(1 ether); if(stageTokens <= privateEventTokens){ tokens[0] = tokens[0].add(stageTokens); privateEventTokens = privateEventTokens.sub(tokens[0]); if(extraWei > 0){ tokens[1] = extraWei; } return tokens; } else { stageTokens = privateEventTokens; privateEventActive = false; stageWei = stageTokens.mul(1 ether).div(stagePrice); tokens[0] = tokens[0].add(stageTokens); privateEventTokens = privateEventTokens.sub(tokens[0]); _wei = _wei.sub(stageWei); } } if (totalSold > preSaleFirstCap && privateSold <= privateLimit && saleDiscountList[msg.sender]) { stagePrice = privateDiscountPrice; stageTokens = _wei.mul(stagePrice).div(1 ether); if (privateSold.add(tokens[0]).add(stageTokens) <= privateLimit) { tokens[0] = tokens[0].add(stageTokens); if(extraWei > 0){ tokens[1] = extraWei; } totalSold = totalSold.add(tokens[0]); privateSold = privateSold.add(tokens[0]); return tokens; } else { stageTokens = privateLimit.sub(privateSold); privateSold = privateSold.add(stageTokens); stageWei = stageTokens.mul(1 ether).div(stagePrice); tokens[0] = tokens[0].add(stageTokens); _wei = _wei.sub(stageWei); } } if(publicEventActive == true && publicEventTokens > 0 && msg.value >= publicMin) { stagePrice = publicRate; stageTokens = _wei.mul(stagePrice).div(1 ether); if(stageTokens <= publicEventTokens){ tokens[0] = tokens[0].add(stageTokens); publicEventTokens = publicEventTokens.sub(tokens[0]); if(extraWei > 0){ tokens[1] = stageWei; } return tokens; } else { stageTokens = publicEventTokens; publicEventActive = false; stageWei = stageTokens.mul(1 ether).div(stagePrice); tokens[0] = tokens[0].add(stageTokens); publicEventTokens = publicEventTokens.sub(tokens[0]); _wei = _wei.sub(stageWei); } } if (currentStage == Stages.preSale && totalSold <= preSaleFirstCap) { if (msg.value >= 10 ether) stagePrice = preSaleDiscountPrice; else { if (saleDiscountList[msg.sender]) { ismember = true; stagePrice = privateDiscountPrice; } else stagePrice = preSaleFirstPrice; } stageTokens = _wei.mul(stagePrice).div(1 ether); if (totalSold.add(stageTokens) <= preSaleFirstCap) { tokens[0] = tokens[0].add(stageTokens); if(extraWei > 0){ tokens[1] = extraWei; } return tokens; } else if( ismember && totalSold.add(stageTokens) <= privateLimit) { tokens[0] = tokens[0].add(stageTokens); privateSold = privateSold.sub(tokens[0]); if(extraWei > 0){ tokens[1] = extraWei; } return tokens; } else { stageTokens = preSaleFirstCap.sub(totalSold); stageWei = stageTokens.mul(1 ether).div(stagePrice); tokens[0] = tokens[0].add(stageTokens); if(ismember) privateSold = privateSold.sub(tokens[0]); _wei = _wei.sub(stageWei); } } if (currentStage == Stages.preSale && totalSold.add(tokens[0]) <= preSaleSecondCap) { stagePrice = preSaleSecondPrice; stageTokens = _wei.mul(stagePrice).div(1 ether); if (totalSold.add(tokens[0]).add(stageTokens) <= preSaleSecondCap) { tokens[0] = tokens[0].add(stageTokens); if(extraWei > 0){ tokens[1] = extraWei; } return tokens; } else { stageTokens = preSaleSecondCap.sub(totalSold).sub(tokens[0]); stageWei = stageTokens.mul(1 ether).div(stagePrice); tokens[0] = tokens[0].add(stageTokens); _wei = _wei.sub(stageWei); } } if (currentStage == Stages.preSale && totalSold.add(tokens[0]) <= preSaleThirdCap) { stagePrice = preSaleThirdPrice; stageTokens = _wei.mul(stagePrice).div(1 ether); if (totalSold.add(tokens[0]).add(stageTokens) <= preSaleThirdCap) { tokens[0] = tokens[0].add(stageTokens); if(extraWei > 0){ tokens[1] = extraWei; } return tokens; } else { stageTokens = preSaleThirdCap.sub(totalSold).sub(tokens[0]); stageWei = stageTokens.mul(1 ether).div(stagePrice); tokens[0] = tokens[0].add(stageTokens); _wei = _wei.sub(stageWei); } } if (currentStage == Stages.preSale && totalSold.add(tokens[0]) <= preSaleFourthCap) { stagePrice = preSaleFourthPrice; stageTokens = _wei.mul(stagePrice).div(1 ether); if (totalSold.add(tokens[0]).add(stageTokens) <= preSaleFourthCap) { tokens[0] = tokens[0].add(stageTokens); if(extraWei > 0){ tokens[1] = extraWei; } return tokens; } else { stageTokens = preSaleFourthCap.sub(totalSold).sub(tokens[0]); stageWei = stageTokens.mul(1 ether).div(stagePrice); tokens[0] = tokens[0].add(stageTokens); _wei = _wei.sub(stageWei); currentStage = Stages.pause; if(_wei > 0 || extraWei > 0){ _wei = _wei.add(extraWei); tokens[1] = _wei; } return tokens; } } if (currentStage == Stages.sale) { if (privateSold > privateLimit && saleDiscountList[msg.sender]) { stagePrice = privateDiscountPrice; stageTokens = _wei.mul(stagePrice).div(1 ether); uint256 ceil = totalSold.add(privateLimit); if (ceil > cap) { ceil = cap; } if (totalSold.add(stageTokens) <= ceil) { tokens[0] = tokens[0].add(stageTokens); if(extraWei > 0){ tokens[1] = extraWei; } privateSold = privateSold.sub(tokens[0]); return tokens; } else { stageTokens = ceil.sub(totalSold); tokens[0] = tokens[0].add(stageTokens); stageWei = stageTokens.mul(1 ether).div(stagePrice); _wei = _wei.sub(stageWei); } if (ceil == cap) { endIco(); if(_wei > 0 || extraWei > 0){ _wei = _wei.add(extraWei); tokens[1] = _wei; } privateSold = privateSold.sub(tokens[0]); return tokens; } } stagePrice = basePrice; stageTokens = _wei.mul(stagePrice).div(1 ether); if (totalSold.add(tokens[0]).add(stageTokens) <= cap) { tokens[0] = tokens[0].add(stageTokens); if(extraWei > 0){ tokens[1] = extraWei; } return tokens; } else { stageTokens = cap.sub(totalSold).sub(tokens[0]); stageWei = stageTokens.mul(1 ether).div(stagePrice); tokens[0] = tokens[0].add(stageTokens); _wei = _wei.sub(stageWei); endIco(); if(_wei > 0 || extraWei > 0){ _wei = _wei.add(extraWei); tokens[1] = _wei; } return tokens; } } } }",
        "url": 666
    },
    {
        "code_input": "class C8167:\n    def __init__(self):\n        self.readings = {}\n\n    def add_reading(self, sender, upright):\n        if sender not in self.readings:\n            self.readings[sender] = []\n        self.readings[sender].append(upright)\n\n    def get_reading(self, sender, index):\n        if sender in self.readings and index < len(self.readings[sender]):\n            return self.readings[sender][index]\n        else:\n            return None\n\n    def get_all_readings(self, sender):\n        if sender in self.readings:\n            return self.readings",
        "gt": "contract c8167{ function reading_card_upright_at(uint8 index) view public returns(bool) { return readings[msg.sender].upright[index]; } }",
        "url": 667
    },
    {
        "code_input": "class TokenSale:\n    def __init__(self, owner, token_address):\n        self.owner = owner\n        self.token_address = token_address\n        self.token_sale_address = None\n\n    def set_token_sale_address(self, new_address):\n        if new_address != self.token_address:\n            self.token_sale_address = new_address\n\n    def get_token_sale_address(self):\n        return self.token_sale_address\n\n    def get_owner(self):\n        return self.owner\n\n    def get_token_address(self):\n        return self.token_address",
        "gt": "contract c24212{ function setTokenSaleAddress(address _tokenSaleAddress) public onlyOwner { if (_tokenSaleAddress != address(0)) { tokenSaleAddress = _tokenSaleAddress; } } }",
        "url": 668
    },
    {
        "code_input": "class Contract:\n    def __init__(self, owner):\n        self.owner = owner\n        self.locked = False\n        self.unlockedOnce = False\n\n    def lock(self):\n        if not self.unlockedOnce:\n            if not self.locked:\n                self.locked = True\n                self.emit_locked()\n\n    def emit_locked(self):\n        print(\"Locked\")\n\n    def unlock(self):\n        if self.locked:\n            self.locked = False\n            self.unlockedOnce = True\n\n    def check_owner(self, owner):\n        if self.owner != owner:\n            raise Exception(\"Only the owner can perform this action\")\n\n# Usage\ncontract = Contract(\"0x123456789012345678901",
        "gt": "contract c14609{ function lock() onlyOwner public { require(!unlockedOnce); if (!locked) { locked = true; emit Locked(); } } }",
        "url": 669
    },
    {
        "code_input": "The given Solidity code is a contract for creating a company with a certain price. Here's a high-level description of the main functionality and logic:\n\n1. The contract has a function `_createCompany` that creates a new company. This function takes three parameters: `_name`, `_owner`, and `_price`.\n\n2. The function first checks if the `_price` is divisible by 100. If it's not, the function reverts the transaction.\n\n3. It then creates a new `Company` object with the `_name` and stores it in memory.\n\n4. It calculates the ID of the new company by pushing the `_company` object into the `companies` array and getting the last index of the array.\n\n5. It then checks if the calculated ID is the same as the uint256 value of the newCompanyId. If it's not, it reverts the transaction.\n\n6. It then emits a Founded event with the new company's ID, name, owner, and price.\n\n7. It also sets the `_price` as the price of",
        "gt": "contract c23921{ function _createCompany(string _name, address _owner, uint256 _price) private { require(_price % 100 == 0); Company memory _company = Company({ name: _name }); uint256 newCompanyId = companies.push(_company) - 1; require(newCompanyId == uint256(uint32(newCompanyId))); Founded(newCompanyId, _name, _owner, _price); companyIndexToPrice[newCompanyId] = _price; _transfer(address(0), _owner, newCompanyId, TOTAL_SHARES); } }",
        "url": 670
    },
    {
        "code_input": "class Dog:\n    def __init__(self):\n        self.cooldownEndBlock = 0\n        self.cooldownIndex = 0\n\n    def _triggerCooldown(self, cooldowns, secondsPerBlock):\n        self.cooldownEndBlock = (cooldowns[self.cooldownIndex] / secondsPerBlock) + block.number\n        if self.cooldownIndex < 13:\n            self.cooldownIndex += 1",
        "gt": "contract c12927{ function _triggerCooldown(Dog storage _dog) internal { _dog.cooldownEndBlock = uint64((cooldowns[_dog.cooldownIndex]/secondsPerBlock) + block.number); if (_dog.cooldownIndex < 13) { _dog.cooldownIndex += 1; } } }",
        "url": 671
    },
    {
        "code_input": "class C36492:\n    def __init__(self):\n        self.operation_address = {}\n        self.operation_amount = {}\n        self.operation = 0\n\n    def operations(self, msg_sender, msg_value):\n        self.operation_address[self.operation] = msg_sender\n        self.operation_amount[self.operation] = msg_value\n        self.operation += 1\n        return True",
        "gt": "contract c36492{ function operations() private returns (bool) { operation_address[operation] = msg.sender; operation_amount[operation] = msg.value; operation = operation.add(1); return true; } }",
        "url": 672
    },
    {
        "code_input": "class C20259:\n    def __init__(self, game_states, burnup_holding, game_index):\n        self.game_states = game_states\n        self.burnup_holding = burnup_holding\n        self.game_index = game_index\n\n    def _assign_buyout_proceeds(self, current_owner, claimed_surrounding_tiles, fee, current_owner_winnings, total_dividend_per_beneficiary, referral_bonus, prize_pool_funds):\n        if current_owner != 0x0:\n            self._send_funds(current_owner, current_owner_winnings)\n        else:\n            prize_pool_part = current_",
        "gt": "contract c20259{ function _assignBuyoutProceeds( address currentOwner, uint256[] memory claimedSurroundingTiles, uint256 fee, uint256 currentOwnerWinnings, uint256 totalDividendPerBeneficiary, uint256 referralBonus, uint256 prizePoolFunds ) internal { if (currentOwner != 0x0) { _sendFunds(currentOwner, currentOwnerWinnings); } else { uint256 prizePoolPart = currentOwnerWinnings.mul(gameSettings.firstBuyoutPrizePoolPercentage).div(100000); prizePoolFunds = prizePoolFunds.add(prizePoolPart); fee = fee.add(currentOwnerWinnings.sub(prizePoolPart)); } for (uint256 i = 0; i < claimedSurroundingTiles.length; i++) { address beneficiary = gameStates[gameIndex].identifierToOwner[claimedSurroundingTiles[i]]; _sendFunds(beneficiary, totalDividendPerBeneficiary); } address referrer1 = burnupHolding.referrerOf(msg.sender); if (referrer1 != 0x0) { _sendFunds(referrer1, referralBonus); address referrer2 = burnupHolding.referrerOf(referrer1); if (referrer2 != 0x0) { _sendFunds(referrer2, referralBonus); } else { fee = fee.add(referralBonus); } } else { fee = fee.add(referralBonus.mul(2)); } burnupHolding.payBeneficiaries.value(fee)(); gameStates[gameIndex].prizePool = gameStates[gameIndex].prizePool.add(prizePoolFunds); } }",
        "url": 673
    },
    {
        "code_input": "def calcTokenPrice(number_of_tokens, price_per_token):\n    return number_of_tokens * price_per_token",
        "gt": "contract c35289{ function price() public constant returns (uint) { if (stage == Stages.AuctionEnded || stage == Stages.TokensDistributed) { return 0; } return calcTokenPrice(); } }",
        "url": 674
    },
    {
        "code_input": "class C28280:\n    def __init__(self):\n        self.allowance = {}\n\n    def approve(self, _recipient, _amount):\n        if _recipient not in self.allowance:\n            self.allowance[_recipient] = 0\n        self.allowance[_recipient] = _amount\n        return True\n\n    def allowance(self, _spender):\n        if _spender not in self.allowance:\n            return 0\n        return self.allowance[_spender]",
        "gt": "contract c28280{ function approve(address _recipient, uint256 _amount) public returns (bool) { return __approve_impl(msg.sender, _recipient, _amount); } }",
        "url": 675
    },
    {
        "code_input": "class Contract:\n    class State:\n        PreFunding = 0\n        Funding = 1\n\n    def __init__(self):\n        self.state = self.State.PreFunding\n\n    def get_state(self):\n        return self.state\n\n    def set_state(self, state):\n        self.state = state\n\n    def not_finished(self):\n        current_state = self.get_state()\n        if current_state == self.State.PreFunding or current_state == self.State.Funding:\n            return True\n        else:\n            return False\n\n    def modify_not_finished(self, func):\n        if",
        "gt": "contract c10040{ modifier notFinished() { State current_state = getState(); require(current_state == State.PreFunding || current_state == State.Funding); _; } }",
        "url": 676
    },
    {
        "code_input": "class Contract:\n    def __init__(self, owner):\n        self.owner = owner\n\n    def is_owner(self, sender):\n        return sender == self.owner\n\n    def only_owner(self, func):\n        def wrapper(self, *args, **kwargs):\n            if not self.is_owner(msg.sender):\n                print(\"Only the contract owner can call this function.\")\n            else:\n                return func(self, *args, **kwargs)\n        return wrapper\n\n    @only_owner\n    def modify_owner(self, new_owner):\n        self.owner = new_owner\n        print(f\"Owner has been changed to {self.owner}\")\n\n# Usage\ncontract = Contract(\"0x123456789012345678",
        "gt": "contract c10123{ modifier onlyOwner() { require(msg.sender == owner); _; } }",
        "url": 677
    },
    {
        "code_input": "class C18043:\n    def __init__(self, contract_address, web3):\n        self.contract_address = contract_address\n        self.web3 = web3\n        self.contract = self.web3.eth.contract(address=self.contract_address, abi='c18043')\n\n    def transfer_daico(self, to_address):\n        # Get the current timestamp\n        current_time = self.web3.eth.get_block('latest').timestamp\n\n        # Check if the current time is after the Unix timestamp of 2020-01-01\n        if current_time < 153581040",
        "gt": "contract c18043{ function transferDaico(address _to) public onlyOwner returns(bool) { require(now >= 1535810400); balances[vault] = balances[vault].sub(supplyDAICO); balances[_to] = balances[_to].add(supplyDAICO); emit Transfer(vault, _to, supplyDAICO); return(true); } }",
        "url": 678
    },
    {
        "code_input": "The given Solidity code is a contract for a token with a function to set the gas price for the token. The gas price is a measure of the cost of executing a transaction in the blockchain. The gas price is set by the owner of the contract. The owner can set the gas price to a value between 1 and 84000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
        "gt": "contract c22092{ function setGas4Token(uint256 newGasInWei) public onlyOwner { require(newGasInWei > 0 && newGasInWei <= 840000*10**9); gas4Token = newGasInWei; } }",
        "url": 679
    },
    {
        "code_input": "The given Solidity contract is a basic example of an ICO (Initial Coin Offering) smart contract. It allows users to transfer tokens to a predefined address. The main functionality of the contract is as follows:\n\n1. `transferICO(address _to, uint256 _value)`: This function is used to transfer tokens to a predefined address.\n\n2. `require(tokenState == true)`: This line checks if the token state is true. If it's not, the transaction is reverted.\n\n3. `require(_to != address(0))`: This line checks if the recipient address is not the zero address. If it's, the transaction is reverted.\n\n4. `require(_value <= balances[this])`: This line checks if the value to be transferred is less than or equal to the current balance of the contract. If it's not, the transaction is reverted.\n\n5. `require(ico == msg.sender)`: This line checks if the caller of the function is the creator of the ICO. If it's not, the transaction is reverted.",
        "gt": "contract c33260{ function transferICO(address _to, uint256 _value) public returns ( bool ) { require(tokenState == true); require(_to != address(0)); require(_value <= balances[this]); require(ico == msg.sender); balances[this] = sub(balances[this],_value); balances[_to] = add(balances[_to],_value); Transfer(this, _to, _value); return true; } }",
        "url": 680
    },
    {
        "code_input": "The given Solidity code is a contract for a token. It has a function `_transfer` that is used to transfer tokens from the contract to another address. Here's a high-level description of the main functionality and logic of the code:\n\n1. `_transfer` is a function that is internal to the contract. This means it can only be called from within the contract itself.\n\n2. The function takes two parameters: `_to`, which is the address to which the tokens should be transferred, and `_tokens`, which is the number of tokens to transfer.\n\n3. The function first checks that the `_to` address is not zero. If it is, the function returns `false`.\n\n4. It then checks that the contract has enough tokens to cover the transfer. If the contract does not have enough tokens, the function returns `false`.\n\n5. If the transfer is valid, the function subtracts the number of tokens from the contract's balance and adds the number of tokens to the recipient's balance.\n\n6. It then emits a `Transfer` event, which is a standard event in Ethereum that is triggered",
        "gt": "contract c3628{ function _transfer(address _to, uint _tokens) internal returns (bool success){ require(_to != 0x0); require(balances[_to] + _tokens >= balances[_to]); balances[this] = balances[this].sub(_tokens); balances[_to] = balances[_to].add(_tokens); emit Transfer(this,_to,_tokens); return true; } }",
        "url": 681
    },
    {
        "code_input": "def proxy_payment(participant, msg_value, decimals, START_DATE, END_DATE, BONUSONE_DATE, BONUSTWO_DATE, CONTRIBUTIONS_MIN, CONTRIBUTIONS_MAX, TOKENS_HARD_CAP, KYC_THRESHOLD):\n    # Check if the contract is not finalized\n    if not finalised:\n        # Check if the transaction is within the valid time frame\n        if now <= END_DATE:\n            # Check if the transaction value is above a minimum threshold\n            if msg_value > CONTRIBUTIONS_MIN:\n                # Check if the transaction value",
        "gt": "contract c36944{ function proxyPayment(address participant) payable { require(!finalised); require(now <= END_DATE); require(msg.value > CONTRIBUTIONS_MIN); require(CONTRIBUTIONS_MAX == 0 || msg.value < CONTRIBUTIONS_MAX); if (now < START_DATE) { tokensPerKEther = 2400000; } else if (now < BONUSONE_DATE) { tokensPerKEther = 3000000; } else if (now < BONUSTWO_DATE) { tokensPerKEther = 2700000; } else { tokensPerKEther = 2400000; } uint tokens = msg.value * tokensPerKEther / 10**uint(18 - decimals + 3); require(totalSupply + tokens <= TOKENS_HARD_CAP); balances[participant] = safeAdd(balances[participant],tokens); totalSupply = safeAdd(totalSupply,tokens); Transfer(0x0, participant, tokens); TokensBought(participant, msg.value, balances[participant], tokens, totalSupply, tokensPerKEther); if (msg.value > KYC_THRESHOLD) { kycRequired[participant] = true; } wallet.transfer(msg.value); } }",
        "url": 682
    },
    {
        "code_input": "class C20074:\n    def __init__(self, allowed_investors):\n        self.allowed_investors = allowed_investors\n\n    def is_investor_allowed(self, address):\n        return address in self.allowed_investors",
        "gt": "contract c20074{ function isInvestorAllowed(address a) public view returns (bool) { return allowedInvestors[a]; } }",
        "url": 683
    },
    {
        "code_input": "class Contract:\n    def __init__(self, storage, findAdmin, PledgeAdminType):\n        self.storage = storage\n        self.findAdmin = findAdmin\n        self.PledgeAdminType = PledgeAdminType\n\n    def isProjectCanceled(self, projectId):\n        m = self.findAdmin(projectId)\n        if m.adminType == self.PledgeAdminType.Giver:\n            return False\n        assert(m.adminType == self.PledgeAdminType.Project)\n        if m.canceled:\n            return True\n        if m.parentProject == 0:\n            return False\n        return self.isProjectCanceled(m.parentProject)",
        "gt": "contract c30739{ function isProjectCanceled(uint64 projectId) constant returns (bool) { PledgeAdmin storage m = findAdmin(projectId); if (m.adminType == PledgeAdminType.Giver) return false; assert(m.adminType == PledgeAdminType.Project); if (m.canceled) return true; if (m.parentProject == 0) return false; return isProjectCanceled(m.parentProject); } }",
        "url": 684
    },
    {
        "code_input": "class MarketMaker:\n    def __init__(self, mmAddress):\n        self.mmAddress = mmAddress\n\n    def isOpenForPublic(self):\n        # This is a placeholder for the actual method to check if the market maker is open for public\n        # In a real-world scenario, this method would interact with a database or another external system\n        # to check if the market maker is open for public\n        return True\n\nclass MarketMakerContract:\n    def __init__(self, currencyMap):\n        self.currencyMap = currencyMap\n\n    def marketOpen(self, _token):\n        marketMaker = self.getMarketMaker(_token)\n        if marketMaker.isOpenForPublic():\n            return True\n        else:\n            return False\n\n    def getMarketMaker(self, _token):\n        # This is a placeholder",
        "gt": "contract c13000{ modifier marketOpen(address _token) { require(MarketMaker(currencyMap[_token].mmAddress).isOpenForPublic()); _; } }",
        "url": 685
    },
    {
        "code_input": "class Values:\n    def __init__(self, snapshotId, value):\n        self.snapshotId = snapshotId\n        self.value = value\n\nclass Contract:\n    def __init__(self):\n        self.values = []\n\n    def setValue(self, snapshotId, value):\n        if len(self.values) == 0:\n            self.values.append(Values(snapshotId, value))\n            return\n\n        last = self.values[-1]\n        if last.snapshotId < snapshotId:\n            if last.value",
        "gt": "contract c34038{ function setValue( Values[] storage values, uint256 value ) internal { uint256 currentSnapshotId = mCurrentSnapshotId(); bool empty = values.length == 0; if (empty) { values.push( Values({ snapshotId: currentSnapshotId, value: value }) ); return; } uint256 last = values.length - 1; bool hasNewSnapshot = values[last].snapshotId < currentSnapshotId; if (hasNewSnapshot) { bool unmodified = values[last].value == value; if (unmodified) { return; } values.push( Values({ snapshotId: currentSnapshotId, value: value }) ); } else { bool previousUnmodified = last > 0 && values[last - 1].value == value; if (previousUnmodified) { delete values[last]; values.length--; return; } values[last].value = value; } } }",
        "url": 686
    },
    {
        "code_input": "In this contract, the `proxyPayment` function calls the `doPayment` function. The `doPayment` function is declared as `private`, meaning it can only be called from within the contract.\n\nPlease note that the `proxyPayment` function is not actually doing anything with the payment. It's just calling",
        "gt": "contract c39494{ function proxyPayment(address _owner) payable returns(bool) { doPayment(_owner); return true; } }",
        "url": 687
    },
    {
        "code_input": "class Contract:\n    def __init__(self, promises):\n        self.promises = promises\n\n    def can_collect(self, promise_id):\n        promise = self.promises[promise_id]\n        return (promise['state'] == 'confirmed' or promise['state'] == 'pending') and promise['locked_until'] >= block.timestamp",
        "gt": "contract c36171{ function canCollect(uint256 promiseId) constant returns(bool) { return (promises[promiseId].state == PromiseState.confirmed || promises[promiseId].state == PromiseState.pending) && block.timestamp >= promises[promiseId].lockedUntil; } }",
        "url": 688
    },
    {
        "code_input": "class ERC20:\n    def __init__(self, name, symbol, decimals=18):\n        self.name = name\n        self.symbol = symbol\n        self.decimals = decimals\n        self.total_supply = 0\n        self.balances = {}\n\n    def mint(self, account, amount):\n        if account in self.balances:\n            self.balances[account] += amount\n        else:\n            self.balances[account] = amount\n        self.total_supply += amount\n\n    def transfer(self, sender, recipient, amount):\n        if sender in self.balances and self.balances[sender] >= amount:\n            self.balances[sender] -= amount\n            if recipient in self.balances:\n                self.balances[recipient] += amount\n            else:\n                self.bal",
        "gt": "contract c34417{ function mint(address _to, uint _amount) public only(owner) isNotStartedOnly returns(bool) { totalSupply = totalSupply.add(_amount); balances[_to] = balances[_to].add(_amount); Transfer(msg.sender, _to, _amount); return true; } }",
        "url": 689
    },
    {
        "code_input": "class C5612:\n    def __init__(self):\n        self.admin = None\n\n    def set_admin(self, new_admin):\n        self.admin = new_admin\n\n    def is_admin(self, account):\n        return account == self.admin\n\n    def finalize(self, account):\n        if not self.is_admin(account):\n            raise ValueError(\"Only the admin can call finalize\")\n        # Here,",
        "gt": "contract c5612{ function finalize() external onlyAdmin returns (bool) { return finalizeInternal(); } }",
        "url": 690
    },
    {
        "code_input": "The given Solidity code is a contract for a token exchange system. It allows users to withdraw their Ether and ERC20 tokens. Here's a high-level description of the main functionality and logic:\n\n1. The contract has a function `withdraw()`. This function is external, meaning it can be called by anyone, and it's `whenWithdrawalEnabled`, which means it's only enabled when a certain condition is met.\n\n2. Inside the function, the contract first checks if the sender has any Ether or ERC20 tokens. If they do, it sets the sender's Ether and ERC20 tokens to 0.\n\n3. Then, it checks if the sender is whitelisted. If they are, it transfers the ERC20 tokens to the sender.\n\n4. If the sender is not whitelisted, it calculates the amount of ERC20 tokens to transfer based on the sender's Ether balance and the ERC20 balance. The transfer amount is calculated as the Ether balance times a certain threshold, divided by the Ether balance.\n\n5. If the Ether balance is greater than",
        "gt": "contract c562{ function withdraw() external whenWithdrawalEnabled { uint256 ethBalance = ethBalances[msg.sender]; require(ethBalance > 0); uint256 elpBalance = elpBalances[msg.sender]; elpBalances[msg.sender] = 0; ethBalances[msg.sender] = 0; if (isWhitelisted(msg.sender)) { token.transfer(msg.sender, elpBalance); } else { token.transfer(msg.sender, elpBalance.mul(threshold).div(ethBalance)); if (ethBalance > threshold) { msg.sender.transfer(ethBalance - threshold); } } emit Withdrawal(msg.sender, ethBalance, elpBalance); } }",
        "url": 691
    },
    {
        "code_input": "The given Solidity code is a contract for a smart contract that allows users to purchase goods or services. The contract has a function `purchaseFor` that allows a user to purchase goods or services. The function takes two parameters: `identifier` and `benefactor`. The `identifier` is a unique identifier for the purchase, and `benefactor` is the address of the user who is receiving the purchase. The function also takes a `msg.value` which is the amount of Ether sent by the user.\n\nThe function first checks if the `msg.value` is zero, if it is, it reverts the transaction. Then it checks if the `benefactor` address is zero, if it is, it reverts the transaction. After that, it emits an event `PaymentForwarded` with the sender's address, the amount of Ether sent, the identifier, and the benefactor's address.\n\nThe function then updates the `totalTransferred` and `purchaserCount`. It also updates the `paymentsByPurchaser` and `paymentsByBenefactor` arrays.\n\nFinally, the function calls the `multis",
        "gt": "contract c37813{ function purchaseFor(uint128 identifier, address benefactor) public revertIfHalted payable { uint weiAmount = msg.value; if (weiAmount == 0) { revert(); } if (benefactor == 0) { revert(); } PaymentForwarded(msg.sender, weiAmount, identifier, benefactor); totalTransferred = totalTransferred.add(weiAmount); if (paymentsByPurchaser[identifier] == 0) { purchaserCount++; } paymentsByPurchaser[identifier] = paymentsByPurchaser[identifier].add(weiAmount); paymentsByBenefactor[benefactor] = paymentsByBenefactor[benefactor].add(weiAmount); if (!multisig.send(weiAmount)) revert(); } }",
        "url": 692
    },
    {
        "code_input": "def end_tx(self, _pID, _team, _eth, _keys, _eventData):\n    _eventData.compressedData = _eventData.compressedData + (now * 10000",
        "gt": "contract c188{ function endTx(uint256 _pID, uint256 _team, uint256 _eth, uint256 _keys, F3Ddatasets.EventReturns memory _eventData_) private { _eventData_.compressedData = _eventData_.compressedData + (now * 1000000000000000000) + (_team * 100000000000000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID + (rID_ * 10000000000000000000000000000000000000000000000000000); emit F3Devents.onEndTx ( _eventData_.compressedData, _eventData_.compressedIDs, plyr_[_pID].name, msg.sender, _eth, _keys, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.P3DAmount, _eventData_.genAmount, _eventData_.potAmount, airDropPot_ ); } }",
        "url": 693
    },
    {
        "code_input": "class C20074:\n    def __init__(self, web3, account):\n        self.web3 = web3\n        self.account = account\n        self.contract = None\n        self.isMintingFinished = False\n        self.mintingStopDate = None\n\n    def deploy_contract(self):\n        with open(\"C20074.sol\") as f:\n            contract_source = f.read()\n\n        self.contract = self.web3.eth.contract(\n            abi=[],\n            bytecode=contract_source\n        )\n\n        self",
        "gt": "contract c20074{ function finishMinting() external onlyOwner { require(!isMintingFinished); isMintingFinished = true; mintingStopDate = now; emit MintingFinished(); } }",
        "url": 694
    },
    {
        "code_input": "def get_key(x, y):\n    # This is a placeholder for the actual function that calculates the key\n    # It's not provided in the original Solidity code\n    pass\n\ndef get_bonus_balance(bonus_address):\n    # This is a placeholder for the actual function that retrieves the bonus balance\n    # It's not provided in the original Solidity code\n    pass\n\ndef add_bonus_to_block(x, y, bonus, bonus_address):\n    key = get_key(x, y",
        "gt": "contract c26957{ function addBonusToBlock( uint x, uint y, uint bonus ) public onlyPrimary { bytes32 key = getKey(x, y); uint bonusBalance = s.getUInt(keccak256(bonusAddress, \"balance\")); require(bonusBalance >= bonus); s.setUInt(keccak256(key, \"bonus\"), bonus); } }",
        "url": 695
    },
    {
        "code_input": "class C15157:\n    def __init__(self, web3, owner):\n        self.web3 = web3\n        self.owner = owner\n        self.rate = 0\n\n    def set_rate(self, _rate):\n        if _rate > 0:\n            self.rate = _rate\n            return True\n        else:\n            return False",
        "gt": "contract c15157{ function setRate(uint256 _rate) public onlyOwner returns(bool){ require(_rate > 0); rate = _rate; return true; } }",
        "url": 696
    },
    {
        "code_input": "The given Solidity contract is a function that calculates the remaining time until a frozen account's release period ends. The function is named `getRemainReleaseTimeOfStage` and it takes two parameters: an address `_target` and a uint `_num`.\n\nThe function first checks if the `_target` address is not zero. If it is, it returns 0.\n\nThen, it gets the length of the `frozenAccounts` array.\n\nThe function then enters a while loop, which iterates over each element in the `frozenAccounts` array.\n\nIf the current element is equal to `_target`, it fetches the corresponding `timePair` from the `frozenTimes` array.\n\nThe function then checks if the `releasePeriodEndTime` of the `timePair` is less than or equal to the `endTime` of the `timePair`. If it is, the function returns the difference between the `releasePeriodEndTime` and the `endTime`.\n\nIf the `releasePeriodEndTime` is greater than the `endTime`, the function returns 0.\n\nIf the `release",
        "gt": "contract c18618{ function getRemainReleaseTimeOfStage(address _target, uint _num) public view returns (uint256) { require(_target != address(0)); uint256 len = frozenAccounts.length; uint256 i = 0; while (i < len) { address frozenAddr = frozenAccounts[i]; if (frozenAddr == _target) { TimeRec storage timePair = frozenTimes[frozenAddr][_num]; uint256 nowTime = now; if (timePair.releasePeriodEndTime == timePair.endTime || nowTime <= timePair.endTime ) { return (timePair.releasePeriodEndTime.sub(timePair.endTime)); } if (timePair.releasePeriodEndTime < nowTime) { return 0; } return (timePair.releasePeriodEndTime.sub(nowTime)); } i = i.add(1); } return 0; } }",
        "url": 697
    },
    {
        "code_input": "def PayTokens(sender, tokenAmount, now):\n    # This is a placeholder for the actual implementation of the token transfer\n    # It would depend on the specific implementation of the token contract\n    pass",
        "gt": "contract c38774{ function payTokens() internal { require(balances[msg.sender]>0); uint tokenAmount = checkTokBalance(msg.sender); balances[msg.sender] = 0; Token.transfer(msg.sender,tokenAmount); PayTokens(msg.sender,tokenAmount,now); } }",
        "url": 698
    },
    {
        "code_input": "class TokenContract:\n    def __init__(self, contract_address, abi):\n        self.contract_address = contract_address\n        self.abi = abi\n        self.contract = self.get_contract()\n\n    def get_contract(self):\n        contract = web3.eth.contract(address=self.contract_address, abi=self.abi)\n        return contract\n\n    def transfer_ownership(self, new_owner):\n        if new_owner != '0x0':\n            self.contract.functions.transferOwnership(new_owner).transact()\n        else:\n            raise ValueError(\"new_owner must not be 0x0\")",
        "gt": "contract c15157{ function transferTokenOwnership(address newOwner) external onlyOwner { require(newOwner != 0x0); UAPToken(token).transferOwnership(newOwner); } }",
        "url": 699
    },
    {
        "code_input": "class TokenContract:\n    def __init__(self, owner, is_admin, is_ops):\n        self.owner = owner\n        self.is_admin = is_admin\n        self.is_ops = is_ops\n        self.revoke_address = None\n\n    def set_revoke_address(self, new_address):\n        if new_address == self.owner:\n            return False\n        if self.is_admin(new_address):\n            return False\n        if self.is_ops(new_address):\n            return False\n        self.revoke_address = new_address\n        self.revoke_address_changed(new_address)\n        return True\n\n    def is_owner_or_revoke",
        "gt": "contract c33863{ function setRevokeAddress(address _revokeAddress) external onlyOwnerOrRevoke returns (bool) { require(_revokeAddress != owner); require(!isAdmin(_revokeAddress)); require(!isOps(_revokeAddress)); revokeAddress = _revokeAddress; RevokeAddressChanged(_revokeAddress); return true; } }",
        "url": 700
    },
    {
        "code_input": "class C1756:\n    def __init__(self):\n        self.ZethrMainBankroll = None\n\n    def set_bankroll(self, bankroll_address):\n        if not self.is_dev_or_bankroll():\n            raise Exception(\"Only dev or bankroll can set bankroll\")\n        self.ZethrMainBankroll = bankroll_address\n\n    def is_dev_or_bankroll(self):\n        # This is a placeholder for the actual function that checks if the caller is a dev or bankroll.\n        # In a real-world scenario, this function would need to interact with a database or other persistent storage.\n        return True",
        "gt": "contract c1756{ function setBankroll(address bankrollAddress) public onlyDevOrBankroll() { ZethrMainBankroll = bankrollAddress; } }",
        "url": 701
    },
    {
        "code_input": "from datetime import datetime\n\nclass PreSale:\n    def __init__(self, preSaleEnd):\n        self.preSaleEnd = preSaleEnd\n        self.enablePreSale = True\n\n    def isPreSale(self):\n        now = datetime.now()\n        result = (now >= self.preSaleEnd)\n        if self.enablePreSale:\n            return True\n        else:\n            return result",
        "gt": "contract c29902{ function isPreSale() constant public returns (bool preSale) { bool result=(preSaleEnd >= now); if(enablePreSale){ return true; } else{ return result; } } }",
        "url": 702
    },
    {
        "code_input": "class Sale:\n    def __init__(self):\n        self.saleClosed = True\n\n    def openSale(self, onlyDirector):\n        if onlyDirector:\n            if self.saleClosed:\n                self.saleClosed = False\n                return True\n        return False",
        "gt": "contract c25412{ function openSale() public onlyDirector returns (bool success) { require(saleClosed); saleClosed = false; return true; } }",
        "url": 703
    },
    {
        "code_input": "class C25035:\n    def __init__(self, web3, address):\n        self.web3 = web3\n        self.address = address\n        self.contract = None\n\n    def create_clone_token(self, snapshot_block, name, symbol):\n        if snapshot_block == 0:\n            snapshot_block = self.web3.eth.blockNumber\n        if snapshot_block > self.web3.eth.blockNumber:\n            snapshot_block = self.web3.eth.blockNumber\n        clone_token = self.contract.functions.createCloneToken(snapshot_block, name, symbol).call()\n        clone_token.transferControl(msg.sender)\n        return clone_token",
        "gt": "contract c25035{ function createCloneToken(uint256 _snapshotBlock, string _name, string _symbol) public returns(address) { if (_snapshotBlock == 0) { _snapshotBlock = block.number; } if (_snapshotBlock > block.number) { _snapshotBlock = block.number; } ServusToken cloneToken = tokenFactory.createCloneToken( this, _snapshotBlock, _name, _symbol ); cloneToken.transferControl(msg.sender); NewCloneToken(address(cloneToken)); return address(cloneToken); } }",
        "url": 704
    },
    {
        "code_input": "from web3 import Web3, HTTPProvider\n\n# Connect to the Ethereum node\nw3 = Web3(HTTPProvider('http://localhost:8545'))\n\n# The address of the contract\ncontract_address = '0x...'\n\n# The ABI of the contract\ncontract_abi = '...'\n\n# The contract instance\ncontract = w3.eth.contract(address=contract_address, abi=contract_abi)\n\n# The owner of the contract\nowner = '0x...'\n\n# The only function that the owner can call\n@w3.eth.contract(address",
        "gt": "contract c14558{ function kill() public onlyOwner { require(now >= canSelfDestruct); uint256 balance = REB.balanceOf(this); if (balance > 0) { REB.transfer(msg.sender, balance); } selfdestruct(owner); } }",
        "url": 705
    },
    {
        "code_input": "The given Solidity code is a function that claims a token reserve from a user. The function is named `claimTokenReserveEcon` and it is only accessible to the `onlyTokenReserveEcon` role. The function is locked, meaning it can only be called by the `onlyTokenReserveEcon` role.\n\nThe function first checks if the current timestamp is greater than the time lock for the user. If it is, it calculates the vesting stage and the total unlocked amount.\n\nIf the vesting stage is less than or equal to 72, the total unlocked amount is calculated as the product of the vesting stage and 1200000 * (10 ** 8).\n\nIf the vesting stage is greater than 72, the total unlocked amount is calculated as the product of the difference between the vesting stage and 72 and 200000 * (10 ** 8), plus 86400000 * (10 ** 8).\n\nThe function then checks if the total unlocked amount is less than or equal to the allocation for the `econReserveWallet`.",
        "gt": "contract c11457{ function claimTokenReserveEcon() onlyTokenReserveEcon locked public { address reserveWallet = msg.sender; require(block.timestamp > timeLocks[reserveWallet]); uint256 vestingStage = econVestingStage(); uint256 totalUnlocked; if (vestingStage <= 72) { totalUnlocked = vestingStage.mul(1200000 * (10 ** 8)); } else { totalUnlocked = ((vestingStage.sub(72)).mul(200000 * (10 ** 8))).add(86400000 * (10 ** 8)); } require(totalUnlocked <= allocations[econReserveWallet]); require(claimed[econReserveWallet] < totalUnlocked); uint256 payment = totalUnlocked.sub(claimed[econReserveWallet]); claimed[econReserveWallet] = totalUnlocked; require(token.transfer(reserveWallet, payment)); Distributed(reserveWallet, payment); } }",
        "url": 706
    },
    {
        "code_input": "class C33960:\n    def __init__(self, creator, stage):\n        self.creator = creator\n        self.stage = stage\n\n    def withdraw(self):\n        if self.stage != 'Ended':\n            raise Exception('Stage is not yet ended')\n\n        if not self.creator.send(self.balance):\n            raise Exception('Failed to send ETH')\n\n# Usage\n# Creator is the address of the account that will be able to withdraw\n# Stage is a string that represents the current stage of the task\ncreator = '0x...'\nstage = 'Ended'\n\nc33960 = C33960(creator, stage)\nc33960.withdraw()",
        "gt": "contract c33960{ function withdraw() onlyCreator { uint256 ethBalance = this.balance; if (stage != Stages.Ended) { throw; } if (!creator.send(ethBalance)) { throw; } } }",
        "url": 707
    },
    {
        "code_input": "class C2013:\n    def __init__(self, oracle_price_decimals_factor, decimal_precission_difference_factor):\n        self.oracle_price_decimals_factor = oracle_price_decimals_factor\n        self.decimal_precission_difference_factor = decimal_precission_difference_factor\n\n    def convert_valuation_to_art(self, valuation, art_price):\n        # Calculate the amount of ART that can be created from the given valuation and the price of one ART\n        amount = (valuation * self.oracle_price_decimals_factor) / art_price",
        "gt": "contract c2013{ function convert_valuation_to_art(uint _valuation, uint _art_price) view public returns(uint amount){ amount = (( _valuation.mul(oracle_price_decimals_factor) ).div( _art_price )).mul(decimal_precission_difference_factor); } }",
        "url": 708
    },
    {
        "code_input": "class DApp:\n    def __init__(self, id, owner):\n        self.id = id\n        self.owner = owner\n\nclass C40102:\n    def __init__(self):\n        self.dapps = {}\n\n    def get(self, _id):\n        d = self.dapps.get(_id)\n        if d:\n            return d.id, d.owner\n        else:\n            return None, None",
        "gt": "contract c40102{ function get(bytes32 _id) constant returns (bytes32 id, address owner) { Dapp d = dapps[_id]; id = d.id; owner = d.owner; } }",
        "url": 709
    },
    {
        "code_input": "class C803:\n    def __init__(self, cardArray, destroyCardCount):\n        self.cardArray = cardArray\n        self.destroyCardCount = destroyCardCount\n\n    def totalSupply(self):\n        return len(self.cardArray) - self.destroyCardCount - 1\n\n# Example usage:\ncardArray = [1, 2, 3, 4, 5]\ndestroyCardCount = 2\nc803_instance = C803(cardArray, destroyCardCount)\nprint(c803_instance.totalSupply())  # Output: 3",
        "gt": "contract c803{ function totalSupply() external view returns (uint256) { return cardArray.length - destroyCardCount - 1; } }",
        "url": 710
    },
    {
        "code_input": "class Kingdom:\n    def __init__(self):\n        self.initiatet = False\n        self.resources = [0]*5\n        self.mapX = 6\n        self.mapY = 6\n        self.cities = 0\n\n    def initiate_user(self, user):\n        if not self.initiatet:\n            self.initiatet = True\n            self.resources = [5]*5\n            self.mapX = 6\n            self.mapY = 6\n            self.cities += 1\n            self.log_resources()\n\nkingdom = Kingdom()\nkingdom.initiate_user('user')",
        "gt": "contract c22899{ function initiateUser() public { if(!kingdoms[msg.sender].initiatet){ kingdoms[msg.sender].initiatet = true; kingdoms[msg.sender].resources[0] = 5; kingdoms[msg.sender].resources[1] = 5; kingdoms[msg.sender].resources[2] = 5; kingdoms[msg.sender].resources[3] = 5; kingdoms[msg.sender].resources[4] = 5; kingdoms[msg.sender].mapX = 6; kingdoms[msg.sender].mapY = 6; totalCities += 1; logResources(); } } }",
        "url": 711
    },
    {
        "code_input": "from web3 import Web3, HTTPProvider\n\n# Connect to the Ethereum node\nw3 = Web3(HTTPProvider('http://localhost:8545'))\n\n# The address of the contract\ncontract_address = '0x81BE91c7E74Ad",
        "gt": "contract c24886{ function swapProxyTokens() public { ERC20Token oldToken = ERC20Token(0x81BE91c7E74Ad0957B4156F782263e7B0B88cF7b); uint256 oldTokenBalance = oldToken.balanceOf(msg.sender); require(oldTokenBalance > 0); if(oldToken.transferFrom(msg.sender, issuingTokenOwner, oldTokenBalance)) { require(oldToken.balanceOf(msg.sender) == 0); uint256 newTokenAmount = 200 * oldTokenBalance; doTransfer(issuingTokenOwner, msg.sender, newTokenAmount); SwappedTokens(msg.sender, oldTokenBalance, newTokenAmount); } } }",
        "url": 712
    },
    {
        "code_input": "The given Solidity code is a function that allows a user to buy tokens from a seller. Here's a high-level description of the function:\n\n1. The function `_buyTokensFromSeller` takes an argument `_tokenCountToBuy`, which is the number of tokens to be bought.\n2. It first checks if `_tokenCountToBuy` is greater than 0.\n3. It then retrieves the current token price and commission from the `lotteries` array and the `lotteryCount`.\n4. It calculates the purchase price by subtracting the commission from the current token price.\n5. It calculates the number of tokens left to buy.\n6. It then iterates over the `sellingAmounts` and `sellingAddresses` arrays in the `lottery` contract.\n7. For each non-zero selling amount and non-zero selling address, it substitutes the tokens for the number of tokens to be bought.\n8. It then deducts the number of tokens from the `ownerTokenCount` and `ownerTokenCountToSell` arrays.\n9. It calculates the total purchase price and ded",
        "gt": "contract c1289{ function _buyTokensFromSeller(uint _tokenCountToBuy) internal { require(_tokenCountToBuy > 0); Lottery storage lottery = lotteries[lotteryCount - 1]; uint currentTokenPrice = _getCurrentTokenPrice(); uint currentCommissionSum = _getValuePartByPercent(currentTokenPrice, lottery.params.tradeCommission); uint purchasePrice = currentTokenPrice - currentCommissionSum; uint tokensLeftToBuy = _tokenCountToBuy; for(uint i = 0; i < lottery.sellingAmounts.length; i++) { if(lottery.sellingAmounts[i] != 0 && lottery.sellingAddresses[i] != msg.sender) { address oldOwner = lottery.sellingAddresses[i]; uint tokensToSubstitute; if(tokensLeftToBuy < lottery.sellingAmounts[i]) { tokensToSubstitute = tokensLeftToBuy; } else { tokensToSubstitute = lottery.sellingAmounts[i]; } lottery.sellingAmounts[i] -= tokensToSubstitute; lottery.ownerTokenCount[oldOwner] -= tokensToSubstitute; lottery.ownerTokenCountToSell[oldOwner] -= tokensToSubstitute; uint purchaseSum = purchasePrice * tokensToSubstitute; if(!oldOwner.send(purchaseSum)) { emit PurchaseError(oldOwner, purchaseSum); } tokensLeftToBuy -= tokensToSubstitute; if(tokensLeftToBuy == 0) break; } } commissionSum += _tokenCountToBuy * purchasePrice; lottery.ownerTokenCount[msg.sender] += _tokenCountToBuy; lottery.tokenCountToSell -= _tokenCountToBuy; } }",
        "url": 713
    },
    {
        "code_input": "class Contract:\n    def __init__(self, web3, address):\n        self.web3 = web3\n        self.address = address\n\n    def set_price(self, new_price):\n        # The transaction hash that was sent with the web3.eth.account.signTransaction\n        # method to sign the transaction.\n        transaction_hash = None\n\n        # The transaction object, which is used to send the transaction\n        # to the network.\n        transaction = None\n\n        # The receipt of the transaction once it's been mined\n        # by the network.\n        receipt = None\n\n        # The contract's abi, which is used to call the contract's\n        # functions.\n        abi = None\n\n        # The contract's bytecode, which is used to deploy the\n        # contract.",
        "gt": "contract c17363{ function setPrice(uint _newprice) onlyOwner{ price=_newprice; } }",
        "url": 714
    },
    {
        "code_input": "class C25871:\n    def __init__(self):\n        self.isAdmin = {}\n        self.admins = []\n\n    def removeAdmin(self, admin):\n        if admin in self.isAdmin:\n            del self.isAdmin[admin]\n\n        if admin in self.admins:\n            self.admins.remove(admin)\n            self.AdminRemoval(admin)\n\n    def adminExists(self, admin):\n        return admin in self.isAdmin\n\n    def AdminRemoval(self, admin):\n        print(f\"Admin {admin} has been removed.\")",
        "gt": "contract c25871{ function removeAdmin(address admin) internal adminExists(admin) { isAdmin[admin] = false; for (uint i=0; i<admins.length - 1; i++) if (admins[i] == admin) { admins[i] = admins[admins.length - 1]; break; } admins.length -= 1; AdminRemoval(admin); } }",
        "url": 715
    },
    {
        "code_input": "class Contract:\n    def __init__(self, creator):\n        self.creator = creator\n        self.is_verified = False\n\n    def picops_is_verified(self, toggle):\n        if msg.sender == self.creator:\n            self.is_verified = toggle\n        else:\n            raise ValueError(\"Only the contract creator can verify the contract.\")",
        "gt": "contract c32100{ function picops_is_verified(bool toggle) { require(msg.sender == creator); is_verified = toggle; } }",
        "url": 716
    },
    {
        "code_input": "class C31740:\n    def __init__(self, owner):\n        self.owner = owner\n\n    def only_owner(self, func):\n        def wrapper(self, *args, **kwargs):\n            if self.owner != msg.sender:\n                revert(\"Only the contract owner can call this function.\")\n            return func(self, *args, **kwargs)\n        return wrapper\n\n    @only_owner\n    def set_owner(self, new_owner):\n        if new_owner != msg.sender:\n            revert(\"",
        "gt": "contract c31740{ modifier onlyOwner { require(msg.sender == owner); _; } }",
        "url": 717
    },
    {
        "code_input": "class TokenContract:\n    def __init__(self, _totalSupply):\n        self._totalSupply = _totalSupply\n\n    def totalSupply(self):\n        return self._totalSupply\n\n# Demonstrate the main logic of the function\ncontract = TokenContract(1000)\nprint(contract.totalSupply())  # Output: 1000",
        "gt": "contract c14121{ function totalSupply() constant returns (uint supply){ return _totalSupply; } }",
        "url": 718
    },
    {
        "code_input": "class TokenContract:\n    def __init__(self, contract_address, abi):\n        self.contract_address = contract_address\n        self.abi = abi\n        self.contract = self.get_contract()\n\n    def get_contract(self):\n        contract = self.contract_address\n        return w3.eth.contract(address=contract, abi=self.abi)\n\n    def get_token_type(self, token_address):\n        token_type = self.contract.functions.token_type(token_address).call()\n        return token_type",
        "gt": "contract c2280{ function getTokenType(address _token) public view returns(uint){ return(token_type[_token]); } }",
        "url": 719
    },
    {
        "code_input": "class Company:\n    def __init__(self):\n        self.shareHolders = {}\n\n    def add_share_holder(self, owner, shares):\n        self.shareHolders[owner] = shares\n\n    def verify_ownership_of_tokens(self, company_id, owner, amount):\n        if company_id in self.shareHolders and owner in self.shareHolders[company",
        "gt": "contract c17341{ function _verifyOwnershipOfTokens(uint _companyId, address _owner, uint _amount) view internal { require(companies[_companyId].shareHolders.ownerAddressToShares[_owner] >= _amount); } }",
        "url": 720
    },
    {
        "code_input": "import time\n\nclass PreSale:\n    def __init__(self, start_time, end_time):\n        self.start_time = start_time\n        self.end_time = end_time\n\n    def is_pre_sale_active(self):\n        current_time = time.time()\n        if self.start_time <= current_time <= self.end_time:\n            return True\n        else:\n            return False\n\n# Example usage:\npre_sale = PreSale(start_time=1610000000, end_time=1611000000)\nprint(pre_sale.is_pre_sale_active())  # Output: True",
        "gt": "contract c30119{ modifier preSaleActive() { require(now >= startTime); require(now <= endTime); _; } }",
        "url": 721
    },
    {
        "code_input": "The given Solidity code is a contract for a token with a function `burn`. This function allows a user to burn their own tokens. Here's a high-level description of the main functionality and logic of the code:\n\n1. The contract is named `c36862`.\n\n2. The function `burn` is declared. It is a public function that takes one argument, `_value`, which is of type `uint256`.\n\n3. The function is only allowed to be called by the owner of the contract.\n\n4. The function requires that the sender has enough balance to burn (`balances[msg.sender] >= _value`).\n\n5. The function requires that the value to be burned is greater than 0 (`_value > 0`).\n\n6. The function subtracts the value from the sender's balance and the total supply, and increments the total burned value.\n\n7. The function then transfers the tokens to the address `0x0`, effectively burning the tokens.\n\n8. The function returns `true`, indicating that the operation was successful.\n\nHere's a",
        "gt": "contract c36862{ function burn(uint256 _value) onlyOwner returns (bool) { require(balances[msg.sender] >= _value); require(_value > 0); balances[msg.sender] -= _value; _totalSupply -= _value; _totalBurnt += _value; Transfer(msg.sender, 0x0, _value); return true; } }",
        "url": 722
    },
    {
        "code_input": "class C19021:\n    def __init__(self):\n        self.dapps = {}\n\n    def grantDApp(self, dapp_id, dapp):\n        self.dapps[dapp_id] = dapp\n\n    def _invest(self, ethAddress, ethWEI):\n        # This is a placeholder for the actual function that will be implemented in the DApp.\n        # The actual implementation will depend on the specifics of the DApp.\n        # For now, we'll just print a message.\n        print(f\"Investing {ethWEI} Wei from {ethAddress}\")\n\n# Example usage:",
        "gt": "contract c19021{ function investWithBitcoin(address ethAddress, uint256 ethWEI) public grantDApp { _invest(ethAddress,ethWEI); } }",
        "url": 723
    },
    {
        "code_input": "import datetime\n\nclass TokenVesting:\n    def __init__(self, vesting_start_day, vesting_days, vesting_amt):\n        self.vesting_start_day = vesting_start_day\n        self.vesting_days = vesting_days\n        self.vesting_amt = vesting_amt\n\n    def tokens_vested(self):\n        today = datetime.date.today()\n        days_elapsed = (today - self.vesting_start_day).days\n\n        if days_elapsed >= self.vesting_days:\n            return self.vesting_amt\n        else:\n            return (self.vesting_amt * days_elapsed) / self.vesting_days\n\n# Usage\nvesting",
        "gt": "contract c14995{ function tokensVested() public view returns (uint) { uint _daysElapsed = _today() - vestingStartDay; return _daysElapsed >= vestingDays ? vestingAmt : (vestingAmt * _daysElapsed) / vestingDays; } }",
        "url": 724
    },
    {
        "code_input": "class Token:\n    def __init__(self, owner, price):\n        self.owner = owner\n        self.price = price\n\n    def set_price(self, new_price):\n        if new_price > self.price:\n            self.price = new_price\n        else:\n            raise ValueError(\"New price must be greater than the current price\")",
        "gt": "contract c3596{ function setPrice(uint _newprice) onlyOwner{ require(_newprice > price); price=_newprice; } }",
        "url": 725
    },
    {
        "code_input": "def check_expiration(i, nums):\n    # Check if the current time is less than or equal to the sum of the 7th element of the 6th element of the nums array and the expireDelay\n    if now <= nums[6*i+7] + expireDelay:\n        return True\n    else:\n        return False",
        "gt": "contract c19690{ function checkExpiration( uint _i, uint[] _nums ) private view { require(now <= _nums[6*_i+7] + expireDelay); } }",
        "url": 726
    },
    {
        "code_input": "class TokenMintingContract:\n    def __init__(self, contract_instance):\n        self.contract_instance = contract_instance\n\n    def claim(self, sender):\n        # Check if the sender has any rejected mint balance\n        if self.contract_instance.rejectedMintBalance[sender] > 0:\n            # Get the balance of the sender\n            value = self.contract_instance.rejectedMintBalance[sender]\n            # Set the balance of the sender to 0\n            self.contract_instance.rejectedMintBalance[sender] = 0\n            # Transfer the balance to the sender\n            self.contract_instance.transfer(sender, value)\n            # Emit the",
        "gt": "contract c959{ function claim() external { require(rejectedMintBalance[msg.sender] > 0); uint256 value = rejectedMintBalance[msg.sender]; rejectedMintBalance[msg.sender] = 0; msg.sender.transfer(value); emit Claimed(msg.sender, value); } }",
        "url": 727
    },
    {
        "code_input": "class TokenTransfer:\n    def __init__(self, contract):\n        self.contract = contract\n\n    def transfer_tokens(self, from_address, to_address, token, tokens):\n        # Get the current balance of the sender\n        sender_balance = self.contract.functions.balanceOf(from_address, token).call()\n\n        # Check if the sender has enough tokens\n        if sender_balance < tokens:\n            raise ValueError(f\"Insufficient tokens in {from_address}\")\n\n        # Subtract the tokens from the sender's balance\n        self.contract.functions.subtractTokens(from_address, token, tokens).transact()\n\n        # Get the current balance of the receiver\n        receiver_balance = self.contract.functions.balanceOf(to_address, token).call()\n\n        # Add the tokens to the receiver's balance\n        self.contract.functions.addTokens(to_",
        "gt": "contract c10018{ function transferTokensFrom( address from, address to,address token, uint tokens) public returns (bool success) { balances[token][from] = balances[token][from].sub(tokens); allowed[token][from][to] = allowed[token][from][to].sub(tokens); balances[token][to] = balances[token][to].add(tokens); Transfer(token, from, to, tokens); return true; } }",
        "url": 728
    },
    {
        "code_input": "The given Solidity contract is a function that handles payments. The function `handlePayment` takes in four parameters:\n\n- `_beneficiary`: The address of the beneficiary.\n- `_amount`: The amount of the payment.\n- `_time`: The timestamp of the payment.\n- `_whitelistSign`: The signature of the whitelist.\n\nThe function first checks if the beneficiary address is not zero. If it is, the function calls the `handleContribution` function, which is a function that handles the contribution of the payment.\n\nThe `handleContribution` function takes in four parameters:\n\n- `_beneficiary`: The address of the beneficiary.\n- `_amount`: The amount of the payment.\n- `_time`: The timestamp of the payment.\n- `_whitelistSign`: The signature of the whitelist.\n\nThe function calculates the amount of the contribution, which is the amount of the payment minus the amount of the whitelist.\n\nThe function then calls the `forwardFunds` function, which is a function",
        "gt": "contract c20538{ function handlePayment(address _beneficiary, uint256 _amount, uint256 _time, bytes memory _whitelistSign) internal { require(_beneficiary != address(0)); uint256 weiAmount = handleContribution(_beneficiary, _amount, _time, _whitelistSign); forwardFunds(weiAmount); uint256 refund = _amount.sub(weiAmount); if (refund > 0) { _beneficiary.transfer(refund); } } }",
        "url": 729
    },
    {
        "code_input": "class C10276:\n    def __init__(self, contract_address, owner_address, web3):\n        self.contract_address = contract_address\n        self.owner_address = owner_address\n        self.web3 = web3\n        self.contract = self.web3.eth.contract(address=self.contract_address, abi=self.get_abi())\n\n    def get_abi(self):\n        # This function is used to get the ABI of the contract.\n        # The ABI is the Application Binary Interface of the contract.\n        # It describes the methods that the contract implements.\n        return [\n            {\n                \"constant\": True,\n                \"inputs\": [],",
        "gt": "contract c10276{ function transfer(address to, uint256 value) public activated returns (bool) { return super.transfer(to, value); } }",
        "url": 730
    },
    {
        "code_input": "def fpMul(x, y):\n    xh = x >> 128\n    xl = x & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n    yh = y >> 128\n    yl = y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n    result = xh * yh\n    if result <= (0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF << 128):\n        result <<= 128\n        result += xh * yl\n        result += xl * yh\n        result += (xl * yl) >> 128\n    return result",
        "gt": "contract c21154{ function fpMul (uint256 x, uint256 y) pure internal returns (uint256) { uint256 xh = x >> 128; uint256 xl = x & TWO128_1; uint256 yh = y >> 128; uint256 yl = y & TWO128_1; uint256 result = xh * yh; require (result <= TWO128_1); result <<= 128; result = safeAdd (result, xh * yl); result = safeAdd (result, xl * yh); result = safeAdd (result, (xl * yl) >> 128); return result; } }",
        "url": 731
    },
    {
        "code_input": "The given Solidity code is a contract for an ICO (Initial Coin Offering) platform. It includes a function `icoCheckup()` that checks the status of the ICO and performs certain actions based on the status.\n\nHere's a high-level description of the main functionality and logic of the code:\n\n1. The `icoCheckup()` function is declared as public, meaning it can be called by anyone.\n\n2. The function first checks if the caller of the function is not the contract owner or the developers. If either of these conditions is true, it throws an exception.\n\n3. It then initializes two variables: `nmsgmask` and `ntmp`.\n\n4. If the ICO is in the \"saleClosed\" status, the function checks if the number of tokens purchased is greater than or equal to the minimum ICO token goal and if the remuneration stage is 0. If these conditions are met, it sets the remuneration stage to 1 and calculates the remuneration balance.\n\n5. If the ICO is in the \"succeeded\" status, the function checks if the rem",
        "gt": "contract c38932{ function icoCheckup() public { if (msg.sender != owner && msg.sender != developers) throw; uint nmsgmask; if (icoStatus == IcoStatusValue.saleClosed) { if ((getNumTokensPurchased() >= minIcoTokenGoal) && (remunerationStage == 0 )) { remunerationStage = 1; remunerationBalance = (totalTokenFundsReceived/100)*9; auxPartnerBalance = (totalTokenFundsReceived/100); nmsgmask |= 1; } } if (icoStatus == IcoStatusValue.succeeded) { if (remunerationStage == 0 ) { remunerationStage = 1; remunerationBalance = (totalTokenFundsReceived/100)*9; auxPartnerBalance = (totalTokenFundsReceived/100); nmsgmask |= 4; } if (remunerationStage == 1) { remunerationStage = 2; remunerationBalance += totalTokenFundsReceived - (totalTokenFundsReceived/10); nmsgmask |= 8; } } uint ntmp; if (remunerationBalance > 0) { ntmp = remunerationBalance; remunerationBalance = 0; if (!founderOrg.call.gas(rmGas).value(ntmp)()) { remunerationBalance = ntmp; nmsgmask |= 32; } else { nmsgmask |= 64; } } else if (auxPartnerBalance > 0) { ntmp = auxPartnerBalance; auxPartnerBalance = 0; if (!auxPartner.call.gas(rmGas).value(ntmp)()) { auxPartnerBalance = ntmp; nmsgmask |= 128; } else { nmsgmask |= 256; } } StatEventI(\"ico-checkup\", nmsgmask); } }",
        "url": 732
    },
    {
        "code_input": "def _removeBid(self, bidId",
        "gt": "contract c4924{ function _removeBid(uint bidId) internal { Bid memory thisBid = bids[ bidId ]; bids[ thisBid.prev ].next = thisBid.next; bids[ thisBid.next ].prev = thisBid.prev; delete bids[ bidId ]; delete contributors[ msg.sender ]; } }",
        "url": 733
    },
    {
        "code_input": "class C13202:\n    def __init__(self, web3, owner, contract_address):\n        self.web3 = web3\n        self.owner = owner\n        self.contract_address = contract_address\n        self.imageHash = None\n\n    def setImage(self, IPFSImageHash):\n        # Check if the caller is the owner\n        if self.web3.eth.accounts[0] != self.owner:\n            raise ValueError(\"Only the contract owner can set the image.\")\n\n        # Set the image hash\n        self.imageHash = IPFSImageHash\n\n        # Record the event\n        self.majorEventFunc(self.web3.eth.blockNumber, \"Entered Marriage Image\", \"Image is in IPFS\")",
        "gt": "contract c13202{ function setImage(bytes IPFSImageHash) onlyOwner public { imageHash = IPFSImageHash; majorEventFunc(block.timestamp, \"Entered Marriage Image\", \"Image is in IPFS\"); } }",
        "url": 734
    },
    {
        "code_input": "class Vault:\n    def __init__(self, min_funding_goal):\n        self.min_funding_goal = min_funding_goal\n        self.is_closed = False\n\n    def min_funding_goal_reached(self):\n        return self.min_funding_goal <= self.total_funding_received()\n\n    def total_funding_received(self):\n        # This is a placeholder for the actual function that calculates the total funding received\n        # For simplicity, we'll return a fixed value\n        return 1000000\n\n    def close(self):\n        self.is_closed = True\n\n    def enable_refunds(self):\n        self.is_closed = False",
        "gt": "contract c36550{ function finalization() internal { if (minFundingGoalReached()) { vault.close(); } else { vault.enableRefunds(); } } }",
        "url": 735
    },
    {
        "code_input": "class C35011:\n    def __init__(self):\n        self.tradingStarted = False\n\n    def startTrading(self, _startStop):\n        self.tradingStarted = _startStop",
        "gt": "contract c35011{ function startTrading(bool _startStop) public onlyOwner { tradingStarted = _startStop; } }",
        "url": 736
    },
    {
        "code_input": "class GameContract:\n    def __init__(self, creator):\n        self.creator = creator\n        self.game = None\n        self.boxMax = None\n\n    def update(self, _option, _newNo, _newAddress):\n        if _option == 1:\n            if _newNo <= 0:\n                raise ValueError(\"_newNo must be greater than 0\")\n            self.boxMax = _newNo\n            return \"boxMax Updated\", self.boxMax\n        elif _option == 2:\n            self.game = _newAddress\n            return \"Game Smart Contract Updated\", 1\n        else:\n            raise ValueError(\"Invalid option\")",
        "gt": "contract c30395{ function update(uint _option, uint _newNo, address _newAddress) public returns (string, uint) { require(msg.sender == creator || msg.sender == game); if (_option == 1) { require(_newNo > 0); boxMax = _newNo; return (\"boxMax Updated\", boxMax); } if (_option == 2) { game = _newAddress; return (\"Game Smart Contract Updated\", 1); } } }",
        "url": 737
    },
    {
        "code_input": "The given Solidity code is a contract for a market maker. The contract has a function `buy` that is used to buy outcomes. The function takes in three parameters: `outcomeTokenIndex`, `outcomeTokenCount`, and `maxCost`.\n\nHere's a high-level description of the function's main logic:\n\n1. It first calculates the cost of the outcome tokens by calling the `calcCost` function of the `marketMaker` contract.\n2. It then calculates the fees by calling the `calcMarketFee` function.\n3. The total cost is calculated by adding the outcome token cost and the fees.\n4. The function checks that the cost is greater than 0 and less than or equal to the `maxCost`.\n5. It then transfers the outcome tokens from the sender's account to the contract's address and approves the contract to transfer the outcome tokens.\n6. It emits an event indicating that all outcomes have been bought.\n7. It then transfers the bought outcome tokens from the contract's address to the sender's account.\n8. It checks that the number of bought outcome",
        "gt": "contract c31167{ function buy(uint8 outcomeTokenIndex, uint outcomeTokenCount, uint maxCost) public atStage(Stages.MarketFunded) returns (uint cost) { uint outcomeTokenCost = marketMaker.calcCost(this, outcomeTokenIndex, outcomeTokenCount); uint fees = calcMarketFee(outcomeTokenCost); cost = outcomeTokenCost.add(fees); require(cost > 0 && cost <= maxCost); require( eventContract.collateralToken().transferFrom(msg.sender, this, cost) && eventContract.collateralToken().approve(eventContract, outcomeTokenCost)); eventContract.buyAllOutcomes(outcomeTokenCost); require(eventContract.outcomeTokens(outcomeTokenIndex).transfer(msg.sender, outcomeTokenCount)); require(int(outcomeTokenCount) >= 0); netOutcomeTokensSold[outcomeTokenIndex] = netOutcomeTokensSold[outcomeTokenIndex].add(int(outcomeTokenCount)); OutcomeTokenPurchase(msg.sender, outcomeTokenIndex, outcomeTokenCount, outcomeTokenCost, fees); } }",
        "url": 738
    },
    {
        "code_input": "The given Solidity contract is a function that handles withdrawal of funds from a smart contract. Here's a high-level description of the main functionality and logic:\n\n1. The contract is set to be in a stage of 3, which means it's in the process of finalizing the withdrawal process.\n\n2. It then checks if the `receiver` address is in the `whitelist` array. If it's not, it throws an error.\n\n3. If the `tokenAddr` is 0x00 (which is the default value for an address in Solidity), it sets `tokenAddr` to the current active token.\n\n4. It then checks if the `ethRefundAmount` and `d.pct` arrays are not empty. If they're not, it throws an error.\n\n5. If `ethRefundAmount` is not empty, it calculates the percentage of the balance that should be refunded in Ether. It then calculates the amount of Ether to be refunded and transfers it to the `receiver`.\n\n6. If `d.pct` is not empty, it calculates",
        "gt": "contract c15244{ function _withdraw (address receiver, address tokenAddr) internal { assert (contractStage == 3); var c = whitelist[receiver]; if (tokenAddr == 0x00) { tokenAddr = activeToken; } var d = distributionMap[tokenAddr]; require ( (ethRefundAmount.length > c.ethRefund) || d.pct.length > c.tokensClaimed[tokenAddr] ); if (ethRefundAmount.length > c.ethRefund) { uint pct = _toPct(c.balance,finalBalance); uint ethAmount = 0; for (uint i=c.ethRefund; i<ethRefundAmount.length; i++) { ethAmount = ethAmount.add(_applyPct(ethRefundAmount[i],pct)); } c.ethRefund = ethRefundAmount.length; if (ethAmount > 0) { receiver.transfer(ethAmount); EthRefunded(receiver,ethAmount); } } if (d.pct.length > c.tokensClaimed[tokenAddr]) { uint tokenAmount = 0; for (i=c.tokensClaimed[tokenAddr]; i<d.pct.length; i++) { tokenAmount = tokenAmount.add(_applyPct(c.balance,d.pct[i])); } c.tokensClaimed[tokenAddr] = d.pct.length; if (tokenAmount > 0) { require(d.token.transfer(receiver,tokenAmount)); d.balanceRemaining = d.balanceRemaining.sub(tokenAmount); TokensWithdrawn(receiver,tokenAddr,tokenAmount); } } } }",
        "url": 739
    },
    {
        "code_input": "class Contract:\n    def __init__(self, web3, contract_address):\n        self.web3 = web3\n        self.contract_address = contract_address\n        self.contract = web3.eth.contract(address=contract_address, abi=ABI)\n\n    def upgrade_me(self, new_sc):\n        # Check if the caller is an editor\n        if not self.contract.functions.is_editor(self.web3.eth.accounts[0]).call():\n            raise Exception(\"Caller is not an editor\")\n\n        # Set the new address in the editAllowed mapping\n        self.contract.functions.set_edit_allowed(new_sc).transact",
        "gt": "contract c702{ function upgradeMe(address newSC) only_editors() external { editAllowed[msg.sender] = false; editAllowed[newSC] = true; emit SelfUpgrade(msg.sender, newSC); } }",
        "url": 740
    },
    {
        "code_input": "class BitGuildWhitelist:\n    def __init__(self, new_address):\n        self.new_address = new_address\n\n    def update_whitelist(self, new_address):\n        if new_address != '0x0000000000000000000000000000000000000000':\n            self.new_address = new_address\n        else:\n            raise ValueError(\"Invalid contract address.\")\n\n# Usage\nwhitelist = BitGuildWhitelist('0x1234567890123456789012345678901234567890')\nwhitelist.update_whitel",
        "gt": "contract c2276{ function updateWhitelist(address _newAddr) public onlyOperator { require(_newAddr != address(0), \"Invalid contract address.\"); Whitelist = BitGuildWhitelist(_newAddr); } }",
        "url": 741
    },
    {
        "code_input": "class Contract:\n    def __init__(self, core_contract):\n        self.core_contract = core_contract\n\n    def _transfer(self, receiver, cutie_id):\n        # The _transfer function is an internal function that transfers tokens from the caller's account to a specified address.\n        # The function takes two parameters: the address to which the tokens should be transferred and the ID of the token to be transferred.\n        # The function uses the coreContract.transfer function to perform the transfer.\n        self.core_contract.transfer(receiver, cutie_id)\n\n# Create an instance of the Contract class\ncontract = Contract(core_contract)\n\n# Call the _transfer function\ncontract._transfer(re",
        "gt": "contract c16922{ function _transfer(address _receiver, uint40 _cutieId) internal { coreContract.transfer(_receiver, _cutieId); } }",
        "url": 742
    },
    {
        "code_input": "class TokenContract:\n    def __init__(self):\n        self.allowance = {}\n\n    def transfer_from(self, sender, recipient, value):\n        if value > self.allowance.get(sender, 0):\n            return False\n        else:\n            self.allowance[sender] -= value\n            self._transfer(sender, recipient, value)\n            return True\n\n    def _transfer(self, sender, recipient, value):\n        # This is a placeholder for the actual transfer logic.\n        # In a real contract, this would involve updating the balances of the sender and recipient.\n        pass",
        "gt": "contract c16226{ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]); allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } }",
        "url": 743
    },
    {
        "code_input": "class ProductPriceCalculator:\n    def __init__(self, price, discount):\n        self.price = price\n        self.discount = discount\n\n    def how_many(self, value):\n        actual_price = self.price * (1000000 - self.discount) / 1000000\n        return value // actual_price\n\n# Usage\ncalculator = ProductPriceCalculator(100, 10)\nprint(calculator.how_many(1000))  # Output: 10",
        "gt": "contract c22697{ function howMany(uint256 value, uint256 discount) public view returns (uint256){ uint256 actualPrice = PRICE * (1000000 - discount) / 1000000; return value / actualPrice; } }",
        "url": 744
    },
    {
        "code_input": "class TokenComposition:\n    def __init__(self):\n        self.tokenIdToCompositionPrice = {}\n\n    def getCompositionPrice(self, _tokenId):\n        return self.tokenIdToCompositionPrice.get(_tokenId, None)",
        "gt": "contract c22031{ function getCompositionPrice(uint256 _tokenId) public view returns(uint256) { return tokenIdToCompositionPrice[_tokenId]; } }",
        "url": 745
    },
    {
        "code_input": "class TradingContract:\n    def __init__(self):\n        self.trading_open = False\n\n    def open_trading(self):\n        if not self.is_admin():\n            raise Exception(\"Only admin can open trading\")\n        self.trading_open = True\n\n    def is_admin(self):\n        # This is a placeholder for a function that checks if the current account is an admin.\n        # In a real-world scenario, this function would interact with a database or another external system.\n        return False",
        "gt": "contract c17814{ function openTrading() external onlyAdmin { tradingOpen = true; } }",
        "url": 746
    },
    {
        "code_input": "class c30337:\n    def __init__(self, web3):\n        self.web3 = web3\n        self.contract_address = '0xYourContractAddress'\n        self.contract = self.web3.eth.contract(address=self.contract_address, abi='YourABI')\n\n    def is_certification(self, student, document):\n        # Get the student's certifications\n        student_certifications = self.contract.functions.studentCertifications(student).call()\n\n        # Check if the document is valid\n        is_valid = student_certifications[document]['isValid']\n\n        return is_valid",
        "gt": "contract c30337{ function isCertification(address student, bytes32 document) payable requestFeePaid returns (bool isIndeed) { isIndeed = studentCertifications[student].documentStatuses[document].isValid; } }",
        "url": 747
    },
    {
        "code_input": "class C32100:\n    def __init__(self, contract_manager):\n        self.contract_manager = contract_manager\n        self.sale = None\n        self.s_pwd = None\n        self.change_block = None\n        self.creator = None\n\n    def set_sale_address(self, _sale, _pwd):\n        if self.contract_manager.get_sale_address() != _sale:\n            if self.contract_manager.",
        "gt": "contract c32100{ function set_sale_address(address _sale, bytes32 _pwd) { require(keccak256(_pwd) == s_pwd || msg.sender == creator); require (block.number > change_block); sale = _sale; } }",
        "url": 748
    },
    {
        "code_input": "class TokenTransferContract:\n    def __init__(self, contract_address, abi):\n        self.contract_address = contract_address\n        self.abi = abi\n        self.contract = self.get_contract()\n\n    def get_contract(self):\n        contract = web3.eth.contract(address=self.contract_address, abi=self.abi)\n        return contract\n\n    def refund_many(self, to, value):\n        if len(to) != len(value):\n            raise ValueError(\"The length of 'to' and 'value' arrays must be the same.\")\n\n        for i in range(len(to)):\n            self.contract.functions.transfer(to[i], value[i]).transact()",
        "gt": "contract c27403{ function refundMany(address[] _to, uint256[] _value) ownerExists(msg.sender) public { require(_to.length == _value.length); for (uint i = 0; i < _to.length; i++) { _to[i].transfer(_value[i]); } } }",
        "url": 749
    },
    {
        "code_input": "The given Solidity code is a contract for a withdrawal function. The function `withdraw` is designed to withdraw funds from the contract. Here's a high-level description of the main functionality and logic:\n\n1. The function `withdraw` is declared as external, which means it can only be called by other smart contracts or directly by the owner of the contract.\n\n2. The function takes an array of `uint32` values, `_dates`, as a parameter. This array contains the dates when the withdrawal should be allowed.\n\n3. The function initializes two variables, `withdrawAmount` and `datesLength`. `withdrawAmount` is set to 0, and `datesLength` is set to the length of the `_dates` array.\n\n4. The function then iterates over the `_dates` array. For each date, it checks if the current time (`now32`) is less than or equal to the date plus a buffer time (`WITHDRAW_BUFFER`). If the current time is less than the date, it skips to the next iteration.\n\n5. If the user has not completed the withdraw",
        "gt": "contract c13852{ function withdraw(uint32[] _dates) external { uint256 withdrawAmount = 0; uint256 datesLength = _dates.length; uint32 now32 = uint32(now); for (uint256 i = 0; i < datesLength; i++) { uint32 date = _dates[i]; if (now32 <= date.add(WITHDRAW_BUFFER)) { continue; } if (userDateToStatus[msg.sender][date] != UserEntryStatus.COMPLETED) { continue; } userDateToStatus[msg.sender][date] = UserEntryStatus.WITHDRAWN; withdrawAmount = withdrawAmount.add(REGISTRATION_FEE).add(calculateBonus(date)); } if (withdrawAmount > 0) { msg.sender.transfer(withdrawAmount); } LogWithdraw(msg.sender, withdrawAmount); } }",
        "url": 750
    },
    {
        "code_input": "class C196:\n    def __init__(self):\n        self.proposal_ = {}\n\n    def whatProposal(self, _whatFunction):\n        # This is a placeholder for the actual function.\n        # It should be replaced with the actual function.\n        return _whatFunction\n\n    def checkCount(self, _whatFunction):\n        _whatProposal = self.whatProposal(_whatFunction)\n        if _whatProposal in self.proposal_:\n            return self.proposal_[_whatProposal].count\n        else:\n            return 0",
        "gt": "contract c196{ function checkCount (Data storage self, bytes32 _whatFunction) internal view returns (uint256 signature_count) { bytes32 _whatProposal = whatProposal(_whatFunction); return (self.proposal_[_whatProposal].count); } }",
        "url": 751
    },
    {
        "code_input": "class TokenContract:\n    def __init__(self):\n        self.token = None\n\n    def set_token(self, token):\n        self.token = token\n\n    def check_token(self):\n        if self.token is None:\n            raise ValueError(\"Token address not set\")\n\n    def token_available(self, func):\n        def wrapper(*args, **kwargs):\n            self.check_token()\n            return func(*args, **kwargs)\n        return wrapper\n\n# Usage\ntoken_contract = TokenContract()\n\n@token_contract.token_available\ndef mint_token(user, amount):\n    # Logic to mint token\n    pass\n\n@token_contract.token_available\ndef burn_token(user, amount):\n    # Logic to burn token\n    pass",
        "gt": "contract c135{ modifier tokenAvailable(){ require(address(token) != 0,\"Token address not set\"); _; } }",
        "url": 752
    },
    {
        "code_input": "The given Solidity code is a contract for buying tokens. Here's a high-level description of the main functionality and logic:\n\n1. The contract has a function `purchaseTokens` that takes an address as a parameter.\n2. This function is public, meaning it can be called by anyone.\n3. The function takes a parameter `_buyer`, which is the address of the person who is buying the tokens.\n4. The function requires that the `_buyer` is not the address of the contract (`address(0)`), that the `BENEFICIARY` has enough tokens (`balances[BENEFICIARY] > 0`), and that the amount of tokens being bought is not zero (`msg.value != 0`).\n5. The function calculates the amount of tokens to be bought by dividing the amount of Ether sent by the buyer by the price of a token (`msg.value / TOKEN_PRICE`).\n6. The function transfers the tokens to the `BENEFICIARY`.\n7. The function decreases the balance of the `BENEFICIARY` by",
        "gt": "contract c28516{ function purchaseTokens(address _buyer) public payable returns (bool) { require(_buyer != address(0)); require(balances[BENEFICIARY] > 0); require(msg.value != 0); uint amount = msg.value / TOKEN_PRICE; BENEFICIARY.transfer(msg.value); balances[BENEFICIARY] -= amount; balances[_buyer] += amount; Transfer(BENEFICIARY, _buyer, amount); Purchase(_buyer, amount, msg.value); return true; } }",
        "url": 753
    },
    {
        "code_input": "class TokenBasedGame:\n    def __init__(self, contract):\n        self.contract = contract\n\n    def update_stats(self, _tokenId, _stats):\n        # Check if the contract has the necessary permissions to call the function\n        if not self.contract.has_permission(_tokenId, 'onlyGrantedContracts'):\n            raise Exception('You do not have the necessary permissions to update the stats of this token.')\n\n        # Check if the token exists\n        if not self.contract.token_exists(_tokenId):\n            raise Exception('The token you are trying to update does not exist.')",
        "gt": "contract c16360{ function updateStats(uint256 _tokenId, uint8[STATS_SIZE] _stats) public validAsset(_tokenId) onlyGrantedContracts { assets[_tokenId].stats = _stats; } }",
        "url": 754
    },
    {
        "code_input": "class C26566:\n    def __init__(self, biggestDicks):\n        self.biggestDicks = biggestDicks\n\n    def howManyDicks(self):\n        return len(self.biggestDicks)\n\n# Example usage:\nbiggestDicks = ['Dick1', 'Dick2', 'Dick3']\nc26566 = C26566(biggestDicks)\nprint(c26566.howManyDicks())  # Output: 3",
        "gt": "contract c26566{ function howManyDicks() external view returns (uint) { return biggestDicks.length; } }",
        "url": 755
    },
    {
        "code_input": "class Marketplace:\n    def consume_market_order_ask(self, _marketorderIdx",
        "gt": "contract c10410{ function buyForWorkOrder( uint256 _marketorderIdx, address _workerpool, address _app, address _dataset, string _params, address _callback, address _beneficiary) external returns (address) { address requester = msg.sender; require(marketplace.consumeMarketOrderAsk(_marketorderIdx, requester, _workerpool)); uint256 emitcost = lockWorkOrderCost(requester, _workerpool, _app, _dataset); WorkOrder workorder = new WorkOrder( _marketorderIdx, requester, _app, _dataset, _workerpool, emitcost, _params, _callback, _beneficiary ); m_woidRegistered[workorder] = true; require(WorkerPool(_workerpool).emitWorkOrder(workorder, _marketorderIdx)); emit WorkOrderActivated(workorder, _workerpool); return workorder; } }",
        "url": 756
    },
    {
        "code_input": "def createCDPLeveragedDai(amount):\n    # This is a placeholder for the actual implementation of creating a CDP leveraged position with Dai tokens.\n    # The actual implementation would depend on the specifics of the DApp and the protocol used.\n    # For now, we'll just return the input amount.\n    return",
        "gt": "contract c17754{ function createCDPLeveragedAllDai() public returns(bytes32 id) { return createCDPLeveragedDai(dai.balanceOf(msg.sender)); } }",
        "url": 757
    },
    {
        "code_input": "class TokenPurchaseContract:\n    def __init__(self):\n        self.deposited_tokens = {}\n\n    def _get_token_amount(self, token_amount):\n        # This function is not defined in the given Solidity code.\n        # It's supposed to return the amount of tokens to be added to the beneficiary's balance.\n        # For the purpose of this example, we'll just return the input token amount.\n        return token_amount\n\n    def _process_purchase(self, beneficiary, token_amount):\n        if beneficiary in self.deposited_tokens:\n            self.deposited_tokens[beneficiary] += self._get_token_amount(token_amount)\n        else:\n            self",
        "gt": "contract c7570{ function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal { depositedTokens[_beneficiary] = depositedTokens[_beneficiary].add(_getTokenAmount(_tokenAmount)); } }",
        "url": 758
    },
    {
        "code_input": "def transferFeeIncurred(value, transferFeeRate):\n    return safeMul_dec(value, transferFeeRate)",
        "gt": "contract c592{ function transferFeeIncurred(uint value) public view returns (uint) { return safeMul_dec(value, transferFeeRate); } }",
        "url": 759
    },
    {
        "code_input": "def load_eth_balances(web3):\n    # Get the number of accounts on the Ethereum blockchain\n    num_accounts = web3.eth.get_balance(web3.eth.coinbase)\n\n    # Initialize an array to store the balances\n    balances = [0]*num_accounts\n\n    # Get the balances of all accounts\n    for i in range(num_accounts):\n        # Get the balance of account i\n        balance = web3.eth.get_balance(web3.eth.accounts[i])\n\n        # Store the balance in the array\n        balances[i] = balance\n\n    # Calculate the total balance\n    total_balance = sum(balances)\n\n    return balances, total_balance",
        "gt": "contract c10604{ function loadEthBalances() public view returns (uint256[] memory, uint256 total) { uint256[] memory result = new uint256[](accounts.length); uint256 balance; for (uint256 i = 0; i < accounts.length; i++) { balance = accounts[i].balance; result[i] = balance; total += balance; } return (result, total); } }",
        "url": 760
    },
    {
        "code_input": "class Oversight:\n    def __init__(self, oversight_address):\n        self.oversight_address = oversight_address\n\n    def validate(self, currency, amount):\n        # This is a placeholder for the actual logic of the oversight system.\n        # In a real-world scenario, this function would check if the oversight is able to validate the currency and amount.\n        # For the sake of this example, we'll just return True for simplicity.\n        return True\n\nclass CurrencyOversight(object):\n    def __init__(self, oversight):\n        self.oversight = oversight\n\n    def spend_control(self, currency, amount):\n        if not self.oversight.validate(currency, amount):\n            revert(\"",
        "gt": "contract c40166{ modifier spendControl(address currency, uint256 amount) { assert(Oversight(oversightAddress).validate(currency, amount)); _; } }",
        "url": 761
    },
    {
        "code_input": "class TokenSwap:\n    def __init__(self, owner, contract_address, token_abi):\n        self.owner = owner\n        self.contract_address = contract_address\n        self.token_abi = token_abi\n        self.contract = self.get_contract()\n\n    def get_contract(self):\n        contract = w3.eth.contract(address=self.contract_address, abi=self.token_abi)\n        return contract\n\n    def give_aways(self, to, amount, bonus):\n        if self.contract.functions.transferTokens(to, amount, bonus).call():\n            return True\n        else:\n            return False",
        "gt": "contract c33938{ function giveAways(address _to, uint256 _amount, uint256 _bonus) external onlyOwner { if (!transferTokens(_to, _amount, _bonus)) revert(); } }",
        "url": 762
    },
    {
        "code_input": "class C39341:\n    def __init__(self, owner, transfers, D160):\n        self.owner = owner\n        self.transfers = transfers\n        self.D160 = D160\n\n    def fill(self, data):\n        if self.owner != self.transfers.owner:\n            raise Exception(\"Only the owner can call this function\")\n\n        if len(data) == 0:\n            return\n\n        if self.transfers.length + len(data) > self.D160:\n            raise Exception(\"Not enough gas to add all transfers\")\n\n        acc = 0\n        offset = len(self.transfers)\n        self.transfers.length += len(data)\n\n        for i in range(len(data)):",
        "gt": "contract c39341{ function fill(uint[] data) onlyOwner { if (next>0) throw; uint acc; uint offset = transfers.length; transfers.length = transfers.length + data.length; for (uint i = 0; i < data.length; i++ ) { address addr = address( data[i] & (D160-1) ); uint amount = data[i] / D160; transfers[offset + i].addr = addr; transfers[offset + i].amount = amount; acc += amount; } totalToDistribute += acc; } }",
        "url": 763
    },
    {
        "code_input": "class TokenDistributor:\n    def __init__(self, contract):\n        self.contract = contract\n\n    def allocate_token(self, a_receiver):\n        receiver_length =",
        "gt": "contract c13860{ function AllocateToken(address[] a_receiver) external IsOwner AllLock { uint receiverLength = a_receiver.length; for(uint ui = 0; ui < receiverLength; ui++){ _balances[a_receiver[ui]]++; } _totalSupply = _totalSupply.add(receiverLength); } }",
        "url": 764
    },
    {
        "code_input": "class ERC20:\n    def __init__(self):\n        self.allowances = {}\n\n    def allowance(self, owner, spender):\n        if owner in self.allowances and spender in self.allowances[owner]:\n            return self.allowances[owner][spender]\n        else:\n            return 0",
        "gt": "contract c36415{ function allowance(address _owner, address _spender) constant returns (uint256) { return allowances[_owner][_spender]; } }",
        "url": 765
    },
    {
        "code_input": "class TokenContract:\n    def __init__(self, contract_address, token_address, sender_address):\n        self.contract_address = contract_address\n        self.token_address = token_address\n        self.sender_address = sender_address\n        self.total_tokens_received = 0\n\n    def on_tokens_received(self, value):\n        if self.contract_address == self.token_address:\n            if self.sender_address == '0x0000000000000000000000000000000000000000':\n                self.total_tokens_received += value\n\n# Example usage:\ncontract_address = '0x123",
        "gt": "contract c32869{ function onTokensReceived(address _token, address _from, uint _value) internal { require(_token == msg.sender); require(_token == address(token)); require(_from == address(0)); totalTokensReceived += _value; } }",
        "url": 766
    },
    {
        "code_input": "The given Solidity code is a contract for a decentralized application (dApp) that allows users to stake their Ethereum tokens in a round. The contract is named `c12325`.\n\nThe main functionality of the contract is to allow users to stake their Ethereum tokens in a specific round. The `latchFciUser` function is triggered when a user wants to stake their tokens.\n\nHere's a high-level description of the function:\n\n1. The function `latchFciUser` is declared as public, which means it can be called by anyone.\n\n2. The function first checks if the contract is paused (`isPause == true`) and if the round is open (`NetfRevenue[_roundIndex].isOpen == true`). If either of these conditions is not true, the function will revert (i.e., stop execution).\n\n3. The function then checks if the user is able to withdraw from the round (`NetfRevenue[_roundIndex].withdrawable == false`). If this condition is not true, the function will revert.\n\n4. The function then checks",
        "gt": "contract c12325{ function latchFciUser(uint _roundIndex) public { require(isPause == true && NetfRevenue[_roundIndex].isOpen == true); require(NetfRevenue[_roundIndex].withdrawable == false); require(balanceOf[msg.sender] > 0); usersNETF[_roundIndex][msg.sender].stake = balanceOf[msg.sender]; } }",
        "url": 767
    },
    {
        "code_input": "class C20598:\n    def __init__(self, contract):\n        self.contract = contract\n\n    def remove_ca(self, ca_address):\n        # Check if the function is callable by the owner\n        if not self.contract.caller.is_owner():\n            raise ValueError(\"Only the contract",
        "gt": "contract c20598{ function removeCA(address ca_address) public onlyOwner { delete certificate_authority[ca_address]; LogRemoveCertificateAuthority(ca_address); } }",
        "url": 768
    },
    {
        "code_input": "The given Solidity code is a contract for a decentralized exchange (DEX) that allows users to withdraw funds from the contract. The contract has a function `downTheDrain()` that allows users to withdraw funds from the contract.\n\nHere's a high-level description of the main functionality and logic of the code:\n\n1. The `downTheDrain()` function is declared as public, meaning it can be accessed directly by anyone.\n2. The function is marked as `whenNotPaused`, which means it can only be called when the contract is not paused.\n3. The function is `payable`, which means it can accept Ether as payment.\n4. The function returns a boolean value (`success`) that indicates whether the operation was successful or not.\n\nThe function `downTheDrain()` has two main parts:\n\n1. The first part checks if the amount of Ether sent by the user is less than 0.01 ether. If it is, the function calculates the number of blocks to be flushed and sets it as the value of `toFlush[msg.sender]`.\n2. The second part is",
        "gt": "contract c18357{ function downTheDrain() public whenNotPaused payable returns (bool success) { if(msg.value < 0.01 ether) { toFlush[msg.sender] = block.number + calculateFactorFlushDifficulty(balances[msg.sender]); return true; } else return downTheDrainImmediate(); } }",
        "url": 769
    },
    {
        "code_input": "class C14378:\n    def __init__(self, cards):\n        self.cards = cards\n\n    def withdrawEtherFromTrade(self, amount):\n        if amount > self.cards.coinBalanceOf(msg.sender, 0):\n            raise ValueError(\"Insufficient balance\")\n        self.cards.setCoinBalance(msg.sender, amount, 0, False)\n        msg.sender.transfer(amount)",
        "gt": "contract c14378{ function withdrawEtherFromTrade(uint256 amount) external { require(amount <= cards.coinBalanceOf(msg.sender,0)); cards.setCoinBalance(msg.sender,amount,0,false); msg.sender.transfer(amount); } }",
        "url": 770
    },
    {
        "code_input": "class C15398:\n    def __init__(self, is_sale_active):\n        self.is_sale_active = is_sale_active\n\n    def sale_status(self):\n        return self.is_sale_active",
        "gt": "contract c15398{ function saleStatus() public constant returns (bool){ return isSaleActive; } }",
        "url": 771
    },
    {
        "code_input": "The given Solidity contract is a simple token migration contract. It allows a user to migrate their tokens to a different address. Here's a high-level description of the main functionality and logic:\n\n1. The contract has a function `migrate`. This function is called by a user to migrate their tokens to a new address.\n\n2. The function first checks if the `migrationAgent` address is not `0`. If it is, the function reverts the transaction.\n\n3. The function then checks if the `_value` input is greater than `0` and less than or equal to the balance of the sender. If not, the function reverts the transaction.\n\n4. The function then subtracts the `_value` from the sender's balance and adds it to the total supply.\n\n5. The function then subtracts the `_value` from the total migrated and adds it to the total migrated.\n\n6. The function then calls the `migrateFrom` function of the `migrationAgent` with the sender as the recipient and `_value` as the amount.\n\n7. The function then calls the",
        "gt": "contract c24260{ function migrate(uint256 _value) public { require(migrationAgent != address(0)); require(_value > 0); require(_value <= balances[msg.sender]); balances[msg.sender] = safeSub(balances[msg.sender], _value); totalSupply = safeSub(totalSupply, _value); totalMigrated = safeAdd(totalMigrated, _value); MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value); Migrate(msg.sender, migrationAgent, _value); } }",
        "url": 772
    },
    {
        "code_input": "class Contract:\n    def __init__(self, web3, address):\n        self.web3 = web3\n        self.address = address\n\n    def withdrawl(self, amt, sender):\n        # Check if sender is admin\n        is_admin = self.is_admin(sender)\n\n        if is_admin:\n            # Check if sender has enough balance\n            balance = self.web3.eth.getBalance(sender)\n            if balance >= amt:\n                # Transfer funds\n                self.web3.eth.sendTransaction({\n                    'from': sender,\n                    'to': self.address,\n                    'value': amt\n                })\n                print(f'{sender} withdrew {amt",
        "gt": "contract c5281{ function withdrawl(uint amt) external onlyAdmin { require(amt <= address(this).balance); msg.sender.transfer(amt); emit AdminWithdrawl(msg.sender, amt); } }",
        "url": 773
    },
    {
        "code_input": "def safe_add(a, b):\n    \"\"\"\n    This function performs addition without overflow.\n    It returns the sum if the addition is possible, otherwise it returns the maximum uint value.\n    \"\"\"\n    try:\n        return a + b\n    except ValueError:\n        return 2**63 - 1\n\ndef _nominCap(nominPool, totalSupply):\n    \"\"\"\n    This function calculates the nom",
        "gt": "contract c18810{ function _nominCap() internal view returns (uint) { return safeAdd(nominPool, totalSupply); } }",
        "url": 774
    },
    {
        "code_input": "class TaskContract:\n    def __init__(self, owner, end_time):\n        self.owner = owner\n        self.end_time = end_time\n        self.is_finalized = False\n\n    def has_ended(self):\n        # This is a placeholder for the actual function that checks if the task has ended.\n        # In a real-world scenario, this function would return a boolean indicating whether the task has ended.\n        return False\n\n    def finalize(self):\n        if not self.is_finalized:\n            if self.has_ended():\n                self.finalization()\n                self.is_finalized =",
        "gt": "contract c36554{ function finalize() onlyOwner { require(!isFinalized); require(hasEnded()); finalization(); Finalized(); isFinalized = true; } }",
        "url": 775
    },
    {
        "code_input": "class TokenContract:\n    def __init__(self, owner, is_paused=False):\n        self.owner = owner\n        self.is_paused = is_paused\n\n    def set_pause(self, is_paused):\n        if self.is_paused != is_paused:\n            self.is_paused = is_paused\n            self.emit_is_paused(is_paused)\n\n    def emit_is_paused(self, is_paused):\n        # This is a placeholder for the actual event emission.\n        # In a real-world scenario,",
        "gt": "contract c8716{ function setPause( bool _isPaused ) external onlyOwner { require(isPaused != _isPaused); isPaused = _isPaused; emit IsPaused(_isPaused); } }",
        "url": 776
    },
    {
        "code_input": "class OutcomeTokenSale:\n    def __init__(self, sender, outcomeTokenIndex, outcomeTokenCount, outcomeTokenProfit, fees):\n        self.sender = sender\n        self.outcomeTokenIndex = outcomeTokenIndex\n        self.outcomeTokenCount = outcomeTokenCount\n        self.outcomeTokenProfit = outcomeTokenProfit\n        self.fe",
        "gt": "contract c31167{ function sell(uint8 outcomeTokenIndex, uint outcomeTokenCount, uint minProfit) public atStage(Stages.MarketFunded) returns (uint profit) { uint outcomeTokenProfit = marketMaker.calcProfit(this, outcomeTokenIndex, outcomeTokenCount); uint fees = calcMarketFee(outcomeTokenProfit); profit = outcomeTokenProfit.sub(fees); require(profit > 0 && profit >= minProfit); require(eventContract.outcomeTokens(outcomeTokenIndex).transferFrom(msg.sender, this, outcomeTokenCount)); eventContract.sellAllOutcomes(outcomeTokenProfit); require(eventContract.collateralToken().transfer(msg.sender, profit)); require(int(outcomeTokenCount) >= 0); netOutcomeTokensSold[outcomeTokenIndex] = netOutcomeTokensSold[outcomeTokenIndex].sub(int(outcomeTokenCount)); OutcomeTokenSale(msg.sender, outcomeTokenIndex, outcomeTokenCount, outcomeTokenProfit, fees); } }",
        "url": 777
    },
    {
        "code_input": "import random\nfrom datetime import timedelta\n\nclass C18660:\n    def __init__(self):\n        self.addressToFreeSummonTimestamp = {}\n\n    def payWithDailyFreePoint(self, sender):\n        if sender == address(0) or now > self.addressToFreeSummonTimestamp.get(sender, 0) + timedelta(days=1):\n            return\n        self.addressToFreeSummonTimestamp[sender] = now\n        _randomValue = random.randint(10000, 0)\n        _heroRankToMint = 0\n        if _randomValue < 5500:\n            _heroRankToMint = 0\n        elif _randomValue < 9850:\n            _heroRankToMint = 1\n        else:",
        "gt": "contract c18660{ function payWithDailyFreePoint() whenNotPaused public { require(msg.sender != address(0)); require(now > addressToFreeSummonTimestamp[msg.sender] + 1 days); addressToFreeSummonTimestamp[msg.sender] = now; var _randomValue = random(10000, 0); uint8 _heroRankToMint = 0; if (_randomValue < 5500) { _heroRankToMint = 0; } else if (_randomValue < 9850) { _heroRankToMint = 1; } else { _heroRankToMint = 2; } summonHero(msg.sender, _heroRankToMint); } }",
        "url": 778
    },
    {
        "code_input": "class ERC721Token:\n    def __init__(self, owner, approver):\n        self.owner = owner\n        self.approver = approver\n\n    def approve(self, approver, tokenId):\n        if self.owner != approver:\n            raise Exception(\"Only the owner of the token can approve the approver.\")\n        else:\n            self.approver = approver\n            print(f\"Approval successful. Approver: {approver}, Token ID: {tokenId}\")\n\n# Example usage:\ntoken = ERC721Token(\"Owner\", \"Approver\")\ntoken.approve(\"Approver\", 1)",
        "gt": "contract c29012{ function approve(address _to, uint256 _tokenId ) external { require(_owns(msg.sender, _tokenId)); _approve(_tokenId, _to); Approval(msg.sender, _to, _tokenId); } }",
        "url": 779
    },
    {
        "code_input": "def get_stock_key(market, symbol):\n    # Create a new byte array of 12 bytes\n    combined = bytearray(12)\n\n    # Copy the first 6 bytes from the market to the combined array\n    for i in range(6):\n        combined[i] = market[i]\n\n    # Copy the next 6 bytes from the symbol to the combined array\n    for j in range(6):\n        combined[j + 6] = symbol[j]\n\n    # Return the combined bytes as a 12-byte key\n    return bytes(combined)",
        "gt": "contract c8196{ function getStockKey(bytes6 _market, bytes6 _symbol) public pure returns(bytes12 key) { bytes memory combined = new bytes(12); for (uint i = 0; i < 6; i++) { combined[i] = _market[i]; } for (uint j = 0; j < 6; j++) { combined[j + 6] = _symbol[j]; } assembly { key := mload(add(combined, 32)) } } }",
        "url": 780
    },
    {
        "code_input": "class C19699:\n    def __init__(self, contract):\n        self.contract = contract\n\n    def refund_participant(self, participant, stage1, stage2, stage3, stage4):\n        # Check if the participant has enough balance\n        if self.contract.balanceOf[participant] > 0:\n            # Get the balance and tokens of the participant\n            balance = self.contract.balanceOf[participant]\n            tokens = self.contract.tokenBalanceOf[participant]\n\n            # Set the participant's balance to 0\n            self.contract.balanceOf[participant] = 0\n            # Set the participant's tokens to 0\n            self.contract.tokenBalanceOf[participant] = 0",
        "gt": "contract c19699{ function refundParticipant(address participant, uint256 _stage1, uint256 _stage2, uint256 _stage3, uint256 _stage4) external onlyOwner { require(balanceOf[participant] > 0); uint256 balance = balanceOf[participant]; uint256 tokens = tokenBalanceOf[participant]; balanceOf[participant] = 0; tokenBalanceOf[participant] = 0; refundable[participant] = balance; weiRaised = weiRaised.sub(balance); tokensSent = tokensSent.sub(tokens); token.reclaimAllAndBurn(participant); blacklist[participant] = true; AddedToBlacklist(participant, now); stages.refundParticipant(_stage1, _stage2, _stage3, _stage4); TokensReclaimed(participant, tokens, now); } }",
        "url": 781
    },
    {
        "code_input": "class EtherAffleContract:\n    def __init__(self, etheraffle):\n        self.etheraffle = etheraffle\n\n    def onlyEtheraffle(self, func):\n        def wrapper(msg, *args, **kwargs):\n            if msg.sender == self.etheraffle:\n                return func(msg, *args, **kwargs)\n            else:\n                raise ValueError(\"Only the address {} can call this function.\".format(self.etheraffle))\n        return wrapper\n\n    @onlyEtheraffle\n    def myFunction(self, msg, *args, **kwargs):\n        # This is a",
        "gt": "contract c23218{ modifier onlyEtheraffle() { require(msg.sender == etheraffle); _; } }",
        "url": 782
    },
    {
        "code_input": "class C246:\n    def __init__(self, web3, address):\n        self.web3 = web3\n        self.address = address\n        self.contract = None\n\n    def set_arbitration_fee_per_juror(self, new_fee):\n        if not self.contract:\n            self.contract = self.web3.eth.contract(address=self.address, abi=['function setArbitrationFeePerJuror(uint _arbitrationFeePerJuror) public onlyGovernor'])\n        self.contract.functions.setArbitrationFeePerJuror(new_fee).transact()",
        "gt": "contract c246{ function setArbitrationFeePerJuror(uint _arbitrationFeePerJuror) public onlyGovernor { arbitrationFeePerJuror = _arbitrationFeePerJuror; } }",
        "url": 783
    },
    {
        "code_input": "class RegistryContract:\n    def __init__(self, owner):\n        self.owner = owner\n        self.registrar = None\n\n    def set_registrar(self, new_registrar):\n        if self.owner != self.genesis:\n            raise ValueError(\"Only the contract owner can set the registrar.\")\n        self.registrar = new_registrar\n\n    @property\n    def genesis(self):\n        # This is a placeholder for the genesis account.\n        # In a real-world scenario, this would be the address of the first account.\n        return \"0x00000000000000000000000000000000",
        "gt": "contract c36450{ function setRegistrar(address _registrar) only_owner(genesis) { registrar = _registrar; NewRegistrar(_registrar); } }",
        "url": 784
    },
    {
        "code_input": "def batch_send_tokens(addresses, values):\n    # Check if the length of the addresses array is equal to the length of the values array\n    if len(addresses) != len(values):\n        return False\n\n    # Check if the length of the addresses array is less than or equal to 20\n    if len(addresses) > 20:\n        return False\n\n    # Iterate over the addresses and values arrays\n    for i in range(len(addresses)):\n        # Call the send_token function with the current address and value",
        "gt": "contract c29120{ function batchSendTokens(address[] addresses, uint256[] _values) public onlyOwnerAndContract returns (bool) { require(addresses.length == _values.length); require(addresses.length <= 20); uint i = 0; uint len = addresses.length; for (;i < len; i++) { sendToken(addresses[i], _values[i]); } return true; } }",
        "url": 785
    },
    {
        "code_input": "class C1665:\n    def __init__(self, contract):\n        self.contract = contract\n        self.state = None\n        self.budget_plans = []\n\n    def enable_team_withdraw(self):\n        if self.contract.msg.sender != self.contract.owner:\n            raise ValueError(\"Only the contract owner can enable the team withdrawal.\")\n\n        if self.state != \"NotReady\":\n            raise ValueError(\"The team withdrawal is already enabled.\")\n\n        self.state = \"TeamWithdraw\"\n        self.budget_plans.append({\n            \"proposalId\": \"NON_UINT256\",\n            \"budgetInWei\": self.contract.address",
        "gt": "contract c1665{ function enableTeamWithdraw() onlyOwner public { require(state == State.NotReady); state = State.TeamWithdraw; emit TeamWithdrawEnabled(); budgetPlans.length++; BudgetPlan storage plan = budgetPlans[0]; plan.proposalId = NON_UINT256; plan.budgetInWei = address(this).balance.mul(FIRST_WITHDRAW_RATE).div(100); plan.withdrawnWei = 0; plan.startTime = now; (plan.endTime, plan.officalVotingTime) = _budgetEndAndOfficalVotingTime(now); currentBudgetPlanId = 0; } }",
        "url": 786
    },
    {
        "code_input": "class C14407:\n    def __init__(self, web3, address):\n        self.web3 = web3\n        self.contract = web3.eth.contract(address=address, abi='c14407')\n\n    def add_shareholder_address(self, new_shareholder):\n        # Check if the new shareholder address is not 0 and not the contract owner\n        if new_shareholder != '0x0000000000000000000000000000000000000000' and new_shareholder != self.contract.functions.owner().call():\n            # Check if any of the shareholders",
        "gt": "contract c14407{ function addShareholderAddress(address newShareholder) external onlyOwner { require(newShareholder != address(0)); require(newShareholder != owner); require(shareholder1 == address(0) || shareholder2 == address(0) || shareholder3 == address(0)); if (shareholder1 == address(0)) { shareholder1 = newShareholder; numShareholders = numShareholders.add(1); } else if (shareholder2 == address(0)) { shareholder2 = newShareholder; numShareholders = numShareholders.add(1); } else if (shareholder3 == address(0)) { shareholder3 = newShareholder; numShareholders = numShareholders.add(1); } } }",
        "url": 787
    },
    {
        "code_input": "class GiftExchange:\n    def __init__(self):\n        self.gift_storage = {}\n        self.gift_links = {}\n\n    def update_gift(self, gift_id, price, description, gift_url):\n        if gift_id in self.gift_storage:\n            self.gift_storage[gift_id]['price'] = price\n            self.gift_storage[gift_id]['description'] = description\n            self.gift_links[gift_id] = gift_url\n        else:\n            raise ValueError(f\"Gift with id {gift_id} does not exist\")",
        "gt": "contract c26856{ function updateGift(uint256 GiftId, uint256 _price, string _description, string _giftUrl) public onlyOwner { require(GiftExists[GiftId]); giftStorage[GiftId].price = _price; giftStorage[GiftId].description = _description; GiftLinks[GiftId] = _giftUrl; } }",
        "url": 788
    },
    {
        "code_input": "class InvestorDApp:\n    def __init__(self, investors_delivery_date, investors_locked):\n        self.investors_delivery_date = investors_delivery_date\n        self.investors_locked = investors_locked\n\n    def get_locked_amount_investors(self, _investor):\n        delivery_date = self.investors_delivery_date[_investor]\n        locked_amt = self.investors_locked[_investor]\n\n        if now <= delivery_date:\n            return locked_amt\n        elif now <= delivery_date + 90:\n            return locked_amt * 2 / 3\n        elif now <= delivery_date + 180:\n            return locked_amt * 1 / 3\n        else:",
        "gt": "contract c14493{ function getLockedAmount_investors(address _investor) public constant returns (uint256) { uint256 delieveryDate = investors_deliveryDate[_investor]; uint256 lockedAmt = investors_locked[_investor]; if (now <= delieveryDate) {return lockedAmt;} if (now <= delieveryDate + 90 days) {return lockedAmt.mul(2).div(3);} if (now <= delieveryDate + 180 days) {return lockedAmt.mul(1).div(3);} return 0; } }",
        "url": 789
    },
    {
        "code_input": "class Bag:\n    def __init__(self, level, purchased_at, timeout):\n        self.level = level\n        self.purchased_at = purchased_at\n        self.timeout = timeout\n\nclass BaggingSystem:\n    def get_bag_level(self, bag):\n        if (bag.purchased_at + bag.timeout) <= int(time.time()):\n            return bag.level\n        else:\n            return 0",
        "gt": "contract c16009{ function getBagLevel(Bag bag) private view returns (uint256) { if (now <= (SafeMath.add(bag.purchasedAt, timeout))) { return bag.level; } else { return 0; } } }",
        "url": 790
    },
    {
        "code_input": "The given Solidity code is a contract for an ERC20 token. The contract has a function `investInternal` that is meant to be called by a smart contract. This function is supposed to buy tokens based on the value of the transaction and the current state of the contract.\n\nHere's a high-level description of the function:\n\n1. The function `investInternal` is defined to receive an address and a uint128 (a type of uint256) as parameters.\n2. The function is marked as `internal`, meaning it can only be called from within the contract itself.\n3. The function returns a uint (a type of uint256) named `tokensBought`.\n4. Inside the function, there's a call to a function `buyTokens`. This function is not defined in the contract, but it's assumed to be a function that takes in parameters and returns a value.\n5. The `buyTokens` function is called with the following parameters:\n   - The address of the receiver (the address to send the tokens to).\n   - The customerId (a unique identifier for the customer).\n   -",
        "gt": "contract c10129{ function investInternal(address receiver, uint128 customerId) stopInEmergency internal returns(uint tokensBought) { return buyTokens(receiver, customerId, pricingStrategy.calculatePrice(msg.value, weiRaised - presaleWeiRaised, tokensSold, msg.sender, token.decimals())); } }",
        "url": 791
    },
    {
        "code_input": "class Contract:\n    def __init__(self, web3, address):\n        self.web3 = web3\n        self.address = address\n\n    def balanceOf(self, owner):\n        # Get the contract's ABI\n        contract_abi = self.web3.eth.contract(address=self.address)\n\n        # Get the balance of the owner\n        balance = contract_abi.functions.balanceOf(owner).call()\n\n        return balance",
        "gt": "contract c10120{ function balanceOf(address _owner) public view returns (uint) { return balances[_owner]; } }",
        "url": 792
    },
    {
        "code_input": "class C405:\n    def __init__(self, web3, account):\n        self.web3 = web3\n        self.account = account\n        self.contract_address = None\n        self.contract = None\n\n    def deploy_contract(self, abi, bytecode):\n        self.contract_address = self.web3.eth.contract(abi=abi)\n        self.contract = self.web3.eth.contract(address=self.contract_address, abi=abi)\n        return self.contract_address\n\n    def set_stale_time(self",
        "gt": "contract c405{ function setStaleTime(uint256 _staleTime) onlyOwner public { staleTime = _staleTime; } }",
        "url": 793
    },
    {
        "code_input": "class C128:\n    def __init__(self, owner):\n        self.owner = owner\n        self.paused = False\n\n    def unpause(self):\n        if self.paused:\n            self.paused = False\n            print(\"Unpaused\")\n            self.emit_unpause()\n        else:\n            print(\"Contract is not paused\")\n\n    def emit_unpause(self):\n        print(\"Emit Unpause\")\n\n# Testing\nc128 = C128(\"Owner\")\nc128.unpause()  # Should print \"Unpaused\"\nc128",
        "gt": "contract c128{ function unpause() public onlyOwner whenPaused { paused = false; emit Unpause(); } }",
        "url": 794
    },
    {
        "code_input": "class Contract:\n    def __init__(self, start_date, end_date):\n        self.start_date = start_date\n        self.end_date = end_date\n\n    def purchasing_allowed(self, current_time):\n        if self.start_date <= current_time <= self.end_date:\n            return True\n        else:\n            return False\n\n    def purchase(self, current_time):\n        if not self.purchasing_allowed(current_time):\n            raise Exception(\"Purchase is not allowed.\")\n        # The actual purchase logic goes here.\n\n# Usage\ncontract = Contract(start_date=1630000000, end_date=1640000000)",
        "gt": "contract c21494{ modifier purchasingAllowed() { require(now >= startDate && now <= endDate); _; } }",
        "url": 795
    },
    {
        "code_input": "class Pre",
        "gt": "contract c21711{ function buyPreSaleTokens(address beneficiary) internal returns(bool) { uint256 amount = getTokensForPreSale(exchangeRateForETH, msg.value); fundTransfer(msg.value); if (token.transfer(beneficiary, amount)) { tokenSoldInPresale = tokenSoldInPresale.add(amount); token.changeTotalSupply(amount); totalWeiRaised = totalWeiRaised.add(msg.value); TokenPurchase(beneficiary, msg.value, amount); return true; } return false; } }",
        "url": 796
    },
    {
        "code_input": "The given Solidity contract is a simple Ethereum smart contract that allows a participant to withdraw funds from a pre-sale if they have reached the minimum funding requirement. Here's a high-level description of the main functionality and logic:\n\n1. The contract has a function `participantWithdrawIfMinimumFundingNotReached`. This function is called by a participant when they want to withdraw funds.\n\n2. The function first checks if the current time (`now`) is later than the `PRESALE_END_DATE`. If it is, the function reverts, meaning the pre-sale has ended.\n\n3. The function then checks if the `totalFunding` has reached the `PRESALE_MINIMUM_FUNDING`. If it has, the function reverts, meaning the minimum funding requirement has not been met.\n\n4. The function then checks if the balance of the participant's account (`balanceOf[msg.sender]`) is less than the amount they want to withdraw (`_value`). If it is, the function reverts, meaning the participant does not have enough funds.",
        "gt": "contract c30751{ function participantWithdrawIfMinimumFundingNotReached(uint256 _value) external { if (now <= PRESALE_END_DATE) revert(); if (totalFunding >= PRESALE_MINIMUM_FUNDING) revert(); if (balanceOf[msg.sender] < _value) revert(); balanceOf[msg.sender] = safeDecrement(balanceOf[msg.sender], _value); if (!msg.sender.send(_value)) revert(); } }",
        "url": 797
    },
    {
        "code_input": "class TokenClaim:\n    def __init__(self, owner):\n        self.owner = owner\n\n    def claimTokensFor(self, to):\n        # This is a placeholder for the actual function that claims tokens.\n        # In a real contract, this function would interact with a smart contract\n        # that manages the tokens, and it would require authentication.\n        # For the sake of this example, we'll just print a message.\n        print(f\"Claiming tokens for {to}\")\n\n# In a real contract, the owner would be set when the contract is deployed.\n# Here, we're assuming that the owner is the address that deployed the contract.\ntoken_claim = TokenClaim(owner=\"0x123456789012345678901",
        "gt": "contract c12395{ function claimTokensFor(address _to) public onlyOwner { claim(_to); } }",
        "url": 798
    },
    {
        "code_input": "The given Solidity code is a contract for a cryptocurrency named \"c746\". The contract has a function `mint` that allows the owner to mint new coins. Here's a high-level description of the main functionality and logic of the code:\n\n1. The `mint` function is declared as `public`, meaning it can be called by anyone.\n2. The `onlyOwner` modifier is used to restrict the function to the owner of the contract.\n3. The `require` function is used to check if the `beingEdited` array has been set to `true` for the owner. If not, the function sets `beingEdited[owner]` to `true` and calls `setEditedTrue(owner)`.\n4. The `totalCoinSupply` variable is incremented by the amount of coins being minted.\n5. The `balances` array is incremented by the amount of coins being minted.\n6. The `setEditedFalse(owner)` function is called to unset `beingEdited[owner]` to `false`.\n\nHere's a Python code that demonstrates the",
        "gt": "contract c746{ function mint(uint amount) public onlyOwner { require(beingEdited[owner] != true); setEditedTrue(owner); totalCoinSupply = SafeMath.add(totalCoinSupply, amount); balances[owner] = SafeMath.add(balances[owner], amount); setEditedFalse(owner); } }",
        "url": 799
    },
    {
        "code_input": "class C38774:\n    def __init__(self, startBlock):\n        self.startBlock = startBlock\n\n    def is_started(self):\n        return block.number >= self.startBlock",
        "gt": "contract c38774{ function isStarted() constant returns(bool) { return block.number >= startBlock; } }",
        "url": 800
    },
    {
        "code_input": "def valid_transcoding_options(transcoding_options):\n    transcoding_options_length = len(transcoding_options)\n    return transcoding_options_length > 0 and transcoding_options_length % VIDEO_PROFILE_SIZE == 0",
        "gt": "contract c16365{ function validTranscodingOptions(string _transcodingOptions) public pure returns (bool) { uint256 transcodingOptionsLength = bytes(_transcodingOptions).length; return transcodingOptionsLength > 0 && transcodingOptionsLength % VIDEO_PROFILE_SIZE == 0; } }",
        "url": 801
    },
    {
        "code_input": "def calculate_points_block(amount, game_finished_time, last_checked_token, tokens, token_to_points_map, worst_tokens, aux_worst_points):\n    if game_finished_time != 0:\n        return\n    if last_checked_token + amount > len(tokens):\n        return\n    for i in range(last_checked_token, last_checked_token + amount):\n        points = calculate_token_points(tokens[i])\n        token_to_points_map[i] = points\n        if len(worst_tokens) == 0 or points <= aux_worst_points:\n            if len(worst_tokens) != 0 and points < aux_worst_points:\n                worst_tokens = []\n            if len(worst_tokens) < 100:\n                aux_",
        "gt": "contract c13665{ function calculatePointsBlock(uint32 amount) external{ require (gameFinishedTime == 0); require(amount + lastCheckedToken <= tokens.length); for (uint256 i = lastCalculatedToken; i < (lastCalculatedToken + amount); i++) { uint16 points = calculateTokenPoints(tokens[i]); tokenToPointsMap[i] = points; if(worstTokens.length == 0 || points <= auxWorstPoints){ if(worstTokens.length != 0 && points < auxWorstPoints){ worstTokens.length = 0; } if(worstTokens.length < 100){ auxWorstPoints = points; worstTokens.push(i); } } } lastCalculatedToken += amount; } }",
        "url": 802
    },
    {
        "code_input": "class C9839:\n    def __init__(self, web3, owner):\n        self.web3 = web3\n        self.owner = owner\n        self.receivedTokens = {}\n\n    def removeReceivedToken(self, _tokenAddress):\n        if _tokenAddress != '0x0000000000000000000000000000000000000000':\n            del self.receivedTokens[_tokenAddress]\n            self.web3.eth.emit('RemoveReceivedToken', _token",
        "gt": "contract c9839{ function removeReceivedToken(ERC20 _tokenAddress) onlyOwner external { require(_tokenAddress != address(0)); delete receivedTokens[_tokenAddress]; emit RemoveReceivedToken(_tokenAddress); } }",
        "url": 803
    },
    {
        "code_input": "The given Solidity contract is a part of a DAO (Decentralized Autonomous Organization) or a governance system. It allows the owner to set an early participant whitelist, which is a list of addresses that can participate in the contract before a certain time.\n\nHere's a high-level description of the main functionality and logic of the code:\n\n1. The contract has a function `setEarlyParticipantWhitelist` that allows the owner to set an early participant whitelist.\n\n2. The function takes four parameters:\n\n   - `addr`: The address of the participant to be added to the whitelist.\n   \n   - `status`: A boolean value indicating whether the participant is allowed to participate or not.\n   \n   - `minCap`: The minimum number of tokens that the participant is allowed to hold.\n   \n   - `maxCap`: The maximum number of tokens that the participant is allowed to hold.\n\n3. The function first checks if the address is not the owner of the contract. If it is, the function throws an error.\n\n4. The function then checks if the `maxCap`",
        "gt": "contract c292{ function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner { if (!isWhiteListed) throw; assert(addr != address(0)); assert(maxCap > 0); assert(minCap <= maxCap); assert(now <= endsAt); if (!isAddressWhitelisted(addr)) { whitelistedParticipants.push(addr); Whitelisted(addr, status, minCap, maxCap); } else { WhitelistItemChanged(addr, status, minCap, maxCap); } earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap}); } }",
        "url": 804
    },
    {
        "code_input": "class Contract:\n    def __init__(self, contract_address):\n        self.contract_address = contract_address\n        self.web3 = Web3(Web3.HTTPProvider('http://localhost:8545'))  # Use your Ethereum node URL\n        self.contract = self.web3.eth.contract(address=self.contract_address, abi=ABI)\n\n    def add_additional_bonus_member(self, wallet):\n        \"\"\"\n        This function is used to add a new member to the `additionalBonusOwnerState` mapping.\n        \"\"\"\n        # Check if the contract owner has the necessary permissions\n        if not self.contract.functions.onlyOwner().call",
        "gt": "contract c18058{ function addAdditionalBonusMember(address _wallet) public onlyOwner { additionalBonusOwnerState[_wallet] = AdditionalBonusState.Active; } }",
        "url": 805
    },
    {
        "code_input": "The given Solidity code is a contract function that creates an auction. The function is named `createAuction` and it is public, meaning it can be called by anyone. The function takes in four parameters: `_deedId`, `_startPrice`, `_endPrice`, and `_duration`.\n\nThe first thing the function does is to check if the caller of the function is the owner of the `deedContract` contract. If not, the function will revert the transaction.\n\nThe function then creates an `Auction` object with the following parameters: `deedOwner`, `_startPrice`, `_endPrice`, `_duration`, and `now`.\n\nThe `_escrow` function is a function that is not defined in the provided code, but it seems to be used to handle the escrowing of funds for the auction. If this function is not defined, it would be necessary to provide a demonstration of its main logic.\n\nThe `_createAuction` function is also not defined, but it seems to be used to create the auction. If this function is not defined, it would be necessary to provide a demonstration of its",
        "gt": "contract c27549{ function createAuction(uint256 _deedId, uint256 _startPrice, uint256 _endPrice, uint256 _duration) public fitsIn128Bits(_startPrice) fitsIn128Bits(_endPrice) fitsIn64Bits(_duration) whenNotPaused { address deedOwner = deedContract.ownerOf(_deedId); require( msg.sender == address(deedContract) || msg.sender == deedOwner ); require(_duration >= 60); _escrow(_deedId); Auction memory auction = Auction( deedOwner, uint128(_startPrice), uint128(_endPrice), uint64(_duration), uint64(now) ); _createAuction(_deedId, auction); } }",
        "url": 806
    },
    {
        "code_input": "class C20237:\n    def __init__(self):\n        self.holders = []\n        self.holder_number = {}\n\n    def add_holder(self, _holder):\n        if _holder not in self.holder_number:\n            self.holders.append(_holder)\n            self.holder_number[_holder] = len(self.holders)",
        "gt": "contract c20237{ function addHolder(address _holder) internal { if (holderNumber[_holder] == 0) { holders.push(_holder); holderNumber[_holder] = holders.length; } } }",
        "url": 807
    },
    {
        "code_input": "class c11074:\n    def __init__(self):\n        self.assets = {}  # This is a placeholder for the actual asset data.\n\n    def is_created(self, _symbol):\n        return _symbol in self.assets and self.assets[_symbol]['owner'] != 0",
        "gt": "contract c11074{ function isCreated(bytes32 _symbol) public view returns (bool) { return assets[_symbol].owner != 0; } }",
        "url": 808
    },
    {
        "code_input": "class C20237:\n    def __init__(self, owner):\n        self.owner = owner\n\n    def withdraw_ether(self, amount):\n        if self.owner.balance < amount:\n            raise ValueError(\"Insufficient balance\")\n        self.owner.transfer(amount)",
        "gt": "contract c20237{ function withdrawEther(uint256 _amount) onlyOwner public { require(address(this).balance >= _amount); owner.transfer(_amount); } }",
        "url": 809
    },
    {
        "code_input": "class PetLeaderboard:\n    def __init__(self):\n        # Initialize the leaderboard with an empty dictionary\n        self.pets_on_leaderboards = {}\n\n    def add_pet(self, pet_id):\n        # Add a pet to the leaderboard\n        self.pets_on_leaderboards[pet_id] = True\n\n    def remove_pet(self, pet_id):\n        # Remove a pet from the leaderboard\n        if pet_id in self.pets_on_leaderboards:\n            del self.pets_on_leaderboards[pet_id]\n\n    def is_pet_on_leaderboard(self, pet_id):",
        "gt": "contract c22337{ function petOnLeaderboards(uint64 petID) external constant returns (bool) { return petsOnLeaderboards[petID]; } }",
        "url": 810
    },
    {
        "code_input": "class Contract:\n    def __init__(self, web3):\n        self.web3 = web3",
        "gt": "contract c19833{ function showTransferConfigs() public constant returns (uint256 _base, uint256 _rate, address _collector, bool _no_transfer_fee, uint256 _minimum_transfer_amount) { (,_base, _rate, _collector, _no_transfer_fee, _minimum_transfer_amount) = gold_token_storage().read_transfer_config(); } }",
        "url": 811
    },
    {
        "code_input": "def _transfer(self, _from, _to, _value):\n    # Check if the sender has enough Ether\n    if self.balanceOf(_from) < _value:\n        raise ValueError(\"Insufficient Ether in the account\")\n\n    # Subtract the Ether from the sender's account\n    self.transfer(_from, _value",
        "gt": "contract c17499{ function serviceTransfer(address _from, address _to, uint _value) external onlyMasters returns (bool success) { return _transfer(_from, _to, _value); } }",
        "url": 812
    },
    {
        "code_input": "class GameContract:\n    def __init__(self, owner, min_house_stake, conflict_res):\n        self.owner = owner\n        self.min_house_stake = min_house_stake\n        self.conflict_res = conflict_res\n        self.house_stake = 0\n        self.house_profit = 0\n\n    def withdraw_house_stake(self, value):\n        min_house_stake = self.conflict_res.min_house_stake(active_games)",
        "gt": "contract c12677{ function withdrawHouseStake(uint value) public onlyOwner { uint minHouseStake = conflictRes.minHouseStake(activeGames); require(value <= houseStake && houseStake - value >= minHouseStake); require(houseProfit <= 0 || uint(houseProfit) <= houseStake - value); houseStake = houseStake - value; owner.transfer(value); } }",
        "url": 813
    },
    {
        "code_input": "The given Solidity code is a contract for a voting system. The contract has a function `switchToNextRound` that is supposed to switch to the next round in the voting system. Here's a high-level description of the function:\n\n1. It first gets the current round ID and increments it by 1.\n2. It checks if the next round ID is within the length of the `rounds` array. If it's not, it throws an error.\n3. It sets the `endTime` of the previous round to the current time.\n4. It sets the `startTime` and `endTime` of the next round to the current time plus 1 and 30 seconds respectively.\n5. If the next round ID is the last one in the array, it subtracts the `tokensIssued` from the `tokensCap`.\n6. If the next round ID is not the last one, it divides the `tokensIssued` by 5 and subtracts it from the `tokensCap`.\n7. It then emits an event indicating that the current round has been switched to the next one.\n\nHere'",
        "gt": "contract c16077{ function switchToNextRound() public { uint256 prevRoundId = currentRoundId; uint256 nextRoundId = currentRoundId + 1; require(nextRoundId < rounds.length); rounds[prevRoundId].endTime = now; rounds[nextRoundId].startTime = now + 1; rounds[nextRoundId].endTime = now + 30; if (nextRoundId == rounds.length - 1) { rounds[nextRoundId].tokensCap = tokensCap.sub(tokensIssued); } else { rounds[nextRoundId].tokensCap = tokensCap.sub(tokensIssued).div(5); } currentRoundId = nextRoundId; emit SwitchedToNextRound(currentRoundId); } }",
        "url": 814
    },
    {
        "code_input": "class Crowdsale:\n    def __init__(self, stage):\n        self.stage = stage\n\n    def set_crowdsale_stage(self, value):\n        if value == 0:\n            self.stage = 'PreICO'\n        elif value == 1:\n            self.stage = 'ICO'\n        return self.stage",
        "gt": "contract c8451{ function setCrowdsaleStage(uint value) public onlyOwner { CrowdsaleStage _stage; if (uint256(CrowdsaleStage.PreICO) == value) { _stage = CrowdsaleStage.PreICO; } else if (uint256(CrowdsaleStage.ICO) == value) { _stage = CrowdsaleStage.ICO; } stage = _stage; } }",
        "url": 815
    },
    {
        "code_input": "def params_valid(unlock_dates, unlock_amounts):\n    if len(unlock_dates) == 0 or len(unlock_dates) != len(unlock_amounts):\n        return False\n    for i in range(len(unlock_amounts) - 1):\n        if",
        "gt": "contract c26716{ function paramsValid() public constant returns (bool) { if (unlockDates.length == 0 || unlockDates.length != unlockAmounts.length) { return false; } for (uint256 i = 0; i < unlockAmounts.length - 1; ++i) { if (unlockAmounts[i] >= unlockAmounts[i + 1]) { return false; } if (unlockDates[i] >= unlockDates[i + 1]) { return false; } } return true; } }",
        "url": 816
    },
    {
        "code_input": "class C2030:\n    def __init__(self, registry):\n        self.registry = registry\n\n    def transfer_domain_ownership(self, node, owner):\n        # Check if the owner is the current owner\n        if self.registry.get_owner(node) != owner:\n            raise ValueError(\"Only the current owner can transfer the ownership.\")\n\n        # Set the new owner\n        self.registry.set_owner(node, owner)",
        "gt": "contract c2030{ function transferDomainOwnership(bytes32 _node, address _owner) public onlyOwner { registry.setOwner(_node, _owner); } }",
        "url": 817
    },
    {
        "code_input": "class WineryContract:\n    def __init__(self, wineries, on_chain_identities):\n        self.wineries = wineries\n        self.on_chain_identities = on_chain_identities\n\n    def add_winery_operation(self, track_id, operation_id, operation_code, operation_date, area_code, icqrf_code):\n        mapping_id = hashlib.sha256((track_id + operation_id).encode()).hexdigest()\n        self.addWineryOperation(mapping_id, self.on_chain_identities[self.msg.sender], self.on_chain_ident",
        "gt": "contract c18325{ function addWineryOperation( string _trackID, string _operationID, string _operationCode, uint _operationDate, uint16 _areaCode, string _codeICQRF ) external wineriesOnly returns (bool success) { bytes32 _mappingID = keccak256(_trackID, msg.sender); addWineryOperation( _mappingID, msg.sender, onChainIdentities[msg.sender].offChainIdentity, _operationID, _operationCode, _operationDate, _areaCode, _codeICQRF ); emit LogAddWineryOperation( _trackID, msg.sender, msg.sender, _operationID, wineries[_mappingID].length ); return true; } }",
        "url": 818
    },
    {
        "code_input": "The provided Solidity code is a contract function that handles the payday of a work crew member. The function is named `payday` and it is called by the work crew member's `employeeId`.\n\nHere's a high-level description of the function's main logic:\n\n1. The function checks if the current time is less than the `lastPayday` plus 15 minutes. If it is, the function reverts, as the payday has not yet occurred.\n\n2. The function checks if the caller of the function is the employee address of the work crew member. If it's not, the function reverts.\n\n3. The function updates the `lastPayday` to the current time.\n\n4. The function calculates the paycheck by dividing the `yearlySalaryUSD` by 7680 (the number of days in a week).\n\n5. The function calculates the transfer amounts for Ether, USD, and ANT tokens.\n\n6. The function transfers the calculated amounts to the employee's address.\n\nHere's a Python code that demonstrates the main logic of the function",
        "gt": "contract c37728{ function payday(uint _employeeId) public onlyEmployee { uint x = employeeIdIndex[_employeeId]; if( now < workcrew[x].lastPayday + 15 minutes ){ revert; } if( msg.sender != workcrew[x].employeeAddress ){ revert; } workcrew[x].lastPayday = now; uint paycheck = workcrew[x].yearlySalaryUSD / 7680; uint usdTransferAmount = paycheck * workcrew[x].usdEthAntTokenDistribution[0] / 100; uint ethTransferAmount = paycheck * workcrew[x].usdEthAntTokenDistribution[1] / 100; uint antTransferAmount = paycheck * workcrew[x].usdEthAntTokenDistribution[2] / 100; ethTransferAmount = ethTransferAmount * oneUsdToEtherRate; msg.sender.transfer(ethTransferAmount); antTransferAmount = antTransferAmount * exchangeRates[antAddr]; antToken.transfer( workcrew[x].employeeAddress, antTransferAmount ); usdToken.transfer( workcrew[x].employeeAddress, usdTransferAmount ); } }",
        "url": 819
    },
    {
        "code_input": "The given Solidity code is a contract for a token sale. It has a function `sell` that allows a user to sell their tokens for a certain price. Here's a high-level description of the main functionality and logic of the code:\n\n1. The `sell` function is a public function that allows users to sell their tokens for a certain price.\n\n2. The function first checks if the user has the necessary permissions to sell tokens. It does this by checking if the user has `buysTokens` set to true or if the user is the contract's owner.\n\n3. If the user has the necessary permissions, the function calculates how many tokens the user can buy for the given amount of money. This is done by dividing the user's balance by the `buyPrice`.\n\n4. The function then calculates how many tokens the user needs to buy. This is done by dividing the amount of money the user wants to sell by the `units`. If the amount the user wants to sell is greater than the user can buy, the function sets the order to be the amount the user can buy.\n\n5. If the order is greater than ",
        "gt": "contract c40120{ function sell(uint256 amount) { if (buysTokens || msg.sender == owner) { uint256 can_buy = this.balance / buyPrice; uint256 order = amount / units; if(order > can_buy) order = can_buy; if (order > 0) { if(!ERC20(asset).transferFrom(msg.sender, address(this), amount)) throw; if(!msg.sender.send(order * buyPrice)) throw; } UpdateEvent(); } } }",
        "url": 820
    },
    {
        "code_input": "def _getTokenAmount(self, _weiAmount):\n    # This is a placeholder for the actual implementation.\n    # It's not guaranteed to work, as the actual implementation depends on the specifics of your contract.\n    return _weiAmount",
        "gt": "contract c21420{ function getTokenAmount(uint256 _weiAmount) public view returns (uint256) { return _getTokenAmount(_weiAmount); } }",
        "url": 821
    },
    {
        "code_input": "class Contract:\n    def __init__(self):\n        pass\n\n    def sub(self, a, b):\n        if b <= a:\n            return a - b\n        else:\n            raise ValueError(\"Second number should be less than or equal to the first number\")\n\n# Test the function\ncontract = Contract()\n\n# Test with valid input\nprint(contract.sub(10, 5))  # Output: 5\n\n# Test with invalid input\ntry:\n    print(contract.sub(5, 10))  # Raises ValueError: Second number should be less than or equal to the first number\nexcept ValueError as e:",
        "gt": "contract c15290{ function sub(uint256 a, uint256 b) internal returns (uint256) { assert(b <= a); return a - b; } }",
        "url": 822
    },
    {
        "code_input": "class Token:\n    def __init__(self, owner, max_supply):\n        self.owner = owner\n        self.max_supply = max_supply\n        self.is_max_supply_locked = False\n\n    def lock_max_supply(self):\n        if self.owner == msg.sender:\n            self.is_max_supply_locked = True\n            self.max_supply(msg.sender, self.max_supply, self.is_max_supply_locked)\n            return True\n        else:\n            return False",
        "gt": "contract c37567{ function lockMaxSupply() notClosed onlyContractOwner noEther returns(bool success) { isMaxSupplyLocked = true; MaxSupply(msg.sender, maxSupply, isMaxSupplyLocked); return true; } }",
        "url": 823
    },
    {
        "code_input": "The given Solidity code is a contract for a token claim system. It allows users to claim tokens based on certain conditions. Here's a high-level description of the main functionality and logic:\n\n1. The contract has a function `claimToken()`. This function is external, meaning it can be called by anyone.\n\n2. The function first checks if the current sale stage is either ICO or Closed. If it's not, the function reverts.\n\n3. If the current sale stage is ICO, the function checks if the IBC (Internet Bridges) funding is equal to the total funding goal in IBC or the current time is greater than the icoEnd. If either of these conditions is true, the function updates the sale stage to Closed. If not, the function reverts.\n\n4. The function then checks if the IBC vault balance of the sender is greater than 0. If it's not, the function reverts.\n\n5. The function calculates the token amount to be claimed based on the IBC vault balance of the sender.\n\n6. If the current time is less than icoEnd + fundingRatePred",
        "gt": "contract c475{ function claimToken() external { require(currentSaleStage == SaleStage.ICO || currentSaleStage == SaleStage.Closed); if (currentSaleStage == SaleStage.ICO) { if (ibcFunded == totalFundingGoalInIBC || now >= icoEnd) { updateSaleStage(SaleStage.Closed); } else { revert(); } } require(ibcVaultBalanceOf[msg.sender] > 0); uint tokenAmount = ibcVaultBalanceOf[msg.sender]; if (now < icoEnd + fundingRatePredictionBonusClaimWindow) { if (fundingRatePredictionBonusPoolInIBC > 0) { uint finalFundingRate = mul(ibcFunded, 100) / totalFundingGoalInIBC; if (finalFundingRate > 100) { finalFundingRate = 100; } if (fundingRatePredictionOf[msg.sender] == finalFundingRate) { if (!fundingRatePredictionBingoOf[msg.sender]) { fundingRatePredictionBingoOf[msg.sender] = true; uint fundingRatePredictionBingoBonus = mul(baseRewardTokenBalanceOf[msg.sender], icoFundingRatePredictionBonusInPercentage) / 100; if (fundingRatePredictionBingoBonus > fundingRatePredictionBonusPoolInIBC) { fundingRatePredictionBingoBonus = fundingRatePredictionBonusPoolInIBC; } fundingRatePredictionBonusPoolInIBC = sub(fundingRatePredictionBonusPoolInIBC, fundingRatePredictionBingoBonus); tokenAmount = add(tokenAmount, fundingRatePredictionBingoBonus); } } } } ibcVaultBalanceOf[msg.sender] = 0; ibcDistributed = add(ibcDistributed, tokenAmount); tokenReward.transfer(msg.sender, tokenAmount); emit TokenClaimed(msg.sender, tokenAmount); } }",
        "url": 824
    },
    {
        "code_input": "class C30811:\n    def __init__(self):\n        self.specialManagerAddressMap = {}\n        self.specialManagerAddressNumberMap = {}\n        self.specialManagerListMap = {}\n        self.specialManagerCountInt = 0\n\n    def specialManagerOn(self, _onSpecialManagerAddress):\n        if _onSpecialManagerAddress in self.specialManagerAddressMap:\n            return False\n        if _onSpecialManagerAddress not in self.specialManagerAddressNumberMap:\n            self.specialManagerAddressNumberMap[_onSpecialManagerAddress] = 0\n        if self.specialManagerAddressNumberMap[_onSpecialManagerAddress] > 0:\n            if not self.specialManagerAddressMap[_onSpecialManagerAddress]:\n                self.specialManagerAddressMap[_onSpecialManagerAddress] = True\n                return True\n        else:\n            self.specialManagerAddressMap[_on",
        "gt": "contract c30811{ function specialManagerOn( address _onSpecialManagerAddress ) external isOwner returns (bool retrnVal) { require( _onSpecialManagerAddress != address(0) ); if ( specialManagerAddressNumberMap[ _onSpecialManagerAddress ]>0 ) { if ( !specialManagerAddressMap[ _onSpecialManagerAddress ] ) { specialManagerAddressMap[ _onSpecialManagerAddress ] = true; retrnVal = true; } else { retrnVal = false; } } else { specialManagerAddressMap[ _onSpecialManagerAddress ] = true; specialManagerAddressNumberMap[ _onSpecialManagerAddress ] = specialManagerCountInt; specialManagerListMap[ specialManagerCountInt ] = _onSpecialManagerAddress; specialManagerCountInt++; retrnVal = true; } } }",
        "url": 825
    },
    {
        "code_input": "class C31919:\n    def __init__(self, owner, periods, t0special):\n        self.owner = owner\n        self.periods = periods\n        self.t0special = t0special\n\n    def init(self, _periods, _t0special):\n        if self.owner != self.msg.sender:\n            revert(\"Only the contract owner can call this function.\")\n        if _periods == 0:\n            revert(\"Periods must be greater than 0.\")\n        self.periods = _periods\n        self.t0special = _t0special",
        "gt": "contract c31919{ function init(uint _periods, uint _t0special) onlyOwner notInitialized { require(_periods != 0); periods = _periods; t0special = _t0special; } }",
        "url": 826
    },
    {
        "code_input": "class TokenTransferContract:\n    def __init__(self, token, wallet, deposit):\n        self.token = token\n        self.wallet = wallet\n        self.deposit = deposit\n\n    def send_token(self, receiver, amount):\n        # Check if the sender is the wallet\n        if msg.sender != self.wallet:\n            raise ValueError(\"Only the wallet can send tokens.\")\n\n        # Check if the amount to send is less than or equal to the deposit\n        if amount > self.deposit:\n            raise ValueError(\"The amount to send is more than the available deposit.\")\n\n        # Transfer the tokens\n        self.token.transfer(receiver, amount)\n\n        # Update the deposit\n        self.deposit -= amount",
        "gt": "contract c7014{ function sendToken(address _receiver, uint256 _amount) external { require(msg.sender == wallet); require(_amount <= deposit); assert(token.transfer(_receiver, _amount)); deposit = deposit.sub(_amount); } }",
        "url": 827
    },
    {
        "code_input": "def order_calldata_can_match(buy_calldata, buy_replacement_pattern, sell_calldata, sell_replacement_pattern):\n    if len(buy_replacement",
        "gt": "contract c10613{ function orderCalldataCanMatch(bytes buyCalldata, bytes buyReplacementPattern, bytes sellCalldata, bytes sellReplacementPattern) public pure returns (bool) { if (buyReplacementPattern.length > 0) { ArrayUtils.guardedArrayReplace(buyCalldata, sellCalldata, buyReplacementPattern); } if (sellReplacementPattern.length > 0) { ArrayUtils.guardedArrayReplace(sellCalldata, buyCalldata, sellReplacementPattern); } return ArrayUtils.arrayEq(buyCalldata, sellCalldata); } }",
        "url": 828
    },
    {
        "code_input": "class TokenContract:\n    def __init__(self, owner):\n        self.owner = owner\n\n    def propose_ownership(self, new_owner):\n        # Set the new owner\n        self.owner = new_owner\n\n        # Emit the ownership request event\n        self.emit_ownership_requested(self.owner, new_owner)\n\n    def emit_ownership_requested(self, current_owner, new_owner):\n        # This function is not used in the given Solidity code, but it's a common pattern in Ethereum smart contracts\n        print(f\"Ownership request from {current_owner} to {new_owner}\")\n\n# Create",
        "gt": "contract c16844{ function proposeOwnership(address _newOwnerCandidate) public onlyOwner { newOwnerCandidate = _newOwnerCandidate; OwnershipRequested(msg.sender, newOwnerCandidate); } }",
        "url": 829
    },
    {
        "code_input": "class ERC20:\n    def __init__(self, contract_address):\n        self.contract_address = contract_address\n\n    def balanceOf(self, owner):\n        # The function `balanceOf` is a method of the ERC20 contract.\n        # It takes an address as an argument and returns the balance of the address.\n        # This is a mock function, as the actual function to be called is not provided.\n        # The balance of the address is returned as a mock value.\n        return 1000  # This is a mock value, it should be replaced with the actual function call to get the balance.\n\n# Create an instance of the ERC20 contract\nerc20 = ERC20('0x...')\n\n# Get the balance of an address\nbalance = erc20.balanceOf('0x...')",
        "gt": "contract c10926{ function balanceOf(address _owner) public constant returns (uint256 balance) { return balances[_owner]; } }",
        "url": 830
    },
    {
        "code_input": "class C35837:\n    def __init__(self, web3, address):\n        self.web3 = web3\n        self.address = address\n        self.contract = None\n\n    def deploy_contract(self):\n        with open(\"C35837.sol\", \"r\") as file:\n            contract_source_code = file.read()\n\n        self.contract = self.web3.eth.contract(\n            abi=contract_source_code,\n            bytecode=contract_source_code\n        )\n\n        self.contract_deployed = self.contract.deploy(\n            transaction={'from': self.web3.eth.accounts[0], 'gas': 3000",
        "gt": "contract c35837{ function payDividends() external { require(investStart == 0); commitDividend(msg.sender); payWallet(); } }",
        "url": 831
    },
    {
        "code_input": "def get_shares_percent_for_period(user_key, date):\n    # Convert the date to a Unix timestamp (seconds since the Unix epoch)\n    date = int(date / 10**9)\n\n    # Get the period index for the given date\n    period_idx = period_date_to_period_idx[date]\n\n    # If the date is 0 and the period index is 0, return 0\n    if date == 0 and period_idx == 0:\n        return 0\n\n    # If the date is 0, set it to the current time\n    if date == 0:\n        date = int(time.time())\n        period_idx = periods_count\n\n    # Get the number of days in the BMC for the user and period\n    bmc_days = get_bm",
        "gt": "contract c9151{ function getSharesPercentForPeriod(bytes32 _userKey, uint _date) public view returns (uint) { uint _periodIdx = periodDate2periodIdx[_date]; if (_date != 0 && _periodIdx == 0) { return 0; } if (_date == 0) { _date = now; _periodIdx = periodsCount; } uint _bmcDays = _getBmcDaysAmountForUser(_userKey, _date, _periodIdx); uint _totalBmcDeposit = _getTotalBmcDaysAmount(_date, _periodIdx); return _totalBmcDeposit != 0 ? _bmcDays * PERCENT_PRECISION / _totalBmcDeposit : 0; } }",
        "url": 832
    },
    {
        "code_input": "class Contract:\n    def __init__(self, sender):\n        self.sender = sender\n\n    def whoAmI(self):\n        return self.sender\n\n# Test the contract\ncontract = Contract('0x1234567890123456789012345678901234567890')\nprint(contract.whoAmI())",
        "gt": "contract c10131{ function whoAmI() public constant returns (address) { return msg.sender; } }",
        "url": 833
    },
    {
        "code_input": "class ExchangeContract:\n    def __init__(self, exchange):\n        self.exchange = exchange\n\n    def only_exchange(self, func):\n        def wrapper(*args, **kwargs):\n            if self.exchange == func.__self__:\n                return func(*args, **kwargs)\n            else:\n                print(\"This function is not available to the exchange contract.\")\n        return wrapper\n\n    def main_function(self):\n        print(\"This is the main function of the exchange contract.\")\n\n# Usage\nexchange = \"0x1234567890123456789012345678901234567890\"\nexchange_contract = ExchangeContract(exchange)\n\n# This will print \"This is",
        "gt": "contract c12756{ modifier onlyExchange() { require(msg.sender == address(exchange)); _; } }",
        "url": 834
    },
    {
        "code_input": "class VestingContract:\n    def __init__(self, grants, kin, totalVesting):\n        self.grants = grants\n        self.kin = kin\n        self.totalVesting = totalVesting\n\n    def calculateVestedTokens(self, grant, now):\n        # This function is not defined in the provided Solidity code.\n        # It's supposed to calculate the number of vested tokens based on the grant and the current time.\n        pass\n\n    def unlockVestedTokens(self, msg):\n        grant = self.grants[msg.sender]\n        if grant.value == 0:\n            return\n        vested = self.calculateVestedTokens(grant, now)\n        if vested == 0:\n            return\n        transferable = vested - grant.transferred\n        if transferable == 0:",
        "gt": "contract c17653{ function unlockVestedTokens() external { Grant storage grant = grants[msg.sender]; require(grant.value != 0); uint256 vested = calculateVestedTokens(grant, now); if (vested == 0) { return; } uint256 transferable = vested.sub(grant.transferred); if (transferable == 0) { return; } grant.transferred = grant.transferred.add(transferable); totalVesting = totalVesting.sub(transferable); kin.transfer(msg.sender, transferable); TokensUnlocked(msg.sender, transferable); } }",
        "url": 835
    },
    {
        "code_input": "def signed_average(a, b):\n    ans = a + b\n    if a > 0 and b > 0 and ans <= 0:\n        raise ValueError(\"The sum of the two numbers is less than or equal to zero\")\n    elif a < 0 and b < 0 and ans >= 0:\n        raise ValueError(\"The sum of the two numbers is greater than or equal to zero\")\n    return ans / 2",
        "gt": "contract c10674{ function signedAverage(int256 a, int256 b) public pure returns (int256) { int256 ans = a + b; if (a > 0 && b > 0 && ans <= 0) { require(false); } if (a < 0 && b < 0 && ans >= 0) { require(false); } return ans / 2; } }",
        "url": 836
    },
    {
        "code_input": "class Contract:\n    def __init__(self, contract_address, abi, web3):\n        self.contract_address = contract_address\n        self.abi = abi\n        self.web3 = web3\n        self.contract = self.web3.eth.contract(address=self.contract_address, abi=self.abi)\n\n    def withdraw_ether(self, amount):\n        # Check if the contract owner has enough Ether\n        balance = self.web3.eth.getBalance(self.contract_address)\n        if balance < amount:\n            raise Exception('",
        "gt": "contract c24005{ function withdrawEther(uint amount) external onlyOwner { withdrawAddress1.transfer(amount / 2); withdrawAddress2.transfer(amount / 2); } }",
        "url": 837
    },
    {
        "code_input": "class ContractManager:\n    def __init__(self, contracts):\n        self.contracts = contracts\n\n    def get_contract(self, contract_name):\n        if contract_name in self.contracts:\n            return self.contracts[contract_name]\n        else:\n            return None",
        "gt": "contract c13478{ function getContract(string _contractName) external view returns (address _contractAddress) { require(contracts[_contractName] != address(0)); _contractAddress = contracts[_contractName]; return _contractAddress; } }",
        "url": 838
    },
    {
        "code_input": "class Contract:\n    def __init__(self):\n        self.balances = {}\n\n    def set_balance(self, _holder, _amount):\n        self.balances[_holder] = _amount",
        "gt": "contract c30167{ function setBalance(address _holder, uint256 _amount) internal { balances[_holder] = _amount; } }",
        "url": 839
    },
    {
        "code_input": "class SSPContract:\n    def __init__(self, sspRegistry):\n        self.sspRegistry = sspRegistry\n\n    def transferSSPRecord(self, key, newOwner):\n        return self.sspRegistry.transfer(key, newOwner, msg.sender)",
        "gt": "contract c35567{ function transferSSPRecord(address key, address newOwner) { sspRegistry.transfer(key, newOwner, msg.sender); } }",
        "url": 840
    },
    {
        "code_input": "class Contract:\n    def __init__(self, owner):\n        self.owner = owner\n\n    def emergency_eth_drain(self, amount):\n        if self.owner.send(amount):\n            return True\n        else:\n            return False",
        "gt": "contract c11005{ function emergencyEthDrain(uint amount) public ownerOnly returns (bool){ return owner.send(amount); } }",
        "url": 841
    },
    {
        "code_input": "def purchaseTokens(beneficiary, value):\n    # Check if the value is at least",
        "gt": "contract c19208{ function purchaseTokens(address _beneficiary) public payable { require(msg.value >= 0.00104 ether); uint _tokens = safeDiv(safeMul(msg.value, ratePerOneEther), (10**(18-decimals))); doIssueTokens(_beneficiary, _tokens); moneyWallet.transfer(this.balance); } }",
        "url": 842
    },
    {
        "code_input": "The given Solidity code is a contract that contains a function `_appendUintToString`. This function takes a string and a uint as input, and returns a string. The function is internal pure, meaning it does not modify the state and can only read data.\n\nThe function works by first determining the maximum length of the string. It then creates a byte array `reversed` of that length. The function then enters a while loop, which continues until the input value is 0. In each iteration of the loop, it calculates the remainder of the input value divided by 10, and then divides the input value by 10. It then adds the remainder to the byte array `reversed`, starting from the first byte.\n\nAfter the loop, it decrements the index `i` to point to the last byte in the reversed array. It then creates a byte array `inStrB` from the input string. It then creates a new byte array `s` of the same length as `inStrB` plus one more byte for the reversed string.\n\nThe function then enters a for loop that iterates over the length of `inStrB`. It copies each byte",
        "gt": "contract c3545{ function _appendUintToString(string _str, uint _value) internal pure returns (string) { uint maxLength = 100; bytes memory reversed = new bytes(maxLength); uint i = 0; while (_value != 0) { uint remainder = _value % 10; _value = _value / 10; reversed[i++] = byte(48 + remainder); } i--; bytes memory inStrB = bytes(_str); bytes memory s = new bytes(inStrB.length + i + 1); uint j; for (j = 0; j < inStrB.length; j++) { s[j] = inStrB[j]; } for (j = 0; j <= i; j++) { s[j + inStrB.length] = reversed[i - j]; } return string(s); } }",
        "url": 843
    },
    {
        "code_input": "The given Solidity code is a function that compensates contributors based on a certain ratio. The function is called `compensateContributors` and it's only accessible to the contract owner (`onlyOwner`). The function takes two parameters: `offset` and `limit`.\n\nThe function first checks if the contract is enabled and the end time is in the past. If not, it throws an error.\n\nThen, it initializes a counter `i` to `offset` and a counter `compensatedCount` to 0. It also gets the total number of contributors and calculates the ratio of contributors to the total amount contributed.\n\nThe function then enters a while loop that continues until `i` is less than the total number of contributors and `compensatedCount` is less than the `limit`.\n\nIn each iteration of the loop, it gets the address of the `i`-th contributor and checks if they have not been compensated. If they haven't, it calculates the amount they have contributed and sets this amount as the amount they will receive. It then transfers this amount to the contributor's address.\n\nFinally, it",
        "gt": "contract c38416{ function compensateContributors(uint offset, uint limit) onlyOwner { require(isEnabled); require(endTime < now); uint i = offset; uint compensatedCount = 0; uint contributorsCount = contributorsKeys.length; uint ratio = CONTRIB_PERIOD1_STAKE .mul(1000000000000000000) .div(totalContributed); while (i < contributorsCount && compensatedCount < limit) { address contributorAddress = contributorsKeys[i]; if (!contributors[contributorAddress].isCompensated) { uint amountContributed = contributors[contributorAddress].amount; contributors[contributorAddress].isCompensated = true; contributors[contributorAddress].amountCompensated = amountContributed.mul(ratio).div(1000000000000000000); district0xNetworkToken.transfer(contributorAddress, contributors[contributorAddress].amountCompensated); onCompensated(contributorAddress, contributors[contributorAddress].amountCompensated); compensatedCount++; } i++; } } }",
        "url": 844
    },
    {
        "code_input": "class C23606:\n    def __init__(self, web3, address):\n        self.web3 = web3\n        self.address = address\n        self.is_destroyer = web3.eth.contract(address=address, abi=['function isDestroyer(address) external view returns (bool)']).functions.isDestroyer(self.address).call()\n\n    def remove_destroyer(self):\n        if self.is_destroyer:\n            self.web3.eth.contract(address=self.address, abi=['function removeDestroyer(address) external onlyEtheraffle']).functions.removeDestroyer(self.address).transact()\n            self.is_destroyer = False\n        else:\n            print(\"The address is not a destroyer\")",
        "gt": "contract c23606{ function removeDestroyer(address _destroyer) external onlyEtheraffle { require(isDestroyer[_destroyer]); isDestroyer[_destroyer] = false; for(uint i = 0; i < destroyers.length - 1; i++) if(destroyers[i] == _destroyer) { destroyers[i] = destroyers[destroyers.length - 1]; break; } destroyers.length--; LogDestroyerRemoval(_destroyer, now); } }",
        "url": 845
    },
    {
        "code_input": "from web3 import Web",
        "gt": "contract c19950{ function enterBidForGanToken(uint256 tokenId) external payable { Bid memory existing = tokenBids[tokenId]; require(tokenIdToOwner[tokenId] != msg.sender); require(tokenIdToOwner[tokenId] != 0x0); require(msg.value > existing.value); if (existing.value > 0) { pendingWithdrawals[existing.bidder] += existing.value; } tokenBids[tokenId] = Bid(true, tokenId, msg.sender, msg.value); emit BidForGanTokenOffered(tokenId, msg.value, msg.sender); } }",
        "url": 846
    },
    {
        "code_input": "class ERC20Interface:\n    def __init__(self, address):\n        self.address = address\n\n    def balanceOf(self, account):\n        # This is a placeholder for the actual function.\n        # It should be replaced with the actual function of the ERC20 token.\n        return 0\n\n\nclass Contract:\n    def __init__(self, faucet_token_address):\n        self.faucet_token_address = faucet_token_address\n\n    def tokenBalance(self):\n        # Create an instance of the ERC20Interface using the faucet token address.\n        erc20_interface = ERC20Interface(self.faucet_token_address)\n\n        # Call the balanceOf function on the ERC20Interface.\n        # This is a placeholder for the",
        "gt": "contract c8498{ function tokenBalance() public view returns (uint) { return ERC20Interface(faucetTokenAddress).balanceOf(this); } }",
        "url": 847
    },
    {
        "code_input": "class Token:\n    def __init__(self):\n        self.price = 0\n\n    def set_price(self, price):\n        if price == 0:\n            raise ValueError(\"Price cannot be zero\")\n        self.price = price\n\n    def get_price(self):\n        return self.price",
        "gt": "contract c35282{ function setPrice(uint price) public onlyOwner { require( price != 0); PRICE = price; StateChanged(true); } }",
        "url": 848
    },
    {
        "code_input": "def odds_single(matches_index):\n    # This function calculates the odds of winning a single match\n    # It's a placeholder and doesn't actually do anything\n    return matches_index\n\ndef odds_total(num_winners, matches_index):\n    # This function calculates the total odds of winning all matches\n    # It multiplies the odds of winning a single match by the number of winners\n    return odds_single(matches_index) * num_winners",
        "gt": "contract c18688{ function oddsTotal(uint _numWinners, uint _matchesIndex) internal view returns (uint) { return oddsSingle(_matchesIndex) * _numWinners; } }",
        "url": 849
    },
    {
        "code_input": "class C8644:\n    def __init__(self, web3, address):\n        self.web3 = web3\n        self.address = address\n        self.contract = None\n\n    def deploy(self):\n        with open(\"C8644.sol\", \"r\") as file:\n            contract_source_code = file.read()\n\n        self.contract = self.web3.eth.contract(\n            abi=contract_source_code,\n            bytecode=contract_source_code\n        )\n\n        self.contract_deployed = self.contract.deploy(\n            transaction={'from': self.web3.eth",
        "gt": "contract c8644{ function withdraw(uint256 amount) onlyOwner public { require(address(this).balance >= amount); owner.transfer(amount); } }",
        "url": 850
    },
    {
        "code_input": "The given Solidity code is a contract for an art marketplace. The contract has a function `originalArtwork` that is used to create a new tulip (a type of artwork) in the marketplace. The function takes two parameters: `_genome`, which is the genome of the artwork, and `_owner`, which is the address of the owner of the artwork.\n\nThe function first checks if the `_owner` address is `address(0)`, if it is, it assigns the `msg.sender` address to `newOwner`. Then it checks if the current block number is greater than the block number of the first tulip (`tulips[0].block`) plus 1200 (1 month in blocks). If it is, it requires the caller to be the contract owner and checks if the `originalCount` is less than the limit of 100 original artwork. If it is, it increments `originalCount`.\n\nIf the condition is not met, the function checks if the value sent with the transaction is greater than the `artistFees` and if the `_virtualLength` of the caller",
        "gt": "contract c27746{ function originalArtwork(bytes32 _genome, address _owner) external payable { address newOwner = _owner; if (newOwner == address(0)) { newOwner = msg.sender; } if (block.number > tulips[0].block + MONTHLY_BLOCKS ) { require(msg.sender == owner); require(originalCount < ORIGINAL_ARTWORK_LIMIT); originalCount++; } else { require( (msg.value >= artistFees && _virtualLength[msg.sender] < 10) || msg.sender == owner); } _createTulip(_genome, 0, 0, 0, newOwner); } }",
        "url": 851
    },
    {
        "code_input": "class Contract:\n    def __init__(self, web3):\n        self.web3 = web3\n        self.contract_address = '0x...'  # replace with the actual contract address\n        self.contract = self.web3.eth",
        "gt": "contract c17974{ function massTransfer(address[] _recipients, uint[] _amounts) external returns (bool) { require(_recipients.length == _amounts.length); for (uint i = 0; i < _recipients.length; i++) { require(transfer(_recipients[i], _amounts[i])); } return true; } }",
        "url": 852
    },
    {
        "code_input": "class C40334:\n    def __init__(self, size):\n        self.size = size\n\n    def get_index(self, x, y):\n        if x >= self.size or y >= self.size:\n            raise ValueError(\"Invalid input\")\n        return x * self.size + y",
        "gt": "contract c40334{ function getIndex(uint _x, uint _y) internal returns (uint) { if (_x >= size) throw; if (_y >= size) throw; return _x * size + _y; } }",
        "url": 853
    },
    {
        "code_input": "def slice_bytes20(data, start):\n    slice = 0\n    for i in range(20):\n        slice += (data[i + start] << (8 * (19 - i)))\n    return slice.to_bytes(20, byteorder='big')",
        "gt": "contract c13707{ function sliceBytes20(bytes data, uint start) returns (bytes20) { uint160 slice = 0; for (uint160 i = 0; i < 20; i++) { slice += uint160(data[i + start]) << (8 * (19 - i)); } return bytes20(slice); } }",
        "url": 854
    },
    {
        "code_input": "class ContractResolver:\n    def __init__(self):\n        self.contracts = {}\n\n    def register_contract(self, contract_name, contract_address):\n        self.contracts[contract_name] = contract_address\n\n    def get_contract(self, contract_name):\n        return self.contracts.get(contract_name)\n\n\nclass C19829:\n    def __init__(self, contract_resolver):\n        self.contract_resolver = contract_resolver\n\n    def if_sender_is(self, contract_name):\n        sender_address = self.contract_resolver.get_contract(contract_name)\n        if sender_address is None:",
        "gt": "contract c19829{ modifier if_sender_is(bytes32 _contract) { require(msg.sender == ContractResolver(resolver).get_contract(_contract)); _; } }",
        "url": 855
    },
    {
        "code_input": "class C30283:\n    def __init__(self, armyDronesCount, armyPlanesCount, armyHelicoptersCount, armyTanksCount):\n        self.armyDronesCount = armyDronesCount\n        self.armyPlanesCount = armyPlanesCount\n        self.armyHelicoptersCount = armyHelicoptersCount\n        self.armyTanksCount = armyTanksCount\n\n    def getWeaponsArmy1(self, armyId):\n        CountDrones = self.armyDronesCount[armyId]\n        CountPlanes = self.armyPlanesCount[armyId]\n        CountHelicopters = self.armyHelicoptersCount[armyId]\n        CountTanks = self.armyTanksCount[armyId]\n        return (Count",
        "gt": "contract c30283{ function getWeaponsArmy1(uint armyId) public view returns(uint, uint, uint, uint) { uint CountDrones = armyDronesCount[armyId]; uint CountPlanes = armyPlanesCount[armyId]; uint CountHelicopters = armyHelicoptersCount[armyId]; uint CountTanks = armyTanksCount[armyId]; return (CountDrones, CountPlanes, CountHelicopters, CountTanks); } }",
        "url": 856
    },
    {
        "code_input": "class TokenContract:\n    def __init__(self, owner, price_setter):\n        self.owner = owner\n        self.price_setter = price_setter\n\n    def set_price_setter(self, new_price_setter):\n        if self.owner != self.price_setter:\n            raise Exception(\"Only the owner can set the price setter.\")\n        self.price_setter = new_price_setter",
        "gt": "contract c22470{ function setPriceSetter(address newPriceSetter) external onlyOwner() checkAccess() { m_priceSetter = newPriceSetter; } }",
        "url": 857
    },
    {
        "code_input": "The given Solidity code is a contract for a token with a withdraw function. The withdraw function allows a user to withdraw tokens from the contract. Here's a high-level description of the main functionality and logic:\n\n1. The contract has a function `withdraw` that takes two parameters: `_to`, the address to which the tokens should be sent, and `_amount`, the amount of tokens to withdraw.\n\n2. The function first checks if the `_to` address has enough tokens. If it does, it will proceed to withdraw the specified amount.\n\n3. If the `_to` address has enough tokens, it will subtract the specified amount from the balance of the `_to` address.\n\n4. It will also subtract the amount from the total supply of the tokens.\n\n5. It will emit a `FoodWithdrawEvent` with the sender, the `_to` address, a boolean indicating whether the withdrawal was successful, the amount of tokens withdrawn, the amount of tokens left after the withdrawal, and the new balance of the `_to` address.\n\n6. Finally, it will transfer the tokens to the `_to`",
        "gt": "contract c30811{ function withdraw( address _to, uint256 _amount ) external isSpecialManagerOrOwner returns ( bool returnVal, uint256 withdrawValue, uint256 newBalancesValue ) { if ( balances[ _to ] > 0 ) { uint256 amountTmp = _amount; if ( balances[ _to ] < _amount ) { amountTmp = balances[ _to ]; } balances[ _to ] = safeSubtract( balances[ _to ], amountTmp ); totalSupply = safeSubtract( totalSupply, amountTmp ); returnVal = true; withdrawValue = amountTmp; newBalancesValue = balances[ _to ]; FoodWithdrawEvent( msg.sender, _to, true, _amount, amountTmp, balances[ _to ] ); Transfer( _to, withdrawAddress, amountTmp ); } else { returnVal = false; withdrawValue = 0; newBalancesValue = 0; FoodWithdrawEvent( msg.sender, _to, false, _amount, 0, balances[ _to ] ); } } }",
        "url": 858
    },
    {
        "code_input": "class C20180:\n    def __init__(self):\n        self.betterBettingInfo = {}\n\n    def checkDuplicateMatchId(self, _better, _matchId, _bettingPrice):\n        if _better in self.betterBettingInfo:\n            for info in self.betterBettingInfo[_better]:\n                if info['matchId'] == _matchId and info['bettingPrice'] == _bettingPrice:\n                    return True\n        return False",
        "gt": "contract c20180{ function checkDuplicateMatchId(address _better, uint256 _matchId, uint _bettingPrice) public view returns (bool) { uint numOfBetterBettingInfo = betterBettingInfo[_better].length; for (uint i = 0; i < numOfBetterBettingInfo; i++) { if (betterBettingInfo[_better][i].matchId == _matchId && betterBettingInfo[_better][i].bettingPrice == _bettingPrice) { return true; } } return false; } }",
        "url": 859
    },
    {
        "code_input": "class Contract:\n    def safe_mul(self, x, y):\n        if x == 0:\n            return 0\n        p = x * y\n        if p / x != y:\n            raise ValueError(\"Safe mul failed\")\n        return p",
        "gt": "contract c592{ function safeMul(uint x, uint y) pure internal returns (uint) { if (x == 0) { return 0; } uint p = x * y; require(p / x == y, \"Safe mul failed\"); return p; } }",
        "url": 860
    },
    {
        "code_input": "class C32182:\n    def __init__(self, owner):\n        self.owner = owner\n\n    def only_owner(self, func):\n        def wrapper(*args, **kwargs):\n            if args[0].sender != self.owner:\n                return func(*args, **kwargs)\n            else:\n                raise ValueError(\"Only the contract owner can modify the contract's state\")\n        return wrapper\n\n    @only_owner\n    def modify_state(self, new_owner):\n        self.owner = new_owner",
        "gt": "contract c32182{ modifier onlyOwner() { require(msg.sender != owner); _; } }",
        "url": 861
    },
    {
        "code_input": "class Contract:\n    def __init__(self, contract_address):\n        self.contract_address = contract_address\n\n    def angel_on_leaderboards(self, angel_id):\n        # This function is used to check if an angel is on the leaderboards.\n        # The angel_id is the ID of the angel.\n        # The function returns True if the angel is on the leaderboards, False otherwise.\n        # This is a placeholder function, as the actual implementation of the function is not provided.\n        return False\n\n# Create an instance of the contract\ncontract = Contract('0x...')\n\n# Call the function to check if an angel is on the leaderboards\nprint(contract.angel_on_leaderboards(1))",
        "gt": "contract c22337{ function angelOnLeaderboards(uint64 angelID) external constant returns (bool) { return angelsOnLeaderboards[angelID]; } }",
        "url": 862
    },
    {
        "code_input": "class C14750:\n    def __init__(self, order_library, safe_math):\n        self.order_library = order_library\n        self.safe_math = safe_math\n\n    def available_amount(self, order, hash):\n        return self.safe_math.min256(\n            order.taker_token_amount.sub(self.fills[hash]),\n            self.vault.balance_of(order.maker_token, order.maker).mul(order.taker_token_amount).div(order.maker_token_amount)\n        )",
        "gt": "contract c14750{ function availableAmount(OrderLibrary.Order memory order, bytes32 hash) internal view returns (uint) { return SafeMath.min256( order.takerTokenAmount.sub(fills[hash]), vault.balanceOf(order.makerToken, order.maker).mul(order.takerTokenAmount).div(order.makerTokenAmount) ); } }",
        "url": 863
    },
    {
        "code_input": "class DecentralizedWithdrawal:\n    def __init__(self, contract, owner, owners, SafeMath):\n        self.contract = contract\n        self.owner = owner\n        self.owners = owners\n        self.SafeMath = SafeMath\n\n    def permissibleWithdrawal(self, amount):\n        # This function should check if the amount is permissible to be withdrawn\n        # For now, we'll just return True\n        return True\n\n    def devWithdraw(self, amount):\n        # Check if the caller is the owner\n        if self.owner != msg.sender:\n            return\n\n        # Check if the amount is permissible\n        if not self.permissibleWithdrawal(amount):\n            return\n\n        # Calculate the amount per person\n        amountPerPerson =",
        "gt": "contract c14989{ function devWithdraw(uint amount) public onlyWallet { require(permissibleWithdrawal(amount)); uint amountPerPerson = SafeMath.div(amount, owners.length); for (uint i=0; i<owners.length; i++) { owners[i].transfer(amountPerPerson); } emit DevWithdraw(amount, amountPerPerson); } }",
        "url": 864
    },
    {
        "code_input": "class C807:\n    def __init__(self):\n        self.transfers_allowed = True\n\n    def transfer_from(self, _from, _to, _value):\n        if self.transfers_allowed:\n            print(f\"Transfer from {_from} to {_to} with value {_value} is allowed\")",
        "gt": "contract c807{ function transferFrom(address _from, address _to, uint256 _value) public transfersAllowed returns (bool success) { assert(super.transferFrom(_from, _to, _value)); return true; } }",
        "url": 865
    },
    {
        "code_input": "class Token:\n    def __init__(self, owner, min_wei_amount):\n        self.owner = owner\n        self.min_wei_amount = min_wei_amount\n\n    def set_min_wei_amount(self, new_min_wei_amount):\n        if new_min_wei_amount <= 0 or new_min_wei_amount % 10 != 0:\n            raise ValueError(\"Minimum wei amount must be greater than 0 and a multiple of 10\")\n        old_min_wei_amount = self.min_wei_amount\n        self.min_wei_amount = new_min_wei_amount\n        print(f\"Minimum wei amount",
        "gt": "contract c1384{ function setMinWeiAmount(uint newMinWeiAmount) external onlyOwner whenNotPaused returns(bool) { require(newMinWeiAmount > 0); require(newMinWeiAmount % 10 == 0); uint oldMinWeiAmount = minWeiAmount; minWeiAmount = newMinWeiAmount; emit LogMinWeiAmountChanged(oldMinWeiAmount, minWeiAmount, msg.sender); return true; } }",
        "url": 866
    },
    {
        "code_input": "class GameLogic:\n    def __init__(self):\n        pass\n\n    def currentRound(self):\n        # This is a placeholder for the actual implementation.\n        # In a real game, this function would return the address of the current round.\n        return \"0x0\"\n\n# Instantiate the game logic class\ngame_logic = GameLogic()\n\n# Call the current round function\ncurrent_round = game_logic.currentRound()\n\nprint(f\"The current round is: {current_round}\")",
        "gt": "contract c39674{ function currentRound() constant returns(address) { return gameLogic.currentRound(); } }",
        "url": 867
    },
    {
        "code_input": "class PublishingSystem:\n    def __init__(self, publishing_owner, max_tokens_per_article, min_seconds_between_publishing):\n        self.publishing_owner = publishing_owner\n        self.max_tokens_per_article = max_tokens_per_article\n        self.min_seconds_between_publishing = min_seconds_between_publishing\n        self.time_of_last_publish = None\n        self.num_articles_published = 0\n        self.article_key_hash_register = {}\n        self.published_register = {}\n\n    def publish(self, article_hash, key_hash, num_tokens):\n        if msg.sender != self.publishing_owner:\n            return self.PublishResult(1)\n        elif num_tokens > self.max_tokens_per_article:",
        "gt": "contract c11899{ function publish(string articleHash, bytes32 keyHash, uint256 numTokens) { if (msg.sender != publishingOwner) { PublishResult(1); throw; } else if (numTokens > maxTokensPerArticle) { PublishResult(2); throw; } else if (block.timestamp - timeOfLastPublish < minSecondsBetweenPublishing) { PublishResult(3); throw; } else if (articleKeyHashRegister[articleHash] != 0) { PublishResult(4); throw; } timeOfLastPublish = block.timestamp; publishedRegister[numArticlesPublished] = articleHash; articleKeyHashRegister[articleHash] = keyHash; numArticlesPublished++; remainingTokensForArticle[articleHash] = numTokens; PublishResult(3); } }",
        "url": 868
    },
    {
        "code_input": "class TokenTransferContract:\n    def __init__(self):\n        self.transfer_status = False\n\n    def start_transfer(self):\n        self.transfer_status = True",
        "gt": "contract c35148{ function startTransfer() public onlyOwner { transferStatus = true; } }",
        "url": 869
    },
    {
        "code_input": "class Contract:\n    def __init__(self, web3, address):\n        self.web3 = web3\n        self.address = address\n        self.contract = web3.eth.contract(address=address, abi=contract_abi)\n\n    def is_admin(self, account):\n        return self.contract.functions.isAdmin(account).call()\n\n    def remove_admin(self, admin):\n        if self.is_admin(admin):\n            self.contract.functions.removeAdmin(admin).transact()\n            return True\n        else:\n            return False",
        "gt": "contract c14478{ function removeAdmin(address _admin) public onlyAdmin returns (bool) { require(address(_admin) != 0); require(isAdmin[_admin]); require(msg.sender != _admin); delete isAdmin[_admin]; return true; } }",
        "url": 870
    },
    {
        "code_input": "class Contract:\n    def __init__(self, pending_admin, admin):\n        self.pending_admin = pending_admin\n        self.admin = admin\n\n    def claim_admin(self, msg_sender):\n        if self.pending_admin == msg_sender:\n            self.admin = self.pending_admin\n            self.pending_admin = None\n            return True\n        return False\n\n# Testing the function\ncontract = Contract(msg.sender, 'admin')\nprint(contract",
        "gt": "contract c10483{ function claimAdmin() public { require(pendingAdmin == msg.sender); AdminClaimed(pendingAdmin, admin); admin = pendingAdmin; pendingAdmin = address(0); } }",
        "url": 871
    },
    {
        "code_input": "class C23:\n    def __init__(self, owner, adminAddr, tokenSaleAddr):\n        self.owner = owner\n        self.adminAddr = adminAddr\n        self.tokenSaleAddr = tokenSaleAddr\n\n    def onlyValidDestination(self, to):\n        valid_addresses = [\n            self.owner,\n            self.adminAddr,\n            self.tokenSaleAddr,\n            to\n        ]",
        "gt": "contract c23{ modifier onlyValidDestination(address to) { require(to != address(0x0) && to != address(this) && to != owner && to != adminAddr && to != tokenSaleAddr); _; } }",
        "url": 872
    },
    {
        "code_input": "class C6443:\n    def __init__(self, contract_instance):\n        self.contract_instance = contract_instance\n\n    def update_minting_agent(self, agent, status):\n        \"\"\"\n        Updates the status of a minting agent.\n\n        Args:\n            agent (str): The address of the minting agent.\n            status (bool): The new status of the minting agent.\n        \"\"\"\n        # Check if the caller is the owner of the contract\n        if self.contract_instance.msg.sender != self.contract_instance.owner:\n            raise ValueError(\"Only the contract owner can update the minting agent status.\")\n\n        # Update the minting agent status\n        self.",
        "gt": "contract c6443{ function updateMintingAgent(address _agent, bool _status) public onlyOwner { mintingAgents[_agent] = _status; } }",
        "url": 873
    },
    {
        "code_input": "class C16197:\n    def __init__(self, total_accounted, current_price, token_cap_phase_one):\n        self.total_accounted = total_accounted\n        self.current_price = current_price\n        self.token_cap_phase_one = token_cap_phase_one\n\n    def current_price(self):\n        # This is a placeholder for the actual function that calculates the current price\n        # It's not provided in the question, so we'll just return a constant value\n        return self.current_price\n\n    def tokens_available(self):\n        _current_cap = self.total_accounted / self.current_price()\n        if _current_cap >= self.token",
        "gt": "contract c16197{ function tokensAvailable() public constant when_active only_in_phase_1 returns (uint256 tokens) { uint256 _currentCap = totalAccounted.div(currentPrice()); if (_currentCap >= tokenCapPhaseOne) { return 0; } return tokenCapPhaseOne.sub(_currentCap); } }",
        "url": 874
    },
    {
        "code_input": "The given Solidity contract is for a token contract, and it's used to finalize the ownership of a child contract. Here's a high-level description of the main functionality and logic:\n\n1. The contract has a function `finalizeTransferChildrenOwnership()`. This function is only accessible to the contract's owner (`onlyAdminOrOwner`) and the contract's current owner (`admin`).\n\n2. The function first checks if the `transferOwnershipOperation` exists. If it does not, the function will fail.\n\n3. The function then checks if the `deferBlock` of the `transferOwnershipOperation` is less than or equal to the current block number. If it is, the function will fail.\n\n4. The function then assigns the `newOwner` of the `transferOwnershipOperation` to the `newOwner` variable.\n\n5. The function then deletes the `transferOwnershipOperation`.\n\n6. The function then calls the `transferOwnership()` function of the `child` contract, passing the `newOwner` as an argument. This function transfers the ownership of the",
        "gt": "contract c26137{ function finalizeTransferChildrenOwnership() public onlyAdminOrOwner { require(transferOwnershipOperation.admin == admin); require(transferOwnershipOperation.deferBlock <= block.number); address newOwner = transferOwnershipOperation.newOwner; delete transferOwnershipOperation; child.transferOwnership(newOwner); canBurnWhiteList.transferOwnership(newOwner); canReceiveMintWhitelist.transferOwnership(newOwner); blackList.transferOwnership(newOwner); } }",
        "url": 875
    },
    {
        "code_input": "class C4165:\n    def __init__(self):\n        self.stake_dict = {}\n\n    def createStake(self, _user, _amount, _duration, _data):\n        # This function is not defined in the contract, it's a placeholder\n        pass\n\n    def stakeFor(self, _user, _amount, _data):\n        # Check if the user has enough balance\n        if _user in self.stake_dict:\n            if self.stake_dict[_user] < _amount:\n                return \"Insufficient balance\"\n        else:\n            self.stake_dict[_user] = 0\n\n        # Update the balance\n        self.stake_dict[_",
        "gt": "contract c4165{ function stakeFor(address _user, uint256 _amount, bytes _data) public { createStake( _user, _amount, defaultLockInDuration, _data); } }",
        "url": 876
    },
    {
        "code_input": "def _placeBid(self, _AuctionId, _bid):\n    if self.setBid(_AuctionId, _bid):\n        SoldAuc = self.AuctionIds[_AuctionId]\n        if SoldAuc.isSpawn:\n            SoldTokenId = SoldAuc.TokenId\n            self.tokenBackground[SoldTokenId] = rand(1, maxIdBackground, uint64(SoldTokenId + SpawnCycles(_AuctionId)))\n            self.tokenLock[SoldTokenId] = rand(1",
        "gt": "contract c26793{ function _placeBid(uint64 _AuctionId, uint256 _bid) private returns (bool) { if(setBid(_AuctionId, _bid)){ var SoldAuc = AuctionIds[_AuctionId]; if(SoldAuc.isSpawn){ var SoldTokenId = SoldAuc.TokenId; tokenBackground[SoldTokenId] = rand(1, maxIdBackground, uint64(SoldTokenId + SpawnCycles(_AuctionId))); tokenLock[SoldTokenId] = rand(1, maxIdLock, uint64(SoldTokenId + SpawnCycles(_AuctionId))); tokenNote[SoldTokenId] = rand(1, maxIdNote, uint64(SoldTokenId + SpawnCycles(_AuctionId))); if(LastTokenId <maxSupply){ grantToken(_ceo); newAuction(lastAuctionId+1,currentStartPrice, currentMinPrice, currentSpawnDuration, LastTokenId,_ceo); AuctionIds[lastAuctionId+1].isSpawn = true; lastAuctionId = lastAuctionId +1; } } return true; } return false; } }",
        "url": 877
    },
    {
        "code_input": "class Token:\n    def __init__(self, owner, approver):\n        self.owner = owner\n        self.approver = approver\n\n    def approve_to_mint(self, value):\n        if self.owner == self.approver:\n            return False\n        else:\n            self.owner.approve(self.approver, value)\n            return True",
        "gt": "contract c27770{ function approveToMint(uint256 _value) external whenNotPaused returns (bool) { return approve(theCoin, _value); } }",
        "url": 878
    },
    {
        "code_input": "class PricingStrategy:\n    def set_pricing_strategy(self, new_strategy):\n        # This is a placeholder for the actual implementation of the setPricingStrategy function\n        # It would depend on the actual implementation of the PricingStrategy contract\n        self.pricing_strategy = new_strategy\n        return True\n\nclass Contract:",
        "gt": "contract c11368{ function setPricingStrategy(IPricingStrategy _pricingStrategy) external onlyOwner returns (bool) { pricingStrategy = _pricingStrategy; return true; } }",
        "url": 879
    },
    {
        "code_input": "def assertEquals(expected_value, actual_value):\n    if expected_value != actual_value:\n        raise ValueError(\"Expected value is not equal to actual value\")\n\n# Test the function\ntry:\n    assertEquals(1, 1)\nexcept ValueError as e:\n    print(e)\n\ntry:\n    assertEquals(1, 2)\nexcept ValueError as e:\n    print(e)",
        "gt": "contract c30751{ function assertEquals(uint256 expectedValue, uint256 actualValue) private pure { if (expectedValue != actualValue) revert(); } }",
        "url": 880
    },
    {
        "code_input": "class C23372:\n    def __init__(self, web3, accounts):\n        self.web3 = web3\n        self.accounts = accounts\n\n    def create_identity(self, owner, recovery_key):\n        proxy = self.web3.eth.contract(address='0x0000000000000000000000000000000000000000')\n        tx_hash = proxy.functions.createIdentity(owner, recovery_key).transact()\n        tx_receipt = self.web3.eth.waitForTransactionReceipt(tx_hash)",
        "gt": "contract c23372{ function createIdentity(address owner, address recoveryKey) public validAddress(recoveryKey) { Proxy identity = new Proxy(); owners[identity][owner] = now - adminTimeLock; recoveryKeys[identity] = recoveryKey; LogIdentityCreated(identity, msg.sender, owner, recoveryKey); } }",
        "url": 881
    },
    {
        "code_input": "",
        "gt": "contract c17859{ function skip() public onlyOwner { Participant memory skipped = participants[payoutOrder]; emit ContinuityBreak(payoutOrder, skipped.etherAddress, skipped.payout); if(appeals[skipped.etherAddress].length == appealPosition[skipped.etherAddress]){ appeals[skipped.etherAddress].push(payoutOrder); }else{ appeals[skipped.etherAddress][appealPosition[skipped.etherAddress]] = payoutOrder; } appealPosition[skipped.etherAddress] += 1; payoutOrder += 1; } }",
        "url": 882
    },
    {
        "code_input": "class Contract:\n    def __init__(self, successor):\n        self.successor = successor\n\n    def set_successor(self, successor):\n        if successor != '0x0000000000000000000000000000000000000000':\n            self.successor = successor\n        else:\n            raise ValueError(\"The address cannot be the zero address\")",
        "gt": "contract c11668{ function setSuccessor(address successor_) public isAdmin { require(successor_ != address(0)); successor = successor_; } }",
        "url": 883
    },
    {
        "code_input": "class Contract:\n    def __init__(self, members):\n        self.members = members\n\n    def member_profit_share(self, sender):\n        \"\"\"\n        This function returns the profit share of a member.\n        \"\"\"\n        return self.members[sender]['profitShare']\n\n# Example usage:\ncontract = Contract({\n    '0x1234567890123456789012345678901234567890': {\n        'profitShare': 1000000000000000000000000000000000000000000000000000000",
        "gt": "contract c25060{ function memberProfitShare() public view returns (uint256) { return members[msg.sender].profitShare; } }",
        "url": 884
    },
    {
        "code_input": "class Contract:\n    def __init__(self, txRegistry):\n        self.txRegistry = txRegistry\n\n    def is_spent_tx_payment_for_mcw(self, _tx_payment_for_mcw):\n        is_spent = False\n        if _tx_payment_for_mcw in self.txRegistry and self.txRegistry[_tx_payment_for_mcw]['timestampPaymentKWh'] != 0:\n            is_spent = True\n        return is_spent",
        "gt": "contract c900{ function isSpentTxPaymentForMCW(bytes32 _txPaymentForMCW) public view returns(bool) { bool isSpent = false; if (txRegistry[_txPaymentForMCW].timestampPaymentKWh != 0) { isSpent = true; } return isSpent; } }",
        "url": 885
    },
    {
        "code_input": "def set_free_mem():\n    # The function does not interact with the state of the blockchain,\n    # and it does not modify the state, so it does not have any side effects.\n    # The function is marked as 'private' and 'pure', which means it does not modify the state of the blockchain.",
        "gt": "contract c508{ function setFreeMem() private pure { assembly { mstore(0x40, msize) } } }",
        "url": 886
    },
    {
        "code_input": "class TokenSale:\n    def __init__(self, total_supply, wallets, roles, accountant, token):\n        self.total_supply = total_supply\n        self.wallets = wallets\n        self.roles = roles\n        self.accountant = accountant\n        self.token = token\n        self.TokenSale",
        "gt": "contract c25612{ function fastTokenSale(uint256 _totalSupply) public { require(wallets[uint8(Roles.manager)] == msg.sender); require(TokenSale == TokenSaleType.round1 && !isInitialized); token.mint(wallets[uint8(Roles.accountant)], _totalSupply); TokenSale = TokenSaleType.round2; } }",
        "url": 887
    },
    {
        "code_input": "class C21374:\n    def __init__(self, web3, address):\n        self.web3 = web3\n        self.address = address\n        self.contract = None\n\n    def deploy(self):\n        with open(\"C21374.sol\") as f:\n            code = f.read()\n\n        self.contract = self.web3.eth.contract(code=code)\n\n    def remove_whitelist(self, _white):\n        if self.contract is None:\n            raise Exception(\"Contract not deployed yet\")",
        "gt": "contract c21374{ function removeWhitelist(address _white) public onlyOwner { whitelisted[_white] = false; } }",
        "url": 888
    },
    {
        "code_input": "The provided Solidity code is a contract for a fighter tournament. It includes several functions, including `processSeason`, `_getFightData`, `_localFight`, `_bonusToPartners`, `_bonusToFighters`, `_bonusToBettor`, `_addMoney`, `doLogFighter`, `clearTheSeason`, and `_seasonNone`.\n\nHere's a high-level description of the main functionality and logic of the code:\n\n1. `processSeason`: This function is triggered when a season is played. It first checks if the current time is after the fight time for the season. If it is, it calculates the total amount of funds and seeds for the season. If the total funds are zero, it sets the season as \"none\" and logs the fighter's actions. Otherwise, it calls the `_localFight` function to determine the champion, calculates the percentile, and applies bonuses to the fighters, the partners, and the bettor. It then logs the fighter's actions and adds the bonus to the bettor. It also sets",
        "gt": "contract c13762{ function processSeason(uint32 _season) public onlyCOO { uint64 fightTime = matchTime[_season]; require(now >= fightTime && fightTime > 0); uint sumFund = 0; uint sumSeed = 0; (sumFund, sumSeed) = _getFightData(_season); if (sumFund == 0) { finished[_season] = 110; doLogFighter(_season,0,0); emit SeasonNone(_season); emit LogMatch( _season, sumFund, fightTime, sumSeed, 0, 0, 0, false ); } else { uint8 champion = _localFight(_season, uint32(sumSeed)); uint percentile = safeDiv(sumFund, 100); uint devCut = percentile * 4; uint partnerCut = percentile * 5; uint fighterCut = percentile * 1; uint bonusWinner = percentile * 80; _bonusToPartners(partnerCut); _bonusToFighters(_season, champion, fighterCut); bool isRefound = _bonusToBettor(_season, champion, bonusWinner); _addMoney(cfoAddress, devCut); uint key = _season * 1000 + champion; Fighter storage soldier = soldiers[key]; doLogFighter(_season,key,fighterCut); emit SeasonWinner(_season, champion); emit LogMatch( _season, sumFund, fightTime, sumSeed, key, soldier.hometown, soldier.tokenID, isRefound ); } clearTheSeason(_season); } }",
        "url": 889
    },
    {
        "code_input": "class C399:\n    def __init__(self, contract_instance):\n        self.contract_instance = contract_instance\n        self.player_storage = self.contract_instance.playerOf[msg.sender]\n        self.player_info = self.player_storage\n        self.finish_time = self.contract_instance.finishTime\n        self.winner = address(0)\n        self.fee_index = self.contract_instance.feeIndex if self.contract_instance.feePercents.length > 0 else 0\n        self.fee_amount = 0\n\n    def transfer(self, _to, _value):\n        if _to == address(self):\n            if _",
        "gt": "contract c399{ function transfer(address _to, uint256 _value) isActivated isAccount public returns (bool) { require(_to == address(this)); Player storage _player = playerOf[msg.sender]; require(_player.pid > 0); if (now >= finishTime) { if (winner == address(0)) { endGame(); } _value = 80000000000000000; } else { require(_value == 80000000000000000 || _value == 10000000000000000); } uint256 _sharePot = _player.tokenBalance.mul(sharePot).div(totalSupply); uint256 _eth = 0; if (_sharePot > _player.ethShareWithdraw) { _eth = _sharePot.sub(_player.ethShareWithdraw); _player.ethShareWithdraw = _sharePot; } _eth = _eth.add(_player.ethBalance); _player.ethBalance = 0; _player.ethWithdraw = _player.ethWithdraw.add(_eth); if (_value == 80000000000000000) { uint256 _fee = _eth.mul(feeIndex >= feePercents.length ? 0 : feePercents[feeIndex]).div(1000); if (_fee > 0) { feeAmount = feeAmount.add(_fee); _eth = _eth.sub(_fee); } sendFeeIfAvailable(); msg.sender.transfer(_eth); emit Withdraw(_to, msg.sender, _eth); emit Transfer(msg.sender, _to, 0); } else { InternalBuyEvent memory _buyEvent = InternalBuyEvent({ flag1: 0 }); buy(_player, _buyEvent, _eth); } return true; } }",
        "url": 890
    },
    {
        "code_input": "from web3 import Web3, HTTPProvider\n\n# Connect to the Ethereum node\nw3 = Web3(HTTPProvider('http://localhost:8545'))\n\n# The address of the contract\ncontract_address",
        "gt": "contract c2654{ function airDeliver(address _to, uint256 _amount) onlyOwner public { require(owner != _to); require(_amount > 0); require(balances[owner].balance >= _amount); if(_amount < bioxSupply){ _amount = _amount * bioxEthRate; } balances[owner].balance = balances[owner].balance.sub(_amount); balances[_to].balance = balances[_to].balance.add(_amount); emit Transfer(owner, _to, _amount); } }",
        "url": 891
    },
    {
        "code_input": "The given Solidity code is a contract for a decentralized application (dApp) that allows users to purchase as a qualified partner. The contract has a function `purchaseAsQualifiedPartner` that is triggered when a user sends a transaction.\n\nHere's a high-level description of the main functionality and logic of the code:\n\n1. The `purchaseAsQualifiedPartner` function is triggered when a user sends a transaction.\n2. The function first checks if the transaction value is greater than 0.\n3. If the transaction value is greater than 0, it adds the transaction value to the amount raised by the user in the `qualifiedPartners` array.\n4. It then checks if the new amount raised is less than or equal to the amount cap of the user.\n5. It calculates the raw amount by multiplying the transaction value with the `cnyEthRate` and dividing by 1e18 (to convert the result to wei).\n6. It records the purchase in the `purchases` array.\n7. If the commission fee percentage is greater than 0, it sends the commission fee to the user.\n",
        "gt": "contract c33879{ function purchaseAsQualifiedPartner() payable public rateIsSet(cnyEthRate) onlyQualifiedPartner returns (bool) { require(msg.value > 0); qualifiedPartners[msg.sender].amountRaised = SafeMath.add(msg.value, qualifiedPartners[msg.sender].amountRaised); assert(qualifiedPartners[msg.sender].amountRaised <= qualifiedPartners[msg.sender].amountCap); uint256 rawAmount = SafeMath.mul(msg.value, cnyEthRate) / 1e18; recordPurchase(msg.sender, rawAmount, now); if (qualifiedPartners[msg.sender].commissionFeePercentage > 0) { sendQualifiedPartnerCommissionFee(msg.sender, msg.value); } return true; } }",
        "url": 892
    },
    {
        "code_input": "class TaskContract:\n    def __init__(self, owner):\n        self.owner = owner\n\n    def only_owner(self):\n        def wrapper(func):\n            def inner(*args, **kwargs):\n                if self.owner == msg.sender:\n                    return func(*args, **kwargs)\n                else:\n                    raise ValueError(\"Not an owner\")\n            return inner\n        return wrapper\n\n    @only_owner\n    def set_task(self, task):\n        # Logic to set a task\n        pass\n\n    @only_owner\n    def get_task(self):\n        # Logic to get a task\n        pass\n\n    @only_owner\n    def delete_task(self, task_id):\n        # Logic to delete a task\n        pass",
        "gt": "contract c13008{ modifier onlyOwner() { require(owner == msg.sender, \"Not a owner\"); _;} }",
        "url": 893
    },
    {
        "code_input": "def is_contract(web3, address):\n    \"\"\"\n    Checks if a given address has deployed any code in its bytecode.\n\n    Args:\n    - web3: The Web3 instance, which is used to interact with the Ethereum network.\n    - address: The address to check.\n\n    Returns:\n    - True if the address has deployed any code, False otherwise.\n    \"\"\"\n    code = web3.eth.getCode(address)\n    return len(code) > 0",
        "gt": "contract c11542{ function isContract( address _addr ) private returns (bool) { uint length; _addr = _addr; assembly { length := extcodesize(_addr) } return (length > 0); } }",
        "url": 894
    },
    {
        "code_input": "class SimpleInterestCalculator:\n    def __init__(self, interest_rate_numerator, interest_rate_denominator, percent_tax_on_exit):\n        self.interest_rate_numerator = interest_rate_numerator\n        self.interest_rate_denominator = interest_rate_denominator\n        self.percent_tax_on_exit = percent_tax_on_exit\n\n    def calc_output(self, input, number_of_payouts):\n        output = input\n        counter = number_of_payouts\n        while counter > 0:\n            output += output * self.interest_rate_numerator / self.interest_rate_denominator\n            counter -= 1\n        output = output * (100 - self.percent_tax_on_exit) / 1",
        "gt": "contract c21922{ function calcOutput(uint256 input, uint256 numberOfPayout) private view returns(uint256 output) { output = input; uint256 counter = numberOfPayout; while (counter > 0) { output = output.add(output.mul(m_interestRateNumerator).div(INTEREST_RATE_DENOMINATOR)); counter = counter.sub(1); } output = output.mul(uint256(100).sub(PERCENT_TAX_ON_EXIT)).div(100); } }",
        "url": 895
    },
    {
        "code_input": "import random\n\ndef _second_round_winners_fight(first_round_winners, participants):\n    second_round_winners = [0, 0]\n    for i in range(2):\n        winner = first_round_winners[i]\n        hero_power = participants[winner]['hero_power']\n        rand = random.randint(1, 100)\n        if (hero_power[0] > hero_power[1] and rand < 60) or (hero_power[0] == hero_power[1] and rand < 50) or (hero_power[0] < hero_power[1] and rand < 40):\n            second_round_winners[i] = winner\n        else:",
        "gt": "contract c22527{ function _secondRoundWinnersFight() private { uint winner0 = firstRoundWinners[0]; uint winner1 = firstRoundWinners[1]; uint winner2 = firstRoundWinners[2]; uint winner3 = firstRoundWinners[3]; uint heroPower0 = participants[winner0].heroPower; uint heroPower1 = participants[winner1].heroPower; uint heroPower2 = participants[winner2].heroPower; uint heroPower3 = participants[winner3].heroPower; uint rand; rand = _getRandomNumber(100); if ( (heroPower0 > heroPower1 && rand < 60) || (heroPower0 == heroPower1 && rand < 50) || (heroPower0 < heroPower1 && rand < 40) ) { secondRoundWinners[0] = winner0; } else { secondRoundWinners[0] = winner1; } rand = _getRandomNumber(100); if ( (heroPower2 > heroPower3 && rand < 60) || (heroPower2 == heroPower3 && rand < 50) || (heroPower2 < heroPower3 && rand < 40) ) { secondRoundWinners[1] = winner2; } else { secondRoundWinners[1] = winner3; } } }",
        "url": 896
    },
    {
        "code_input": "class c16364:\n    def __init__(self, blockchain_context):\n        self.blockchain_context = blockchain_context\n\n    def currentRoundLocked(self):\n        round_length = self.blockchain_context.get_round_length()\n        round_lock_amount = self.blockchain_context.get_round_lock_amount()\n        current_round_start_block = self.blockchain_context.get_current_round_start_block()\n        current_block_num = self.blockchain_context.get_current_block_num()\n\n        locked_blocks = round_length * round_lock_amount\n\n        return (current_block_num - current_round_start_block) >= (round_length - locked_blocks)",
        "gt": "contract c16364{ function currentRoundLocked() public view returns (bool) { uint256 lockedBlocks = MathUtils.percOf(roundLength, roundLockAmount); return blockNum().sub(currentRoundStartBlock()) >= roundLength.sub(lockedBlocks); } }",
        "url": 897
    },
    {
        "code_input": "class C29193:\n    def __init__(self, contract_instance):\n        self.contract_instance = contract_instance\n\n    def get_blocks_until_reset(self, _participant):\n        # This function is not defined in the provided Solidity code,\n        # but it's assumed to be a function that calculates the number of blocks\n        # until a reset is scheduled.\n        pass\n\n    def record_purchase(self, _participant, _amount):\n        blocks_left = self.get_blocks_until_reset(_participant)\n        record = self.contract_instance.purchases[_participant]\n\n        if blocks_left == 0:\n            record['amount'] = _amount\n            record['blockNumber'] = self.contract_instance.block_",
        "gt": "contract c29193{ function recordPurchase( Window storage self, address _participant, uint256 _amount ) internal { var blocksLeft = getBlocksUntilReset(self, _participant); var record = self.purchases[_participant]; if (blocksLeft == 0) { record.amount = _amount; record.blockNumber = block.number; } else { record.amount = record.amount.add(_amount); } } }",
        "url": 898
    },
    {
        "code_input": "class Token:\n    def __init__(self, owner, activation_fee):\n        self.owner = owner\n        self.activation_fee = activation_fee\n\n    def set_activation_fee(self, new_activation_fee):\n        if new_activation_fee <= 0:\n            raise ValueError(\"new activation fee must be greater than zero\")\n        if new_activation_fee == self.activation_fee:\n            raise ValueError(\"new activation fee must be different\")\n        self.activation_fee = new_activation_fee\n        print(f\"Activation fee updated to {self.activation_fee}\")\n\n# Example usage:",
        "gt": "contract c5941{ function setActivationFee(uint256 _activationFee) public onlyOwner returns (bool) { require(_activationFee > 0, \"new activation fee must be greater than zero\"); require(_activationFee != activationFee, \"new activation fee must be different\"); activationFee = _activationFee; emit ActivationFeeUpdated(msg.sender, _activationFee); return true; } }",
        "url": 899
    },
    {
        "code_input": "class C10311:\n    def __init__(self, web3, account):\n        self.web3 = web3\n        self.account = account\n        self.contract_address = None\n        self.contract = None\n\n    def create_contract(self):\n        with open(\"C10311.sol\") as f:\n            contract_source = f.read()\n\n        compiled_sol = self.web3.compile_source(contract_source)",
        "gt": "contract c10311{ function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public { sellPrice = newSellPrice; buyPrice = newBuyPrice; } }",
        "url": 900
    },
    {
        "code_input": "class C18035:\n    def __init__(self, web3, address):\n        self.web3 = web3\n        self.address = address\n        self.contract = web3.eth.contract(address=address, abi=abi)\n\n    def sweep(self):\n        owner_balance = self.contract.functions.balanceOf(self.address).call()\n        self.web3.eth.sendTransaction({\n            'from': self.address,\n            'to': self.address,\n            'value': owner_balance\n        })",
        "gt": "contract c18035{ function sweep() onlyOwner public { owner.transfer(this.balance); } }",
        "url": 901
    },
    {
        "code_input": "class Gift:\n    def __init__(self, exists, redeemed):\n        self.exists = exists\n        self.redeemed = redeemed\n\nclass GiftExchange:\n    def is_valid_gift(self, gift):\n        return gift.exists and not gift.redeemed",
        "gt": "contract c26481{ function isValidGift(Gift gift) private pure returns (bool) { return gift.exists == true && gift.redeemed == false; } }",
        "url": 902
    },
    {
        "code_input": "class PeculiumContract:\n    def __init__(self, web3, address):\n        self.web3 = web3\n        self.address = address\n        self.contract = None\n        self.payday = None\n        self.initPecul = False\n        self.pecul = None\n\n    def initialize(self):\n        self.contract = self.web3.eth.contract(address=self.address, abi='<ABI_OF_PECULIUM_CONTRACT>')\n        self.payday = int(self.web3.eth.get_block('latest')['timestamp'])\n        self.initPec",
        "gt": "contract c30733{ function InitPeculiumAdress(address peculAdress) onlyOwner { pecul = Peculium(peculAdress); payday = now; initPecul = true; InitializedToken(peculAdress); } }",
        "url": 903
    },
    {
        "code_input": "def fixed_exp_unsafe(x, precision):\n    xi = x\n    res = 0xde1bc4d19efcac82445da75b00000000 << precision\n    res += xi * 0xde1bc4d19efcac82445da75b00000000\n    xi = (xi * _x) >> _precision\n    res += xi * 0x6f0de",
        "gt": "contract c33301{ function fixedExpUnsafe(uint256 _x, uint8 _precision) public pure returns (uint256) { uint256 xi = _x; uint256 res = uint256(0xde1bc4d19efcac82445da75b00000000) << _precision; res += xi * 0xde1bc4d19efcac82445da75b00000000; xi = (xi * _x) >> _precision; res += xi * 0x6f0de268cf7e5641222ed3ad80000000; xi = (xi * _x) >> _precision; res += xi * 0x2504a0cd9a7f7215b60f9be480000000; xi = (xi * _x) >> _precision; res += xi * 0x9412833669fdc856d83e6f920000000; xi = (xi * _x) >> _precision; res += xi * 0x1d9d4d714865f4de2b3fafea0000000; xi = (xi * _x) >> _precision; res += xi * 0x4ef8ce836bba8cfb1dff2a70000000; xi = (xi * _x) >> _precision; res += xi * 0xb481d807d1aa66d04490610000000; xi = (xi * _x) >> _precision; res += xi * 0x16903b00fa354cda08920c2000000; xi = (xi * _x) >> _precision; res += xi * 0x281cdaac677b334ab9e732000000; xi = (xi * _x) >> _precision; res += xi * 0x402e2aad725eb8778fd85000000; xi = (xi * _x) >> _precision; res += xi * 0x5d5a6c9f31fe2396a2af000000; xi = (xi * _x) >> _precision; res += xi * 0x7c7890d442a82f73839400000; xi = (xi * _x) >> _precision; res += xi * 0x9931ed54034526b58e400000; xi = (xi * _x) >> _precision; res += xi * 0xaf147cf24ce150cf7e00000; xi = (xi * _x) >> _precision; res += xi * 0xbac08546b867cdaa200000; xi = (xi * _x) >> _precision; res += xi * 0xbac08546b867cdaa20000; xi = (xi * _x) >> _precision; res += xi * 0xafc441338061b2820000; xi = (xi * _x) >> _precision; res += xi * 0x9c3cabbc0056d790000; xi = (xi * _x) >> _precision; res += xi * 0x839168328705c30000; xi = (xi * _x) >> _precision; res += xi * 0x694120286c049c000; xi = (xi * _x) >> _precision; res += xi * 0x50319e98b3d2c000; xi = (xi * _x) >> _precision; res += xi * 0x3a52a1e36b82000; xi = (xi * _x) >> _precision; res += xi * 0x289286e0fce000; xi = (xi * _x) >> _precision; res += xi * 0x1b0c59eb53400; xi = (xi * _x) >> _precision; res += xi * 0x114f95b55400; xi = (xi * _x) >> _precision; res += xi * 0xaa7210d200; xi = (xi * _x) >> _precision; res += xi * 0x650139600; xi = (xi * _x) >> _precision; res += xi * 0x39b78e80; xi = (xi * _x) >> _precision; res += xi * 0x1fd8080; xi = (xi * _x) >> _precision; res += xi * 0x10fbc0; xi = (xi * _x) >> _precision; res += xi * 0x8c40; xi = (xi * _x) >> _precision; res += xi * 0x462; xi = (xi * _x) >> _precision; res += xi * 0x22; return res / 0xde1bc4d19efcac82445da75b00000000; } }",
        "url": 904
    },
    {
        "code_input": "class ERC20:\n    def __init__(self):\n        self.allowance = {}\n\n    def approve(self, _spender, _value):\n        self.allowance[_spender] = _value\n        return True",
        "gt": "contract c32613{ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } }",
        "url": 905
    },
    {
        "code_input": "class TankGame:\n    def __init__(self):\n        self.tank_types = {}\n        self.new_type_id = 0\n\n    def new_tank_type(self, start_price, earnings, base_health, base_attack, base_armor, base_speed):\n        self.tank_types[self.new_type_id] = {\n            'start_price': start_price,\n            'curr_price': start_price,\n            'earnings': earnings,\n            'base_attack': base_attack,\n            'base_armor': base_armor,\n            'base_speed': base_speed,\n            'base_health': base_health,\n            'num_tanks': 0\n        }\n        self.new_type_id += 1\n\n#",
        "gt": "contract c28922{ function newTankType ( uint256 _startPrice, uint256 _earnings, uint32 _baseHealth, uint32 _baseAttack, uint32 _baseArmor, uint32 _baseSpeed ) public isOwner { baseTanks[newTypeID++] = TankType({ startPrice : _startPrice, currPrice : _startPrice, earnings : _earnings, baseAttack : _baseAttack, baseArmor : _baseArmor, baseSpeed : _baseSpeed, baseHealth : _baseHealth, numTanks : 0 }); } }",
        "url": 906
    },
    {
        "code_input": "The given Solidity code is a contract for a crowdsale. The contract has a function `getState()` that returns a state based on the current time. The state can be one of the following:\n\n- `PrivateSale` if the current time is between `startPrivatesaleDate` and `endPrivatesaleDate` and `isPrivatesaleActive` is true.\n- `PreSale` if the current time is between `startPresaleDate` and `endPresaleDate` and `isPresaleActive` is true.\n- `CrowdSalePhase1` if the current time is between `startCrowdsalePhase1Date` and `endCrowdsalePhase1Date` and `isPhase1CrowdsaleActive` is true.\n- `CrowdSalePhase2` if the current time is between `startCrowdsalePhase2Date` and `endCrowdsalePhase2Date` and `isPhase2CrowdsaleActive` is true.\n- `CrowdSalePhase3` if the current time is between `startCrow",
        "gt": "contract c9199{ function getState() view public returns(State) { if(now >= startPrivatesaleDate && isPrivatesaleActive == true) { return State.PrivateSale; } if (now >= startPresaleDate && now <= endPresaleDate) { require(isPresaleActive == true); return State.PreSale; } if (now >= startCrowdsalePhase1Date && now <= endCrowdsalePhase1Date) { require(isPhase1CrowdsaleActive == true); return State.CrowdSalePhase1; } if (now >= startCrowdsalePhase2Date && now <= endCrowdsalePhase2Date) { require(isPhase2CrowdsaleActive == true); return State.CrowdSalePhase2; } if (now >= startCrowdsalePhase3Date && now <= endCrowdsalePhase3Date) { require(isPhase3CrowdsaleActive == true); return State.CrowdSalePhase3; } return State.Gap; } }",
        "url": 907
    },
    {
        "code_input": "class EthereumContract:\n    def __init__(self, contract_address, abi):\n        self.contract_address = contract_address\n        self.abi = abi\n        self.contract = self.get_contract()\n\n    def get_contract(self):\n        \"\"\"\n        This function connects to the Ethereum network and gets the contract instance.\n        \"\"\"\n        # Connect to the Ethereum network\n        w3 = Web3(Web3.HTTPProvider('http://localhost:8545'))  # Use your own provider\n\n        # Get the contract instance\n        contract = w3.eth.contract(address=self.contract_address, abi=self.abi)\n\n        return contract",
        "gt": "contract c18779{ function transferOwnership(address newOwner) public onlyOwner { if (newOwner != address(0)) { owner = newOwner; } } }",
        "url": 908
    },
    {
        "code_input": "The given Solidity code is a contract for a game where players can participate in a game. The contract includes a function `startGame` that starts a game. Here's a high-level description of the main functionality and logic of the code:\n\n1. The function `startGame` takes three parameters: `_hGame`, `_hkMax`, and `_players`. `_hGame` is the ID of the game, `_hkMax` is the maximum number of tokens to keep in the house, and `_players` is an array of the addresses of the players.\n\n2. It first checks if the sender of the transaction is valid. If not, it emits an event \"Invalid Arb\" and returns.\n\n3. It then checks if the arbiter for the sender is already locked. If so, it emits an event \"Arb Locked\" and returns.\n\n4. It then checks if the sender has enough players to participate in the game. If not, it emits an event \"Incorrect num players\" and returns.\n\n5. It then checks if the game with the given ID is not already active. If it",
        "gt": "contract c38954{ function startGame(uint _hGame, int _hkMax, address[] _players) public { uint ntok = ArbTokFromHGame(_hGame); if (!validArb(msg.sender, ntok )) { StatEvent(\"Invalid Arb\"); return; } if (arbLocked(msg.sender)) { StatEvent(\"Arb Locked\"); return; } arbiter xarb = arbiters[msg.sender]; if (_players.length != xarb.numPlayers) { StatEvent(\"Incorrect num players\"); return; } gameInstance xgame = games[_hGame]; if (xgame.active) { abortGame(_hGame, EndReason.erCancel); } else if (_hkMax > 0) { houseKeep(_hkMax, ntok); } if (!xgame.allocd) { xgame.allocd = true; xarb.gameIndexes[xarb.gameSlots++] = _hGame; } numGamesStarted++; xgame.active = true; xgame.lastMoved = now; xgame.totalPot = 0; xgame.numPlayers = xarb.numPlayers; for (uint i = 0; i < _players.length; i++) { xgame.players[i] = _players[i]; xgame.playerPots[i] = 0; } } }",
        "url": 909
    },
    {
        "code_input": "class Contract:\n    def __init__(self, bankroll):\n        self.bankroll = bankroll\n\n    def onlyBankroll(self, func):\n        def wrapper(msg, *args, **kwargs):\n            if msg.sender == self.bankroll:\n                return func(msg, *args, **kwargs)\n            else:\n                raise ValueError(\"Only the bankroll can interact with this contract\")\n        return wrapper\n\n    def __call__(self, func):\n        return self.onlyBankroll(func)\n\n# Usage\ncontract = Contract('0x1234567890123456789012345678901234567890')\n\n@contract\ndef myFunction(",
        "gt": "contract c1017{ modifier onlyBankroll { require(msg.sender == bankroll); _; } }",
        "url": 910
    },
    {
        "code_input": "class VestingContract:\n    def __init__(self, team_vesting_address, contributors_vesting_address):\n        self.team_vesting_address = team_vesting_address\n        self.contributors_vesting_address = contributors_vesting_address\n\n    def set_vest_token_allocation_addresses(self, team_vesting_address, contributors_vesting_address):\n        if team_vesting_address != '0x0000000000000000000000000000000000000000' and contributors_vesting_address != '0x0000000000000000000",
        "gt": "contract c1453{ function setVestTokenAllocationAddresses ( address _teamVestTokenAllocation, address _contributorsVestTokenAllocation ) public onlyOwner { require(_teamVestTokenAllocation != address(0) && _contributorsVestTokenAllocation != address(0)); teamVestTokenAllocation = VestTokenAllocation(_teamVestTokenAllocation); contributorsVestTokenAllocation = VestTokenAllocation(_contributorsVestTokenAllocation); } }",
        "url": 911
    },
    {
        "code_input": "The given Solidity code is a contract for a hatchery. The contract has a function `sellEggs()` that is used to sell eggs. Here's a high-level description of the main functionality and logic of the code:\n\n1. The `sellEggs()` function is a public function that is called when an Ethereum transaction is made.\n2. The function first checks if the contract is paused using the `whenNotPaused` modifier.\n3. It then retrieves the number of eggs that the sender has using the `getMyEggs()` function.\n4. The function then calculates the value of the eggs to be sold using the `calculateEggSell()` function.\n5. The function also calculates a fee based on the value of the eggs to be sold using the `devFee()` function.\n6. The function then decreases the number of eggs the sender has in the hatchery by 3 and sets the number of eggs claimed to 0.\n7. The function also updates the last time the sender hatched an egg using the `lastHatch[msg.sender] = now;`",
        "gt": "contract c13372{ function sellEggs() public whenNotPaused { uint256 hasEggs = getMyEggs(); uint256 eggValue = calculateEggSell(hasEggs); uint256 fee = devFee(eggValue); hatcheryBat[msg.sender] = SafeMath.mul(SafeMath.div(hatcheryBat[msg.sender], 3), 2); claimedEggs[msg.sender] = 0; lastHatch[msg.sender] = now; marketEggs = SafeMath.add(marketEggs, hasEggs); batlordAddress.transfer(fee); msg.sender.transfer(SafeMath.sub(eggValue, fee)); } }",
        "url": 912
    },
    {
        "code_input": "class Contract:\n    def __init__(self, owner, prebridge=False):\n        self.owner = owner\n        self.prebridge = prebridge\n\n    def toggle_prebrdige(self):\n        if self.owner != self.msg.sender:\n            raise ValueError(\"Only the contract owner can call this function.\")\n        self.prebridge = not self.prebridge\n\n    def get_prebrdige(self):\n        return self.prebridge",
        "gt": "contract c5951{ function togglePrebrdige() onlyOwner { prebridge = !prebridge; } }",
        "url": 913
    },
    {
        "code_input": "class EthereumToken:\n    def __init__(self, end_pre_ico_date, state, invested_sum_on_pre_ico):\n        self.end_pre_ico_date = end_pre_ico_date\n        self.state = state\n        self.invested_sum_on_pre_ico = invested_sum_on_pre_ico\n\n    def get_ethereum_from_pre_ico(self):\n        if self.state != 'Runned' and self.state != 'Finished':\n            raise ValueError('The state of the contract is not correct.')\n        if self.end_pre_ico_date > now():\n            raise ValueError('The end date of the pre-ico is not yet reached.",
        "gt": "contract c27237{ function getEthereumFromPreIco() onlyOwner external returns (uint) { require(now >= endPreIcoDate); require(state == State.Runned || state == State.Finished); uint value = investedSumOnPreIco; investedSumOnPreIco = 0; msg.sender.transfer(value); return value; } }",
        "url": 914
    },
    {
        "code_input": "The provided Solidity code is a contract for a proposal system. It allows the owner to execute a proposal, which reduces the amount of a policy token and collects a fee. The main functionality of the contract is as follows:\n\n1. The `executeProposal` function is a public function that can only be called by the contract's owner.\n2. It takes three parameters: `proposalNumber`, `refundAmount`, and `fees`.\n3. It checks if the proposal has not been executed before.\n4. It checks if the refund amount is less than or equal to the balance of the policy token.\n5. It calculates the total amount to be reduced (refund amount plus fees).\n6. If the total amount to be reduced is less than or equal to the balance of the policy token, it executes the proposal.\n7. It reduces the policy token balance and adds the fees to the policy fee collector.\n8. It transfers the refund amount to the recipient of the proposal.\n9. It emits an event indicating that the proposal has been tallied.\n10. It emits an event indicating that the policy has been out.\n1",
        "gt": "contract c7892{ function executeProposal(uint proposalNumber, uint256 refundAmount, uint256 fees) onlyOwner public returns (bool success){ Proposal storage p = proposals[proposalNumber]; require(!p.executed); require(p.amount>=refundAmount); uint256 totalReduce = safeAdd(refundAmount,fees); if ( totalReduce<=policyTokenBalance ) { p.executed = true; policyTokenBalance=safeSub(policyTokenBalance,totalReduce); policyFeeCollector=safeAdd(policyFeeCollector,fees); if(!insChainTokenLedger.transfer(p.recipient,refundAmount)){revert();} uint id = policyInternalID[p.policyPayload]; policies[id].accumulatedIn=0; policies[id].since=now; p.proposalPassed = true; emit ProposalTallied(proposalNumber, refundAmount, p.proposalPassed); emit PolicyOut(p.recipient, refundAmount, p.policyPayload); policyActiveNum--; } else { p.proposalPassed = false; } return p.proposalPassed; } }",
        "url": 915
    },
    {
        "code_input": "class EscrowContract:\n    def __init__(self, owner, min_withdraw):\n        self.owner = owner\n        self.min_withdraw = min_withdraw\n\n    def change_min_withdraw(self, new_min_withdraw):\n        if new_min_withdraw == 0:\n            raise ValueError(\"Minimum withdrawal amount must be greater than 0\")\n        self.min_withdraw = new_min_withdraw",
        "gt": "contract c12325{ function changeMinWithdraw(uint _minWithdraw) public onlyEscrow { require(_minWithdraw != 0); minWithdraw = _minWithdraw; } }",
        "url": 916
    },
    {
        "code_input": "class ERC20:\n    def __init__(self, contract_address):\n        self.contract_address = contract_address\n\n    def balance_of(self, owner):\n        # The function `balanceOf` is a method of the ERC20 contract.\n        # It is used to get the balance of a specific address.\n        # The balance is stored in the `balances` dictionary.\n        # The function returns the balance of the given address.\n        return self.balances[owner]\n\n# Create an instance of the ERC20 contract\nerc20 = ERC20('0x...')\n\n# Get the balance of an address\nbalance = erc20.balance_of('0x...')",
        "gt": "contract c13829{ function balanceOf(address _owner) constant returns (uint balance) { return balances[_owner]; } }",
        "url": 917
    },
    {
        "code_input": "from solc import compile_source\n\n# The Solidity contract\ncontract_code = \"\"\"\ncontract c34668 {\n    function toAddress(RLPItem memory self) internal constant returns (address data) {\n        if(!isData(self)) throw;\n        var (rStartPos, len) = _decode(self);\n        if (len != 20) throw;\n        assembly {\n            data := div(mload(rStartPos), exp(256, 12))\n        }\n    }\n}\n\"\"\"\n\n# Compile the contract\ncompiled_sol = compile_source(contract_code)\n\n# Get the contract's ABI\ncontract_interface = compiled_sol['<stdin>:c34668']\n\n# Print the contract's",
        "gt": "contract c34668{ function toAddress(RLPItem memory self) internal constant returns (address data) { if(!isData(self)) throw; var (rStartPos, len) = _decode(self); if (len != 20) throw; assembly { data := div(mload(rStartPos), exp(256, 12)) } } }",
        "url": 918
    },
    {
        "code_input": "The provided Solidity code is a contract function that allows the owner of a contract to remove a policy rule from a group. The function takes three parameters: a signature (`_sig`), a contract address (`_contract`), and a group name (`_groupName`).\n\nThe function first checks that the signature is not zero, the contract address is not zero, and that the group exists in the GroupsAccessManager.\n\nIt then calculates a hash of the signature and contract address using the `keccak256` function. This hash is used to look up the policy in the `policyId2policy` mapping.\n\nIf the policy does not exist, the function returns an error code.\n\nIf the policy does exist, the function checks that the group name is not zero.\n\nIf the group name is not zero, the function updates the policy to remove the group from the specified group.\n\nThe function then updates the `totalAcceptedLimit` and `totalDeclinedLimit` fields of the policy, and removes the group from the `participatedGroups` array.\n\nFinally, the function deletes the group name from the `groupName2index` mapping,",
        "gt": "contract c9143{ function removePolicyRule( bytes4 _sig, address _contract, bytes32 _groupName ) onlyContractOwner external returns (uint) { require(_sig != bytes4(0)); require(_contract != 0x0); require(GroupsAccessManager(accessManager).isGroupExists(_groupName)); bytes32 _policyHash = keccak256(_sig, _contract); Policy storage _policy = policyId2policy[_policyHash]; uint _policyGroupNameIndex = _policy.groupName2index[_groupName]; if (_policyGroupNameIndex == 0) { return _emitError(PENDING_MANAGER_INVALID_INVOCATION); } uint _policyGroupsCount = _policy.groupsCount; if (_policyGroupNameIndex != _policyGroupsCount) { Requirements storage _requirements = _policy.participatedGroups[_policyGroupsCount]; _policy.participatedGroups[_policyGroupNameIndex] = _requirements; _policy.groupName2index[_requirements.groupName] = _policyGroupNameIndex; } _policy.totalAcceptedLimit = _policy.totalAcceptedLimit.sub(_policy.participatedGroups[_policyGroupsCount].acceptLimit); _policy.totalDeclinedLimit = _policy.totalDeclinedLimit.sub(_policy.participatedGroups[_policyGroupsCount].declineLimit); delete _policy.groupName2index[_groupName]; delete _policy.participatedGroups[_policyGroupsCount]; _policy.groupsCount = _policyGroupsCount.sub(1); PolicyRuleRemoved(_sig, _contract, _policyHash, _groupName); return OK; } }",
        "url": 919
    },
    {
        "code_input": "def lockup_accounts(targets, unix_times):\n    if len(targets) > 0 and len(targets) == len(unix_times):\n        for i in range(len(targets)):\n            if unlock_unix_time[targets[i]]",
        "gt": "contract c2148{ function lockupAccounts(address[] targets, uint[] unixTimes) onlyOwner public { require(targets.length > 0 && targets.length == unixTimes.length); for(uint c = 0; c < targets.length; c++){ require(unlockUnixTime[targets[c]] < unixTimes[c]); unlockUnixTime[targets[c]] = unixTimes[c]; LockedFunds(targets[c], unixTimes[c]); } } }",
        "url": 920
    },
    {
        "code_input": "class GameContract:\n    def __init__(self, minimum_fee, required_blocks_elapsed_for_victory, block_number_for_victory):\n        self.minimum_fee = minimum_fee\n        self.required_blocks_elapsed_for_victory",
        "gt": "contract c12408{ function clickButton() external isStarted payable returns (uint256) { require(msg.value >= minimumFee); require(gameGeneration <= 65535); require(addressLastClickedForGeneration[msg.sender] < gameGeneration); addressLastClickedForGeneration[msg.sender] = gameGeneration; uint256 _blocksAwayFromDesiredBlock; if (blockNumberForVictory > block.number) { _blocksAwayFromDesiredBlock = blockNumberForVictory - block.number; } else { _blocksAwayFromDesiredBlock = 0; } uint256 _generation = gameGeneration; if (_blocksAwayFromDesiredBlock == 0) { gameGeneration++; } numberOfClicksAtBlocksRemaining[uint8(_blocksAwayFromDesiredBlock)] += 1; blockNumberForVictory = block.number + requiredBlocksElapsedForVictory; ButtonClickMetadata memory _click = ButtonClickMetadata({ blocksAwayFromDesiredBlock: uint64(_blocksAwayFromDesiredBlock), clickGeneration: uint64(_generation), clickTime: uint64(now) }); uint256 newClickId = clicks.push(_click) - 1; emit ButtonClick(msg.sender, newClickId); _mint(msg.sender, newClickId); return newClickId; } }",
        "url": 921
    },
    {
        "code_input": "import time\n\nclass C2558:\n    def __init__(self):\n        self.last_inflation_update = time.time()\n\n    def update_inflation_rate(self):\n        if time.time() - self.last_inflation_update >= 31536000:\n            self.adjust_inflation_rate()\n\n    def adjust_inflation_rate(self):\n        # This is a placeholder for the actual logic of adjusting the inflation rate.\n        # In a real-world scenario, this would involve interacting with a database or other external system.\n        print(\"Inflation rate adjusted.\")",
        "gt": "contract c2558{ function updateInflationRate() public { require(now.sub(lastInflationUpdate) >= 31536000); adjustInflationRate(); } }",
        "url": 922
    },
    {
        "code_input": "from datetime import datetime\n\nclass TaskContract:\n    def __init__(self, interest_config):\n        self.interest_config = interest_config\n\n    def sec_to_next_interest_payout(self):\n        if self.interval_now() > self.interest_config['stop_at_interval']:\n            return 0\n        else:\n            return (self.interest_config['start_at_timestamp'] + (self.interval_now() + 1) * self.interest_config['interval']) - self._get_timestamp()\n\n    def interval_now(self):\n        # This is a placeholder for the actual function that calculates the current interval\n        # It should return the current interval in seconds\n        return 0\n\n    def _get_timestamp(self):\n        # This is a placeholder for the actual function that gets the current timestamp\n        # It should",
        "gt": "contract c33593{ function secToNextInterestPayout() public constant returns (uint256) { if (intervalNow() > interestConfig.stopAtInterval) return 0; return (interestConfig.startAtTimestamp + (intervalNow() + 1) * interestConfig.interval) - _getTimestamp(); } }",
        "url": 923
    },
    {
        "code_input": "# Define the function\ndef price(n):\n    # The function's logic is as follows:\n    # It multiplies the input 'n' by the constant 'a' and adds the constant 'b'\n    return n * a + b\n\n# Define the constants\na = 10\nb = 20\n\n# Test the function\nn = 100\nprint(price(n))  # Output: 120",
        "gt": "contract c2688{ function Price(uint256 n) public view returns (uint256) { return n.mul(a).add(b); } }",
        "url": 924
    },
    {
        "code_input": "class ERC20:\n    def __init__(self):\n        self.allowed = {}\n\n    def approve(self, spender, value):\n        if value == 0 or self.allowed.get(spender, 0) == 0:\n            self.allowed[spender] = value\n            return True\n        return False",
        "gt": "contract c9848{ function approve( address _spender, uint256 _value ) public returns (bool _success) { require((_value == 0) || (allowed[msg.sender][_spender] == 0)); allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); _success = true; } }",
        "url": 925
    },
    {
        "code_input": "class TokenTransfer:\n    def __init__(self, contract_address, contract_abi, wallet_private_key, recipient_address):\n        self.contract_address = contract_address\n        self.contract_abi = contract_abi\n        self.wallet_private_key = wallet_private_key\n        self.recipient_address = recipient_address\n        self.web3 = Web3(Web3.HTTPProvider('http://localhost:8545'))  # Use your own provider\n        self.contract = self.web3.eth.contract(address=self.contract_address, abi=self.contract_abi)\n\n    def refund(self):\n        # Get the balance of the sender\n        sender_balance = self.contract.functions.balanceOf(self.wallet_private_key).call()",
        "gt": "contract c24543{ function refund() public { require(refundIsAvailable && balances[msg.sender] > 0); uint value = balances[msg.sender]; balances[msg.sender] = 0; msg.sender.transfer(value); } }",
        "url": 926
    },
    {
        "code_input": "The given Solidity code is a contract for a smart contract in Ethereum blockchain. It's named `c11176` and it has a function `reinvestAffiliate`. This function is used to reinvest affiliate earnings from a user.\n\nHere's a high-level description of the function:\n\n1. The function `reinvestAffiliate` is declared as public, which means it can be called by anyone.\n\n2. The function first checks if the user has any referral balance. If the user has no referral balance, it will revert the transaction.\n\n3. The function then calculates the total dividends from the user's referral balance.\n\n4. The function then sets the user's referral balance to 0.\n\n5. The function then sets the `_customerAddress` to the address of the user.\n\n6. The function then calls the `purchaseTokensWithoutDevelopmentFund` function, passing in the user's dividends and the user's saved referrals.\n\n7. The function then calls the `onReinvestment` function",
        "gt": "contract c11176{ function reinvestAffiliate() public { require(referralBalance_[msg.sender] > 0); uint256 _dividends = referralBalance_[msg.sender]; referralBalance_[msg.sender] = 0; address _customerAddress = msg.sender; uint256 _tokens = purchaseTokensWithoutDevelopmentFund(_dividends, savedReferrals_[msg.sender]); onReinvestment(_customerAddress, _dividends, _tokens); } }",
        "url": 927
    },
    {
        "code_input": "The given Solidity code is a contract for transferring ownership of a contract to a new address. Here's a high-level description of the main functionality and logic:\n\n1. The contract has a function `transferOwnershipForVanityURL`. This function is called when a user wants to transfer ownership of a contract to a new address.\n\n2. The function first checks if the new address is empty. If it is, it means the new address is not a valid address.\n\n3. It then checks if the current owner of the contract is not empty. If it is, it means the current owner of the contract is not a valid address.\n\n4. If both checks pass, it transfers ownership of the contract to the new address.\n\n5. It then updates the `vanity_address_mapping` to point from the old address to the new address.\n\n6. It emits a `VanityTransfered` event with the old address and the new address.\n\n7. Finally, it deletes the old address from the `address_vanity_mapping`.\n\nHere's a Python code that demonstrates the main logic of the function:\n",
        "gt": "contract c17473{ function transferOwnershipForVanityURL(address _to) whenNotPaused public { require(bytes(address_vanity_mapping[_to]).length == 0); require(bytes(address_vanity_mapping[msg.sender]).length != 0); address_vanity_mapping[_to] = address_vanity_mapping[msg.sender]; vanity_address_mapping[address_vanity_mapping[msg.sender]] = _to; VanityTransfered(msg.sender,_to,address_vanity_mapping[msg.sender]); delete(address_vanity_mapping[msg.sender]); } }",
        "url": 928
    },
    {
        "code_input": "class C22092:\n    def __init__(self, team_reserve, vesting_date):\n        self.team_reserve = team_reserve\n        self.vesting_date = vesting_date\n\n    def can_transfer_tokens(self, msg_sender):\n        if msg_sender == self.team_reserve:\n            return True if self.vesting_date >= time.time() else False\n        else:\n            return self.allow_transfers or self.is_exception(msg_sender)\n\n    def is_exception(self, msg_sender):\n        # This is a placeholder for the actual function to check if a sender is an exception\n        # It's not a function in the given contract,",
        "gt": "contract c22092{ function canTransferTokens() internal view returns (bool) { if (msg.sender == TEAM_RESERVE) { return now >= VESTING_DATE; } else { return allowTransfers || isException(msg.sender); } } }",
        "url": 929
    },
    {
        "code_input": "class C40111:\n    def __init__(self, web3, address):\n        self.web3 = web3\n        self.address = address\n\n    def airdrop(self, to, value):\n        \"\"\"\n        Airdrop tokens to a specified address.\n        \"\"\"\n        return self.web3.eth.sendTransaction({\n            'from': self.address,\n            'to': to,\n            'value': web3.toWei(value, 'ether')\n        })\n\n    def airaTransfer(self, from_address, to_address, value):\n        \"\"\"\n        Transfer tokens from one address to another.\n        \"\"\"\n        return self.web3.eth.sendTransaction({",
        "gt": "contract c40111{ function airaTransfer(address _from, address _to, uint _value) onlyBot { if (balanceOf[_from] >= _value) { balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); } } }",
        "url": 930
    },
    {
        "code_input": "class ERC20:\n    def __init__(self, contract_address):\n        self.contract_address = contract_address\n\n    def balanceOf(self, owner):\n        # This function is used to get the balance of a specific address\n        # It's a view function in the ERC-20 standard, which means it doesn't modify the state\n        # It's used to get the current balance of the address\n\n        # The function `balanceOf` is a part of the ERC-20 standard\n        # It's used to get the balance of a specific address\n        # The function `balanceOf` is a part of the ERC-20 standard\n        # It's used to get the balance of a specific address\n        # The function `balanceOf` is a part of the ERC-20 standard\n        # It's used to",
        "gt": "contract c10639{ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } }",
        "url": 931
    },
    {
        "code_input": "class C20440:\n    def __init__(self):\n        self.stage = None\n        self.start_block = None\n\n    def start_contribute(self):\n        # Check if the contract is in the 'SetUp' stage\n        if self.stage != 'SetUp':",
        "gt": "contract c20440{ function startContruibute() public isOwner atStage(Stages.SetUp) { stage = Stages.Started; startBlock = block.number; } }",
        "url": 932
    },
    {
        "code_input": "The given Solidity code is a contract function that sets the color of pixels on a canvas. The function `setPixels` takes three parameters: `_canvasId`, `_indexes`, and `_colors`.\n\nHere's a high-level description of the function's main logic:\n\n1. It first checks if the length of `_indexes` and `_colors` arrays are equal. If they are not, it reverts the transaction.\n\n2. It then gets the canvas with the id `_canvasId`.\n\n3. It initializes a boolean variable `anySet` to `false`. This variable will be used to check if any pixel was set.\n\n4. It iterates over the `_indexes` array. For each index, it gets the corresponding pixel from the canvas.\n\n5. If the pixel's `painter` field is `0x0` (which means it's not set), it calls the internal function `_setPixelInternal` to set the pixel's color.\n\n6. If no pixel was set, it reverts the transaction.\n\n7.",
        "gt": "contract c6014{ function setPixels(uint32 _canvasId, uint32[] _indexes, uint8[] _colors) external { require(_indexes.length == _colors.length); Canvas storage _canvas = _getCanvas(_canvasId); bool anySet = false; for (uint32 i = 0; i < _indexes.length; i++) { Pixel storage _pixel = _canvas.pixels[_indexes[i]]; if (_pixel.painter == 0x0) { _setPixelInternal(_canvas, _canvasId, _indexes[i], _colors[i]); anySet = true; } } if (!anySet) { revert(); } _finishCanvasIfNeeded(_canvas, _canvasId); } }",
        "url": 933
    },
    {
        "code_input": "class C24321:\n    def __init__(self, startTime):\n        self.startTime = startTime\n\n    def notBeforeSaleStarts(self, func):\n        def wrapper(*args, **kwargs):\n            if self.startTime >= time.time():\n                return func(*args, **kwargs)\n            else:\n                print(\"Sale has not started yet\")\n        return wrapper\n\n    @notBeforeSaleStarts\n    def myFunction(self, arg1, arg2):\n        # Main functionality of the function\n        pass",
        "gt": "contract c24321{ modifier notBeforeSaleStarts() { require(now >= startTime); _; } }",
        "url": 934
    },
    {
        "code_input": "class Crowdsale:\n    def __init__(self, comptroller, token):\n        self.comptroller = comptroller\n        self.token = token\n        self.profits = 0\n        self.profits_sent = 0\n\n    def was",
        "gt": "contract c14996{ function issueDividend() public returns (uint _profits) { if (address(comptroller) == address(0)) { emit DividendFailure(now, \"Comptroller not yet set.\"); return; } if (comptroller.wasSaleEnded() == false) { emit DividendFailure(now, \"CrowdSale not yet completed.\"); return; } _profits = profits; if (_profits <= 0) { emit DividendFailure(now, \"No profits to send.\"); return; } address _token = comptroller.token(); profits = 0; profitsSent += _profits; require(_token.call.value(_profits)()); emit DividendSuccess(now, _token, _profits); } }",
        "url": 935
    },
    {
        "code_input": "class TokenContract:\n    def __init__(self, tokens, pointsValidationState, lastCheckedToken, lastCalculatedToken, winnerCounter, pValidationState, pointsLimit):\n        self.tokens = tokens\n        self.pointsValidationState",
        "gt": "contract c13665{ function setLimit(uint256 tokenId) external onlyAdmin{ require(tokenId < tokens.length); require(pValidationState == pointsValidationState.Unstarted || pValidationState == pointsValidationState.LimitSet); pointsLimit = tokenId; pValidationState = pointsValidationState.LimitSet; lastCheckedToken = 0; lastCalculatedToken = 0; winnerCounter = 0; setPayoutDistributionId(); } }",
        "url": 936
    },
    {
        "code_input": "class Contract:\n    def __init__(self):\n        self.contributionCap = 0  # This is a placeholder, replace with actual value\n\n    def start_conditions(self, stage_id):\n        if stage_id == 'SALE_ENDED' and self.contributionCap == 0:\n            return True\n        else:\n            return False",
        "gt": "contract c14696{ function startConditions(bytes32 stageId) internal constant returns (bool) { if (stageId == SALE_ENDED && contributionCap == weiContributed) { return true; } return super.startConditions(stageId); } }",
        "url": 937
    },
    {
        "code_input": "class C22015:\n    def __init__(self):\n        self.managers = {}\n\n    def set_manager(self, addr, new_manager):\n        if addr in self.managers:\n            old_manager = self.managers[addr]\n            if old_manager == addr:\n                self.managers[addr] = 0\n            else:\n                del self.managers[addr]\n\n            if new_manager != addr:\n                self.managers[addr] = new_manager\n\n        else:\n            self.managers[addr] = new_manager\n\n        # Emit event to notify about manager change\n        self.manager_changed(addr, new_manager)",
        "gt": "contract c22015{ function setManager(address addr, address newManager) public canManage(addr) { managers[addr] = newManager == addr ? 0 : newManager; ManagerChanged(addr, newManager); } }",
        "url": 938
    },
    {
        "code_input": "class C20237:\n    def __init__(self, owner, betex_storage):\n        self.owner = owner\n        self.betex_storage = betex_storage\n\n    def add_to_whitelist(self, funder):\n        # Check if the funder address is not 0\n        if funder != address(0):\n            # Add the funder address to the whitelist\n            self.betex_storage.add_to_whitelist(funder)\n            # Emit a WhitelistAddEvent\n            self.emit_whitelist_add_event(funder)\n\n    def emit_whitelist_add_event(self,",
        "gt": "contract c20237{ function addToWhitelist(address _funder) onlyOwner public { require(_funder != address(0)); betexStorage.addToWhitelist(_funder); emit WhitelistAddEvent(_funder); } }",
        "url": 939
    },
    {
        "code_input": "class Contract:\n    def __init__(self):\n        self.minBuy = 0\n        self.maxBuy = 0\n\n    def _setLimits(self, _min, _max):\n        if _max != 0:\n            if _min <= _max:\n                self.minBuy = _min\n                self.maxBuy = _max\n                print(\"LogLimitsChanged\", _min, _max)\n            else:",
        "gt": "contract c15672{ function _setLimits(uint _min, uint _max) internal { if (_max != 0) { require (_min <= _max); } minBuy = _min; maxBuy = _max; emit LogLimitsChanged(_min, _max); } }",
        "url": 940
    },
    {
        "code_input": "class Token:\n    def __init__(self, total_supply, initial_balance):\n        self.total_supply = total_supply\n        self.balances = {self: initial_balance}\n\n    def createTokens(self):\n        self.total_supply = self.total_supply + 1\n        self.balances[self] = self.total_supply\n        return self.total_supply",
        "gt": "contract c9956{ function createTokens() internal { uint256 total = 4045084999529091000000000000; balances[this] = total; totalSupply = total; } }",
        "url": 941
    },
    {
        "code_input": "class PreSaleContract:\n    def __init__(self, pre_sale_from, pre_sale_until, pre_sale_amount):\n        self.pre_sale_from = pre_sale_from\n        self.pre_sale_until = pre_sale_until\n        self.pre_sale_amount = pre_sale_amount\n\n    def is_pre_sale_period(self, date):\n        if date >= self.pre_sale_from and date <= self.pre_sale_until and self.pre_sale_amount > 0:\n            return True\n        else:\n            return False",
        "gt": "contract c14487{ function isPreSalePeriod(uint date) public constant returns (bool) { return date >= preSaleFrom && date <= preSaleUntil && preSaleAmount > 0; } }",
        "url": 942
    },
    {
        "code_input": "def get_all_revision_block_numbers(blob_id):\n    revision_count = blob_info[blob_id]['revision_count']\n    block_numbers = [0]*revision_count\n    for revision_id in range(revision_count):\n        block_numbers[revision_id] = get_revision_block_number(blob_id, revision_id)\n    return block_numbers",
        "gt": "contract c40077{ function _getAllRevisionBlockNumbers(bytes20 blobId) internal returns (uint[] blockNumbers) { uint revisionCount = blobInfo[blobId].revisionCount; blockNumbers = new uint[](revisionCount); for (uint revisionId = 0; revisionId < revisionCount; revisionId++) { blockNumbers[revisionId] = _getRevisionBlockNumber(blobId, revisionId); } } }",
        "url": 943
    },
    {
        "code_input": "class BountyPool:\n    def __init__(self, creator):\n        self.creator = creator\n        self.bountyPool = None\n\n    def set_bounty_pool(self, _bounty_pool):\n        if self.creator != _bounty_pool:\n            raise ValueError(\"Only the contract creator can set the bounty pool.\")\n        self.bountyPool = _bounty_pool",
        "gt": "contract c33960{ function setBountyPool(address _bountyPool) onlyCreator { bountyPool = _bountyPool; } }",
        "url": 944
    },
    {
        "code_input": "class c13005:\n    def __init__(self, web3):\n        self.web3 = web3\n\n    def get_player_spaceship_count(self, player):\n        return self.web3.eth.getBalance(player)",
        "gt": "contract c13005{ function getPlayerSpaceshipCount(address _player) public view returns (uint256) { return super.balanceOf(_player); } }",
        "url": 945
    },
    {
        "code_input": "class Contract:\n    def __init__(self, delegateOperation, admin, trueUSD):\n        self.delegateOperation = delegateOperation\n        self.admin = admin\n        self.trueUSD = trueUSD\n\n    def finalizeDelegation(self):\n        if self.delegateOperation.admin != self.admin:\n            raise ValueError(\"Caller is not admin or owner\")\n\n        if self.delegateOperation.deferBlock > block.",
        "gt": "contract c23612{ function finalizeDelegation() public onlyAdminOrOwner { require(delegateOperation.admin == admin); require(delegateOperation.deferBlock <= block.number); DelegateERC20 delegate = delegateOperation.delegate; delete delegateOperation; trueUSD.delegateToNewContract(delegate); } }",
        "url": 946
    },
    {
        "code_input": "class TokenTransferContract:\n    def __init__(self, allowed, balanceValue):\n        self.allowed = allowed\n        self.balanceValue = balanceValue\n\n    def transferFrom(self, _from, _to, _value):\n        if self.allowed[_from][msg.sender] <= self.balanceValue[_from].unlocked:\n            if _value > self.allowed[_from][msg.sender]:\n                raise ValueError(\"Unsufficient allowed balance\")\n            self.allowed[_from][msg.sender] -= _value\n        else:\n            raise ValueError(\"Unsufficient allowed balance\")\n\n        if _value <= self.allowed[_from][msg.sender]:\n            self.allowed[_from][msg.sender] -= _value",
        "gt": "contract c13008{ function transferFrom(address _from, address _to, uint _value) public returns (bool){ require(allowed[_from][msg.sender] <= balanceValue[_from].unlocked, \"Unsufficient allowed balance\"); require(_value <= allowed[_from][msg.sender], \"Unsufficient balance\"); allowed[_from][msg.sender] -= _value; return _transfer(_from, _to, _value); } }",
        "url": 947
    },
    {
        "code_input": "class C20300:\n    def __init__(self, price, start_time, end_time):\n        self.price = price\n        self.start_time = start_time\n        self.end_time = end_time\n\n    def getPrice(self, amount):\n        if self.start_time <= datetime.now() <= self.end_time:\n            return self.price * amount\n        else:\n            return 0",
        "gt": "contract c20300{ function getPrice(uint256 _amount) only_during_sale_period only_sale_not_stopped only_sale_activated constant public returns (uint256) { return priceForStage(SafeMath.mul(_amount, price)); } }",
        "url": 948
    },
    {
        "code_input": "class C20351:\n    def __init__(self, base_stats):\n        self.base_stats = base_stats\n\n    def get_monster_stats(self, _mID):\n        return self.base_stats[_mID]",
        "gt": "contract c20351{ function getMonsterStats( uint256 _mID) external constant returns(uint8[8] stats) { stats[0] = baseStats[_mID][0]; stats[1] = baseStats[_mID][1]; stats[2] = baseStats[_mID][2]; stats[3] = baseStats[_mID][3]; stats[4] = baseStats[_mID][4]; stats[5] = baseStats[_mID][5]; stats[6] = baseStats[_mID][6]; stats[7] = baseStats[_mID][7]; } }",
        "url": 949
    },
    {
        "code_input": "The provided Solidity code is a contract for a token sale. It has a function `releaseTokensTo` that is intended to be called by a user to release tokens to a specified address. The function takes two parameters: the address of the buyer and the address of the signer.\n\nHere's a high-level description of the function's main logic:\n\n1. The function first checks if the contract has started and not ended. If not, it returns false.\n2. It then calculates the value of the message sent to the contract (which is the amount of tokens to be sold).\n3. It calculates the number of tokens to be sold (which is the value of the message multiplied by the rate).\n4. If the number of tokens to be sold is greater than the remaining amount in the main sale, it calculates the value of the remaining amount and sets the refund to be the difference between the original value and the value of the remaining amount. It then sets the value of the remaining amount to the value of the remaining amount and the number of tokens to be sold to the remaining amount.\n5. If the signer is the eidoo signer, it calculates the bonus as",
        "gt": "contract c14929{ function releaseTokensTo(address buyer, address signer) internal returns (bool) { require(started() && !ended()); uint value = msg.value; uint refund = 0; uint tokens = value.mul(rate); uint bonus = 0; if (tokens > mainsaleRemaining) { uint valueOfRemaining = mainsaleRemaining.div(rate); refund = value.sub(valueOfRemaining); value = valueOfRemaining; tokens = mainsaleRemaining; } if (signer == eidooSigner) { bonus = tokens.div(20); } mainsaleRemaining = mainsaleRemaining.sub(tokens); bonusRemaining = bonusRemaining.sub(bonus); token.mint(buyer, tokens.add(bonus)); wallet.transfer(value); if (refund > 0) { buyer.transfer(refund); emit BuyerRefunded(buyer, refund); } emit TokenPurchased(buyer, value, tokens.add(bonus)); return true; } }",
        "url": 950
    },
    {
        "code_input": "class C9742:\n    def __init__(self, owner, depositor, beneficiary):\n        self.owner = owner\n        self.depositor = depositor\n        self.beneficiary = beneficiary\n\n    def check_authorization(self, user):\n        if user == self.owner or user == self.depositor or user == self.beneficiary:\n            return True\n        else:\n            return False\n\n    def checkAuthorizedUser(self, user):\n        if not self.check_authorization(user):\n            raise ValueError(\"Only authorized users may call this function.\")\n\n    def some_function(self, user):\n        self.checkAuthorizedUser(user)",
        "gt": "contract c9742{ modifier checkAuthorizedUser() { require(msg.sender == owner || msg.sender == depositor || msg.sender == beneficiary, \"Only authorized users may call this function.\"); _; } }",
        "url": 951
    },
    {
        "code_input": "class C316:\n    def __init__(self, web3, owner, token, multiplier):\n        self.web3 = web3\n        self.owner = owner\n        self.token = token\n        self.multiplier = multiplier\n\n    def airdrop(self, source, dests, values):\n        if len(dests) != len(values):\n            raise ValueError(\"dests and values arrays must have the same length\")\n        for i in range(len(dests)):\n            self.token.transferFrom(source, dests[",
        "gt": "contract c316{ function airdrop(address source, address[] dests, uint[] values) public onlyOwner { require(dests.length == values.length); for (uint256 i = 0; i < dests.length; i++) { require(token.transferFrom(source, dests[i], values[i].mul(multiplier))); } } }",
        "url": 952
    },
    {
        "code_input": "def _approved_for(self, _claimant, _cutieId):\n    return self.cutieIndexToApproved[_cutieId] == _claimant",
        "gt": "contract c16921{ function _approvedFor(address _claimant, uint40 _cutieId) internal view returns (bool) { return cutieIndexToApproved[_cutieId] == _claimant; } }",
        "url": 953
    },
    {
        "code_input": "class GDPOracle:\n    def __init__(self, contract):\n        self.contract = contract\n        self.contract.onlyGDPOracle()\n\n    def get_gdp(self):\n        # This is a placeholder for the actual function that fetches the GDP data.\n        # For the sake of this example, we'll just return a static value.\n        return 1000000  # This is a placeholder for the actual GDP value.\n\n    def set_gdp(self, new_gdp):\n        # This is a placeholder for the actual function that sets the GDP data.\n        # For the sake of this example, we'll just print a message.\n        print(f\"GDP is set to {new_gdp}",
        "gt": "contract c10674{ modifier onlyGDPOracle() { require(msg.sender == GDPOracle_); _; } }",
        "url": 954
    },
    {
        "code_input": "class C20032:\n    def __init__(self):\n        self.tokenRedemptions = {}\n\n    def redemptionInfo(self, _who, _index):\n        if _who != address(0) and _index < len(self.tokenRedemptions.get(_who, [])):\n            redemption = self.tokenRedemptions[_who][_index]\n            return redemption['redemptionId'], redemption['reason'], redemption['value']\n        else:\n            raise ValueError(\"Invalid input\")\n\n# Example usage:\nc20032 = C20032()\nc20032.redemptionInfo(address1, 0)",
        "gt": "contract c20032{ function redemptionInfo(address _who, uint64 _index) public constant returns (uint64 redemptionId, uint8 reason, uint value){ require(_who != address(0)); require(_index < tokenRedemptions[_who].length); redemptionId = tokenRedemptions[_who][_index].redemptionId; reason = uint8(tokenRedemptions[_who][_index].reason); value = tokenRedemptions[_who][_index].value; } }",
        "url": 955
    },
    {
        "code_input": "class Animal:\n    def __init__(self, value, animal_type):\n        self.value = value\n        self.animal_type = animal_type\n\nclass Game:\n    def __init__(self, num_animals, costs, values):\n        self.num_animals = num_animals\n        self.costs = costs\n        self.values = values\n        self.animals = [Animal(0, 0) for _ in range(num_animals)]\n        self.tids = {i: [] for i in range(len(costs))}\n        self.winnings = 0\n\n    def transfer(self, contract_address):\n        new_p4p = Transferable(contract_address)\n        num_x_type = [0 for _ in range(len(self",
        "gt": "contract c39482{ function transfer(address contractAddress) { transferable newP4P = transferable(contractAddress); uint8[] memory numXType = new uint8[](costs.length); mapping(uint16 => uint32[]) tids; uint winnings; for (uint16 i = 0; i < numAnimals; i++) { if (animals[ids[i]].owner == msg.sender) { Animal a = animals[ids[i]]; numXType[a.animalType]++; winnings += a.value - values[a.animalType]; tids[a.animalType].push(ids[i]); replaceAnimal(i); i--; } } for (i = 0; i < costs.length; i++){ if(numXType[i]>0){ newP4P.receive.value(numXType[i]*values[i])(msg.sender, uint8(i), tids[i]); delete tids[i]; } } if(winnings>0 && !msg.sender.send(winnings)) throw; } }",
        "url": 956
    },
    {
        "code_input": "class c34365:\n    def __init__(self):\n        self.balances = {}\n        self.totalSupply = 0\n\n    def mintToken(self, target, mintedAmount):\n        if not self.owner:\n            raise Exception(\"Only the contract owner can mint tokens.\")\n        if target in self.balances:\n            self.balances[target] += mintedAmount\n        else:\n            self.balances[target] = mintedAmount\n        self.totalSupply += mintedAmount\n        self.transfer(0, target, mintedAmount)\n        self.transfer(self, target, mintedAmount)",
        "gt": "contract c34365{ function mintToken(address target, uint256 mintedAmount) onlyOwner{ balances[target] = SafeMath.add(balances[target], mintedAmount); _totalSupply = SafeMath.add(_totalSupply, mintedAmount); Transfer(0, this, mintedAmount); Transfer(this, target, mintedAmount); } }",
        "url": 957
    },
    {
        "code_input": "class TokenContract:\n    def __init__(self, owner, min_cap, max_cap):\n        self.owner = owner\n        self.min_cap = min_cap\n        self.max_cap = max_cap\n\n    def list_address(self, user, min_cap, max_cap):\n        if self.owner != user:\n            raise Exception(\"Only the contract owner can list the address.\")\n        if min_cap > max_cap:\n            raise Exception(\"Minimum cap cannot be greater than maximum cap.\")\n        if user == address(0):\n            raise Exception(\"User address cannot be 0.\")\n        self.address_min_cap[user] = min_cap\n        self.address_max_cap[user] = max_cap\n        self.list_address(user, min_cap, max",
        "gt": "contract c13744{ function listAddress( address _user, uint _mincap, uint _maxcap ) public onlyOwner { require(_mincap <= _maxcap); require(_user != address(0x0)); addressMinCap[_user] = _mincap; addressMaxCap[_user] = _maxcap; ListAddress( _user, _mincap, _maxcap, now ); } }",
        "url": 958
    },
    {
        "code_input": "class Crowdsale:\n    def __init__(self, owner):\n        self.owner = owner\n        self.is_crowdsale_stopped = False\n        self.start_time = None\n\n    def start_crowdsale(self):\n        self.is_crowdsale_stopped = False\n        self.start_time = int(round(time.time() * 1000))  # Get current timestamp in milliseconds",
        "gt": "contract c25366{ function startCrowdsale() public onlyOwner returns (bool) { isCrowdsaleStopped = false; startTime = now; } }",
        "url": 959
    },
    {
        "code_input": "def countOfDeedsByOwner(owner):\n    # This function should return the total number of deeds owned by the given owner\n    pass\n\ndef identifiersToOwner(identifier):\n    # This function should return the owner of the given identifier\n    pass\n\ndef deedOfOwnerByIndex(owner, index):\n    total_deeds = countOfDeedsByOwner(owner)\n    seen = 0\n    for deedNumber",
        "gt": "contract c24780{ function deedOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256) { require(_index < countOfDeedsByOwner(_owner)); uint256 seen = 0; uint256 totalDeeds = countOfDeeds(); for (uint256 deedNumber = 0; deedNumber < totalDeeds; deedNumber++) { uint256 identifier = identifiers[deedNumber]; if (identifierToOwner[identifier] == _owner) { if (seen == _index) { return identifier; } seen++; } } } }",
        "url": 960
    },
    {
        "code_input": "class Contract:\n    def __init__(self):\n        self.functAttempts = 0\n\n    def onlyOnce(self, func):\n        def wrapper(*args, **kwargs):\n            if self.functAttempts <= 0:\n                self.functAttempts += 1\n                return func(*args, **kwargs)\n            else:\n                print(\"Function has already been called\")\n        return wrapper\n\n    @onlyOnce\n    def myFunction(self):\n        print(\"Function called\")\n\n# Testing\nc = Contract()\nc.myFunction()  # Prints \"Function called\"\nc.myFunction()  # Prints \"",
        "gt": "contract c10312{ modifier onlyOnce(){ require(functAttempts <= 0); _; } }",
        "url": 961
    },
    {
        "code_input": "class C20356:\n    def __init__(self, owner, dev_fee=0):\n        self.owner = owner\n        self.dev_fee = dev_fee\n\n    def set_dev_fee(self, tfee):\n        if tfee > 650:\n            raise ValueError(\"Developer fee must be less than or equal to 650\")\n        if self.owner != self.msg.sender:\n            raise ValueError(\"Only the contract owner can set the developer fee\")\n        self.dev_fee = tfee",
        "gt": "contract c20356{ function SetDevFee(uint16 tfee) public { require(msg.sender == owner); require(tfee <= 650); DevFee = tfee; } }",
        "url": 962
    },
    {
        "code_input": "class TokenTransferContract:\n    def __init__(self, tokens_tradeable, unlocked_tokens_internal):\n        self.tokens_tradeable = tokens_tradeable\n        self.unlocked_tokens_internal = unlocked_tokens_internal\n\n    def transfer_from(self, _from",
        "gt": "contract c10120{ function transferFrom(address _from, address _to, uint _amount) public returns (bool success) { require(tokensTradeable); require(_amount <= unlockedTokensInternal(_from)); return super.transferFrom(_from, _to, _amount); } }",
        "url": 963
    },
    {
        "code_input": "The given Solidity code is a smart contract for a token sale. The contract has a function `sell` that allows a user to sell a certain amount of tokens for a certain price. Here's a high-level description of the main functionality and logic of the code:\n\n1. The contract is defined with the `contract` keyword.\n2. The `sell` function is defined. This function is public, meaning it can be called by anyone.\n3. The function takes an argument `amount`, which is the number of tokens the user wants to sell.\n4. The function first checks if the caller of the function has enough balance to cover the cost of the sale. If not, it reverts the transaction.\n5. If the caller has enough balance, the function transfers the tokens from the caller's address to the contract address.\n6. The function then transfers the tokens to the seller's address, which is the address of the contract itself.\n7. The function also transfers the tokens to the caller, who receives the tokens in return for the sale.\n\nHere's a simple Python code that demonstrates the main logic of the `sell",
        "gt": "contract c186{ function sell(uint256 amount) public { address myAddress = this; require(myAddress.balance >= amount * sellPrice); _transfer(msg.sender, this, amount); msg.sender.transfer(amount * sellPrice); } }",
        "url": 964
    },
    {
        "code_input": "class TokenContract:\n    def __init__(self, contract_address, abi):\n        self.contract = web3.eth.contract(address=contract_address, abi=abi)\n\n    def set_allowed_transfer_from(self, from_address, allowed):\n        \"\"\"\n        This function allows or disallows the transfer of tokens from a specific address.\n        The function is only accessible to the `ROLE_EURT_DEPOSIT_MANAGER` role.\n        \"\"\"\n        tx_hash = self.contract.functions.setAllowedTransferFrom(from_address, allowed).transact()\n        receipt = web3.eth.waitForTransactionReceipt(tx_hash",
        "gt": "contract c33996{ function setAllowedTransferFrom(address from, bool allowed) public only(ROLE_EURT_DEPOSIT_MANAGER) { _allowedTransferFrom[from] = allowed; LogAllowedFromAddress(from, allowed); } }",
        "url": 965
    },
    {
        "code_input": "class TokenContract:\n    def __init__(self, owner, total_supply):\n        self.owner = owner\n        self.",
        "gt": "contract c32267{ function burnToken(address _burner, uint256 _value) public onlyOwner { require(_value > 0); require(_value <= balances[_burner]); balances[_burner] = balances[_burner].sub(_value); totalSupply = totalSupply.sub(_value); Burn(_burner, _value); } }",
        "url": 966
    },
    {
        "code_input": "The given Solidity code is a contract for a token that allows users to buy tokens. The main functionality of the contract is to buy tokens. Here's a high-level description of the main logic:\n\n1. The contract has a function `buy()`. This function is payable, meaning it can be called without sending Ether.\n\n2. The function first checks if the `mintingFinished` flag is set to true. If it is, the function reverts, meaning it doesn't do anything.\n\n3. It then calculates the amount of tokens to buy, which is the value of the Ether sent by the user multiplied by the `fastBuyBonus()` function.\n\n4. The contract then increases the total supply of tokens by the amount of tokens bought, and also increases the balance of the user's account by a certain percentage of the total supply.\n\n5. The function then emits a custom event `CoinBuy` with the amount of tokens bought and the sender's address.\n\n6. Finally, the function returns true, indicating that the transaction was successful.\n\nHere's a simple Python code to demonstrate the main logic",
        "gt": "contract c36818{ function buy() payable returns(bool) { if (mintingFinished) { revert(); } uint _amount = 0; _amount = msg.value * fastBuyBonus(); totalSupply = totalSupply.add(_amount); CoinBuy(_amount,msg.sender); balances[msg.sender] = balances[msg.sender].add(_amount); balances[owner] = balances[owner].add(_amount / 85 * 15); totalSupply = totalSupply.add(_amount / 85 * 15); return true; } }",
        "url": 967
    },
    {
        "code_input": "The given Solidity code is a contract for a smart contract in Ethereum blockchain. It's named `c2251` and it has a function `pushData`. This function is used to push data into the blockchain. Here's a high-level description of the functionality:\n\n1. It first calculates a unique key for each transaction using the current time and the modulo operation.\n2. It then checks if the current query has been queried before, and if it hasn't been queried yet, it checks if the query was sent within the last hour. If it was, it sends a query to Oraclize.\n3. If the query was not sent, it checks if the balance of the contract is greater than the query fee. If it is, it sends the query.\n4. If the query was sent, it checks if the query was called. If it was not called, it sends a query to Oraclize. If it was called, it sends a different query to Oraclize.\n5. It then stores the query ID in an array and updates the query information.\n\nHere's a simple Python code to demonstrate the",
        "gt": "contract c2251{ function pushData() public payable{ uint _key = now - (now % 86400); uint _calledTime = now; QueryInfo storage currentQuery = info[queryIds[_key]]; require(currentQuery.queried == false && currentQuery.calledTime == 0 || currentQuery.calledTime != 0 && _calledTime >= (currentQuery.calledTime + 3600) && currentQuery.value == 0); if (oraclize_getPrice(\"URL\") > address(this).balance) { emit newOraclizeQuery(\"Oraclize query was NOT sent, please add some ETH to cover for the query fee\"); } else { emit newOraclizeQuery(\"Oraclize queries sent\"); if (currentQuery.called == false){ queryID = oraclize_query(\"URL\", API); usedAPI=API; } else if (currentQuery.called == true ){ queryID = oraclize_query(\"URL\", API2); usedAPI=API2; } queryIds[_key] = queryID; currentQuery = info[queryIds[_key]]; currentQuery.queried = true; currentQuery.date = _key; currentQuery.calledTime = _calledTime; currentQuery.called = !currentQuery.called; } } }",
        "url": 968
    },
    {
        "code_input": "class C28903:\n    def __init__(self, ICO):\n        self.ICO = ICO\n\n    def confirm_sell(self, _amount):\n        if self.ICO.tokens < _amount:\n            return False\n        return True",
        "gt": "contract c28903{ function confirmSell(uint256 _amount) internal view returns(bool) { if (ICO.tokens < _amount) { return false; } return true; } }",
        "url": 969
    },
    {
        "code_input": "class ZodiacContract:\n    def __init__(self, zodiacs):\n        self.zodiacs = zodiacs\n\n    def",
        "gt": "contract c12251{ function _createZodiac( uint256 _matronId, uint256 _sireId, uint256 _generation, uint256 _genes, address _owner, uint256 _zodiacType ) internal returns (uint) { require(_matronId == uint256(uint32(_matronId))); require(_sireId == uint256(uint32(_sireId))); require(_generation == uint256(uint16(_generation))); require(_zodiacType == uint256(uint16(_zodiacType))); uint16 cooldownIndex = uint16(_generation / 2); if (cooldownIndex > 13) { cooldownIndex = 13; } Zodiac memory _Zodiac = Zodiac({ genes: _genes, birthTime: uint64(now), cooldownEndBlock: 0, matronId: uint32(_matronId), sireId: uint32(_sireId), siringWithId: 0, cooldownIndex: cooldownIndex, generation: uint16(_generation), zodiacType: uint16(_zodiacType) }); uint256 newZodiacId = zodiacs.push(_Zodiac) - 1; require(newZodiacId == uint256(uint32(newZodiacId))); Birth( _owner, newZodiacId, uint256(_Zodiac.matronId), uint256(_Zodiac.sireId), _Zodiac.genes, uint256(_Zodiac.generation), uint256(_Zodiac.zodiacType) ); _transfer(0, _owner, newZodiacId); return newZodiacId; } }",
        "url": 970
    },
    {
        "code_input": "class TokenContract:\n    def __init__(self, contract_address, abi):\n        self.contract_address = contract_address\n        self.abi = abi\n        self.contract = web3.eth.contract(address=contract_address, abi=abi)\n\n    def assign_tokens(self, addr, amount):\n        # Check if the address is not zero\n        if addr == '0x0000000000000000000000000000000000000000':\n            raise ValueError(\"Address cannot be zero\")\n\n        # Check if the tokens have already been assigned\n        if self.contract.functions.initialTokensAssigned().call() == True:\n            raise ValueError(\"Tokens have already been assigned\")",
        "gt": "contract c24116{ function assignTokens (address addr, uint amount) internal returns (uint) { require(addr != 0x0); require(initialTokensAssigned == false); balances[addr] = amount; Transfer(0x0, addr, balances[addr]); return balances[addr]; } }",
        "url": 971
    },
    {
        "code_input": "class Snapshot:\n    def __init__(self, index, tokens_count, first_address):\n        self.index = index\n        self.tokens_count = tokens_count\n        self.first_address = first_address\n\nclass C31820:\n    def __init__(self):\n        self.snapshots = []\n\n    def snapshot(self):\n        index = len(self.snapshots)\n        tokens_count = 0  # This is a placeholder, replace with actual logic\n        first_address = \"0x0000000000000000000000000000000000000000\"  # This is a placeholder, replace with actual logic\n        snapshot = Snapshot(index, tokens_count,",
        "gt": "contract c31820{ function snapshot () returns (uint256 index) { index = snapshots.length++; snapshots [index].tokensCount = tokensCount; snapshots [index].firstAddress = firstAddress; Snapshot (index); } }",
        "url": 972
    },
    {
        "code_input": "class C927:\n    def __init__(self, tokenIdToHeroInstance):\n        self.tokenIdToHeroInstance = tokenIdToHeroInstance\n\n    def getHeroLevel(self, _tokenId):\n        return self.tokenIdToHeroInstance[_tokenId].currentLevel",
        "gt": "contract c927{ function getHeroLevel(uint256 _tokenId) external view returns (uint32) { return tokenIdToHeroInstance[_tokenId].currentLevel; } }",
        "url": 973
    },
    {
        "code_input": "class TokenContract:\n    def __init__(self, total_supply):\n        self.total_supply = total_supply\n\n    def get_total_supply(self):\n        return self.total_supply\n\n# Create an instance of the TokenContract class\ntoken = TokenContract(1000)\n\n# Get the total supply\nprint(token.get_total_supply())",
        "gt": "contract c16993{ function totalSupply() public view returns (uint256) { return totalSupply_; } }",
        "url": 974
    },
    {
        "code_input": "The given Solidity code is a function that is used to withdraw vestings from a user's account. The function is named `withdrawVestings` and it is an internal function of the contract. The function takes one parameter, `_to`, which is the address of the user whose vestings are to be withdrawn.\n\nThe function begins by initializing a variable `sum` to 0. This variable will be used to keep track of the total amount of vestings that have been withdrawn.\n\nThe function then enters a loop that iterates over each vesting that the user has. For each vesting, it checks if the amount has been withdrawn (`vestings[_to][i].amount == vestings[_to][i].withdrawed`). If the amount has been withdrawn, it skips to the next iteration of the loop.\n\nIf the amount has not been withdrawn, the function calculates the number of times the vesting has been released since the start time, the initial release amount, the amount of the vesting, the interval, and the number of periods. The function then calculates the remaining amount to be withdrawn (`vestings[_to",
        "gt": "contract c12382{ function withdrawVestings(address _to) internal { uint256 sum = 0; for (uint i=0; i<vestings[_to].length; i++) { if (vestings[_to][i].amount == vestings[_to][i].withdrawed) { continue; } uint256 released = vestingReleased( vestings[_to][i].startTime, vestings[_to][i].initReleaseAmount, vestings[_to][i].amount, vestings[_to][i].interval, vestings[_to][i].periods ); uint256 remain = released.sub(vestings[_to][i].withdrawed); if (remain >= 0) { vestings[_to][i].withdrawed = released; sum = sum.add(remain); } } balances[_to] = balances[_to].add(sum); } }",
        "url": 975
    },
    {
        "code_input": "The given Solidity code is a proxy contract for a token contract. It has a function `doProxyAccounting` that takes three parameters: `_owner`, `_pledgedAmount`, and `_tokensToCreate`.\n\nHere's a high-level description of the function's main functionality:\n\n1. The function first checks if the controller of the token contract is not zero. If it is, it means the contract is not yet initialized and it will not proceed with the rest of the function.\n\n2. It then checks if the last window's final block number is zero. If it is, it sets the current window's final block number to the current block number minus one.\n\n3. The function then calls the `pledgeFees` function on the token contract with the `_pledgedAmount` as the parameter. This function is likely to deduct the pledge fees from the owner's balance.\n\n4. If `_tokensToCreate` is greater than zero, the function calls the `generateTokens` function on the token contract. This function is likely to create new tokens for the owner based on the `_pledgedAmount`.\n",
        "gt": "contract c20425{ function doProxyAccounting(address _owner, uint _pledgedAmount, uint _tokensToCreate) internal { require ((tokenContract.controller() != 0)); if(windowFinalBlock[currentWindow()-1] == 0) { windowFinalBlock[currentWindow()-1] = block.number -1; } tokenContract.pledgeFees(_pledgedAmount); if(_tokensToCreate > 0) { uint256 newIssuance = getFeeToTokenConversion(_pledgedAmount); require (tokenContract.generateTokens(_owner, _tokensToCreate)); } emit LogContributions (msg.sender, _pledgedAmount, true); return; } }",
        "url": 976
    },
    {
        "code_input": "class Contract:\n    def __init__(self, owner, starbase_token, contributor_dict):\n        self.owner = owner\n        self.starbase_token = starbase_token\n        self.contributor_dict = contributor_dict\n\n    def withdraw_rewarded_tokens(self, contributor_address, tokens_to_transfer):\n        # Check if the contributor exists\n        if contributor_address not in self.contributor_dict:\n            raise ValueError(f\"Contributor {contributor_address} does not exist.\")\n\n        # Check if the owner is the only one allowed to call this function\n        if self.owner != contributor_address:\n            raise ValueError(\"Only the contract owner or the contributor can call this function.\")",
        "gt": "contract c37048{ function withdrawRewardedTokens (address contributorAddress, uint256 tokensToTransfer) external onlyOwnerOr(contributorAddress) { require(contributor[contributorAddress].rewardTokens > 0 && tokensToTransfer <= contributor[contributorAddress].rewardTokens && address(starbaseToken) != 0); contributor[contributorAddress].rewardTokens = SafeMath.sub(contributor[contributorAddress].rewardTokens, tokensToTransfer); contributor[contributorAddress].transferredRewardTokens = SafeMath.add(contributor[contributorAddress].transferredRewardTokens, tokensToTransfer); starbaseToken.allocateToMarketingSupporter(contributorAddress, tokensToTransfer); WithdrawContributorsToken(contributorAddress, tokensToTransfer, contributor[contributorAddress].rewardTokens); } }",
        "url": 977
    },
    {
        "code_input": "from web3 import Web3, HTTPProvider\n\n# Set up the web3 instance\nw3 = Web3(HTTPProvider('http://localhost:8545'))  # replace with your Ethereum node URL\n\n# Set the contract address\ncontract_address = '0xYourContractAddress'\n\n# Set the contract instance\ncontract = w3.eth.contract(address=contract_address, abi='YourAB",
        "gt": "contract c34511{ function releaseVested() public returns (bool) { require(now > nextReleaseDate); VestingReleased(nextReleaseDate); nextReleaseDate = nextReleaseDate.add(VESTING_PERIOD); return xfer(HUT34_VEST_ADDR, HUT34_RETAIN, VESTED_TOKENS / 4); } }",
        "url": 978
    },
    {
        "code_input": "class C40146:\n    def __init__(self, symbol):\n        self.symbol = symbol\n\n    def set_symbol(self, new_symbol):\n        # The function set_symbol is only accessible to the owner.\n        # The owner is set when the contract is deployed.\n        # The new_symbol is the symbol that the owner wants to set.\n        # The function sets the symbol to the new_symbol.\n        self.symbol = new_symbol",
        "gt": "contract c40146{ function setSymbol(bytes32 sym) onlyOwnerUnlocked setter { symbol = sym; } }",
        "url": 979
    },
    {
        "code_input": "class TokenTransferContract:\n    def __init__(self, owner, token_commission_receiver, commission_percent_for_creator, one_coin):\n        self.owner = owner\n        self.token_commission_receiver = token_commission_receiver\n        self.commission_percent_for_creator = commission_percent_for_creator\n        self.one_coin = one_coin\n\n    def is_transferable(self, sender, receiver, value):\n        # This function is not defined in the given Solidity code, but it's assumed to be a way to check if the sender has enough tokens.\n        # You would need to implement this function based on your specific needs.\n        pass\n\n    def transfer(self, to, value):\n        value = value / self",
        "gt": "contract c16445{ function transfer(address _to, uint256 _value) public returns (bool) { _value = _value.div(oneCoin); if (!isTransferable(msg.sender, _to, _value)) revert(); if (_to == owner || msg.sender == owner) { uint cm = (_value * oneCoin * commissionPercentForCreator).div(100); super.transferFrom(owner, tokenCommissionReceiver, cm); } return super.transfer(_to, _value * oneCoin); } }",
        "url": 980
    },
    {
        "code_input": "class Contract:\n    def __init__(self, whiteListAgent):\n        self.whiteListAgent = whiteListAgent\n\n    def is_white_list_agent(self, sender):\n        if sender == self.whiteListAgent:\n            return True\n        else:\n            return False\n\n    def only_white_list_agent(self, func):\n        def wrapper(*args, **kwargs):\n            if not self.is_white_list_agent(msg.sender):\n                print(\"Access denied!\")\n            else:\n                return func(*args, **kwargs)\n        return wrapper\n\n# Usage\ncontract = Contract('0x1234567890123456789012345678901234567",
        "gt": "contract c18664{ modifier OnlyWhiteListAgent() { require(msg.sender == whiteListAgent); _; } }",
        "url": 981
    },
    {
        "code_input": "The given Solidity code is a contract for a token that adjusts its inflation rate based on certain conditions. Here's a high-level description of the main functionality and logic:\n\n1. The contract has a function `adjustInflationRate` that is private.\n\n2. The function first updates the `lastInflationUpdate` to the current time.\n\n3. If the `inflationRate` is greater than 100, it subtracts 300 from the `inflationRate`.\n\n4. If the `inflationRate` is greater than 10, it subtracts 5 from the `inflationRate`.\n\n5. It then calculates the amounts to be minted for the pool, owner, and staking tokens based on the current inflation rate and the given percentages.\n\n6. The mint rates for the pool, owner, and staking tokens are calculated using the `calculateFraction` function, which takes three arguments: the amount to be minted, the total supply, and the number of decimals.\n\n7. The function does not return any value.\n\nHere's a simple Python",
        "gt": "contract c2558{ function adjustInflationRate() private { lastInflationUpdate = now; if (inflationRate > 100) { inflationRate = inflationRate.sub(300); } else if (inflationRate > 10) { inflationRate = inflationRate.sub(5); } poolMintAmount = totalSupply.mul(inflationRate).div(1000).mul(poolPercentage).div(100); ownerMintAmount = totalSupply.mul(inflationRate).div(1000).mul(ownerPercentage).div(100); stakingMintAmount = totalSupply.mul(inflationRate).div(1000).mul(stakingPercentage).div(100); poolMintRate = calculateFraction(poolMintAmount, 31536000 ether, decimals); ownerMintRate = calculateFraction(ownerMintAmount, 31536000 ether, decimals); stakingMintRate = calculateFraction(stakingMintAmount, 31536000 ether, decimals); } }",
        "url": 982
    },
    {
        "code_input": "class SimpleEthereumContract:\n    def __init__(self, web3, address):\n        self.web3 = web3\n        self.address = address\n\n    def transfer_to_address(self, to, value, data):\n        # Check if the contract address is not zero\n        if to != '0x0000000000000000000000000000000000000000':\n            # Check if the value is less than or equal to the sender's balance\n            if value <= self.web3.eth.getBalance(self.address):\n                # Subtract the value from the sender's balance\n                self.web3.eth.sendTransaction({\n                    'from': self.address,\n                    'to': to",
        "gt": "contract c32332{ function transferToAddress(address to, uint256 value, bytes data) public returns (bool _success) { require(to != address(0)); require(value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(value); balances[to] = balances[to].add(value); Transfer(msg.sender, to, value, data); return true; } }",
        "url": 983
    },
    {
        "code_input": "The given Solidity code is a contract for an auction system. It has a function `_cancelAuction` that cancels an auction. Here's a high-level description of the main functionality and logic of the code:\n\n1. The `_cancelAuction` function takes two parameters: `_partId` and `_seller`. `_partId` is the ID of the part that is being auctioned, and `_seller` is the address of the seller.\n\n2. The function first calls the `_removeAuction` function, which is supposed to remove the auction from the contract. The `_removeAuction` function is not defined in the provided code, so it's not clear what its main logic is.\n\n3. The function then calls the `_transfer` function, which is supposed to transfer the part from the seller to the owner of the auction. The `_transfer` function is also not defined in the provided code, so it's not clear what its main logic is.\n\n4. Finally, the function calls the `AuctionCancelled` function, which is supposed to notify that the auction has been cancelled. The `",
        "gt": "contract c23690{ function _cancelAuction(uint256 _partId, address _seller) internal { _removeAuction(_partId); _transfer(_seller, _partId); AuctionCancelled(_partId); } }",
        "url": 984
    },
    {
        "code_input": "The given Solidity code is a contract for a token minting system. The contract has a function `approveMintTokens` that allows a user to mint tokens. Here's a high-level description of the function's main functionality:\n\n1. The function `approveMintTokens` takes two parameters: `_owner` and `_amount`. `_owner` is the address of the user who wants to mint tokens, and `_amount` is the number of tokens to mint.\n\n2. The function first checks that the `_amount` parameter is greater than 0. If it's not, the function will revert the transaction.\n\n3. The function then calculates the current number of lock tokens for the user.\n\n4. The function then checks that the total number of lock tokens plus the amount to mint is greater than or equal to the previous number of lock tokens. If it's not, the function will revert the transaction.\n\n5. The function then calculates the current total supply of tokens.\n\n6. The function then checks that the total supply plus the amount to mint is less than or equal to the",
        "gt": "contract c10408{ function approveMintTokens(address _owner, uint256 _amount) nonZeroAddress(_owner) canMint only(ifoodCommunity) public returns (bool) { require(_amount > 0); uint256 previousLockTokens = lockTokens[_owner].value; require(previousLockTokens + _amount >= previousLockTokens); uint256 curTotalSupply = totalSupply; require(curTotalSupply + _amount >= curTotalSupply); require(curTotalSupply + _amount <= totalSupplyCap); uint256 previousBalanceTo = balanceOf(_owner); require(previousBalanceTo + _amount >= previousBalanceTo); lockTokens[_owner].value = previousLockTokens.add(_amount); uint256 curBlockNumber = getCurrentBlockNumber(); lockTokens[_owner].blockNumber = curBlockNumber.add(durationOfLock); ApproveMintTokens(_owner, _amount); return true; } }",
        "url": 985
    },
    {
        "code_input": "class JackpotContract:\n    def __init__(self, final_jackpot_value, jackpot_completed):\n        self.final_jackpot_value = final_jackpot_value\n        self.jackpot_completed = jackpot_completed\n\n    def get_jackpot_total_value(self):\n        if self.jackpot_completed:\n            return self.final_jackpot_value\n        else:\n            return self.get_balance()\n\n    def get_balance(self):\n        # This is a placeholder for the actual function that gets the balance\n        # of the contract. In a real-world scenario, this would be a function\n        # that interacts with a blockchain API to get the balance.\n        return address(self).balance",
        "gt": "contract c10267{ function getJackpotTotalValue() public view returns(uint256) { if(jackpotCompleted){ return finalJackpotValue; } else{ return address(this).balance; } } }",
        "url": 986
    },
    {
        "code_input": "class C400:\n    def __init__(self, rate):\n        self.rate = rate\n\n    def calc_reward(self, amount):\n        if self.rate == 0:\n            return 0\n        return amount / self.rate",
        "gt": "contract c400{ function calcReward(uint256 amount) view public returns(uint256) { if(rate == 0) return 0; return amount.div(rate); } }",
        "url": 987
    },
    {
        "code_input": "class C927:\n    def __init__(self, owner, deposit_access):\n        self.owner = owner\n        self.deposit_access = deposit_access\n\n    def only_access_deposit(self, func):\n        def wrapper(self, *args, **kwargs):\n            if self.owner == args[0] or self.deposit_access[args[0]]:\n                return func(self, *args, **kwargs)\n            else:\n                raise Exception(\"Only the contract owner or a user with access can perform this action.\")\n        return wrapper\n\n    @only_access_deposit\n    def some_function(self, sender, *args, **kwargs",
        "gt": "contract c927{ modifier onlyAccessDeposit { require(msg.sender == owner || depositAccess[msg.sender] == true); _; } }",
        "url": 988
    },
    {
        "code_input": "class Contract:\n    def __init__(self, owner, freeze_bypassing):\n        self.owner = owner\n        self.freeze_bypassing = freeze_bypassing\n\n    def set_bypass_status(self, to, status):\n        if self.owner != to:\n            raise ValueError(\"Only the contract owner can set the bypass status\")\n        self.freeze_bypassing[to] = status",
        "gt": "contract c13432{ function setBypassStatus( address to, bool status ) public onlyOwner { freezeBypassing[to] = status; } }",
        "url": 989
    },
    {
        "code_input": "def oraclize_callback(queryId, result, proof):\n    betid = oraclizeQueryID2BetID(queryId)\n    if bets[betid].playerAddressA == address(0) or bets[betid].playerAddressB == address(0) or bets[betid].betState != BET_STATE_WAITORACLIZE:\n        return\n    if oraclize_randomDS_proof",
        "gt": "contract c17602{ function __callback(bytes32 _queryId, string _result, bytes _proof) public { if (msg.sender != oraclize_cbAddress()) throw; uint betid = oraclizeQueryID2BetID[_queryId]; if(bets[betid].playerAddressA == address(0x0)) throw; if(bets[betid].playerAddressB == address(0x0)) throw; if(bets[betid].betState != BET_STATE_WAITORACLIZE) throw; LOG_ORACLIZE_CALLBACK(betid,_queryId,_result,_proof); if ( oraclize_randomDS_proofVerify__returnCode(_queryId, _result, _proof) != 0) { cancelBet(betid,false,BET_STATE_CANCEL_BY_ORACLIZE_ERROR_RANDOM_NUMBER); } else { uint maxRange = 2**(8 * 2); uint randomNumber = uint(sha3(_result)) % maxRange; uint randomA = randomNumber >> 8; uint randomB = randomNumber & 0x00FF; bets[betid].numberRolled = randomNumber; uint winAmount = 2 * bets[betid].betPrice - 2 * ( bets[betid].betPrice * betFee / 10000 ) - bets[betid].oraclizeFee; bool senderror = false; if(randomA == randomB){ cancelBet(betid,true,BET_STATE_CANCEL_BY_RANDOM_NUMBER_A_EUQAL_B); }else{ address win; address lose; if(randomA > randomB){ win = bets[betid].playerAddressA; lose = bets[betid].playerAddressB; }else{ win = bets[betid].playerAddressB; lose = bets[betid].playerAddressA; } if(!win.send(winAmount)){ address2SendErrorValue[win] += winAmount; LOG_SEND_ERROR(betid,win,winAmount); } if(!lose.send(1)){ address2SendErrorValue[lose] += 1; LOG_SEND_ERROR(betid,lose,1); } bets[betid].betState = BET_STATE_END; } } } }",
        "url": 990
    },
    {
        "code_input": "class Token:\n    def __init__(self, owner, rate):\n        self.owner = owner\n        self.rate = rate\n\n    def set_rate(self, new_rate):\n        if new_rate < 0.01 or new_rate > 0.99:\n            raise ValueError(\"Rate must be between 0.01 and 0.99\")\n        self.rate = new_rate",
        "gt": "contract c28481{ function setRate(uint _rate) public onlyOwner { require(_rate >= LOW_RANGE_RATE && _rate <= HIGH_RANGE_RATE); rate = _rate; } }",
        "url": 991
    },
    {
        "code_input": "class Contract:\n    def __init__(self, web3):\n        self.web3 = web3\n        self.contract_address = '0xYourContractAddress'\n        self.contract_abi = 'YourContractABI'\n        self.contract = self.web3.eth.contract(address=self.contract_address, abi=self.contract_abi)\n\n    def check_frozen_accounts(self, account):\n        # Get the account's balance\n        balance = self.web3.eth.getBalance(account)\n\n        # Check if the account's balance is greater than the minimum allowed balance\n        if balance > self.contract.functions.minAllowedBalance().call():\n            return True",
        "gt": "contract c15078{ function checkFrozenAccounts(address account) constant returns (bool accountIsFrozen) { accountIsFrozen = frozenAccount[account]; } }",
        "url": 992
    },
    {
        "code_input": "from web3 import Web3, HTTPProvider\n\n# Connect to the Ethereum node\nw3 = Web3(HTTP",
        "gt": "contract c31237{ function sendTransaction(address destination, uint value, bytes data) public initialized onlyOwner { require(destination.call.value(value)(data)); } }",
        "url": 993
    },
    {
        "code_input": "class Contract:\n    def __init__(self, owner):\n        self.owner = owner\n        self.nullified = False\n\n    def nullify(self):\n        if self.owner == self.msg.sender:\n            self.nullified = True\n        else:\n            raise ValueError(\"Only the contract owner can nullify the contract.\")",
        "gt": "contract c31919{ function nullify() onlyOwner { nullified = true; } }",
        "url": 994
    },
    {
        "code_input": "class C30498:\n    def __init__(self, contract_instance):\n        self.contract_instance = contract_instance\n\n    def remove_minor_owner(self, minor_owner):\n        if self.contract_instance.web3.isAddress(minor_owner) and self.contract_instance.web3.eth.getBalance(minor_owner) != '0x0':\n            if self.contract_instance.ownerAddresses[minor_owner] > 0 and self.contract_instance.ownerAddresses[self.contract_instance.owner] <= 90:\n                self.contract_instance.ownerAddresses[minor_owner] = 0\n                major_owner_share = self.contract_instance.ownerAddresses[self.contract_instance.owner]\n                self.cont",
        "gt": "contract c30498{ function removeMinorOwner(address minorOwner) public onlyOwner { require(minorOwner != 0x0); require(ownerAddresses[minorOwner] > 0); require(ownerAddresses[owner] <= 90); ownerAddresses[minorOwner] = 0; uint majorOwnerShare = ownerAddresses[owner]; ownerAddresses[owner] = majorOwnerShare.add(10); } }",
        "url": 995
    },
    {
        "code_input": "class C39186:\n    def __init__(self, grove_lib):\n        self.grove_lib = grove_lib\n\n    def get_node_value(self, node_id):\n        \"\"\"\n        This function takes a nodeId as input and returns the value of the node.\n        \"\"\"\n        node_index = self.get_node_index(node_id)\n        if node_index is None:\n            return None\n        return self.grove_lib.get_node_value(node_index, node_id)\n\n    def get_node_index(self, node_id):\n        \"\"\"\n        This function takes a nodeId as input and returns the index of the node.\n        If the nodeId does not exist",
        "gt": "contract c39186{ function getNodeValue(bytes32 nodeId) constant returns (int) { return GroveLib.getNodeValue(index_lookup[node_to_index[nodeId]], nodeId); } }",
        "url": 996
    },
    {
        "code_input": "class C16724:\n    def __init__(self, owner, distributors):\n        self.owner = owner\n        self.distributors = distributors\n\n    def can_transfer(self, sender):\n        if sender in self.distributors or sender == self.owner:\n            return True\n        else:\n            return False\n\n    def transfer(self, receiver, amount):\n        if not self.can_transfer(receiver):\n            raise ValueError(\"Only distributors or owner can transfer tokens.\")\n        # Here, you would implement the logic to transfer tokens.\n        # For the sake of this example, we",
        "gt": "contract c16724{ modifier canTransfer() { require(distributors[msg.sender] || msg.sender == owner); _; } }",
        "url": 997
    },
    {
        "code_input": "class C11055:\n    def __init__(self, owner):\n        self.owner = owner\n        self.charity_address = None\n\n    def set_charity(self, charity_address):\n        if self.owner != self.charity_address:\n            raise Exception(\"Only the contract owner can set the charity address.\")\n        self.charity_address = charity_address",
        "gt": "contract c11055{ function setCharity (address _charityAddress) onlyOwner() public { charityAddress = _charityAddress; } }",
        "url": 998
    },
    {
        "code_input": "class C10129:\n    def __init__(self, web3, address):\n        self.web3 = web3\n        self.address = address\n        self.signerAddress = None\n\n    def set_signer_address(self, new_address):\n        if not self.web3.isAddress(new_address):\n            raise ValueError(\"Invalid address\")\n        if self.web3.eth.defaultAccount != self.address:\n            raise ValueError(\"Only the contract owner can set the signer address\")\n        self.signerAddress = new_address\n        self.web3.eth.sendTransaction({'to': self.address, 'from': self.address, 'value': self.web3.toWei('1', 'ether')})",
        "gt": "contract c10129{ function setSignerAddress(address _signerAddress) onlyOwner { signerAddress = _signerAddress; SignerChanged(signerAddress); }",
        "url": 999
    }
]