[
    {
        "nl_input": "The query requires a function to replace an existing owner address with a new owner address in a contract. This function must ensure the current owner exists, the new owner does not already exist, update the owners list accordingly, modify ownership mappings, and trigger events indicating owner removal and addition to reflect the ownership change securely and atomically.",
        "url": 0
    },
    {
        "nl_input": "The query requires a function that calculates the real cap by processing a cap value and a key input, producing a cryptographic or computed result based on both parameters. The solution involves a computation that derives a unique or hashed cap output from these two inputs.",
        "url": 1
    },
    {
        "nl_input": "The query requires a constructor function in a contract where the function\u2019s name must exactly match the contract\u2019s name as declared. This constructor initializes the contract upon deployment, ensuring that the contract\u2019s behavior or state is set up correctly according to the contract identifier. The function defined should directly correspond to the contract name to act as its constructor.",
        "url": 2
    },
    {
        "nl_input": "The query requires defining a specific amount of Kitten Coins that a holder must possess to qualify for holder rewards. This involves setting or determining a threshold value representing the minimum coin balance needed to receive rewards for holding the tokens.",
        "url": 3
    },
    {
        "nl_input": "The query requires a function named balanceOf that retrieves and returns the balance of a specific account identified by an address input parameter. The function should be publicly accessible and provide a view or constant state guarantee, indicating it does not alter blockchain state. It accepts an address representing the account and returns an unsigned integer reflecting that account's balance from a stored balances mapping.",
        "url": 4
    },
    {
        "nl_input": "The query requires a function within a smart contract that allows the contract owner to burn a specific amount of BNTT tokens directly from users' balances. This function must verify the user has sufficient tokens, reduce their balance and the total token supply accordingly, and emit a burn or transfer event for transparency. The burning mechanism should securely update relevant tracking variables and only be executable by the owner.",
        "url": 5
    },
    {
        "nl_input": "The query requires a method that updates the current state of tranches and the currentRound variable. This involves checking conditions to transition between different tranche stages based on currentRound values and predefined caps, resetting currentRound when moving to the next tranche, and marking the process as successful with a timestamp once all tranches are completed. The method should manage tranche progression and update currentRound accordingly.",
        "url": 6
    },
    {
        "nl_input": "The query requires a code snippet involving a condition or modifier that restricts or controls execution based on a specific time or event, likely related to a state change when \"the castle would be no more.\" It suggests implementing a mechanism to ensure actions occur only after a certain release time or event, enforcing temporal or state-based access control in a contract.",
        "url": 7
    },
    {
        "nl_input": "The query requires a function that logs a data request by recording and emitting details associated with a request ID. It should access stored data linked to the given ID and log or emit an event reflecting the request and its parameters, effectively tracking the occurrence of each data request by its unique identifier.",
        "url": 8
    },
    {
        "nl_input": "The query requires a contract feature allowing a controller or owner to voluntarily relinquish or step down from their control or privileges, effectively transferring or ceasing their management role. This involves an accessible function that toggles or changes the controller's authority status, such as locking/unlocking or enabling/disabling control, typically restricted to the current owner or controller.",
        "url": 9
    },
    {
        "nl_input": "The query requires a function that enables token withdrawals from a smart contract, allowing authorized users to transfer tokens held by the contract to specified recipients. The function should include conditions that control when withdrawals are permitted, such as ownership or contract state checks, and handle updating balances or transferring the token amount accordingly to ensure secure and correct withdrawal processes.",
        "url": 10
    },
    {
        "nl_input": "The query requires an interface to access a directory of games, providing functions to retrieve the total number of games, detailed information about each game (including its contract address, description, URL, submitter, and submission time), and the active status of a game by index. The interface should enable users to query the directory with indexes and obtain comprehensive game metadata and activity state.",
        "url": 11
    },
    {
        "nl_input": "The query requires a feature that allows any user to withdraw or retrieve their assigned prize from a contract. This involves verifying the user's ownership, calculating their total prize, ensuring the prize amount is positive, and transferring the prize funds securely to the user.",
        "url": 12
    },
    {
        "nl_input": "The query requires functionality to add a new casino by creating a casino entity with attributes including star rating, price, name, and description, assigning it a unique ID, setting its owner, and storing it in a list or mapping for future reference.",
        "url": 13
    },
    {
        "nl_input": "The query requires functionality for transferring tokens between two accounts, ensuring proper decrement of the sender's balance, increment of the receiver's balance, and adjustment of allowances if applicable. The transfer should handle token ownership checks, validate amounts, and emit transfer events to record the transaction securely and transparently. The transfer functions must support different token contracts, allow authorized transfers, and enforce any necessary constraints such as time limits or access controls.",
        "url": 14
    },
    {
        "nl_input": "The query requires a function to toggle a \"locked\" state variable, switching its boolean value and emitting an event when changed. The toggle operation should be restricted to the contract owner, ensuring only the owner can change the lock status. The focus is on enabling and disabling a locked flag dynamically through a controlled and authorized function call.",
        "url": 15
    },
    {
        "nl_input": "The query requires a function that allows a designated pendingOwner address to finalize a transfer, but only if the call occurs within a specific start and end time window. This involves verifying the caller's authorization, ensuring the transfer is finalized only once, and checking that the current time falls between predefined limits before completing the transfer process. The function should enforce these constraints to securely finalize the transfer within the allowed timeframe.",
        "url": 16
    },
    {
        "nl_input": "The query requires overriding the transfer function in a contract to include additional conditions before executing the original transfer logic. Specifically, it involves customizing the transfer method to add checks, such as verifying if a transfer is allowed, before calling the parent contract\u2019s transfer function. This ensures control over token transfers through custom logic integrated into the overridden transfer function.",
        "url": 17
    },
    {
        "nl_input": "The query requires a function to allocate tokens to multiple users, ensuring that allocations match given arrays of user addresses, token amounts, and lock types. The function should validate input lengths, update total supply and individual balances accordingly, emit transfer events, and record token release information and lock types for each user. It should also include access control to restrict allocation ability to authorized owners or roles.",
        "url": 18
    },
    {
        "nl_input": "The query requires identifying or describing a function related to token allowances, specifically excluding any implementation of an allowance function. The focus is on code dealing with allowance concepts but explicitly disallowing the presence or use of an allowance function that returns token allowances between owners and spenders.",
        "url": 19
    },
    {
        "nl_input": "The query requests a Solidity function that delegates contract execution to another implementation contract, using low-level delegatecall within inline assembly. The code should copy calldata, perform the delegatecall to the implementation address, handle the returned data or revert on failure, enabling the current contract to execute logic defined in the implementation contract.",
        "url": 20
    },
    {
        "nl_input": "The query requires functionality to cancel or abort ongoing operations or requests within a contract. This includes canceling projects by checking their status recursively, canceling auctions by removing listings and transferring ownership, and canceling withdrawal requests by resetting related indicators. The focus is on enabling cancellation actions that halt pending processes or undo initiated transactions in different contract contexts.",
        "url": 21
    },
    {
        "nl_input": "Validate that a string\u2019s length falls within specified minimum and maximum bounds by checking if it meets the inclusive range criteria.",
        "url": 22
    },
    {
        "nl_input": "The query requires setting or managing a cooldown period specifically for childbirth or breeding. This involves tracking and updating cooldown timers associated with an entity (such as a \"Dog,\" \"Mother,\" or \"Zodiac\") to prevent immediate repeated births. The cooldown should account for block-based timing or real-time intervals, increment the cooldown index or count accordingly, and ensure readiness to breed only when the cooldown period has elapsed. Emitting events to signal cooldown updates or birth counts may also be involved.",
        "url": 23
    },
    {
        "nl_input": "The query requires a function to set a specific contract address authorized to call the \"vacate\" function on the current contract. This involves defining an external or public setter function that updates an address state variable representing the allowed contract, with appropriate access control (e.g., onlyOwner) to restrict who can perform this action. The function ensures that the designated contract address is recorded for permission management purposes within the contract.",
        "url": 24
    },
    {
        "nl_input": "The query requires a smart contract function to enable users to purchase tokens using Ether. This function should validate the sender's address, ensure a minimum Ether contribution, calculate the number of tokens based on a current rate, enforce a hard cap on token issuance, mint the calculated tokens to the buyer, log the purchase event, and transfer the received Ether to a designated wallet.",
        "url": 25
    },
    {
        "nl_input": "The query requires a function that retrieves the number of base token units needed per grain for multiple tokens. Specifically, it should return an array of unsigned integers, each representing the token units associated with a corresponding token in a collection. This function is read-only (view) and involves iterating through a list of tokens to extract and compile their token unit values into a single array output.",
        "url": 26
    },
    {
        "nl_input": "The query requires a function to update the multi-signature (multiSig) address in a smart contract. This function should restrict access to only the current multiSig address holder, ensure the new address is not zero, and then change the multiSig address to the new provided address. The focus is on safely modifying a critical contract address with proper access control and validation.",
        "url": 27
    },
    {
        "nl_input": "The query requires verifying if the burnToken function returns true when it has completed execution. This involves checking that the burnToken function is designed to return a boolean value indicating successful completion, specifically returning true at the end of the function after performing token burning actions and necessary validations.",
        "url": 28
    },
    {
        "nl_input": "If the minimum token generation threshold is not reached by the end of the sale, participants can request a refund of their contributions. The refund function verifies that the participant has contributed, the sale is incomplete, the total tokens are below the minimum requirement, and the sale period has ended. Upon refund, the participant's token balance and contribution are reset, corresponding tokens are deducted, and the contributed funds are returned to the participant.",
        "url": 29
    },
    {
        "nl_input": "The query requires a smart contract function to enforce a quorum condition, making the function callable exclusively via a script executed by the contract itself. This implies restricting access so that only internal contract calls, likely from specific authorized scripts or contract actions, can invoke the function, preventing external or unauthorized calls. The solution should integrate access control based on contract-internal execution context, ensuring quorum-based permission checks before function execution.",
        "url": 30
    },
    {
        "nl_input": "The query requires a function or contract logic that retrieves the remaining balance of a specified token or cryptocurrency within a wallet or contract. This includes handling both ETH (native currency) and ERC20 tokens, by returning the wallet's ETH balance or the token balance via the token's balanceOf method. The focus is on accessing and returning the wallet\u2019s current token holdings accurately.",
        "url": 31
    },
    {
        "nl_input": "The query requires determining the amount of wei (the smallest Ethereum unit) needed to purchase 0.01 Mozo tokens, essentially finding the token's price rate in wei per 0.01 Mozo. The relevant function should calculate or provide the exchange rate between wei and Mozo tokens to allow conversion from wei investment to token quantity, enabling the calculation of how much wei is required to buy a specified token amount.",
        "url": 32
    },
    {
        "nl_input": "The query requires a function within a contract that allows only the owner to rescue or recover all ether held by the contract. This function should transfer the entire balance of the contract's ether to the owner's address or a specified beneficiary address, enabling the owner to withdraw the contract's funds securely.",
        "url": 33
    },
    {
        "nl_input": "The query requires functionality to transfer contract ownership by updating the owner address. It must restrict this action to the current owner only and emit an event to notify about the ownership change. The function should accept a new owner address, update the owner state variable accordingly, and ensure proper access control to maintain security.",
        "url": 34
    },
    {
        "nl_input": "The query requires a function that calculates and returns both the token amount and its equivalent value in USD based on an input value. This involves converting the input (likely in ethers or another unit) to USD, applying any bonuses or rates, and deriving both the number of tokens to be awarded and the corresponding USD amount. The function should handle edge cases such as zero inputs and use internal calculations for accuracy.",
        "url": 35
    },
    {
        "nl_input": "The query requires methods for user authorization management in a smart contract. This involves functions or modifiers to grant or check permission for specific addresses, enabling certain actions only for authorized users. It includes adding or setting authorization status, verifying user roles before function execution, and managing authorized amounts or privileges, ensuring only approved users can perform sensitive operations within the contract.",
        "url": 36
    },
    {
        "nl_input": "The query requires a function where a customer can purchase a box by sending a payment. The function should verify that the buyer is not a contract, check if the box sale is active, and ensure the payment meets or exceeds the box price. It should assign a reward or item based on a randomized evaluation, potentially limited by rarity or availability, create the item for the buyer, and refund any excess payment above the box price. The purchase process must handle payment and item creation securely.",
        "url": 37
    },
    {
        "nl_input": "The query requires a function that retrieves the sale prices of a Property in both ETH and PXL tokens. It should accept a Property ID, verify its validity, and return two price values: one in ETH and another in PXL. If the property has no owner, it should provide system-wide default sale prices; otherwise, it should return the individual property's sale prices, ensuring accurate pricing information in both cryptocurrencies.",
        "url": 38
    },
    {
        "nl_input": "The query requires determining the total remaining free trial drops for a specific token. This involves checking if the token is eligible for a free trial and then calculating the remaining trial drops by subtracting the number of drops already used from the maximum allowed trial drops. If the token does not have a free trial, the remaining drops should be zero.",
        "url": 39
    },
    {
        "nl_input": "The query requires a contract function that transfers ownership to a new owner while also destroying (self-destructing) the contract itself as part of the transfer process. This involves relinquishing control from the current contract by assigning ownership to a new address and subsequently terminating the current contract to ensure it cannot be used further.",
        "url": 40
    },
    {
        "nl_input": "The query requires a function that transfers tokens owned by the sender to a specified recipient address. The function should handle token balances, update allowances if relevant, emit transfer events, and ensure proper authorization and sufficient token balance before executing the transfer. It should securely move the sender's tokens to the given address, reflecting the transfer on the token ledger.",
        "url": 41
    },
    {
        "nl_input": "The query requires a smart contract feature that allows only the owner to update the token-to-Ether exchange rate, initially set to 0.005 Ether. This functionality should enable the owner to modify the rate securely, ensuring control over the token pricing mechanism.",
        "url": 42
    },
    {
        "nl_input": "The query requires a function callable by the provider on a CANCELED subscription to immediately return the subscription deposit to the customer. This involves verifying the subscription is canceled, ensuring a deposit exists, confirming the caller's authorization, updating the subscription expiration, and initiating the return of the deposit to the customer.",
        "url": 43
    },
    {
        "nl_input": "The query requires a function to set the approval expiry window duration, specifically designed to be called before the contract becomes locked. This function should restrict access to only the contract owner, allowing them to define or update the expiry timeframe (lockout or time window) that governs when approvals expire, ensuring it is set prior to the contract locking state.",
        "url": 44
    },
    {
        "nl_input": "The query requires a function to retrieve the BOP token balance for a given address. The solution should include a contract function named balanceOf that accepts an address as input and returns the token balance associated with that address, typically by accessing a balances mapping or calling an external controller's balanceOf method.",
        "url": 45
    },
    {
        "nl_input": "The query seeks a best practice guideline recommending that functions unable to alter or access the blockchain state should be declared as pure rather than constant. This implies distinguishing between functions that only compute values without reading blockchain state (pure) and those that read state without modifying it (constant/view), encouraging the use of pure for clarity and gas optimization when applicable.",
        "url": 46
    },
    {
        "nl_input": "The query requires a function or mechanism to reallocate unsold and leftover bounty tokens after initial allocations. This involves tracking remaining bounty tokens post-distribution and implementing logic to redistribute or reclaim those tokens rather than leaving them unused or locked. The solution should handle token transfers, ensure proper accounting of leftover tokens, and possibly enable their redistribution or reintegration into other allocations or uses within the contract.",
        "url": 47
    },
    {
        "nl_input": "The query requires handling a user-initiated withdrawal request where the user may later reconsider. The system should track withdrawal status per user and date, only allowing withdrawal if conditions like time buffers and completion status are met. If the user changes their mind after requesting withdrawal, the contract should enable managing or preventing the withdrawal accordingly. The solution involves updating user withdrawal statuses, calculating amounts with bonuses, and ensuring funds are securely transferred while logging the withdrawal events.",
        "url": 48
    },
    {
        "nl_input": "The query requires a function that mints or creates new tokens and then assigns or transfers them to a specified address. This involves verifying that the address is valid (not zero), minting or generating the tokens, and recording or emitting a transfer event indicating tokens moved from a zero (minting) address to the recipient. The function typically includes minting logic and updating balances or ownership records accordingly.",
        "url": 49
    },
    {
        "nl_input": "The query requires an internal function that calculates the current bonus during the ICO period. This function should determine the bonus based on the ICO state, particularly during the main ICO, adjusting the bonus amount according to predefined bonus stages and timestamps. It assumes the function is only called during the ICO timeframe to return the correct bonus value reflecting the current stage of the ICO.",
        "url": 50
    },
    {
        "nl_input": "The query requires a function that calls token allocation on all token bankrolls. Specifically, it involves invoking a token allocation method multiple times with different parameters to distribute or allocate tokens across various token groups or bankrolls within a contract, ensuring each token bankroll receives a designated allocation.",
        "url": 51
    },
    {
        "nl_input": "The query requires a token transfer function that moves the entire balance from the token owner's account to another account, allowing zero-value transfers, and ensuring the owner's account has sufficient balance. Additionally, there must be a developer override capability. The function should validate ownership or permissions, check balance sufficiency, permit zero transfers, and enable an override mechanism for special cases.",
        "url": 52
    },
    {
        "nl_input": "The query requires a function within a smart contract that transfers or sends tokens to a specified user address. This function should include access control to ensure only authorized callers (e.g., the token holder or wallet) can initiate the transfer. Additionally, it must execute the actual token transfer to the recipient address, ensuring the transfer amount is valid and updating relevant state variables accordingly.",
        "url": 53
    },
    {
        "nl_input": "The query requires a function that extracts exactly 256 bits (32 bytes) from a given byte stream starting at a specified offset. The solution should process the byte array to return a fixed-size 32-byte segment, suitable for handling raw bytes data extraction and slicing in smart contract environments.",
        "url": 54
    },
    {
        "nl_input": "The query requires a function that retrieves all relevant information about a specific element identified by a tokenId. This includes returning attributes such as the element's ID, name, selling price, owner address, and associated scientist ID. The function should access stored element data and provide these details in a structured manner.",
        "url": 55
    },
    {
        "nl_input": "The query requires a contract function or mechanism that reverts (throws an error) if certain operational conditions are not met. This includes verifying that the contract is in a valid operational state before proceeding, such as checking if required values are set, the sale or process has started, the wallet address is valid, the configuration is complete, and the sale is not finalized. The function should enforce these prerequisites by reverting whenever any condition fails.",
        "url": 56
    },
    {
        "nl_input": "The query requires calculating the total payout amount by deducting commission and donation amounts from the total bet amount. It involves computing commission and donation based on fixed rates, subtracting these from the total bets to get the net payout, and transferring the respective amounts to the owner and charity addresses. The logic should also emit events confirming commission payment and donation transfer.",
        "url": 57
    },
    {
        "nl_input": "The query requires functionality to delete or cancel a transaction within a smart contract context. This involves removing all associated references and data entries tied to a specific transaction key or ID. Essential steps include validating the transaction's existence, updating indices or mappings to maintain data integrity, decrementing transaction counts, and emitting an event to signal successful deletion. The operation must ensure no leftover references remain to prevent inconsistencies in the contract's state.",
        "url": 58
    },
    {
        "nl_input": "The query requires a contract function that allows adding a new dungeon floor by specifying its ID, with updates to floor count, creation time, rewards, and floor genes. Only the contract owner has permission to modify the dungeon state, ensuring restricted access to this functionality.",
        "url": 59
    },
    {
        "nl_input": "The query requires a function to calculate the number of tokens to transfer to an investor based on the amount of ether they invested. The solution should take the invested ether value as input, use a conversion rate to determine the equivalent token amount, and return this token quantity for transfer purposes in a token sale or investment scenario.",
        "url": 60
    },
    {
        "nl_input": "The query requires functionality that allows the contract owner to enable a crowdsale contract to distribute tokens. This involves owner-restricted methods to initiate or authorize token distribution, ensuring tokens are whitelisted and conditions like minimum distribution amounts and active distribution status are met, allowing controlled token transfer or minting tied to crowdsale events.",
        "url": 61
    },
    {
        "nl_input": "The query requires a function that creates a new request with a unique sequential ID, assigns various details such as type, target address, value, creation timestamp, and message to the request, adds the request ID to a pending list, and emits an event signaling the creation of the request.",
        "url": 62
    },
    {
        "nl_input": "The query requires a function that enables the message sender (msg.sender) to assign an allowance value (_value or _amount) to a specified spender address (_spender). This allowance permits the spender to use a certain amount of the sender's tokens or funds. The function should update the allowance mapping accordingly and confirm the approval, ideally returning a boolean success status or emitting an approval event.",
        "url": 63
    },
    {
        "nl_input": "The query requires functionality for depositing funds into a system or contract. It involves enabling users to add funds, typically by sending ether or tokens, with mechanisms to log or validate the deposit. The deposit function may include checks such as ensuring certain conditions before accepting funds and possibly emitting events for tracking deposits. The primary need is to implement a secure and verifiable method for users to deposit assets into a wallet or contract.",
        "url": 64
    },
    {
        "nl_input": "The query requires a function for withdrawing previously deposited funds from a contract, restricted to the owner. The function should allow specifying an amount to withdraw or default to the full balance, ensure the recipient address is valid, and securely transfer the requested funds to an approved destination. Additionally, it may emit an event to log the withdrawal action for transparency and auditing purposes.",
        "url": 65
    },
    {
        "nl_input": "The query requires restricting function access to a single authorized payer from a group of payers. This involves implementing a modifier that checks if the caller's address exists in a mapping of payers and allows function execution only if the caller is an approved payer.",
        "url": 66
    },
    {
        "nl_input": "The query requires a function that allows the contract owner to transfer tokens between addresses, with checks such as positive transfer amount, time restrictions, and ensuring neither sender nor receiver is part of a specified group. The function must be callable exclusively by the owner to securely manage token transfers on behalf of others.",
        "url": 67
    },
    {
        "nl_input": "The query requires a payment function where someone can pay on behalf of another person, specifically emphasizing that the payment is made by a sender on behalf of a beneficiary. The functionality should allow forwarding funds from the payer (sender) to the designated recipient (benefactor or owner), ensuring the amount is transferred correctly and associated with both parties in the transaction.",
        "url": 68
    },
    {
        "nl_input": "The query requires functionality related to managing \"burning man\" entities within a contract, including adding a burning man with address and block validation, as well as controlling or verifying burner permissions. The code should provide mechanisms to add burning man addresses, check their existence, enforce burner restrictions, and handle whitelisted burn addresses, ensuring proper access control and state management around burning man roles and permissions.",
        "url": 69
    },
    {
        "nl_input": "The query requires a function to add multiple staff members to a whitelist by providing a list of addresses. It should include validation that the list is not empty and each address is valid (non-zero). The function must prevent duplicates by checking if the staff is already whitelisted before adding. Access control (e.g., restricted to admin or authorized roles) is also necessary to ensure only permitted users can modify the whitelist.",
        "url": 70
    },
    {
        "nl_input": "The query requires a function that allows the contract owner to freeze or lock an account at a specific address by setting its frozen status. The function must take a target address and a boolean indicating whether to freeze or unfreeze the account, update the account's frozen state, and emit an event to signal this change. The focus is on freezing a single account based on the provided target address.",
        "url": 71
    },
    {
        "nl_input": "Set the address of the authorized entity responsible for approving users through Know Your Customer (KYC) verification by defining a function callable only by the contract owner. This function assigns the KYC approval authority to a specified address, enabling controlled management of KYC providers within the smart contract.",
        "url": 72
    },
    {
        "nl_input": "The query requires a function that returns the price information of registered assets in the format of a tuple containing a boolean indicating if the prices are recent, an array of prices, and an array of decimals. This involves checking multiple assets, determining if each price is recent, and collecting their respective prices and decimal values. The output should be structured as (bool areRecent, uint[] prices, uint[] decimals).",
        "url": 73
    },
    {
        "nl_input": "The query requires a function to remove or cancel an auction by deleting or clearing its associated data, such as auction identifiers or seller information. This involves safely removing auction records from storage mappings and potentially handling ownership or transfer processes related to the auction's items. The function should ensure the auction is effectively removed from the system to prevent further interactions.",
        "url": 74
    },
    {
        "nl_input": "The query requires a method to retrieve or withdraw the dividend amounts associated with an owner's address. This involves accessing or calculating the dividend balance, potentially including bonuses or referral rewards, and ensuring the accurate distribution or withdrawal of the owner's entitled dividend funds securely and correctly from the contract\u2019s stored dividends.",
        "url": 75
    },
    {
        "nl_input": "The query requires defining a new product contract that enables the creation and management of product ownership, including functions to transfer or claim ownership rights securely. This contract should ensure proper permission checks, maintain product records, and handle ownership updates with event logging. It may also include features related to product branding, fee handling, and interaction with associated entities like brands and applications.",
        "url": 76
    },
    {
        "nl_input": "The query requires executing a spin function that involves validating a bet using token value and a divisor rate, ensuring the game is active and the block number is valid. It must track the player's spin by storing block number, wagered tokens, tier based on divisor rate, and update game statistics like total spins and total tokens wagered. The process includes handling contract balance updates, preventing duplicate spins in the same block, and emitting events to log token wagers.",
        "url": 77
    },
    {
        "nl_input": "The query requires a smart contract function that allows any user to contribute funds (payable function) toward a buyer or executor's reward pool, enabling collective contributions to increase the reward amount.",
        "url": 78
    },
    {
        "nl_input": "The query requires a function that enables users to donate to an event by specifying the event address and donation amount. The function should ensure the event is active, securely transfer the donation amount to the event, and update the contribution records accordingly. The donation process must trigger appropriate events or logging to confirm the contribution.",
        "url": 79
    },
    {
        "nl_input": "The query requires adding a new owner to a contract by defining a function that takes an owner address, validates it (e.g., not address(0) and not already an owner), and updates ownership records accordingly. The function should ensure only authorized entities can add owners, maintain owner consistency, update owner counts and mappings, emit relevant events, and prevent duplicates.",
        "url": 80
    },
    {
        "nl_input": "The query requires a function that verifies whether the sent transaction includes a sufficient fee amount. It should retrieve the required fee configuration, exempt certain privileged accounts or zero-fee scenarios, and conditionally reject the transaction if the provided fee is inadequate. Additionally, it should securely transfer the fee to a designated receiver address, reverting the transaction if the transfer fails, thus ensuring proper fee validation and collection before proceeding.",
        "url": 81
    },
    {
        "nl_input": "The query requires a function that returns the current state of a game for a specific player. This includes details such as the game's current status, game ID, bet direction, bet amount, initial and final roll values, and the player's winnings. The main focus is on retrieving comprehensive, real-time information about the ongoing game state for a given player address.",
        "url": 82
    },
    {
        "nl_input": "The query requires a function to calculate the amount of WPX tokens received based on a given wei amount and predefined rates per 1 ether. The calculation involves applying conditional rate tiers depending on the wei amount thresholds or using a fixed rate, and then multiplying the wei amount by the corresponding rate to determine the token quantity. The function should handle rate selection and perform accurate arithmetic conversions aligned with ether units.",
        "url": 83
    },
    {
        "nl_input": "The query requires a smart contract function to pause and unpause an Initial Coin Offering (ICO), ensuring that only the authorized sender (owner) can perform these actions. This involves implementing controlled state changes with access restrictions, emitting events on unpause, and using modifiers like onlyOwner and whenPaused to maintain security and proper contract state management.",
        "url": 84
    },
    {
        "nl_input": "The query requires a function callable exclusively by the contract owner to close a token sale. This function should finalize the sale process by burning any remaining sale tokens and updating the contract state to indicate that the sale is closed, preventing further sales or changes until explicitly reopened.",
        "url": 85
    },
    {
        "nl_input": "The query requires a function to add multiple KYC-verified addresses to a whitelist. This involves iterating over a list of addresses and marking each as whitelisted, typically restricted to authorized roles (e.g., owner or whitelister). The function should ensure valid addresses are added, enforce access control, and update the whitelist mapping to grant whitelist status to these addresses. Event emission upon addition is optional but useful for tracking.",
        "url": 86
    },
    {
        "nl_input": "The query requires a Solidity contract modifier named to permit actions by all users universally, without restrictions. This modifier should enforce that a specific disabling condition (like 'everyoneDisabled') is false, allowing the function to proceed for everybody. The focus is on creating an access control modifier enabling all users to perform certain actions unless globally disabled.",
        "url": 87
    },
    {
        "nl_input": "The query requires a safeguard mechanism within a contract to protect investors who might lose their key after investing. It seeks a function that enables secure recovery or transfer of funds under specific conditions, ensuring that investors' assets can be protected or retrieved if they lose access, thus preventing permanent loss of their investment.",
        "url": 88
    },
    {
        "nl_input": "The query requires a function that, given a soul identifier (such as an address or index), returns the owner\u2019s address of that soul. The function should accept an input parameter representing the soul and provide the corresponding owner address as output.",
        "url": 89
    },
    {
        "nl_input": "The query requires implementing a function to put a LinglongCat up for auction, ensuring the seller owns the LinglongCat and that it is not pregnant before approval. The auction should be created with parameters like starting price, ending price, and duration, facilitating secure and paused-state-checked sale auctions of the LinglongCat NFT.",
        "url": 90
    },
    {
        "nl_input": "The query requires a function that allocates or assigns tokens to a specified address. The function should ensure proper validation, such as checking the address is not zero and should handle token balance updates and related token transfer events or records. It must support assigning a defined amount of tokens to the given address securely and restrict this operation to appropriate conditions or roles to prevent unauthorized token allocation.",
        "url": 91
    },
    {
        "nl_input": "The query requires a function that can only be called when tokens have been released, enforcing this condition potentially through a modifier or a check on the current time against a release date. It should restrict execution before the release and allow it after. The function may involve accessing or managing tokens related to their released status, such as querying released tokens or triggering token release mechanisms.",
        "url": 92
    },
    {
        "nl_input": "The query requires a function or contract logic that calculates or provides a bonus amount based on certain conditions or input values. It should detail how bonuses are assigned, accumulated, or distributed, potentially using thresholds or multiple bonus levels to determine the final bonus amount. The focus is on implementing or retrieving bonus values and possibly handling authorization or limits related to bonus provision.",
        "url": 93
    },
    {
        "nl_input": "The query requires functionality to restrict or lock ERC721 token behavior, specifically to prevent or disable trading on third-party platforms. The code should provide a method, likely accessible only by an authorized user, to disable or freeze ERC721-related actions, thereby controlling or halting trading activity externally.",
        "url": 94
    },
    {
        "nl_input": "The query requires obtaining the address of a specific smart contract. The relevant code should include a function that returns the contract\u2019s own address or the address of another contract stored or referenced within it. This typically involves a function that accesses and returns an address type, such as the contract\u2019s own address (`this`) or an externally stored contract address. The focus is on retrieving and providing the smart contract\u2019s address programmatically.",
        "url": 95
    },
    {
        "nl_input": "The query requires a function that assigns an alias to the sender's address in a smart contract. Specifically, it should map the sender's address to a given alias string and also map the alias back to the sender's address, enabling a bidirectional association between addresses and aliases.",
        "url": 96
    },
    {
        "nl_input": "The query requires a function that allows an account to cast a vote for a specific participant or candidate, with restrictions preventing self-voting and limiting the number of votes per account. It should update the vote counts accordingly, ensure valid voting conditions, and track votes used by each voter to prevent exceeding allowed limits. The function must validate input parameters and maintain integrity of the voting process.",
        "url": 97
    },
    {
        "nl_input": "The query requires a smart contract function that locks up a specific address by associating it with a predefined time until which the address is restricted. This function should ensure the lockup time is valid, update the lockup state for the given address, and emit an event to signal the lockup. Access control (e.g., owner-only) is needed to restrict who can set or modify the lockup period for an address.",
        "url": 98
    },
    {
        "nl_input": "The query requires a contract modifier or access control that restricts modifications to KittyData exclusively to the KittyGym and Arena contracts, ensuring only these two specified contracts have permission to change KittyData, preventing any other contracts or addresses from making alterations.",
        "url": 99
    },
    {
        "nl_input": "The query requires a function to update the enabled status of a user account by accepting an address and a boolean value. The function should restrict access so only the owner can perform the change and should update the account's enabled field only if the current status differs from the desired one.",
        "url": 100
    },
    {
        "nl_input": "The query requires a function that distributes a specified value by sequentially sending it to each investor in a list. The function should handle partial payments by deducting from each investor's balance, send the corresponding funds, and recursively proceed to the next investor if the total value remains. It must also handle edge cases such as empty balances and terminate once the entire value is distributed or all investors have been processed.",
        "url": 101
    },
    {
        "nl_input": "The query requires a function to modify the treasury address, specifically the destination address for forwarded payments. This involves implementing a method that allows the contract owner to update and set a new treasury address securely, ensuring only authorized users can perform this change.",
        "url": 102
    },
    {
        "nl_input": "The query requires a helper function, potentially implemented as a contract modifier or utility function, designed to enforce a specific condition or limit, such as restricting the number of function calls (e.g., \"onlyOnce\" modifier ensuring a function runs no more than once). The helper should facilitate code reuse and maintain control flow or access restrictions, enhancing contract security and efficiency.",
        "url": 103
    },
    {
        "nl_input": "The query requires a function to migrate token holders from an old contract to a new one, transferring each holder's token balance to the new contract through a migration agent. This involves iterating over a list of holders, adjusting balances and total supply accordingly, and ensuring only authorized execution. The process should handle a specified count of holders per call, update migration progress, and emit migration events for each holder migrated.",
        "url": 104
    },
    {
        "nl_input": "The query requires storing the gas price as a contract storage variable and updating it using the correct Oraclize function. This involves defining a storage variable for gas price and a function restricted to the contract owner that sets this variable and calls the appropriate Oraclize function to update the gas price accordingly.",
        "url": 105
    },
    {
        "nl_input": "The query requires a function that sends tokens to a partner address, ensuring this operation is only performed once by a manager after initialization. It should calculate partner tokens based on a fraction of the supply limit minus tokens already sold, then emit tokens to the partner and mark the tokens as sent to prevent duplicate transfers.",
        "url": 106
    },
    {
        "nl_input": "The query requires a function to self-register a new DIN (Decentralized Identifier Number) and assign a specified resolver to it. The implementation should allow users to invoke the registration themselves and link the DIN with a custom resolver address, ensuring the resolver is set during the registration process.",
        "url": 107
    },
    {
        "nl_input": "The query requires an internal function that handles the transfer of ownership for a team entity, updating ownership mappings and counts, and emitting a transfer event. This function should be private, manage ownership token counts for both previous and new owners, update the team-owner relationship, and ensure the proper transfer of ownership within the contract without exposing the operation publicly.",
        "url": 108
    },
    {
        "nl_input": "The query requires a function that assigns a parameter value identified by a given name. Specifically, it should take a name and a value as inputs and set the parameter keyed by the name to the value. This involves mapping or storing the value associated with the name key, typically using a hashing function like keccak256 on the name to index the parameter storage.",
        "url": 109
    },
    {
        "nl_input": "The query requires a function named setToken that assigns a token contract address into a contract. This function should restrict access to authorized roles (like founder or owner), ensure the token address is set only once or handle proper state checks, and update the token variable with the provided address. The function must include validation such as confirming the address is non-zero or that the token is not previously set, and it should return a success indicator if applicable.",
        "url": 110
    },
    {
        "nl_input": "The query requires a manual health check function that allows the contract owner to set a maintenance mode and trigger a health check process if the mode is within a specified range. This involves a function restricted to the owner, which updates maintenance status and conditionally calls a health check routine to ensure system integrity.",
        "url": 111
    },
    {
        "nl_input": "The query requires a function that allows updating or setting a new token wallet address. This function should be restricted to authorized users (e.g., owner), include validation to prevent setting invalid addresses (such as zero address), and securely update the token wallet address stored in the contract.",
        "url": 112
    },
    {
        "nl_input": "The query requires a function that checks whether a given address is registered or allowed. This involves verifying if the provided address exists in a predefined list or mapping of registered addresses and returning a boolean result indicating registration status. The function should accept an address input and confirm its presence in the registry to determine if it is registered.",
        "url": 113
    },
    {
        "nl_input": "The query requires a function that returns the current total supply of tokens in a contract. This function should be a public or constant method named totalSupply, which returns a uint or uint256 value representing the total number of tokens currently available or in circulation.",
        "url": 114
    },
    {
        "nl_input": "The query requires calling the addMinter function of the TAU token contract immediately after deploying the contract. This involves invoking addMinter with an address parameter to register a new minter, ensuring the address is valid and not already a minter. The function should be callable only by the contract owner and must enable minting capability for the specified address right after deployment.",
        "url": 115
    },
    {
        "nl_input": "The query requires functionality to transfer shares or tokens to another address, consistent with ERC-20 token standards as referenced by the Ethereum EIP-20. The code should include a transfer function that validates input values, prevents self-transfers, ensures sufficient balance, updates balances accordingly, tracks new shareholders, and emits a Transfer event to log the transaction. The implementation must securely handle ownership and transfer processes to maintain correct and transparent share transfers on the blockchain.",
        "url": 116
    },
    {
        "nl_input": "The query requires implementing a function to close or finalize a fund, which involves conditionally closing the fund if a minimum funding goal is reached or enabling refunds if not. It should securely handle state transitions, emit appropriate events, and manage funds by either transferring remaining balances to a designated wallet or enabling investors to claim refunds if the funding fails.",
        "url": 117
    },
    {
        "nl_input": "The query requires a function that distributes tokens among multiple recipients based on predefined ratios or conditions. The distribution should prevent multiple executions (one-time distribution), ensure the token is whitelisted or valid for distribution, check that the amount to distribute meets minimum thresholds, update balances or token holdings appropriately, emit events signaling distribution, and maintain internal state to track distributed amounts and ownership to ensure accurate and secure token allocation.",
        "url": 118
    },
    {
        "nl_input": "The query requires a function or mechanism to aggregate and retrieve the total fees collected so far in a contract. It involves tracking fee amounts paid over time, ensuring proper calculation and storage of fees, and potentially transferring or recording these fees through fee-collecting wallets or accounts within the contract. The solution should provide a way to sum all fees paid up to the current moment, reflecting accurate accumulation from multiple transactions or sources.",
        "url": 119
    },
    {
        "nl_input": "The query requires a function that updates or modifies the token fee specifically during the approval process of a token transfer. This involves adjusting or managing the fee amount charged when a token holder approves another address to spend tokens on their behalf. The focus is on implementing logic that changes the fee value associated with the approve function or similar token allowance mechanism before executing the transfer approval.",
        "url": 120
    },
    {
        "nl_input": "The query requires a function that reduces (burns) tokens directly from the sender's balance, ensuring the sender has sufficient tokens before decrementing their balance and adjusting the total token supply accordingly. This involves subtracting a specified token amount from the sender's balance and the total supply, typically emitting a burn event to log the transaction. The operation should include proper validations to prevent burning more tokens than the sender owns.",
        "url": 121
    },
    {
        "nl_input": "The query requires a generic way to replace or abstract the Solidity `require()` function used in contract modifiers. This involves creating a reusable pattern or substitution for `require()` statements inside modifiers that enforce conditions such as limiting function calls, timing constraints, or sender verification, to streamline contract code and enhance readability or modularity.",
        "url": 122
    },
    {
        "nl_input": "The query seeks a method to publicly retrieve detailed action mappings in a Solidity contract using web3.js but encounters issues with the standard getter. It requires a public function that returns multiple action-related properties\u2014confirmations, expiration, triggered status, target address, and value\u2014for a given action ID, ensuring compatibility with web3.js to enable external access to these structured action details.",
        "url": 123
    },
    {
        "nl_input": "The query requires a smart contract function that allows only the contract owner to remove a specified address from a blacklist, effectively revoking its blacklisted status. The functionality should enforce owner-only access control and modify the blacklist mapping or status accordingly.",
        "url": 124
    },
    {
        "nl_input": "The query requires a helper method within a smart contract that simultaneously retrieves a token's name, symbol, and total supply. This function should be a public view function returning these three details at once, facilitating easy access to key token information in a single call.",
        "url": 125
    },
    {
        "nl_input": "The query requires a function that determines the maximum number of tokens that can be removed or remaining from a given token address, focusing on how much can be deducted based on conditions like free trials or reservations. The function should use arithmetic operations to calculate the removable token amount, considering limits, ownership, and validation checks on amounts and addresses. The goal is to verify how much of a specific token can be subtracted or returned.",
        "url": 126
    },
    {
        "nl_input": "The query requires a function that, given an address, returns an array of actual amounts for all active personal stakes associated with that address. The function should access personal stake data and extract the current stake amounts that are active, providing a view-only method to retrieve this financial stake information for the specified user address.",
        "url": 127
    },
    {
        "nl_input": "The query requires a function that allows only whitelisted internal applications to set the ICO end date. This function must enforce that the ICO end date can be set only once, ensuring it cannot be modified afterward. It should include access control, preventing unauthorized use, and only permit the setting of the ICO end date when certain conditions, such as the contract not being paused, are met.",
        "url": 128
    },
    {
        "nl_input": "The query requires a function that sets or updates a controller address within a contract. This function should include access control to restrict who can set the controller, verify that certain conditions or flags (e.g., attachment enabled) are met before allowing the change, and emit an event to signal that the controller has been set.",
        "url": 129
    },
    {
        "nl_input": "The query requires a function in a contract that allows the contract owner to set a percentage fee (owner cut) charged to the seller upon a successful sale. This function must ensure the owner cut is less than 100%, update the owner's cut percentage accordingly, and trigger an event or notification indicating the change.",
        "url": 130
    },
    {
        "nl_input": "The query requires functionality to update or set the access manager's address within a contract. This involves a function that securely assigns a new access manager address, ensuring the address is valid (non-zero) and that only authorized users (e.g., the contract owner) can perform this update. The function should update the stored access manager address and confirm the change, maintaining proper access control.",
        "url": 131
    },
    {
        "nl_input": "The query requires generating a giant cat image, likely represented as pixel data in a blockchain contract. The desired code should define a function that returns a large-scale cat image as a pixel or byte array, possibly by manipulating rows of byte data to form the cat's shape. This involves using internal logic to create or assemble the image from hex-encoded data segments arranged to visually represent a cat.",
        "url": 132
    },
    {
        "nl_input": "The query requires a function that retrieves the commitment or pledged value associated with a specified address. It should accept an address as input and return a numeric value representing that address's commitment. This function is typically a public view method that looks up a stored record or mapping related to the address and returns the corresponding commitment amount.",
        "url": 133
    },
    {
        "nl_input": "The query requires a function to change the reserved vesting wallet address, allowing it to be set to a smart-contract address later. This function must be restricted to the contract owner and should update the reserved wallet variable safely, possibly including an event emission to log the change. The implementation should ensure only the owner can call it and handle the address assignment appropriately.",
        "url": 134
    },
    {
        "nl_input": "The query requires a function that allows an individual to create or update their own claim by associating a specific key-value pair with their address. This involves a method enabling users to set or modify personal claim data directly, rather than adding claimants or issuing claims on behalf of others.",
        "url": 135
    },
    {
        "nl_input": "The query requires a function to verify if a specific user belongs to a given group. The solution should take a group identifier and a user address as inputs, then return a boolean indicating the membership status by checking user registration and the user's associated group information.",
        "url": 136
    },
    {
        "nl_input": "The query requires functionality related to interacting with ERC20 tokens via an interface named ERC20Interface, specifically involving transferring ERC20 tokens from a contract to the owner. The implementation should include a function restricted to the contract owner that enables transferring any amount of ERC20 tokens from a specified token contract address back to the owner's address. This supports managing ERC20 token balances held by the contract securely.",
        "url": 137
    },
    {
        "nl_input": "The query requires extracting functionalities related to token allowance and availability from Solidity smart contracts. Specifically, it focuses on checking the remaining token allowance for a spender, determining the number of tokens available during a specific phase with respect to a token cap, and handling approval of token allowances by interacting with token balances and approvals. The description should cover methods to query allowance, calculate available tokens under conditions, and update allowance for token transfers within smart contracts.",
        "url": 138
    },
    {
        "nl_input": "The query requires a function that enables a sender to forward or transfer payment to a specified recipient address ('to'). The function should handle the transfer of funds or tokens securely, ensuring the recipient address is valid, deducting fees if applicable, and updating balances accordingly. It may also need to emit events to record the transaction details, confirming successful payment forwarding from the sender to the 'to' address.",
        "url": 139
    },
    {
        "nl_input": "The query requires a function to add an address to an accredited list, ensuring input validation (non-zero address, valid vesting period, investment limits). The function should store the address with associated accredited investor details such as cliff, vesting, revocability, burn-on-revoke status, minimum investment, and maximum cumulative investment. It should emit an event confirming the addition and restrict access to authorized users only.",
        "url": 140
    },
    {
        "nl_input": "The query requires a function named \"unpauseToken\" that enables resuming or unpausing token transfers within a smart contract. This function should be publicly accessible but restricted to the contract owner only, ensuring controlled reactivation of token operations after a pause or halt.",
        "url": 141
    },
    {
        "nl_input": "The query requires a function allowing the contract owner to freeze or unfreeze multiple accounts by their addresses simultaneously. It should iterate over an array of addresses, updating each account's frozen status in a mapping, and emit an event to signal the change. The function must ensure only the owner can execute it and handle multiple addresses in a single transaction efficiently.",
        "url": 142
    },
    {
        "nl_input": "The query requires a function to create \"Tubers,\" which involves initializing a new Tuber with a name, setting its owner, assigning a price, and emitting a Birth event. The function should handle adding the Tuber to a storage array, ensure the new Tuber ID fits within a 32-bit unsigned integer, and transfer ownership from the zero address to the specified owner. The focus is on precise creation, indexing, pricing, event emission, and ownership transfer in a private/internal context.",
        "url": 143
    },
    {
        "nl_input": "The query requires a function that returns the number of decimal places used by a token. The desired function should be a public, constant (view) method named like tokenDecimals(), returning a uint8 value representing the token's decimals property. This function allows external callers to ascertain the precision or fractional units of the token.",
        "url": 144
    },
    {
        "nl_input": "The query seeks functionality to redeem MTU tokens, requiring verification of user-applied units, redeeming conditions such as timing and rate checks, transferring rewards in ETH or tokens based on user choice, updating redemption records, and emitting relevant events to log redemption activities.",
        "url": 145
    },
    {
        "nl_input": "The query requires a function that calculates the number of tokens received for a given amount of wei based on a course or rate. Specifically, it needs a direct conversion of wei to tokens using a defined course value. The function should take wei as input and return the equivalent token amount, typically by dividing wei by the course or multiplying by a rate, without additional complexity like excess calculation or tiered rates.",
        "url": 146
    },
    {
        "nl_input": "The query requires handling contribution amounts and applying cap logic. It involves validating beneficiary addresses, calculating how much a contributor can still contribute up to the cap, limiting contributions accordingly, processing token transfers, and tracking when soft and hard caps are reached. The logic should enforce contribution limits and trigger events or state changes when caps are met to manage the fundraising or token sale process effectively.",
        "url": 147
    },
    {
        "nl_input": "The query requires updating the token's symbol in a smart contract. This involves a function accessible only to the owner that sets or modifies the symbol value. The function may accept input as bytes32 or string and should ensure proper access control to prevent unauthorized changes. An event emission upon updating symbol or token information can be included for transparency.",
        "url": 148
    },
    {
        "nl_input": "The query requires a method to list all deeds owned by an address without relying on arrays, serving as an alternative to ERC721Enumerable. It suggests a function enabling enumeration of deeds by owner index through iteration and ownership checks, avoiding direct array handling for enumeration. The solution should allow dynamic, on-demand retrieval of specific deeds owned by a user without maintaining explicit deed arrays.",
        "url": 149
    },
    {
        "nl_input": "The query requires modifying code to change the contract owner to a new address variable named _owner, ensuring the owner state variable is assigned from _owner. The function should have access restricted to the current owner (onlyOwner modifier), emit an event reflecting the ownership change, and return a boolean confirming success. The key focus is updating the owner to _owner while maintaining ownership control and appropriate event logging.",
        "url": 150
    },
    {
        "nl_input": "The query requires a function that enables only the contract owner to mint new tokens by increasing the balance of a specified target address and updating the total token supply accordingly. This function must securely handle token creation and emit transfer events reflecting the minting process.",
        "url": 151
    },
    {
        "nl_input": "The query requires a function to set or update a token address in a smart contract, ensuring only authorized users (e.g., owner or founder) can perform this action. The function must take an address parameter, assign it to the token address variable, and optionally include conditions to prevent resetting if already set or to validate the address is not zero. The function should return a confirmation of success or run without errors.",
        "url": 152
    },
    {
        "nl_input": "The query requires an internal Solidity function that instantiates a new EtherDog struct with given parameters (matronId, sireId, generation, genes, owner), applies validation on inputs, calculates cooldownIndex, stores the EtherDog in a collection, emits a Birth event, transfers ownership of the new EtherDog token to the specified owner, and returns the new EtherDog's ID. This method encapsulates creation and storage logic within the contract.",
        "url": 153
    },
    {
        "nl_input": "The query requires a function that transfers all raised funds directly to the founders' wallet, ensuring that the entire contract balance is sent securely and only by an authorized party, typically the contract owner. The function must handle the full balance transfer in one operation to the founders' address without splitting or allocating funds to other parties.",
        "url": 154
    },
    {
        "nl_input": "The query requires a function to close betting for a specific champion by champion ID, marking the bet as closed and recording the champion as the winner. It should finalize the bet results, calculate and distribute rewards based on wager totals and winning choices, and emit an event indicating the winning champion and reward.",
        "url": 155
    },
    {
        "nl_input": "The query focuses on handling urgent or emergency situations in smart contracts, specifically mechanisms that allow the contract owner or authorized parties to quickly withdraw or transfer funds during a critical event. This includes functions enabling emergency drainage of Ether, contract self-destruction with fund transfer to a specified address, and state checks for specific conditions before allowing such emergency actions. The requirement centers on secure, owner-restricted interventions to safeguard or recover assets in emergencies.",
        "url": 156
    },
    {
        "nl_input": "The query requires an admin-only function to add claimants by specifying their address and claim amount. This function should create a new claimant record, initialize their claimed status to false, and append this record to a list of claimants, ensuring only users with admin privileges can execute it.",
        "url": 157
    },
    {
        "nl_input": "The query requires a function named betOnDozen that allows placing bets on one of three dozens in a roulette game. The input should be an integer 0, 1, or 2 corresponding to the first, second, or third dozen respectively. The function must validate the input to ensure it does not exceed 2 and then place the bet using a designated bet type for dozens. The focus is on handling dozen-based bets with proper input validation.",
        "url": 158
    },
    {
        "nl_input": "The query requires validating a transaction where the signer is a certified individual restricted to basic account holders. It ensures the signature's validity by verifying the user's certification status for specific countries, confirming the account type as basic, and enforcing that the transaction's gas price is sufficiently low and the value transferred exceeds a minimum threshold, ensuring meaningful and authorized participation.",
        "url": 159
    },
    {
        "nl_input": "The query requires an internal function that processes a loan repayment under the assumption that the repayment amount has already been transferred. The function should validate the loan ID and state, ensure the repayment amount matches the expected amount, handle loan state changes, calculate and distribute interest and principal amounts appropriately, burn the repaid tokens, notify relevant parties, return any collateral to the borrower, and emit a repayment event.",
        "url": 160
    },
    {
        "nl_input": "The query requires a description of a function that is overridden by test mocks, focusing on verifying expected versus actual values. Specifically, the function should assert equality between two unsigned integers and revert if they do not match, supporting testing scenarios where mock implementations override the original function to validate behavior. The description should highlight the importance of asserting conditions in tests and handling discrepancies via reversion.",
        "url": 161
    },
    {
        "nl_input": "The query requires a function that retrieves the enemy combination associated with a specific address. This involves returning an array or list of identifiers representing enemy slots or classes, with a check to provide a default combination if no personalized one is set for that address. The function should be a view or constant method that accesses stored mappings or variables to fetch the enemy combination data.",
        "url": 162
    },
    {
        "nl_input": "The query requires a function for the contract owner to read detailed player metadata during migration. This includes retrieving a player\u2019s ID, name, address, confirmed and unconfirmed scores, and active status, identified by a board hash and player ID. The function must be owner-restricted and return comprehensive player data necessary for migration purposes.",
        "url": 163
    },
    {
        "nl_input": "The query requires a function that determines and returns the current halving number based on the blockchain state. This involves calculating which halving phase the blockchain is currently in by analyzing the current block number or an equivalent metric that tracks halving progress. The desired function should provide this halving count as an unsigned integer, reflecting the current halving period within a blockchain contract.",
        "url": 164
    },
    {
        "nl_input": "The query requires a contract function that allows the crowdsale owner to withdraw any specified amount of ether from the contract at any time. This function must restrict access solely to the owner and enable flexible withdrawal amounts rather than only the entire balance.",
        "url": 165
    },
    {
        "nl_input": "The query requires a function that converts a uint256 WSIC value into a Warship structure by extracting and bit-shifting specific segments of the uint256 value into corresponding Warship fields.",
        "url": 166
    },
    {
        "nl_input": "The query requires a function restricted to the contract owner that specifically delivers or mints tokens to ICO investors. This function should transfer tokens from the owner to a given investor address or mint tokens directly for the investor, ensuring proper authorization and token allocation during the ICO phase. The function must enforce owner-only access control to securely manage token distribution to ICO participants.",
        "url": 167
    },
    {
        "nl_input": "The query requires a method that allows users to cast a single vote for a specified candidate, identified by an input parameter. The method should validate the candidate's identifier, ensure the voting period is active, prevent double voting or track voters, record the voter's choice, and emit an event signaling that the vote has been cast. The focus is on a straightforward voting mechanism tied to candidates with proper checks and voter registration.",
        "url": 168
    },
    {
        "nl_input": "Retrieve the total amount of pending bets by summing the bet prices of all bets currently in a waiting state. Specifically, include bets with states indicating they are waiting for pairing or waiting on an oracle, applying different multipliers as needed. This involves iterating through all bets and accumulating their values to obtain the aggregate pending bet amount.",
        "url": 169
    },
    {
        "nl_input": "The query requires a function within a smart contract that allows setting or updating a delegate address responsible for delegated execution of certain methods. This function should include access control (e.g., only the owner can set the delegate), verify that the new delegate address is different from the current one, and emit an event upon successfully updating the delegate address. The purpose is to assign a specific address as the delegate for executing designated contract functions.",
        "url": 170
    },
    {
        "nl_input": "The query requires adding a Digix price feed functionality that updates and verifies price data on-chain. The contract should accept parameters like block number, nonce, and Digix price bids and asks, enforce nonce increment and valid block range checks, verify a signature for security, and encode the price feed data. This ensures tamper-proof, up-to-date Digix pricing information is stored and accessible within a smart contract.",
        "url": 171
    },
    {
        "nl_input": "The query requires a function that securely transfers an estate token from the previous owner to a new owner. This involves verifying token existence, confirming current ownership, preventing transfers to invalid addresses, updating related payout data, clearing prior approvals, removing the token from the old owner, assigning it to the new owner, and emitting a transfer event to log the change of ownership.",
        "url": 172
    },
    {
        "nl_input": "The query requires an internal utility function designed to finalize a PvE battle, presuming all battle completion conditions are met. This function should handle post-battle updates such as setting the warrior's action state to idle, managing cooldown periods based on warrior level and bonuses, incrementing dungeon progression if applicable, assigning ownership, and possibly generating or triggering related events after finishing the PvE encounter.",
        "url": 173
    },
    {
        "nl_input": "Retrieve the balance of tokens held by a specific user address at a particular block number in the blockchain, enabling historical token balance queries for that user at the given block.",
        "url": 174
    },
    {
        "nl_input": "The query requires a function to mint tokens for purchases made during a pre-crowdsale period before the official crowdsale starts. The function should ensure that minting occurs only prior to the crowdsale start time, prevent minting to a zero address, and enforce an upper limit on total tokens minted during this phase. It should then mint the specified tokens to the investor's address and record the purchase event accordingly.",
        "url": 175
    },
    {
        "nl_input": "The query requires an ERC20 token transfer function that restricts token transfers until a sale process is finalized. Specifically, token holders should only be able to transfer their tokens after the sale has officially ended and finalization conditions are met. The function should enforce a check to ensure that transfers are disabled during the sale period and enabled strictly post-finalization, providing controlled token distribution aligned with sale completion.",
        "url": 176
    },
    {
        "nl_input": "The query requires calculating a rate value by multiplying a base rate by (100 plus a bonus) and then dividing by 100. The bonus can be a dynamic value influenced by certain conditions or thresholds. The computation should be done using safe arithmetic operations within a function, returning a final adjusted rate that incorporates both the base rate and applicable bonuses formatted as a percentage increase.",
        "url": 177
    },
    {
        "nl_input": "The query requires extracting a token or rate schedule contract that defines specific rate values for given time intervals, particularly with initial rates around 1,500,000 units or similar magnitude. The contract should detail how the rate changes over defined periods starting from a set start time, providing exact rate constants for each period within approximately the first 1,500,000 units or related range.",
        "url": 178
    },
    {
        "nl_input": "The query requires an internal utility function that initiates a PvP battle, presuming all prerequisites for the battle are already validated. This function should manage the starting process of a player-versus-player battle within the contract environment, ensuring preconditions for battle integrity have been met before execution.",
        "url": 179
    },
    {
        "nl_input": "The query requires a contract feature that restricts a function to being called only once. This is typically implemented using a modifier that checks a condition to ensure the function has not been previously executed, preventing multiple calls.",
        "url": 180
    },
    {
        "nl_input": "The query requires a system that accepts contributions only if the contributor has passed KYC verification. This involves setting KYC levels for addresses, which determine their contribution caps. Contributions should only be accepted and processed when the contributor\u2019s KYC status is validated and meets the required level, ensuring compliance before allowing contributions or token allocations.",
        "url": 181
    },
    {
        "nl_input": "The query requires functionality to modify the minimum bet amount allowed in a betting contract. Specifically, it seeks a method to update the minimum bet threshold, typically restricted to the contract owner, ensuring the new minimum is greater than zero before applying the change. This allows dynamic adjustment of the minimum stake players must place to participate in betting activities.",
        "url": 182
    },
    {
        "nl_input": "The query requires a function that calculates and retrieves a specific number of tokens based on an input amount, such as ether or investment. This function should accept an amount as input, compute the corresponding token quantity according to a certain rate or logic, and return the exact number of tokens allocable or retrievable for that amount.",
        "url": 183
    },
    {
        "nl_input": "The query requires retrieving an array of gift IDs associated with a specific gift template ID from a mapping structure. The function should accept a template ID as input and return the corresponding list of gift IDs linked to that template.",
        "url": 184
    },
    {
        "nl_input": "The query requires a function invoked after the crowdsale ends to perform finalization tasks such as forwarding collected funds to a wallet if the funding goal is met or enabling refunds if the goal is not reached. This function should include checks ensuring the crowdsale has concluded, prevent repeated finalization, and emit events indicating completion or refund status. It may also handle token minting finalization and fund forwarding as part of the closure process.",
        "url": 185
    },
    {
        "nl_input": "The query requires a smart contract function that calculates the number of tokens to be sent to the buyer based on the amount of ether sent multiplied by a predefined rate set during deployment. The function must validate the payment, compute tokens by multiplying the sent value with the rate, ensure supply constraints, update issued token records, mint or transfer the calculated tokens to the buyer, and forward the received ether to a designated wallet.",
        "url": 186
    },
    {
        "nl_input": "The query requires implementing a function that handles purchasing tokens during a specific sale stage, ensuring conditions like stage validity, token availability, and purchase limits are met. It should calculate token amounts based on payment, manage leftover funds if token availability is insufficient, update sale stages accordingly, and handle beneficiary payouts securely. Additionally, it involves managing distributor permissions or enforcing sale constraints such as timing, caps, and minimum contribution limits.",
        "url": 187
    },
    {
        "nl_input": "The query requires a function that enables users to fortify multiple previously claimed tiles within a single transaction. This function should accept an array of claimed tile IDs, a fortify amount, and a boolean to indicate whether to use a battle value. It must verify the provided payment matches the fortify amount and then apply the fortification to all specified tiles efficiently, ensuring the operation occurs only when the contract is active and the caller is valid.",
        "url": 188
    },
    {
        "nl_input": "The query requires a function that processes purchases specifically during a private sale stage, handling token allocation based on the amount sent and the current token pool. It should verify the sale stage, compute tokens purchasable for the given payment, allocate tokens if available, and handle excess payment by refunding the buyer. This function operates privately within the contract to manage private sale transactions accurately and ensure proper token distribution and payment handling at this stage.",
        "url": 189
    },
    {
        "nl_input": "The query requires a function that allows transferring token balances specifically from the owner's account to another account, with the restriction that only an escrow contract or entity can initiate these token transfers. This mechanism is intended to enable private sale token transfers securely, ensuring only authorized escrow can perform the transfer, protecting the owner's tokens from unauthorized movement.",
        "url": 190
    },
    {
        "nl_input": "The query requires functionality to create a new poll, including setting parameters like title, quorum, or approval percentage, verifying uniqueness or validity of poll details, initializing poll data structures, and emitting events upon creation. The poll setup should support managing voting periods or quorum thresholds and ensure only authorized or valid poll creations.",
        "url": 191
    },
    {
        "nl_input": "The query requires checking whether the variable dstWalletLMNO is assigned a non-zero (valid) address. This involves verifying that dstWalletLMNO is not set to the zero address (address(0)) in the contract, ensuring it has been properly initialized or configured before being used in functions like debitWalletLMNO.",
        "url": 192
    },
    {
        "nl_input": "The query requires implementing a mechanism that restricts access to the slots bankroll, allowing withdrawals only after a period of 60 days has passed. This involves enforcing a time-based lock on bankroll funds, ensuring funds cannot be accessed or withdrawn until the 60-day period elapses. The solution should include proper permissions for bankroll management and safeguard the transfer of funds upon meeting the timing condition.",
        "url": 193
    },
    {
        "nl_input": "The query requires a contract function that accepts ERC-20 tokens which a user has approved for spending, and in exchange, issues the user RMC tokens. It involves utilizing the allowance granted by the user to transfer their ERC-20 tokens and then providing the corresponding RMC tokens to the user, ensuring proper token transfer mechanisms and user authorization are handled.",
        "url": 194
    },
    {
        "nl_input": "The query requires code that determines conditions under which a jackpot is released and specifies the recipient of the jackpot funds. It involves logic to decide if the jackpot payout should occur, typically based on timing or other criteria, and identifies the ticket holder or address that receives the jackpot amount. The solution must include mechanisms to handle the transfer of the jackpot balance accordingly.",
        "url": 195
    },
    {
        "nl_input": "The query requires a function that calculates and returns the profit from selling a specified number of outcome tokens. The function should compute the profit based on market conditions, deduct any applicable fees, ensure the resultant profit meets a minimum threshold, handle token transfers securely, update token sale records, and emit an event indicating the details of the token sale transaction.",
        "url": 196
    },
    {
        "nl_input": "The query requires a function that assigns asset share tokens to the authors of winning bids. This involves verifying auction success status, calculating shares and returns based on bid details and final prices, updating assigned shares and funds raised, transferring any return amounts to investors, marking bids as closed, tracking share holders and their balances, and emitting an event to record the assignment.",
        "url": 197
    },
    {
        "nl_input": "The query requires a function that returns the quantity of available tokens. This involves calculating the remaining or accessible tokens for a user or phase by considering conditions such as token caps, time-based allocations, or claimed amounts. The function should provide an accurate count of how many tokens can be currently accessed or claimed by an address or in a particular contract phase.",
        "url": 198
    },
    {
        "nl_input": "The query requires a function to retrieve the available inventory quantity of a specific product identified by its product ID. The function should be a public view method that returns the current available stock for the given product from a stored product mapping or data structure.",
        "url": 199
    },
    {
        "nl_input": "The query requires a function to mint tokens by creating new tokens and assigning them to a specified address. This function should include safety checks such as ensuring the recipient address is valid (not zero), updating the recipient's token balance, increasing the total token supply, and emitting appropriate transfer events to record the minting process on the blockchain. Access control, like restricting minting to authorized users, can also be part of the requirements.",
        "url": 200
    },
    {
        "nl_input": "The query requires functionality that empowers the reservation owner to either close their reservation earlier than planned or extend its duration. This implies implementing controls for modifying the reservation end time or prematurely terminating the reservation while ensuring proper access control, such as restricting these actions to the reservation owner. The functionality should handle validation of time constraints and update the reservation state accordingly.",
        "url": 201
    },
    {
        "nl_input": "The query requires a function to change the lock period, restricted to execution by the contract owner only. The function should accept a time period parameter, enforce constraints on its value (e.g., within a specified range), and update the lock period accordingly. This ensures that only the owner can modify the lock duration, maintaining controlled access and secure setting of the lock timing mechanism.",
        "url": 202
    },
    {
        "nl_input": "The query requires a smart contract allowing the owner to refund collected ETH to contributors if either the soft cap is not met or KYC verification fails. This includes mechanisms to check contribution eligibility via KYC levels, track contributions, and enable the owner to send ETH back to contributors under these conditions, ensuring compliance and secure refund capability.",
        "url": 203
    },
    {
        "nl_input": "The query requires functionality to cancel an ongoing auction. It involves validating the caller's ownership, ensuring the item is currently on auction, updating or removing auction-related data, transferring ownership if needed, and emitting an event to signal auction cancellation.",
        "url": 204
    },
    {
        "nl_input": "The query requires a smart contract where the contract owner can add funds to the jackpot (\"seed\" it) and ensure that the seeded amount is accounted for and can be reclaimed when the jackpot is paid out. This implies functions to allow only the owner to deposit into the jackpot, update the jackpot balance accordingly, and a mechanism to return the seeded amount when distributing the jackpot.",
        "url": 205
    },
    {
        "nl_input": "The query requires a function that retrieves the sender's (caller\u2019s) information or identity within a contract. This includes accessing and returning details tied to the message sender, such as their address or associated data stored in the contract. The primary need is to obtain the caller's information programmatically inside a smart contract function.",
        "url": 206
    },
    {
        "nl_input": "The query requires implementing a contract that adheres to the tokenRecipient interface, focusing on functions to claim or manage tokens. It involves creating methods that allow an address (typically the message sender or a specified recipient) to claim tokens, possibly on behalf of investors or others. The implementation should ensure proper token assignment, secure claiming processes, and appropriate ownership or permission checks as needed.",
        "url": 207
    },
    {
        "nl_input": "The query requires a backup withdrawal function to safely transfer any ETH balance held in the contract to a designated wallet or owner, ensuring that ETH mistakenly sent to the contract can be recovered. The withdrawal should only be allowed after specific conditions (e.g., ICO ended or contract stage completed) and restricted to authorized users (owner or creator). The function should securely transfer the entire contract balance to the intended recipient without vulnerabilities.",
        "url": 208
    },
    {
        "nl_input": "The query requires a function named setAdmin that allows only the contract owner to change the admin address. This function should securely update the admin address, ensuring the new address is valid and not the owner, the contract itself, or an operations address, and trigger an event upon successful change.",
        "url": 209
    },
    {
        "nl_input": "The query requires a description of a purely internal method that exclusively resets two specific mappings: sellerListMapping and sellerToPrice, by zeroing out their values for a given seller address. This method does not affect other data and is intended to clear or deactivate the seller\u2019s entries in these two mappings only.",
        "url": 210
    },
    {
        "nl_input": "The query requires a function that transfers a LAND token represented by coordinates (x, y) to a specific address. This involves a method that takes coordinates and a recipient address as inputs and executes the transfer of the encoded LAND token ID to that address. The focus is on enabling LAND ownership transfer using coordinates-based token identification and transferring ownership to another user's address.",
        "url": 211
    },
    {
        "nl_input": "The query requires a function that allows the contract owner to complete the loyalty phase and then initiate the presale phase. Specifically, the owner should be able to end the loyalty part (by setting a related state to false) and start the presale phase by recording the current block number as the presale start time. The transition must be restricted to the owner to ensure controlled phase management.",
        "url": 212
    },
    {
        "nl_input": "The query requires a housekeeping function in a smart contract to safely handle contract termination or decommissioning after events like a LOT upgrade. The function should restrict access to the owner, ensure certain conditions or time periods have passed, and securely transfer remaining contract balance or destruct the contract to clean up resources. This is to ensure proper closure and fund management when the contract is no longer needed.",
        "url": 213
    },
    {
        "nl_input": "The query requires a function to add a new manager by assigning a manager address to an entity, with checks to validate permissions and prevent the manager from being set to itself. It should emit an event upon changing the manager to notify about the update. The function involves access control to ensure only authorized users can set or enable a manager, and it manages the state of manager assignments securely.",
        "url": 214
    },
    {
        "nl_input": "The query requires a function that allows staking tokens on behalf of a specific user, thereby locking those tokens and simultaneously rewarding that user with credits or points. This involves deducting tokens from the caller, assigning them to the user, and updating the user's credit balance to reflect the reward. The functionality must securely handle staking parameters and ensure the user's credit balance update correlates with the staked amount and lock-in duration.",
        "url": 215
    },
    {
        "nl_input": "The query requires a Solidity modifier that verifies whether a given value can be safely stored within a 64-bit unsigned integer range. This involves checking if the value fits into 64 bits without data loss or overflow, typically by casting the value to a 64-bit type and ensuring equality with the original value.",
        "url": 216
    },
    {
        "nl_input": "The query requires initializing betting data by setting parameters such as the ticket price and bet title. This involves defining a function to assign initial values to betting configurations, typically restricted to an admin role, to prepare the system for accepting bets.",
        "url": 217
    },
    {
        "nl_input": "The query requires a function to submit an order-ring for validation and settlement. The function should accept multiple orders with detailed parameters, verify their integrity, ensure tokens are registered, and authenticate signatures. It then assembles the orders, computes a ring hash for the entire order-ring, and handles the ring settlement, including fee recipient designation and preventing reentrancy during processing. The operation must check the ring size limits and manage a ring index to avoid duplicate processing.",
        "url": 218
    },
    {
        "nl_input": "The query requires a default approval function in a smart contract that allows an address to approve a specified token amount for a spender. It should ensure the allowance can only be set if the value is zero or the current allowance is zero (to prevent race conditions). The function must update the allowance mapping, emit an Approval event with the sender, spender, and amount, and return a boolean success indicator.",
        "url": 219
    },
    {
        "nl_input": "When the minimum cap (MIN_CAP) is not reached, backers must first approve the Devvote token contract to transfer all their Devvotes for refund. Then, they call the refund function in the DevvotePrefund contract with the same amount of Devvotes to initiate the refund process. Finally, backers invoke the withdrawPayments function of the DevvotePrefund contract to receive their refund in ETH. This ensures backers can reclaim their contributions if the funding goal is unmet.",
        "url": 220
    },
    {
        "nl_input": "The query seeks a method or function that returns the X and Y coordinates of the elliptic curve point representing the public key. Specifically, it requires extracting or defining a function that, given an input node or identifier, retrieves both the X and Y values of the public key's curve point for cryptographic or verification purposes.",
        "url": 221
    },
    {
        "nl_input": "The query requires a function that returns the current token or ICO cap value. This involves retrieving a numerical cap representing the maximum tokens or funds allowed, ideally returned as a uint256, reflecting the current state accurately and directly without additional calculations or restrictions.",
        "url": 222
    },
    {
        "nl_input": "The query requires functionality to set or update the ICO (Initial Coin Offering) status within a smart contract. Specifically, it involves defining a method to change the ICO status to active or other states based on conditions, such as token availability or ICO phases. This includes managing different ICO stages, transitioning the status accordingly (e.g., active, waiting, closed), and potentially verifying if a given time falls within the ICO period.",
        "url": 223
    },
    {
        "nl_input": "The query requires retrieving the value of the contract's constant variable named _symbol. This involves accessing the symbol data stored in the contract, typically via a public view function that returns the symbol string. The focus is specifically on extracting the _symbol constant, indicating the contract's identifier or ticker symbol.",
        "url": 224
    },
    {
        "nl_input": "The query requires a function named setTokenAddress that assigns a token address to a variable, can only be called once, and is restricted to the founder (a specific privileged role). This function should enforce a single assignment by checking a flag and prevent multiple calls, ensuring only the founder role can execute it.",
        "url": 225
    },
    {
        "nl_input": "The query requires a function that returns the registered EOS public key associated with a given address. The solution involves checking stored keys mapped to the address and, if not found, querying an alternative source like a crowdsale key. The function should accept an Ethereum address as input and provide the corresponding EOS public key as a string output.",
        "url": 226
    },
    {
        "nl_input": "The query requires a function to transfer tokens from one specified address to another, typically involving deduction from the sender's balance, allowance checks or adjustments, and addition to the recipient's balance. The function should handle token contracts or balances securely, verify permissions or conditions like owner restrictions or tradeability, and emit transfer events to record the transaction. It must enable moving tokens on behalf of another address, not just the caller's own tokens.",
        "url": 227
    },
    {
        "nl_input": "The query requires a function that enables batch approval for multiple addresses simultaneously, allowing the caller to set or revoke approval for all their tokens to a list of spenders in one transaction. This function should validate input, prevent zero addresses, and loop through the given addresses to apply approveAll settings efficiently. The primary goal is to facilitate bulk \"setApprovalForAll\" operations to streamline permissions management.",
        "url": 228
    },
    {
        "nl_input": "The query requires a function that allows the contract owner to burn all remaining tokens in the owner's account, effectively reducing the total supply to zero. Additionally, the function should set or update the license cost, potentially by adjusting parameters such as a numerator and denominator. The operation must be restricted to the owner, occur only once, and ensure the token burn and license cost update happen atomically and securely.",
        "url": 229
    },
    {
        "nl_input": "The query requires creating a new proposal mechanism within a contract, allowing a designated user to submit a proposal under specific conditions or stages. This process involves setting a target address or action for transfer or change, initializing proposal parameters such as deadlines and voting status, and ensuring only authorized roles can propose. The proposal should be restricted by timing or state constraints to avoid overlapping requests and require consensus or approval steps to proceed.",
        "url": 230
    },
    {
        "nl_input": "The query requires a function within a smart contract that returns the total number of match entries stored in the contract, specifically by accessing and returning the length of a matches array or similar data structure.",
        "url": 231
    },
    {
        "nl_input": "The query requires a function enabling the release of FT tokens specifically for the core team account. The solution should allow authorized users or the contract itself to trigger the token release process for the core team, ensuring that the core team's locked or timelocked tokens can be claimed or unlocked. The focus is on granting access to release core team tokens securely and accurately within a smart contract.",
        "url": 232
    },
    {
        "nl_input": "The query requires calculating the offset of a given block number within a specific interval. This involves determining the remainder when the block number is divided by a predefined constant, such as a subsidy halving interval, to find the block's position or offset within that interval.",
        "url": 233
    },
    {
        "nl_input": "The query requires a function to set an expiration time as a timestamp in milliseconds since 1970 (Unix epoch). The function should allow only authorized users (e.g., owner) to set this expiry time directly with a parameter representing the expiry in milliseconds. It ensures precise control over the expiration moment using a 64-bit integer value for time.",
        "url": 234
    },
    {
        "nl_input": "The query requires functionality to remove a specified contract address from an active contracts list by updating or deleting its entry and maintaining the integrity of the list, including index adjustments as necessary to prevent gaps or inconsistencies.",
        "url": 235
    },
    {
        "nl_input": "The query requires functionality to change or transfer the ownership of a product or contract. This involves verifying permissions, updating the owner to a new specified address, and ensuring the new owner is valid. The process may emit events to signal ownership changes and restrict actions to authorized callers only, preventing unauthorized ownership transfers.",
        "url": 236
    },
    {
        "nl_input": "The query requires a function to set or update a wallet address in a contract. The function should be restricted to the contract owner and include safety checks such as ensuring the new wallet address is not zero, not the contract's own address, and not a current owner address. The function should update the stored wallet address and ideally emit an event to signal the update.",
        "url": 237
    },
    {
        "nl_input": "The query requires a failsafe mechanism to remove or abort a game. This includes safely refunding players their stakes if the game is active, handling unsuccessful refund attempts by holding fees, marking the game as inactive, recording the reason for ending (such as cancellation or timeout), updating relevant counters, and triggering appropriate events. Additionally, it may involve manual removal of game data and unlocking associated resources by the owner, ensuring proper cleanup and prevention of game activity continuation.",
        "url": 238
    },
    {
        "nl_input": "The query requires a function that retrieves the owner of a specific token or the tokens owned by a given address. The function should accept an address parameter and return the token ID(s) or count associated with that owner, indicating ownership details of tokens for that address.",
        "url": 239
    },
    {
        "nl_input": "The query requires a function that determines if an entity is a user entity, returning true only if the entity was created with createUser() and false if created with createVirtualEntity(). This involves verifying the entity's creation method or ownership to distinguish between user entities and virtual entities.",
        "url": 240
    },
    {
        "nl_input": "The query requires a function designed to facilitate token purchases using other tokens as payment. The function should allow a user to specify a token address and execute a purchase transaction that handles buying tokens via the provided token mechanism, rather than using currency or native cryptocurrency directly.",
        "url": 241
    },
    {
        "nl_input": "The query requires a function that allows the contract owner to set or update a standard signature by redirecting it to one of several predefined, approved function signatures. This ensures that the standard signature is mapped only to authorized pre-signed functions, enhancing controlled behavior within the smart contract.",
        "url": 242
    },
    {
        "nl_input": "The query requires retrieving the \"TocPrice\" value from a contract's market data. The relevant function must be a public view function that returns the TocPrice associated with a specific contract address, providing the current TocPrice as a uint256 value.",
        "url": 243
    },
    {
        "nl_input": "The query requires a function to cancel a blackmarket order where the seller wants to revoke an offer for selling a specific quantity of cocaine at a defined price. The function must identify matching orders from the seller with the given quantity and price, remove them from the offer list, and emit an event confirming cancellation. It should support canceling one or multiple matching orders depending on a flag while ensuring the seller\u2019s authorization and order existence.",
        "url": 244
    },
    {
        "nl_input": "The query requires calculating the total lottery amount or total pot available in a lottery contract. This involves determining the total funds collected or held for payout before any deduction of fees, commissions, or donations. The description includes retrieving the lottery balance or total bet amount and accounting for deductions such as commission and donation fees to find the net total payout amount or total lottery amount available for distribution.",
        "url": 245
    },
    {
        "nl_input": "The query seeks functions related to game management, including retrieving the total number of games, accessing detailed game information such as contract address, description, URL, submitter, and timestamp, and handling game operations like forfeiting a game with state validation, fee processing, updating player balances, recording results, and transferring funds. These functions facilitate tracking, querying, and managing the lifecycle and outcomes of games within a smart contract environment.",
        "url": 246
    },
    {
        "nl_input": "The query requires verifying the integrity and correctness of a contract's relationships or conditions, such as ensuring gifts are valid and unredeemed, change requirements are logically consistent and not overly restrictive, or confirming that terms and conditions are duly signed by the user. The focus is on proper validation functions that enforce contract rules and prevent invalid or unauthorized states, ensuring the contract's operational logic is sound and reliable.",
        "url": 247
    },
    {
        "nl_input": "The query requires a helper function within a smart contract that allows the user interface (UI) to display the amount of ETH a specific user has already contributed. This function should take the user's address as input and return the total ETH contribution made by that user in a view (read-only) manner.",
        "url": 248
    },
    {
        "nl_input": "The query requires a function that extracts and returns an address encoded as the first argument from transaction data. This involves decoding the transaction input data to isolate the initial argument and converting it into a valid Ethereum address format. The solution must handle raw transaction calldata parsing rather than simply accessing the contract's own address or sending transactions.",
        "url": 249
    },
    {
        "nl_input": "The query requires a function to determine if a specific day index corresponds to a holiday. It involves checking a day index against defined holiday ranges or lists and returning a boolean or indicator reflecting holiday status. The solution should efficiently categorize the day index and verify whether it falls on a holiday based on stored holiday data or ranges.",
        "url": 250
    },
    {
        "nl_input": "The query requires a function that verifies whether a specific address has previously invested by checking if it exists in a list or mapping of investors. This function should return true if the address is found among investors, indicating prior investment, and false otherwise.",
        "url": 251
    },
    {
        "nl_input": "The query requires retrieving the current stage of a contract based on time or conditions. It involves calculating or returning the stage index or status, such as by comparing blockchain timestamps against a start time and dividing by a stage duration, or checking if certain conditions or states (e.g., contribution caps or predefined stages) are met to transition or identify the current stage.",
        "url": 252
    },
    {
        "nl_input": "The query requires a smart contract function that prevents authorized wallets from withdrawing funds from the \"bonkroll\" to a specific address. It seeks a mechanism disallowing withdrawals by authorized users to that particular address, ensuring funds cannot be transferred there by authorized parties.",
        "url": 253
    },
    {
        "nl_input": "The query requires displaying both the timelock periods and the corresponding locked values for a given address. This involves retrieving an array of timelock durations and accessing the amounts locked during each period, effectively showing the schedule and quantities of locked assets.",
        "url": 254
    },
    {
        "nl_input": "The query requires a function that allows the registry owner or admin to withdraw any surplus value or balance held within the contract. This function should include access control to restrict withdrawal to the owner or admin only and facilitate transferring the specified amount or entire balance of tokens or Ether from the contract to the owner. It is essentially a withdrawal mechanism for surplus funds in the registry contract, ensuring secure authorized access.",
        "url": 255
    },
    {
        "nl_input": "The query requires a function to configure or set up a whitelist, enabling specific addresses to be authorized or allowed access. This involves assigning a whitelist contract address or adding addresses to the whitelist, typically controlled by the contract owner and applicable during a specific contract stage or active sale period. The function should ensure proper access control and state management of the whitelist feature.",
        "url": 256
    },
    {
        "nl_input": "The query requires a function that allows the current owner of a contract to transfer ownership rights to a new Ethereum address. This involves verifying that the new owner address is valid and updating the ownership state variable accordingly, ensuring that only the current owner can authorize this change. The function should securely handle ownership transfer and emit ownership transfer events if applicable.",
        "url": 257
    },
    {
        "nl_input": "The query requires a function that enables the current collector to transfer the contract's control to a specified newCollector address. The function should be restricted to authorized users (e.g., only the owner), verify the newCollector is a valid non-zero address, emit an event to signal the transfer of collectorship, and update the collector state variable to the new address accordingly.",
        "url": 258
    },
    {
        "nl_input": "The query requires a function that caps a reward amount based on three factors: the reward itself, the contract's current balance, and the remaining daily limit. The function should return the minimum of these three values to ensure the reward does not exceed any of these constraints.",
        "url": 259
    },
    {
        "nl_input": "The query requires functionality to transfer the \"superOwner\" role or authority to a new address, specifically allowing a current superOwner or a designated privileged owner to hand over their superOwner rights. The transfer must emit an event indicating the role change and update the superOwner variable accordingly, ensuring only authorized callers can perform this action.",
        "url": 260
    },
    {
        "nl_input": "The query requires a function enabling users to purchase Dragon Ball Z heroes by paying the current price in Ether. The function should verify the payment matches the hero's price, ensure the contract is not paused, distribute a 10% developer fee and the remainder to the current owner, transfer hero ownership to the buyer, and then double the hero's price for future sales.",
        "url": 261
    },
    {
        "nl_input": "The query requires a function that returns the total number of bronze caps produced so far. It seeks a read-only method providing a numeric count of produced bronze caps, typically reflecting a tracked supply value in the contract.",
        "url": 262
    },
    {
        "nl_input": "The query seeks a function that updates both the balances mapping and the totalSupply (or totalSupplyHistory) variable. Specifically, it requires a function that assigns a value to the balances map for an address and simultaneously modifies the total supply record, reflecting token issuance or supply changes.",
        "url": 263
    },
    {
        "nl_input": "The query requires determining whether a process or funding set has been completed successfully. Specifically, it asks for a condition or function that confirms the success status of a set. The criteria involve checking a state variable or status flag that indicates if the set is finalized, completed, or marked as successful. The focus is on validating the completion status to ensure that the set's success is confirmed programmatically.",
        "url": 264
    },
    {
        "nl_input": "The query requires a setter function named to update the timePerPeriod variable, which is an array of unsigned integers, ensuring only authorized users (e.g., a governor) can call it. The function should accept an array parameter to set or modify multiple time periods simultaneously.",
        "url": 265
    },
    {
        "nl_input": "The query requires a feature allowing the contract owner to authorize a specific address, such as a crowdsale contract, to transfer tokens even during a lock-up period, overriding normal transfer restrictions. This means the owner can grant transfer permissions to certain contracts despite usual time-based or condition-based transfer locks.",
        "url": 266
    },
    {
        "nl_input": "The query requires a function that allows player 1 to forfeit or concede a game without revealing their move, effectively indicating they have lost. This involves updating the game state to ended, marking the result as a forfeit, transferring winnings and fees accordingly, and triggering game end events. The function should be callable only by player 1 under specific game conditions, ensuring a clean and undisclosed loss acknowledgment.",
        "url": 267
    },
    {
        "nl_input": "The query requires a function that, when called exclusively by a housekeeping role, cleans up an active game by setting its state to inactive and refunds all player balances within the game. The process must ensure that any player holdings are returned, and if refunds fail, amounts are preserved for later handling. Additionally, the function must log appropriate events about the refund and game termination reasons, specifically allowing only the housekeeping entity to initiate this cleanup.",
        "url": 268
    },
    {
        "nl_input": "The query requires functionality that allows the contract owner to modify the bonus value corresponding to the current phase of a process, such as an ICO. This involves a function restricted to the owner that can update the bonus amount depending on the ICO phase, ensuring the new bonus differs from the existing one, and triggering an event to signal the bonus change.",
        "url": 269
    },
    {
        "nl_input": "The query requires functionality to add a new animal type to the game, specifically by enabling the insertion of a new animal cost entry into stored lists, with proper access control to ensure only the game owner can add. This involves implementing a function that updates animal-related data structures to extend the range of animal types in the game.",
        "url": 270
    },
    {
        "nl_input": "The query requires a modifier that restricts function execution exclusively to times when the contract is not paused, ensuring actions cannot occur while paused. This modifier should enforce a condition that the contract\u2019s paused state is false before allowing the function to proceed.",
        "url": 271
    },
    {
        "nl_input": "The query requires functionality to directly mint tokens to a Hashed TimeLock Contract (HTLC) address. This involves creating new tokens and assigning them to the HTLC contract's address while ensuring appropriate checks, like non-zero recipient addresses and authorization controls. The minting process should update total supply, adjust the recipient's balance, and emit transfer events indicating token creation from the zero address to the HTLC contract.",
        "url": 272
    },
    {
        "nl_input": "The query requires a function within a smart contract that allows the contract owner to change or update the wallet address. The function should include appropriate access control (onlyOwner) and ideally validate the new address to prevent setting it to the zero address. The purpose is to securely modify the stored wallet address used by the contract.",
        "url": 273
    },
    {
        "nl_input": "The query requires a function that retrieves the namespace string associated with a given address from a service locator, ensuring the namespace is valid by checking its time-to-live and last update. If the namespace is expired or invalid, the function should return an empty string; otherwise, it should return the stored namespace.",
        "url": 274
    },
    {
        "nl_input": "The query requires a function that allows creating a free token and transferring it directly to a specified recipient address. The function should include necessary checks, such as validating the recipient address is not zero or restricted and enforcing limits on the total supply of free tokens created. It should be callable by an authorized user, like an admin, to prevent unauthorized token creation and ensure controlled distribution.",
        "url": 275
    },
    {
        "nl_input": "The query requires a contract function modifier named \"onlyOwner\" that restricts function access exclusively to the contract owner. This modifier should include a check ensuring the caller's address (msg.sender) matches the stored owner address, preventing unauthorized users from executing owner-only functions. The modifier must be applied to functions to enforce this ownership constraint, providing secure control over sensitive contract operations.",
        "url": 276
    },
    {
        "nl_input": "The query requires a smart contract design ensuring that ETH sent to the contract cannot become irretrievably locked. This typically involves including mechanisms for the contract owner to withdraw all ETH balances, avoiding conditions that lock funds, and possibly using modifiers or checks to prevent locking states. The contract should allow ETH price setting only by the owner but must enable complete ETH withdrawal to prevent any ETH from being permanently trapped inside.",
        "url": 277
    },
    {
        "nl_input": "The query requires a method to efficiently invoke the function claimAllForInvestor using msg.sender as the argument. This involves implementing a function that calls claimAllForInvestor, passing in the address of the message sender, ensuring a streamlined and direct claim operation for the caller without unnecessary overhead or additional parameters.",
        "url": 278
    },
    {
        "nl_input": "The query requires a function that retrieves and returns the current price of a specified team based on its team ID. The function should accept a team identifier as input and provide the corresponding team's price as output, without additional processing or unrelated data.",
        "url": 279
    },
    {
        "nl_input": "The query requires modifying or updating the \"next steal time\" by setting it to a new timestamp based on a given input duration in seconds. The solution involves a function that adjusts the next steal timestamp by adding the input seconds to the current time.",
        "url": 280
    },
    {
        "nl_input": "The query requires a function that, given a holder\u2019s address, returns the registration date or time associated with that holder. The function should access a stored mapping or record indexed by the address and return the corresponding registration timestamp as an unsigned integer.",
        "url": 281
    },
    {
        "nl_input": "The query requires functionality to update the reward rate for a specific token in a contract. It involves modifying the reward rate value linked to a given token address, ensuring the new rate is positive and the token address is valid. The operation is restricted to authorized users, typically the contract owner, and involves iterating through existing reward sources to find and update the matching token's reward rate.",
        "url": 282
    },
    {
        "nl_input": "The query requires functionality to create or activate an owner in a contract, ensuring the owner address is valid and not previously activated. It involves adding new owners, tracking owner addresses and numbers, and enabling ownership transfer with proper authorization and non-zero address verification.",
        "url": 283
    },
    {
        "nl_input": "The query requires creating a new lottery round by deploying a contract instance with payable functionality, setting secret hashed values (salt and proof of N) for that round. The function should ensure ownership transfer of the new round contract to the creator and emit an event confirming its creation. It involves handling both cases of payable value presence or absence during instantiation and securely storing secret hashed parameters.",
        "url": 284
    },
    {
        "nl_input": "The query requires a contract function to set a \"softCap\" value, converting an input number (likely in a smaller unit) to a larger unit by multiplying it with a power of ten (specifically 10^12 or a similarly large factor), for managing a funding cap parameter typically used in token sales or crowdfunding contracts. This \"softCap\" should be adjustable by the contract owner and represent a significant threshold amount in the contract's currency unit.",
        "url": 285
    },
    {
        "nl_input": "The query requires a function that enables the contract owner to withdraw tokens to a beneficiary address, specifically excluding the DGZ token. The withdrawal should support any token address other than DGZ, transferring a specified amount securely, and emit an event logging the beneficiary, token address, and amount withdrawn. This ensures controlled withdrawal of various tokens except DGZ to a predefined beneficiary.",
        "url": 286
    },
    {
        "nl_input": "The query requires a function that disables or cancels the sale status of a specific block, ensuring only the block's owner can perform this action. This involves verifying ownership, changing the block's \"forSale\" status to false or zero, and triggering an event or update to reflect that the block is no longer for sale.",
        "url": 287
    },
    {
        "nl_input": "The query requires a function that enables a user (msg.sender) to claim the tokens owed to them from the contract. The function should access and calculate the token amount allocated to the sender, reset their allocation afterward, and transfer the corresponding tokens directly to the sender's address. This ensures an investor or participant can retrieve their entitled tokens based on their recorded allocations within the contract.",
        "url": 288
    },
    {
        "nl_input": "The query requires a function that retrieves and returns comprehensive details about a specific GameItem identified by its token ID. This information includes the item\u2019s unique ID, name, selling price, current owner address, and associated game ID, consolidating all relevant attributes of the GameItem into a single response for efficient access.",
        "url": 289
    },
    {
        "nl_input": "The query requires a smart contract feature that enables users to claim reward segments every 1000 units (blocks). This involves tracking user eligibility based on contribution and previous withdrawals, calculating the amount they are entitled to from accumulated segments, updating balances accordingly, and ensuring claims happen only after the required segment period. The mechanism should prevent double claims within the same segment and distribute rewards proportionally to user shares.",
        "url": 290
    },
    {
        "nl_input": "The query requires implementing a secure token exchange mechanism that involves transferring tokens between parties. It should include conditions to verify the legitimacy of token recipients and senders, handle token allocations from different sale stages with appropriate exchange rates, update balances accurately after transfers, and ensure transaction validity through checks like non-zero addresses and sufficient deposits. The process should support minting, claiming, and sending tokens securely within specified contract states.",
        "url": 291
    },
    {
        "nl_input": "The query requires facilitating the sale of presale tokens, including managing token allocations and purchases during the presale phase. This involves functions that allow users to buy presale tokens by paying ether, calculate token amounts based on exchange rates, transfer purchased tokens to buyers, update sale metrics such as tokens sold and total funds raised, and enable claim or redemption of presale tokens during or after the presale stage. Overall, it manages token distribution and fund handling specifically for presale participants.",
        "url": 292
    },
    {
        "nl_input": "The query requires implementing a mechanism to prevent specific targets from sending or receiving tokens. This involves disallowing or restricting certain addresses from receiving tokens, clearing approvals before transfers, and ensuring that tokens held by those targets cannot be transferred to or from them, effectively blocking all token transactions involving those addresses.",
        "url": 293
    },
    {
        "nl_input": "The query requires a function to remove a specific address from a list or array called \"pools.\" The function must verify that the address is valid and currently exists in the pool before removal. It should efficiently remove the address by replacing it with the last element in the array and then reducing the array length to avoid gaps, ensuring proper ownership or permission checks.",
        "url": 294
    },
    {
        "nl_input": "Retrieve the end date of a customer\u2019s term deposit by accessing their specific term deposit end time or date, typically stored in a mapping keyed by the customer\u2019s address, returning it as a timestamp or block number.",
        "url": 295
    },
    {
        "nl_input": "The query requires the implementation of a function to add a CZR token lock for a specified address. The function should allow the contract owner to set the lock amount, start time (defaulting to the current time if zero), and lock duration in months. It must ensure the amount is positive, record the lock details in a mapping, and emit an event documenting the new lock addition.",
        "url": 296
    },
    {
        "nl_input": "The query requires a function to transfer authority or ownership within the data layer of a contract, specifically transferring control rights like data authority or domain ownership to a new owner address. This involves a controlled function restricted to an owner role that calls an internal method to update or set the new authorized owner of specific data or domain elements in the contract.",
        "url": 297
    },
    {
        "nl_input": "The query requires a function that resolves a challenge for a given property ID (_propID). This involves retrieving the proposal and associated challenge, calculating the winner's reward and tokens, marking the challenge as resolved, and transferring rewards based on whether the challenge passed or failed, emitting corresponding events. The solution must handle setting the proposal's value if passed before a deadline and transfer tokens to the appropriate recipient, either the proposal owner or challenger.",
        "url": 298
    },
    {
        "nl_input": "The query requires a function that reduces the number of tokens a spender is allowed to use, effectively decreasing their approved allowance. This involves safely subtracting a specified value from the spender's current approved amount or resetting it to zero if the decrease exceeds the existing allowance, while emitting an event to record the updated approval status.",
        "url": 299
    },
    {
        "nl_input": "The query requires a function to whitelist multiple addresses at once by setting their status to true in a whitelist mapping. The function should accept an array of addresses, iterate through it, and mark each address as whitelisted. Access control should restrict the function to authorized roles like the owner or whitelister. The whitelist is updated in a loop to efficiently add multiple addresses in a single transaction.",
        "url": 300
    },
    {
        "nl_input": "The query requires identifying a function that is invoked exclusively by another function named shiftSale. Specifically, it seeks to find functions called only within the shiftSale context, ensuring no other external calls exist outside this function.",
        "url": 301
    },
    {
        "nl_input": "The query requires an extension of OpenZeppelin's StandardToken transferFrom function to include a mechanism for taking and storing snapshots of account states before executing token transfers. This involves augmenting the transferFrom method to record snapshot data for both the sender and receiver addresses at the time of transfer, enabling historical state tracking alongside the token transfer process.",
        "url": 302
    },
    {
        "nl_input": "The query requires a function to verify the amount of tokens that an owner has delegated or approved for a spender to use. It should check and return the allowance or approved token balance that the owner has assigned to the spender, ensuring that the delegated token amount is accessible or trackable.",
        "url": 303
    },
    {
        "nl_input": "The query requires functionality to add intervals to a data structure, specifically inserting an interval defined by a start and end point along with associated data into a tree. It should handle creating nodes if necessary, correctly position intervals relative to a center point, and manage interval storage within nodes. This involves maintaining interval relationships within a hierarchical structure, enabling efficient interval insertion and organization.",
        "url": 304
    },
    {
        "nl_input": "The query requires a function that allows token withdrawals only after the crowdsale has ended and been finalized. Specifically, it must include checks ensuring the crowdsale is closed and finalized before enabling users to withdraw their allocated tokens. Withdrawals before these conditions should be prevented to maintain the proper sequence of ending the sale and confirming results prior to token distribution.",
        "url": 305
    },
    {
        "nl_input": "The query requires a function that returns the token balance of a specified owner address. This function should be publicly accessible and return a numeric value representing how many tokens the owner holds. The focus is on retrieving and providing the balance data associated with the owner's address in a contract context.",
        "url": 306
    },
    {
        "nl_input": "The query requires a function that allows an authorized user, typically the contract owner or founder, to update or set the token address within a smart contract. The function should ensure restricted access, validate the new address if necessary, and assign it to a token-related state variable, enabling controlled modification of the token contract reference.",
        "url": 307
    },
    {
        "nl_input": "The query requires updating a board's status to reflect the losing player's color in a game context. Specifically, when a player loses, the board status should be set to indicate that the opposite color has won. This involves checking the losing player's color and then updating the board status accordingly, ensuring the game outcome accurately represents the winner based on the losing color.",
        "url": 308
    },
    {
        "nl_input": "The query requires a function that returns true if an event has ended. This is determined by checking whether the current time is past the event's end time or if a specific condition such as no tokens left is met. The function should be publicly accessible and return a boolean indicating the event's status as ended or not.",
        "url": 309
    },
    {
        "nl_input": "The query requires a method to verify if a given address is an authorized burner. This involves checking eligibility through a condition or modifier that confirms whether the burner address is permitted to perform burn operations, ensuring only approved burners can execute token burns or related actions.",
        "url": 310
    },
    {
        "nl_input": "The query requires a multisignature contract function that handles monetary value transfers or deposits using msg.value. It involves updating or managing multisig structures with conditions on unlocking times or value deposits, ensuring secure multisig execution or fund allocation through payable functions.",
        "url": 311
    },
    {
        "nl_input": "The query requires a function named \"recycle\" that disposes of a user's potatoes that have rotted over time. This function calculates the elapsed time since the last recycle, determines the portion of potatoes that have decayed based on a decay period, reduces the user's stored potatoes by the rotten amount, transfers the rotten potatoes to trash, and updates the recycle timestamp for the user. The purpose is to manage and remove spoiled potatoes from a user's storage.",
        "url": 312
    },
    {
        "nl_input": "The query requires determining the renewal interval of a product in seconds. The relevant information is found in a function that returns the renewal interval by accessing the product's interval property via its product ID. This function provides the renewal interval directly as a uint256 value representing seconds.",
        "url": 313
    },
    {
        "nl_input": "The query requires a function that allows any wallet with a recorded owed amount under addressToFailedOldOwnerTransferAmount to withdraw that specific value. The function should check the owed amount for the caller, ensure it is greater than zero, reset this amount to zero upon withdrawal, adjust the total failed transfer amounts accordingly, and transfer the owed Ether directly to the caller.",
        "url": 314
    },
    {
        "nl_input": "The query requires a function that calculates the winnings amount based on a given bet and a percentage. The calculation involves multiplying the bet by the percentage and dividing by 100 to determine the payout. This ensures that the winnings reflect the specified portion of the bet rather than fixed odds or conditions. The focus is on a straightforward mathematical computation to return the winnings value from the input parameters bet and percent.",
        "url": 315
    },
    {
        "nl_input": "The query requires a function that allows both the contract owner and an admin to change the admin address. The function should include access control restricting this ability to only owner or admin roles, validate the new admin address against certain conditions, update the admin address state variable, and emit an event indicating the change. This ensures secure and authorized modification of the admin address by designated roles only.",
        "url": 316
    },
    {
        "nl_input": "The query requires creating a function that generates a unique leaderboard identifier by hashing a given leaderboard name and an admin address. This involves using a cryptographic hash function (keccak256) combined with encoding the name and admin together to simulate creating a leaderboard hash for identification or indexing purposes.",
        "url": 317
    },
    {
        "nl_input": "The query requires defining setter methods that operate exclusively when the contract is in an unlocked state. This implies implementing functions that modify state variables but include checks or modifiers ensuring these setters can only be called if the contract is not locked, preventing state changes once locked.",
        "url": 318
    },
    {
        "nl_input": "The query requires functionality to add content to an agreement, including specifying a name, description, and reward amount. This involves implementing a method that updates the agreement's content with these details while ensuring conditions like not being locked, valid branding, and reward validation are met. The focus is on appending detailed entries to an agreement structure with appropriate access control and validation mechanisms.",
        "url": 319
    },
    {
        "nl_input": "The query requires a function or mechanism to update or set an interest or inflation rate based on a specific time or event, such as a new round in a sequence or after a defined period. The update should enforce access control (e.g., only owner) and include conditions validating the round number or elapsed time before allowing the rate update to ensure controlled and secure modifications of the rate parameter.",
        "url": 320
    },
    {
        "nl_input": "The query requires a function where markers can register a product by associating a productAccount address with an itemPublicKey transformed by sha3 (keccak256). This involves recording the product's marking while ensuring the product, brand, and app are active and valid, confirming the marker has permission, emitting a Marked event, and handling possible fee transfers via a token contract. The process must securely link productAccount to the hashed item key and update relevant mappings accordingly.",
        "url": 321
    },
    {
        "nl_input": "The query requires a function to end an auction by changing its state to ended, emitting an event with the highest bidder and bid, and transferring the highest bid amount to the auction owner.",
        "url": 322
    },
    {
        "nl_input": "The query requires a function that retrieves an owner address based on a zero-based index position from a list or mapping of owners. The function should accept an integer index and return the corresponding owner's address, adjusted correctly if the storage is 1-indexed internally.",
        "url": 323
    },
    {
        "nl_input": "The query requires a function that sets an initial date and associates it with a token, ensuring proper initialization before sale or allocation. This includes specifying a starting timestamp and linking a token address, validating token supply and ownership, and preparing the contract for subsequent stages. The process must enforce conditions such as valid addresses and initial setup constraints to securely manage token distribution timing and control.",
        "url": 324
    },
    {
        "nl_input": "The query requires a function that returns the price of a bet ticket. It seeks a method to access and retrieve the stored ticket price value, likely for display or calculation purposes within a betting contract.",
        "url": 325
    },
    {
        "nl_input": "The query requires a function triggered when tokens are purchased during a token sale. This function must validate sale timing, token availability, purchase limits, and calculate the total price with dynamic pricing tiers based on tokens sold. It should update token balances, track tokens sold and total funds raised, refund any excess payment, and emit a transfer event recording the purchase.",
        "url": 326
    },
    {
        "nl_input": "The query requires enabling token transfers, burning any unsold tokens by setting the token offering address to zero. This involves activating transfer permissions, identifying and burning remaining tokens allocated for sale, and ensuring the contract address or token offering address is reset or nullified to prevent further token distribution. The process typically includes owner-only functions that finalize the token sale by burning leftover tokens and enabling holders to transfer their tokens freely afterward.",
        "url": 327
    },
    {
        "nl_input": "The query requires a function called PlaceBet that accepts an Access Code and a Mode parameter, allowing users to place bets under certain conditions. The function should validate the bet amount against minimum and maximum limits, track the number of games played per block, and manage player participation. It should apply different odds based on whether the player has previously played and determine winnings using a random number mechanism.",
        "url": 328
    },
    {
        "nl_input": "The query requires a function that computes or determines the status of a transcoder, specifically identifying whether a given transcoder address is registered or not. The function should return a status enumeration indicating \"Registered\" if the transcoder is in the transcoder pool, or \"NotRegistered\" otherwise.",
        "url": 329
    },
    {
        "nl_input": "The query requires a function that processes a buy order by matching and filling it with a sell order, involving calculation of the fill amount, handling of fees, and transferring tokens accordingly. It should adjust the remaining ether and tokens obtained values, ensure validation of fees and order data, and support interaction with different exchange protocols to execute the sell order fill against the buy request.",
        "url": 330
    },
    {
        "nl_input": "The query requires functionality that enables anyone to transfer Reporter tokens only after trading has officially started, controlled by an accessible state flag indicating the start of trading. Once this trading status is activated by the contract owner, token transfers become permissible for all users without restrictions.",
        "url": 331
    },
    {
        "nl_input": "The query requires a function that returns the address of the current contract and provides information about the availability of allocated tokens or amounts for a given address or order. Specifically, it seeks access to an address representing the contract itself and a method to check how many allocated tokens or funds are available (unclaimed or unlocked) for a recipient or party, indicating allocation and availability details tied to an address.",
        "url": 332
    },
    {
        "nl_input": "The query requires a function that allows transferring a value and locking it, with the condition that only administrators can invoke the lock-setting operation. Specifically, the function should combine value transfer and lock setting, while the lock-setting method should have access restricted to admin roles.",
        "url": 333
    },
    {
        "nl_input": "The query requires a function that transfers ether from the current contract's balance to a specified beneficiary address. The function should accept the beneficiary's address as a parameter and execute the transfer of ether directly to that address. It should handle the ether transfer securely and appropriately, ensuring the correct recipient receives the funds.",
        "url": 334
    },
    {
        "nl_input": "The query requires a function that returns the address of the founder associated with a specific library token ID. The solution must include a public view function that, given a token ID, retrieves and returns the founder\u2019s address from a mapping. The function should ensure the returned address is valid (i.e., not zero). This addresses identifying and verifying the founder\u2019s address linked to a particular library item or token.",
        "url": 335
    },
    {
        "nl_input": "The query requires functionality that enables users to delete their accounts. This involves verifying the user's identity, removing their associated data from relevant mappings or directories, and emitting an event to confirm account deletion. The solution should ensure only the user can perform this action on their account, securely erasing personal information and preventing further access.",
        "url": 336
    },
    {
        "nl_input": "The query requires a function that enables buyers to claim or receive the tokens they have purchased. This involves verifying the buyer's eligibility, calculating or retrieving the token amount allocated to them from sales, resetting their allocation records to prevent double claims, and transferring the corresponding tokens to the buyer's address. The functionality should ensure that buyers can securely obtain their purchased tokens after the sale or claim period.",
        "url": 337
    },
    {
        "nl_input": "The query requires a function that enables transferring tokens from the caller (msg.sender) to another specified holder address. The transfer should validate sufficient token balance and minimum transfer limits and then execute the transfer operation successfully, updating ownership accordingly.",
        "url": 338
    },
    {
        "nl_input": "The query requires verifying that a sale is properly set up and has not yet ended. It involves checking whether the sale is actively configured (e.g., via flags or status functions) and confirming that the current time is before the sale's end time, ensuring the sale remains ongoing rather than finalized or closed. The focus is on validating both sale activation and that the sale period has not yet expired.",
        "url": 339
    },
    {
        "nl_input": "The query requires calculating the total Ether amount needed to successfully purchase an item. This includes the base purchase price, any applicable fees deducted or collected (such as buy fees handled internally), and the consideration of token pricing or rate tiers that affect the amount of tokens received per Ether spent. The solution must account for deductions, fee collection, and conversion rates to ensure the correct total Ether cost for a successful purchase transaction.",
        "url": 340
    },
    {
        "nl_input": "The query requires a function that calculates and returns the bonus percentage applicable during the current ICO stage by checking the ICO state and time against predefined bonus stages. The bonus should adjust based on the current time within the ICO phases, potentially decreasing after certain dates, and reflect the active ICO stage\u2019s bonus rules. The calculation must be dynamic and return the precise bonus value valid at the moment of the query.",
        "url": 341
    },
    {
        "nl_input": "The query requires a function to finalize a crowdsale by halting any further token minting permanently. This involves a mechanism to stop minting forever after the crowdsale ends, ensuring no additional tokens can be created. The process should securely conclude the sale, typically restricted to the contract owner, and emit an event or update a status indicating minting has been finished and the crowdsale finalized.",
        "url": 342
    },
    {
        "nl_input": "The query requires a function enabling users to participate in an airdrop by claiming tokens themselves. The function should include checks for participation limits, timing constraints, and prevent multiple claims per user. It should issue or transfer tokens to the claimant and update participation records to ensure fair distribution during the airdrop stage.",
        "url": 343
    },
    {
        "nl_input": "The query requires a function that returns detailed ELHT token information based on up to 64 provided Token IDs. This includes retrieving token balances or ownership details related to those Token IDs, likely via smart contract calls that interact with ERC20 tokens. The function should handle multiple Token IDs, fetch their corresponding data, and return this information effectively within a single call.",
        "url": 344
    },
    {
        "nl_input": "The query requires a contract where the owner authorizes redemptions in increments of 1/1000 ETH units. This involves an owner-only function that sets allowance amounts measured in thousandths of an ETH unit (milli-ETH) and ensures the contract has sufficient balance before authorization. The contract manages redemption permissions as fractional ETH units, enabling controlled redemption by specified addresses.",
        "url": 345
    },
    {
        "nl_input": "The query requires a smart contract function that allows only the contract owner to transfer ether from the contract to a specified address, such as an upgraded contract. The function should include a check ensuring the transfer amount does not exceed the contract\u2019s ether balance and securely execute the transfer to the target address.",
        "url": 346
    },
    {
        "nl_input": "The query requires an Ethereum smart contract address for an Oracle contract that must implement the OracleInterface. This Oracle contract should facilitate proposals related to oracle data, likely involving fees, balance checks, and events signaling oracle proposals. The contract must support interactions such as submitting oracle data hashes and managing oracle indexes between different parties, ensuring the contract follows the specified interface to enable reliable oracle functionality.",
        "url": 347
    },
    {
        "nl_input": "The query requires creating a trade offer that involves sending a message value (msg.value) greater than zero and some settings as parameters. The function should check that the payable amount and settings are valid before proceeding to create the offer in an internal function.",
        "url": 348
    },
    {
        "nl_input": "The query requires functionality related to checking or managing the balance or count associated with a holder or owner. Specifically, it mentions a variable or function named \"balanceOfOn\" or something similar, which suggests toggling or updating a boolean state related to balance tracking (\"balanceOfOnForHolder\"). The requirement likely involves implementing or calling a function to get the balance of a token holder or updating a boolean flag that enables or disables balance tracking for a holder.",
        "url": 349
    },
    {
        "nl_input": "The query requires functionality to verify the total amount raised in a fundraiser converted to USD. This involves calculating or retrieving the fundraiser's balance and converting or checking it in USD terms, considering exchange rates or conversion methods. The desired code should provide a way to determine the USD value of funds raised, either through direct balance access and conversion or via a function that calculates the fundraising result in USD.",
        "url": 350
    },
    {
        "nl_input": "The query requires functionality to monitor and manage the distribution of rewards from a token pool, specifically tracking the balances of rewards issued. This involves maintaining records of available tokens or rewards allocated to beneficiaries, ensuring accurate deduction from the token pool upon distribution, and updating recipients' reward balances accordingly. The system should enable transparent tracking of outgoing rewards to participants while safeguarding that the token pool balance is properly decremented with each reward disbursed.",
        "url": 351
    },
    {
        "nl_input": "The query requires a function to collect a service or affiliate fee during a purchase transaction. Specifically, it needs to calculate the fee based on the purchase amount, check if the contract balance can cover the fee, transfer the fee to an affiliate's wallet, and return the remaining purchase amount after the fee deduction. The solution must handle safe arithmetic operations and ensure proper fee allocation to the affiliate within the buy process.",
        "url": 352
    },
    {
        "nl_input": "The query requires an internal function that verifies whether transferring a specific token is permitted, considering the sender, recipient, and token ID. It should implement logic to allow or restrict transfers based on predefined conditions or external contract validation, ensuring transfer authorization before execution.",
        "url": 353
    },
    {
        "nl_input": "The query requires overriding the MintableToken's transferFrom function to incorporate KYC (Know Your Customer) verification logic, ensuring that token transfers are only allowed if the sender has passed KYC checks. This involves adding a check to prevent transfers from addresses that require KYC before calling the original transferFrom functionality.",
        "url": 354
    },
    {
        "nl_input": "The query requires functionality to update the address associated with a specific role in a contract. This involves verifying that the caller has the proper authority to make the change, clearing the old address linked to that role, assigning the new address, and updating any related role permissions accordingly. An event should be emitted to signal the address change for transparency and tracking.",
        "url": 355
    },
    {
        "nl_input": "The query requires a smart contract function to withdraw ZRX tokens, allowing only an authorized admin to transfer a specified amount of ZRX. This withdrawal should be triggered specifically if a new contract version is deployed, ensuring that ZRX tokens held by the contract can be safely retrieved and managed during upgrades or replacements.",
        "url": 356
    },
    {
        "nl_input": "The query requires creating a modifier that restricts token transfers until minting is complete. This modifier should check a boolean flag indicating minting completion (e.g., mintingFinished) and only permit transfers once minting has finished, ensuring that no transfers occur before all tokens are minted.",
        "url": 357
    },
    {
        "nl_input": "The query requires a function that allows investors to claim refunds if the fundraising softcap is not met and the token sale period has ended. The function must verify that the sale was unsuccessful, confirm the sale period is over, check the investor\u2019s contributed amount, reset their contribution records, and securely transfer the refunded funds back to the investor. Events or logs should record the refund action for transparency.",
        "url": 358
    },
    {
        "nl_input": "The query requires a function that determines if a contribution period is currently active by returning true or false. The function should check several conditions: the hard cap has not been reached, the contribution period is enabled, the current time is after or equal to the start time, and before the end time. The primary goal is a boolean function indicating whether the contribution period is currently running based on these time and state constraints.",
        "url": 359
    },
    {
        "nl_input": "The query requires an internal function that updates and manages the ICO status based on token availability during various ICO stages. Specifically, it should monitor token balances for stages like PrivateICO, PreICO, ICO week 1, and ICO week 2, and change the ICO status to \"Waiting\" when tokens for a stage are sold out. When all tokens are sold out, the status should be set to \"Closed,\" ensuring automated status transitions as token allocations deplete.",
        "url": 360
    },
    {
        "nl_input": "The query requires a contract function that enables the owner to designate specific addresses authorized to burn tokens. This involves managing a whitelist or mapping where the owner can add addresses permitted to reduce token balances by burning, ensuring controlled and secure token burning privileges.",
        "url": 361
    },
    {
        "nl_input": "Enable a wallet to claim ownership of an account by implementing a function that transfers ownership from a pending owner to the current owner, with conditions such as a valid block number range. This involves verifying eligibility, updating the owner address, resetting pending ownership, and confirming the transfer, ensuring that only the designated pending owner can finalize the ownership claim within a specified timeframe.",
        "url": 362
    },
    {
        "nl_input": "The query requires functionality to purchase a collectible item using cryptocurrency, handling payment processing, fee deductions, and transaction conditions. It involves validating payment amount, managing fees through an affiliate system, ensuring user accounts are active and able to buy, and performing token transfers corresponding to the purchase value. The process should include security checks like account status and sufficient balance to cover fees and costs associated with the collectible purchase.",
        "url": 363
    },
    {
        "nl_input": "The query requires a function that, after an auction ends, returns either the next minimal bid (increment above the highest bid) or the final winning bid if the auction has concluded. This involves determining if the auction is over and then providing the appropriate bid amount\u2014either the final highest bid or the minimum increment needed for a subsequent bid.",
        "url": 364
    },
    {
        "nl_input": "The query requires a function to create promotional narco entities with a restriction on the maximum number that can be created. This limit is enforced by checking counters against predefined creation limits. The function should accept details like genes, name, and owner address, defaulting the owner if unset. It must ensure promo and generation zero creation counts do not exceed their limits before incrementing counts and creating the narco.",
        "url": 365
    },
    {
        "nl_input": "The query requires functionality to modify fundamental ICO parameters such as bonus rates or token supply before or during the ICO phases. This includes changing bonus percentages for pre-ICO or main ICO stages with owner-only access, updating token supply limits prior to the ICO start date, and adjusting token prices based on the ICO phase status. The operations should include validation checks to prevent redundant or invalid changes and emit events to log these updates.",
        "url": 366
    },
    {
        "nl_input": "The query requires a function that allows only the current override address to change the override address to a new one. This function must enforce strict access control, permitting the override address alone to update the override address, ensuring unauthorized entities cannot make this change. The function should also emit an event notifying about the override address update for transparency and tracking purposes.",
        "url": 367
    },
    {
        "nl_input": "The query requires a smart contract function that allows approving multiple token IDs at once. This function should accept an array of token IDs and an address to approve, verify ownership of each token by the sender, set the approval for each token ID to the specified address, and emit an approval event for each token. The functionality enables batch approval to a single address within a non-paused contract state.",
        "url": 368
    },
    {
        "nl_input": "The query requires a method to purchase DOL tokens from a VAULT by sending ETH. The essential functionality involves exchanging ETH for DOL, where the user sends ETH and receives DOL tokens in return, effectively buying DOL from a vault or reserve contract. The implementation should handle the transfer of tokens upon receiving ETH, ensuring the correct amount of DOL is issued or sent to the buyer in exchange for the received ETH.",
        "url": 369
    },
    {
        "nl_input": "The query requires a function executed upon crowdsale completion that transfers any remaining unsold tokens back to a designated wallet. This entails checking finalization conditions, stopping further token minting or sale activity, and ensuring leftover tokens are returned securely to the project's wallet address after the crowdsale ends.",
        "url": 370
    },
    {
        "nl_input": "The query requires initiating a poll with predefined standard parameters, generating a unique pollID, and emitting a PollCreated event that includes this pollID. The poll should have configurable attributes like vote quorum, commit duration, and reveal duration, with timestamps calculated based on the current block time. This setup facilitates a structured voting process with commit and reveal phases, ensuring that the poll creation is recorded transparently on-chain.",
        "url": 371
    },
    {
        "nl_input": "The query requests functionality to set an individual cap for stage 2 investors in a crowdsale contract. Specifically, it needs a function that allows authorized users to define the maximum allocation per investor during the second stage of the crowdfunding process, ensuring individual investment limits are enforced at that stage.",
        "url": 372
    },
    {
        "nl_input": "The query seeks a summary of how to quickly assess seller balances to determine the amount of tokens available for withdrawal. Specifically, it focuses on calculating the possible withdrawal amount by examining the contract's token balance minus outstanding IOUs or commitments, ensuring the logic facilitates identifying withdrawable tokens accurately and efficiently.",
        "url": 373
    },
    {
        "nl_input": "The query requires extracting details specifically related to a price feed mechanism. It involves functions managing price feed data with parameters such as block number, nonce, bid and ask prices, and signature verification. The focus is on updating and validating price feed information securely, ensuring freshness and correctness of the data through checks on nonce order, block number validity, and cryptographic signature verification.",
        "url": 374
    },
    {
        "nl_input": "The query requires a function to set or update a security check report URI within a contract. This involves defining a method that assigns a new URI value to a securityCheckURI variable, ensuring only authorized users (e.g., the contract owner) can perform this update, typically enforced through access control modifiers like onlyOwner. The function primarily deals with managing and storing a security report's reference link or identifier.",
        "url": 375
    },
    {
        "nl_input": "The query requires a function that calculates and returns the number of tokens purchasable with a given weiAmount, potentially including any excess amount. The response should involve token amount computation based on the input wei value, applying relevant rates or tiers, and return the token quantity obtainable for the specified ether value.",
        "url": 376
    },
    {
        "nl_input": "The query requires a function to set the sale status of a specific account by updating a mapping with a given boolean value. The function should accept an account address and a sale status flag, restrict access to authorized users, and ensure the account address is valid before modifying the sale status.",
        "url": 377
    },
    {
        "nl_input": "The query requires a method to compute the Developer's Cut in a game by calculating a specific portion of an input price. The calculation should multiply the input value by a developer cut rate (represented in promille or percentage) and divide by a base unit (1000 or 100) to obtain the developer's share. The method is typically private or internal to the contract and returns the developer's cut as an integer value.",
        "url": 378
    },
    {
        "nl_input": "The query requires adding new methods to the StandardToken contract to enhance its functionality. These methods should include internal functions for minting tokens to an address, safely adding token balances while preventing zero-value transfers and invalid addresses, and possibly calculating token amounts based on Ether input. The focus is on securely handling token creation, balance updates, and token-ether conversion within the token contract.",
        "url": 379
    },
    {
        "nl_input": "The query requires a function or modifier that restricts access, throwing an error if called by any account other than the authorized ones. This involves validating if the caller's address matches an authorized address, such as an owner, depositor, or beneficiary. If the caller is unauthorized, the function should revert with an appropriate message, ensuring that only specific predefined accounts can execute certain contract functions.",
        "url": 380
    },
    {
        "nl_input": "The query requires a function to set the deposit gas cost in a contract. This function should accept a gas cost value as a parameter and assign it to a variable representing the deposit gas cost. Access to this function should be restricted to authorized users only.",
        "url": 381
    },
    {
        "nl_input": "The query requires a function that enables sending a specified value of tokens from the message sender to a recipient address. This involves transferring tokens by invoking a transfer mechanism, followed by notifying the recipient contract through a callback function to handle the received tokens appropriately. The key aspects include using the message sender as the source, specifying recipient and value, and ensuring the recipient contract executes a token fallback or reception function to acknowledge the token transfer.",
        "url": 382
    },
    {
        "nl_input": "The query requires functions that interact with ERC20 token contracts, specifically focusing on token transfers and balance checks. It includes functionality to transfer ERC20 tokens from the contract to the owner and to retrieve the contract's ERC20 token balance, ensuring ownership restrictions for transfers and safe handling of token operations.",
        "url": 383
    },
    {
        "nl_input": "The query requires disabling all token transfer functions in the contract, ensuring no transfers can occur. This involves preventing any transfer logic, such as transfer, transferFrom, or owner-initiated token movements, from executing\u2014effectively locking tokens by disabling or restricting transfer functions. The requirement is to completely block token transfers regardless of conditions or roles.",
        "url": 384
    },
    {
        "nl_input": "The query requires implementing a transfer restriction controlled by a tradingOpen modifier that disables transfers when trading is closed or after December 24, 2017. This means transfers should only be allowed when tradingOpen is true and the current date is before or on 24 Dec 2017, effectively limiting token transfers based on trading status and a specific date. The contract must include functionality to manage and check tradingOpen status and enforce these transfer limits.",
        "url": 385
    },
    {
        "nl_input": "The query requires a modifier that restricts function execution to occur only when funds are not locked. This modifier should check a locked state variable and allow actions only if the funds are unlocked, preventing operations when funds are locked.",
        "url": 386
    },
    {
        "nl_input": "The query requires an internal function that processes Ethereum refunds exclusively during the third stage of a contract. It must enforce that only the owner or a designated receiver can initiate the refund and ensure the refund amount meets a minimum contribution threshold. The function should record the refunded amounts and emit an event logging the recipient and the refunded value.",
        "url": 387
    },
    {
        "nl_input": "The query requires a description of a contract function that allows sending or adding a bonus to a contract. Specifically, it involves a payable function restricted to the contract owner or authorized role, which increments a bonus pool or reward with the sent Ether, ensures limits on the number of bonuses, and allocates or records the bonus amounts relative to total supply or specific keys within the contract state. The primary need is a method for transferring and managing bonus funds within a contract securely.",
        "url": 388
    },
    {
        "nl_input": "The query requires a function that calculates the amount of tokens based on an input amount, typically using a rate or pricing mechanism, returning the token quantity. The calculation may involve multiplications with a rate or price, considering bonuses or internal calculations, and often returns token amounts possibly alongside USD amounts. The function should consistently provide the token amount corresponding to the given input.",
        "url": 389
    },
    {
        "nl_input": "The query requires a smart contract function that allows the contract owner to withdraw ETH stored in the contract. The withdrawal should securely transfer the contract\u2019s entire or specified ether balance from the contract to the owner's or designated addresses, ensuring only authorized access to the withdrawal functionality.",
        "url": 390
    },
    {
        "nl_input": "The query requires functionality to update or upgrade specific contract parameters or permissions, such as changing authorized editors, toggling a balance flag, or setting a minimum contribution threshold. The required code should include controlled access to these update functions (e.g., only editors, owners, or management) and emit events to signal successful updates, ensuring secure and authorized modifications within a smart contract.",
        "url": 391
    },
    {
        "nl_input": "The query requires overriding the token purchase function to send additional tokens to a registered address. This involves customizing the token purchase process to credit extra tokens to a beneficiary or a predefined address during or after the purchase transaction, ensuring the registered address receives more tokens than the standard purchase amount. The implementation must securely handle token distribution beyond the normal purchase logic.",
        "url": 392
    },
    {
        "nl_input": "The query requires obtaining the total token supply as a public unsigned 256-bit integer variable named totalSupply. This totalSupply should reflect the overall amount of tokens available and be accessible through a function or variable with the exact name totalSupply, returning a uint256 type representing the total token count.",
        "url": 393
    },
    {
        "nl_input": "The query requires functionality to manage and update the status of developers, specifically setting or changing a developer's status (active or inactive) by the contract owner, along with emitting an event to signal this change.",
        "url": 394
    },
    {
        "nl_input": "The query requires a function that allows any user to set rabbit attributes (explosive, endurance, nimble) using a signed message from the COO to authorize the update. The function must verify the signature corresponds to the COO\u2019s address, ensure a unique task ID is unused, and only update rabbit data if the rabbit is not in auction. The process includes signature verification, prevention of replay attacks by marking task IDs as used, and emitting an update event upon successful data modification.",
        "url": 395
    },
    {
        "nl_input": "The query requires a function that deposits tokens into a game account for a specific user. It should verify user eligibility or identifiers, ensure valid deposit amounts, update the user's token balance accordingly, and emit appropriate events to record the transaction. The deposit process must securely transfer tokens from the sender to the game or contract, maintaining accurate tracking of token deposits associated with the user.",
        "url": 396
    },
    {
        "nl_input": "The query requires a function to register pre-ICO participant addresses with an associated token price, where setting the pricePerToken to zero disables the pre-ICO for that address. This involves storing each pre-ICO address alongside its specific token price for use during the token sale.",
        "url": 397
    },
    {
        "nl_input": "If the last price update was more than one day ago, the contract should update the price accordingly and record the current time as the price update timestamp. This involves checking the elapsed time since the last update, recalculating buy and sell prices based on daily growth or other parameters, and emitting an event to indicate the price adjustment.",
        "url": 398
    },
    {
        "nl_input": "The query requires a function to freeze multiple user accounts simultaneously by accepting an array of addresses and a freeze status (true/false). The function must be restricted to the contract owner, validate inputs, update each account's frozen state accordingly, and emit an event signaling the change in freeze status for each account.",
        "url": 399
    },
    {
        "nl_input": "The query requires a function that updates the payout amounts for burritos owned by a specific owner. This involves retrieving the owner's burrito tokens, calculating the total payout owed for each based on a payout pool and previously withdrawn amounts, summing the owed amounts, updating each burrito's withdrawn payout, and increasing the owner's overall payout balance accordingly.",
        "url": 400
    },
    {
        "nl_input": "The query requires an admin-restricted function to withdraw the entire PLAT token balance held by the contract. The function should verify that only the owner or admin can execute the withdrawal and should transfer all PLAT tokens from the contract's balance to the caller's address.",
        "url": 401
    },
    {
        "nl_input": "The query requires a function to verify whether all contributors' tokens have been successfully distributed. This involves iterating through all contributors and checking a boolean flag indicating if their tokens were distributed. If any contributor has not received tokens, the function should reflect that distribution is incomplete.",
        "url": 402
    },
    {
        "nl_input": "The query requires retrieving all contributors' unique identifiers in an ordered array. The function should traverse a linked data structure representing contributors, count the total contributors, and return their IDs as an array. If no contributors exist, it should return an empty array. The focus is on providing a complete, iterable list of contributor IDs without additional processing or compensation logic.",
        "url": 403
    },
    {
        "nl_input": "The query requires a function that returns the amount of tokens or funds that a specified spender (_spender) is currently authorized to withdraw from a specified owner\u2019s (_owner) account, typically represented as an allowance or approved balance in a token contract.",
        "url": 404
    },
    {
        "nl_input": "The query requires functionality to calculate and provide the amount of tokens that can be returned or allocated to a user based on certain inputs, such as the amount of ether or tokens they contribute or hold. The solution should enable determining how many tokens a user is entitled to receive and handle the return or allocation of those tokens accordingly.",
        "url": 405
    },
    {
        "nl_input": "The query requires functionality to initiate or start an auction process within a contract. This includes validating conditions before beginning, such as ownership checks or status verification, setting the auction status to active, and possibly recording the auction start event. It may also involve creating auctions with parameters like item ID, starting and ending prices, and duration, ensuring the caller has the right permissions, and handling item escrow or approval before the auction officially starts.",
        "url": 406
    },
    {
        "nl_input": "The query requires functionality to reenable or unfreeze contract operations or accounts after a freeze has been initiated. Specifically, it involves lifting restrictions imposed during a freeze, allowing transfers or actions to resume. The code should include mechanisms to track freeze status, trigger unfreezing by authorized roles, and emit notifications or events indicating the unfreeze action and its conditions.",
        "url": 407
    },
    {
        "nl_input": "The query requires a process or function that marks the completion of a token generation event, ensuring final steps like returning unsold tokens, stopping minting, distributing tokens, forwarding funds, and setting finalization flags are executed securely and only once by authorized parties, typically the contract owner, to conclude the token sale or crowdsale.",
        "url": 408
    },
    {
        "nl_input": "The query requires a function that calculates points for tournament stages including the round of sixteen, quarter-finals, and semifinals. The function should iterate through teams, check their progression in specific rounds, and accumulate points accordingly, such as awarding 60 points per qualifying team. The solution must use round identifiers and team states to determine point allocation based on match results during these middle rounds of a competition.",
        "url": 409
    },
    {
        "nl_input": "The query requires a contract function that transfers all Ether held by the contract to a specified owner address. The function should be callable only by the owner, ensure the entire contract balance is sent, and transfer the full Ether balance directly to the owner's address, effectively reclaiming all stored Ether.",
        "url": 410
    },
    {
        "nl_input": "The query requires a function that sets default parameters for a vesting schedule, including bonus percentage, principle lock percentage, bonus lock period, principle lock period, and early participant price, allowing controlled configuration of vesting terms for whitelisted participants.",
        "url": 411
    },
    {
        "nl_input": "The query requires a contract that holds ETH rewards, where all ETH has been withdrawn by the owner, but the contract still needs to cover gas fees for transaction transfers. The requirement emphasizes the need for functionality allowing the contract owner to withdraw Ether balances while ensuring the contract retains enough ETH to pay transaction costs. The withdrawal function must handle owner-only access and check contract balance before transferring ETH.",
        "url": 412
    },
    {
        "nl_input": "The query requires a burn function that allows the contract owner to burn all tokens they own, reducing the owner's token balance and the total token supply to zero. The function should ensure only the owner can execute it, handle token balance checks, update the total supply accordingly, and emit an event to log the burn action. The burn must apply specifically to all tokens owned by the owner address, effectively eliminating their entire token holdings.",
        "url": 413
    },
    {
        "nl_input": "The query requires utility functions commonly used in smart contracts, such as modifiers to restrict function calls, arithmetic functions ensuring safe operations (e.g., addition with overflow checks), and functions to retrieve contract data like total supply. The focus is on reusable, safe, and controlled coding patterns that enhance contract security and reliability.",
        "url": 414
    },
    {
        "nl_input": "The query requires a function that returns false if the requested purchase amount exceeds the remaining available fuel supply for the current day. Specifically, it should verify that the amount to buy, when added to the fuel already sold, does not surpass the total fuel supply minus any reserved fuel. This ensures that no more fuel can be sold than what is available on that day.",
        "url": 415
    },
    {
        "nl_input": "The query requires a function that, given a round identifier, retrieves the total number of tweets associated with that specific round. This function should accept a round parameter and return a numerical count of tweets recorded for that round.",
        "url": 416
    },
    {
        "nl_input": "The query requires a function to set allowances for spender addresses from owner addresses in a smart contract. This involves managing permissions that allow one address to spend tokens on behalf of another. The desired functionality should support storing and updating these allowances, enabling controlled token transfers approved by the token owners.",
        "url": 417
    },
    {
        "nl_input": "The query requires determining the total supply of the xlmgold token by accessing a smart contract's totalSupply function. This function returns a numeric value representing the total number of tokens issued. The description should focus on identifying and retrieving the total supply variable from the token contract, typically named totalSupply, _totalSupply, or similar, indicating the complete amount of xlmgold tokens available.",
        "url": 418
    },
    {
        "nl_input": "The query requires a time utility function that provides or manipulates time data. Specifically, it seeks functionality to retrieve the current time, set configurable time windows, or define time intervals, enabling time-based operations or constraints within a contract.",
        "url": 419
    },
    {
        "nl_input": "The query requires a function that allows the contract owner or admin to withdraw DGZ tokens specifically to a designated beneficiary address, ensuring conditions like the crowdsale not being closed. The withdrawal should update token sale records and emit an event confirming the transfer of DGZ tokens to the beneficiary.",
        "url": 420
    },
    {
        "nl_input": "The query requires a function that safely adds two unsigned integers x and y, returning their sum. The function must check for integer overflow during addition and throw an exception if overflow occurs, ensuring the operation's safety and correctness.",
        "url": 421
    },
    {
        "nl_input": "The query requires functionality for the contract owner to allocate or manage tokens specifically for a private sale phase. This involves ensuring that tokens are reserved or distributed to private sale participants, typically through controlled token pools and purchase processing during the private sale stage, with proper handling of token amounts and possible refunds. The process should enforce ownership access control and secure token allocation or minting linked to the private sale.",
        "url": 422
    },
    {
        "nl_input": "The query requires a function to preallocate or allocate a portion of tokens considered as liquid, ensuring only authorized users can perform this action, validating token availability before allocation, and updating the balance of allocatable liquid tokens accordingly. This typically involves minting or transferring tokens to a specific address during a pre-sale or allocation phase while enforcing transfer or allocation constraints.",
        "url": 423
    },
    {
        "nl_input": "The query requires a function that returns the total count of Zodiac entities currently existing in the system. It seeks a method that accesses the stored Zodiac data and provides the total supply or number of Zodiacs available at the moment.",
        "url": 424
    },
    {
        "nl_input": "The query requires identifying a contract constructor or an initialization function that sets essential state variables or contract stages during deployment. Specifically, it focuses on functions that establish the contract\u2019s initial conditions or roles, such as owner-only initialization, enabling contribution periods, or setting distributor permissions to configure the contract's operational state right after deployment.",
        "url": 425
    },
    {
        "nl_input": "The query requires functionality used in transport, challenge, and training contexts to obtain the genes of a specific hero. If the user does not own any hero, the system should automatically claim a new hero for them. This involves checking the user's hero balance, claiming a hero if none exist, and retrieving the hero's genetic information. The focus is on ensuring ownership or acquisition of a hero and accessing their genes for further use.",
        "url": 426
    },
    {
        "nl_input": "The query requires a function to set or update a transform agent by the contract owner, ensuring the agent address is valid and checking specific conditions before assignment. The function should prevent setting the agent during certain states, verify the new agent's compliance via multiple require checks, and emit an event upon successful update.",
        "url": 427
    },
    {
        "nl_input": "The query requires a function that allows the contract owner to withdraw all Ether held by the contract in one transaction. The function should transfer the entire contract balance to the owner's address, ensuring complete withdrawal of ether without specifying an amount parameter. Access should be restricted to the owner only for security.",
        "url": 428
    },
    {
        "nl_input": "The query requires functionality to mint Kin tokens, specifically involving creating new tokens and assigning them to a specified address. This includes verifying the recipient address is valid, increasing their token balance, and emitting a transfer event from the zero address to indicate token creation. The core need is a mint function that securely generates and allocates new Kin tokens to a user.",
        "url": 429
    },
    {
        "nl_input": "The query requires a function that executes periodic subscription payments by verifying sender permissions, checking if the subscription is chargeable, processing payment transfers, updating payment periods and execution counters, and confirming successful execution with the service provider. It should handle errors appropriately and prevent reentrancy.",
        "url": 430
    },
    {
        "nl_input": "The query requires a function accessible by users and token holders that can verify if Trump is currently president. This function should be callable by different roles and return a status indicating Trump's presidency.",
        "url": 431
    },
    {
        "nl_input": "The query requires implementing an access control mechanism that restricts function execution exclusively to a specific burnable account. If any other account attempts to call the function, the contract should revert the transaction with an error. This ensures that only the designated burn address can perform certain operations, enhancing security by preventing unauthorized calls from other accounts.",
        "url": 432
    },
    {
        "nl_input": "The query requires a function that checks if an early purchase has been amended by verifying whether a given early purchase index exists within a list of amended early purchase indexes. This involves confirming the purchase index is valid and searching through amended indexes to return a true or false result indicating amendment status.",
        "url": 433
    },
    {
        "nl_input": "The query requires a function that changes the visibility status of a document, specifically marking a document identified by its ID as visible. This involves modifying a flag or state variable associated with the document's invisibility, ensuring only authorized users can perform this action, and potentially emitting an event to signal the change.",
        "url": 434
    },
    {
        "nl_input": "The query requires a function that returns the current round of a process or event. This function should identify and provide details about the ongoing round based on defined criteria, such as token sales thresholds or internal round states, allowing retrieval of the current round's information as a structured data type or reference.",
        "url": 435
    },
    {
        "nl_input": "The query describes a function that updates the status of a given listingHash. It changes the status from 'application' to 'listing' if the listing can be whitelisted. If there is an existing challenge related to the listingHash, it resolves the challenge instead. If neither condition is met, the function reverts the transaction. The focus is on managing listing status transitions and challenge resolution based on specific conditions associated with the listingHash.",
        "url": 436
    },
    {
        "nl_input": "The query requires implementing a refund poll mechanism that allows checking if the current time falls within specified refund poll dates or a defined second refund poll date, enabling refunds during those periods. This includes managing refund availability based on time windows and ensuring that users can claim their refunds if conditions are met. The solution should handle date comparisons, maintain refund eligibility periods, and enable secure refund withdrawals for eligible participants during these polls.",
        "url": 437
    },
    {
        "nl_input": "The query requires a description of a minting function that allows the creation of new tokens. The function typically includes checks such as ownership restrictions, preventing minting to the zero address, and ensuring the total supply limits are not exceeded. It should update balances or token ownership, adjust total supply accordingly, and emit relevant events like Mint and Transfer to signal token creation and assignation. Additionally, some implementations may include a function to finish or stop minting after a certain point.",
        "url": 438
    },
    {
        "nl_input": "The query requires a function to transfer tokens between addresses that also verifies if there are dividend payments to be made. This involves checking token balances, adjusting the balances upon transfer, and ensuring any owed dividends are accounted for and paid during the transfer process. The solution should integrate token transfer mechanics with dividend distribution logic to handle both token movement and dividend payout validations seamlessly.",
        "url": 439
    },
    {
        "nl_input": "The query requires a function or mechanism that refunds the invested funds back to the investor after a condition such as an unsuccessful sale or authorized refund is met. The refund should reset the investor's contribution record, transfer the invested amount back to the investor\u2019s address, and may involve handling multiple investors or checking for refund eligibility. The process should be secure, prevent double refunds, and ideally be callable by authorized parties or the contract owner.",
        "url": 440
    },
    {
        "nl_input": "The query requires a function to set a KYC (Know Your Customer) contribution cap for a specific address, defining different caps based on the KYC level assigned to that address. The function should update the contribution limit according to the user's KYC tier, with higher levels granting higher caps, and the cap values may depend on exchange rates or fixed amounts. Only authorized personnel should be able to set or modify these contribution caps.",
        "url": 441
    },
    {
        "nl_input": "The query requires a function that returns the current exchange rate of LNC tokens per Ether. The solution should provide a read-only method to retrieve the current rate or exchange rate value used in the contract, reflecting how much one Ether is worth in LNC tokens at the present moment.",
        "url": 442
    },
    {
        "nl_input": "The query requires functionality to update the minimum contribution amount necessary for participation. This involves a controlled function that allows authorized users to set a new minimum contribution value, ensuring the value is positive and changing the contract's stored minimum contribution accordingly, often with an event emitted to signal the update.",
        "url": 443
    },
    {
        "nl_input": "The query requires a method enabling manual transfer of tokens to a specified address. This function must include permission checks to restrict access (e.g., whitelisting and privileged roles), validate that the token amount is positive, and conditionally handle transfers during different sale phases (pre-ICO or ICO) ensuring remaining token availability. It should update purchase records accordingly and revert the transaction if conditions are not met.",
        "url": 444
    },
    {
        "nl_input": "The query requires a function to determine the total number of voters who have voted for a specific proposal, identified by a proposal ID or key. The solution should access a data structure mapping proposals to voter counts and return the count of voters who participated in voting for that given proposal.",
        "url": 445
    },
    {
        "nl_input": "The query requires a function that adds a user\u2019s address to a list of participants, ensuring the address is only added if it is not already present. The method should check for duplicates before appending the user to the participants array or list, effectively managing participation without redundancy.",
        "url": 446
    },
    {
        "nl_input": "The query requires functionality to revoke or deauthorize an entity that has issuing authority, typically by the contract owner. This involves removing the issuer's address from a maintained list or mapping, effectively disabling their issuing rights. The process should include permission checks to ensure only authorized users can perform this action and optionally emit an event or log to record the removal.",
        "url": 447
    },
    {
        "nl_input": "The query requires calculating the number of tokens that have not yet vested at a specific point in time. This involves determining the total granted tokens and subtracting the amount that has already vested up to the given timestamp, resulting in the remaining non-vested token balance. The function should take into account the grant details and the current time to produce an accurate non-vested token amount.",
        "url": 448
    },
    {
        "nl_input": "The query requires initializing an array of vesting stages, each with specific unlock dates and corresponding token release percentages. It should set multiple stages relative to a start timestamp, assigning incremental dates and defining increasing token unlock percentages for each stage, thereby structuring the timeline and amount of tokens vested at each vesting milestone.",
        "url": 449
    },
    {
        "nl_input": "The query requires a smart contract function that facilitates the purchase of tokens by sending Ether. It should accept Ether payments, verify transaction validity (e.g., minimum amount and valid addresses), calculate the number of tokens based on the Ether sent and a rate or token price, issue or transfer tokens to the buyer's address, and securely forward the received Ether to a designated wallet or beneficiary address. The function must handle token issuance and Ether transfer atomically within the purchase process.",
        "url": 450
    },
    {
        "nl_input": "The query requires a method to obtain the number of contributors for all campaigns by retrieving and counting contributor identifiers. The solution should efficiently access contributor data, track the total count, and return an array or list representing all contributors involved in the campaigns.",
        "url": 451
    },
    {
        "nl_input": "The query requires a function that facilitates the selling of tokens during a crowdfunding period. This function should handle token transfers between investors and the contract, enforce timing or ownership restrictions related to the crowd time, ensure proper token supply management, and process payments corresponding to token sales. It should update relevant balances and emit necessary events to track the sale within the crowd sale context.",
        "url": 452
    },
    {
        "nl_input": "The query requires a function that verifies if the recipient address for token transfer is valid by ensuring it is not the zero address and not the token contract's own address. This validation prevents sending tokens to an invalid or the token contract address itself, which could lead to token loss or unintended behavior. The function should include checks rejecting zero or token address destinations before proceeding with the token transfer.",
        "url": 453
    },
    {
        "nl_input": "The query requires adding an address with administrative privileges that can manage the token contract even when the contract is paused. This involves implementing a function to assign such an administrator, ensuring the administrator role has permission to perform token administration regardless of the contract's paused state. The added administrator should be distinct from the owner and prevent conflicts with other roles, enabling critical token operations during paused conditions.",
        "url": 454
    },
    {
        "nl_input": "The query requires a function that can accept either an address or bytes32 input types directly without manual casting by the user. It should handle both types seamlessly, enabling easy extraction or usage of these types from given data. The solution should simplify user input by automatically recognizing and processing address and bytes32 values, removing the need for explicit type conversion in the interface.",
        "url": 455
    },
    {
        "nl_input": "The query requires adding a private function named \"addFee\" that manages fees by either setting or incrementing the fee amount for a given address. This function should be private, ensuring it is only accessible within the contract, and it should update a mapping or storage structure that keeps track of each address's fee.",
        "url": 456
    },
    {
        "nl_input": "The query requires implementing re-entry protection in smart contract functions to prevent multiple, nested calls that could lead to vulnerabilities such as unauthorized fund withdrawals. This involves ensuring that sensitive operations like ether transfers or state changes are guarded against recursive calls, typically by using mechanisms like mutexes or checks that block re-entrant entry during execution.",
        "url": 457
    },
    {
        "nl_input": "The query requires a function that filters a list of buyer addresses based on a given condition, such as whether they are approved investors or not. The function should iterate through the buyers, check each against a specific criterion, and return a new list containing only the buyers that meet the condition. This involves creating a temporary array, counting qualifying buyers, and producing a filtered array without empty or null entries.",
        "url": 458
    },
    {
        "nl_input": "The query requires identifying usage of inherited Solidity function modifiers, particularly focusing on the \"onlyOwner\" modifier pattern that restricts function access to the contract owner. The code should demonstrate the definition of the onlyOwner modifier with a require statement validating the caller's ownership and allowing modifier inheritance across contracts. The intent is to verify correct implementation of access control via inherited modifiers consistent with Solidity documentation on function modifiers.",
        "url": 459
    },
    {
        "nl_input": "The query requires a smart contract function that sets the variable \"paused\" to false. This function should include access control, allowing only authorized roles (such as \"onlyManager\" or \"onlyOwner\") to execute it. Additionally, the function should be callable only when the contract is currently paused (\"whenPaused\"). Emitting an event upon unpausing is optional but desirable to signal the state change.",
        "url": 460
    },
    {
        "nl_input": "The query requires functionality related to managing token release timing and conditions. It involves ensuring tokens are not released before a specified time, tracking released token amounts for specific addresses, and providing a mechanism to release tokens for a team or group once release conditions are met. The system should include checks to enforce release dates, methods to retrieve released token balances, and functions to trigger token release actions.",
        "url": 461
    },
    {
        "nl_input": "The query requires a function that, given an owner and a spender, returns the amount of ACE Equity Tokens the spender is permitted to spend on behalf of the owner. This involves checking a stored allowance mapping or similar data structure that tracks approved spend limits between owners and spenders, typically via a publicly accessible view or constant function.",
        "url": 462
    },
    {
        "nl_input": "The query requires a function or mechanism that, after distributing bonus tokens, returns or reallocates those bonus tokens back to the original coin or token contract itself. This involves handling bonus token allocation during token transfers or sales and ensuring the ability to send or send back the bonus tokens to the main token contract or source after distribution.",
        "url": 463
    },
    {
        "nl_input": "The query requires a function that returns the balance of a specified account address. The function should accept an address parameter and provide a view or constant method to retrieve the corresponding balance value from a stored balances mapping or variable. The focus is on reading and returning the current token or fund balance associated with the given address without modifying the contract's state.",
        "url": 464
    },
    {
        "nl_input": "The query requires a function that enables a user to claim ownership of a specified unicorn ID by verifying their allowance and then transferring ownership from the current owner to the caller. The function should include checks to ensure the caller has permission and handle the transfer process securely.",
        "url": 465
    },
    {
        "nl_input": "The query requires functionality to handle redemption operations both when the contract is paused and unpaused. It involves managing a paused state with the ability to unpause the contract conditionally, triggering appropriate events or state changes. The contract should include mechanisms to check the paused status and control the unpause process securely, ensuring redemption logic works seamlessly regardless of the contract\u2019s paused state.",
        "url": 466
    },
    {
        "nl_input": "The query requires a function that enables the contract owner to transfer advisor tokens to a specified advisor wallet. This function must ensure tokens are granted only once after a certain time lock has passed, verify that advisor tokens are available, and support multiple scheduled vesting periods. The function should mint tokens to the advisor's wallet address, update the vesting status, extend the time lock for subsequent grants, and eventually stop further grants after all tokens are distributed.",
        "url": 467
    },
    {
        "nl_input": "The query requires a function that enables only the contract owner to transfer ERC20 tokens held by the contract to a designated multisignature vault address, ensuring secure token retrieval and transfer control.",
        "url": 468
    },
    {
        "nl_input": "The query requires a function that combines approving token transfer and invoking another contract in a single step. This function should allow a token owner to authorize a transfer to a specified address and subsequently trigger a call to a separate contract within one operation, streamlining token approval and inter-contract interaction.",
        "url": 469
    },
    {
        "nl_input": "The query requires a function to transfer ownership of another contract, where the current contract is the owner, to a new specified address. This involves invoking the transferOwnership method on the target contract owned by the current contract, ensuring only the current owner can initiate the transfer. The function must accept the target contract address and the new owner's address as parameters to execute the ownership change securely.",
        "url": 470
    },
    {
        "nl_input": "The query requires a function that, given an Ethereum address, returns a list of token IDs owned by that address. This involves accessing a mapping or data structure that associates an owner's address with their token IDs and providing a public view function to retrieve this list. The function should directly return the array of token IDs owned by the specified address.",
        "url": 471
    },
    {
        "nl_input": "The query requires modifications where the functions endCrowdsale() and endCrowdsalePublic() are relocated from their original contract to the Steak contract. This implies changing their implementation to be part of the Steak contract rather than their current contract, likely to consolidate crowd sale finalization logic within the Steak contract.",
        "url": 472
    },
    {
        "nl_input": "The query requires calculating the number of tokens corresponding to a given amount of wei. It involves implementing a function that takes wei as input and returns the token quantity by applying a conversion rate or formula, potentially including tiered rates or additional calculations such as adjusting by a rate factor. The output is the token amount derived directly from the wei amount, reflecting the conversion logic from ether value to tokens.",
        "url": 473
    },
    {
        "nl_input": "The query requires a function that allows the token owner, after completing required operations, to rename the token by updating its name and symbol. Additionally, it should guide users to interact with the token contract, ensuring only the owner can perform these updates and that the changes are tracked or emitted as events.",
        "url": 474
    },
    {
        "nl_input": "The query requires a function to enable purchasing option tokens using a specified token address. It should facilitate buying options or tokens by interacting with different token types or phases, validating conditions like available supply and purchase limits. The function must handle the transaction process, update balances, and ensure compliance with sale phases or supply constraints, enabling users to buy option tokens directly with tokens or currency, reflecting the purchase in contract state.",
        "url": 475
    },
    {
        "nl_input": "Calculates the fund manager's unclaimed fees by determining management and performance fees based on the elapsed time, the fund's gross asset value (GAV), and share price gains. It computes management fees proportionally to time and GAV, then calculates performance fees if the share price exceeds a previous high-water mark. The total unclaimed fees equal the sum of management and performance fees, reflecting the fund manager's earnings not yet claimed.",
        "url": 476
    },
    {
        "nl_input": "The query requires a trading restriction feature that enforces a minimum waiting period of three weeks after a sale has closed before trading can commence. This means implementing logic to track when a sale closes and ensuring that trading cannot open until at least three weeks have elapsed since that closure. The requirement focuses on time-based gating of trading activities following sale closure.",
        "url": 477
    },
    {
        "nl_input": "The query requires a function that enables purchasing soldiers by specifying an army ID and the number of soldiers to buy. The function should accept payment, verify the payment amount matches predefined prices for different soldier counts (1, 10, 100, 1000), and increase the soldier count in the specified army accordingly. The purchase must ensure a positive payment and adjust the army's soldier count based on the amount paid and soldiers bought.",
        "url": 478
    },
    {
        "nl_input": "The query requires a function that allows only the contract owner to add a new minter by specifying their address. The function must ensure the address is valid (non-zero) and not already a minter, then add it to the minters list, enabling minting permissions. It should return a boolean indicating success.",
        "url": 479
    },
    {
        "nl_input": "The query requires initiating a token distribution phase within a contract, allowing token owners to claim their allocated tokens. This involves activating the distribution by verifying whitelist status, ensuring no active distribution, checking minimum balance requirements, recording the distribution details, and emitting an event to signal the start. The focus is on securely managing and tracking the distribution process so owners can subsequently claim their tokens.",
        "url": 480
    },
    {
        "nl_input": "The query requires an internal function that removes a specific deed ID from the list associated with a given address. This function must verify ownership of the deed by the address, locate the deed's index in the owner's list, update the list by replacing the removed deed with the last deed in the list, adjust indices accordingly, clear ownership and indexing references for the removed deed, decrease the owner's deed list length, and decrement the total count of deeds.",
        "url": 481
    },
    {
        "nl_input": "The query requires a function that returns the sender's share balance. The function should be a public or external view method that retrieves and returns the balance, profit share, or shares associated with the caller's address (msg.sender). Additionally, it may include conditions to ensure the contract is in a valid state before returning the balance. The key focus is on accessing and returning the share or balance of the message sender.",
        "url": 482
    },
    {
        "nl_input": "The query requires a function that reveals the properties of a bid in an auction setting. Specifically, it involves submitting or revealing a sealed bid, validating it against auction states and timing constraints, updating highest and secondary bids accordingly, handling refunds or closing bids, and emitting events to indicate the bid reveal status and outcome. The function should manage bid values securely, ensure proper auction state transitions, and provide transparent bid reveal information.",
        "url": 483
    },
    {
        "nl_input": "The query requires a function that allows the contract owner to securely add a new Sale wallet address for holding funds. This function should restrict access to the owner, validate the provided wallet address to prevent zero addresses, and store the new Sale wallet in a list to manage funds safely.",
        "url": 484
    },
    {
        "nl_input": "The query requires a Solidity modifier that restricts function execution exclusively to a specified Contractor address, ensuring only the Contractor (identified by an address parameter) can call the protected function. This modifier performs a check comparing the caller's address (msg.sender) with the Contractor's address and reverts if they do not match, thus enforcing strict access control limited to the Contractor.",
        "url": 485
    },
    {
        "nl_input": "The query requires a function that transfers or releases tokens which are locked, specifically moving them to a designated team account or team timelock. The solution should involve a mechanism to unlock or release the tokens that were previously restricted, ensuring that the tokens become accessible or transferred to the team\u2019s control securely.",
        "url": 486
    },
    {
        "nl_input": "The query requires modifying the hasEnded function to accurately reflect the state when all tokens have been sold, meaning the function should return true not only when the sale period has expired but also when no tokens remain available for purchase.",
        "url": 487
    },
    {
        "nl_input": "The query requires a function named \"name\" that returns the token's name as a string. The function should be publicly accessible, view-only (does not modify state), and return a single string value representing the token's name. This function is expected to provide the token name directly without additional token details or types.",
        "url": 488
    },
    {
        "nl_input": "The query requires a function to set or update the current exchange rate between ETH and USD or a related pricing rate. This function should securely adjust the token price or rate based on an input value, ideally restricted to the contract owner. It involves updating a rate variable that defines how many tokens equal one ETH or sets the price rate per wei, ensuring the contract reflects the current ETH/USD valuation.",
        "url": 489
    },
    {
        "nl_input": "The query requests a description of a SafeMath divide function that safely performs division with validation. The function should take two unsigned integers, ensure the divisor is greater than zero, and return the quotient. It must include a check or assertion to prevent division by zero errors, providing a secure way to divide numbers in smart contracts.",
        "url": 490
    },
    {
        "nl_input": "The query requires functionality to distribute or claim tokens to multiple recipients as part of an airdrop. This involves transferring specified token amounts from a source to a list of destination addresses, ensuring eligibility and participation limits, and controlling timing or conditions under which tokens can be claimed or withdrawn during an airdrop event.",
        "url": 491
    },
    {
        "nl_input": "The query requires a function to refund Ether to investors, ensuring the refund is initiated only through the token contract. The refund should be allowed after the ICO ends or sale conditions fail and must securely transfer the contributed Ether back to each investor, adjusting their contributed amounts and token balances accordingly. The process should be restricted to authorized callers, typically the token contract owner or an allowed entity, and ensure proper state updates to prevent re-entrancy or double refunds.",
        "url": 492
    },
    {
        "nl_input": "The query requires a smart contract function that enables batch transferring of Ether (ETH) to multiple addresses in a single transaction. It should accept an array of addresses, ensure the array is not empty, and distribute the total Ether sent with the transaction evenly among the addresses. The function must handle the division of the sent Ether amount to properly send a proportional share to each recipient.",
        "url": 493
    },
    {
        "nl_input": "The query requires a smart contract function that allows the current owner to propose a change of ownership by specifying a new owner address. The function should be restricted to be callable only by the current owner and should record or emit an event indicating that an ownership change has been proposed or requested. This enables a two-step ownership transfer process where the owner first proposes a new owner address.",
        "url": 494
    },
    {
        "nl_input": "The query requests an interface declaration in a smart contract context, specifically defining a contract interface type and a function to set or update the address of this interface. This includes a function that assigns a new address to an interface variable (e.g., BLInterface) restricted by an ownership modifier. The focus is on establishing or updating a link to an external contract through an interface reference within the contract.",
        "url": 495
    },
    {
        "nl_input": "The query requires functionality to cancel or reduce reserved tokens for a specified wallet address, ensuring valid parameters, ownership authorization, and that the cancellation occurs before a defined end condition. This involves decreasing the total reserved tokens and updating the reserved amount for the wallet, while emitting an event to log the cancellation.",
        "url": 496
    },
    {
        "nl_input": "The query requires extracting functions guarded by an \"onlyOwner\" modifier, which restricts access to the contract owner. This modifier enforces that only the owner can execute certain functions by checking if the caller's address matches the owner's address before proceeding with function execution. The focus is on identifying and describing functions that implement this ownership access control to ensure only authorized actions by the contract owner.",
        "url": 497
    },
    {
        "nl_input": "The query requires functionality for transferring tokens between addresses. This includes securely debiting tokens from a sender\u2019s balance, updating allowances, crediting the recipient\u2019s balance, and emitting transfer events. Additional checks may involve owner restrictions, transfer limits, and preventing transfers involving certain flagged accounts. The focus is on ensuring proper token balance updates, access control, and successful, verifiable token transfers on the blockchain.",
        "url": 498
    },
    {
        "nl_input": "The query requires a function named approve that enables a token holder to authorize another address to spend a specified amount of tokens on their behalf. This function should update the allowance mapping to set the spender's allowed amount, emit an Approval event signaling the approval, and return a boolean indicating success. Additional constraints like access control or checks on allowance resetting may be included.",
        "url": 499
    },
    {
        "nl_input": "The query requires a mechanism to return funds directly to the curator, typically by allowing only the curator to trigger a refund or clawback function that transfers the contract's balance back to them. The function must restrict access to the curator and securely send the entire balance to their address, ensuring funds are returned if necessary.",
        "url": 500
    },
    {
        "nl_input": "The query requires managing contract states without running code in the constructor. Specifically, it needs functions to control contract stages: pausing/unpausing by a manager, starting a contribution phase only by the owner at a defined setup stage, and checking if the contract's start block has been reached. This allows manual progression through contract states and checks that rely on block number, ensuring state transitions are explicit and not automatic during deployment.",
        "url": 501
    },
    {
        "nl_input": "The query requires a function that transfers token balances from the current contract or sender to a specified recipient address. It should securely deduct the token amount from the sender\u2019s balance, add it to the recipient\u2019s balance, and emit a transfer event to log the transaction. Additionally, the solution must include checks to prevent invalid transfers, such as zero address recipients or insufficient balances, ensuring the token transfer is completed correctly and securely.",
        "url": 502
    },
    {
        "nl_input": "The query requires a function to deposit wei (the smallest Ether unit) into an exchange contract, effectively transferring Ether to the contract. This involves handling a payable function that accepts wei, updates balances accordingly, and possibly emits an event for logging the deposit transaction. The function should enable users to send Ether directly to the exchange contract, increasing their invested or deposited amount in wei.",
        "url": 503
    },
    {
        "nl_input": "The query requires verification that terms and conditions have been acknowledged by the user. This involves proving that the user has read and understood the terms through a cryptographic signature process, specifically by validating a signed message using the ecrecover function to confirm the user's agreement on the terms and conditions document.",
        "url": 504
    },
    {
        "nl_input": "The query requires a smart contract function that manages the sale of tokens with varying pricing tiers based on the number of tokens sold. It should enforce purchase limits (minimum 1, maximum 10 tokens), check sale timing and token availability, calculate the total price using different step increments for distinct sale phases, update token balances and prices accordingly, track total tokens sold and funds raised, and refund any excess payment to the buyer, ensuring secure and dynamic token sale management.\n\nTokens left: 292",
        "url": 505
    },
    {
        "nl_input": "The query requires a contract function that enables transferring tokens on behalf of another address using the transferFrom() method. This function must deduct tokens from the sender's allowance, update the recipient's balance accordingly, and emit a transfer event to log the transaction. Additionally, it should ensure the managing of allowed token allowances for the involved addresses to permit secure delegated token transfers.",
        "url": 506
    },
    {
        "nl_input": "The query requires a smart contract function that allows users to sell a specified amount of tokens or keys by transferring them to the contract in exchange for payment. The function must verify that the contract has sufficient balance to pay the seller based on a sell price, securely transfer the tokens from the seller to the contract, and then transfer the corresponding funds to the seller's address.",
        "url": 507
    },
    {
        "nl_input": "The query requires a function that, given a parent address, returns the corresponding child address. This involves interacting with an external contract (at a specific address) that implements the function returnChildAddressForParent(address). The required function should accept a parent address as input and invoke the external contract's method to obtain and return the associated child address.",
        "url": 508
    },
    {
        "nl_input": "The query requires a description of a function modifier that enforces a condition allowing everyone to call a function, without restrictions. It specifically demands a modifier ensuring the function is callable by all users, typically by checking that any disabling condition is not active, thus permitting universal access.",
        "url": 509
    },
    {
        "nl_input": "The query requires checking and handling rewards within a contract, specifically focusing on distributing rewards to owners, ensuring reward amounts are valid and capped by available balances or limits, and updating the total reward pool. The key needs include verifying reward amounts are positive, properly deducting from manufacturer pools, adding to owner rewards, and maintaining a capped or updated reward balance.",
        "url": 510
    },
    {
        "nl_input": "The query requires a function that verifies the validity of a sale by checking specific parameters. It should evaluate whether the sale type matches predefined criteria (e.g., FixedPrice) and confirm that the sale's expiration time is acceptable (e.g., greater than zero). The function must ensure that the sale parameters meet these conditions to be considered valid.",
        "url": 511
    },
    {
        "nl_input": "The query requires a function that internally checks if a given rate falls within predefined minimum and maximum limits, returning a boolean result. It should perform a validation to confirm that the rate is within acceptable boundaries without altering state or being externally accessible.",
        "url": 512
    },
    {
        "nl_input": "The query requires a function that returns the number of tokens or balance owned by a specific owner address. This function should take an owner address as input and output a uint256 or uint value representing the token count or balance associated with that owner. It should be publicly accessible and allow viewing the ownership token count without modifying the contract state.",
        "url": 513
    },
    {
        "nl_input": "Checks if one numeric value is greater than or equal to another, returning a boolean result indicating this comparison.",
        "url": 514
    },
    {
        "nl_input": "The query requires a function that allows the contract owner to receive or claim a financial benefit or funds. It involves verifying available benefit funds, transferring these funds to the owner\u2019s address, updating the contract\u2019s internal accounting to reflect the transfer, and ensuring the contract's balance remains consistent after the operation. The function must restrict access to the owner only.",
        "url": 515
    },
    {
        "nl_input": "The query requires a function to log diary entries with a timestamp representing the current time. The diary log should include the time the entry was made and the diary content, capturing the current timestamp at the moment of logging.",
        "url": 516
    },
    {
        "nl_input": "The query requires functionality to remove or burn specified token values between 120 and 123, reducing the user's balance and total supply accordingly. The operation should verify the user has sufficient balance before burning, adjust balances and total supply by subtracting the burned amount, and potentially emit events logging the burn action. The code should ensure secure, validated burning of token amounts within the specified range.",
        "url": 517
    },
    {
        "nl_input": "The query requires a function to set a monetary rate or fee described in terms of \"card,\" \"watt,\" and \"month,\" specifically allowing the setting of an amount per month. The function should be restricted to authorized users (e.g., onlyOwner), enabling them to define a payment or rate in fixed units per month, such as setting cents or currency units monthly. This involves updating a value representing cost or rate for a recurring monthly charge.",
        "url": 518
    },
    {
        "nl_input": "The query requires a function to approve the removal of an owner, callable only by existing owners, ensuring the removal request hasn't been called or executed before. It must validate sufficient approvals, prevent duplicate confirmations by the same owner, confirm the request is active within its lifetime, and upon reaching the needed approvals, mark the removal as executed and update ownership status accordingly.",
        "url": 519
    },
    {
        "nl_input": "The query requires functionality in a smart contract that enables returning invested funds to contributors if the ICO does not meet its success criteria, such as a minimum fundraising goal or token sale threshold. It involves verifying ICO failure conditions, ensuring only eligible investors can claim refunds, resetting their balances, and securely transferring their invested amounts back. The contract should include proper access controls and event logging to track the refund process.",
        "url": 520
    },
    {
        "nl_input": "The query involves a scenario where a user loses their Ether permanently but receives a consolation prize. The relevant code should handle prize withdrawal or consolation payouts after a certain condition, such as finishing a points validation state, and the prize amount is calculated and transferred to the user. The contract should track user-owned tokens and assign payouts accordingly, ensuring users can claim a prize even if their original Ether is lost.",
        "url": 521
    },
    {
        "nl_input": "The query requires determining the maximum amount of investments accepted during a token sale, expressed in wei. It seeks a function or method that returns or enforces a cap on the total wei contributions permitted for purchasing tokens within the sale contract, ensuring investments do not exceed a predefined maximum limit.",
        "url": 522
    },
    {
        "nl_input": "The query requires a function that transfers a tulip token to another address without requiring the recipient's confirmation. It must include checks to prevent transferring to the zero address or the contract itself and verify that the sender owns the tulip. The function should then execute the transfer immediately, ensuring that no additional approval or confirmation steps are needed from the recipient.",
        "url": 523
    },
    {
        "nl_input": "The query requires a function modifier that restricts function execution until after a specified vesting period has elapsed. This means the function can only be called when the current time exceeds or equals a defined vesting end time, ensuring tokens or assets are released only after the vesting schedule completes.",
        "url": 524
    },
    {
        "nl_input": "The query requires a function that accepts only two specific input values: 0.1 ether and 1 ether. The function should handle these exact ether amounts to determine a token amount or rate, rejecting any other ether values outside these.",
        "url": 525
    },
    {
        "nl_input": "The query requires a function that distributes bankroll funds as additional dividends to users. This involves verifying dividend shares, calculating the amount based on users' share proportions, ensuring sufficient contract balance, updating dividend shares and funds, and transferring the calculated dividend amount to the user. The process includes recording the withdrawal event and properly managing internal dividend accounting to reflect the disbursed dividends.",
        "url": 526
    },
    {
        "nl_input": "The query requires a function that allows a caller to approve token transfers only if the caller owns the tokens and has a sufficient token balance or allowance to do so. This means the function must verify the caller's ownership of the tokens and check that the caller\u2019s account holds enough tokens before granting approval to another address to manage or transfer those tokens.",
        "url": 527
    },
    {
        "nl_input": "The query requires a function that allows only the owner wallet to change the token rate. This function should include an access restriction ensuring only the owner can call it and must update a variable representing the token-to-ether rate, with validation checks such as requiring the new rate to be positive.",
        "url": 528
    },
    {
        "nl_input": "The query requires a function that distributes ERC20 tokens to multiple holders based on predefined ratios. The distribution should ensure tokens are allocated proportional to each holder's ratio relative to a coefficient, prevent multiple distributions, and emit an event upon completion. The function must calculate each holder's token amount from a target total supply and transfer tokens accordingly.",
        "url": 529
    },
    {
        "nl_input": "The query requires a function to transfer tokens from a specified address to the owner's address. The function should handle token transfers securely, ensuring valid amounts and authorization, and updating balances accordingly. It should allow only authorized parties\u2014preferably the contract owner\u2014to initiate the transfer. The implementation must include checks to prevent unauthorized or invalid transfers and update token ownership or balances as needed.",
        "url": 530
    },
    {
        "nl_input": "The query requires a function that allows a user to bet on a specific number in a gambling or casino context. It should accept a number between 0 and 36 and a bet amount within specified limits. The function must validate the bet amount and number, ensure the casino has sufficient funds, generate a random number, compare it with the user's chosen number, and pay out winnings at 36 times the bet if the user wins, otherwise retain the bet amount for the casino.",
        "url": 531
    },
    {
        "nl_input": "The query requires a mechanism to manually refund bets if the external Oraclize callback is not received, indicating a failure in the random number generation or oracle response. The solution should verify the callback origin, check bet validity and state, handle errors from Oraclize, and include a refund process to return wagered funds to players when the callback or verification fails. The refund should address scenarios where randomness or oracle data is missing, ensuring no losses due to oracle issues.",
        "url": 532
    },
    {
        "nl_input": "The query requires a function to set a verification slashing period with controlled access, ensuring the new period plus an existing verification period does not exceed a certain limit (256). The function must update the verification slashing period and trigger a parameter update event. This involves validating input, restricting execution to an authorized controller owner, and safely modifying the verification slashing period parameter.",
        "url": 533
    },
    {
        "nl_input": "The query requires a function to set a time lock on a specified allocation address by assigning a timestamp until which the address is locked. It involves checking that the address is valid (non-zero) and the timelock date is in the future, then recording this timelock for the address and emitting an event to signal the action. The goal is to enforce a time-based restriction on allocations for the given address.",
        "url": 534
    },
    {
        "nl_input": "The query requires a function that prevents or cancels the minting of tokens for a specific investor by reducing or removing their allocated tokens from a holding mapping and updating the total tokens to mint accordingly. This operation should be restricted to the contract owner and emit an event indicating the investor's token minting has been declined.",
        "url": 535
    },
    {
        "nl_input": "The query requires functionality to set a percentage value for reserved tokens associated with a reserved wallet. Specifically, it seeks a method to update the reserved tokens percentage, likely controlled by the contract owner, to manage token allocation reserved for a particular wallet or purpose. The focus is on modifying a numeric percentage related to reserved tokens rather than changing wallet addresses or canceling reserved token amounts.",
        "url": 536
    },
    {
        "nl_input": "The query requires setting up an interface to the Blocklord contract by implementing a function that allows updating the Blocklord interface address. This function, restricted to the contract owner, should accept a new address and assign it to the Blocklord interface instance, enabling interaction with the Blocklord contract through that interface.",
        "url": 537
    },
    {
        "nl_input": "The query requires a smart contract mechanism that guarantees the original tokens within the contract are distributed equally among recipients, preventing any unfair or excessive accumulation by a single party (\"no divine dump\"). This ensures a balanced token allocation that supports long-term health and sustainability of the ecosystem by maintaining fairness and avoiding centralization or manipulation of token distribution.",
        "url": 538
    },
    {
        "nl_input": "The query requires a secure method allowing the seller to withdraw tokens that were not purchased by buyers, ensuring safety in returning only unbought tokens. The withdrawal function should verify authorization, calculate the correct token amount excluding already sold or claimed tokens, and transfer the remaining tokens back to the seller, preventing loss or misuse of tokens still held by the contract.",
        "url": 539
    },
    {
        "nl_input": "The query requires a function that updates a counter tracking whitelisted planned contributions by subtracting a specified contribution amount before applying it. This involves decrementing the existing whitelisted contribution total by the planned contribution value and emitting an event to log the update. The focus is on accurately adjusting the counter to reflect the removal or reduction of a planned whitelisted contribution prior to its actual application.",
        "url": 540
    },
    {
        "nl_input": "The query requires implementing a function to set the price for summoning a hero using Ethereum (ETH) as payment. This involves defining a payable function that requires the user to send the exact ETH amount corresponding to the hero summoning price, processes the payment, and then triggers the hero summoning logic accordingly. The function should ensure security checks like validating payment value and contract state before minting or transferring heroes.",
        "url": 541
    },
    {
        "nl_input": "The query requires a solution to log wallet interactions off-chain by emitting events that record wallet-related actions such as deposits. The functionality should enable tracking wallet operations without on-chain state changes, focusing on event logging to capture details like sender address, token, amount, and updated wallet balance for off-chain monitoring purposes.",
        "url": 542
    },
    {
        "nl_input": "The query requires functionality where player two approves a contract (SlammerTime) to take their tokens, which then triggers an event notifying player one of player two's intention to \"rumble\" or challenge in the game. This involves token approval mechanisms, event broadcasting to signal the challenge initiation, and a link between player two's token approval and an event triggering for player one's awareness.",
        "url": 543
    },
    {
        "nl_input": "The query requires identifying a public function that returns a string value for a token or contract's symbol or name. It looks for a function with public visibility and view modifier that outputs a string representing the token symbol or contract name.",
        "url": 544
    },
    {
        "nl_input": "The query requires determining the ICO stage based on a given or current time variable. The solution should check whether a specific time falls within the ICO period, returning a boolean indicating if the ICO is active at that time. This involves comparing the input time against defined ICO start and end timestamps or mapping a time to predefined stages during the ICO timeline to identify the current crowdsale phase.",
        "url": 545
    },
    {
        "nl_input": "The query requires a description of an internal token issuance method that can be called only by the buyToken function and does not need the owner's consent to issue tokens to any address. The functionality ensures tokens can be issued internally without owner approval, emphasizing the internal call restriction and token distribution during purchasing or gifting processes.",
        "url": 546
    },
    {
        "nl_input": "The query requires functionality allowing the contract owner to modify the number of tokens available for the ICO, with a constraint that this number must be less than 70 million. The owner must be able to update the ICO token supply before the ICO start date, ensuring the new supply is below the total token supply limit. This capability should be restricted to the owner and enforce the specified upper limit on tokens available for the ICO.",
        "url": 547
    },
    {
        "nl_input": "The query requires a function that returns the asset allowance authorized by one holder (owner) to another (spender). It should accept addresses of both parties and, if applicable, an asset identifier, then return the permitted amount the spender can use from the owner's assets. This involves querying internal mappings or records that track allowances between holders for specific assets.",
        "url": 548
    },
    {
        "nl_input": "The query requires proposing a transfer of ownership for the EngravedToken contract to a specified address _engravedAddress. This involves creating a proposal mechanism that only authorized beneficiaries can initiate, setting stages for the proposal process, defining deadlines and cooldown periods, and recording the proposed new owner address to transition ownership securely and systematically.",
        "url": 549
    },
    {
        "nl_input": "The query requires completing a breeding auction by placing a bid through a function that verifies ownership and breeding eligibility of the involved entities, checks if they can mate via the marketplace, calculates and verifies the breeding fee, then submits a bid with the adjusted payment and initiates the breeding process, ensuring all conditions and payments are correctly handled within a paused state check.",
        "url": 550
    },
    {
        "nl_input": "The query requires functionality related to an individual's ability to influence outcomes, symbolized by changing terms or conditions within a contract. This involves functions allowing authorized personnel (owners or escrow) to modify minimum thresholds or limits (bet amount, withdrawal minimum), ensuring conditions are valid and secure. It also includes participant withdrawal mechanisms if certain funding goals are unmet, emphasizing individual action impacting contract state or future events.",
        "url": 551
    },
    {
        "nl_input": "The query requires an internal function that clears the current approval of a specific token ID and transfers its ownership from one address to another. This function should verify the new owner's address is valid and different from the current owner, confirm the current owner matches the token's owner, clear existing approvals, update token ownership records, and emit a Transfer event indicating the ownership change.",
        "url": 552
    },
    {
        "nl_input": "The query requires a function within an ICO contract that enables only the contract owner to unpause or resume the associated token contract's operations. This ensures that the token contract, which may be paused for security or administrative reasons, can be reactivated exclusively by the authorized owner to maintain control over the token's state.",
        "url": 553
    },
    {
        "nl_input": "The query requires a function that allows users to place a bid on an auction by sending a monetary value along with the transaction. The bid must be higher than the current highest bid and only accepted within the auction time frame. If a higher bid is made, the previous highest bidder\u2019s funds are recorded for potential withdrawal. The function should update the highest bid and bidder, ensuring bids are sent as transaction value.",
        "url": 554
    },
    {
        "nl_input": "The query requires a smart contract function enabling users to buy the HQX token by sending payment, enforcing conditions like account not being frozen and payment amount being positive, then executing the token purchase logic.",
        "url": 555
    },
    {
        "nl_input": "The query requires a contract mechanism that allows for immediate payout of proceeds while handling unexpected incoming funds. Specifically, it needs a function that transfers available benefit or proceeds to the owner right away, updates balances accordingly, and ensures any extra or unexpected funds received by the contract are managed properly without loss, possibly including refunding or retaining them safely. The solution should include secure fund transfer with balance verification and proper access control.",
        "url": 556
    },
    {
        "nl_input": "The query requires a function or method to batch set or assign quota specifically for the user \"admin,\" conditioned on an \"openTag\" value of 0, with removal or resetting actions implied. The task involves updating or managing admin-related permissions or settings in bulk, ensuring the operation is controlled by access checks and includes handling of empty or zero addresses, aligning with managing admin rights and quotas efficiently within smart contracts.",
        "url": 557
    },
    {
        "nl_input": "The query requires a function or method that checks and returns whether a specific game is currently active. It should take a game identifier as input and output a boolean indicating the game's active status, confirming the game exists and is marked as active.",
        "url": 558
    },
    {
        "nl_input": "The query requires functions related to writing data on a pyramid grid, specifically focusing on setting or modifying grid elements (pixels) within a structured layout. The needed code should allow batch updates to multiple grid cells, validate input consistency, handle storage of the grid\u2019s state, and finalize changes if criteria are met. It implies managing indexed positions with associated values (such as colors) to reflect updates on a pyramid-structured grid, ensuring integrity and conditional completion of writing operations.",
        "url": 559
    },
    {
        "nl_input": "The query requires a smart contract with functions to return the total supply of tokens, calculate the amount of tokens for a given ether value along with any excess, and provide the token's decimal precision. These functions include totalSupply(), howManyTokensForEther(uint256 weiAmount), and tokenDecimals(), each returning supply, tokens with excess, and decimal information respectively. This supports token management and conversion within an Ethereum contract.  \nToken count: 71",
        "url": 560
    },
    {
        "nl_input": "The query requests a function that returns the expected amount of MET tokens for a given amount of ETH. It requires a method that takes an ETH deposit value as input and computes or retrieves the corresponding MET token amount as output, reflecting a conversion or exchange rate from ETH to MET.",
        "url": 561
    },
    {
        "nl_input": "The query requires a function to disapprove a user's KYC by updating the user's KYC status to false. This involves identifying the user, changing their KYC verification flag to false, and logging or triggering an event to reflect that the user's KYC is no longer approved. The functionality should be accessible only by authorized roles, such as a KYC manager.",
        "url": 562
    },
    {
        "nl_input": "The query requires functionality to unpause a smart contract, making it active again after being paused. This involves a public function that can only be called by authorized roles such as the owner or manager, and only when the contract is currently paused. The function sets the contract\u2019s paused state to false and may emit an event signaling the contract has been unpaused.",
        "url": 563
    },
    {
        "nl_input": "The query requires a smart contract function that allows selling a specified small amount of tokens (e.g., 0.000000000000000001 HERE) back to the contract. This involves decreasing token balances from the contract's available supply, transferring tokens from the contract to the investor, and ensuring sufficient token availability before the sale. The function should handle token transfers, update inventory accordingly, and validate that the contract holds enough tokens to complete the sell transaction securely.",
        "url": 564
    },
    {
        "nl_input": "The query requires functionality to update the maximum gas price in a smart contract. Specifically, it should include a function allowing only authorized users (typically the contract owner) to set a new maximum gas price value, with validation ensuring the price is greater than zero before updating.",
        "url": 565
    },
    {
        "nl_input": "The query requires functionality to purchase artworks triggered specifically by a likecoin transfer callback. This involves handling a transfer event as payment, validating transfer value, and then assigning or minting artworks accordingly to the buyer's address within a smart contract function. The purchase should ensure sufficient funds correspond to artwork costs, update ownership records, and emit relevant events confirming the purchase. The solution must integrate token transfer callbacks and automate artwork allocation upon successful payment.",
        "url": 566
    },
    {
        "nl_input": "The query seeks methods related to ICO (Initial Coin Offering) functionality in smart contracts, including checking whether a given time is within the ICO period, activating or setting the ICO status, and transferring tokens specifically during the ICO phase. These methods typically involve time validation for ICO phases, changing contract states to activate ICO, and securely handling token transfers limited to ICO conditions.",
        "url": 567
    },
    {
        "nl_input": "The query requires a function that enables a coin holder to add their vote count to a specific option within an active ballot. The function must verify the ballot's validity and active status, confirm the voter's available coin balance hasn't been used yet for that ballot, validate the chosen option, then increment the vote count for that option by the voter's eligible coin balance while tracking their votes to prevent double voting.",
        "url": 568
    },
    {
        "nl_input": "The query requires a Solidity modifier that restricts function execution exclusively to the pendingOwner account. If any other account calls a function using this modifier, the transaction should revert by throwing an error. This ensures only the designated pendingOwner can invoke certain contract functions.",
        "url": 569
    },
    {
        "nl_input": "The query requires a function that verifies if a given address corresponds to a certificate authority by checking specific stored data related to that address. It needs to determine and return a boolean indicating whether the address is recognized as a certificate authority within the system.",
        "url": 570
    },
    {
        "nl_input": "The query requires a mechanism to distribute winnings, including bounty and bonds, to all participants who provided accepted answers. This involves verifying claim history, processing each answer contributor, managing queued funds, and ensuring payments are sent to rightful beneficiaries. The solution should handle multi-level payout logic that fairly assigns rewards to accepted answerers while accounting for referral bonuses and any residual fees, ultimately ensuring transparent and comprehensive allocation of the entire winnings pool.",
        "url": 571
    },
    {
        "nl_input": "The query involves managing a token crowdsale process including minting tokens before the crowdsale begins, finalizing the crowdsale by minting remaining tokens, ending the crowdsale by distributing tokens to designated addresses, transferring ownership, and updating the crowdsale stages. It requires strict conditions like time checks, supply caps, and ownership restrictions to ensure correct token supply control and fund forwarding during the crowdsale lifecycle.",
        "url": 572
    },
    {
        "nl_input": "The query requires information related to a situation where a soft cap or funding goal has not been achieved. It involves checking or handling conditions when the fundraising target (soft cap) is unmet, such as defining or verifying the soft cap value, determining whether the fundraising period is active without reaching a hard cap, or applying restrictions/actions when the funding goal hasn't been reached after the ICO.",
        "url": 573
    },
    {
        "nl_input": "The query requires implementing a function to set the reward divisor in a smart contract. This function should allow updating the reward divisor value, typically restricted to the contract owner for security, enabling control over how rewards are calculated or distributed.",
        "url": 574
    },
    {
        "nl_input": "The query requires a function to create a new series by associating it with a unique identifier (nodehash), assigning a series name, a root hash, and an initial count. The function should ensure only the owner can create the series, prevent creation if the root hash is zero or if the series already exists, and initialize count values accordingly. It should finalize the creation by signaling that the series has been created.",
        "url": 575
    },
    {
        "nl_input": "The query requires a function that returns the number of coins owned by a specific address. The function should accept an owner's address as input and provide the total count of coins associated with that owner, typically by returning the length or balance value linked to that address.",
        "url": 576
    },
    {
        "nl_input": "The query requires a function named \"end genesis\" that transitions a contract from the genesis start stage to the genesis end stage by transferring specific token supplies to designated addresses and transferring token ownership, ensuring the operation is restricted to the owner and occurs only at the GenesisStart stage.",
        "url": 577
    },
    {
        "nl_input": "The query requires a function that allows a maker (caller) to propose or create an oracle by submitting relevant data. This function should handle checks such as verifying the caller\u2019s balance, deducting fees, and storing the proposal details linked to both the maker and a specified taker. It should enable tracking or referencing the oracle proposal via an index or identifier and emit an event to signal a successful oracle proposal.",
        "url": 578
    },
    {
        "nl_input": "The query requires a contract function that transfers ownership of a proxy contract by setting a new owner while removing or replacing the old owner. The function should be restricted to the current owner and validate the new owner's address before updating ownership, ensuring secure and authorized transfer of control over the proxy contract.",
        "url": 579
    },
    {
        "nl_input": "The query requires a system where any user can donate tokens to a specific manufacturer's pool. The functionality must enable public deposits of tokens tied to a manufacturer identifier, validate the input, transfer tokens from the donor to the contract, and update the token balance associated with that manufacturer's pool, emitting an event upon successful deposit.",
        "url": 580
    },
    {
        "nl_input": "The query requires a function that retrieves a user's balance, specifically accessing and returning the token or account balance associated with a given user address. The solution should provide a means to query the balance either at the current state or at a specific point, ensuring that the balance information corresponds directly to the specified user account.",
        "url": 581
    },
    {
        "nl_input": "The query requires a function that allows the contract owner to grant or revoke permission to specific wallet addresses to freeze tokens. This involves setting a boolean permission flag (e.g., canFreezeTokens) for multiple wallet addresses, enabling or disabling their ability to freeze tokens. The function should process an array of addresses, update their freeze permission statuses accordingly, and confirm the changes, restricting this capability to the owner only.",
        "url": 582
    },
    {
        "nl_input": "The query requires a function within a smart contract that triggers when a user or another contract attempts to transfer funds to the contract. This function should securely handle or facilitate the receipt and internal transfer of funds, ensuring proper authorization, balance checks, and compatibility with both external user accounts and contract addresses. It may involve mechanisms to send funds, update balances, and possibly reject transfers if conditions like insufficient balance or failed transactions arise.",
        "url": 583
    },
    {
        "nl_input": "The query requires a function allowing the contract owner to withdraw unsold extra tokens remaining after the auction ends, ensuring the withdrawal only occurs after the auction completion and only for tokens that were not sold. The function involves calculating the unsold token amount and securely transferring them to a specified recipient address.",
        "url": 584
    },
    {
        "nl_input": "The query requires a function named getFeeToTokenConversion, designed to calculate token amounts based on contributed fees. This function should use a controller that can be modified in the future to update the conversion logic. It involves retrieving supply and fee data at specific calculation blocks, performing arithmetic operations to determine the number of new tokens corresponding to a given contribution. The focus is on a flexible, upgradeable token fee-to-token conversion mechanism within a smart contract.",
        "url": 585
    },
    {
        "nl_input": "The query requires functionality to officially authorize or approve a new borrower, typically involving a mechanism to add or mark an borrower\u2019s address as approved. This implies granting permissions or rights to the borrower within a contract, often controlled by the contract owner or an authorized party, ensuring the borrower is recognized and allowed to interact with the contract.",
        "url": 586
    },
    {
        "nl_input": "The query requires a function that retrieves or calculates the current token price. It involves accessing the present token price state or computing it dynamically, considering different conditions or stages. The focus is on obtaining the active, up-to-date token price value that reflects the token's current market or sale status.",
        "url": 587
    },
    {
        "nl_input": "The query requires a function that returns the total count of games stored in a collection, specifically by providing the total number of games available. This involves accessing a data structure that tracks all games and retrieving its length or count value.",
        "url": 588
    },
    {
        "nl_input": "The query requires identifying code that uses the interface marker '.' to access or interact with an interface. This primarily involves contracts where an interface type is declared and referenced via the '.' syntax, such as assigning or calling interface functions or variables. The code should demonstrate usage of an interface variable accessed or modified through '.', highlighting interaction between contracts or components via interface references.",
        "url": 589
    },
    {
        "nl_input": "The query requires a Solidity contract function that acts as a getter for a boolean variable named \"paused.\" This function should be publicly accessible and return the current value of the \"paused\" state variable, indicating whether the contract is paused or active.",
        "url": 590
    },
    {
        "nl_input": "The query requires a function that checks whether a specific key or address is registered or authorized within a system. This function should accept a key as input and return a boolean indicating the registration status, typically by verifying the presence or status of the key in a record or registry.",
        "url": 591
    },
    {
        "nl_input": "The query requests information about functions related to \"status\" that provide or return the current state or condition, such as sale status, action status, or ICO status. It involves functions that report whether a sale is active, retrieve detailed status of an action including confirmations and triggers, or set an ICO status to active. The focus is on reading or modifying status indicators through functions named or associated with \"status.\"",
        "url": 592
    },
    {
        "nl_input": "The query requires a function to check a user's REB token balance and determine their tier classification based on specific balance thresholds, such as Platinum, Gold, Titanium, Free tier, or no REB possession. The function should accept a user address and return a string indicating the corresponding balance tier category according to predefined token amount ranges.",
        "url": 593
    },
    {
        "nl_input": "The query requires a function to create a new promotional team by specifying its name and price, and assign ownership to a given address. It should handle cases where the owner address is null by assigning a default address, enforce a creation limit, set a default price if none is provided, increment a creation count, and then invoke an internal function to finalize team creation with the given parameters.",
        "url": 594
    },
    {
        "nl_input": "The query requires a function that pays the creator once a task or condition is successfully completed. This includes verifying completion status, ensuring the creator has not been previously paid, and then disbursing payments in tokens and/or Ether accordingly. It may also handle token burns or partial payments based on the success criteria, with safeguards to prevent duplicate payments.",
        "url": 595
    },
    {
        "nl_input": "The query requires overriding the getRate function to integrate it with an external rate provider, allowing dynamic rate retrieval based on parameters such as the caller, sold tokens, or input values, rather than returning a static or fixed rate. The function should call the rate provider's getRate method, passing relevant arguments to compute or fetch the current rate.",
        "url": 596
    },
    {
        "nl_input": "The query requires functionality to transfer or move remaining contract funds after the contract\u2019s active period or sale ends. This involves checking contract completion status or contract stages, ensuring only authorized owners can trigger the transfer, possibly defining a wallet or recipient address, and safely sending the contract\u2019s balance away upon contract termination or finalization. The primary need is a secure withdrawal or fund transfer mechanism that activates once the contract's active lifecycle or sale process concludes.",
        "url": 597
    },
    {
        "nl_input": "The query requires a function where the token holder explicitly authorizes this contract's address to spend tokens on their behalf using the approve() function. This involves the token owner calling approve() to grant the contract address an allowance, enabling token transfers by the contract within the approved limit. The approval updates the allowance mapping, triggers an Approval event, and requires proper ownership or authorization checks.",
        "url": 598
    },
    {
        "nl_input": "The query requires determining the exchange rate of FARM tokens per 1 ETH transaction based on the timing of the transaction and a FARM pricing mechanism. It involves accessing or setting a dynamic rate variable that reflects the current price of FARM relative to ETH, influenced by factors such as contract balances or predefined formulas, to provide an accurate and time-dependent FARM per ETH rate.",
        "url": 599
    },
    {
        "nl_input": "The query requires a convenience function in a smart contract that allows users to immediately receive refunds. This function should verify refund eligibility, transfer the user's invested or held balance back to them, reset their stored balance to prevent re-entrancy, and optionally emit an event confirming the refund. The function should enable straightforward, secure, and prompt refunding of funds to users when refund conditions are met.",
        "url": 600
    },
    {
        "nl_input": "The query requires a functionality that manages token purchases at a given price. Specifically, it should handle receiving payment, calculate the token amount based on the price, ensure sufficient token availability, update balances accordingly, transfer funds to the beneficiary or vault, and emit relevant purchase or transfer events. The process must validate inputs, restrict invalid buyers or zero payments, and maintain accurate tracking of tokens sold and total funds raised.",
        "url": 601
    },
    {
        "nl_input": "The query requires a function to set the historical balance for a given address owner over a specified range of snapshot indexes. The function should validate the range and balance parameters and update the stored balances for each snapshot index within that range, efficiently handling the indexing across multiple levels, reflecting the owner's balance at those specific snapshots in time.",
        "url": 602
    },
    {
        "nl_input": "The query requires a function that validates parameters related to changing signature requirement settings. It should check that the new required signature count is not zero and does not exceed permissible limits based on the total number of signers, preventing invalid or overly high requirements. The validation should return a boolean indicating whether the proposed changes to signature requirements are acceptable.",
        "url": 603
    },
    {
        "nl_input": "The query requires determining the amount of tokens that have been released or vested in a vesting schedule. This involves calculating tokens that become available over time based on vesting duration, start date, or release conditions. The focus is on retrieving the currently vested or releasable token quantity at a given point, reflecting how many tokens have been unlocked or are available for withdrawal within a smart contract handling token vesting.",
        "url": 604
    },
    {
        "nl_input": "The query requires a function named totalSupply that returns a uint256 value representing the total supply of tokens. It assumes this totalSupply value cannot exceed the maximum uint256 limit (2^256 - 1). The required function should be publicly or externally accessible and constant or view to ensure it does not modify state while retrieving the total supply.",
        "url": 605
    },
    {
        "nl_input": "The query requires retrieving specific statistical data, preferably detailed numeric arrays or multiple values representing attributes or metrics. The function should offer constant (read-only) access to these stats, ideally tied to a particular entity or context, such as an identifier or user, for example, obtaining comprehensive base stats or aggregated numeric values. The main need is to extract structured numeric statistics relevant to the queried subject through a public or external read-only function.",
        "url": 606
    },
    {
        "nl_input": "The query requires a function or mechanism to reset all user balances to zero and change a certain state variable to false. This involves iterating over all accounts or relevant entries to set their balances to 0 and updating a boolean status variable accordingly, effectively clearing all funds and disabling a particular state or feature.",
        "url": 607
    },
    {
        "nl_input": "The query requires a token purchase process that integrates anti-money laundering (AML) and know your customer (KYC) verifications. This involves validating the buyer\u2019s identity and compliance before allowing token transactions, ensuring regulatory adherence. The process should include buyer address checks, fund transfers, token balance updates, event logging, and restrictions preventing token sales to unverified or suspicious parties. In essence, the requirement is a secure token purchase mechanism with mandatory AML/KYC checks to prevent illicit transactions.",
        "url": 608
    },
    {
        "nl_input": "The query requires a smart contract function named setNews that allows the contract owner to update a news string, emit an event signaling the news publication, and return a boolean indicating success. The function must be externally callable, restricted to the owner, and update the stored news data accordingly.",
        "url": 609
    },
    {
        "nl_input": "The query requires a function that transfers the entire balance from a sale auction contract to the ZodiacCore contract, ensuring the funds collected during the sale are properly forwarded. This involves finalizing the sale, verifying sale conditions, calculating any reserved balances if needed, and then transferring the remaining contract balance securely to the specified ZodiacCore contract address. Only authorized callers (e.g., owner) should perform this transfer, ensuring proper control and security of the funds.",
        "url": 610
    },
    {
        "nl_input": "The query requires a contract function that permanently disables the contract and deletes it from the blockchain, effectively removing its state. The function should be restricted to the contract owner and call a self-destruct mechanism to transfer remaining funds and erase the contract code, ensuring complete shutdown and removal of the contract from the blockchain.",
        "url": 611
    },
    {
        "nl_input": "The query requires a delete function designed to remove or deactivate elements in a contract, specifically used to fix or address bugs. This function should effectively eliminate or disable entries or users when problems arise, ensuring smoother contract operation and maintenance.",
        "url": 612
    },
    {
        "nl_input": "The query requires a function to retrieve a certification document by its index for a given student address, with the access contingent on payment of a fee. This indicates that users must pay to access certification documents at specified indexes within a student's stored certifications.",
        "url": 613
    },
    {
        "nl_input": "The query requires verifying if a given address belongs to an investor. This involves checking whether the address is included in the list or mapping of authorized or allowed investors and returning a boolean result indicating the investor status. The function should efficiently confirm investor legitimacy without modifying state, ensuring access control where applicable.",
        "url": 614
    },
    {
        "nl_input": "The query requires a function that retrieves comprehensive details about a match, including the names of both teams, total amounts bet, number of participants per team, the winning team index, whether the match is completed, the minimum bet amount, the match number, and the status of betting being stopped. The information should reflect the current state of the match comprehensively.",
        "url": 615
    },
    {
        "nl_input": "The query requires a function that transfers tokens to a specified address but uses a different sender address instead of msg.sender for authorization or token transfer logic. It should not simply transfer tokens from the caller (msg.sender) but replace msg.sender with another address variable when executing the transfer. The function should handle permission checks and token transfer accordingly, distinguishing itself from a typical transfer where msg.sender is the sender.",
        "url": 616
    },
    {
        "nl_input": "The query requires a function allowing the contract owner to transfer out any ERC20 tokens mistakenly sent to the contract, except for the specific ERC20 token intended for the contract's operation. The function must enforce ownership control and explicitly prevent transferring the designated token, ensuring only unintended tokens can be moved out by the owner.",
        "url": 617
    },
    {
        "nl_input": "The query requires a function that updates the startTimestamp property by assigning it a new _start value, ensuring appropriate validation checks such as the new value being less than endTimestamp and greater than the current time. Additionally, the update should emit an event indicating the change and be restricted to administrative access.",
        "url": 618
    },
    {
        "nl_input": "The query requires creating a new offer by setting a parameter (likely an integer or configuration setting) that must be greater than zero, involving a payable function that accepts a positive value (msg.value > 0). The method should internally handle the creation process using this setting without involving additional parameters like owner address or price. The function focuses on validating input and triggering an internal creation routine for the offer.",
        "url": 619
    },
    {
        "nl_input": "The query requires a function that transfers a specified balance amount from the sender's address to another address (_to) while including additional data (_data) in the transaction. The function must ensure the sender has sufficient balance, prevent transfers to the zero address, update balances accordingly, and emit an event with the sender, recipient, amount, and data to log the transfer.",
        "url": 620
    },
    {
        "nl_input": "The query requires a function in a contract that allows the owner to update the current DOL price by setting a new price value. The function must include an ownership check and enforce constraints such as the price being non-zero or higher than the previous price before updating the stored price variable.",
        "url": 621
    },
    {
        "nl_input": "The query requires functionality to add a Kin token vesting grant, enabling token holders to lock tokens with vesting conditions. This includes creating and managing grants that specify token amounts, vesting schedules, and tracking vested versus transferred tokens. The system must support unlocking vested tokens, calculating vested balances at given times, and allowing granters, vesters, and tokens to interact, ensuring proper transfer of vested Kin tokens according to the grant's terms.",
        "url": 622
    },
    {
        "nl_input": "The query requires functionality to freeze tokens or accounts for a specified address. The solution should enable freezing an account's ability to transact or freezing tokens sent to a particular address, potentially including setting conditions like freeze duration or amount limits, ensuring only authorized users can perform the freeze operation, and emitting relevant events to notify about the freezing action.",
        "url": 623
    },
    {
        "nl_input": "The query requires a function that retrieves comprehensive details about a specific waifu, including its name, current selling price, and the owner's address, based on a given token ID. The function should accept a token identifier as input and return these three pieces of information connected to that particular waifu.",
        "url": 624
    },
    {
        "nl_input": "The query requires a function that allows assigning a new address specifically to the CEO role. This involves securely updating the CEO's address with appropriate access control to ensure only the current CEO can perform the update. The new address must be valid and not a zero address. The focus is on role reassignment for the CEO position within a contract.",
        "url": 625
    },
    {
        "nl_input": "The query requires a function that retrieves the amount of released tokens associated with a specified address. This involves accessing a stored mapping or record to return the uint256 value representing released tokens for the given address.",
        "url": 626
    },
    {
        "nl_input": "The query requires a description of the actual predator attack mechanism. From the provided code, it involves randomly selecting a number of animals to be killed based on available animal count, retrieving random numbers via an oracle callback, mapping these to existing animal IDs, killing the selected animals, calculating the pot and gas costs, distributing rewards if pot exceeds gas cost, and triggering a new attack. The focus is on the full process of executing and handling a predator attack event in a contract.",
        "url": 627
    },
    {
        "nl_input": "The query requires functionality to extend the ICO end date by allowing the contract owner or authorized user to set or update the ICO end timestamp, ensuring it occurs after the current time and the ICO start date. The implementation should include access control (e.g., only owner or whitelist), checks to prevent invalid end dates, and conditions to modify the ICO end date only when appropriate (e.g., when not paused or if not previously set).",
        "url": 628
    },
    {
        "nl_input": "The query requires functionality in a smart contract that enables a user who has been pre-approved to claim ownership of a specific color token. The process involves verifying that the caller is approved for the token, ensuring valid ownership transfer conditions, and then transferring ownership of the color to the caller. This includes checks for non-null addresses and approval status before executing the transfer of the specified token ID to the new owner.",
        "url": 629
    },
    {
        "nl_input": "The query requires a function that transfers pooled Ether to a specified receiving address, calculates and records any remaining unused Ether to be refunded, and then progresses the contract to the next operational stage (stage two). This process must include validation checks for contract stage, receiver address validity, minimum contribution, and should emit an event upon successful submission.",
        "url": 630
    },
    {
        "nl_input": "The query requires retrieving a tuple consisting of the activation status of an entity and its connection counterparts, including the entity's active state, the connected entity's active state, the connection's active status, associated connection data, the connection's direction, and its expiration time. This involves accessing and returning detailed connection information between two specified addresses within a contract.",
        "url": 631
    },
    {
        "nl_input": "The query requires identifying a contract condition or modifier that ensures an agreement or contract is not locked. It focuses on implementing a check that confirms the contract\u2019s \"locked\" state is false before allowing certain functions or actions to proceed, preventing them from executing if the contract is locked. This typically involves a require statement validating that the \"locked\" boolean variable is false.",
        "url": 632
    },
    {
        "nl_input": "The query requires a method to verify if a given sequence can be expressed as 48151623420 multiplied by 10 raised to some power within a specified range. Specifically, it checks whether the sequence equals 4815162342 * 10^i for some index i in the range from offset to offset plus length, returning the exponent if matched or -1 if not.",
        "url": 633
    },
    {
        "nl_input": "The query requires calculating a fee based on the losing portion of the total pot by subtracting the winners' amount from the total pot, then computing a fee as a percentage of this losing portion. The fee is deducted from the remaining losing amount, and the net amount after fee deduction is returned. This involves safe arithmetic operations and uses a predefined fee percentage to determine the fee from the losing portion.",
        "url": 634
    },
    {
        "nl_input": "The query requires a function to update or modify network-related constants, specifically adjusting parameters such as registration costs or bonus rates. It involves secure access controls, ensuring only authorized users (e.g., the owner) can perform such updates. The function should allow changing these constants dynamically to maintain or configure the network's operational parameters.",
        "url": 635
    },
    {
        "nl_input": "The query requires a function that performs an initial distribution of tokens to founders' addresses. This function should ensure the allocation occurs only once, verify conditions such as ownership and non-repetition, and transfer predefined token amounts to specific founder-related addresses securely. The primary goal is to initialize token balances for founders at the start while preventing multiple allocations.",
        "url": 636
    },
    {
        "nl_input": "The query requires functionality to create and store a new promise object by assigning it an ID, recipient, amount, and lock time, setting its initial state, and updating the total promised token balance accordingly. This includes ensuring sufficient uncommitted tokens before creation, updating the promisedTokenBalance by adding the new promise amount, and logging the creation event for tracking purposes.",
        "url": 637
    },
    {
        "nl_input": "The query requires a function to transfer tokens on behalf of another account, utilizing a previously set allowance. It should deduct the transferred token amount from the sender's balance and the approved allowance, then credit the recipient's balance accordingly. The function should confirm the transfer by emitting an event and return a success status, ensuring secure handling of the approved token allowance during the transfer process.",
        "url": 638
    },
    {
        "nl_input": "The query requires a batch transfer function that sends a specified fixed value (_value) of tokens or funds to multiple receivers provided as an array. The function should validate non-empty, size-limited receiver lists, ensure the sender has sufficient balance, and update balances accordingly for each receiver. It should perform transfers only to unfrozen accounts, emit transfer events, and return a success status.",
        "url": 639
    },
    {
        "nl_input": "The query requires a function named totalSupply that returns the total supply amount of a token as an unsigned integer. This function should be publicly accessible and constant (or view), providing the current total token supply stored in a variable like numTokens, _totalSupply, or totalSupply within a smart contract. The purpose is to retrieve the total number of tokens available in circulation or issued by the contract.",
        "url": 640
    },
    {
        "nl_input": "The query requires initiating a crowdsale through a function typically restricted to the contract owner. This start function should transition the crowdsale from a stopped or inactive state to active, setting relevant timing or block parameters to mark the beginning and phases of the crowdsale. It may include preconditions like ensuring a presale has concluded and preventing multiple starts, establishing clear timing or block-based phases for the crowdsale progress.",
        "url": 641
    },
    {
        "nl_input": "The query requires functionality to remove or delete a contract, involving the deletion or deactivation of contract-related data structures. This includes removing contract entries from mappings or lists, resetting associated values, and potentially managing contract indices to effectively deactivate or eliminate the contract's presence within the system.",
        "url": 642
    },
    {
        "nl_input": "The query requires a function to update the coldwallet2 address in a contract. The function should only be callable by the owner, accept a new address parameter, and validate that the new address is not the zero address before assigning it to the coldwallet2 state variable.",
        "url": 643
    },
    {
        "nl_input": "The query requires a function that enables users to make payments using mileage points. It should validate the sender's address, limit the payment amount within a specific range, calculate the total cost based on mileage point price, ensure the user has enough mileage points, deduct the points accordingly, and then perform an action (like summoning items) multiple times based on the payment amount, with random outcomes determining the result's quality or rank.",
        "url": 644
    },
    {
        "nl_input": "The query requires functionality in a smart contract that allows a token owner to grant permission (approve) another address (proxy) to manage or transfer specific tokens on their behalf. This involves an approve function that verifies ownership of the token before setting an approved address for that token, enabling delegated control over token transfers while ensuring proper authorization.",
        "url": 645
    },
    {
        "nl_input": "The query requires a function to verify if a specific Zodiac character is ready and able to breed. This involves checking that the Zodiac is not currently engaged in breeding with another (siringWithId == 0) and that its breeding cooldown period has ended (cooldownEndBlock has passed the current block number). The function should return a boolean indicating breeding readiness.",
        "url": 646
    },
    {
        "nl_input": "The query requires a function that allows users to deposit funds into a smart contract wallet. The deposit process should handle tokens or ether, update the user's wallet balance, and emit an event or log indicating the deposit details, including the sender's address, token type, amount deposited, and updated balance. Additionally, access control such as user whitelisting or condition checks may be necessary to restrict who can make deposits.",
        "url": 647
    },
    {
        "nl_input": "The query requires a method that any user can call to withdraw tokens to a specific coindrops wallet only after a designated locking period has ended. The withdrawal must check the lock expiration and ensure tokens have not yet been withdrawn, then transfer the tokens to the coindrops wallet and update the withdrawal status.",
        "url": 648
    },
    {
        "nl_input": "The query requires a function that creates a new dynamically allocated string by concatenating two given string-like slices, ensuring the combined string contains the contents of both inputs in order.",
        "url": 649
    },
    {
        "nl_input": "The query requires executing a multi-signature transaction from a wallet that mandates approval by two signers, one being the message sender (msg.sender). The transaction should verify signatures, generate a unique operation hash incorporating transaction details (recipient, value, data, expiration, sequence ID), confirm the other signer's approval, and ensure secure execution of the value transfer and data call. The function must enforce the multi-signature policy and emit an event capturing the transaction details and involved signers.",
        "url": 650
    },
    {
        "nl_input": "The query involves unlocking or releasing locked tokens. It requires functions that enable authorized users to unlock vested tokens based on specific conditions, such as vesting schedules or time locks. The process includes verifying the releasability of tokens, calculating the amount available for unlocking, updating records to reflect transferred tokens, and transferring the unlocked tokens to the user. Access control and proper event logging upon successful unlocking are also necessary.",
        "url": 651
    },
    {
        "nl_input": "The query requires a function that facilitates adding or distributing dividends within a smart contract. This includes accepting funds intended as dividends, updating related dividend tracking variables, and ensuring the proper handling of dividend-related state changes to allow shareholders or participants to receive their proportional shares. The function should securely manage dividend additions and maintain accurate dividend accounting for future withdrawals or distributions.",
        "url": 652
    },
    {
        "nl_input": "The query requires a function that disables or deactivates the whitelist feature in a contract by changing its state to false. This function should likely be restricted to the contract owner and emit an event or provide confirmation of the whitelist status being changed to disabled.",
        "url": 653
    },
    {
        "nl_input": "The query requires a function or modifier that can only be invoked after the presale phase has concluded. This means there must be a check to ensure the presale period is over or finalized before allowing the subsequent actions. The implementation should include conditions verifying that the current time is beyond the presale end or flags indicating presale finalization, preventing calls during the presale period.",
        "url": 654
    },
    {
        "nl_input": "The query requires a function to cancel any outstanding multisig call, verifying the caller\u2019s authorization, checking if there is a pending multisig call, and then resetting the call information to cancel it. The function should handle unauthorized access, indicate if there's nothing to cancel, and properly update stored multisig call data to reflect the cancellation.",
        "url": 655
    },
    {
        "nl_input": "The query requires a function that refunds all Ether to contributors, including returning any fees. The refund process should verify the contributor's investment, reset their balance, and send back the full invested Ether amount securely. It should handle cases where the sale or funding goal was not reached, enabling users to reclaim their Ether. The mechanism must ensure that all investments are returned without loss, providing a full refund with any fees reimbursed.",
        "url": 656
    },
    {
        "nl_input": "The query requires public \"give\" and \"take\" functions within a contract that can only be executed by owners. These methods should enforce ownership-restricted access, ensuring only authorized owners can call them to transfer or receive assets.",
        "url": 657
    },
    {
        "nl_input": "The query requires a function to transfer tokens from an Ethereum fund deposit to a user. This involves securely issuing or sending tokens from a contract-held deposit or wallet balance directly to a specified user address, ensuring proper authorization, balance checks, and updating token allocations accordingly.",
        "url": 658
    },
    {
        "nl_input": "The query requires a token creation mechanism restricted to an active sale period. Tokens can only be purchased while the sale is active (saleActive), ensuring conditions like sale start and end times, token availability, purchase limits, and price calculation based on tokens sold. Payment is checked and excess refunded. Token balances are updated accordingly, and a transfer event is emitted to register token distribution during the active sale phase.",
        "url": 659
    },
    {
        "nl_input": "The query requires a function named \"add\" that operates on a data structure, specifically adding an address value to a set or collection and returning a boolean indicating success. The function should interact with storage and handle address-type inputs for insertion into the set.",
        "url": 660
    },
    {
        "nl_input": "The query requires a smart contract function that enables the factory owner to withdraw any ERC20 tokens held by the contract. This function must restrict access to the owner only and allow transferring a specified amount of any ERC20 token from the contract to the owner's address. Notifications or events signaling the withdrawal may be included to track the action. The contract should ensure secure token transfer while preventing unauthorized access.",
        "url": 661
    },
    {
        "nl_input": "The query requires a function to finalize or seal a crowdsale only after it has completely finished, ensuring conditions like presale finalization, goal achievement, and that the closing time has passed. The function should mark the crowdsale as finalized, transfer funds or enable refunds accordingly, and emit relevant events or update states to indicate completion and prevent re-finalization.",
        "url": 662
    },
    {
        "nl_input": "The query requires obtaining the total supply value from a smart contract by calling a function named totalSupply. The function is expected to be publicly accessible and returns an unsigned integer representing the total number of tokens or items available within the contract.",
        "url": 663
    },
    {
        "nl_input": "The query requires a function that allows a user to cancel their adoption request for a cat. The function should verify the existence of the request, ensure that the requester is the one cancelling, reset the adoption request data, refund the requester the price paid, and emit an event indicating the cancellation.",
        "url": 664
    },
    {
        "nl_input": "The query requires an internal function that creates a payment request, accepts it, and adds additional amounts from the perspective of the payer. This involves processing request data bytes to identify the main payee and payees count, validating conditions like sender and payee addresses, calculating total expected amounts, charging fees, updating request data to record the payer, creating the request, storing related payment addresses, and finally accepting the request while adding any specified additional payments.",
        "url": 665
    },
    {
        "nl_input": "The query needs a function that calculates the number of tokens a sender is purchasing based on their payment amount. It requires computing the token amount from the sent value, considering rates or bonuses, and ensuring correct conversion (e.g., ether to token units). The function should return the token quantity to be issued to the sender, reflecting the purchase calculation accurately.",
        "url": 666
    },
    {
        "nl_input": "The query requires handling and returning variable-length arrays or strings within a smart contract function. This involves carefully managing dynamic memory allocation and copying data to construct and return concatenated or combined arrays/strings without errors. The focus is on techniques to create and return variable-length data types in Solidity, ensuring the data is correctly assembled and returned from internal or external functions.",
        "url": 667
    },
    {
        "nl_input": "The query requires setting up a Token Sale smart contract by initializing the sale with a start date and linking it to a specific token address. The setup must ensure the token's total supply is zero and that the contract owns the token. Additionally, the sale stage should transition to a \"ready\" state upon successful setup, with access restricted to the contract owner and occurring only during the designated setup phase.",
        "url": 668
    },
    {
        "nl_input": "The query requires a function that the contract owner calls to lock the contract. This function should ensure the contract has not been unlocked before, set a locked state to true, and emit a locking event to signal the change. The locking process must be owner-restricted, preventing unauthorized access, and the lock should be enacted only once or under specific conditions to avoid repeated unlocking or locking.",
        "url": 669
    },
    {
        "nl_input": "The query requires a function to create a company entity with specific attributes including name, owner address, and price. The creation process should ensure the price meets a condition (e.g., divisible by 100), instantiate a company structure, assign a unique company ID, emit an event signaling the company's founding with relevant details, set the price, and transfer total shares from a null address to the owner. The function should be private and handle storage and indexing of companies.",
        "url": 670
    },
    {
        "nl_input": "The query requires a function that sets the cooldown end time for a given Dog object by calculating it from the Dog's current cooldownIndex. This involves using a cooldowns array or mapping and factoring in the block timing (e.g., seconds per block, current block number) to compute cooldownEndTime, and then updating the Dog's cooldownIndex appropriately, ensuring the Dog's cooldown state progresses after each cooldown trigger.",
        "url": 671
    },
    {
        "nl_input": "The query requires functions that perform update operations, specifically modifying contract state variables or mappings. These functions handle tasks such as recording operation details, changing permissions or editor status, and updating agent statuses, with controlled access and state changes reflected through assignments to mappings or variables. The focus is on methods that implement updates to the contract's internal data.",
        "url": 672
    },
    {
        "nl_input": "The query requires a function that assigns and distributes the proceeds from a buyout transaction. This includes sending earnings to the current owner or allocating funds to a prize pool if no owner exists, distributing dividends to beneficiaries holding surrounding assets, paying referral bonuses to up to two levels of referrers with fallback handling if absent, forwarding fees to beneficiaries, and updating the prize pool accordingly.",
        "url": 673
    },
    {
        "nl_input": "The query requires a function that retrieves the current RDN token price in WEI specifically during an ongoing auction, reflecting the price at the moment the function is called. This involves returning the current bid or starting price depending on auction status, ensuring the price is up-to-date for a given region or auction item.",
        "url": 674
    },
    {
        "nl_input": "The query requires a function that allows the transaction creator to approve and authorize a specified amount of tokens to be sent to a designated recipient. This involves granting permission from the message sender to the recipient address for transferring a certain token amount, typically returning a boolean to indicate success. The function manages allowances or approvals to enable token spending by the recipient on behalf of the sender.",
        "url": 675
    },
    {
        "nl_input": "The query requests a modifier that restricts function execution to when the crowdsale is actively running. This involves checking the crowdsale status\u2014ensuring it is neither stopped nor inactive\u2014before allowing the function to proceed. The modifier should enforce that the current time falls within the crowdsale\u2019s start and end times or that a specific \"running\" condition is true, thereby permitting execution only during the active crowdsale period.",
        "url": 676
    },
    {
        "nl_input": "The query requires a function to set or add an additional authorized address or manager with restricted access control, ensuring the address is valid (non-zero), and typically callable only by an owner or admin role. This involves updating a state variable to assign the role or state to the given address, with proper validation and access restrictions to secure who can perform this action.",
        "url": 677
    },
    {
        "nl_input": "The query requires locking the DAICO token supply until September 1, 2018, 14:00:00 (Unix timestamp 1535810400). It involves restricting transfers or unlocking functions before this date. After this timestamp, the DAICO supply can be transferred or unlocked. The solution must include a time-based restriction to prevent actions before the specified date, effectively locking the token supply until then.",
        "url": 678
    },
    {
        "nl_input": "The query requires functionality to dynamically adjust the reimbursed gas amount during token transfers when the sender's account balance falls below a minimum threshold, especially in cases of changes to gas prices. This ensures adequate gas reimbursement on every transfer to cover fluctuating network costs, maintaining smooth transaction processing despite balance constraints.",
        "url": 679
    },
    {
        "nl_input": "The query requires a function that transfers tokens from the contract owner during an ICO phase. The transfer should only occur if the token is active, the recipient address is valid, the owner holds enough tokens, and the call is made by the designated ICO contract. The function should update balances accordingly and emit a transfer event, ensuring secure and authorized token distribution specifically within the ICO context.",
        "url": 680
    },
    {
        "nl_input": "The query requires a function that transfers tokens from the contract's own balance in OBL's token system to another address. The tokens should be deducted from the contract's balance and added to the recipient's balance, ensuring safe arithmetic operations and emitting a transfer event. The transfer must check validity such as non-zero recipient address, and update balances accordingly, reflecting a token transfer originating specifically from the contract's balance rather than an external account.",
        "url": 681
    },
    {
        "nl_input": "The query requires a function that accepts Ether payments and facilitates token purchases on behalf of a specified user address (beneficiary). The function must ensure proper value checks, calculate token amounts based on Ether sent, update balances or token supplies accordingly, transfer received Ether to a designated wallet or beneficiary, and emit relevant events or confirmations of the purchase process. The function should securely handle the transaction, ensuring funds are appropriately routed and tokens correctly issued or transferred.",
        "url": 682
    },
    {
        "nl_input": "The query requires verifying if a specific account is permitted to purchase tokens, focusing on code that checks account restrictions before allowing a token purchase. The relevant functionality involves confirming the account is not frozen or restricted and ensuring payment conditions are met prior to executing the token buying process.",
        "url": 683
    },
    {
        "nl_input": "The query requires a getter function that determines if a specific project, identified by its ID, has been canceled. This function should retrieve the project's administrative record, verify its type, and check the cancellation status. If the project has a parent project, the function should recursively check the parent's cancellation status to reflect inherited cancellations accurately.",
        "url": 684
    },
    {
        "nl_input": "The query requires verifying if a market maker contract instance is publicly accessible by checking a specific condition that ensures the contract's \"open for public\" status before allowing certain operations. This involves a modifier or function that references the market maker's \"isOpenForPublic()\" method and restricts access based on this state.",
        "url": 685
    },
    {
        "nl_input": "The query requires a function named setValue that updates a sequence of snapshot values by storing the new value at the current snapshot ID. If the snapshot is new and the value is unchanged, no update occurs. If the value changes at the current snapshot, it is appended. If updating an existing snapshot, the value is replaced or removed to avoid redundancy. The function manages snapshot history efficiently, ensuring only meaningful changes are recorded in sequence for the next snapshot.",
        "url": 686
    },
    {
        "nl_input": "The query requires a proxyPayment function enabling callers to send ether to a Campaign contract and allocate CampaignTokens to a specified address. This involves accepting payments, validating contributions, calculating token amounts based on timing and caps, minting tokens to the beneficiary's address, and transferring the received ether to a wallet. The function should ensure token creation is tied to payments and allow token assignment to any chosen address.",
        "url": 687
    },
    {
        "nl_input": "The query requires a function that determines whether a specific promise can be collected by its recipient. The function should return true if the promise's state is either confirmed or pending and the current block timestamp is equal to or greater than the promise's lockedUntil time. This ensures that only promises that have reached their unlock time and are in an appropriate state can be collected by the recipient.",
        "url": 688
    },
    {
        "nl_input": "The query requires functionality to define or enforce a start time or start condition within a contract, ensuring certain actions or stages only proceed after a specified start time or block. This includes modifiers or functions that check the current time or block against a predefined start value, allow setting or updating this start time under controlled permissions, and transition contract stages or enable contributions only once the start conditions are met.",
        "url": 689
    },
    {
        "nl_input": "The query requires a function that allows the administrator or owner to finalize a token sale by verifying sale completion conditions, completing or closing the sale process, handling token allocations or burning remaining tokens, managing funds by transferring or reserving balances, and marking the sale as finalized to prevent further modifications. The process should ensure all sale goals and time constraints are met before completing allocations and enabling subsequent steps.",
        "url": 690
    },
    {
        "nl_input": "The query requires a function to withdraw tokens, ensuring specific conditions are met before allowing withdrawal. The function should verify the contract is finalized or closed, confirm the caller's token balance is greater than zero, reset the balance, and then transfer the tokens to the caller. It focuses on securely reclaiming tokens by authorized users after contract completion or sale finalization.",
        "url": 691
    },
    {
        "nl_input": "The query requires a function that facilitates purchasing on behalf of another person, referred to as the benefactor. It should accept payment, validate that payment and benefactor address are non-zero, record the payment, update relevant balances for the purchaser and benefactor, and forward funds appropriately, ensuring transactions are secure and properly accounted for. The function must handle payments from a purchaser and associate them with a designated benefactor.",
        "url": 692
    },
    {
        "nl_input": "The query requires a function that prepares and compresses transaction-related data, then triggers an event specifically when a buy or reload transaction occurs. The solution involves packaging multiple data points into compressed variables and emitting an event conveying detailed transaction information such as participant IDs, values, and winners, ensuring efficient data handling and real-time notification of buy or reload actions.",
        "url": 693
    },
    {
        "nl_input": "The query requires a function within a contract that permanently stops or finishes the token minting process, preventing any new tokens from being minted forever. This involves a mechanism to mark minting as finished, typically by setting a flag and recording the time of this action, ensuring no further minting operations can occur thereafter.",
        "url": 694
    },
    {
        "nl_input": "The query requires functionality to add a bonus to a specific block or entity. This involves verifying that sufficient bonus funds are available, calculating or determining bonus amounts, and securely assigning or updating bonus values. The operation should have access control to restrict who can add bonuses. The bonus addition may consider different levels or conditions based on certain thresholds or states.",
        "url": 695
    },
    {
        "nl_input": "The query requires a function to set a new rate value. The function should include validation to ensure the rate falls within certain bounds or is computed based on conditions like escrow balance. It may require owner-only access control and should update a stored rate variable accordingly.",
        "url": 696
    },
    {
        "nl_input": "The query requires obtaining the remaining releasing period for a specific account, which involves checking stored release timing information for the account and calculating the time left until the release period ends. This includes verifying if the current time is before or after the scheduled end time and returning the difference accordingly, or zero if the release period has passed.",
        "url": 697
    },
    {
        "nl_input": "The query requires a function that enables the user to claim or pay out tokens they hold. The function should check the user's token balance, ensure they have a positive balance, reset their balance to zero upon payout, and transfer the corresponding token amount to their address. The function must also emit an event logging the payout details, such as the recipient, token amount, and timestamp, to facilitate transparent token distribution.",
        "url": 698
    },
    {
        "nl_input": "The query requires a mechanism to transfer ownership of tokens automatically or explicitly after the completion of a token sale. Specifically, once the token sale has concluded and conditions are met, the contract should enable transferring token ownership from the seller to the buyer or a new owner, ensuring the transfer only occurs post-sale finalization to maintain correct and secure ownership changes.",
        "url": 699
    },
    {
        "nl_input": "The query requires functionality that allows both the contract owner and a designated revoke address to update the revoke address, with restrictions preventing the revoke address from being set to the owner or specific roles like admin or ops. Additionally, the code should have owner-only capability to change the owner address, emitting appropriate events upon these changes.",
        "url": 700
    },
    {
        "nl_input": "The query requires an admin or bankroll-specific function that allows updating or changing the bankroll address within a contract. This includes permission control to restrict the function to authorized roles such as admin or bankroll, ensuring secure access to modify the bankroll address.",
        "url": 701
    },
    {
        "nl_input": "The query asks to determine if the current time or a given date falls within an active pre-sale period based on conditions such as pre-sale start and end times, whether pre-sale is enabled, and if there is pre-sale amount remaining. It requires checking boolean states that signify whether pre-sale is currently active or ongoing.",
        "url": 702
    },
    {
        "nl_input": "The query requires functionality that allows a director to open or initiate a contribution-related process or event. Specifically, it needs a mechanism where a director role can change a state from closed to open, enabling contributions or sales to proceed. The method should include appropriate access control to restrict it to the director and return confirmation of success.",
        "url": 703
    },
    {
        "nl_input": "The query requires a function or contract snippet involving the creation, update, or handling of a cloned token's address. Specifically, it seeks code that assigns, returns, or updates the address of a cloned token contract, including creating cloned token instances or changing addresses related to token management.",
        "url": 704
    },
    {
        "nl_input": "The query requires a smart contract feature that enables the contract owner to trigger self-destruction (selfdestruct) after a certain condition or time and ensures any remaining funds or tokens held by the contract are securely transferred to the owner upon destruction. This includes a selfdestruct method restricted to the owner, a time or condition check for allowing selfdestruct, and transferring all contract balance or token holdings to the owner before selfdestruct executes.",
        "url": 705
    },
    {
        "nl_input": "The query requires a function allowing the economic reserve wallet to claim vested tokens from a token reserve, subject to time locks and vesting stages. The function must verify the caller is the economic reserve wallet, check the current vesting phase, calculate total unlocked tokens accordingly, ensure the claimed amount does not exceed allocations, update claimed tokens, transfer the calculated payment, and emit a distribution event.",
        "url": 706
    },
    {
        "nl_input": "The query requires a function that transfers a specified amount of raised funds from the current contract balance to a company's address. The function should ensure the caller's authorization (such as only the owner), verify the transfer amount or balance, and execute the transfer to the designated company address securely, handling possible errors or exceptions. It should update balances accordingly and emit relevant transfer events to confirm the transaction.",
        "url": 707
    },
    {
        "nl_input": "The query needs a helper function that converts an asset's valuation into a corresponding quantity of ART tokens. This involves calculating the amount of ART tokens equivalent to a given asset valuation, using the ART token price and adjusting for decimal precision and price oracle factors to ensure accurate valuation conversion.",
        "url": 708
    },
    {
        "nl_input": "The query requires a function that retrieves an object or record using an identifier as input and returns its details, specifically including the ID and the owner or associated address. This involves accessing a mapping or collection by the provided ID to obtain and return relevant data fields tied to that ID.",
        "url": 709
    },
    {
        "nl_input": "The query requires a function that counts and returns the total number of ELHT tokens or items tracked by a smart contract, similar to how other contracts return counts of games, coins owned by an address, or voters. This involves accessing the length of an array or collection representing ELHT tokens within the contract and returning that count as a uint value.",
        "url": 710
    },
    {
        "nl_input": "The query requires a function that initializes or sets up a user upon their first visit by assigning initial resources, map coordinates, and updating relevant counters or states to represent the user's starting status in the system.",
        "url": 711
    },
    {
        "nl_input": "The query requires a method that allows users holding old proxy tokens to swap them for new tokens at a fixed ratio of 1:2. This function should verify the user has a positive balance of old tokens, transfer these old tokens from the user to the issuing token owner, ensure the user's old token balance is zero afterward, then credit the user with twice the amount of new tokens in exchange, and emit an event to record the swap details.",
        "url": 712
    },
    {
        "nl_input": "The query requires a function that facilitates purchasing tokens directly from sellers by transferring tokens for sale, handling partial or full token buyouts from multiple sellers, calculating purchase prices after commissions, updating token ownership and sale amounts, and managing payment transfers to previous owners, including error handling for failed payments.",
        "url": 713
    },
    {
        "nl_input": "The query requires handling token amounts with precise decimal consideration, specifically using 18 decimals for Ethereum's smallest unit (wei) and no decimals for NSP tokens. It involves calculating token quantities based on wei input, applying tiered rates depending on the wei amount, and ensuring accurate multiplication and division aligned with Ethereum's decimal standards. The calculation must adjust token output based on specified rates and consider different tiers or conditions for rate application.",
        "url": 714
    },
    {
        "nl_input": "The query requires a function that allows removing an admin from a list of administrators. This function should ensure the specified admin exists, update the admin status to false or delete it, and adjust the admins list accordingly. The removal process may include access control checks such as verifying the caller is an admin and preventing self-removal. The function should cleanly update related data structures and optionally emit an event indicating the admin removal.",
        "url": 715
    },
    {
        "nl_input": "The query requires a function or mechanism in a smart contract that verifies or confirms an address, indicating that the address has been validated or approved. This typically involves a way to mark or toggle the verification status of an address, ensuring only authorized entities (like the contract creator) can change this status. The focus is on maintaining and indicating the verified state of an address within the contract.",
        "url": 716
    },
    {
        "nl_input": "The query requires a Solidity function modifier named \"onlyOwner\" that restricts function execution exclusively to the contract owner by verifying the caller's address matches the owner's address. The modifier should use a require statement to enforce this condition, allowing the function to proceed only if the sender is the owner.",
        "url": 717
    },
    {
        "nl_input": "The query requires calculating or retrieving the total number of tokens, specifically focusing on obtaining the total token supply or total token count within a smart contract. The goal is to find a function or method that returns the total number of tokens available or created.",
        "url": 718
    },
    {
        "nl_input": "The query requires a function that retrieves the type of a given token address, distinguishing between long and short tokens. Specifically, it needs a method that accepts a token address as input and returns an associated token type identifier, typically represented as an unsigned integer.",
        "url": 719
    },
    {
        "nl_input": "The query requires a function to verify if a specified owner holds at least a given number of shares in a particular company. The function should accept the company ID, owner address, and the minimum share amount as inputs and check that the owner's share count in that company is equal to or exceeds the provided amount. This verification should enforce a requirement to ensure ownership sufficiency before proceeding.",
        "url": 720
    },
    {
        "nl_input": "The query requires a method to determine whether an ICO (Initial Coin Offering) is currently active. This involves checking the ICO's status or timing to confirm its active state. The solution may include a function indicating the ICO status is set to active, or a timestamp-based function that returns true if the current time is within the ICO start and finish times. The main goal is to verify the ICO's active status accurately.",
        "url": 721
    },
    {
        "nl_input": "The query requires checking whether the token burning process was successful or not. This involves functions that perform the burning of tokens, ensure the burn action is authorized (e.g., only owner or allowed burners), and return a status indicator (such as a boolean true/false or a status code) to confirm if the burn operation was executed successfully.",
        "url": 722
    },
    {
        "nl_input": "The query requires a smart contract feature that enables a \u0110App to accept Bitcoin transfers. Specifically, it involves a function to invest or receive Bitcoin funds linked to an Ethereum address, facilitating Bitcoin deposits within the \u0110App environment. This requires handling Bitcoin-related transactions or investments directly through the smart contract interface.",
        "url": 723
    },
    {
        "nl_input": "The query requires a function that calculates and returns the total number of tokens that have vested up to the current time, based on vesting schedules. This includes computing elapsed time against vesting periods and determining the proportion of tokens vested accordingly. The solution should output the vested token amount as a numerical value, reflecting how many tokens are currently available or unlocked from a vesting contract.",
        "url": 724
    },
    {
        "nl_input": "The query requires a function to calculate token amounts from given ether values denominated in wei (18 decimal places), considering different exchange rates for tiers of ether amounts. The calculation must handle large decimal precision (18 decimals for ETH, 2 decimals for the token NVT). It involves converting wei amounts to token units accurately according to specified rates or tiers, ensuring precise multiplication and division by ether's 10^18 base unit.",
        "url": 725
    },
    {
        "nl_input": "The query requires functionality that checks if an order is expired and throws an error if it is. Specifically, it needs a mechanism to verify that the current time is within the valid expiration period of the order and to prevent further actions when the order has expired.",
        "url": 726
    },
    {
        "nl_input": "The query requires a smart contract function that allows users to buy tokens with Ether and ensures the Ether is refunded if the token purchase request is rejected or partially fulfilled. Specifically, it should handle conditions where the token amount exceeds the cap, mint tokens accordingly, transfer the purchased Ether to a beneficiary, and automatically return any excess Ether to the buyer. This mechanism safeguards the buyer\u2019s funds when the token sale cannot process the full Ether payment.",
        "url": 727
    },
    {
        "nl_input": "The query requires functionality to transfer specific token amounts between user balances within a contract's internal balance mapping. It should securely update balances by subtracting tokens from the sender's allocation and adding them to the recipient's, ensuring proper authorization and successful transfer events. The focus is on manipulating a nested balance structure indexed by token and user addresses to facilitate token movements within the system's internal ledger.",
        "url": 728
    },
    {
        "nl_input": "The query requires an internal function within a smart contract that manages ether transactions, specifically handling the withdrawal of ether. The function should include safety checks on the withdrawal amount, update internal balances accordingly, and transfer ether to the caller's address. The focus is on securely managing ether withdrawals tied to user balances within the contract.",
        "url": 729
    },
    {
        "nl_input": "The query requires modifying an ERC20 token transfer function by wrapping it with an \"activated\" modifier. This involves implementing a transfer function adhering to the ERC20 standard and ensuring it can only be executed when a specific condition, enforced by the activated modifier, is met. The goal is to add an activation control layer around the token transfer operation for enhanced access or state-based control.",
        "url": 730
    },
    {
        "nl_input": "The query requires a method to perform fixed-point multiplication of two large unsigned integers x and y, shifting and dividing by 2^128 to adjust the scale. It involves breaking inputs into high and low 128-bit parts, multiplying them accordingly, shifting results, and safely adding intermediate values while ensuring no overflow. The operation essentially calculates (x * y) / 2^128 with overflow checks and safe arithmetic operations.",
        "url": 731
    },
    {
        "nl_input": "The query requires a function that performs a post-ICO check once the sale is closed and minimum ICO tokens are sold. It should distribute 10% of the total token funds received to the company to cover operating expenses after meeting sale and usage deadlines, and allocate the remaining 90% to the company. This function must ensure authorized callers only and manage different remuneration stages, updating balances and handling potential transfer failures.",
        "url": 732
    },
    {
        "nl_input": "The query requires identifying a contract function that is declared separately so it can be accessed and used by derived contracts as well as the base contract. The function should have a visibility scope that supports inheritance (e.g., public or internal) and be designed to be overridden or called by child contracts, ensuring modular and extensible contract architecture.",
        "url": 733
    },
    {
        "nl_input": "The query requires functionality to set and store the IPFS hash of a couple's image on a blockchain contract. The system needs a method restricted to the owner that updates an imageHash variable with the provided IPFS hash, and logs or triggers an event recording the timestamp and details of the image entry as a major marriage event.",
        "url": 734
    },
    {
        "nl_input": "The query requires a mechanism to handle finalization of a funding process by either executing funds if the minimum funding goal is reached or enabling refunds if not. This involves checking funding status, closing the vault to execute funds when successful, or enabling refund mode to allow investors to reclaim their investments on failure. The solution should include functions to finalize funding, trigger refunds to investors, and control refund states securely.",
        "url": 735
    },
    {
        "nl_input": "The query requires a smart contract function that enables the contract owner to start or stop trading by toggling a trading status variable. It must include ownership restriction to ensure only the owner can perform these actions, allowing control over the trading state (start or stop) through a single function.",
        "url": 736
    },
    {
        "nl_input": "The query requires functionality to modify and update game-related parameters within a smart contract. This includes validating active game instances and allowing authorized entities to change game settings such as maximum limits or updating the game contract address. The focus is on secure, controlled tweaks to maintain or change the state and properties of a game within a blockchain environment.",
        "url": 737
    },
    {
        "nl_input": "The query requires a function allowing users to purchase outcome tokens from a market maker during the MarketFunded stage. This involves calculating the total cost including fees, ensuring it does not exceed a maximum limit, transferring collateral tokens from the buyer to the contract, buying all outcome tokens from the event contract, and transferring the specified amount of outcome tokens to the buyer. It also updates the net outcome tokens sold and emits a purchase event.",
        "url": 738
    },
    {
        "nl_input": "The query requires a function to manage user withdrawals specifically during the third stage of a process. It should enforce stage restrictions, ensuring withdrawals only happen at the correct stage, verify eligibility or completion status before processing, calculate the withdrawal amount including any bonuses, and securely transfer funds to the user or designated recipient. The function should also handle errors appropriately and optionally log the withdrawal event.",
        "url": 739
    },
    {
        "nl_input": "The query requires a smart contract design that permits self-upgrade (self-upgrading) capabilities for smart contracts (SCs) at any time, including after a lockdown state. This means SCs should always be allowed to upgrade themselves, even if a lockdown or lock mechanism that restricts certain actions is in place. The upgrade function should enable changing the contract address or logic while bypassing or overriding any lock or restriction conditions.",
        "url": 740
    },
    {
        "nl_input": "The query requires a function within a smart contract to update or set the whitelist contract address. The function should restrict access to authorized roles, validate the new address is not zero, and then assign the new whitelist contract address to the contract's whitelist variable. This ensures the whitelist contract can be updated securely and only by permitted operators or owners.",
        "url": 741
    },
    {
        "nl_input": "The query requires a function that transfers tokens owned by the contract itself to another address. It should enable the contract to send or move its own token balance to a specified recipient, ensuring proper authorization and balance updates during the transfer process.",
        "url": 742
    },
    {
        "nl_input": "The query requires a function that enables transferring tokens on behalf of another address, specifically sending a specified amount of tokens (_value) from the sender's address (_from) to a recipient address (_to). The function should handle updating balances accordingly and ensure the transfer adheres to any necessary restrictions or allowances. The main focus is the \"transferFrom\" functionality to authorize and execute token transfers between third-party addresses.",
        "url": 743
    },
    {
        "nl_input": "The query requires a uint256 value representing the number of tokens obtainable for a given amount of wei (Ether), ideally through a function that calculates token quantity based on wei input and may also return any excess wei. The focus is on determining how many tokens one can receive for a specified Ether amount.",
        "url": 744
    },
    {
        "nl_input": "The query requires a function that returns the composition price associated with a specific token ID. It should accept a token ID as input and provide the corresponding composition price stored or calculated for that token. The focus is on retrieving the price value linked directly to the given token identifier.",
        "url": 745
    },
    {
        "nl_input": "The query requires a function that enables opening or starting trading access for everyone by authorized roles, typically through a public or external function with access control (e.g., onlyAdmin or onlyOwner). This function should set a trading state variable (like tradingOpen or tradingStarted) to true, thereby allowing public or general market participation without restrictions.",
        "url": 746
    },
    {
        "nl_input": "The query requires a function that verifies if a given document is a certification associated with a student address and that this verification is a paid feature, meaning the function call requires paying a fee to access the confirmation result.",
        "url": 747
    },
    {
        "nl_input": "The query requires functionality to enable or activate a sale phase before the main sale, specifically a \"pre-sale\" or \"before sale\" period. The code should include a mechanism to set or toggle the pre-sale state, check if the pre-sale is currently active based on time constraints and an enable flag, and enforce restrictions or access controls around this sale-enabling feature.",
        "url": 748
    },
    {
        "nl_input": "The query requires functionality that allows refunding ETH to specified destination addresses. This involves transferring Ether back to users, either individually or in batches, ensuring proper authorization and validation. The refund process should handle updating balances or records to prevent double refunds and support sending specified amounts of ETH securely to one or multiple addresses.",
        "url": 749
    },
    {
        "nl_input": "The query requires managing or verifying the state of a contract or process, specifically focusing on changing or checking states such as enabling or disabling distributors, ensuring a certain release or funding state before proceeding, and restricting actions when a particular state, like \"finished,\" has not been reached. It involves state checking with conditions and modifying the state within controlled functions or modifiers.",
        "url": 750
    },
    {
        "nl_input": "The query requires a function that returns the number of signers associated with any given function, essentially providing a count of signatures or approvals for that function. This involves tracking proposals or actions and retrieving the current count of signers or signatures linked to a specific function identifier. The solution should be able to access stored data about proposals and return a numeric count representing how many signers have approved or signed off on that function.",
        "url": 751
    },
    {
        "nl_input": "The query requires verification of whether a token address is set within a smart contract. The relevant code involves functions or modifiers that set, update, or check the token address variable, ensuring it is properly initialized and accessible. This includes conditions preventing resetting the token address once set and checks to confirm the address is non-zero before usage. The description focuses on managing and validating a token address state within the contract.",
        "url": 752
    },
    {
        "nl_input": "The query requires a function that enables purchasing tokens from a reserve by sending Ether. The function should verify the buyer's address is valid, ensure the reserve has sufficient tokens, calculate the token amount based on a token price, transfer received Ether to a beneficiary, update token balances accordingly, and emit relevant events confirming the transfer and purchase.",
        "url": 753
    },
    {
        "nl_input": "The query requires a function to update only the stats attribute of an asset, identified by a token ID. This update should replace the existing stats with new values, typically in an array format, while ensuring appropriate access control to restrict who can perform this update.",
        "url": 754
    },
    {
        "nl_input": "The query requires a function that returns the total count of a specific plural noun (\"dicks\") that have existed or been recorded. The function should be publicly accessible for reading (view) and return an unsigned integer representing the length or number of elements in a collection or array named accordingly.",
        "url": 755
    },
    {
        "nl_input": "The query requires a function to create and emit a WorkOrder in a blockchain contract. This involves consuming a market order, locking the associated cost, instantiating a new WorkOrder with detailed parameters (market order index, requester, app, dataset, workerpool, cost, callback, beneficiary), registering the work order, and emitting an activation event through the WorkerPool. The focus is on WorkOrder creation, cost handling, registration, and event emission within a decentralized marketplace framework.",
        "url": 756
    },
    {
        "nl_input": "The query requires a smart contract function that first approves and uses the sender\u2019s entire DAI balance to create a Collateralized Debt Position (CDP). Then, it should generate DAI from the CDP and automatically reinvest this newly created DAI back into the CDP repeatedly. This reinvestment should continue until reaching a specified target liquidation price or meeting a minimum investment amount threshold, ensuring leveraged exposure and optimized collateral use.",
        "url": 757
    },
    {
        "nl_input": "The query requires a function that overrides the _processPurchase function from a Crowdsale contract. This function should internally handle the purchase process by updating a record of tokens deposited to the beneficiary address, typically by adding the amount of tokens purchased to the beneficiary's existing token balance.",
        "url": 758
    },
    {
        "nl_input": "The query requires calculating an additional fee charged on top of a transferred value. This involves retrieving a configured fee amount, checking if the sender is exempt or if the fee is zero, validating that the sent value covers the fee, and then transferring the fee to a specified receiver address. The process ensures the fee is correctly added and enforced during value transfers.",
        "url": 759
    },
    {
        "nl_input": "The query requires a function that loads the ETH balances of all accounts, iterating over each account to retrieve its ETH balance and compiling these into a list or array. Additionally, it should compute the total ETH balance across all accounts and return both the individual balances and the aggregate total.",
        "url": 760
    },
    {
        "nl_input": "The query requires verifying whether a specified amount of an asset or currency has been approved by consulting the Oversight contract. Specifically, it involves checking approval authorization through a validation function in the Oversight address that confirms if the amount for a given currency is approved before spending or further actions are allowed. This validation enforces spending control by asserting approval status within the Oversight contract before proceeding.",
        "url": 761
    },
    {
        "nl_input": "The query requires a function that allocates or mints tokens specifically to investors. The desired function should be restricted to authorized calls (e.g., onlyOwner) and handle a token distribution process by minting or sending a specified amount of tokens directly to investor addresses, ensuring conditions like total supply limits or purchase validations are met to securely transfer tokens to investors.",
        "url": 762
    },
    {
        "nl_input": "The query requires a function that processes a list of transfers with combined data fields, where each element encodes both the recipient address and the amount as a single large number. The function should decode this number into separate address and amount values to efficiently store and manage the transfers. Additionally, it must include checks to ensure data validity and optimize gas usage and storage on the blockchain by minimizing redundant zero values.",
        "url": 763
    },
    {
        "nl_input": "The query requires functionality for allocating or assigning tokens in a smart contract. It involves executing token allocation functions that distribute specified token amounts to addresses, ensuring certain conditions like ownership or initial assignment status. The contract should handle token transfers securely, possibly with access control (e.g., owner-only or paused state checks), and support tracking or recording allocations to prevent reallocation or duplication.",
        "url": 764
    },
    {
        "nl_input": "The query requires determining the amount of tokens that have been approved for transfer from a token holder's address. This involves retrieving the current allowance or approved token amount set for spending by another address. The desired functionality is centered on checking or obtaining the approved token allowance for transfers, reflecting how many tokens can be spent or transferred by an authorized spender under the token approval mechanism.",
        "url": 765
    },
    {
        "nl_input": "The query requires an event handler function that processes the reception of tokens by validating the token source and sender address, updating the total tokens received accordingly. This involves verifying the token contract address, ensuring the sender is correct, and incrementing a total count of tokens received within the contract.",
        "url": 766
    },
    {
        "nl_input": "The query requires a function that allows investors to independently latch or claim FCI by themselves. This involves verifying certain conditions such as the pause status, round status, and user balance before assigning the investor's stake accordingly. The function should enable self-service interaction for investors to latch their FCI without external intervention.",
        "url": 767
    },
    {
        "nl_input": "The query requires functionality to remove an existing certificate authority (CA) from a system, ensuring it can no longer issue new certificates. This involves deleting the CA\u2019s record and emitting an event or log to confirm removal, thereby updating the system\u2019s state to prevent further certificate issuance by that CA.",
        "url": 768
    },
    {
        "nl_input": "The query describes a function that \"throws away your stash,\" implying a method to dispose of or reset stored funds or balances. It likely involves conditions on the amount involved and may include pausing mechanisms, refunds, or immediate disposal actions. The focus is on discarding or flushing stored values, possibly with security checks or owner-only controls, and may relate to transferring, zeroing balances, or self-destructing contracts.",
        "url": 769
    },
    {
        "nl_input": "The query requires a function to withdraw ether by transferring it to a wallet address. It involves securely sending a specified amount of ether from the contract to one or more designated wallet addresses, possibly with ownership restrictions to authorize the withdrawal, ensuring the ether is moved out of the contract to external wallets.",
        "url": 770
    },
    {
        "nl_input": "The query requires a function that returns a boolean value indicating whether a sale is currently active. Specifically, it should provide a true/false status reflecting the current active state of the sale without altering it.",
        "url": 771
    },
    {
        "nl_input": "The query requires a migrate functionality that allows token holders to transfer their token balance to a new contract or system. This involves validating the migration agent address, ensuring the value is positive and within the sender's balance, updating balances and total supply accordingly, recording the amount migrated, and calling the migration agent's migrateFrom function to finalize the migration process. It should also emit an event to log the migration.",
        "url": 772
    },
    {
        "nl_input": "The query requires a contract function enabling the owner or authorized user to withdraw funds. The function should securely transfer a specified amount or the entire contract balance to the caller's address, usually the owner. It may include access control (like onlyOwner) and emit events upon withdrawal. The focus is on securely and properly transferring funds from the contract to a user\u2019s address.",
        "url": 773
    },
    {
        "nl_input": "The query requires a function that calculates and returns the maximum number of existing nomins by adding the nomin pool amount to the total (circulating) supply. This involves accessing both the nomin pool value and the total supply, then summing them to get the combined maximum nomin count.",
        "url": 774
    },
    {
        "nl_input": "The query requires a function that is called after the crowdsale ends to perform additional finalization steps. This includes checks to confirm the crowdsale's end, verification of certain conditions like goals reached or finalization status, executing actions such as transferring funds or enabling refunds, emitting finalization events, and setting a flag to indicate completion. The function should ensure proper closure and settlement of the crowdsale process.",
        "url": 775
    },
    {
        "nl_input": "The query requires functionality to set the paused state of NFTs, allowing authorized users to enable or disable NFT operations by toggling a pause flag. It should include checks to prevent redundant state changes, update the paused status, and emit events to notify about pause state changes. The implementation must restrict this ability to specific roles such as the owner or manager to ensure secure control over pausing NFTs.",
        "url": 776
    },
    {
        "nl_input": "The query requires a function that enables selling outcome tokens to a market maker, ensuring the seller receives a profit exceeding a minimum threshold. It involves calculating the profit minus fees, verifying token transfers from the seller to the contract, executing the sale of all outcomes, transferring the net profit to the seller, and updating the record of tokens sold. The function must also emit an event confirming the sale details.",
        "url": 777
    },
    {
        "nl_input": "The query requires a feature enabling users to perform a free summon once per day. The summon function verifies the caller's address is valid and ensures at least one day has passed since their last free summon. Based on a random value, it determines the hero rank to mint and then summons a hero for the user. This enforces a daily cooldown mechanism to allow free summons while preventing multiple claims within the same day.",
        "url": 778
    },
    {
        "nl_input": "The query requires functionality to authorize a specific address to transfer a particular monster token on behalf of another address using the transferFrom() method. This involves setting or granting permission (an allowed status) for the address from which the monster token can be transferred, enabling controlled third-party transfers through an approval mechanism.",
        "url": 779
    },
    {
        "nl_input": "The query requires a function that generates a unique 12-byte key for a stock by concatenating two 6-byte inputs: the market identifier and the stock symbol. This key uniquely represents the stock by combining both its market and symbol into a single value, facilitating distinct stock identification.",
        "url": 780
    },
    {
        "nl_input": "The query requires a function designed by Pickeringware Ltd that enables users to receive a refund if their KYC (Know Your Customer) analysis fails. This refund function should securely return the invested or contributed amount to the user when certain conditions indicating unsuccessful KYC or sale failure are met, while updating relevant state variables and emitting events to log the refund process.",
        "url": 781
    },
    {
        "nl_input": "The query requires creating a Solidity modifier named to restrict function access exclusively to the Etheraffle address by validating that msg.sender equals Etheraffle. This modifier should be designed for reuse to prepend and enforce this permission constraint on multiple contract functions.",
        "url": 782
    },
    {
        "nl_input": "The query requires a function that allows authorized personnel to set or update the arbitration fee per juror in a contract. The setter should accept a fee value as input, enforce proper access control (e.g., onlyGovernor), and update the arbitrationFeePerJuror variable accordingly. The function is focused specifically on arbitration fees per juror rather than other types of fees.",
        "url": 783
    },
    {
        "nl_input": "The query requires modifying the DINRegistrar contract by implementing or altering a function that allows self-registration of a DIN (Decentralized Identifier Number) with a specified resolver address. This function should enable the sender to register their own DIN linked to the resolver, returning the DIN identifier upon completion. The key focus is on enabling self-registration within the DINRegistrar contract.",
        "url": 784
    },
    {
        "nl_input": "The query requires a function that enables the contract owner to batch transfer tokens from the owner's balance to multiple recipient addresses efficiently. It should accept arrays of recipient addresses and corresponding token amounts, validate matching array lengths, limit batch size, and execute transfers to each address in one operation, ensuring ownership control and secure token distribution from the owner's balance.",
        "url": 785
    },
    {
        "nl_input": "The query requires a function that transitions the contract state to \"TeamWithdraw\" by enabling the TeamWithdraw state. This function should be owner-restricted, verify the current state as NotReady, update the state to TeamWithdraw, emit a corresponding event, initialize or update budget plan details including proposal ID, withdrawal amounts based on a specific rate of the contract balance, timestamps for start, end, and official voting times, and set the current budget plan identifier.",
        "url": 786
    },
    {
        "nl_input": "The query requires functionality to set or assign initial shareholders in a contract. This involves adding new shareholder addresses, ensuring they are valid (not zero or owner), and storing them in predefined shareholder slots until all initial shareholders are set. The process updates the count of shareholders as addresses are added.",
        "url": 787
    },
    {
        "nl_input": "The query requires functionality to modify properties of a gift, specifically updating attributes such as price, description, and a gift URL. This involves verifying the existence of the gift before allowing changes and restricting the update capability to the contract owner. The goal is to enable controlled and secure modification of gift details within a contract.",
        "url": 788
    },
    {
        "nl_input": "The query requires a function to retrieve the locked token amount for investors, with the lockup being released in three batches over time. Specifically, a method to check the investor's locked tokens that unlock progressively in three stages at distinct time intervals (immediate full lockup, then reduced by one-third after 90 days, and further reduced after 180 days) until fully released. This ensures staged token unlocking for investors following a predefined schedule.",
        "url": 789
    },
    {
        "nl_input": "The query requires functionality to reset a bag's level to zero if it hasn't been purchased within a specified timeout period, while maintaining its current owner information. This involves checking the bag's purchase timestamp against the timeout, and if expired, resetting the level but not altering ownership details.",
        "url": 790
    },
    {
        "nl_input": "The query requires implementing an investment function that calculates token purchase amounts based on a defined pricing strategy. This involves using a pricing strategy contract to determine the token price dynamically during the investment process, allowing token amounts to be computed from the invested Ether. Additionally, there should be functionality to set or update the pricing strategy by the contract owner, ensuring flexible and controlled token pricing during investment transactions.",
        "url": 791
    },
    {
        "nl_input": "The query requires functionality to manage both locked and unlocked tokens within a contract, including mechanisms to track, calculate, and transfer vested (unlocked) tokens for users. It should include the ability to unlock vested tokens based on a vesting schedule, updating the transferred amount accordingly, and support locking tokens to prevent transfers until certain conditions are met. The solution must handle token issuance with optional locking reasons and maintain proper state and events for token unlocking and locking actions.",
        "url": 792
    },
    {
        "nl_input": "The query requires a contract function that allows only the owner to set a duration after which a price is deemed outdated or stale. This involves an owner-restricted method to update a time parameter defining the validity period of the price data.",
        "url": 793
    },
    {
        "nl_input": "The query requires a function named \"unpause\" that can only be called by the contract owner to change the contract's state from paused to normal (unpaused). The function should have appropriate access control (onlyOwner) and a condition that ensures it is only callable when the contract is currently paused. Upon execution, the function updates the paused state to false and may emit an Unpause event to signal the state change.",
        "url": 794
    },
    {
        "nl_input": "The query requires a modifier that restricts the purchase of tokens to occur only within a predefined start and end date set at contract creation. This modifier should check the current time and ensure token purchases happen exclusively between these dates, preventing buying before the start or after the end time.",
        "url": 795
    },
    {
        "nl_input": "The query requires a function to purchase tokens during a presale phase. The function should accept a beneficiary address, calculate token amounts based on the presale exchange rate and the payment value, transfer funds accordingly, update token supply and sales records, and emit an event confirming the purchase. The logic must ensure compliance with presale timing, supply limits, and secure token transfers to the buyer.",
        "url": 796
    },
    {
        "nl_input": "The query requires a contract function allowing participants to withdraw their funds if the presale ends without reaching the minimum funding goal. The function must prevent withdrawals before the presale ends and only allow withdrawals if total funding is below the minimum threshold. Additionally, it should verify the participant\u2019s balance suffices for the withdrawal and securely send the withdrawn amount back to the participant.",
        "url": 797
    },
    {
        "nl_input": "The query requires a function enabling a user to claim all tokens vested up to the current date, reflecting the cumulative vested amount based on elapsed time. This involves calculating the total vested tokens available to the user at the present date and allowing them to release or transfer these tokens in a single action. The functionality should enforce any necessary time restrictions and update the vesting state accordingly during the claim process.",
        "url": 798
    },
    {
        "nl_input": "The query requires a function that allows only the contract's owner, minter, or creator to mint new coins. The minting process must ensure that the sender of the minting message is authorized as the owner or designated minter. This function should increase the total coin supply and update the owner's or specified address's balance accordingly, enforcing appropriate access control to prevent unauthorized minting.",
        "url": 799
    },
    {
        "nl_input": "The query requires a function that determines whether the crowdsale has started by checking if the current block number has reached or passed the predefined start block number. This involves comparing the blockchain's current block number with the crowdsale's start block to confirm if the sale period has begun.",
        "url": 800
    },
    {
        "nl_input": "The query requires a function that verifies the validity of a transcoding options string by ensuring its length is greater than zero and is a multiple of a specific predefined size constant (VIDEO_PROFILE_SIZE). This validation confirms the string's formatting and suitability for transcoding settings.",
        "url": 801
    },
    {
        "nl_input": "The query requires a function that sets the points for all tokens in a range starting from the last processed chunk up to a specified amount. This involves iterating over tokens between lastCalculatedToken and lastCalculatedToken plus the given amount, calculating each token's points, updating a mapping from token IDs to points, and tracking worst-performing tokens. It ensures no overlap beyond the total tokens and updates the lastCalculatedToken pointer accordingly.",
        "url": 802
    },
    {
        "nl_input": "The query requires a function that allows the contract owner to remove or delete a record of a specific foreign token received by the contract. This involves validating the token address is not zero and then deleting the token entry from the received tokens mapping, followed by emitting an event to signal the removal. The functionality focuses on secure and authorized management of tokens the contract has received, ensuring only the owner can perform the removal action.",
        "url": 803
    },
    {
        "nl_input": "The query requires functionality to allow specific addresses to participate early in an event or contract activity. It involves maintaining a whitelist with controls on each address's participation status, minimum contribution (minCap), and maximum contribution (maxCap). The system needs to validate inputs, ensure the address is not zero, enforce timing restrictions (e.g., before a deadline), and track whitelist membership changes securely by an authorized owner.",
        "url": 804
    },
    {
        "nl_input": "The query requires a function to add a wallet address to a collection of additional bonus members, ensuring only the contract owner can perform this action. The wallet should be marked or tracked as active within the additional bonus members' state.",
        "url": 805
    },
    {
        "nl_input": "The query requires creating an auction for a specific deed by specifying the deed ID, starting price, ending price, and auction duration. The function should verify the caller's ownership or authorization, ensure the auction duration meets a minimum limit, escrow the deed, and initialize the auction details including prices, duration, start time, and deed owner before officially creating the auction.",
        "url": 806
    },
    {
        "nl_input": "The query requires a function to add a holder's address to a list of holders, ensuring no duplicates by checking if the holder is already recorded. The process involves appending the new holder to an array and updating a mapping or count to track the holder's position or existence, thus managing a dynamic list of unique holder addresses.",
        "url": 807
    },
    {
        "nl_input": "The query requires a function to verify the existence of an asset by checking if it is created or present. This involves confirming whether a particular asset, identified by a unique symbol or key, exists within a contract's asset registry or data structure. The function should return a boolean value indicating the presence or absence of the asset.",
        "url": 808
    },
    {
        "nl_input": "The query requires a smart contract function that enables the owner or authorized user to withdraw ether from the contract. It should securely transfer ether from the contract balance or specified amount to the owner or designated addresses. Access control (e.g., onlyOwner) is essential to restrict withdrawal permissions. The function may transfer the entire balance or a specified portion and can involve distributing ether to one or multiple addresses.",
        "url": 809
    },
    {
        "nl_input": "The query requires a system ensuring that each pet can only appear on one sponsored leaderboard at a time. This involves maintaining and checking a record that maps each pet's ID to its participation status on leaderboards, preventing duplicates across sponsored lists. Functions should allow querying whether a pet is currently on any leaderboard, enforcing the one-leaderboard-per-pet constraint.",
        "url": 810
    },
    {
        "nl_input": "The query requires reading transfer configuration parameters such as base fee, rate, fee collector address, transfer fee exemption status, and minimum transfer amount. This involves accessing stored transfer settings to retrieve these values, typically via a function that returns the configuration details without modifying the state.",
        "url": 811
    },
    {
        "nl_input": "The query requires a function for transferring tokens that can only be executed by authorized master accounts. The function should handle transferring tokens from one address to another, enforcing access control to restrict this operation solely to master users.",
        "url": 812
    },
    {
        "nl_input": "The query requires a function enabling the contract owner to withdraw a specified amount from the house stake balance. The withdrawal must ensure the remaining house stake does not fall below the minimum required stake for active games and that house profits do not exceed the adjusted stake. The function should enforce owner-only access and transfer the withdrawn value to the owner's address.",
        "url": 813
    },
    {
        "nl_input": "The query requires a function named switchToNextRound that updates the timing and token cap parameters for the upcoming phase in a round-based system. Specifically, it sets the endTime of the current phase to the present time, the startTime of the next phase to shortly after, and its endTime to a defined future time. It also adjusts the tokenCap of the next phase based on the remaining tokens and designates this next phase as the current phase by updating the current phase ID.",
        "url": 814
    },
    {
        "nl_input": "The query requires a function to change the Crowdsale stage by setting it to specific enumerated values (PreICO or ICO). This involves a controlled method, likely restricted to the contract owner, which updates the current stage variable accordingly. The focus is on stage management rather than starting or stopping the crowdsale, emphasizing the ability to switch between different predefined crowdsale phases.",
        "url": 815
    },
    {
        "nl_input": "The query requires a function that returns true if the given parameters are valid by performing comprehensive checks. Specifically, it should verify array lengths are non-zero and equal, ensure array elements follow a strictly increasing order, and validate constraints on parameter values to confirm overall correctness. The function must return a boolean indicating the validity of the input parameters based on these logical conditions.",
        "url": 816
    },
    {
        "nl_input": "The query requires a contract function that allows the contract owner to forcibly take ownership of any top-level domain managed by the contract. This implies a function enabling the owner to transfer domain ownership at will, ensuring control over the domain registry entries tied to the contract. The function should restrict this capability exclusively to the contract owner and directly update the domain ownership records accordingly.",
        "url": 817
    },
    {
        "nl_input": "The query requires functionality related to external functions that manage winery operations, specifically adding winery operations with parameters such as track ID, operation ID, operation code, operation date, area code, and regulatory code, accessible only by authorized wineries. The function should log the addition of operations and use mappings to store winery-related data. The focus is on securely recording and tracking operational details for wineries through smart contract methods.",
        "url": 818
    },
    {
        "nl_input": "The query requires modification of a payday function in a smart contract so that if an employee misses a payday, their owed pay is not lost but instead carried over and added to the next payday. This involves tracking unpaid amounts across pay periods and ensuring cumulative payment upon the next successful payday, rather than resetting or losing the missed payment.",
        "url": 819
    },
    {
        "nl_input": "The query requires a smart contract function that enables a user to sell tokens for ETH, ensuring the user has set an allowance for the contract to transfer their tokens. Before calling the sell function, the user must approve the contract to spend their tokens. The function checks the token amount, transfers tokens from the user to the contract, and sends ETH back to the user accordingly.",
        "url": 820
    },
    {
        "nl_input": "The query requires a function that calculates and returns the amount of tokens based on a given investment amount and a token-to-ETH rate. The calculation should use a token rate or pricing mechanism, potentially involving tiered rates or external rate providers, to convert the invested amount (in wei or ETH) into the corresponding token quantity according to a specified rate or set of rates.",
        "url": 821
    },
    {
        "nl_input": "The query requires a function that subtracts two unsigned integers and reverts the transaction if an overflow occurs during subtraction (i.e., when the subtrahend is greater than the minuend). This ensures the operation is safe by preventing underflow, typically achieved through assertions or require statements. The function should return the correct difference if no overflow happens and revert otherwise to maintain contract security and correctness.",
        "url": 822
    },
    {
        "nl_input": "The query requires a function to permanently lock the maxSupply variable at its current value, preventing any future changes. This involves setting a state variable that indicates the maxSupply is locked and emitting an event to record the lock action. The function should include access restrictions, allowing only authorized users (e.g., contract owner) to execute the lock, ensuring the maxSupply cannot be altered afterward.",
        "url": 823
    },
    {
        "nl_input": "The query requires a function that allows users to claim IBC tokens after the ICO or sale has closed, ensuring the sale stage is correct and the user has a token balance. It should handle conditions like sale stage transitions, token amounts, and potential bonuses based on funding rate predictions during a specific claim window. The function must update balances, distribute tokens, and emit an event confirming the claim.",
        "url": 824
    },
    {
        "nl_input": "The query requires functions to create and activate (enable) special managers. This involves adding a manager's address, validating it is not zero or already active, updating mappings to track manager status and count, and enabling the manager with owner-only permissions and proper event notifications. The process ensures managers can be uniquely identified, activated, and their state securely managed by the contract owner.",
        "url": 825
    },
    {
        "nl_input": "The query requires a contract initialization function that must be explicitly called once after deployment. This function should include checks to restrict access to the contract owner and ensure it is only run once, setting initial state variables and marking the contract as initialized to prevent re-initialization.",
        "url": 826
    },
    {
        "nl_input": "The query requires a function that sends tokens from a controlled wallet address to a specified receiver, ensuring the sender is authorized, the amount does not exceed the available deposit, and the token transfer succeeds before updating the deposit balance.",
        "url": 827
    },
    {
        "nl_input": "The query requires determining if two orders' calldata specifications can match by applying their respective replacement patterns to the calldata and then comparing the resulting calldata for equality. This involves conditionally modifying each calldata using the other's replacement pattern and then checking if the modified calldatas are identical.",
        "url": 828
    },
    {
        "nl_input": "The query requires a function restricted by an onlyOwner modifier that initiates the transfer of contract ownership to a specified new owner address. The function must ensure the new owner address is valid (non-zero) before assigning ownership, thereby delegating control securely and preventing unauthorized access. It should provide a mechanism for the current owner to propose and execute ownership change, effectively transferring contract control rights.",
        "url": 829
    },
    {
        "nl_input": "The query requires a function that returns the balance of a specified account address. The function should take an address as input and output the corresponding balance, typically by accessing and returning the stored value from a mapping or token contract related to that address. This functionality is used to check how much balance a particular account holds in a given token or contract.",
        "url": 830
    },
    {
        "nl_input": "The query seeks functionality related to distributing unpaid dividends to shareholders. The code should include mechanisms for verifying eligibility, calculating each shareholder's dividend based on their shares or contributions, updating dividend records, and transferring the owed dividend amounts securely to users. It should ensure correctness through require/assert checks, handle dividend fund balances, and emit events for transparency. Overall, the requirement is an automated, fair, and secure contract function to pay or withdraw owed dividends to eligible recipients.",
        "url": 831
    },
    {
        "nl_input": "The query requires a function that calculates and returns the percentage of shares a user holds on a specific date. This involves determining the relevant period index from the date, handling cases when the date is zero (defaulting to the current time), calculating the user's share of a total deposit or amount for that period, and expressing this as a percentage value. The user\u2019s share percentage should be accurately derived from deposit amounts or holdings relative to the total for that period.",
        "url": 832
    },
    {
        "nl_input": "The query requires Solidity code snippets useful for debugging in online environments like Remix and sandboxes. It focuses on functions that manage contract state or provide contract data visibility, such as toggling boolean variables with access control, querying user-specific contribution records, and retrieving caller-specific balance information, facilitating interactive inspection and testing of contract behavior during debugging sessions.",
        "url": 833
    },
    {
        "nl_input": "The query requires a modifier that restricts function access exclusively to calls originating from the exchange contract's address, ensuring only the designated exchange contract can invoke those functions.",
        "url": 834
    },
    {
        "nl_input": "The query requires a function that unlocks vested tokens for a grantee by calculating the vested amount, ensuring it is transferable, updating the transferred token count, reducing the total vesting balance, and then transferring the tokens to the grantee\u2019s address. The function should include checks to prevent unlocking if no tokens are vested or transferable and emit an event upon successful token transfer.",
        "url": 835
    },
    {
        "nl_input": "The query requires a function that adjusts a numeric value toward zero by 1.5, likely involving fractional or integer operations rounding or truncation. The code should handle rate calculations or adjustments, ensuring any computed rates or values move closer to zero appropriately, possibly by truncation or rounding mechanisms that approach zero rather than away from it.",
        "url": 836
    },
    {
        "nl_input": "The query requires a function within a smart contract that retrieves the amount of Ether held by the contract. It should be able to distinguish Ether from other tokens and return the contract\u2019s Ether balance specifically. This implies a function that accesses the contract\u2019s native Ether balance rather than token balances, enabling users or other contracts to query how much Ether is currently stored in the contract.",
        "url": 837
    },
    {
        "nl_input": "The query requires functionality to retrieve a contract's address by providing its name. The solution involves a contract containing a mapping of contract names to addresses and a function that takes a contract name as input, verifies the contract exists, and returns the associated contract address.",
        "url": 838
    },
    {
        "nl_input": "The query requires functionality related to managing and accessing internal account balances within a contract. It involves retrieving the balance of the caller, internally setting or updating balances for specific addresses, and possibly toggling balance-related states. The key needs are methods that read balances linked to addresses and internal mechanisms to modify these balances securely within the contract.",
        "url": 839
    },
    {
        "nl_input": "The query requires a function to transfer ownership of a specific SSP record by changing its owner. This involves providing the current owner or authorized caller the ability to assign a new owner to the SSP record identified by a key or address, ensuring proper authorization and validation before updating ownership details in the registry or contract storage.",
        "url": 840
    },
    {
        "nl_input": "The query requires a smart contract function that enables the contract owner to withdraw or transfer Ether from the contract to themselves, effectively allowing the draining of the contract's Ether balance. The function should restrict access to the owner and facilitate sending a specified amount or the entire balance of Ether held by the contract to the owner's address.",
        "url": 841
    },
    {
        "nl_input": "The query requires a function within a smart contract that issues tokens to users based on the amount of Ether they send. It should calculate the number of tokens corresponding to the received Ether, ensuring proper conditions such as minimum purchase amounts and caps. The function must update token balances, record Ether received, mint new tokens to the user, and transfer the received Ether to a designated wallet.",
        "url": 842
    },
    {
        "nl_input": "The query requires a function that appends an unsigned integer, represented in decimal form, to an existing string. This involves converting the uint to its decimal string representation and concatenating it to the original string, resulting in a combined string output.",
        "url": 843
    },
    {
        "nl_input": "The query requires a function callable only by the owner after the contribution period has ended, which distributes a specific token (DNT) proportionally to contributors based on their contribution amounts. The function verifies that the distribution is enabled and the contribution period has ended, iterates through contributors with offset and limit parameters to process batches, marks contributors as compensated, calculates their proportional token share, transfers the tokens to them, and emits an event upon compensation.",
        "url": 844
    },
    {
        "nl_input": "The query requires a function that allows authorized users to revoke the privilege of a \"destroyer\" by removing their status from an approved list. This involves checking that the address is currently recognized as a destroyer, updating the list and related mappings, reducing the count accordingly, and emitting a removal event or log. The function should ensure that only designated roles can execute the removal and must maintain data integrity in the destroyers' collection.",
        "url": 845
    },
    {
        "nl_input": "The query requires a function that allows an account to submit a higher bid specifically on a token. The function should verify that the new bid is greater than the existing highest bid on the token, ensure the bidder is not the token's owner, handle any previous bid amounts by refunding or storing them, update the highest bid and bidder information accordingly, and emit an event to notify about the new highest bid on the token.",
        "url": 846
    },
    {
        "nl_input": "The query requires retrieving the balance of the Faucet, specifically the amount of tokens held by the Faucet contract. This involves accessing the token balance via a function that calls the ERC20 token's balanceOf method on the Faucet's address or contract. The focus is on obtaining the Faucet's token balance, not the contract's native currency balance or an arbitrary user's balance.",
        "url": 847
    },
    {
        "nl_input": "The query requires functionality to set or update the price of the EXH Token, ideally allowing for dynamic price adjustments during different sale stages such as pre-ICO and ICO. The system should maintain current token price state, handle price changes with appropriate checks, and enable authorized entities (e.g., the contract owner) to set or update price rates securely. It should also provide notifications or events when the token price is updated.",
        "url": 848
    },
    {
        "nl_input": "The query requires a function that calculates the total payout amount for each prize tier using the odds method. Specifically, it should multiply the number of winners in that tier by the odds payout per winner to determine the total payout for the tier. The function should handle tier-based payout calculations internally and return the cumulative prize amount allocated for that tier accordingly.",
        "url": 849
    },
    {
        "nl_input": "The query requires a smart contract function that enables the contract owner to withdraw a specified amount of ether from the contract's balance and transfer it to the owner's address. The function should include ownership access control to restrict withdrawals to the owner only and ensure the contract has sufficient balance before the transfer. Optional event logging of the withdrawal may be included.",
        "url": 850
    },
    {
        "nl_input": "The query requires allowing a caller to create an original artwork by providing a genome (bytes32). The solution should include a function that takes the genome and an owner address, assigns ownership (defaults to sender if none specified), enforces limits or fees under certain conditions, and invokes an internal function to create the artwork with the given genome. The focus is on enabling original artwork creation linked to a unique genome input.",
        "url": 851
    },
    {
        "nl_input": "The query requires a function to transfer tokens between addresses. The function should handle token balance adjustments, check necessary conditions like permissions or token availability, and record the transfer event. It may involve transferring tokens on behalf of others or direct transfers, ensuring security constraints such as ownership or tradeability are enforced. The function should return a success indicator after completing the token transfer process.",
        "url": 852
    },
    {
        "nl_input": "The query requires a function that returns the index of a specified element in an array. It should accept positional arguments and check if the given position is within the array bounds. If the position is outside the valid range, the function must throw an error to prevent out-of-bounds access. The function focuses on validating input indices and providing accurate indexing for a two-dimensional array represented in a one-dimensional form.",
        "url": 853
    },
    {
        "nl_input": "Extract 20 consecutive bytes from a given bytes array starting at a specified index, and return this slice as a fixed-size 20-byte data type.",
        "url": 854
    },
    {
        "nl_input": "The query requires a function modifier that verifies whether the message sender (msg.sender) matches a specific address. This address can be either retrieved dynamically from a contract resolver using an identifier or be a fixed known address. The modifier should use a require statement to enforce this check before allowing function execution to proceed.",
        "url": 855
    },
    {
        "nl_input": "The query requires a function that returns an array or tuple containing the counts of different weapon types in an army. Specifically, it should provide the quantity of drones, planes, helicopters, and tanks belonging to a given army identified by its ID. The returned data structure should include all these weapon counts together, enabling retrieval of the entire weapon composition of the specified army.",
        "url": 856
    },
    {
        "nl_input": "The query requires a contract function that allows the owner to set the PriceSetter address, which is authorized to set the price of a single token in wei. This function must restrict access to only the owner and ensure the new address is properly assigned for managing token pricing.",
        "url": 857
    },
    {
        "nl_input": "The query requires a function named \"withdraw\" or similar that enables users to withdraw tokens after certain conditions are met. It should verify states like sale closure or finalization, ensure the caller has a positive token balance, update the balance post-withdrawal, and then transfer or deliver the tokens to the caller. The function should handle secure token transfers and include necessary access or state checks to prevent unauthorized or premature withdrawals.",
        "url": 858
    },
    {
        "nl_input": "The query requires a mechanism to prevent users from placing the same bet more than once on the same match with the same betting amount. This involves tracking each bettor's previous bets by match ID and bet price, and checking for duplicates before accepting a new bet. If a duplicate bet is detected, the system should reject it to ensure that no repeated bets are submitted by the same user for the same match and amount.",
        "url": 859
    },
    {
        "nl_input": "The query requires a function that multiplies two unsigned integers x and y, returning their product while ensuring safety by detecting and throwing an exception if an overflow occurs during multiplication.",
        "url": 860
    },
    {
        "nl_input": "The query requires a Solidity modifier, a special function that executes before the function it decorates. This modifier performs a pre-condition check using a require statement to enforce certain rules (e.g., time constraints or state conditions) before allowing the function's main logic to execute.",
        "url": 861
    },
    {
        "nl_input": "The query requires a system ensuring that each angel can only be assigned to one sponsored leaderboard at any given time. This involves tracking angel participation on leaderboards and enforcing uniqueness constraints so no angel appears on multiple sponsored leaderboards simultaneously. The solution must provide a method to check if a specific angel is currently on a leaderboard and implement logic that prevents angels from being on more than one sponsored leaderboard concurrently.",
        "url": 862
    },
    {
        "nl_input": "The query requires a function that calculates and returns the maximum available amount that can be taken from an order. This involves considering the order\u2019s total taker token amount, the amount already filled, and the maker's token balance in the vault proportionally adjusted based on the order\u2019s token amounts. The function must ensure the returned amount does not exceed these constraints, reflecting the maximum feasible portion of the order that can still be fulfilled.",
        "url": 863
    },
    {
        "nl_input": "The query requires a function that enables a developer or authorized wallet to withdraw a specified amount from a contract, distributing the withdrawn funds equally among all contract owners. The withdrawal should include safeguards such as permission checks, calculate an equal share per owner, transfer the funds individually, and emit an event recording the total and per-person withdrawal amounts.",
        "url": 864
    },
    {
        "nl_input": "The query requires a function within a contract that attempts to transfer coins and throws an error on any failure instead of returning false, to reduce user errors. The function must include standard checks and explicitly throw if transfers are disabled, ensuring robust error handling rather than silent failure flags during coin transfers.",
        "url": 865
    },
    {
        "nl_input": "The query requires a contract function to set a minimum Wei amount, defaulting to 1000 Wei. The function should be restricted to the contract owner, only callable when not paused, and enforce that the new minimum is positive and a multiple of 10. When the value changes, it must emit an event logging the old and new minimum amounts along with the caller's address, returning a boolean indicating success.",
        "url": 866
    },
    {
        "nl_input": "The query requires a function or method that retrieves the current round information, specifically the address or data related to the current round in the context of a game or a token sale. The solution should identify and return the current round based on relevant conditions or state, such as matching indices or ranges, enabling access to the current round when applicable.",
        "url": 867
    },
    {
        "nl_input": "The query requires a function to publish an article by validating the sender's ownership, limiting token usage per article, ensuring a minimum time gap between publishes, and checking for duplicate articles. Upon successful validation, it should record the article's hash, associate a key hash, update timestamps, track the number of articles published, manage remaining tokens, and emit corresponding results or errors.",
        "url": 868
    },
    {
        "nl_input": "The query requires a function that allows only the contract owner to enable or start token transfers by changing a transfer status variable to true. This function must be restricted to the owner and should activate transfers when called, potentially including additional steps like handling token burning or approvals.",
        "url": 869
    },
    {
        "nl_input": "The query requires a function that attempts to remove an admin address and returns true if the removal is successful. The function should validate that the provided admin address is valid, currently holds admin status, and is not the caller. Upon successful validation, the admin status is revoked or deleted, and the function returns a boolean true indicating success.",
        "url": 870
    },
    {
        "nl_input": "The query requires a function that permits the pendingAdmin address to complete the admin change process by validating the caller is pendingAdmin, updating the admin to pendingAdmin, resetting pendingAdmin to zero, and emitting an event to signal the admin claim.",
        "url": 871
    },
    {
        "nl_input": "The query requires a method to verify whether a token transfer destination is valid before completing the transfer. It involves implementing a check, typically within the contract, to confirm if transferring tokens from one address to another is permitted based on predefined rules, conditions, or external logic contracts. This ensures that token transfers adhere to allowed constraints, preventing unauthorized or invalid transfers to certain addresses.",
        "url": 872
    },
    {
        "nl_input": "The query requires functionality to update the status of a minting agent by changing their permission to mint tokens. This involves a function that allows an authorized entity (typically the contract owner) to enable or disable minting rights for a specific address, effectively managing which agents can mint new tokens in the contract.",
        "url": 873
    },
    {
        "nl_input": "The query requires a function or method to return the total number of tokens currently available for purchase. This involves calculating how many tokens remain unsold or can still be bought during an active sale or phase. The solution should consider sale period constraints, supply caps, and current price or phase-based availability limits to determine the exact number of tokens that can be bought right now.",
        "url": 874
    },
    {
        "nl_input": "The query requires a function where, after a day delay, the admin finalizes the change of ownership by verifying the admin's identity, ensuring the waiting period has passed (defer block), and transferring ownership of various dependent contracts or resources to the new owner, followed by clearing the transfer operation's data.",
        "url": 875
    },
    {
        "nl_input": "The query requires a function that stakes a specified token amount by transferring that exact amount from the caller's address. This function must ensure the transfer operation originates from the caller and successfully moves the given token quantity to another party or contract, effectively reducing the caller's token balance by the staked amount. It should include checks to confirm transfer permissions and validate that the amount does not exceed available tokens.",
        "url": 876
    },
    {
        "nl_input": "The query requires a function that allows a user to place a bid in an auction by sending a payment. The function should check that the auction is still ongoing and that the bid value is higher than the current highest bid. If there is a previous highest bidder, their bid amount should be returned to them. The function should then update the highest bidder and highest bid records accordingly and emit an event signaling the bid increase.",
        "url": 877
    },
    {
        "nl_input": "The query requires a function to approve a proxy (spender) to spend a specified amount of tokens on behalf of the message sender. The function should update the allowance mapping to set the allowed amount for the spender and emit an Approval event indicating the owner, the spender, and the authorized token amount. This approval mechanism enables delegated token spending rights from the token owner to the designated proxy.",
        "url": 878
    },
    {
        "nl_input": "The query requires a contract function that allows only the owner to update the token-related rate or price, such as the tokens per Ethereum rate or reward rate. This function should restrict access to the owner and enable modification of a token rate parameter, ensuring the contract owner can adjust token valuation or reward rates securely.",
        "url": 879
    },
    {
        "nl_input": "The query requires a function that compares two numerical amounts and throws an exception if they are not equal, ensuring strict equality validation by reverting the transaction when a mismatch occurs.",
        "url": 880
    },
    {
        "nl_input": "The query requires creating a new proxy contract associated with an owner and a recovery key. The solution should involve deploying a proxy instance, setting the owner and recovery addresses, validating the recovery key, and logging the creation event. The contract must ensure secure initialization and management of ownership and recovery roles within the proxy to allow future recovery or control transfers.",
        "url": 881
    },
    {
        "nl_input": "The query requires a description of a highly risky function that should only be used in extreme situations, implying it might perform critical operations with potential for serious consequences or failure. The focus is on highlighting the function's dangerous nature and the necessity for cautious use, likely involving operations that could cause errors, security issues, or irreversible changes if misused.",
        "url": 882
    },
    {
        "nl_input": "The query requires a function that allows changing or updating the successor address, ensuring the new successor is valid (non-zero address), and restricting this action to an authorized role such as an admin or owner. The function should securely assign the new successor to a state variable while including appropriate access control and validation checks.",
        "url": 883
    },
    {
        "nl_input": "The query seeks to determine the profit amount related to a contract function. The requirement is to calculate or retrieve the profit or profit share, typically by comparing costs or shares before and after a transaction or event. The code should involve functions that compute profit values, handle shares, or return the amount of profit earned or distributed to a member or participant.",
        "url": 884
    },
    {
        "nl_input": "The query requires a function to verify if a specific customer's transaction payment for MCW (Metered Consumption Wallet) has already been spent. This involves checking a transaction registry to determine if the payment timestamp associated with the given transaction ID is non-zero, indicating the payment has been recorded as spent. The function should return a boolean value reflecting whether the payment has been used or not.",
        "url": 885
    },
    {
        "nl_input": "The query requires setting the free memory pointer in a smart contract to point just beyond the currently accessed memory, ensuring no overlapping memory usage. This is typically done by updating the memory pointer at the special address 0x40 (free memory pointer) to the current highest memory offset, such as the size returned by msize, using inline assembly for precise memory management in Solidity.",
        "url": 886
    },
    {
        "nl_input": "The query requires a mechanism to quickly verify the completion or expiration of Round1 only once. This involves checking if the current funding round has exceeded Round1's cap, then transitioning the state from Round1 to Round2, and resetting the round counter, all performed solely for the first funding round without repeated checks.",
        "url": 887
    },
    {
        "nl_input": "The query requires a function to remove an address from a whitelist by setting its whitelist status to false. The function should be publicly accessible only by the contract owner and take an address as input to update the whitelist mapping accordingly, effectively revoking the address's whitelist privileges.",
        "url": 888
    },
    {
        "nl_input": "The query requires handling a costly combat process by allocating sufficient gas to cover its expensive execution. The focus is on ensuring enough gas is provided to avoid failures during the combat-related transaction processing.",
        "url": 889
    },
    {
        "nl_input": "The query requires functionality that allows withdrawing accumulated balance or funds from a contract, transferring them to a owner or user, and also includes sharing or managing a pooled amount (pot). The focus is on securely handling withdrawals of either the contract\u2019s overall balance or specific tokens and ensuring that only authorized parties can initiate these transfers.",
        "url": 890
    },
    {
        "nl_input": "The query requires implementing air delivery functions in the BioX contract that use token counts instead of wei amounts for value transfers. Specifically, all air delivery-related methods must operate on token counts (actual token units) rather than on wei (the smallest Ethereum currency unit), ensuring calculations and balance adjustments are based on token quantities rather than ether denominations.",
        "url": 891
    },
    {
        "nl_input": "The query requires functionality that allows qualified crowdsale partners to purchase Star Tokens. This involves a function that is restricted to qualified partners, accepts payments, updates the amount raised by each partner within their allowed cap, calculates token amounts based on an exchange rate, records the purchase, and handles partner commission fees if applicable. The mechanism ensures only authorized participants can buy tokens during the crowdsale, enforcing participation constraints and proper accounting of token purchases.",
        "url": 892
    },
    {
        "nl_input": "The query requires a Solidity modifier named \"onlyOwner\" that restricts function execution exclusively to the contract owner. This modifier should use a require statement to check that the caller's address (msg.sender) is equal to the owner's address, allowing the function to proceed only if this condition is met.",
        "url": 893
    },
    {
        "nl_input": "The query requires checking the contract size of an ERC223 token to determine if an address is a nonzero-sized contract, indicating it is a valid contract. This involves fetching the token balance and verifying that the contract size is greater than zero, confirming the target address is indeed a deployed contract rather than an externally owned account or zero address. The logic must ensure the balance or contract code size is nonzero to validate contract existence.",
        "url": 894
    },
    {
        "nl_input": "The query requires calculating the compounded interest output based on a given principal input amount and a specified number of payout periods. It involves repeatedly applying interest over multiple intervals to grow the initial amount and then adjusting the result by subtracting a percentage tax on exit. The calculation should consider the compounding effect, applying interest rate multipliers each payout period before factoring in tax deductions.",
        "url": 895
    },
    {
        "nl_input": "The query requires computing the winners of the second round by comparing all winners from the first round. This involves evaluating each pair of first round winners based on attributes (e.g., heroPower) and a probability factor (random number), then determining and storing the second round winners accordingly. The process should handle multiple pairs and decide winners for each matchup to generate the complete list of second round winners from the first round victors.",
        "url": 896
    },
    {
        "nl_input": "The query requires a function that determines whether the current round is within its lock period. This involves calculating a lock duration based on a portion of the total round length and comparing the elapsed blocks since the round's start to identify if the round is still locked. The solution should provide a boolean status indicating whether the lock period is active in the current round.",
        "url": 897
    },
    {
        "nl_input": "The query requires functionality to reset a purchaser's purchase limit after a specified time window has elapsed. Specifically, it involves checking the time duration or block count since the last purchase, and if the window duration is met, resetting the recorded purchase amount to allow new purchases within a fresh window period. This ensures that purchase caps are enforced per time window and reset appropriately once the window expires.",
        "url": 898
    },
    {
        "nl_input": "The query requires setting a global activation fee through a function that updates the fee only if the new value is greater than zero and different from the current fee. The function should be restricted to the contract owner, update the stored activation fee, emit an event to signal the update, and return a confirmation boolean.",
        "url": 899
    },
    {
        "nl_input": "The query requires a function to set or update price values within a contract. It should allow the contract owner to assign one or multiple price-related variables, such as a single price, separate sell and buy prices, or a price rate. The function must have access control restricting usage to the owner and should include validation like nonzero price checks or simply update the price state variables accordingly.",
        "url": 900
    },
    {
        "nl_input": "The query requires a smart contract function that enables only the owner to retrieve or transfer any Ether accidentally or otherwise trapped within the contract by sweeping the contract's entire balance and sending it to the owner's address. This function should be restricted to the owner's access to prevent unauthorized withdrawals.",
        "url": 901
    },
    {
        "nl_input": "The query requires a function that returns true only if a gift both exists and has not been redeemed yet. This involves checking a gift's existence status and redemption status to ensure it is valid and available for use.",
        "url": 902
    },
    {
        "nl_input": "The query requires identifying functions within smart contracts that perform specific roles, such as handling deposits with conditions, returning the contract's own address, or providing token symbol information. The focus is on extracting contract functions that interact with contract state or metadata, including payable functions with prerequisite checks, internal view functions returning the contract address, and public view functions returning symbolic identifiers.",
        "url": 903
    },
    {
        "nl_input": "The query requires a Solidity function named fixedExpUnsafe that calculates an exponential expression using fixed-point arithmetic with adjustable precision. The function takes a uint256 input and a uint8 precision parameter, performing a series of multiplications and bit shifts combined with predefined constants to approximate the exponential value. The output is a uint256 representing the computed fixed-point exponential result, adjusted by dividing with a large constant to scale the final value correctly.",
        "url": 904
    },
    {
        "nl_input": "The query requires a function that allows a privileged user (e.g., owner or primary) to add or assign additional bonuses or special privileges to specific addresses or entities, ensuring proper authorization checks. The function should maintain state mappings to track these bonus or special status assignments, using keys or IDs where necessary, and should verify sufficient balances when bonuses are allocated.",
        "url": 905
    },
    {
        "nl_input": "The query requires a function to create a new tank type with specified attributes, including start price, earnings, base health, base attack, base armor, and base speed. This function should be callable only by the owner and must initialize and store a new tank type with these parameters.",
        "url": 906
    },
    {
        "nl_input": "The query requires a function that returns the current or prevailing contract state based on the current timestamp. It should check the current time against multiple predefined time ranges corresponding to different sale phases (e.g., PrivateSale, PreSale, CrowdSalePhase1, etc.) and their activation flags. The function outputs the appropriate state enum value depending on which time window and state conditions are met or a default gap state if none apply.",
        "url": 907
    },
    {
        "nl_input": "The query requires a function named transferOwnership that enables the current owner to transfer contract ownership to a new owner, ensuring the new owner address is valid (non-zero) and access-restricted to only the current owner.",
        "url": 908
    },
    {
        "nl_input": "The query requires functionality to initiate or start a game within a contract, including validations such as verifying the arbiter's authority, ensuring the arbiter is not locked, checking the correct number of players, managing game state transitions like aborting an active game or housekeeping, allocating game resources if not already assigned, recording game start time, initializing player details, and setting the game as active.",
        "url": 909
    },
    {
        "nl_input": "The query requires code involving access control modifiers that validate the caller using msg.sender. Specifically, it looks for conditions where msg.sender is checked against certain allowed entities, such as a contract address obtained via a resolver, a predefined oracle address, or an authorization mapping. This ensures that only authorized senders can execute particular functions within the contract.",
        "url": 910
    },
    {
        "nl_input": "The query requires a function to set specific addresses that will receive the vested team tokens upon finalization. This involves defining and assigning non-zero addresses for the team's vested token allocation, ensuring only authorized access (e.g., onlyOwner), and preparing these allocations for use at the finalization stage of a token distribution or sale contract.",
        "url": 911
    },
    {
        "nl_input": "The query requires a smart contract function that allows users to sell eggs in exchange for ETH. The function should calculate the user's egg quantity and value, deduct a developer fee, update user and market egg balances accordingly, transfer the fee to a specific address, and send the remaining ETH to the seller. It should ensure the contract is not paused and securely handle transfers and state updates related to egg selling for ETH.",
        "url": 912
    },
    {
        "nl_input": "The query requires functionality that enables an admin user to toggle or switch the state of a \"prebridge\" feature in a smart contract. This involves a function restricted to the admin or owner that can change a boolean variable representing the prebridge state from true to false or vice versa.",
        "url": 913
    },
    {
        "nl_input": "The query requires a function to retrieve the amount of Ethereum invested during a Pre-ICO phase, accessible only by the contract owner after the Pre-ICO has ended. It involves checking the ICO state, transferring the invested Ethereum amount to the owner, resetting the invested sum, and returning the transferred value.",
        "url": 914
    },
    {
        "nl_input": "The query requires a function that handles refunding money based on a given proposal number, specifying the refund amount to be paid back and including fees that must be paid by the claimer. The function should verify proposal execution status, ensure sufficient funds, update balances accordingly, execute token transfers to the recipient, adjust fee collections, and emit relevant events to record the refund and fees processed.",
        "url": 915
    },
    {
        "nl_input": "The query requires functionality to set minimum and maximum withdrawal amounts related to NAC (likely a token or asset). Specifically, it seeks code enabling the adjustment of minimum withdrawal limits and the enforcement of withdrawal amounts within defined min and max boundaries, ensuring controlled and validated withdrawal operations.",
        "url": 916
    },
    {
        "nl_input": "The query requires a function that returns the Krown token balance of a specific address. It needs a method accepting an address parameter and returning the balance associated with that address, similar to a typical balanceOf function in token contracts, which retrieves the token balance (not just the contract\u2019s ether balance) for the given token owner.",
        "url": 917
    },
    {
        "nl_input": "The query requires a function that decodes an RLPItem to extract and return an Ethereum address. This involves verifying that the RLPItem contains data, decoding it to obtain a memory position and length, ensuring the length is exactly 20 bytes (the size of an Ethereum address), and then using low-level assembly operations to load and convert the raw bytes at the decoded position into a valid address type. The process includes validation and careful memory manipulation.",
        "url": 918
    },
    {
        "nl_input": "The query requires functionality to remove a specific policy rule by its signature, contract address, and group name, ensuring validation of inputs and managing associated data structures such as group indexes and acceptance limits, while emitting an event upon removal. This involves careful updating and deletion within policy mappings and arrays.",
        "url": 919
    },
    {
        "nl_input": "The query requires a function that restricts specified target addresses from sending or receiving tokens until a specified Unix timestamp. This involves setting a lockup time per target, ensuring the lock period can only be extended, and preventing token transfers before the designated unlock time.",
        "url": 920
    },
    {
        "nl_input": "The query requires a method implementing core game logic that records a unique button click event. This function must validate conditions (like minimum fee, game generation limits), update game state variables (such as generation counters and victory conditions), and capture comprehensive metadata for each click event, including timing, generation, and blocks remaining to victory. Additionally, it should emit an event signaling the click and store this metadata to enable tracking and identification of distinct button click interactions within the game.",
        "url": 921
    },
    {
        "nl_input": "The query requires a publicly accessible function that allows anyone to update the inflation rate once per year. The function must enforce a time restriction ensuring at least one year has passed since the last update before adjusting the inflation rate. This update process should be callable by any user without access restrictions and triggered only after a yearly interval.",
        "url": 922
    },
    {
        "nl_input": "The query requests a read-only function that calculates the number of seconds remaining until the next interest payout, primarily for user display. This function should consider the current interval, interest configuration parameters like start timestamp, interval duration, and stopping interval, returning zero if payouts have stopped. The goal is to provide an accurate countdown to the next interest payout time without modifying contract state.",
        "url": 923
    },
    {
        "nl_input": "The query requires a function that calculates and returns the price for the nth key, considering the number of keys (n) and decimal places, formatting the price with a decimal point. The function should handle multiplication/division by constants or parameters to scale the price appropriately, ensuring correct decimal placement. It aims to compute the price of the nth key based on input parameters, and properly format numeric output with decimals and separators.",
        "url": 924
    },
    {
        "nl_input": "The query requires a function that allows a specified spender to repeatedly withdraw tokens from the owner's account, up to a defined limit (_value), effectively managing allowances for multiple withdrawals. This involves tracking and limiting the amount the spender can withdraw over time, rather than a one-time transfer or owner-only withdrawal. The function should support multiple, controlled spendings without exceeding the approved total amount.",
        "url": 925
    },
    {
        "nl_input": "The query requires functions named \"withdraw\" that enable transferring or withdrawing funds from a contract. These functions may include access control (e.g., admin-only), iterate over input parameters to calculate a withdrawal amount based on conditions or statuses, update records to prevent repeated withdrawals, and perform the actual transfer of funds to the caller or admin. The key needs are secure fund withdrawal logic, condition checks, and event logging where applicable.",
        "url": 926
    },
    {
        "nl_input": "The query requires a function that allows the caller to convert all their accumulated affiliate rewards into tokens. This involves checking the caller's referral balance, resetting it to zero, calculating the number of tokens equivalent to the rewards, and executing the token purchase or conversion process for the caller's account.",
        "url": 927
    },
    {
        "nl_input": "The query requires a function to transfer ownership specifically for a vanity URL, ensuring the new owner does not already have a vanity URL and the current owner has one. It involves updating mappings linking addresses to vanity URLs, emitting an event to signal the transfer, and deleting the old owner's mapping. The function also includes checks to prevent transfer if conditions are not met and operates when the contract is not paused.",
        "url": 928
    },
    {
        "nl_input": "The query requires identifying internal functions within smart contracts, such as those used for internal computations or returning contract-related data. Specifically, it involves functions marked with the \"internal\" visibility modifier that perform tasks like accessing the contract's address or calculating indexes, without external exposure. The description focuses on the use of internal functions for restricted, internal-only logic or data retrieval inside the contract.",
        "url": 929
    },
    {
        "nl_input": "The query pertains to implementing an internal token transfer function specifically for AIRA, allowing a designated bot to transfer tokens between addresses within the contract. This function should verify sufficient sender balance, update balances accordingly, and emit a transfer event, ensuring controlled and authorized internal movement of tokens without general public access.",
        "url": 930
    },
    {
        "nl_input": "Retrieve the balance of a specified address, either in Ether or ERC20 tokens, by querying the balance held at the given address or via the token\u2019s balanceOf function for that address.",
        "url": 931
    },
    {
        "nl_input": "The query requires a function named \"startContruibute\" within a contract that can only be called by the owner when the contract is in the \"SetUp\" stage. Upon execution, it changes the contract's stage to \"Started\" and records the current block number as the start block. This ensures controlled initiation of a contribution phase, with stage management and ownership restrictions.",
        "url": 932
    },
    {
        "nl_input": "The query requires a function that can set multiple pixels on a canvas in a single transaction. This involves providing the canvas ID, arrays of pixel indexes, and their corresponding colors. The function should validate that the lengths of these arrays match, update pixels only if they are not already painted, and finalize the canvas state as needed. If no pixels are set during the operation, the transaction should be reverted.",
        "url": 933
    },
    {
        "nl_input": "The query requires a function or modifier that enforces the crowdsale start time by throwing an error if called before the designated start time. This ensures that certain actions cannot proceed until the crowdsale has officially begun, typically using a time check such as require(now >= startTime).",
        "url": 934
    },
    {
        "nl_input": "The query requires a smart contract function that sends or transfers profits or tokens to a specific token contract or beneficiary address, ensuring proper authorization and validation. It involves minting or buying tokens, updating total supply, and transferring tokens or funds securely, often emitting events to record the transaction. The focus is on handling token distribution and profit transfer within a token sale or management context.",
        "url": 935
    },
    {
        "nl_input": "The query requires a function that sets the ID of the last token eligible for a prize. This involves updating a token limit variable to specify the highest token ID that can receive a reward, ensuring the state allows this update. The function should include checks for valid token ID ranges and update relevant state variables to reflect this change in prize eligibility.",
        "url": 936
    },
    {
        "nl_input": "The query requires specifying the conditions that must be met for a particular stage to start in a contract. These conditions may include checks like whether a sale has ended and contributions have reached a cap, ensuring certain functions can only be called by authorized roles (e.g., owner) and at specific stages, and enforcing time-based restrictions such as not allowing actions before a set start time.",
        "url": 937
    },
    {
        "nl_input": "The query requires a function to assign an external manager authorized to invoke setInterfaceImplementer() on behalf of a specified address, enabling delegated control or management actions for that address.",
        "url": 938
    },
    {
        "nl_input": "The query requires functionality to add specific funder addresses to a whitelist. The solution should include a function that only authorized users (e.g., owner or whitelister) can call, which verifies the address is valid and then adds it or multiple addresses to a whitelist data structure, enabling later recognition of these addresses as approved or allowed participants. It should also trigger an event or record the addition for transparency or logging purposes.",
        "url": 939
    },
    {
        "nl_input": "The query requires a function to set minimum and maximum limits, ensuring the minimum does not exceed the maximum if the maximum is nonzero. It should update the limit variables accordingly and emit an event indicating the change. The logic involves internal validation and state updates related to buying limits or thresholds.",
        "url": 940
    },
    {
        "nl_input": "The query requires a smart contract that creates and holds AVALANCHE ICE tokens at a specific address designated to store all tokens. This address is the source for community contribution coins, implying centralized control of token distribution. The contract should handle minting tokens to various groups (advisors, bounty, community, company, presale), maintain total tokens sold, and ensure the tokens intended for community contributions are allocated from this central holding address.",
        "url": 941
    },
    {
        "nl_input": "The query requires functionality to determine if the current or given date falls within a defined pre-sale period. This involves checking that the date is between a pre-sale start and end time, ensuring the pre-sale is active or enabled, and optionally verifying that pre-sale conditions like available pre-sale amount are met. The focus is on validating whether the pre-sale is currently ongoing based on time constraints and pre-sale status flags.",
        "url": 942
    },
    {
        "nl_input": "The query requires a function that retrieves and returns an array of block numbers corresponding to all revisions of a specified blob. This involves accessing the revision count of the blob and iterating through each revision to get its associated block number, compiling these block numbers into an array for output.",
        "url": 943
    },
    {
        "nl_input": "The query requires functionality to establish or configure a bounty pool within a contract by assigning an address to represent the bounty pool. This involves setting a specific address variable that holds the bounty pool's location, and it should be done with restricted access such as by the contract creator or an authorized role.",
        "url": 944
    },
    {
        "nl_input": "The query requires functions that retrieve player-related data, such as obtaining player information based on the caller's address, fetching detailed player attributes from storage using identifiers, or getting counts of player-owned assets like spaceships. Essentially, it seeks getter methods to access various player properties and statistics from smart contracts.",
        "url": 945
    },
    {
        "nl_input": "The query requires a function that allows an admin to finalize a delegation process after a certain delay (\"after a day\"). This involves verifying the admin's authority, ensuring the required deferment period has passed based on block number, then executing the delegation finalization by transferring control or ownership to a delegate or new contract, and cleaning up temporary operation data. The function must restrict access to admin or owner roles and update related contract references accordingly.",
        "url": 946
    },
    {
        "nl_input": "The query requires a smart contract function that enables receiving a specific ERC20 token, the WEDU token, from another user. This involves a mechanism to accept token transfers initiated by users, ensuring the contract can receive and handle an incoming WEDU token transfer securely and correctly. The functionality should facilitate token reception rather than token ownership transfer, minting, or withdrawal by the contract owner.",
        "url": 947
    },
    {
        "nl_input": "Retrieve the token price specific to the current stage of a contract's lifecycle, ensuring that price information is returned only when the stage is active and relevant (i.e., not after auction ended or tokens distributed). The focus is on obtaining a price value reflecting the current stage's conditions or calculations, excluding fees or total aggregated prices.",
        "url": 948
    },
    {
        "nl_input": "The query requires a mechanism to store and retrieve base stats for monsters using a shared monster ID, enabling efficient generation of new monsters. It also emphasizes saving storage and gas by only storing the monster ID during core interactions and updating it during evolutions. This approach facilitates consistent base stat lookup across monsters with the same ID and reduces transaction costs in the evolution process.",
        "url": 949
    },
    {
        "nl_input": "The query requires functionality to release purchased tokens to buyers during the mainsale phase in compliance with Eidoo's ICOEngineInterface. This involves validating the sale period, calculating token amounts based on the buyer\u2019s payment, handling bonuses if signed by a specific signer, ensuring token availability within mainsale limits, minting tokens to the buyer, transferring received funds to a wallet, and refunding any excess payment. Additionally, relevant events for purchases and refunds should be emitted.",
        "url": 950
    },
    {
        "nl_input": "The query requires a function that reverts (blocks execution) if called by anyone other than the owner, depositor, or beneficiary. It emphasizes access control by restricting function calls exclusively to these three specific roles, ensuring unauthorized accounts cannot execute the function. The solution involves checking the caller's address against these roles and reverting with an error message if the caller is not authorized.",
        "url": 951
    },
    {
        "nl_input": "The query requires a smart contract function to distribute or airdrop tokens to multiple accounts by transferring specified token amounts to each recipient address, typically in a loop. The function should ensure authorization (e.g., only owner) and handle multiple recipients and token values arrays, performing token transfers accordingly. The focus is on batch token transfers to various addresses for token airdrops.",
        "url": 952
    },
    {
        "nl_input": "The query requires a function to verify if a specific address currently holds transfer approval for a particular Cutie identified by its ID. This involves checking an internal mapping or record that associates Cutie IDs with approved addresses and returning a boolean indicating whether the given address is authorized to transfer that Cutie at the present time.",
        "url": 953
    },
    {
        "nl_input": "The query requires a modifier named `onlyGDPOracle` that restricts function execution exclusively to the account identified as `GDPOracle_`. If any other account calls the function, the modifier should cause the transaction to revert, enforcing strict access control based on the sender's address.",
        "url": 954
    },
    {
        "nl_input": "The query requires a function that retrieves detailed information about a specific redemption event associated with a particular address. This includes identifying the redemption by index, returning the redemption ID, the reason code for the redemption, and the value involved. The function must validate the address and index inputs to ensure they are valid before providing these details.",
        "url": 955
    },
    {
        "nl_input": "The query requires a function that transfers animals owned by the sender from one contract to another specified contract. The function must identify the sender's animals, categorize them by type, and transfer ownership along with associated values to the new contract's receiver method. It should handle multiple animal types, track transferred animals' IDs, replace or update ownership records, and return any surplus value to the sender. The transfer must ensure secure and accurate relocation of animal assets between contracts.",
        "url": 956
    },
    {
        "nl_input": "Mint Token. The query requires functionality to create (mint) new tokens and assign them to a specified address, ensuring the recipient is valid (not zero address). It involves increasing the total token supply and updating the recipient's balance accordingly. The minting process should emit events to record the token creation and transfer from the zero address to the recipient, often restricted to authorized users (like the contract owner).",
        "url": 957
    },
    {
        "nl_input": "The query requires a function allowing the contract owner to remove or delist an address by setting its cap to zero. This involves owner-only access to update or reset a user's minimum and maximum cap values, effectively delisting them by assigning a cap of 0.",
        "url": 958
    },
    {
        "nl_input": "The query requires a function that allows only the contract owner to manually start the ICO crowdsale before its scheduled start date or to resume the crowdsale if it was stopped due to human error. This function must enforce owner-only access and enable toggling the crowdsale state from stopped to active, effectively overriding preset timing restrictions or pause states.",
        "url": 959
    },
    {
        "nl_input": "The query requires a function that, given an owner's address and an index, returns the identifier of the deed owned by that owner at that specific index. It involves verifying the index is within the owner's deed count and iterating through all deeds to locate and return the identifier corresponding to the indexed deed owned by the specified owner.",
        "url": 960
    },
    {
        "nl_input": "The query requires a Solidity modifier that restricts a function's execution to only once by enforcing a condition that limits the number of allowed calls, typically using a state variable checked with a require statement before function logic proceeds.",
        "url": 961
    },
    {
        "nl_input": "The query requires a smart contract function that allows changing the developer fee, with a restriction on who can set the fee (e.g., only the owner) and a maximum limit on the fee value.",
        "url": 962
    },
    {
        "nl_input": "The query requires overriding the transferFrom function in a contract to customize its behavior. The function must accept parameters for sender, recipient, and token amount, and return a boolean indicating success. It should call the parent contract's transferFrom method, optionally include additional conditions or state checks before or after the call, and ensure the operation is permitted or meets specified requirements. The goal is to modify or extend transferFrom's functionality while preserving its core transfer logic.",
        "url": 963
    },
    {
        "nl_input": "The query requires a function within a smart contract that sells a specified amount of tokens to a contract address, reducing the token supply accordingly. This involves deducting the sold tokens from total available tokens and transferring them from the contract to the buyer's address, ensuring that the token balance and supply are updated correctly during the sell transaction.",
        "url": 964
    },
    {
        "nl_input": "The query requires functionality to enable or disable a specific address as an authorized sender of EUR-T tokens. This involves setting a permission flag for the address to control whether it can initiate transfers, likely managed by a role-restricted function to update this authorization status and emit a corresponding event or log.",
        "url": 965
    },
    {
        "nl_input": "The query requires functionality solely related to processing refunds within a smart contract. Specifically, it involves enabling refunds by changing contract state or checking conditions that allow refunds, verifying user balances or investments, and transferring the refundable amount back to the user. The focus is on implementing and managing refund mechanisms ensuring only eligible users receive their funds back securely.",
        "url": 966
    },
    {
        "nl_input": "The query requires functionality to buy shares by paying a specified amount, calculating the number of shares based on a buy price, and transferring those shares to the buyer. It involves a payable buy function that accepts payment, verifies purchase conditions, computes share quantity, and executes a transfer to the buyer's address, enabling users to effectively purchase shares within a smart contract.",
        "url": 967
    },
    {
        "nl_input": "The query requires a function that sends an Oraclize query to a specified API, ensuring that queries are sent no more than once per hour per day key. It must check for sufficient ETH balance to cover query fees and emit events indicating whether the query was sent or not. The function should handle alternating API URLs based on prior calls, track and store query IDs with timestamps, and enforce conditions preventing duplicate or overlapping queries within the set timeframe.",
        "url": 968
    },
    {
        "nl_input": "The query seeks a function to confirm an automatic sale by checking if a specified token amount is available before selling. It requires verifying token availability against a given amount and returning a boolean indicating if the sale can proceed. The function should operate internally, likely as part of a contract managing ICO token sales, ensuring the sale only confirms when sufficient tokens exist.",
        "url": 969
    },
    {
        "nl_input": "The query requires an internal function that creates a new Zodiac entity by initializing its attributes (matronId, sireId, generation, genes, owner, zodiacType), calculates a cooldown index, stores the newly created Zodiac in an array, emits a Birth event, transfers ownership, and returns the new Zodiac's ID. This method must ensure data integrity through type validations and proper storage while managing ownership and event notification within the contract.",
        "url": 970
    },
    {
        "nl_input": "The query requires a function that is automatically executed upon contract deployment. This function should configure essential contract parameters during the deployment stage, such as setting a whitelist address, and restrict its execution to authorized entities like the contract owner. It should ensure actions occur only at a specific stage of the contract lifecycle, typically the deployment phase, to manage initialization securely and properly.",
        "url": 971
    },
    {
        "nl_input": "The query requires extracting the index of a newly created snapshot. The relevant function should create a snapshot entry, assign an index based on the current length of snapshot storage, populate snapshot details, and return the snapshot index.",
        "url": 972
    },
    {
        "nl_input": "The query requires a function to retrieve the level of a hero character using its token ID. The solution involves accessing a hero instance mapping by token ID and returning the hero's current level as a 32-bit unsigned integer.",
        "url": 973
    },
    {
        "nl_input": "The query requires a function or method that returns the total supply or total number of tokens available in a contract. This functionality typically involves accessing and returning a stored variable representing the total token count, allowing external callers to query the overall token quantity currently in existence. The function is expected to be a constant or view function that does not modify contract state but simply provides this total supply information.",
        "url": 974
    },
    {
        "nl_input": "The query requires a function that withdraws all vested tokens that have been released but not yet withdrawn by a user, summing these amounts and adding the total to the user's balance. It involves iterating over vesting schedules, calculating the releasable amount based on vesting parameters, updating the withdrawn amounts accordingly, and transferring the cumulative withdrawable vested coins into the user's balance account.",
        "url": 975
    },
    {
        "nl_input": "The query seeks a description of an internal function named doProxyAccounting that handles fee pledges by an owner and creates tokens accordingly. The function requires a valid token controller, updates a tracking block number, pledges fees via the token contract, computes new token issuance based on pledged fees, generates tokens for the owner if applicable, and emits a contribution event. The focus is on fee pledging, token creation, and related state updates within a contract.",
        "url": 976
    },
    {
        "nl_input": "The query requires a function that enables marketing contributors to withdraw their rewarded tokens. This involves verifying the contributor\u2019s reward balance, ensuring the withdrawal amount doesn\u2019t exceed available rewards, updating their reward and transferred token balances, and transferring the tokens accordingly, all while restricting access to authorized parties like the owner or the contributor themselves.",
        "url": 977
    },
    {
        "nl_input": "The query requires functionality to release vested tokens specifically back to a Hut34 wallet address. This involves checking timing conditions, updating the next release date, and transferring a portion of vested tokens to the designated Hut34 wallet. The mechanism should handle scheduled releases, ensure appropriate token transfer amounts, and record the event.",
        "url": 978
    },
    {
        "nl_input": "The query requires a function that allows setting or updating the symbol of a token. This function should modify the symbol variable, ideally restricting access to the contract owner or authorized setter, ensuring controlled updates to the symbol value.",
        "url": 979
    },
    {
        "nl_input": "The query requires a token contract functionality that permits any user to transfer Change tokens only after trading has commenced. The transfer function should include a condition enforcing that trading has officially started before allowing token transfers, ensuring tokens are not transferable beforehand. This implies a trading start flag or modifier controlling transfer permissions, enabling unrestricted token transfers once the trading phase is active.",
        "url": 980
    },
    {
        "nl_input": "The query requires a smart contract function modifier that reverts the transaction if the caller (msg.sender) is not the designated whiteListAgent address. This modifier ensures that only the whiteListAgent can execute certain functions, enforcing access control based on the sender's identity.",
        "url": 981
    },
    {
        "nl_input": "The query requires a system where the inflation rate starts at 100 and decreases annually by 30 until it hits 10. After reaching 10, the rate should then decrease more gradually by 0.5 each subsequent year. This logic must be implemented in a timed manner, updating once per year, adjusting inflation based on the current rate, and influencing minting amounts accordingly.",
        "url": 982
    },
    {
        "nl_input": "The query requires a function to transfer tokens from one user address to another. The solution should include specifying sender and receiver addresses, the token type or contract, and the amount of tokens to be transferred. It needs to securely update account balances, verify permissions or allowances, and emit transfer events to track the transaction. The focus is on direct token transfer between user addresses with proper balance adjustments and authorization checks.",
        "url": 983
    },
    {
        "nl_input": "The query requires a function that removes an auction from public access and returns the associated token to the original seller. This involves canceling or removing the auction listing and then transferring ownership of the token back to the seller, ensuring the auction is no longer visible or active.",
        "url": 984
    },
    {
        "nl_input": "The query requires a function that approves the minting of a specified amount of tokens assigned to a given owner address. It must validate that the amount is positive, ensure no overflow in token balances or total supply, and update the owner's locked token balance accordingly. The function should also enforce address validity and authorized minting rights, emit an approval event, and return a success status.",
        "url": 985
    },
    {
        "nl_input": "Retrieve the total jackpot amount by checking if the jackpot is complete; if completed, return the finalized jackpot value, otherwise return the current contract balance as the jackpot value.",
        "url": 986
    },
    {
        "nl_input": "The query requires calculating the amount of ETH one can receive by selling a given amount of BOB tokens. This involves determining the exchange rate or price per unit of BOB in ETH, checking available contract balance, limiting the sale based on liquidity, transferring BOB tokens from seller to contract, and then sending the corresponding ETH amount to the seller. The process should handle transaction validations and update relevant events accordingly.",
        "url": 987
    },
    {
        "nl_input": "The query requires creating a modifier named \"onlyAccessDeposit\" that restricts function access to the contract owner or addresses with deposit permissions. This modifier should verify if the sender is either the owner or has a true value in a depositAccess mapping before proceeding.",
        "url": 988
    },
    {
        "nl_input": "The query requires a function that determines whether a specific address is permitted to bypass a global freeze in a contract. It involves checking if the address can be exempt from restrictions imposed by a global freeze mechanism, essentially verifying if the address holds a special permission or status that allows it to operate despite the freeze.",
        "url": 989
    },
    {
        "nl_input": "The query requires a Solidity smart contract function that serves as the callback handler for Oraclize's random number generation. It must verify the callback's authenticity, validate the associated bet state and involved players, verify the Oraclize proof, extract and process the random number, determine the bet outcome by comparing two derived random values, handle win/loss distributions with error logging, and update bet states accordingly. The callback should also manage errors by canceling bets on verification failure or tied random values.",
        "url": 990
    },
    {
        "nl_input": "The query requires a smart contract function that allows the contract owner to update the exchange rate between TCR tokens and ETH. This involves defining a function restricted to the owner that sets or modifies a rate variable representing the token price per ETH, enabling dynamic adjustment of the conversion rate by the owner.",
        "url": 991
    },
    {
        "nl_input": "The query requires a function that indicates whether a specific account is frozen by returning a boolean status. This involves checking a stored state that marks accounts as frozen or not, without modifying it. The functionality should provide a clear true/false output reflecting the frozen condition of the given account address.",
        "url": 992
    },
    {
        "nl_input": "The query requires a contract function that allows the owner to send any transaction, similar to a multi-signature wallet, enabling the owner to transfer tokens or pledges they hold to another DAC or campaign. This functionality is necessary because campaigns might receive DAC or campaign tokens when transferring ownership of a pledge, ensuring the owner has full control to execute such transfers or transactions securely and flexibly.",
        "url": 993
    },
    {
        "nl_input": "The query requires a contract function that disables or deactivates the contract's operations without destroying it. This \"nullify\" functionality should be restricted to the contract owner and set a state (e.g., a boolean flag) indicating the contract is nullified or disabled, effectively preventing further interactions or usage. It should not remove or selfdestruct the contract but merely render it inactive or non-functional.",
        "url": 994
    },
    {
        "nl_input": "The query requires a function that allows only the major or actual owner to remove a minor owner from ownership. The function must ensure valid minor owner address input, verify the caller is the major owner, check proper ownership conditions, and then remove the minor owner by resetting their ownership status. Additionally, it should adjust the major owner's share accordingly.",
        "url": 995
    },
    {
        "nl_input": "The query requires retrieving the value associated with a given node identifier. Specifically, it seeks a function that accepts a node ID and returns the stored value of that node from a data structure or library, enabling access to the node's value based on its identifier.",
        "url": 996
    },
    {
        "nl_input": "The query requires defining who is authorized to transfer tokens, specifying that both the contract owner and designated distributors have transfer permissions. Only these roles can execute token transfers, ensuring controlled and secure token movement within the system.",
        "url": 997
    },
    {
        "nl_input": "The query requires a function that allows setting or updating a charity's address within a contract. Specifically, it needs a method named \"setCharity\" or similar, which accepts an address parameter representing the charity's address and restricts access to the contract owner only. The function should securely assign the provided address to a stored charity address variable.",
        "url": 998
    },
    {
        "nl_input": "The query requires a function to set the server-side address, specifically allowing the modification of an address variable with appropriate access control and validation checks to prevent setting restricted addresses such as the owner or the contract itself. This function should only be callable by authorized roles, ensure the new address is valid, update the stored address, and emit an event to signal the change.",
        "url": 999
    }
]