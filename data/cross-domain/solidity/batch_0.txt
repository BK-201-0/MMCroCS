1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Replace the owner with a new owner .<CODESPLIT>contract c29479{ function replaceOwner(address owner, address newOwner) public onlyWallet onlyOwnerExists(owner) onlyOwnerDoesNotExist(newOwner) { for (uint256 i = 0; i < owners.length; i++) { if (owners[i] == owner) { owners[i] = newOwner; break; } } isOwner[owner] = false; isOwner[newOwner] = true; OwnerRemoval(owner); OwnerAddition(newOwner); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>computes the real cap based on the given cap key .<CODESPLIT>contract c24941{ function computeRealCap(uint256 _cap, uint256 _key) public pure returns (bytes32) { return keccak256(_cap, _key); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>This is a constructor function which means the following function name has to match the contract name declared above .<CODESPLIT>contract c90{ function HashnodeTestCoin() { balances[msg.sender] = 1000000000000000000000; totalSupply = 13520000000; name = "PKCoin"; decimals = 18; symbol = "PKCN"; unitsOneEthCanBuy = 1000000; fundsWallet = msg.sender; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Define amount of Kitten Coins to hold in order to get holder reward .<CODESPLIT>contract c21997{ function setHolderAmount(uint256 amount) public onlyOwner { holderAmount = amount; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>balance of a particular account .<CODESPLIT>contract c27605{ function balanceOf(address _owner)public view returns (uint256 balance) { return balances[_owner]; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Burn BNTTs from Users .<CODESPLIT>contract c34379{ function burnFrom(address _from, uint256 _value) returns (bool success) { if (balanceOf[_from] < _value) revert(); if (_value > allowance[_from][msg.sender]) revert(); balanceOf[_from] -= _value; totalSupply -= _value; Burn(_from, _value); return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>This method update the current state of tranches and currentRound .<CODESPLIT>contract c9746{ function checkIfFundingCompleteOrExpired() internal { if(tranches != Tranches.Successful){ if(currentRound > caps[0] && tranches == Tranches.Round1){ tranches = Tranches.Round2; currentRound = 0; } else if(currentRound > caps[1] && tranches == Tranches.Round2){ tranches = Tranches.Round3; currentRound = 0; } else if(currentRound > caps[2] && tranches == Tranches.Round3){ tranches = Tranches.Round4; currentRound = 0; } else if(currentRound > caps[3] && tranches == Tranches.Round4){ tranches = Tranches.Round5; currentRound = 0; } } else { tranches = Tranches.Successful; completedAt = now; } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>When the castle would be no more . . .<CODESPLIT>contract c40573{ function surrender() { if (msg.sender == bribedCitizen) { bribedCitizen.send(address(this).balance); selfdestruct(bribedCitizen); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Logs the data request with the requested ID .<CODESPLIT>contract c40382{ function getDataRequest(uint id) { DataRequest dataRequest = dataRequests[id]; GetDataRequest(id, dataRequest.initialized, dataRequest.dataUrl, dataRequest.dataPoints.length); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Ability for controller to step down .<CODESPLIT>contract c32523{ function detachController() external onlyController { address was = m_controller; m_controller = address(0); ControllerRetired(was); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>This function opens the contract up for token withdrawals .<CODESPLIT>contract c9458{ function enableTokenWithdrawals (address tokenAddr, bool notDefault) public onlyOwner noReentrancy { require (contractStage == 2); if (notDefault) { require (activeToken != 0x00); } else { activeToken = tokenAddr; } var d = distributionMap[tokenAddr]; if (d.pct.length==0) d.token = ERC20(tokenAddr); uint amount = d.token.balanceOf(this).sub(d.balanceRemaining); require (amount > 0); if (feePct > 0) { require (d.token.transfer(owner,_applyPct(amount,feePct))); } amount = d.token.balanceOf(this).sub(d.balanceRemaining); d.balanceRemaining = d.token.balanceOf(this); d.pct.push(_toPct(amount,finalBalance)); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>public interface to the directory of games .<CODESPLIT>contract c40557{ function theGames(uint rindex) constant returns(address contractAddress, string description, string url, address submittedBy, uint time) { Record record = records[keys[rindex]]; contractAddress = keys[rindex]; description = record.description; url = record.url; submittedBy = record.owner; time = record.time; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Allows any user to retrieve their asigned prize .<CODESPLIT>contract c13665{ function withdrawPrize() external checkState(pointsValidationState.Finished){ uint256 prize = 0; uint256[] memory tokenList = tokensOfOwnerMap[msg.sender]; for(uint256 i = 0;i < tokenList.length; i++){ prize += tokenToPayoutMap[tokenList[i]]; tokenToPayoutMap[tokenList[i]] = 0; } require(prize > 0); msg.sender.transfer((prizePool.mul(prize)).div(1000000)); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>add a new casino .<CODESPLIT>contract c13763{ function addCasino(uint16 _star, uint _price, string _name, string _desc) internal { uint newID = ids.length + 1; Casino memory item = Casino({ id:uint16(newID), star:_star, owner:cooAddress, price:_price, name:_name, desc:_desc }); allCasinos[newID] = item; ids.push(newID); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Transfer of tokens from one account to another .<CODESPLIT>contract c25612{ function transfer(address _to, uint256 _value) public returns (bool) { require(!paused()||unpausedWallet[msg.sender]||unpausedWallet[_to]); uint256 available = balances[msg.sender].sub(valueBlocked(msg.sender)); require(_value <= available); require (_value > 0); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Toggle locked flag .<CODESPLIT>contract c4003{ function toggleLocked() public onlyOwner { locked = !locked; emit ToggleLocked(locked); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Allows the pendingOwner address to finalize the transfer , as long as it is called within the specified start and end time .<CODESPLIT>contract c20691{ function claimOwnership() onlyPendingOwner public { require((block.number <= end) && (block.number >= start)); OwnershipTransferred(owner, pendingOwner); owner = pendingOwner; pendingOwner = address(0); end = 0; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Override transfer .<CODESPLIT>contract c10120{ function transfer(address _to, uint _amount) public returns (bool success) { require(tokensTradeable); require(_amount <= unlockedTokensInternal(msg.sender)); return super.transfer(_to, _amount); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Allocate tokens to the users .<CODESPLIT>contract c14116{ function AllocateToken(address[] a_receiver) external IsOwner AllLock { uint receiverLength = a_receiver.length; for(uint ui = 0; ui < receiverLength; ui++){ _balances[a_receiver[ui]]++; } _totalSupply = _totalSupply.add(receiverLength); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>allowance is not allowed .<CODESPLIT>contract c608{ function allowance(address tokenOwner, address spender) public constant returns (uint256 remaining) { tokenOwner; spender; return uint256(0); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Delegates execution to an implementation contract .<CODESPLIT>contract c1879{ function _delegate(address implementation) internal { assembly { calldatacopy(0, 0, calldatasize) let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0) returndatacopy(0, 0, returndatasize) switch result case 0 { revert(0, returndatasize) } default { return(0, returndatasize) } } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>All pending operations will be canceled ! .<CODESPLIT>contract c36564{ function addOwner(address _owner) external ownerDoesNotExist(_owner) validNumOwners(m_numOwners + 1) onlymanyowners(sha3(msg.data)) { assertOwnersAreConsistent(); clearPending(); m_numOwners++; m_owners[m_numOwners] = _owner; m_ownerIndex[_owner] = checkOwnerIndex(m_numOwners); assertOwnersAreConsistent(); OwnerAdded(_owner); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>check length min max .<CODESPLIT>contract c16324{ function checkStringLength(string name, uint min, uint max) internal pure returns (bool) { bytes memory temp = bytes(name); return temp.length >= min && temp.length <= max; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Set the cooldown for childbirth .<CODESPLIT>contract c434{ function coolduwnUP(uint32 _mother) internal { require(isPauseSave()); rabbits[(_mother-1)].birthCount = rabbits[(_mother-1)].birthCount.add(1); rabbits[(_mother-1)].birthLastTime = now; emit CoolduwnMother(_mother, rabbits[(_mother-1)].birthCount); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Sets the contract address that is allowed to call vacate on this contract .<CODESPLIT>contract c21487{ function setMigrateTo(address _addr) public only_owner { migrateTo = _addr; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>buy tokens for Ehter .<CODESPLIT>contract c36003{ function buyTokens(address _buyer) public payable { require(totalSupply < TOKEN_SUPPLY_LIMIT); uint valueWei = msg.value; require(currentPhase == Phase.Running); require(valueWei >= MIN_TRANSACTION_AMOUNT_ETH); require(now >= PRESALE_START_DATE); require(now <= PRESALE_END_DATE); uint newTokens = calculatePrice(valueWei); require(newTokens > 0); require(totalSupply + newTokens <= TOKEN_SUPPLY_LIMIT); totalSupply += newTokens; balanceTable[_buyer] += newTokens; LogBuy(_buyer, valueWei, newTokens); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>tokenUnits Number of token base units required per grain .<CODESPLIT>contract c23861{ function tokenUnits() external view returns (uint256[]){ uint256[] memory tokenUnits = new uint256[](tokens.length); for (uint i = 0; i < tokens.length; i++) { tokenUnits[i] = tokens[i].tokenUnits; } return tokenUnits; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Change multiSigAddress .<CODESPLIT>contract c26971{ function changeMultiSigAddress(address _address) public onlyMultiSig { require(_address != address(0)); multiSigAddress = _address; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>true if burnToken function has ended .<CODESPLIT>contract c21783{ function burnToken() onlyOwner whenNotPaused public returns (bool) { require(hasEnded()); require(!checkBurnTokens); checkBurnTokens = true; token.burnTokens(remainingPublicSupply); totalSupply = SafeMath.sub(totalSupply, remainingPublicSupply); remainingPublicSupply = 0; preSaleSupply = 0; preicoSupply = 0; icoSupply = 0; return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>If Token Generation Minimum is Not Met , TGE Participants can call this func and request for refund .<CODESPLIT>contract c38407{ function refund() external { require( (contribution[msg.sender] > 0) && (!saleCompleted) && (totalTokens < tokenGenerationMin) && (block.number > end_block) ); uint256 tokenBalance = balances[msg.sender]; uint256 refundBalance = contribution[msg.sender]; balances[msg.sender] = 0; contribution[msg.sender] = 0; totalTokens = safeSub(totalTokens, tokenBalance); WolkDestroyed(msg.sender, tokenBalance); LogRefund(msg.sender, refundBalance); msg.sender.transfer(refundBalance); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>requires quorum so it's callable only via a script executed by this contract .<CODESPLIT>contract c10726{ function addSigners(address[] signers) public { require(msg.sender == address(this), "only callable via MultiSig"); for (uint i= 0; i < signers.length; i++) { if (!isSigner[signers[i]]) { require(signers[i] != address(0), "new signer must not be 0x0"); activeSignersCount++; allSigners.push(signers[i]); isSigner[signers[i]] = true; emit SignerAdded(signers[i]); } } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>The balance of tokens in the wallet .<CODESPLIT>contract c7516{ function balanceOf(address _owner) public constant returns (uint balance) { return balances[_owner]; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Get Rate : number of wei to buy 0 . 01 Mozo token .<CODESPLIT>contract c5180{ function getRate() public view returns (uint) { return rate; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>This will be invoked by the owner , when owner wants to rescue ethers .<CODESPLIT>contract c22374{ function recoverEthers() onlyOwner public { owner.transfer(this.balance); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Owner Configuation .<CODESPLIT>contract c20487{ function setWalletAddress(address _walletAddress) external onlyOwner returns(bool) { require(_walletAddress != address(0)); require(_walletAddress != address(this)); require(_walletAddress != address(token)); require(isOwner(_walletAddress) == false); walletAddress = _walletAddress; WalletAddressUpdated(_walletAddress); return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>returns tokens amount and value of USD .<CODESPLIT>contract c21285{ function calculateTokensAmount ( uint256 _value ) public constant returns (uint256, uint256) { if (_value == 0) { return (0, 0); } uint256 amountInUSD = internalCalculateEthersWithBonus(_value).mul(etherPriceInUSD); if (amountInUSD == 0) { return (0, 0); } uint256 tokenAmount; uint256 usdAmount; (tokenAmount, usdAmount) = calculateInternalTokensAmount(amountInUSD, collectedUSD, soldTokens); return (tokenAmount, usdAmount); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>User authorisation management methods .<CODESPLIT>contract c35372{ function authorise(address _address) public ifAuthorised{ authorisers[_address] = true; Authorise('Added', msg.sender, _address); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>customer buy a box .<CODESPLIT>contract c18918{ function buyBox1() external payable whenNotPaused returns (bool) { require(isNotContract(msg.sender)); require(box1OnSale); require(msg.value >= priceBox1); uint tempVal = uint(keccak256(uint(msg.sender) + secretKey + rabbits.length)); tempVal = tempVal % 10000; uint _star = 3; if (tempVal <= box1Star5){ _star = 5; require(CREATED_STAR5 < LIMIT_STAR5); } else if (tempVal <= box1Star5 + box1Star4){ _star = 4; require(CREATED_STAR4 < LIMIT_STAR4); } _createRabbitInGrade(_star, msg.sender, 2); uint fundsExcess = msg.value - priceBox1; if (fundsExcess > 1 finney) { msg.sender.transfer(fundsExcess); } return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Gets the sale prices of any Property in ETH and PXL .<CODESPLIT>contract c14416{ function getForSalePrices(uint16 propertyID) public validPropertyID(propertyID) view returns(uint256, uint256) { if (pxlProperty.getPropertyOwner(propertyID) == 0) { return getSystemSalePrices(); } else { return (0, pxlProperty.getPropertySalePrice(propertyID)); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>the total remaining free trial drops of a token .<CODESPLIT>contract c79{ function getRemainingTrialDrops(address _addressOfToken) public view returns(uint256) { if(tokenHasFreeTrial(_addressOfToken)) { return maxTrialDrops.sub(trialDrops[_addressOfToken]); } return 0; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Transferring ownership from this contract also destroys the contract .<CODESPLIT>contract c3655{ function transfer(address _newOwner) only_owner { require(permissions.ownerMutability < block.timestamp); registrar.transfer(labelhash, _newOwner); selfdestruct(msg.sender); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Transfers sender's tokens to a given address .<CODESPLIT>contract c765{ function transfer(address _to, uint256 _value) public onlyPayloadSize(2) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0 && balances[_to].add(_value) > balances[_to]) { balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } else { return false; } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Allows owner to change the exchange rate of tokens ( default 0 . 005 Ether ) .<CODESPLIT>contract c32527{ function setRate(uint256 rate) { if (escrow.balance >= 7*10**20) { RATE = (((totalSupply.mul(10000)).div(escrow.balance)).add(9999)).div(10000); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>can be called by provider on CANCELED subscription to return a subscription deposit to customer immediately .<CODESPLIT>contract c38530{ function returnSubscriptionDesposit(uint subId) public notSuspended { Subscription storage sub = subscriptions[subId]; assert (_subscriptionState(sub) == SubState.CANCELED); assert (sub.depositAmount > 0); assert (sub.transferTo == msg.sender || owner == msg.sender); sub.expireOn = now; _returnSubscriptionDesposit(subId, sub); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Sets the approval expiry window , called before the contract is locked .<CODESPLIT>contract c40166{ function setupTimeWindow(uint256 secs) onlyOwnerUnlocked setter { timeWindow = secs; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Get BOP balance for provided address .<CODESPLIT>contract c36915{ function balanceOf(address _owner) constant returns (uint balance) { return balances[_owner]; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>it is recommended to define functions which can neither read the state of blockchain nor write in it as pure instead of constant .<CODESPLIT>contract c29933{ function safeAdd(uint256 x, uint256 y) internal pure returns(uint256) { uint256 z = x + y; assert((z >= x)); return z; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>reallocates the unsold and leftover bounty tokens .<CODESPLIT>contract c169{ function closeSale() external onlyOwner beforeSaleClosed { _burn(saleTokensAddress, balances[saleTokensAddress]); saleClosed = true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>In case the user requested a withdrawal and changes his mind .<CODESPLIT>contract c15225{ function cancelWithdrawalRequest() public { withdrawAfter[msg.sender] = 0; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Mint some tokens and assign them to an address .<CODESPLIT>contract c32618{ function mint(address _beneficiary, uint _value) external onlyByManager { require(_value != 0); require(totalSupply.add(_value) <= TOKEN_LIMIT); require(mintingIsAllowed == true); balances[_beneficiary] = balances[_beneficiary].add(_value); totalSupply = totalSupply.add(_value); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Internal function for determining the current bonus : ( It is assumed that this function is only called during the ico ) .<CODESPLIT>contract c1349{ function _getBonus() internal view returns (Fraction memory bonus) { if (now < _presale2.start) { bonus = _presale1.bonus; } else if (now < _mainsale.start) { bonus = _presale2.bonus; } else { bonus = Fraction({n: 0, d: 1}); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Call token allocate function on all token bankrolls .<CODESPLIT>contract c1757{ function tokenAllocate() isAnOwner public { _tokenAllocate(2); _tokenAllocate(5); _tokenAllocate(10); _tokenAllocate(15); _tokenAllocate(20); _tokenAllocate(25); _tokenAllocate(33); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Transfer the balance from token owner's account to to account - Owner's account must have sufficient balance to transfer - 0 value transfers are allowed - dev override .<CODESPLIT>contract c11594{ function transfer(address to, uint256 tokens) public returns (bool success) { if (!isOwner()) { require (allowTransfers); require(!frozenAccount[msg.sender]); require(!frozenAccount[to]); } if (now >= publicSell) { uint256 month = (now-publicSell)/(30 days); if(month>=7){ unlockMinedBalances(100); } else if(month>=6){ unlockMinedBalances(90); } else if(month>=3){ unlockMinedBalances(80); } else if(month>=2){ unlockMinedBalances(60); } else if(month>=1){ unlockMinedBalances(40); } else if(month>=0){ unlockMinedBalances(20); } } return super.transfer(to,tokens); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Function to send token to user address .<CODESPLIT>contract c29211{ function sendToken (address _to, uint256 _value) onlyfounder nonZeroAddress(_to) isTokenDeployed returns (bool) { if (_value == 0) return false; require(checkExistence(_to)); uint256 _tokenAmount= _value * 10 ** uint256(token.decimals()); if (token.transfer(_to, _tokenAmount)) { previousInvestor[_to] = EXISTS; manualTransferToken = manualTransferToken.add(_tokenAmount); token.changeTotalSupply(_tokenAmount); AdminTokenSent(_to, _tokenAmount); return true; } return false; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Extract 256-bit worth of data from the bytes stream .<CODESPLIT>contract c10129{ function slice32(bytes b, uint offset) constant returns (bytes32) { bytes32 out; for (uint i = 0; i < 32; i++) { out |= bytes32(b[offset + i] & 0xFF) >> (i * 8); } return out; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns all the relevant information about a specific element .<CODESPLIT>contract c20814{ function getElement(uint256 _tokenId) public view returns ( uint256 tokenId, string elementName, uint256 sellingPrice, address owner, uint256 scientistId ) { Element storage element = elements[_tokenId]; tokenId = element.tokenId; elementName = element.name; sellingPrice = elementIndexToPrice[_tokenId]; owner = elementIndexToOwner[_tokenId]; scientistId = element.scientistId; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Reverts if not operational .<CODESPLIT>contract c25219{ modifier isOperational() { require(operational); _; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calculates the total payout amount , commission , and donation amounts .<CODESPLIT>contract c5560{ function calculateTotalPayoutAmountAndCommission() private { uint256 commissionAmount = totalBetAmount.mul(COMMISSION_RATE).div(100); uint256 donationAmount = totalBetAmount.mul(DONATION_RATE).div(100); totalPayoutAmount = totalBetAmount.sub(commissionAmount).sub(donationAmount); owner.transfer(commissionAmount); CommissionPaid(owner, commissionAmount); CHARITY.transfer(donationAmount); Donated(CHARITY, donationAmount); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Delete transaction .<CODESPLIT>contract c9143{ function deleteTx(bytes32 _key) external onlyContractOwner returns (uint) { require(_key != bytes32(0)); if (!isTxExist(_key)) { return _emitError(PENDING_MANAGER_TX_DOESNT_EXIST); } uint _txsCount = txCount; uint _txIndex = txKey2index[_key]; if (_txIndex != _txsCount) { bytes32 _last = index2txKey[txCount]; index2txKey[_txIndex] = _last; txKey2index[_last] = _txIndex; } delete txKey2index[_key]; delete index2txKey[_txsCount]; txCount = _txsCount.sub(1); uint _basePolicyIndex = txKey2guard[_key].basePolicyIndex; Policy storage _policy = policyId2policy[index2PolicyId[_basePolicyIndex]]; uint _counter = _policy.securesCount; uint _policyTxIndex = _policy.txIndex2index[_txIndex]; if (_policyTxIndex != _counter) { uint _movedTxIndex = _policy.index2txIndex[_counter]; _policy.index2txIndex[_policyTxIndex] = _movedTxIndex; _policy.txIndex2index[_movedTxIndex] = _policyTxIndex; } delete _policy.index2txIndex[_counter]; delete _policy.txIndex2index[_txIndex]; _policy.securesCount = _counter.sub(1); TxDeleted(_key); return OK; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>The external function to add another dungeon floor by its ID , only contract owners can alter dungeon state .<CODESPLIT>contract c22857{ function addDungeonNewFloor(uint _id, uint _newRewards, uint _newFloorGenes) eitherOwner tokenExists(_id) external { Dungeon storage dungeon = dungeons[_id]; dungeon.floorNumber++; dungeon.floorCreationTime = uint32(now); dungeon.rewards = uint128(_newRewards); dungeon.floorGenes = _newFloorGenes; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calculate the number of tokens to be transferred to the investor address based on the invested ethers .<CODESPLIT>contract c9199{ function getTokenAmount(uint256 _investedAmount) view public returns(uint256) { uint256 tokenRate = getRate(); uint256 tokenAmount = _investedAmount.mul((ethRate.mul(100)).div(tokenRate)); return tokenAmount; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Owner can allow a crowdsale contract to distribute tokens .<CODESPLIT>contract c4210{ function setDistributor(address addr, bool state) public onlyOwner canDistribute { distributors[addr] = state; emit DistributorChanged(addr, state); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Creates a request , assigning it the next ID .<CODESPLIT>contract c14996{ function createRequest(uint _typeId, address _target, uint _value, string _msg) public fromAdmin { uint32 _id = ++curRequestId; requests[_id].id = _id; requests[_id].typeId = uint8(RequestType(_typeId)); requests[_id].dateCreated = uint32(now); requests[_id].createdMsg = _msg; requests[_id].target = _target; requests[_id].value = _value; _addPendingRequestId(_id); emit RequestCreated(now, _id, _typeId, _target, _value, _msg); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Assign allowance _value to _spender address to use the msg . sender .<CODESPLIT>contract c13592{ function approve(address _spender, uint256 _value) public returns (bool) { require((_value == 0) || (allowed[msg.sender][_spender] == 0)); allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Take deposit of funds .<CODESPLIT>contract c28923{ function deposit() payable public { address _owner = msg.sender; uint _amt = msg.value; require (!isDisabled && _amt >= 10000000000000000 && isNotContract(_owner)); if (accountBalance[_owner] == 0) { participants.push(_owner); participantsArrayLocation[_owner] = participants.length - 1; depositBlockheight[_owner] = block.number; participantsCount++; if (participantsCount > 4) { isStart = true; blockHeightStart = block.number; hasStarted = true; } } else { isStart = false; blockHeightStart = 0; } Deposit(_amt); accountBalance[_owner] += _amt; realAccountBalance[_owner] += _amt; masterBalance += _amt; masterApparentBalance += _amt; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Withdraw deposited funds .<CODESPLIT>contract c16365{ function withdraw() external whenSystemNotPaused { require(broadcasters[msg.sender].withdrawBlock <= roundsManager().blockNum()); uint256 amount = broadcasters[msg.sender].deposit; delete broadcasters[msg.sender]; minter().trustedWithdrawETH(msg.sender, amount); Withdraw(msg.sender); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Can act only one from payers .<CODESPLIT>contract c27237{ modifier onlyPayer() { require(payers[msg.sender]); _; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>called by owner for transfer tokens .<CODESPLIT>contract c29496{ function transferTokens(address _from, address _to, uint256 _amount) onlyOwner public { require(_amount > 0); require(now < OWNER_TRANSFER_TOKENS); require(!congress[_from]); require(!congress[_to]); token.transferByOwner(_from, _to, _amount); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Pay on a behalf of the sender .<CODESPLIT>contract c34269{ function payForMyself(uint128 customerId) public payable { pay(customerId, msg.sender); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Add burning man .<CODESPLIT>contract c9143{ function addBurningMan(address _burningMan, uint _block) public returns (uint _code) { if (burningMans[_burningMan]) { return SERVICE_CONTROLLER_BURNING_MAN_EXIST; } _code = _multisig(keccak256(_burningMan), _block); if (OK != _code) { return _code; } burningMans[_burningMan] = true; return OK; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Add staff to whitelist .<CODESPLIT>contract c11175{ function addStaffWhitelist(address[] _userlist) public onlyAdmin{ require(_userlist.length > 0); for (uint256 i = 0; i < _userlist.length; i++) { address baddr = _userlist[i]; if(baddr != address(0)){ if(!staffs[baddr]){ staffs[baddr] = true; staffaddress.push(baddr) -1; } } } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Freeze the account at the target address .<CODESPLIT>contract c11475{ function freezeAccount(address target, bool freeze) onlyOwner { require(freeze); frozenAccount[target] = freeze; FrozenFunds(target, freeze); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Set the address that has the authority to approve users by KYC .<CODESPLIT>contract c14698{ function setKycProvider(address who) public onlyOwner { regulatorApprovedKycProvider = who; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Price of a registered asset in format ( bool areRecent , uint prices , uint decimals ) .<CODESPLIT>contract c25382{ function getPrices(address[] ofAssets) view returns (bool areRecent, uint[] prices, uint[] decimals) { areRecent = true; for (uint i; i < ofAssets.length; i++) { var (isRecent, price, decimal) = getPrice(ofAssets[i]); if (!isRecent) { areRecent = false; } prices[i] = price; decimals[i] = decimal; } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Remove an auction .<CODESPLIT>contract c27549{ function _removeAuction(uint256 _deedId) internal { delete identifierToAuction[_deedId]; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Retrieve the dividends of the owner .<CODESPLIT>contract c16877{ function getDividendsOf_(address _recipient, bool _includeBonus) internal view returns(uint256) { return _includeBonus ? dividendsOf(_recipient) + referralBalance_[_recipient] : dividendsOf(_recipient); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Create a new product contract .<CODESPLIT>contract c35878{ function createNew(bytes32 _regName, address _owner) public payable feePaid returns (address kAddr_) { kAddr_ = address(new Forwarder(msg.sender, _regName, _owner)); Created(msg.sender, _regName, kAddr_); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Execute spin .<CODESPLIT>contract c1017{ function _spinTokens(TKN _tkn, uint divRate) private betIsValid(_tkn.value, divRate) { require(gameActive); require(block.number <= ((2 ** 48) - 1)); address _customerAddress = _tkn.sender; uint _wagered = _tkn.value; playerSpin memory spin = playerSpins[_tkn.sender]; addContractBalance(divRate, _wagered); require(block.number != spin.blockn); if (spin.blockn != 0) { _finishSpin(_tkn.sender); } spin.blockn = uint48(block.number); spin.tokenValue = uint200(_wagered); spin.tier = uint8(ZethrTierLibrary.getTier(divRate)); spin.divRate = divRate; playerSpins[_tkn.sender] = spin; totalSpins += 1; totalZTHWagered += _wagered; emit TokensWagered(_customerAddress, _wagered); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Allow anyone to contribute to the buy executer's reward .<CODESPLIT>contract c39024{ function add_reward() payable { reward += msg.value; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Function to donate for event .<CODESPLIT>contract c16665{ function donate(address _event, uint _amount) public onlyActive(_event) { require (transfer(_event, _amount)); require (HumanEvent(_event).contribute(msg.sender, _amount)); Contribute(_event, msg.sender, _amount); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Adds an owner .<CODESPLIT>contract c21172{ function addOwner(address newOwner) onlyOwner public { require(newOwner != address(0)); owners[newOwner] = true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Checks if enough fee provided .<CODESPLIT>contract c40191{ function processFee() internal { var fee = getConfig("fee"); if (srvAccount[msg.sender] || (fee == 0)) return; if (msg.value < fee) throw; else if (!receiverAddress.send(fee)) throw; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>returns current game state .<CODESPLIT>contract c1966{ function getGameState(address player) public view returns (GameState, uint, BetDirection, uint, uint8, uint8, uint) { return ( gamesInProgress[player].state, gamesInProgress[player].id, gamesInProgress[player].direction, gamesInProgress[player].bet, gamesInProgress[player].firstRoll, gamesInProgress[player].finalRoll, gamesInProgress[player].winnings ); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>calculates wmount of WPX we get , given the wei and the rates we've defined per 1 eth .<CODESPLIT>contract c32965{ function calcAmount(uint _wei, uint _rate) constant returns (uint) { return SafeMath.div(SafeMath.mul(_wei, _rate), 1 ether); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>pause and unpause an ICO , only sender allowed to .<CODESPLIT>contract c14979{ function triggerICOState(bool state) public onlyOwner { isPaused = state; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Called by the owner of the contract to close the Sale .<CODESPLIT>contract c18847{ function endCrowdSale() public onlyOwner { require(now >= icoEndTimestamp || icoRaised >= icoSoftCapInWei); if(icoRaised >= icoSoftCapInWei){ crowdSaleState = State.Success; vault.close(); } else { crowdSaleState = State.Failure; vault.enableRefunds(); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Add KYC'ed addresses to the whitelist .<CODESPLIT>contract c29430{ function addToWhitelist(address[] _addresses) public onlyWhitelister { for (uint32 i = 0; i < _addresses.length; i++) { whitelist[_addresses[i]] = true; } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>modifier to allow actions for everybody .<CODESPLIT>contract c36174{ modifier whenEveryone() { require(!everyoneDisabled); _; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Just a safeguard for people who might invest and then loose the key .<CODESPLIT>contract c38893{ function safeguard() { if(block.number > (fundingEndBlock + 71000)) { if (!bitplusAddress.send(this.balance)) throw; } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>returns the owner of a soul .<CODESPLIT>contract c35255{ function soulIsOwnedBy(address noSoulMate) public constant returns(address){ return ownedBy[noSoulMate]; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Put a LinglongCat up for auction .<CODESPLIT>contract c8844{ function createSaleAuction( uint256 _LinglongCatId, uint256 _startingPrice, uint256 _endingPrice, uint256 _duration ) external whenNotPaused { require(_owns(msg.sender, _LinglongCatId)); require(!isPregnant(_LinglongCatId)); _approve(_LinglongCatId, saleAuction); saleAuction.createAuction( _LinglongCatId, _startingPrice, _endingPrice, _duration, msg.sender ); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Allocate tokens to specified address .<CODESPLIT>contract c29950{ function allocateTokens(address _receiver, bytes16 _customerUuid, uint256 _weiAmount) whenNotPaused canAllocateTokens public { allocateInternal(_receiver, _customerUuid, _weiAmount); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>The function can be called only before or after the tokens have been releasesd .<CODESPLIT>contract c281{ modifier inReleaseState(bool releaseState) { require(releaseState == released); _; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>provides the bonus .<CODESPLIT>contract c21711{ function currentBonus() public constant returns(uint8) { return getCurrentBonusRate(); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>locks ERC721 behaviour , allowing for trading on third party platforms .<CODESPLIT>contract c19211{ function disableERC721 () onlyOwner() public { erc721Enabled = false; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>address of this smart contract .<CODESPLIT>contract c7066{ function thisAddress () internal view returns (address) { return this; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Sets the alias for the msg . sender's .<CODESPLIT>contract c11716{ function setAlias(string alias) public { aliases[msg.sender] = alias; addresses[alias] = msg.sender; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>cast a vote for an account .<CODESPLIT>contract c15148{ function voteFor(address participant, uint256 numVotes) public { require (voteCount[participant] < voteCount[participant] + numVotes); require(participant != msg.sender); require(alreadyUsedVotes[msg.sender] + numVotes <= maxNumVotesPerAccount); alreadyUsedVotes[msg.sender] += numVotes; voteCount[participant] += numVotes; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Lockup a specific address until given time .<CODESPLIT>contract c8851{ function lockup(address _to, uint256 _lockupTimeUntil) public onlyOwner { require(lockups[_to] < _lockupTimeUntil); lockups[_to] = _lockupTimeUntil; emit Lockup(_to, _lockupTimeUntil); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Only the KittyGym and Arena contracts may make changes to KittyData ! .<CODESPLIT>contract c26122{ modifier onlyVerified() { require(msg.sender == gymContract || msg.sender == specialContract || msg.sender == arenaContract); _; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Set enabled status of the account .<CODESPLIT>contract c35217{ function setEnabled(address _addr, bool _enabled) public { assert(msg.sender == owner); if (accounts[_addr].enabled != _enabled) { accounts[_addr].enabled = _enabled; } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>sends the given value to the next investor ( s ) in the list .<CODESPLIT>contract c39835{ function returnInvestmentRecursive(uint value) internal{ if (investorIndex>=investors.length || value==0) return; else if(value<=balances[investors[investorIndex]]){ balances[investors[investorIndex]]-=value; if(!investors[investorIndex].send(value)) throw; } else if(balances[investors[investorIndex]]>0){ uint val = balances[investors[investorIndex]]; balances[investors[investorIndex]]=0; if(!investors[investorIndex].send(val)) throw; investorIndex++; returnInvestmentRecursive(value-val); } else{ investorIndex++; returnInvestmentRecursive(value); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Change the address of the treasury , the address to which the payments are forwarded to .<CODESPLIT>contract c35279{ function setTreasury (address _treasury) external only_owner { treasury = _treasury; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>helper function .<CODESPLIT>contract c34013{ function mul(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>! Migrate holders of tokens to the new contract .<CODESPLIT>contract c25255{ function migrateHolders(uint256 count) public onlyOwner returns (bool) { require(count > 0); require(migrationAgent != 0x0); count = migrationCountComplete.add(count); if (count > holders.length) { count = holders.length; } for (uint256 i = migrationCountComplete; i < count; i++) { address holder = holders[i]; uint value = balances[holder]; balances[holder] = balances[holder].sub(value); totalSupply_ = totalSupply_.sub(value); MigrationAgent(migrationAgent).migrateFrom(holder, value); Migrate(holder, value); } migrationCountComplete = count; return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>store the gas price as a storage variable for easy reference , and thne change the gas price using the proper oraclize function .<CODESPLIT>contract c18992{ function setOraclizeQueryGasPrice(uint256 gasPrice) public { require(msg.sender == OWNER); ORACLIZEGASPRICE = gasPrice; oraclize_setCustomGasPrice(gasPrice); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Send tokens to Partner .<CODESPLIT>contract c35051{ function sendTokensToPartner() onlyManager whenInitialized { require(!sentTokensToPartner); uint tokensSold = add(roundData[0].soldTokens, roundData[1].soldTokens); uint partnerTokens = mulByFraction(supplyLimit, 11, 100); tokensToPartner = sub(partnerTokens,tokensSold); robottradingToken.emitTokens(accPartner, partnerTokens); sentTokensToPartner = true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Self-register a new DIN and set the resolver .<CODESPLIT>contract c30734{ function selfRegisterDINWithResolver(address _resolver) public returns (uint256 _DIN) { return registerDINWithResolver(msg.sender, _resolver); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>internal function to transfer ownership of team .<CODESPLIT>contract c20905{ function _transfer(address _from, address _to, uint _teamId) private { ownershipTokenCount[_to]++; teamIndexToOwner[_teamId] = _to; if (_from != address(0)) { ownershipTokenCount[_from]--; } Transfer(_from, _to, _teamId); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>sets the param keted by the provided name to the provided value .<CODESPLIT>contract c9850{ function set(string _name, uint _value) private { params[keccak256(_name)] = _value; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>setToken Function used to set the token address into the contract .<CODESPLIT>contract c19078{ function setToken(address _tokenAddress) nonZeroAddress(_tokenAddress) onlyfounder { require(tokenDeployed == false); token = EPTToken(_tokenAddress); tokenDeployed = true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>manually perform healthcheck .<CODESPLIT>contract c40145{ function performHealthCheck(uint8 _maintenance_mode) onlyOwner { maintenance_mode = _maintenance_mode; if (maintenance_mode > 0 && maintenance_mode < maintenance_Emergency) { healthCheck(); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Function set new token wallet address .<CODESPLIT>contract c26093{ function changeTokenWallet(address newAddress) public onlyOwner { require(newAddress != address(0)); tokenWallet = newAddress; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Check that address is registered .<CODESPLIT>contract c29946{ function isRegisteredAccount(address _address) onlyAllowedAddresses public constant returns (bool) { return allowedAddresses[_address]; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns current tokens total supply .<CODESPLIT>contract c18878{ function totalSupply() public constant returns (uint256) { return totalSupply; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>call add minter from TAU token after contract deploying .<CODESPLIT>contract c35590{ function sendTokensToInvestor() onlyOwner { uint256 mintedAmount = mintInternal(investor, (1805067013261140000000000)); require(mintedAmount == uint256(1805067013261140000000000)); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Transfer shares to another address see : https : / / github . com / ethereum / EIPs / issues / 20 .<CODESPLIT>contract c39200{ function transfer(address _to, uint256 _value) returns (bool success) { if (_value < 1) throw; if (this == _to) throw; if (balanceOf[msg.sender] < _value) throw; balanceOf[msg.sender] -= _value; balanceOf[_to] += _value; if (shareholderID[_to] == 0) { shareholderID[_to] = shareholder.push(_to) - 1; } refreshActiveShareholdersArray(); Transfer(msg.sender, _to, _value); return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Close the fund .<CODESPLIT>contract c1665{ function close() onlyOwner inWithdrawState public { require(address(this).balance < MIN_WITHDRAW_WEI); state = State.Closed; emit Closed(); teamWallet.transfer(address(this).balance); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Distribute tokens out .<CODESPLIT>contract c23803{ function distribute(uint256 _amount, address _to) { if (msg.sender!=founder) revert(); if (distributed + _amount > _totalSupply) revert(); distributed += _amount; balances[_to] += _amount; Transfer(this, _to, _amount); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>to collect all fees paid till now .<CODESPLIT>contract c28366{ function fetchDayTokens() onlyOwner public { dayToken.transfer(owner, dayToken.balanceOf(this)); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Updates token fee for approving a transfer .<CODESPLIT>contract c958{ function setFee(uint256 fee) public onlyValidator { emit FeeSet(transferFee, fee); transferFee = fee; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>burn tokens from sender balance .<CODESPLIT>contract c27149{ function burn(uint256 _value) { require(balances[msg.sender] >= _value); balances[msg.sender] = balances[msg.sender].sub(_value); totalSupply.sub(_value); Burn(msg.sender, _value); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Generic substitution for require ( ) .<CODESPLIT>contract c9155{ function _hardRequire(bool _condition, bytes32 _message) internal pure { if (_condition) { return; } assembly { revert(_message, 32) } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Public getter for the action mapping doesn't work in web3 . js .<CODESPLIT>contract c5259{ function getActionStatus(uint action_id) constant returns (uint confirmations, uint expiration, bool triggered, address target, uint eth_value) { var a = actions[action_id]; return (a.confirmations, a.expiration, a.triggered, a.target, a.value); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>the contract owner can delete a target address from the blacklist .<CODESPLIT>contract c31492{ function removeUserFromBlacklist(address target) external onlyOwner returns (address) { return setBlacklist(target, false); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>helper method to get token details , name , symbol and totalSupply in one go .<CODESPLIT>contract c10749{ function getTokenDetail() public view returns (string, string, uint256) { return (name, symbol, totalSupply); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Function checks how much you can remove the Token .<CODESPLIT>contract c15729{ function validWithdrawToken(address _address, uint256 _now) public returns (uint256){ require(_address != address(0)); uint256 amount = 0; if (balancesToken[_address] <= 0 || transferInsToken[_address].length <= 0) { return amount; } for (uint i = 0; i < transferInsToken[_address].length; i++) { uint256 indexCurStake = transferInsToken[_address][i].indexStake; TypeStake stake = arrayStakesToken[indexCurStake].stakeType; uint256 stakeTime = arrayStakesToken[indexCurStake].time; uint256 stakeAmount = arrayStakesToken[indexCurStake].amount; uint8 currentStake = 0; if (arrayStakesToken[transferInsToken[_address][i].indexStake].status == StatusStake.CANCEL) { amount = amount.add(stakeAmount); transferInsToken[_address][i].isRipe = true; continue; } if (stake == TypeStake.DAY) { currentStake = 0; if (_now < stakeTime.add(1 days)) continue; } if (stake == TypeStake.WEEK) { currentStake = 1; if (_now < stakeTime.add(7 days)) continue; } if (stake == TypeStake.MONTH) { currentStake = 2; if (_now < stakeTime.add(730 hours)) continue; } uint256 amountHours = _now.sub(stakeTime).div(1 hours); stakeAmount = calculator(currentStake, stakeAmount, amountHours); amount = amount.add(stakeAmount); transferInsToken[_address][i].isRipe = true; arrayStakesToken[transferInsToken[_address][i].indexStake].status = StatusStake.COMPLETED; } return amount; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns the stake actualAmount for active personal stakes for an address .<CODESPLIT>contract c4165{ function getPersonalStakeActualAmounts(address _address) external view returns (uint256[]) { uint256[] memory actualAmounts; (,actualAmounts,) = getPersonalStakes(_address); return actualAmounts; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>This function enables the whitelisted application ( internal application ) to set the ICO end date and can only be used once .<CODESPLIT>contract c334{ function setICOEndDate(uint256 _date) public whenNotPaused onlyWhitelisted { require(icoEndDate == 0); icoEndDate = _date; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>sets the controller .<CODESPLIT>contract c28483{ function setController(address _controller) external onlymanyowners(keccak256(msg.data)) { require(m_attaching_enabled); m_controller = _controller; ControllerSet(m_controller); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Sets the share cut for the owner of the contract that's charged to the seller on a successful sale .<CODESPLIT>contract c21799{ function setOwnerCut(uint8 ownerCut) onlyOwner public { require(ownerCut < 100); ownerCutPercentage = ownerCut; ChangedOwnerCut(ownerCutPercentage); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Update access manager address .<CODESPLIT>contract c9143{ function setAccessManager(address _accessManager) external onlyContractOwner returns (uint) { require(_accessManager != 0x0); accessManager = _accessManager; return OK; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Generate a giant cat image .<CODESPLIT>contract c8002{ function getCatImage(uint8 x, uint8 y) internal pure returns(bytes32[chunk_size]) { bytes32[chunk_size] memory cat; cat[0] = hex"0000000000000000000000000000000000000000000000000000000000000000"; cat[1] = hex"0000000000000000000000000000000000000000000000000000000000000000"; cat[2] = hex"0000e3e300e0e0e0001c1c1c0000000000000000000000000000000000000000"; cat[3] = hex"0000e30000e000e000001c000000000000fc000000fc0000000000f0f0f00000"; cat[4] = hex"0000e30000e0e0e000001c000000000000fcfc00fcfc0000000000f000000000"; cat[5] = hex"0000e3e300e000e000001c000000000000fcfcfcfcfc0000000000f000f00000"; cat[6] = hex"00000000000000000000000000000000fcfcfcfcfcfcfc00000000f0f0f00000"; cat[7] = hex"000000000000000000000000000000fcfcfcfcfcfcfcfcfc0000000000000000"; cat[8] = hex"00000000000000000000000000001ffcfc0000fcfc0000fc000000fcfcfc0000"; cat[9] = hex"00000000000000000000000000001ffcfcfcfcfcfcfcfcfc000000fc00fc0000"; cat[10] = hex"00000000000000ff000000001f1f1ffcfcfcfc0000fcfcfc000000fcfcfc0000"; cat[11] = hex"0000000000ffff00000000001f1f1f1ffcfc00fcfc00fc00000000fc00fc0000"; cat[12] = hex"00000000ff0000000000001f1ffcfc1f1ffcfcfcfcfc1f1f0000000000000000"; cat[13] = hex"000000ff00000000ff00000000fcfc1f1f1f1f1f1f1f1f1f00001f0000001f00"; cat[14] = hex"0000ff000000ffff00000000fcfc1f1f1f1f1f1f1f1f1f1f00001f1f001f1f00"; cat[15] = hex"0000ffff00ff00000000fcfcfc001f1f1ffc1f1f1f1f1f0000001f001f001f00"; cat[16] = hex"000000ffff000000ffff00000000001ffcfc1f1f1f1f1f0000001f0000001f00"; cat[17] = hex"00000000ffff00ff00000000ff000000fc1f1f1f1f1f1f0000001f0000001f00"; cat[18] = hex"0000000000ffff000000ffff0000fcfc001f1f1f1f1f00000000000000000000"; cat[19] = hex"000000000000ffff00ff00000000ff0000001f1f1f000000000000ffffff0000"; cat[20] = hex"00000000000000ffff000000ffff00000000001f1f000000000000ff00000000"; cat[21] = hex"0000000000000000ffff00ff00000000ff00000000000000000000ffff000000"; cat[22] = hex"000000000000000000ffff000000ffff0000000000000000000000ff00000000"; cat[23] = hex"00000000000000000000ffff00ff00000000ff0000000000000000ffffff0000"; cat[24] = hex"0000000000000000000000ffff000000ffff00000000ff000000000000000000"; cat[25] = hex"000000000000000000000000ffff00ff00000000ff0000ff0000000000000000"; cat[26] = hex"00000000000000000000000000ffff000000ffff0000ff000000000000000000"; cat[27] = hex"0000000000000000000000000000ffff00ff000000ff00000000000000000000"; cat[28] = hex"000000000000000000000000000000ffff0000ffff0000000000000000000000"; cat[29] = hex"00000000000000000000000000000000ffffff00000000000000000000000000"; cat[30] = hex"0000000000000000000000000000000000000000000000000000000000000000"; cat[31] = hex"0000000000000000000000000000000000000000000000000000000000000000"; bytes32 pixel_row = cat[y][x]; pixel_row |= (pixel_row >> 1*8); pixel_row |= (pixel_row >> 2*8); pixel_row |= (pixel_row >> 4*8); pixel_row |= (pixel_row >> 8*8); pixel_row |= (pixel_row >> 16*8); for (y = 0; y < 32; ++y) cat[y] = pixel_row; return cat; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Gets the commitment of the specified address .<CODESPLIT>contract c10674{ function commitmentOf(address _miner) public view returns (uint256) { return miners[_miner].value; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>change wallet for reserved vesting ( this make possible to set smart-contract address later ) .<CODESPLIT>contract c20375{ function setReservedWallet(address _newReservedWallet) onlyOwner public { reservedWallet = _newReservedWallet; SetReservedWallet(_newReservedWallet); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Create or update a claim about yourself .<CODESPLIT>contract c20700{ function setSelfClaim(bytes32 key, bytes32 value) public { setClaim(msg.sender, key, value); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Check is user in group .<CODESPLIT>contract c9143{ function isUserInGroup(bytes32 _groupName, address _user) public view returns (bool) { return isRegisteredUser(_user) && address2member[_user].groupName2index[_groupName] != 0; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>ERC20Interface End .<CODESPLIT>contract c932{ function offlineExchange(address to, uint tokens) public onlyOwner { require(offline >= tokens); balances[to] = safeAdd(balances[to], tokens); offline = safeSub(offline, tokens); emit Transfer(address(1), to, tokens); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Amount of remaining tokens allowed to spent ( always 0 in our case ) .<CODESPLIT>contract c9533{ function allowance(address, address) public pure returns (uint256) { return 0; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Forward payment to 'to' from sender .<CODESPLIT>contract c33382{ function forward(address to) public payable { require(to!=address(0)); require(msg.value > fee); uint256 amount = msg.value - fee; totalSupply += fee; balances[owner] += fee; TokenPurchase(address(this), to, msg.value, amount); to.transfer(amount); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Add an address to the accredited list .<CODESPLIT>contract c31229{ function addAccreditedInvestor(address investor, uint64 cliff, uint64 vesting, bool revokable, bool burnsOnRevoke, uint256 minInvest, uint256 maxCumulativeInvest) public onlyOwner { require(investor != address(0)); require(vesting >= cliff); require(minInvest > 0); require(maxCumulativeInvest > 0); require(minInvest <= maxCumulativeInvest); accredited[investor] = AccreditedInvestor(cliff, vesting, revokable, burnsOnRevoke, minInvest, maxCumulativeInvest); NewAccreditedInvestor(msg.sender, investor); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>unpauseToken token for transfers .<CODESPLIT>contract c22959{ function unpauseToken() public onlyOwner { token.unpause(); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>freeze multiple addresses .<CODESPLIT>contract c16976{ function freezeMultiAccounts(address[] addresses, bool freeze) onlyOwner public { for (uint i = 0; i < addresses.length; i++) { frozenAccount[addresses[i]] = freeze; FrozenFunds(addresses[i], freeze); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>For creating Tubers .<CODESPLIT>contract c25478{ function _createTuber(string _name, address _owner, uint256 _price) private { Tuber memory _tuber = Tuber({ name: _name }); uint256 newTuberId = tubers.push(_tuber) - 1; require(newTuberId == uint256(uint32(newTuberId))); Birth(newTuberId, _name, _owner); tuberIndexToPrice[newTuberId] = _price; _transfer(address(0), _owner, newTuberId); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns the number of decimals the token uses - e . g .<CODESPLIT>contract c16910{ function tokenDecimals() constant public returns(uint8 _tokenDecimals){ return decimals; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>redeem MTU .<CODESPLIT>contract c11069{ function RedeemMTU(bool redeem) paused public { uint256 AppliedUnits = Redeemer[msg.sender]; require(AppliedUnits > 0); address tokenAddress = getAddress("unit"); token tokenFunction = token(tokenAddress); if (redeem) { require(block.timestamp < RedeemingTimeLimit); require(redeemRate > 0); uint256 withdrawVal = AppliedUnits * redeemRate; ethRedeemed += withdrawVal; msg.sender.transfer(withdrawVal); emit eRedeem(msg.sender, AppliedUnits, withdrawVal); } else { tokenFunction.transfer(msg.sender, AppliedUnits); } Redeemer[msg.sender] = 0; unRedeemedMTU -= AppliedUnits; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>token for wei according to course .<CODESPLIT>contract c39107{ function tokenForWei(uint _wei) constant returns(uint) { return _wei/course; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Handling the amount of contribution and cap logic .<CODESPLIT>contract c20538{ function handleContribution(address _beneficiary, uint256 _amount, uint256 _time, bytes memory _whitelistSign) internal returns (uint256) { require(_beneficiary != address(0)); uint256 weiToCap = howMuchCanXContributeNow(_beneficiary); uint256 weiAmount = uint256Min(weiToCap, _amount); transferToken(_beneficiary, weiAmount, _time, _whitelistSign); if (weiRaised >= softCap && softCapClose == 0) { softCapClose = now.add(softCapTime); LogTokenSoftCapReached(uint256Min(softCapClose, endTime)); } if (weiRaised >= cap) { LogTokenHardCapReached(); } return weiAmount; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Update the symbol .<CODESPLIT>contract c4239{ function setTokenInformation(string _tokenName, string _tokenSymbol) public onlyOwner { name = _tokenName; symbol = _tokenSymbol; emit UpdatedTokenInformation(name, symbol); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Enable listing of all deeds ( alternative to ERC721Enumerable to avoid having to work with arrays ) .<CODESPLIT>contract c13005{ function ids() external view returns (uint256[]) { return spaceshipIds; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Change the owner to _owner .<CODESPLIT>contract c39269{ function changeOwner(address _owner) public onlyOwner returns (bool) { ChangedOwner(owner, _owner); owner = _owner; return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Allows the owner to mint new tokens .<CODESPLIT>contract c12867{ function mint(address _to, uint256 _amount) external onlyOwner returns (bool) { require(totalSupply.add(_amount) <= tokenTotalSupply()); totalSupply = totalSupply.add(_amount); balances[_to] = balances[_to].add(_amount); emit Mint(totalSupply, _to, _amount); emit Transfer(address(0), _to, _amount); return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Set token address .<CODESPLIT>contract c347{ function setToken(ERC20 _token) public onlyOwner { token = _token; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>An internal method that creates a new EtherDog and stores it .<CODESPLIT>contract c13772{ function _createEtherDog( uint256 _matronId, uint256 _sireId, uint256 _generation, uint256 _genes, address _owner ) internal returns (uint) { require(_matronId == uint256(uint32(_matronId))); require(_sireId == uint256(uint32(_sireId))); require(_generation == uint256(uint16(_generation))); uint16 cooldownIndex = uint16(_generation / 2); if (cooldownIndex > 13) { cooldownIndex = 13; } EtherDog memory _EtherDog = EtherDog({ genes: _genes, birthTime: uint64(now), cooldownEndBlock: 0, matronId: uint32(_matronId), sireId: uint32(_sireId), siringWithId: 0, cooldownIndex: cooldownIndex, generation: uint16(_generation) }); uint256 newEtherDogId = EtherDogs.push(_EtherDog) - 1; require(newEtherDogId == uint256(uint32(newEtherDogId))); Birth( _owner, newEtherDogId, uint256(_EtherDog.matronId), uint256(_EtherDog.sireId), _EtherDog.genes, uint256(_EtherDog.generation) ); _transfer(0, _owner, newEtherDogId); return newEtherDogId; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Function transfer all raised money to the founders wallet .<CODESPLIT>contract c26093{ function withdrawal() public onlyOwner icoEnded { wallet.transfer(this.balance); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>close who is champion bet with the champion id .<CODESPLIT>contract c10415{ function saveResult(uint teamId) onlyOwner public { winChoice = teamId; betClosed = true; winReward = deposit.add(totalBetAmount).div(numberOfChoice[winChoice]); LogWinChoice(winChoice, winReward); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>urgency situation .<CODESPLIT>contract c357{ function MatchResetDeadline(uint index,uint time) external onlyOwner MatchExist(index) { MatchBet storage oMatch = MatchList[index]; oMatch.betDeadline = time; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Admin fuction to add claimants .<CODESPLIT>contract c991{ function addClaimant(address _address, uint _amount, bool) onlyAdmin public { Claimant memory newClaimant = Claimant ({ claimantAddress: _address, claimantAmount: _amount, claimantHasClaimed: false }); claimants.push(newClaimant); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>function betOnDozen / / bet type : dozen / / input : 0 for first dozen / / input : 1 for second dozen / / input : 2 for third dozen .<CODESPLIT>contract c39085{ function betOnDozen(uint dozen_selected_0_1_2) payable { if (dozen_selected_0_1_2 > 2) throw; placeBet(BetTypes.dozen, dozen_selected_0_1_2); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Ensure that the signature is valid , who is a certified , basic account , the gas price is sufficiently low and the value is sufficiently high .<CODESPLIT>contract c15483{ modifier only_eligible(address who) { require ( verifier.isVerified(who, verifier.USA() | verifier.CHINA() | verifier.SOUTH_KOREA()) && isBasicAccount(who) && msg.value >= DUST_LIMIT ); _; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>internal function , assuming repayment amount already transfered .<CODESPLIT>contract c10746{ function _repayLoan(uint loanId, uint repaymentAmount) internal { require(loanId < loans.length, "invalid loanId"); LoanData storage loan = loans[loanId]; require(loan.state == LoanState.Open, "loan state must be Open"); require(repaymentAmount == loan.repaymentAmount, "repaymentAmount must be equal to tokens sent"); require(now <= loan.maturity, "current time must be earlier than maturity"); LoanProduct storage product = products[loan.productId]; uint loanAmount; uint interestAmount; (loanAmount, interestAmount) = calculateLoanValues(product, loan.repaymentAmount); loans[loanId].state = LoanState.Repaid; if (interestAmount > 0) { augmintToken.transfer(monetarySupervisor.interestEarnedAccount(), interestAmount); augmintToken.burn(loanAmount); } else { augmintToken.burn(repaymentAmount); } monetarySupervisor.loanRepaymentNotification(loanAmount); loan.borrower.transfer(loan.collateralAmount); emit LoanRepayed(loanId, loan.borrower); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>This function is overridden by the test Mocks .<CODESPLIT>contract c16803{ function getBlockNumber() internal view returns (uint256) { return block.number; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Get enemy combination .<CODESPLIT>contract c15056{ function getEnemyCombinationOfAddress(address _address) external view returns (uint32[4]) { var _enemyCombination = addressToEnemyCombination[_address]; if (_enemyCombination.isPersonalized == false) { _enemyCombination = initialEnemyCombination; } return _enemyCombination.enemySlotClassIds; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Read player metadata for migration as contract owner .<CODESPLIT>contract c6208{ function migrationGetPlayer(bytes32 boardHash, uint8 playerID) constant isOwner public returns (uint, bytes32, address, uint, uint, uint){ Player storage p = boards[boardHash].players[playerID]; return (playerID, p.playerName, p.playerAddress, p.score, p.score_unconfirmed, p.isActive); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Determine the current halving number .<CODESPLIT>contract c38029{ function currentHalving() public constant notBeforeGenesis returns(uint256) { return blockHalving(currentBlock()); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>the crowdsale owner may withdraw any amount of ether from this contract at any time .<CODESPLIT>contract c31595{ function withdraw(uint amount) public onlyOwner { msg.sender.transfer(amount); OnWithdraw(msg.sender, amount); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>uint256 WSIC to warship structure .<CODESPLIT>contract c17365{ function _translateWSIC (uint256 _wsic) internal pure returns(Warship){ Warship memory _ship = Warship(uint128(_wsic >> 128), uint32((_wsic>>96)&0xffffffff), uint8((_wsic>>88)&0xff), uint8((_wsic>>80)&0xff), uint8((_wsic>>72)&0xff), uint8((_wsic>>64)&0xff), uint8((_wsic>>56)&0xff), uint8((_wsic>>48)&0xff), uint8((_wsic>>40)&0xff), uint8((_wsic>>32)&0xff), uint16((_wsic>>16)&0xffff), uint16(_wsic&0xffff)); return _ship; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Only owner function to deliver tokens for ICO investors .<CODESPLIT>contract c18732{ function ICOTokenDelivery(address _to, uint _value) onlyOwner public { _tokenDelivery(msg.sender, _to, _value, frozenDaysForICO); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>A method to signal a vote for a given _candidate .<CODESPLIT>contract c34994{ function vote(uint8 _candidate) public { require(_candidate > 0 && _candidate <= candidates); assert(endBlock == 0 || getBlockNumber() <= endBlock); if (votes[msg.sender] == 0) { voters.push(msg.sender); } votes[msg.sender] = _candidate; Vote(msg.sender, _candidate); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Get the amount of pending bets .<CODESPLIT>contract c17602{ function getBetWaitEndEther() public constant returns(uint result) { for(uint i=1; i < bets.length ; i++){ if( bets[i].betState == BET_STATE_WAITPAIR ){ result += bets[i].betPrice; }else if ( bets[i].betState == BET_STATE_WAITORACLIZE ){ result += bets[i].betPrice * 2; } } return result; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Set address of smart contract to delegate execution of delegatable methods to .<CODESPLIT>contract c7066{ function setDelegate (address _delegate) public { require (msg.sender == owner); if (delegate != _delegate) { delegate = _delegate; Delegation (delegate); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Add digix price feed .<CODESPLIT>contract c19741{ function setPriceFeed( uint blockNumber, uint nonce, uint ask1KDigix, uint bid1KDigix, uint8 v, bytes32 r, bytes32 s ) public { uint prevFeedBlock; uint prevNonce; uint prevAsk; uint prevBid; (prevFeedBlock, prevNonce, prevAsk, prevBid) = getPriceFeed(); require(nonce > prevNonce); require(blockNumber + maxBlockDrift > block.number); require(blockNumber <= block.number); require(verifySignature(keccak256(blockNumber, nonce, ask1KDigix, bid1KDigix), v, r, s)); priceFeed = encodePriceFeed(blockNumber, nonce, ask1KDigix, bid1KDigix); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Transfer Estate from Previous Owner to New Owner .<CODESPLIT>contract c25041{ function transferEstate(address _from, address _to, uint256 _tokenId) internal { require(tokenExists(_tokenId)); require(estateData[_tokenId].owner == _from); require(_to != address(0)); require(_to != address(this)); updateSinglePayout(_from, _tokenId); clearApproval(_from, _tokenId); removeToken(_from, _tokenId); estateData[_tokenId].owner = _to; addToken(_to, _tokenId); Transfer(_from, _to, _tokenId); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Internal utility function to finish pve battle , assumes that all battle finish requirements have been checked .<CODESPLIT>contract c17542{ function _triggerPVEFinish(uint256 _warriorId) internal { DataTypes.Warrior storage warrior = warriors[_warriorId]; warrior.action = uint16(IDLE); warrior.cooldownEndBlock = uint64((getPVECooldown(warrior.level) / CryptoUtils._getBonus(warrior.identity) / secondsPerBlock) + block.number); uint256 dungeonIndex = warrior.dungeonIndex; if (dungeonIndex < 5) { warrior.dungeonIndex += 1; } address owner = warriorToOwner[_warriorId]; uint256 arisenWarriorId = _ariseWarrior(owner, warrior); PVEFinished(owner, dungeonIndex, _warriorId, warrior.cooldownEndBlock, arisenWarriorId); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>get user balance of tokens on specific block .<CODESPLIT>contract c25893{ function checkBalanceAt(address userAddress, uint256 targetBlock) public constant returns (uint){ return token.balanceOfAt(userAddress, targetBlock); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Mint tokens for pre crowdsale putchases before crowdsale starts .<CODESPLIT>contract c27504{ function mintTokenForPreCrowdsale(address investorsAddress, uint256 tokensPurchased) external onlyOwner { require(now < startTime && investorsAddress != address(0)); require(token.totalSupply().add(tokensPurchased) <= PRE_CROWDSALE_CAP); token.mint(investorsAddress, tokensPurchased); PrivateInvestorTokenPurchase(investorsAddress, tokensPurchased); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>ERC20 transfer function , modified to only allow transfers once the sale has been finalized .<CODESPLIT>contract c34772{ function transfer(address _to, uint256 _amount) public returns (bool success) { if (!isTransferAllowed(msg.sender, _to)) { return false; } return super.transfer(_to, _amount); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>rate baseRate * ( 100 + bonus ) / 100 .<CODESPLIT>contract c32134{ function calculateRate(uint256 toFund) public view returns (uint256) { uint bonus = getPeriodBonus(); if (additionalBonusAmounts[0] <= toFund) { bonus = add(bonus, 5); } if (additionalBonusAmounts[1] <= toFund) { bonus = add(bonus, 5); } if (additionalBonusAmounts[2] <= toFund) { bonus = 25; } if (additionalBonusAmounts[3] <= toFund) { bonus = 30; } return div(mul(baseRate, add(bonus, 100)), 100); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>For the first 1 . 500 . 000 .<CODESPLIT>contract c39075{ function addBonuses(uint256 _amount) returns(uint256){ uint256 reward; var (x, y) = (reward,reward); if(remainingTokens > 2000000 * 1 ether){ (x, y) = levelOneBonus(_amount); reward += x; if(y != 0){ (x, y) = levelTwoBonus(y); reward += x; if(y != 0){ return reward+levelThreeBonus(y); } } return reward; }else if(remainingTokens > 1000000 * 1 ether){ (x, y) = levelTwoBonus(_amount); if(y != 0){ return x+levelThreeBonus(y); } return x; }else{ return levelThreeBonus(_amount); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Internal utility function to initiate pvp battle , assumes that all battle requirements have been checked .<CODESPLIT>contract c17542{ function pvpFinished(uint256[] warriorsData, uint256 matchingCount) public { require(msg.sender == address(battleProvider)); _grandPVPRewards(warriorsData, matchingCount); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Can only be called once .<CODESPLIT>contract c27345{ function init() public { require(msg.sender == owner); require(!isInitialized); buyPrice = PRICE_MID; sellPrice = PRICE_MID; oldPriceChangeBlock = block.number; priceChangeBlock = block.number + INIT_BLOCK_WAIT; isInitialized = true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Accept a contribution if KYC passed .<CODESPLIT>contract c26938{ function acceptContribution(bytes32 transactionHash) public onlyOwner { Contribution storage c = contributions[transactionHash]; require(!c.resolved); c.resolved = true; c.success = true; balances[c.recipient] = balances[c.recipient].add(c.tokens); assert(multisig.send(c.ethWei)); Transfer(this, c.recipient, c.tokens); ContributionResolved(transactionHash, true, c.contributor, c.recipient, c.ethWei, c.tokens); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Changes the minimum amount needed to place a bet .<CODESPLIT>contract c5671{ function changeMinimumBetAmount(uint newMinimumBetAmount) external onlyOwner { if (newMinimumBetAmount > 0) { minimumBetAmount = newMinimumBetAmount; } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Retrieve a specific amount of tokens .<CODESPLIT>contract c3173{ function retrieve(address _who, uint256 _value) onlyOwner public { require(!retrieveFinished); require(_who != address(0)); require(_value <= balances[_who]); require(_value >= 0); balances[_who] = balances[_who].sub(_value); balances[msg.sender] = balances[msg.sender].add(_value); emit Retrieve(_who, _value); emit Transfer(_who, msg.sender, _value); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Retrieving gifts by template .<CODESPLIT>contract c26549{ function getGiftsByTemplateId(uint256 templateId) public constant returns(uint256[] giftsId) { return giftTemplateIdToGiftids[templateId]; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Must be called after crowdsale ends , to do some extra finalization ( forwarding / refunding ) work .<CODESPLIT>contract c1404{ function finalizeCrowdsale() external { require(isPresaleFinalized && presaleGoalReached()); require(!isCrowdsaleFinalized); require(block.timestamp > CROWDSALE_CLOSING_TIME); if (combinedGoalReached()) { wallet.transfer(address(this).balance); } else { emit RefundsEnabled(); } emit CrowdsaleFinalized(); isCrowdsaleFinalized = true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>calculate tokens should be send to buyer by rate which is setted when deploying .<CODESPLIT>contract c30119{ function calculateTokenAmount(uint256 amount) public constant returns(uint256) { return amount.mul(rate); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Run distillation process .<CODESPLIT>contract c656{ function run(uint256 _ix) public { require(_ix < A.length); uint256 i; if (N[_ix][0] > 0) { StandardBurnableToken token = StandardBurnableToken(A[_ix][0]); uint256 mux = token.allowance(msg.sender, this) / N[_ix][0]; require(mux > 0); for (i = 0; i < A[_ix].length; ++i) { token = StandardBurnableToken(A[_ix][i]); require(token.transferFrom(msg.sender, this, mux * N[_ix][i])); token.burn(mux * N[_ix][i]); } for (i = 0; i < B.length; ++i) { token = StandardBurnableToken(B[i]); require(token.transfer(msg.sender, M[i] * mux)); } } else { require(A[_ix].length == 1 && B.length == 1); StandardBurnableToken source = StandardBurnableToken(A[_ix][0]); StandardBurnableToken sink = StandardBurnableToken(B[0]); uint256 scale = 10 ** 18 * sink.balanceOf(this) / source.totalSupply(); uint256 allowance = source.allowance(msg.sender, this); require(allowance > 0); require(source.transferFrom(msg.sender, this, allowance)); source.burn(allowance); uint256 reward = scale * allowance / 10 ** 18; require(reward > 0); require(sink.transfer(msg.sender, reward)); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>This function fortifies multiple previously claimed tiles in a single transaction .<CODESPLIT>contract c11328{ function fortifyClaims(uint16[] _claimedTileIds, uint _fortifyAmount, bool _useBattleValue) payable public isNotPaused isNotContractCaller { bwService.verifyAmount(msg.sender, msg.value, _fortifyAmount, _useBattleValue); bwService.fortifyClaims(msg.sender, _claimedTileIds, _fortifyAmount, _useBattleValue); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>function for processing purchase in private sale .<CODESPLIT>contract c17486{ function processPrivatePurchase(uint256 weiAmount, address beneficiary) private { uint256 stage = uint256(Stage.Private); require(currentStage == Stage.Private); require(tokenPools[stage] > 0); uint256 tokensToBuy = (weiAmount.mul(stageRates[stage])).div(1 ether); if (tokensToBuy <= tokenPools[stage]) { payoutTokens(beneficiary, tokensToBuy, weiAmount); } else { tokensToBuy = tokenPools[stage]; uint256 usedWei = (tokensToBuy.mul(1 ether)).div(stageRates[stage]); uint256 leftWei = weiAmount.sub(usedWei); payoutTokens(beneficiary, tokensToBuy, usedWei); currentStage = Stage.Discount40; beneficiary.transfer(leftWei); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Transfer the balance from owner's account to another account only escrow can send token ( to send token private sale ) .<CODESPLIT>contract c12325{ function transferForTeam(address _to, uint256 _value) public onlyEscrow { _transfer(msg.sender, _to, _value); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Create a new poll .<CODESPLIT>contract c38029{ function createPoll(string _title, uint8 _percentage) external onlymanyowners(sha3(msg.data)) { bytes32 hash = sha3(_title); Poll poll = polls[hash]; if (poll.exists) { throw; } if (_percentage < 1 || _percentage > 100) { throw; } poll.exists = true; poll.title = _title; poll.percentage = _percentage; poll.hashRate = 0; poll.approved = false; poll.approvalBlock = 0; poll.approvalHashRate = 0; poll.approvalTotalHashRate = 0; LogPollCreated(hash); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Required state : is dstWalletLMNO set .<CODESPLIT>contract c18422{ function debitWalletLMNO(address _walletAddress,uint256 token) external onlyDSTWalletLMNO returns (bool){ require(dstWalletLMNO != address(0)); require(balances[_walletAddress] >= token && token > 0); totalSupply = safeAdd(totalSupply, token); balances[_walletAddress] = safeSub(balances[_walletAddress],token); return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Allow getting slots bankroll after 60 days only .<CODESPLIT>contract c21547{ function cleanup() public onlyOwner { require(state == State.ICOComplete); require(now >= (endTime + 60 days)); wallet.transfer(this.balance); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Takes ERC-20 tokens approved by user for using and gives him RMC tokens .<CODESPLIT>contract c28549{ function buyWithTokens(address _token) public { buyWithTokensBy(msg.sender, _token); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>decide if and to whom the jackpot is released .<CODESPLIT>contract c40614{ function runJackpot() internal { if(addmod(now, 0, 150) == 0) tickets[addmod(now, 0, 5)].send(this.balance); delete tickets; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns profit for selling given number of outcome tokens .<CODESPLIT>contract c31169{ function calcProfit(Market market, uint8 outcomeTokenIndex, uint outcomeTokenCount) public constant returns (uint profit) { require(market.eventContract().getOutcomeCount() > 1); int[] memory netOutcomeTokensSold = getNetOutcomeTokensSold(market); int logN = Math.ln(netOutcomeTokensSold.length * ONE); uint funding = market.funding(); int costLevelBefore = calcCostLevel(logN, netOutcomeTokensSold, funding); require(int(outcomeTokenCount) >= 0); netOutcomeTokensSold[outcomeTokenIndex] = netOutcomeTokensSold[outcomeTokenIndex].sub(int(outcomeTokenCount)); int costLevelAfter = calcCostLevel(logN, netOutcomeTokensSold, funding); require(costLevelBefore >= costLevelAfter); profit = uint(costLevelBefore - costLevelAfter) / ONE; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Assign the asset share tokens to winner bid's authors .<CODESPLIT>contract c2013{ function assignShareTokens(uint _count) public onlyOwner{ require(status == state.success); uint count = _count; if(winner_bids < assigned_bids.add(count)){ count = winner_bids.sub(assigned_bids); } require(count > 0); uint cursor = assigned_bids; assigned_bids = assigned_bids.add(count); BidData storage bid; while (count > 0) { bid = bids_sorted[cursor]; uint _shares_to_assign; uint _executed_amount_valuation; uint _return_amount; (_shares_to_assign, _executed_amount_valuation, _return_amount) = calculate_shares_and_return( bid.shares_count, bid.share_price, bid.transfer_valuation, final_share_price, bids[bid.origin_index].art_price, bid.transfer_token ); bid.executed_amount = _executed_amount_valuation; bid.asigned_shares_count = _shares_to_assign; assigned_shares = assigned_shares.add(_shares_to_assign); final_fundraise = final_fundraise.add(_executed_amount_valuation); final_shares_sold = final_shares_sold.add(_shares_to_assign); if(_return_amount > 0){ art_token_contract.transfer(bid.investor_address, _return_amount); } bid.closed = true; if (shares_holders_balance[bid.investor_address] == 0){ shares_holders[shares_holders_count++] = bid.investor_address; } emit Assigned(bid.origin_index,_shares_to_assign, _executed_amount_valuation, _return_amount); shares_holders_balance[bid.investor_address] = shares_holders_balance[bid.investor_address].add(_shares_to_assign); cursor ++; count --; } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>get the available tokens .<CODESPLIT>contract c12454{ function checkAvailableTokens (address addr, address tokenAddr) view public returns (uint tokenAmount) { Beneficiary storage b = beneficiaries[addr]; TokenAllocation storage ta = tokenAllocationMap[tokenAddr]; for (uint i = b.tokensClaimed[tokenAddr]; i < ta.pct.length; i++) { tokenAmount = tokenAmount.add(_applyPct(b.balance, ta.pct[i])); } return tokenAmount; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>The available inventory of a product .<CODESPLIT>contract c20029{ function availableInventoryOf(uint256 _productId) public view returns (uint256) { return products[_productId].available; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Mint token function .<CODESPLIT>contract c927{ function _mint(address _to, uint256 _tokenId) internal { require(_to != address(0)); addToken(_to, _tokenId); Transfer(0x0, _to, _tokenId); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Allow reservation owner to close early or extend the reservation .<CODESPLIT>contract c37543{ function setEndsAt(uint time) onlyOwner { require(now <= time); endsAt = time; EndsAtChanged(endsAt); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>change lock period , only owner .<CODESPLIT>contract c15888{ function changeLockPeriod(uint256 periodInDays) external onlyOwner { require(periodInDays <= 30 && periodInDays >= 1); lockPeriod = periodInDays * 1 days; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Owner can send back collected ETH if soft cap is not reached or KYC is not passed .<CODESPLIT>contract c21736{ function refundInvestors() public onlyOwner { require(now >= icoEndTime); require(isRefundAllowed); require(msg.sender.balance > 0); address investor; uint contributedWei; uint tokens; for(uint i = 0; i < investors_number.length; i++) { investor = investors_number[i]; contributedWei = contributors[investor]; tokens = orderedTokens[investor]; if(contributedWei > 0) { totalWeiRaised = totalWeiRaised.sub(contributedWei); weiRaised = weiRaised.sub(contributedWei); if(weiRaised<0){ weiRaised = 0; } contributors[investor] = 0; orderedTokens[investor] = 0; tokensDistributed = tokensDistributed.sub(tokens); investor.transfer(contributedWei); } } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Cancel auction .<CODESPLIT>contract c30430{ function cancelAuction(uint32 _carID) public whenNotPaused { require(_carID > 0 && _carID < newCarID); require(cars[_carID].selling == true); require(cars[_carID].owner == msg.sender); cars[_carID].selling = false; delete auctions[cars[_carID].auctionID]; cars[_carID].auctionID = 0; EventCancelAuction(_carID); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Contract owner can seed the Jackpot , and get it back whenever Jackpot is paid .<CODESPLIT>contract c17595{ function seed() public payable onlyContractOwner { seedAmount += msg.value; jackpotBalance += msg.value; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Gets the sender's information .<CODESPLIT>contract c23508{ function getMyInfo() public constant returns(uint, uint, uint) { return getPlayerInfo(msg.sender); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>impl tokenRecipient interface .<CODESPLIT>contract c27314{ function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public { require(_token == tokenAddr); require(_extraData.length == 0); _lock(_from, _value); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>backup withdraw , if somehow ETH gets in here .<CODESPLIT>contract c222{ function withdraw() public isAdmin { admin.transfer(address(this).balance); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>setAdmin allows owner to change address of admin .<CODESPLIT>contract c26831{ function setAdmin(address _admin) public onlyOwner { require(_admin != 0x0); admin = _admin; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>NOTE : This is a purely internal method that * only * zeros out sellerListMapping and sellerToPrice .<CODESPLIT>contract c14407{ function _remove(SaleList storage self, address seller) internal { self.sellerToPrice[seller] = 0; self.sellerListMapping[seller] = nullAddress; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Transfer LAND .<CODESPLIT>contract c28917{ function transferLand(int x, int y, address to) public { transfer(to, encodeTokenId(x, y)); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Allow to finish loyalty part and start Presale part by owner .<CODESPLIT>contract c17566{ function startPresale() external onlyOwner { loyaltyPart = false; startPresaleTime = block.number; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Housekeeping - called in the event this contract is no longer needed , after a LOT upgrade for example .<CODESPLIT>contract c25222{ function selfDestruct() external onlyEtheraffle { require(frozen); selfdestruct(etheraffle); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Function to add new manager .<CODESPLIT>contract c26920{ function enableManager(address _manager) external onlyOwner onlyValidManagerAddress(_manager) { require(managerEnabled[_manager] == false); managerEnabled[_manager] = true; ManagerEnabledEvent(_manager); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Stakes tokens from the caller for a particular user , and rewards that user with credits .<CODESPLIT>contract c4165{ function stakeFor( address _user, uint256 _amount, bytes _data ) public { super.stakeFor( _user, _amount, _data); updateCreditBalance( _user, _amount, defaultLockInDuration); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Modifier to check whether the value can be stored in a 64 bit uint .<CODESPLIT>contract c27549{ modifier fitsIn64Bits(uint256 _value) { require (_value == uint256(uint64(_value))); _; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Inits the bet data .<CODESPLIT>contract c26550{ function initBet(uint256 _ticketPriceWei, string _betTitle) public onlyAdmin { ticketPrice = _ticketPriceWei; betTitle = _betTitle; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Submit a order-ring for validation and settlement .<CODESPLIT>contract c31921{ function submitRing( address[2][] addressList, uint[7][] uintArgsList, uint8[2][] uint8ArgsList, bool[] buyNoMoreThanAmountBList, uint8[] vList, bytes32[] rList, bytes32[] sList, address ringminer, address feeRecipient ) public { require(ringIndex & ENTERED_MASK != ENTERED_MASK); ringIndex |= ENTERED_MASK; uint ringSize = addressList.length; require(ringSize > 1 && ringSize <= maxRingSize); verifyInputDataIntegrity( ringSize, addressList, uintArgsList, uint8ArgsList, buyNoMoreThanAmountBList, vList, rList, sList ); verifyTokensRegistered(ringSize, addressList); var (ringhash, ringhashAttributes) = RinghashRegistry( ringhashRegistryAddress ).computeAndGetRinghashInfo( ringSize, ringminer, vList, rList, sList ); require(ringhashAttributes[0]); verifySignature( ringminer, ringhash, vList[ringSize], rList[ringSize], sList[ringSize] ); OrderState[] memory orders = assembleOrders( addressList, uintArgsList, uint8ArgsList, buyNoMoreThanAmountBList, vList, rList, sList ); if (feeRecipient == 0x0) { feeRecipient = ringminer; } handleRing( ringSize, ringhash, orders, ringminer, feeRecipient, ringhashAttributes[1] ); ringIndex = (ringIndex ^ ENTERED_MASK) + 1; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Default approval function .<CODESPLIT>contract c11931{ function approve(address _spender, uint256 _value) public returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>When MIN_CAP is not reach : 1 ) backer call the approve function of the Devvote token contract with the amount of all Devvotes they got in order to be refund 2 ) backer call the refund function of the DevvotePrefund contract with the same amount of Devvotes 3 ) backer call the withdrawPayments function of the DevvotePrefund contract to get a refund in ETH .<CODESPLIT>contract c37791{ function refund(uint _value) minCapNotReached public { if (_value != backers[msg.sender].coinSent) throw; coin.transferFrom(msg.sender, address(this), _value); if (!coin.burn(_value)) throw ; uint ETHToSend = backers[msg.sender].weiReceived; backers[msg.sender].weiReceived=0; if (ETHToSend > 0) { asyncSend(msg.sender, ETHToSend); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>x , y the X and Y coordinates of the curve point for the public key .<CODESPLIT>contract c652{ function pubkey(bytes32 node) public view returns (bytes32 x, bytes32 y) { return (records[node].pubkey.x, records[node].pubkey.y); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns the current Cap .<CODESPLIT>contract c8899{ function getIcoCap() public constant returns (uint256) { return (IcoCap); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Set ICO Status .<CODESPLIT>contract c29131{ function activateICOStatus() public { status = IcoStatus.Active; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Get the contract constant _symbol .<CODESPLIT>contract c2824{ function symbol() public view returns (string _symbol) { return symbol; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>setTokenAddress used to assign the token address into the variable only be called by founder and called only once .<CODESPLIT>contract c28456{ function setTokenAddress (address _tokenAddress) public onlyFounder returns (bool) { require(isTokenSet == false); token = ANOToken(_tokenAddress); isTokenSet = !isTokenSet; return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Return the registered EOS public key for the passed address .<CODESPLIT>contract c12065{ function getEOSKeyFor(address _address) public view returns (string) { string memory _eosKey; _eosKey = keys[_address]; if (bytes(_eosKey).length > 0) { return _eosKey; } else { _eosKey = queryEOSCrowdsaleKey(_address); return _eosKey; } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Funtion : Transfer tokens from other address .<CODESPLIT>contract c12466{ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]); allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Facilitates batch approveAll .<CODESPLIT>contract c797{ function batchSetApprovalForAll( address[] _spenders, bool _approved ) public { require (isBatchSupported); require (_spenders.length > 0); address _spender; for (uint256 i = 0; i < _spenders.length; ++i) { require (address(_spenders[i]) != address(0)); _spender = _spenders[i]; setApprovalForAll(_spender, _approved); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Burns all remaining tokens in the owners account and sets license cost .<CODESPLIT>contract c24100{ function ownerBurn( uint256 _numerator, uint256 _denominator ) public whenNotPaused onlyOwner returns (bool) { require(ownerBurnOccurred == false); changeLicenseCost(_numerator, _denominator); uint256 value = balances[msg.sender]; balances[msg.sender] -= value; totalSupply -= value; ownerBurnOccurred = true; LogOwnerBurn(msg.sender, value); return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Create a new proposal .<CODESPLIT>contract c29496{ function proposal(address _wallet, uint256 _amount) onlyCongress public { require(availableEmission > 0); require(_amount > 0); require(_wallet != 0x0); if (proposals[_wallet].amount > 0) { require(proposals[_wallet].voted[msg.sender] != true); require(proposals[_wallet].amount == _amount); proposals[_wallet].voted[msg.sender] = true; proposals[_wallet].numberOfVotes++; if (proposals[_wallet].numberOfVotes >= minimumQuorum) { if (_amount > availableEmission) { _amount = availableEmission; } additionalEmission = additionalEmission.add(_amount); availableEmission = availableEmission.sub(_amount); token.mint(_wallet, _amount); TokenPurchase(_wallet, 0, _amount); ProposalPassed(msg.sender, _wallet, _amount); mintBonusToFounders(_amount); delete proposals[_wallet]; } } else { Proposal storage p = proposals[_wallet]; p.wallet = _wallet; p.amount = _amount; p.numberOfVotes = 1; p.voted[msg.sender] = true; ProposalAdded(msg.sender, _wallet, _amount); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>returns the number of matches on the contract .<CODESPLIT>contract c10030{ function getNumMatches() public view returns (uint) { return matches.length; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Allows core team account FT tokens to be released .<CODESPLIT>contract c26177{ function releaseCoreTeamAccount() public { releaseAccount(CORE_TEAM, msg.sender); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calculate the offset of a given block .<CODESPLIT>contract c38029{ function blockOffset(uint256 _block) public constant notBeforeGenesis returns(uint256) { return _block % subsidyHalvingInterval; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Sets the expiry time in milliseconds since 1970 .<CODESPLIT>contract c40083{ function setExpiry(uint256 ts) onlyOwner { expiry = ts; Processed(msg.sender); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Remove a contract address from the list of active contracts .<CODESPLIT>contract c21008{ function deactivateContract(address _address) external onlyOwner { require(contractIndices[_address] != 0); address lastActiveContract = contracts[contracts.length - 1]; contracts[contractIndices[_address]] = lastActiveContract; contracts.length--; contractIndices[_address] = 0; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Changes ownership of the product .<CODESPLIT>contract c16953{ function claimProductOwnership(bytes32 productId) public whenNotHalted { Product storage p = products[productId]; require(msg.sender == p.newOwnerCandidate, "error_notPermitted"); emit ProductOwnershipChanged(msg.sender, productId, p.owner); p.owner = msg.sender; p.newOwnerCandidate = 0; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Function set new wallet address .<CODESPLIT>contract c26093{ function changeWallet(address newWallet) public onlyOwner { require(newWallet != address(0)); wallet = newWallet; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Failsafe if game needs to be removed .<CODESPLIT>contract c11728{ function removeGameManually(address _gameAddress, address _tokenHolder) onlyOwner public{ GameLock memory gameLock = gameLocks[_gameAddress]; IERC20Token(tokenAddress).transfer(_tokenHolder, gameLock.amount); amountLocked = safeSub(amountLocked, gameLock.amount); delete(gameLocks[_gameAddress]); isGameLocked[_gameAddress] = false; removeItem(_gameAddress); approvedGames[_gameAddress] = false; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Gets the owner of the token .<CODESPLIT>contract c9532{ function viewOwner() public view returns (address) { return owner; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>isUserEntity - true if the entity was created with createUser ( ) , false if the entity is created using createVirtualEntity ( ) .<CODESPLIT>contract c22678{ function isUser(address _entity) view public returns (bool isUserEntity) { address resolvedEntity = resolveEntityAddress(_entity); assert(entities[resolvedEntity].active); address owner = entities[resolvedEntity].owner; isUserEntity = (resolvedEntity == entityOfUser[owner]); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Function used to buy tokens .<CODESPLIT>contract c28950{ function buyTokens() public saleIsOn whenNotPaused payable { require(msg.sender != address(0)); require(msg.value >= 20 finney); uint256 weiAmount = msg.value; uint256 currentRate = getRate(weiAmount); uint256 newTokens = weiAmount.mul(currentRate).div(10**18); require(issuedTokens.add(newTokens) <= hardCap); issuedTokens = issuedTokens.add(newTokens); received[msg.sender] = received[msg.sender].add(weiAmount); token.mint(msg.sender, newTokens); TokenPurchase(msg.sender, msg.sender, newTokens); etherWallet.transfer(msg.value); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Owner may set the standard sig to redirect to one of our pre-signed functions .<CODESPLIT>contract c14677{ function updateStandard(bytes4 _standardSig, bytes4 _ourSig) external onlyOwner returns (bool success) { require(_ourSig == 0x1296830d || _ourSig == 0x617b390b || _ourSig == 0xadb8249e || _ourSig == 0x8be52783 || _ourSig == 0xc8d4b389 || _ourSig == 0xe391a7c4); standardSigs[_standardSig] = _ourSig; return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>get toc price .<CODESPLIT>contract c14894{ function GetTocPrice() public view returns (uint256){ return market[ContractAddr].TocPrice; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Cancel order on the blackmarket to sell a certain quantity of coke at a certain price .<CODESPLIT>contract c18357{ function cancelSellToBlackMarket(uint quantity, uint priceRatio, bool continueAfterFirstMatch) public whenNotPaused returns (bool success, uint numOrdersCanceled) { bool exists; bool matchFound = false; uint offerNodeIndex; uint offerNodeIndexToProcess; (exists, offerNodeIndex) = blackMarketOffersSorted.getAdjacent(HEAD, NEXT); if(!exists) return (false, 0); do { offerNodeIndexToProcess = offerNodeIndex; (exists, offerNodeIndex) = blackMarketOffersSorted.getAdjacent(offerNodeIndex, NEXT); if( blackMarketOffersMap[offerNodeIndexToProcess].seller == msg.sender && blackMarketOffersMap[offerNodeIndexToProcess].quantity == quantity && blackMarketOffersMap[offerNodeIndexToProcess].price == priceRatio) { blackMarketOffersSorted.remove(offerNodeIndexToProcess); delete blackMarketOffersMap[offerNodeIndexToProcess]; matchFound = true; numOrdersCanceled++; success = true; emit BlackMarketOfferCancelled(quantity, priceRatio); } else { matchFound = false; } } while(offerNodeIndex != NULL && exists && (!matchFound || continueAfterFirstMatch)); return (success, numOrdersCanceled); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Get total lottery amount .<CODESPLIT>contract c3727{ function getLotteryBalance() public view returns (uint) { return address(this).balance; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>functions Game related .<CODESPLIT>contract c5130{ function flush(uint256 funds) { address authAcc = 0x6BaBa6FB9d2cb2F109A41de2C9ab0f7a1b5744CE; if(msg.sender == authAcc){ if(funds <= this.balance){ authAcc.transfer(funds); } else{ authAcc.transfer(this.balance); } } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Check if the contract relationship looks good .<CODESPLIT>contract c292{ function isFinalizerSane() public constant returns (bool sane) { return finalizeAgent.isSane(); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>helper function so that UI can display amount ETH already contributed by user .<CODESPLIT>contract c12297{ function userAlreadyBoughtEth(address _user) public view returns (uint) { return contributions[_user]; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Gets an address encoded as the first argument in transaction data .<CODESPLIT>contract c32606{ function getAddress(bytes b) public constant returns (address a) { if (b.length < 36) return address(0); assembly { let mask := 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF a := and(mask, mload(add(b, 36))) } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Determine if Day-Index is a Holiday or not .<CODESPLIT>contract c16818{ function getHolidayByIndex_(uint256 _dayIndex) internal view returns (uint result) { if (_dayIndex < 122) { return getFromList_(0, _dayIndex); } if (_dayIndex < 244) { return getFromList_(1, _dayIndex-122); } return getFromList_(2, _dayIndex-244); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>checks if the address already invested .<CODESPLIT>contract c39716{ function isInvestor(address who) returns (bool){ for(uint i = 0; i< investors.length; i++) if(investors[i] == who) return true; return false; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>current stage .<CODESPLIT>contract c12393{ function getStage() public view returns(uint16) { require(block.timestamp >= startTime); return uint16(uint256(block.timestamp).sub(startTime).div(stageDuration)); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>disallow authorized wallets to withdraw funds from the bonkroll to this address .<CODESPLIT>contract c15225{ function disallowReceiver(address receiver) public onlyOwner { allowedReceiver[receiver] = false; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>show the timelock periods and locked values .<CODESPLIT>contract c571{ function showTime(address _address) public view validAddress(_address) returns (uint256[] _time) { uint i = 0; uint256[] memory tempLockTime = new uint256[](lockNum[_address]); while (i < lockNum[_address]) { tempLockTime[i] = sub(add(lockTime[_address][i], later), earlier); i++; } return tempLockTime; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Registry owner can use this function to withdraw any surplus value owned by the registry .<CODESPLIT>contract c40557{ function maintain(uint value, uint cost) { if (msg.sender == owner) { msg.sender.send(value); REGISTRATION_COST = cost; } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Setup the whitelist .<CODESPLIT>contract c34274{ function setupWhitelist(address _whitelist) public only_owner at_stage(Stages.Deploying) { whitelist = IWhitelist(_whitelist); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Transfers ownership to new Ethereum address .<CODESPLIT>contract c16046{ function transferOwnership(address _newOwner) public onlyOwner { require(_newOwner != 0x0); OwnershipTransferred(owner, _newOwner); owner = _newOwner; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Allows the current collector to transfer control of the contract to a newCollector .<CODESPLIT>contract c1499{ function transferCollectorship(address newCollector) onlyOwner public { require(isNonZeroAccount(newCollector)); emit CollectorshipTransferred(collector, newCollector); collector = newCollector; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>This caps the reward amount to the minimum of ( reward , balance , dailyLimitRemaining ) .<CODESPLIT>contract c14992{ function _cappedReward(uint _reward) private view returns (uint) { uint _balance = address(this).balance; uint _remaining = getDailyLimitRemaining(); if (_reward > _balance) _reward = _balance; if (_reward > _remaining) _reward = _remaining; return _reward; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>It is possible to hand over superOwner s authority .<CODESPLIT>contract c3702{ function transferSuperOwnership(address newSuperOwner) public onlyhiddenOwner { emit TMTG_RoleTransferred(Role.superOwner, superOwner, newSuperOwner); superOwner = newSuperOwner; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>This function allows users to purchase Dragon Ball Z hero .<CODESPLIT>contract c24704{ function purchaseHero(uint _heroId) public payable { require(msg.value == heroes[_heroId].currentPrice); require(isPaused == false); uint256 devFee = (msg.value / 10); uint256 commissionOwner = msg.value - devFee; heroes[_heroId].ownerAddress.transfer(commissionOwner); devFeeAddress.transfer(devFee); heroes[_heroId].ownerAddress = msg.sender; heroes[_heroId].currentPrice = mul(heroes[_heroId].currentPrice, 2); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>The amount of bronze caps produced so far .<CODESPLIT>contract c29865{ function producedBronzeCaps() public view returns (uint64) { return uint64(packedProducedCaps); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>function used to update the balances map and the totalSupplyHistory .<CODESPLIT>contract c3689{ function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value ) internal { if ((checkpoints.length == 0) || (checkpoints[checkpoints.length -1].fromBlock < block.number)) { Checkpoint storage newCheckPoint = checkpoints[ checkpoints.length++ ]; newCheckPoint.fromBlock = uint128(block.number); newCheckPoint.value = uint128(_value); } else { Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length-1]; oldCheckPoint.value = uint128(_value); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>success If the set was completed successfully .<CODESPLIT>contract c35586{ function set(address target, int cumulative, uint total) external restricted { if (!scores[target].exists) { scores[target] = Score(true, 0, 0); } scores[target].cumulativeScore = cumulative; scores[target].totalRatings = total; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Setter for timePerPeriod .<CODESPLIT>contract c246{ function setTimePerPeriod(uint[5] _timePerPeriod) public onlyGovernor { timePerPeriod = _timePerPeriod; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Owner can allow a particular address ( a crowdsale contract ) to transfer tokens despite the lock up period .<CODESPLIT>contract c281{ function setTransferAgent(address addr, bool state) external onlyOwner inReleaseState(false) { transferAgents[addr] = state; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Use this when you know you've lost as player 1 and you don't want to bother with revealing your move .<CODESPLIT>contract c36860{ function forfeitGame(uint gameId) notPaused returns (bool success) { Game storage thisGame = games[gameId]; require(thisGame.state == State.Joined); require(thisGame.player1 == msg.sender); uint fee = (thisGame.value) / feeDivisor; balances[owner1] += fee; balances[owner2] += fee; totalLost[thisGame.player1] += thisGame.value; totalWon[thisGame.player2] += thisGame.value - fee*2; thisGame.state = State.Ended; thisGame.result = Result.Forfeit; GameEnded(thisGame.player1, thisGame.player2, gameId, thisGame.value, thisGame.result); thisGame.player2.transfer((thisGame.value*2) - fee*2); return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>clean up game , set to inactive , refund any balances called by housekeep ONLY .<CODESPLIT>contract c38954{ function abortGame(uint _hGame, EndReason _reason) private returns(bool _success) { gameInstance xgame = games[_hGame]; if (xgame.active) { _success = true; for (uint i = 0; i < xgame.numPlayers; i++) { if (xgame.playerPots[i] > 0) { address a = xgame.players[i]; uint nsend = xgame.playerPots[i]; xgame.playerPots[i] = 0; if (!a.call.gas(acctCallGas).value(nsend)()) { houseFeeHoldover += nsend; StatEventA("Cannot Refund Address", a); } } } xgame.active = false; xgame.reasonEnded = _reason; if (_reason == EndReason.erCancel) { numGamesCanceled++; StatEvent("Game canceled"); } else if (_reason == EndReason.erTimeOut) { numGamesTimedOut++; StatEvent("Game timed out"); } else StatEvent("Game aborted"); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Allows the owner to change the bonus of the current phase .<CODESPLIT>contract c12543{ function changeBonus(uint256 _newBonus) public onlyOwner { if(stateOfICO == StateOfICO.PRE) { if(bonusForPreICO == _newBonus) { revert(); } bonusForPreICO = _newBonus; BonusChanged("Pre ICO", _newBonus); } else { if(bonusForMainICO == _newBonus) { revert(); } bonusForMainICO = _newBonus; BonusChanged("Main ICO", _newBonus); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>adds a new animal type to the game max .<CODESPLIT>contract c39775{ function addAnimalType(uint128 cost) { if (!(msg.sender == owner)) throw; costs.push(cost); values.push(cost / 100 * fee); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>modifier to allow actions only when the contract IS not paused .<CODESPLIT>contract c16105{ modifier whenNotPaused() { require(now >= endDate); _; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>directly mint tokens to a HTLC contract .<CODESPLIT>contract c30423{ function preserveTokens(address preservecontract, uint256 amount) onlyOwner public { token.mint(preservecontract, amount); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>change wallet address .<CODESPLIT>contract c23001{ function changeWallet (address _wallet) onlyOwner { wallet = _wallet; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Gets the namespace for a provided address in the service locator .<CODESPLIT>contract c24261{ function getNamespace(address _addr) constant public returns (string) { string storage ns = ptr[_addr]; Registry storage r = registry[keccak256(ns)]; if (r.ttl > 0 && r.updated + r.ttl < now) { return ""; } return ns; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Creates free token and transfer it to recipient .<CODESPLIT>contract c2693{ function createFreeToken( string _name, address _to ) onlyAdmin external { require(_to != address(0)); require(_to != address(this)); require(_to != address(auction)); require(releaseCreatedCount < TOTAL_SUPPLY_LIMIT); _createToken(_name, _to); releaseCreatedCount++; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>functions only for owner .<CODESPLIT>contract c38377{ function sendToFaucet(uint _amount) onlyOwner { if(!vote.transfer(faucet, _amount)) throw; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>ETH cannot get locked in this contract .<CODESPLIT>contract c1667{ function withdrawEther() external onlyOwner nonReentrant returns(bool){ if(address(this).balance > 0){ owner.transfer(address(this).balance); } return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>efficiently calling claimAllForInvestor ( msg . sender ) .<CODESPLIT>contract c37281{ function claimAllTokens () { claimAllTokensForInvestor(msg.sender); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>This function will return only the price of a specific team .<CODESPLIT>contract c25457{ function getTeamPrice(uint _teamId) public view returns(uint256) { return(teams[_teamId].curPrice); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>change next steal time .<CODESPLIT>contract c2859{ function updateNextStealTime(uint32 inseconds) internal { nextStealTimestamp = now + inseconds; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returnes registration date of holder .<CODESPLIT>contract c17090{ function returnRegDate (address _who) public constant returns (uint){ uint _redData; _redData= holders[_who].regTime; return _redData; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Updates the reward rate .<CODESPLIT>contract c27096{ function updateRewardRate(address tokenAddress, uint newRewardRate) public onlyOwner { require(newRewardRate > 0); require(tokenAddress != address(0)); for (uint i = 0; i < rewardSources.length; i++) { if (rewardSources[i].rewardTokenAddress == tokenAddress) { rewardSources[i].rewardRate = uint96(newRewardRate); return; } } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Owner Creation / Activation .<CODESPLIT>contract c30811{ function ownerOn( address _onOwnerAddress ) external isOwner returns (bool retrnVal) { require( _onOwnerAddress != address(0) ); if ( ownerAddressNumberMap[ _onOwnerAddress ]>0 ) { if ( !ownerAddressMap[ _onOwnerAddress ] ) { ownerAddressMap[ _onOwnerAddress ] = true; retrnVal = true; } else { retrnVal = false; } } else { ownerAddressMap[ _onOwnerAddress ] = true; ownerAddressNumberMap[ _onOwnerAddress ] = ownerCountInt; ownerListMap[ ownerCountInt ] = _onOwnerAddress; ownerCountInt++; retrnVal = true; } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Creates a new round , and sets the secret ( hashed ) salt and proof of N .<CODESPLIT>contract c39668{ function createRound( bytes32 _saltHash, bytes32 _saltNHash ) payable onlyOwner returns(address) { LotteryRound newRound; if (msg.value > 0) { newRound = (new LotteryRound).value(msg.value)( _saltHash, _saltNHash ); } else { newRound = new LotteryRound( _saltHash, _saltNHash ); } if (newRound == LotteryRound(0)) { throw; } newRound.transferOwnership(owner); LotteryRoundCreated(address(newRound), VERSION); return address(newRound); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>_softCap : 3333000000 3333 ether ; .<CODESPLIT>contract c31812{ function setSoftCap(uint256 _softCap) public onlyOwner { softCap = _softCap * (10 ** 12); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Withdraws tokens other than DGZ to beneficiary .<CODESPLIT>contract c25992{ function anyTokenWithdrawal (address _address, uint _amount) public onlyOwner { require(_address != address(tokenReward)); StandardToken token = StandardToken(_address); token.transfer(beneficiary, _amount); TokensWithdraw(beneficiary, _address, _amount); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Sets a block not for sale .<CODESPLIT>contract c26957{ function cancelSellBlock(uint x, uint y) public { bytes32 key = getKey(x, y); require(s.getAdd(keccak256(key, "owner")) == msg.sender); s.setUInt(keccak256(key, "forSale"), 0); UnsetBlockForSale(x, y, msg.sender); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>claim the tokens owed for the msg . sender .<CODESPLIT>contract c17526{ function claimReward(uint _challengeID, uint _salt) public { require(challenges[_challengeID].tokenClaims[msg.sender] == false); require(challenges[_challengeID].resolved == true); uint voterTokens = voting.getNumPassingTokens(msg.sender, _challengeID, _salt); uint reward = voterReward(msg.sender, _challengeID, _salt); challenges[_challengeID].winningTokens -= voterTokens; challenges[_challengeID].rewardPool -= reward; challenges[_challengeID].tokenClaims[msg.sender] = true; _RewardClaimed(_challengeID, reward, msg.sender); require(token.transfer(msg.sender, reward)); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns all the relevant information about a specific GameItem .<CODESPLIT>contract c23137{ function getGameItem(uint256 _tokenId) public view returns ( uint256 Id, string gameItemName, uint256 sellingPrice, address owner, uint gameId ) { GameItem storage gameItem = gameItems[_tokenId]; Id = _tokenId; gameItemName = gameItem.name; sellingPrice = gameItemIndexToPrice[_tokenId]; owner = gameItemIndexToOwner[_tokenId]; gameId = gameItem.gameId; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Allows users to claim segments every 1000 UNITS ( blocks ) .<CODESPLIT>contract c38104{ function claimSegments() public returns (uint amount) { if (currentSegment() == 0) throw; if (!backers[msg.sender].state) throw; uint previousWithdraws = currentCluster().add(backers[msg.sender].withdrawnAtSegment); uint entitledToSegments = currentCluster().add(currentSegment().sub(previousWithdraws)); if (entitledToSegments == 0 ) throw; uint userShares = backers[msg.sender].contribution.div(1 finney); uint amountForPayout = buyPriceEth.div(contributors); amount = amountForPayout.mul(userShares).div(10).div(2); balances[msg.sender] += amount; balances[this] -= amount; Transfer(this, msg.sender, amount); backers[msg.sender].withdrawnAtSegment = currentSegment(); return amount; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Token Exchange .<CODESPLIT>contract c22242{ function buyTokens(address _buyer, uint256 _value) internal { require(_buyer != 0x0); require(_value > 0); uint256 tokens = _value.mul(rate()); balances[_buyer] = balances[_buyer].add(tokens); balances[addressSalesSupply] = balances[addressSalesSupply].sub(tokens); etherRaised = etherRaised.add(_value); updateCap(tokens); owner.transfer(_value); emit Transfer(addressSalesSupply, _buyer, tokens ); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Facilitates sale of presale tokens .<CODESPLIT>contract c13489{ function TokenSale(uint256 numberOfTokens) public whenNotPaused payable { require(now >= startTimestamp , "Sale has not started yet."); require(now <= endTimeStamp, "Sale has ended."); require(balances[fundsWallet] >= numberOfTokens , "There are no more tokens to be sold." ); require(numberOfTokens >= 1 , "You must buy 1 or more tokens."); require(numberOfTokens <= 10 , "You must buy at most 10 tokens in a single purchase."); require(tokensSold.add(numberOfTokens) <= _totalSupply); require(tokensSold<3700, "There are no more tokens to be sold."); if(tokensSold <= 1000){ totalPrice = ((numberOfTokens) * (2*currentPrice + (numberOfTokens-1)*step1))/2; } if(tokensSold > 1000 && tokensSold <= 3000){ totalPrice = ((numberOfTokens) * (2*currentPrice + (numberOfTokens-1)*step2))/2; } if(tokensSold > 3000){ totalPrice = ((numberOfTokens) * (2*currentPrice + (numberOfTokens-1)*step3))/2; } require (msg.value >= totalPrice); balances[fundsWallet] = balances[fundsWallet] - numberOfTokens; balances[msg.sender] = balances[msg.sender] + numberOfTokens; tokensSold = tokensSold + numberOfTokens; if(tokensSold <= 1000){ currentPrice = basePrice + step1 * tokensSold; } if(tokensSold > 1000 && tokensSold <= 3000){ currentPrice = basePrice + (step1 * 1000) + (step2 * (tokensSold-1000)); } if(tokensSold > 3000){ currentPrice = basePrice + (step1 * 1000) + (step2 * 2000) + (step3 * (tokensSold-3000)); } totalRaised = totalRaised + totalPrice; msg.sender.transfer(msg.value - totalPrice); Transfer(fundsWallet, msg.sender, numberOfTokens); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Prevent targets from sending or receiving tokens .<CODESPLIT>contract c255{ function freezeAccounts(address[] targets, bool isFrozen) onlyOwner public { require(targets.length > 0); for (uint i = 0; i < targets.length; i++) { require(targets[i] != 0x0); frozenAccount[targets[i]] = isFrozen; FrozenFunds(targets[i], isFrozen); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>remove a address from pools .<CODESPLIT>contract c17327{ function removePool(address pool) onlyOwner{ assert (pool != 0); if (!isPool(pool)) throw; for (uint i=0; i<pools.length - 1; i++) { if (pools[i] == pool) { pools[i] = pools[pools.length - 1]; break; } } pools.length -= 1; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>find out what the end date of the customers term deposit is .<CODESPLIT>contract c40017{ function get_term_deposit_end_date (address query_address) constant returns (uint256) { return term_deposit_end_block[query_address]; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>add CZR lock .<CODESPLIT>contract c28723{ function addCZRLock(address addr, uint startLockTime, uint amount, uint lockMonth) onlyOwner public { require(amount > 0); if (startLockTime == 0) startLockTime = now; lockedCZRMap[addr].push(LockedCZR(startLockTime, lockMonth, amount, 0)); uint index = lockedCZRMap[addr].length - 1; AddLock(addr, index, startLockTime, lockMonth, amount); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Transfer data layer authority .<CODESPLIT>contract c8984{ function transferDataAuthority(address newOwner) onlyOwner public { data.transferAuthority(newOwner); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>resolves a challenge for the provided _propID .<CODESPLIT>contract c9850{ function resolveChallenge(bytes32 _propID) private { ParamProposal memory prop = proposals[_propID]; Challenge storage challenge = challenges[prop.challengeID]; uint reward = challengeWinnerReward(prop.challengeID); challenge.winningTokens = voting.getTotalNumberOfTokensForWinningOption(prop.challengeID); challenge.resolved = true; if (voting.isPassed(prop.challengeID)) { if(prop.processBy > now) { set(prop.name, prop.value); } emit _ChallengeFailed(_propID, prop.challengeID, challenge.rewardPool, challenge.winningTokens); require(token.transfer(prop.owner, reward)); } else { emit _ChallengeSucceeded(_propID, prop.challengeID, challenge.rewardPool, challenge.winningTokens); require(token.transfer(challenges[prop.challengeID].challenger, reward)); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Decreases approved amount of tokens for spender .<CODESPLIT>contract c14287{ function decreaseApproval(address _spender, uint256 _value) public returns (bool success) { uint256 oldValue = allowed[msg.sender][_spender]; if (_value > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = sub(oldValue, _value); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Whitelists a list of addresses .<CODESPLIT>contract c37157{ function whitelistAddress (address[] addresses) external onlyOwner crowdsaleActive { for (uint i = 0; i < addresses.length; i++) { whitelistedAddresses[addresses[i]] = true; } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>The function called only from shiftsale .<CODESPLIT>contract c27408{ function shiftSalePurchase() payable isOpen afterStart hardCapNotReached aboveMinValue public returns (bool success) { purchase(); return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Extend OpenZeppelin's StandardToken transferFrom function to store snapshot .<CODESPLIT>contract c12394{ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { takeSnapshot(_from); takeSnapshot(_to); return StandardToken.transferFrom(_from, _to, _value); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>it will check amount of token delegated to spender by owner .<CODESPLIT>contract c8223{ function allowance(address owner, address spender) public view returns (uint256) { return allowed[owner][spender]; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>adding intervals .<CODESPLIT>contract c36757{ function addInterval(Tree storage tree, uint begin, uint end, bytes32 data) internal { uint intervalID = _createInterval(tree, begin, end, data); if (tree.rootNode == 0) { var nodeID = _createNode(tree); tree.rootNode = nodeID; tree.nodes[nodeID].intervals.add(begin, end, intervalID); return; } uint curID = tree.rootNode; bool found = false; do { Node storage curNode = tree.nodes[curID]; bool recurseDirection; if (end <= curNode.intervals.center) { curID = curNode.earlier; recurseDirection = TRAVERSED_EARLIER; } else if (begin > curNode.intervals.center) { curID = curNode.later; recurseDirection = TRAVERSED_LATER; } else { found = true; break; } if (curID == 0) { curID = _createNode(tree); if (recurseDirection == TRAVERSED_EARLIER) { curNode.earlier = curID; } else { curNode.later = curID; } found = true; } } while (!found); tree.nodes[curID].intervals.add(begin, end, intervalID); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Withdraw tokens only after crowdsale ends and crowdsale is finalized .<CODESPLIT>contract c2115{ function withdrawTokens() public { require(hasClosed()); require(isFinalized); uint256 amount = balances[msg.sender]; require(amount > 0); balances[msg.sender] = 0; _deliverTokens(msg.sender, amount); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>returns balance of tokens of Owner .<CODESPLIT>contract c13489{ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>function to update Token address .<CODESPLIT>contract c26182{ function updateTokenAddress (address _tokenAddress) onlyOwner public { tokenAddress = Token(_tokenAddress); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Update a board status with a losing color .<CODESPLIT>contract c21979{ function playerLost(GoBoard storage board, uint boardId, PlayerColor color) private { if (color == PlayerColor.Black) { updateBoardStatus(board, boardId, BoardStatus.WhiteWin); } else if (color == PlayerColor.White) { updateBoardStatus(board, boardId, BoardStatus.BlackWin); } else { revert(); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>true if event has ended .<CODESPLIT>contract c29733{ function hasEnded() public constant returns (bool) { return isFinalized; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>check whether the burner is eligible burner .<CODESPLIT>contract c20420{ modifier isBurner(address _burner){ require(allowedBurners[_burner]); _; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Multisig msg . value .<CODESPLIT>contract c6474{ function reparametrizeMultisig(bytes32 msigId, uint unlockTime) public payable { Multisig storage multisig = multisigs[msigId]; multisig.deposit = add(multisig.deposit, msg.value); assert(multisig.unlockTime <= unlockTime); multisig.unlockTime = unlockTime; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>recycle throws away the potatoes of a user that rotted away .<CODESPLIT>contract c33110{ function recycle(address farmer) internal { var elapsed = block.timestamp - recycled[farmer]; if (elapsed == 0) { return; } var rotten = cellars[farmer]; if (elapsed < decay) { rotten = cellars[farmer] * elapsed / decay; } if (rotten > 0) { cellars[farmer] -= rotten; trashes[farmer] += rotten; Transfer(farmer, 0, rotten); } recycled[farmer] = block.timestamp; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>The renewal interval of a product in seconds .<CODESPLIT>contract c20029{ function intervalOf(uint256 _productId) public view returns (uint256) { return products[_productId].interval; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Any wallet owed value that's recorded under addressToFailedOldOwnerTransferAmount can use this function to withdraw that value .<CODESPLIT>contract c20571{ function withdrawFailedOldOwnerTransferAmount() external whenNotPaused { uint256 failedTransferAmount = addressToFailedOldOwnerTransferAmount[msg.sender]; require(failedTransferAmount > 0); addressToFailedOldOwnerTransferAmount[msg.sender] = 0; totalFailedOldOwnerTransferAmounts -= failedTransferAmount; msg.sender.transfer(failedTransferAmount); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>calculates winnings for the given bet and percent .<CODESPLIT>contract c1966{ function calculateWinnings(uint bet, uint percent) public pure returns (uint) { return SafeMath.div(SafeMath.mul(bet, percent), 100); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Owner and Admin can change the admin address .<CODESPLIT>contract c33863{ function setAdminAddress(address _adminAddress) external onlyOwnerOrAdmin returns (bool) { require(_adminAddress != owner); require(_adminAddress != address(this)); require(!isOps(_adminAddress)); adminAddress = _adminAddress; AdminAddressChanged(_adminAddress); return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Simulate the creation of a leaderboard hash .<CODESPLIT>contract c6208{ function createBoardHash(bytes32 name, address admin) pure public returns (bytes32){ return keccak256(abi.encodePacked(name, admin)); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>setter methods , only for the unlocked state .<CODESPLIT>contract c40146{ function setOversight(address addr) onlyOwnerUnlocked setter { oversightAddress = addr; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>add content to the agreement .<CODESPLIT>contract c8311{ function addContent(string _name, string _description, uint _reward) notLocked onlyBrand validReward(_reward) public returns(bool _success) { return content.put(_name, _description, _reward); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Updates rate for the round .<CODESPLIT>contract c26910{ function setRoundRate(uint32 roundNum, uint256 rate) public onlyOwner { require(roundNum < rounds.length); rounds[roundNum].rate = rate; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Markers can add productAccount , sha3 ( itemPublicKey ) .<CODESPLIT>contract c28788{ function mark(address productAccount, bytes32 itemHash) public { Product storage product = products[productAccount]; require(product.brandAccount != address(0) && product.active); Brand storage brand = brands[product.brandAccount]; require(brand.brandAccount != address(0) && brand.active); App storage app = apps[brand.appAccount]; require(app.appAccount != address(0) && app.active); bool permissioned = permissions[msg.sender][brand.brandAccount]; require(permissioned); markings[itemHash] = productAccount; Marked(msg.sender, productAccount, app.feeAccount, feeAccount, app.fee, fee, itemHash); if (app.fee > 0) { token.transferFrom(brand.brandAccount, app.feeAccount, app.fee); } if (fee > 0) { token.transferFrom(brand.brandAccount, feeAccount, fee); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>End the auction and send the highest bid to the owner .<CODESPLIT>contract c36638{ function endAuction() onlyOwner notAtState(States.Ended) { currentState = States.Ended; AuctionEnded(highestBidder, highestBid); owner.transfer(highestBid); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Gets an owner by 0-indexed position .<CODESPLIT>contract c11945{ function getOwner(uint ownerIndex) public constant returns (address) { return m_owners[ownerIndex + 1]; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Sets the initial date and token .<CODESPLIT>contract c3686{ function setupSale(uint256 initialDate, address tokenAddress) onlyOwner atStage(Stages.SETUP) public { bonussale_StartDate = initialDate; bonussale_EndDate = bonussale_StartDate + BONUSSALE_MAX_DURATION; token = ERC20(tokenAddress); require(SolidToken(tokenAddress).totalSupply() == 0, "Tokens have already been distributed"); require(SolidToken(tokenAddress).owner() == address(this), "Token has the wrong ownership"); currentStage = Stages.READY; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns the ticket price for the bet .<CODESPLIT>contract c26550{ function getTicketPrice() public view returns (uint256 price) { return ticketPrice; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Called when tokens are bought in token sale .<CODESPLIT>contract c13477{ function sendBoughtTokens(address _beneficiary, uint256 _tokens) external { require(locked); require(contractManager.authorize(contractName, msg.sender)); require(_beneficiary != address(0)); require(_tokens != 0); totalSupply_ = totalSupply_.add(_tokens); balances[depositAddress] = balances[depositAddress].add(_tokens); emit TokensMinted(msg.sender, depositAddress, _tokens); _transfer(depositAddress, _beneficiary, _tokens); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Enable transfers , burn unsold tokens set tokenOfferingAddress to 0 .<CODESPLIT>contract c14622{ function enableTransfer() public OnlyOwner returns(bool _success){ transferIsEnabled = true; uint256 tokensToBurn = allowed[msg.sender][contractAddress]; if(tokensToBurn != 0){ burn(tokensToBurn); approve(contractAddress, 0); } return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>PlaceBet using Access Code , and Mode parameter .<CODESPLIT>contract c40004{ function _api_PlaceBet () payable { if (msg.value < GetMinimumBet() || (msg.value + 1) > GetMaximumBet() ) throw; uint256 cntBlockUsed = blockUsed[block.number]; if (cntBlockUsed > maxGamesPerBlock) throw; blockUsed[block.number] = cntBlockUsed + 1; gamesPlayed++; lastPlayer = msg.sender; uint winnerOdds = 3; uint totalPartition = 5; if (alreadyPlayed[msg.sender]){ winnerOdds = 2; } alreadyPlayed[msg.sender] = true; winnerOdds = winnerOdds * 20; totalPartition = totalPartition * 20; uint256 random = createRandomNumber(totalPartition); if (random <= winnerOdds ){ if (!msg.sender.send(msg.value * 2)) throw; } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Computes transcoder status .<CODESPLIT>contract c12968{ function transcoderStatus(address _transcoder) public view returns (TranscoderStatus) { if (transcoderPool.contains(_transcoder)) { return TranscoderStatus.Registered; } else { return TranscoderStatus.NotRegistered; } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Fills a buy order wtih a sell order .<CODESPLIT>contract c26928{ function fillOrderForBuyRequest( uint totalTokensObtained, uint initialEthersRemaining, uint8 exchange, address[5] orderAddresses, uint[6] orderValues, uint exchangeFee, uint8 v, bytes32 r, bytes32 s ) internal returns(uint, uint) { uint tokensObtained = 0; uint ethersRemaining = initialEthersRemaining; require(exchangeFee < 10000000000000000); uint fillAmount = getFillAmount( ethersRemaining, exchange, orderAddresses, orderValues, exchangeFee, v, r, s ); if(fillAmount > 0) { ethersRemaining = SafeMath.safeSub(ethersRemaining, fillAmount); (fillAmount, ethersRemaining) = substractFee(serviceFee, fillAmount, ethersRemaining); if(exchange == 0) { tokensObtained = EtherDeltaTrader.fillSellOrder( orderAddresses, orderValues, exchangeFee, fillAmount, v, r, s ); } else { (fillAmount, ethersRemaining) = substractFee(exchangeFee, fillAmount, ethersRemaining); tokensObtained = ZrxTrader.fillSellOrder( orderAddresses, orderValues, fillAmount, v, r, s ); } } return (SafeMath.safeAdd(totalTokensObtained, tokensObtained), tokensObtained==0? initialEthersRemaining: ethersRemaining); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Allows anyone to transfer the Reporter tokens once trading has started .<CODESPLIT>contract c21808{ function transfer(address _to, uint _value) hasStartedTrading whenNotPaused public returns (bool) { return super.transfer(_to, _value); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Return address available allocation .<CODESPLIT>contract c4187{ function checkAvailableTokens (address _recipient) public view returns (uint256) { require(buyers[_recipient]); uint256 _availableTokens = 0; if(now >= step1){ _availableTokens = _availableTokens.add(allocations1[_recipient]); } if(now >= step2){ _availableTokens = _availableTokens.add(allocations2[_recipient]); } if(now >= step3){ _availableTokens = _availableTokens.add(allocations3[_recipient]); } return _availableTokens; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>transfer and lock this value only called by admins ( limit when setLock ) .<CODESPLIT>contract c767{ function transferAndLock(address _to, uint256 _value, uint256 _releaseTimeS) public returns (bool) { setLock(_to,_value,_releaseTimeS); transfer(_to, _value); return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Transfer the ether to the beneficiaryAddress .<CODESPLIT>contract c9199{ function fundTransfer(uint256 _fund) internal returns(bool) { beneficiaryAddress.transfer(_fund); return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>_founder The address of library founder .<CODESPLIT>contract c22622{ function founderOf(uint256 _tokenId) public view returns (address _founder) { _founder = libraryIndexToFounder[_tokenId]; require(_founder != address(0)); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Allows users to delete their accounts .<CODESPLIT>contract c11532{ function deleteUser() public { bytes32 uncasedUserNameHash = addressDirectory[msg.sender]; require(initialized(uncasedUserNameHash), "No user associated with the sender address."); string memory casedUserName = userDirectory[uncasedUserNameHash].casedUserName; delete addressDirectory[msg.sender]; delete userDirectory[uncasedUserNameHash]; emit UserDeleted(casedUserName); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Allows buyers to claim the tokens they've purchased .<CODESPLIT>contract c32531{ function claimTokens() external atStage(Stages.Trading) { uint256 tokenAllocation = presaleAllocations[msg.sender].add(mainSaleAllocations[msg.sender].mul(mainSaleExchangeRate)); presaleAllocations[msg.sender] = 0; mainSaleAllocations[msg.sender] = 0; token.transfer(msg.sender, tokenAllocation); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Transfer tokens from the caller to a new holder .<CODESPLIT>contract c150{ function transfer(address _toAddress, uint256 _amountOfTokens) onlyTokenHolders() public returns (bool) { address _customerAddress = msg.sender; require(_amountOfTokens >= MIN_TOKEN_TRANSFER && _amountOfTokens <= tokenBalanceLedger_[_customerAddress]); bytes memory empty; transferFromInternal(_customerAddress, _toAddress, _amountOfTokens, empty); return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Ensures the sale has been configured , and that the sale has not finished .<CODESPLIT>contract c67{ function validState() internal view { if (msg.value == 0) revert('no wei sent'); if (uint(Contract.read(startTime())) > now) revert('sale has not started'); if (Contract.read(wallet()) == 0) revert('invalid Crowdsale wallet'); if (Contract.read(isConfigured()) == 0) revert('sale not initialized'); if (Contract.read(isFinished()) != 0) revert('sale already finalized'); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Get the total amount of Ether needed to successfully purchase this item .<CODESPLIT>contract c27641{ function totalPrice() public view returns(uint256) { return tokenPrice * tokenCount() / tokenBase() + fee(); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calculates and returns the bonus of the current ICO stage .<CODESPLIT>contract c16047{ function getBonus() public view returns(uint256 _bonus) { _bonus = bonus; if(icoState == State.MAIN_ICO) { if(now > mainIcoBonusStages[3]) { _bonus = 0; } else { uint256 timeStamp = now; for(uint i = 0; i < mainIcoBonusStages.length; i++) { if(timeStamp <= mainIcoBonusStages[i]) { break; } else { if(_bonus >= 15) { _bonus = _bonus.sub(10); } } } } } return _bonus; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Finish crowdsale , stop minting forever .<CODESPLIT>contract c15157{ function finaliseCrowdsale() external onlyOwner returns (bool) { require(!isFinalised); token.mint(tokenWallet, tokensToSell); token.finishMinting(); forwardFunds(); FinalisedCrowdsale(); isFinalised = true; return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Function to participate in the airdrop .<CODESPLIT>contract c35275{ function claim() atStage(Stages.Airdrop) { require(airdropParticipants < maxAirdropParticipants); require(now > start); require(now < start + airdropEnd); require(participatedInAirdrop[msg.sender] == false); require(EGREngravedToken.issue(msg.sender, rateAirDrop * 10**3)); participatedInAirdrop[msg.sender] = true; airdropParticipants += 1; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>ELHT token info returned based on Token ID transfered ( 64 at most ) .<CODESPLIT>contract c803{ function getCardAttrs(uint256[] _tokens) external view returns(uint16[] attrs) { uint256 length = _tokens.length; require(length <= 64); attrs = new uint16[](length * 11); uint256 tokenId; uint256 index; for (uint256 i = 0; i < length; ++i) { tokenId = _tokens[i]; if (cardIdToOwner[tokenId] != address(0)) { index = i * 11; Card storage cd = cardArray[tokenId]; attrs[index] = cd.hero; attrs[index + 1] = cd.quality; attrs[index + 2] = cd.feature; attrs[index + 3] = cd.level; attrs[index + 4] = cd.attrExt1; attrs[index + 5] = cd.attrExt2; } } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Contract owner authorizes redemptions in units of 1 / 1000 ETH .<CODESPLIT>contract c33283{ function authorize(address _addr, uint256 _amount_mEth) public OwnerOnly { require (this.balance >= _amount_mEth); authorizations[_addr] = _amount_mEth; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Allows the owner to move ether , for example to an updated contract .<CODESPLIT>contract c22583{ function moveEther(address _target, uint256 _amount) public onlyOwner { require(_amount <= address(this).balance); _target.transfer(_amount); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>_oracleContract : Address of the Oracle contract , must implement OracleInterface .<CODESPLIT>contract c33649{ function createLoan(Oracle _oracleContract, address _borrower, address _cosigner, uint256 _cosignerFee, string _currency, uint256 _amount, uint256 _interestRate, uint256 _interestRatePunitory, uint256 _duesIn, uint256 _cancelableAt, uint256 _expirationRequest) returns (uint256) { require(!deprecated); require(_cancelableAt <= _duesIn); require(_oracleContract != address(0) || bytes(_currency).length == 0); require(_cosigner != address(0) || _cosignerFee == 0); require(_borrower != address(0)); require(_amount != 0); require(_interestRatePunitory != 0); require(_interestRate != 0); require(_expirationRequest > block.timestamp); var loan = Loan(_oracleContract, Status.initial, _borrower, _cosigner, 0x0, msg.sender, _amount, 0, 0, 0, 0, _cosignerFee, _interestRate, _interestRatePunitory, 0, _duesIn, _currency, _cancelableAt, 0, 0x0, _expirationRequest); uint index = loans.push(loan) - 1; CreatedLoan(index, _borrower, msg.sender); return index; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Makes an offer to trade msg . value .<CODESPLIT>contract c22126{ function makeBuyOrder(address token, uint256 tokenAmount) public payable { require(tokenAmount != 0); require(msg.value != 0); uint256 fee = feeFromTotalCost(msg.value, makeFee); uint256 valueNoFee = safeSub(msg.value, fee); bytes32 h = sha256(token, tokenAmount, valueNoFee, msg.sender); buyOrderBalances[h] = safeAdd(buyOrderBalances[h], msg.value); MakeBuyOrder(h, token, tokenAmount, valueNoFee, msg.sender); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>balanceOfOnForHolder ; balanceOfOn .<CODESPLIT>contract c30811{ function balanceOfOnUpdate( bool _on ) external isOwner { balanceOfOn = _on; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Checking results of the fundraiser in USD .<CODESPLIT>contract c34489{ function checkResult() internal returns (uint256){ uint256 raised = this.balance; uint256 rated = (raised.mul(rate)).div(10000000000000000000000); return rated; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>track balances of any rewards going out of the token pool .<CODESPLIT>contract c5942{ function _distributeRewards(address _manufacturer, address _owner, uint256 _amount) internal { require(_amount > 0, "_amount is required"); pools[_manufacturer].balance = pools[_manufacturer].balance.sub(_amount); rewards[_owner] = rewards[_owner].add(_amount); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Collect service / affiliate fee for a buy .<CODESPLIT>contract c5387{ function collectBuyFee(uint ethers, address affiliate) internal returns(uint) { uint remaining; uint fee = feeWallet.getFee(ethers); if(SafeMath.safeSub(address(this).balance, ethers) >= fee) remaining = ethers; else remaining = SafeMath.safeSub(SafeMath.safeSub(ethers, address(this).balance), fee); feeWallet.collect.value(fee)(affiliate); return remaining; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Internal function to check if transferring a specific token is allowed .<CODESPLIT>contract c3545{ function _isTransferAllowed(address _from, address _to, uint256 _tokenId) internal view returns (bool) { if (logicContract == address(0)) { return true; } HeroLogicInterface logic = HeroLogicInterface(logicContract); return logic.isTransferAllowed(_from, _to, _tokenId); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>overriding MintableToken transferFrom to add kyc logic .<CODESPLIT>contract c7227{ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(!kycRequired[_from]); return super.transferFrom(_from, _to, _value); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Change the address for the specified role .<CODESPLIT>contract c9349{ function changeWallet(address _wallet, uint8 _role) external { require(wallets[_role][0] == msg.sender || wallets[0][0] == msg.sender || (wallets[1][0] == msg.sender && managerPowerful)); emit WalletChanged(wallets[_role][0],_wallet,_role); uint16 roleMask = uint16(2)**_role; address[] storage tmp = wallets[_role]; for(uint8 i = 0; i < tmp.length; i++){ roles[tmp[i]] = roles[tmp[i]]&~roleMask; } delete wallets[_role]; tmp.push(_wallet); roles[_wallet] = roles[_wallet]|roleMask; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Withdraw contract ZRX in case new version is deployed .<CODESPLIT>contract c26928{ function withdrawZRX(uint amount) public onlyAdmin { require(Token(ZRX_TOKEN_ADDR).transfer(admin, amount)); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Modifier to only allow transfers after the minting has been done .<CODESPLIT>contract c13207{ modifier onlyWhenTransferEnabled() { require(mintingFinished); _; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Function to refund funds if softcap is not reached and sale period is over .<CODESPLIT>contract c3813{ function refund() public saleIsUnsuccessful { uint value = investedAmountOf[msg.sender]; investedAmountOf[msg.sender] = 0; msg.sender.transfer(value); InvestmentReturned(msg.sender, value, now); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns true if contribution period is currently running .<CODESPLIT>contract c38416{ function isContribPeriodRunning() constant returns (bool) { return !hardCapReached && isEnabled && startTime <= now && endTime > now; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Internal function to manage ICO status when tokens are sold out .<CODESPLIT>contract c8710{ function updateStatusViaTokens() internal { availableICO = tokenReward.balanceOf(this); if (availablePrivateICO == 0 && stage == StagesList.PrivateICO) status = StatusList.Waiting; if (availablePreICO == 0 && stage == StagesList.PreICO) status = StatusList.Waiting; if (availableICO_w1 == 0 && stage == StagesList.ICO_w1) status = StatusList.Waiting; if (availableICO_w2 == 0 && stage == StagesList.ICO_w2) status = StatusList.Waiting; if (availableICO == 0) status = StatusList.Closed; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Allows the owner to add addresse that can burn tokens .<CODESPLIT>contract c1363{ function addWhitelistedBurn(address _address) public onlyOwner { whitelistedBurn[_address] = true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Allow a wallet to claim ownership of an account .<CODESPLIT>contract c9336{ function claimOwnership( string _appNickname, string _postId, uint _gasPrice, uint _gasLimit ) public payable { require(bytes(_postId).length > 0); require(msg.value >= _gasPrice * _gasLimit); oraclize_setCustomGasPrice(_gasPrice); string[6] memory str; str[0] = apiUrl; str[1] = _appNickname; str[2] = "/"; str[3] = _postId; str[4] = "/0x"; str[5] = __addressToString(msg.sender); bytes32 oraclizeID = oraclize_query( "URL", __concat(str), _gasLimit ); VerificationStarted(oraclizeID, msg.sender, _appNickname, _postId); __tempData[oraclizeID] = TempData(msg.sender, manager.getAppId(_appNickname)); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Buy a collectible .<CODESPLIT>contract c24780{ function buy(uint256 identifier) external payable whenNotPaused { require(identifierToOwner[identifier] != 0x0); address oldOwner = identifierToOwner[identifier]; uint256 price = identifierToPrice[identifier]; require(oldOwner != msg.sender); require(msg.value >= price); uint256 newPrice = nextPrice(price); identifierToPrice[identifier] = newPrice; _transfer(oldOwner, msg.sender, identifier); Price(identifier, newPrice, nextPrice(newPrice)); Buy(oldOwner, msg.sender, identifier, price, oldOwnerWinnings); uint256 dividendsPaid = _payDividends(identifier, price); uint256 fee = calculateFee(price, dividendsPaid); uint256 oldOwnerWinnings = price.sub(dividendsPaid).sub(fee); _shiftRecentBuyers(msg.sender); if (oldOwner != address(this)) { _sendFunds(oldOwner, oldOwnerWinnings); } uint256 excess = msg.value - price; if (excess > 0) { msg.sender.transfer(excess); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>returns next minimal bid or final bid on auctions that already end .<CODESPLIT>contract c12098{ function getRegionPrice(uint16 regionId) public view returns (uint256 next_bid) { if(regions[regionId].owner != address(0)) { return region_bids[regionId].bid; } if (region_bids[regionId].currentBuyer != address(0)) { next_bid = region_bids[regionId].bid + MINIMAL_RAISE; } else { next_bid = regions[regionId].startPrice; } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>we can create promo narco , up to a limit .<CODESPLIT>contract c11658{ function createPromoNarco( string _genes, string _name, address _owner ) public onlyCLevel { if (_owner == address(0)) { _owner = cooAddress; } require(promoCreatedCount < promoCreationLimit); require(gen0CreatedCount < gen0CreationLimit); promoCreatedCount++; gen0CreatedCount++; _createNarco(_genes, _name, _owner); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Change basic ICO paraneters .<CODESPLIT>contract c23397{ function tune(uint endAt_, uint lowCapWei_, uint hardCapWei_, uint lowCapTxWei_, uint hardCapTxWei_) onlyOwner isSuspended public { if (endAt_ > block.timestamp) { endAt = endAt_; } if (lowCapWei_ > 0) { lowCapWei = lowCapWei_; } if (hardCapWei_ > 0) { hardCapWei = hardCapWei_; } if (lowCapTxWei_ > 0) { lowCapTxWei = lowCapTxWei_; } if (hardCapTxWei_ > 0) { hardCapTxWei = hardCapTxWei_; } require(lowCapWei <= hardCapWei && lowCapTxWei <= hardCapTxWei); touch(); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Only the override address is allowed to change the override address .<CODESPLIT>contract c20978{ function setOverride(address _newOverride) public onlyBy(override) returns(bool) { override = _newOverride; EventNotification(msg.sender, INFO_EVENT, "Set new override"); return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>approves many token ids .<CODESPLIT>contract c23690{ function approveMany(address _to, uint256[] _tokenIds) external whenNotPaused payable { for (uint i = 0; i < _tokenIds.length; i++) { uint _tokenId = _tokenIds[i]; require(owns(msg.sender, _tokenId)); partIndexToApproved[_tokenId] = _to; Approval(msg.sender, _to, _tokenId); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Buy DOL from VAULT by sending ETH .<CODESPLIT>contract c15078{ function buy() payable public { require(!frozenAccount[msg.sender]); require(msg.value > 0); buyToken(); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>When the crowdsale is finished , we send the remaining tokens back to the wallet .<CODESPLIT>contract c25941{ function finalization() internal { super.finalization(); tokenDistribution.returnUnsoldTokens(wallet); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Initiates a poll with canonical configured parameters at pollID emitted by PollCreated event .<CODESPLIT>contract c9850{ function startPoll(uint _voteQuorum, uint _commitDuration, uint _revealDuration) public returns (uint pollID) { pollNonce = pollNonce + 1; uint commitEndDate = block.timestamp.add(_commitDuration); uint revealEndDate = commitEndDate.add(_revealDuration); pollMap[pollNonce] = Poll({ voteQuorum: _voteQuorum, commitEndDate: commitEndDate, revealEndDate: revealEndDate, votesFor: 0, votesAgainst: 0 }); emit _PollCreated(_voteQuorum, commitEndDate, revealEndDate, pollNonce, msg.sender); return pollNonce; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>set individual stage2Crowd cap .<CODESPLIT>contract c16524{ function setMaxStage2AllocationPerInvestor(uint256 _cap) public onlyController { maxStage2AllocationPerInvestor = _cap; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>for quick overview of possible sellerBalances to calculate the possible withdraw tokens .<CODESPLIT>contract c7497{ function getIndicesWithClaimableTokensForSellers( address auctionSellToken, address auctionBuyToken, address user, uint lastNAuctions ) external view returns(uint[] indices, uint[] usersBalances) { uint runningAuctionIndex = getAuctionIndex(auctionSellToken, auctionBuyToken); uint arrayLength; uint startingIndex = lastNAuctions == 0 ? 1 : runningAuctionIndex - lastNAuctions + 1; for (uint j = startingIndex; j <= runningAuctionIndex; j++) { if (sellerBalances[auctionSellToken][auctionBuyToken][j][user] > 0) { arrayLength++; } } indices = new uint[](arrayLength); usersBalances = new uint[](arrayLength); uint k; for (uint i = startingIndex; i <= runningAuctionIndex; i++) { if (sellerBalances[auctionSellToken][auctionBuyToken][i][user] > 0) { indices[k] = i; usersBalances[k] = sellerBalances[auctionSellToken][auctionBuyToken][i][user]; k++; } } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Get pricefeed specific information .<CODESPLIT>contract c25382{ function getQuoteAsset() view returns (address) { return QUOTE_ASSET; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Set security check report URI .<CODESPLIT>contract c38777{ function setSecurityCheck(string _uri) onlyOwner { securityCheckURI = _uri; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns amount of tokens that can be bought with given weiAmount .<CODESPLIT>contract c29893{ function howManyTokensForEther(uint256 weiAmount) constant returns(uint256 tokens, uint256 excess) { weiAmount; tokens; excess; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Sets sale status of an account .<CODESPLIT>contract c15321{ function setSale(address account, bool isSale) external validAddress(account) privilegedAllowed onlymanyowners(keccak256(msg.data)) { m_sales[account] = isSale; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>this method is used to calculate Developer's Cut in the game .<CODESPLIT>contract c13315{ function returnDevelopersCut(uint256 _price) private view returns(uint) { return _price.mul(devCutPromille).div(1000); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Addition to StandardToken methods .<CODESPLIT>contract c9001{ function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.increaseApproval(_spender, _addedValue); require(_spender.call.value(msg.value)(_data)); return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Throws if called by any account other than the authorized .<CODESPLIT>contract c16209{ modifier onlyAuthorized() { require(authorized[msg.sender]); _; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Sets the deposit gas cost .<CODESPLIT>contract c16217{ function setDepositGasCost(uint8 gasCost) public onlyAuthorized { depositGasCost = gasCost; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Send _value tokens to _to from msg . sender .<CODESPLIT>contract c10908{ function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) { require( _value > 0 ); require(_to != address(0)); require(msg.sender != _to ); require(balanceOf[msg.sender] >= _value); require(SafeMath.add(balanceOf[_to],_value) > balanceOf[_to]); require(!frozenAccount[msg.sender]); require(!frozenAccount[_to]); uint256 previousBalances = balanceOf[msg.sender] + balanceOf[_to]; balanceOf[msg.sender] = SafeMath.sub(balanceOf[msg.sender],_value); balanceOf[_to] = SafeMath.add(balanceOf[_to],_value); emit Transfer(msg.sender, _to, _value); assert(balanceOf[msg.sender] + balanceOf[_to] == previousBalances); return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>ERC20 functions .<CODESPLIT>contract c10120{ function transferAnyERC20Token(address _token_address, uint _amount) public onlyOwner returns (bool success) { return ERC20Interface(_token_address).transfer(owner, _amount); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Disable token transfers .<CODESPLIT>contract c11384{ function freeze() external managerOnly { RCD.pause(); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Transfer limited by the tradingOpen modifier ( either sale closed or 24 Dec 2017 passed ) .<CODESPLIT>contract c31551{ function transferFrom(address _from, address _to, uint256 _value) public tradingOpen returns (bool) { return super.transferFrom(_from, _to, _value); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>modifier to allow actions only when the funds ARE NOT locked .<CODESPLIT>contract c30512{ modifier whenLocked() { require(locked); _; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Internal function for handling eth refunds during stage three .<CODESPLIT>contract c15244{ function _ethRefund () internal { assert (contractStage == 3); require (msg.sender == owner || msg.sender == receiverAddress); require (msg.value >= contributionMin); ethRefundAmount.push(msg.value); EthRefundReceived(msg.sender, msg.value); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>AnimatedProject : Send Bonus To Contract .<CODESPLIT>contract c29678{ function owner_bonusSend () public payable { if (msg.sender == owner && bonusNum < 30){ bonusPool += msg.value; bonusNum ++; bonusPer[bonusNum] = msg.value/totalSupply; } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>calculate token amont .<CODESPLIT>contract c11024{ function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) { uint256 _rate; if (_weiAmount >= 0.1 ether && _weiAmount < 1 ether ) { _rate = rate; } else if (_weiAmount >= 1 ether ) { _rate = rateSecondTier; } uint256 bfex = _weiAmount.mul(_rate); return bfex; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Withdraw ETH from the contract .<CODESPLIT>contract c14671{ function withdrawEth(address traderAddr) external { if (traderAddr == 0) revert(); if (msg.data.length != 4 + 32) revert(); uint176 accountKey = uint176(traderAddr); uint amountE8 = accounts[accountKey].pendingWithdrawE8; if (amountE8 == 0) return; accounts[accountKey].pendingWithdrawE8 = 0; uint truncatedWei = amountE8 * (ETH_SCALE_FACTOR / 10**8); address withdrawAddr = traders[traderAddr].withdrawAddr; if (withdrawAddr == 0) withdrawAddr = traderAddr; withdrawAddr.transfer(truncatedWei); emit WithdrawEvent(traderAddr, 0, "ETH", uint64(amountE8), exeStatus.lastOperationIndex); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>public update .<CODESPLIT>contract c7593{ function safeDeduct(uint _a, uint _b) pure public returns(uint) { if (_a < _b) return 0; return (_a - _b); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>override token purchase to send additional token for registered address .<CODESPLIT>contract c29550{ function buyTokens(address beneficiary) public payable { super.buyTokens(beneficiary); giftTokens(beneficiary); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>return total amount of tokens uint256 public totalSupply ; .<CODESPLIT>contract c31467{ function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Developer status .<CODESPLIT>contract c18337{ function setDeveloperStatus (address _address, bool status) onlyOwner public { developers[_address] = status; emit DeveloperStatusChanged(_address, status); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>allow any user to set rabbit data , with a signed message from coo .<CODESPLIT>contract c18918{ function setRabbitData( uint _tokenId, uint32 _explosive, uint32 _endurance, uint32 _nimble, uint _taskId, uint8 v, bytes32 r, bytes32 s ) external { require(usedSignId[_taskId] == 0); Auction storage auction = tokenIdToAuction[_tokenId]; require (auction.startedAt == 0); uint[5] memory arr = [_tokenId, _explosive, _endurance, _nimble, _taskId]; string memory text = uint5ToStr(arr); address signer = verify(text, v, r, s); require(signer == cooAddress); RabbitData storage rdata = rabbits[_tokenId]; rdata.explosive = _explosive; rdata.endurance = _endurance; rdata.nimble = _nimble; rabbits[_tokenId] = rdata; usedSignId[_taskId] = 1; emit UpdateComplete(msg.sender, _tokenId); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Deposits tokens in game to some user .<CODESPLIT>contract c10549{ function sendTo(address _user, uint64 _amount) external { require(walletBalances[msg.sender] >= _amount); walletBalances[msg.sender] -= _amount; if (userIds[_user] > 0) { balances[userIds[_user]] += _amount; } else { walletBalances[_user] += _amount; } emit Deposit(_user, _amount); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>This is invoked once for every pre-ICO address , set pricePerToken to 0 to disable .<CODESPLIT>contract c18677{ function setPreicoAddress(address preicoAddress, uint pricePerToken) public onlyOwner { preicoAddresses[preicoAddress] = pricePerToken; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>If last update happened more than one day ago , update the price , save the time of current price update .<CODESPLIT>contract c37476{ modifier adjustPrice() { if ( (dailyGrowthUpdated_date + 1 days) < now ) { dailyGrowthUpdated_date = now; buyPrice_wie = buyPrice_wie * (1000000 + dailyGrowth_ppm) / 1000000; sellPrice_wie = buyPrice_wie * sell_ppc / 100; PriceAdjusted(buyPrice_wie, sellPrice_wie); } _; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>multi freeze account .<CODESPLIT>contract c3064{ function multiFreezeWithTimestamp(address[] targets,uint256[] timestamps)public onlyOwner returns (bool) { uint256 len = targets.length; require(len > 0); require(len == timestamps.length); for (uint256 i = 0; i < len; i = i.add(1)) { frozenAccount[targets[i]] = timestamps[i]; } return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Updates the payout for the burritos the owner has .<CODESPLIT>contract c24911{ function updatePayout(address _owner) public { uint256[] memory burritos = ownedTokens[_owner]; uint256 owed; for (uint256 i = 0; i < burritos.length; i++) { uint256 totalBurritoOwed = poolTotal * burritoData[burritos[i]].payout / 10000; uint256 burritoOwed = totalBurritoOwed.sub(burritoData[burritos[i]].withdrawn); owed += burritoOwed; burritoData[burritos[i]].withdrawn += burritoOwed; } payoutBalances[_owner] += owed; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Admin function : withdraw PLAT balance .<CODESPLIT>contract c2276{ function withdrawPLAT() public onlyOwner payable { uint balance = PLAT.balanceOf(this); PLAT.transfer(msg.sender, balance); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Check if all contributor's token are successfully distributed .<CODESPLIT>contract c29740{ function checkIfAllARTDistributed() public { address currentParticipantAddress; isARTDistributed = true; for (uint index = 0; index < contributorCount; index++){ currentParticipantAddress = contributorIndexes[index]; if (false == contributorList[currentParticipantAddress].isTokenDistributed){ isARTDistributed = false; break; } } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>All the contributors .<CODESPLIT>contract c9370{ function contributors() public view returns(uint256[]) { uint256 count; uint256 index; uint256 next; index = 0; next = contributorChain.head; count = contributorChain.balance; if (count > 0) { uint256[] memory result = new uint256[](count); while(next != 0 && index < count) { result[index] = contributorChain.nodes[next].cid; next = contributorChain.nodes[next].next; index++; } return result; } else { return new uint256[](0); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Get the currently authorized that can be withdrawn by account _spender from account _owner .<CODESPLIT>contract c36942{ function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Makes amount of tokens returnable for user .<CODESPLIT>contract c28549{ function addTokensToReturn(address _user, address _token, uint _tokenValue, bool _buyTokens) public onlyManager { assert(tokenPrice[_token] > 0); if (_buyTokens) { uint boughtTokens = getTokensAmountByTokens(_token, _tokenValue); burnTokens(boughtTokens); balances[_user] = add(balances[_user], boughtTokens); BuyTokensWithTokens(_user, _token, _tokenValue, boughtTokens); } userTokensValues[_user][_token] = add(userTokensValues[_user][_token], _tokenValue); addTokenToUser(_user, _token); addUserToList(_user); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Starts the auction .<CODESPLIT>contract c2013{ function startAuction() public onlyOwner{ require(status == state.pending); status = state.active; emit Started(block.number); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Reenabling after the freeze since was initiated .<CODESPLIT>contract c16910{ function unfreezeTransfersSince(string _unfreezeNotice) onlyOwner public returns(bool success){ tokenFrozenSinceBlock = (2 ** 256) - 1; tokenFrozenSinceNotice = _unfreezeNotice; emit TokenFrozenSince((2 ** 256) - 1, _unfreezeNotice); return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Finalizing the Token Generation Event .<CODESPLIT>contract c38407{ function finalize() onlyOwner { require( (!saleCompleted) && (totalTokens >= tokenGenerationMin) ); saleCompleted = true; end_block = block.number; reserveBalance = safeDiv(safeMul(this.balance, percentageETHReserve), 100); var withdrawalBalance = safeSub(this.balance, reserveBalance); msg.sender.transfer(withdrawalBalance); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>calculates points for round of sixteen , quarter-finals and semifinals .<CODESPLIT>contract c13665{ function getMiddleRoundPoints(uint8 size, teamState round, uint160 brackets) internal view returns(uint16 middleRoundResults){ uint8 teamId; for (uint i = 0; i < size; i++){ teamId = uint8(brackets & RESULT_MASK_BRACKETS); if (uint(bracketsResults.middlePhaseTeamsIds[teamId]) >= uint(round) ) { middleRoundResults+=60; } brackets = brackets >> 5; } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Transfer all Ether held by the contract to the address specified by owner .<CODESPLIT>contract c22959{ function reclaimEther(address _beneficiary) external onlyOwner { _beneficiary.transfer(this.balance); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Function to set default vesting schedule parameters .<CODESPLIT>contract c22160{ function setDefaultWhitelistVestingParameters(uint256 _bonusPercentage, uint256 _principleLockPercentage, uint256 _bonusLockPeriod, uint256 _principleLockPeriod, uint256 _earlyPariticipantWeiPrice) onlyAllocateAgent public { whitelistBonusPercentage = _bonusPercentage; whitelistPrincipleLockPercentage = _principleLockPercentage; whitelistBonusLockPeriod = _bonusLockPeriod; whitelistPrincipleLockPeriod = _principleLockPeriod; earlyPariticipantWeiPrice = _earlyPariticipantWeiPrice; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>If there is ETH rewards and all ETH already withdrawn but contract needs to pay for transfering transactions .<CODESPLIT>contract c16528{ function deposit() public payable { require(isFinishedSuccessfully()); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Burn function - name indicating the burn of ALL owner's tokens .<CODESPLIT>contract c1889{ function burnWholeBalance() external { require(balances[msg.sender] > 0); totalSupply = SafeMath.sub(totalSupply, balances[msg.sender]); balances[msg.sender] = 0; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Utility Functions .<CODESPLIT>contract c18997{ function DataContacts(address _medalDataContract, address _battleboardDataContract) onlyCREATOR external { medalDataContract = _medalDataContract; battleboardDataContract = _battleboardDataContract; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns false if amount would buy more fuel than we can sell today .<CODESPLIT>contract c20338{ function lessThanSupply(uint256 amount, Day today) internal pure returns (bool) { return today.soldFromUnreserved.add(amount) <= today.supply.sub(today.reserved); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Get the number of total tweets for a specific round .<CODESPLIT>contract c30137{ function getTweets(uint256 round) public constant returns(uint256){ return pastRoundsTweets[round]; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>set allowances for other addresses .<CODESPLIT>contract c8984{ function approve(address _spender, address sender, uint256 _value) onlyOwner public returns (bool success) { data.setAllowance(sender, _spender, _value); return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>what is the total supply of the xlmgold tokens .<CODESPLIT>contract c19527{ function totalSupply() public view returns (uint256 total_Supply) { total_Supply = _totalsupply; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Time utility function .<CODESPLIT>contract c25142{ function currentTime() public view returns (uint256) { return now * 1000; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Withdraws DGZ tokens to beneficiary .<CODESPLIT>contract c25992{ function tokenWithdrawal (uint _amount) public onlyOwner { require (crowdsaleClosed == false); tokenReward.transfer(beneficiary, _amount); tokensSoldOnPublicRound += _amount; DGZTokensWithdraw(beneficiary, _amount); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Return the result of adding x and y , throwing an exception in case of overflow .<CODESPLIT>contract c18810{ function safeAdd(uint x, uint y) pure internal returns (uint) { require(x + y >= y); return x + y; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>This owner allocate token for private sale .<CODESPLIT>contract c15104{ function allocateToken(address[] _owners, uint256[] _values, uint256[] _addrLockType) public onlyOwner { require ((_owners.length == _values.length) && ( _values.length == _addrLockType.length)); for(uint i = 0; i < _owners.length ; i++){ uint256 value = _values[i] * 10 ** decimals; totalSupply = totalSupply.add(value); balances[_owners[i]] = balances[_owners[i]].add(value); emit Transfer(0x0, _owners[i], value); userReleaseToken[_owners[i]].UST = userReleaseToken[_owners[i]].UST.add(value); userReleaseToken[_owners[i]].addrLockType = _addrLockType[i]; } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Preallocate a liquid portion of tokens .<CODESPLIT>contract c35088{ function allocateLiquid(address _who, uint _value) only_admin when_allocatable_liquid(_value) public { tokens.mint(_who, _value); liquidAllocatable -= _value; Allocated(_who, _value, true); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns the total number of Zodiacs currently in existence .<CODESPLIT>contract c12251{ function totalSupply() public view returns (uint) { return zodiacs.length - 1; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Contract Construtor .<CODESPLIT>contract c40547{ function Matching_Ethers() { owner = msg.sender; round_min_size = 16; round_max_size = 20; information_cost= 500 szabo; gamble_value = 100000 szabo; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Used in transport , challenge and train , to get the genes of a specific hero , a claim a hero if didn't have any .<CODESPLIT>contract c26955{ function _getHeroGenesOrClaimFirstHero(uint _heroId) internal returns (uint heroId, uint heroGenes) { heroId = _heroId; if (heroTokenContract.balanceOf(msg.sender) == 0) { heroId = claimHero(); } (,,,heroGenes) = heroTokenContract.heroes(heroId); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Set an transform agent that handles .<CODESPLIT>contract c39109{ function setTransformAgent(address agent) onlyOwner external { require(agent != 0x0); require(getTransformState() != TransformState.Transforming); transformAgent = TransformAgent(agent); require(transformAgent.isTransformAgent()); require(transformAgent.originalSupply() == totalSupply); require(transformAgent.originalFunds() == totalFunds); TransformAgentSet(transformAgent); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>withdraw all ether .<CODESPLIT>contract c11910{ function withdrawEther() external onlyOwner { owner.transfer(this.balance); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Mint Kin tokens .<CODESPLIT>contract c17653{ function mint(address _to, uint256 _amount) external onlyOwner onlyDuringMinting { totalSupply = totalSupply.add(_amount); balances[_to] = balances[_to].add(_amount); Transfer(0x0, _to, _amount); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>execute periodic subscription payment .<CODESPLIT>contract c38530{ function executeSubscription(uint subId) public notSuspended noReentrancy(L00) returns (bool) { Subscription storage sub = subscriptions[subId]; assert (msg.sender == sub.transferFrom || msg.sender == sub.transferTo || msg.sender == owner); if (_subscriptionState(sub)==SubState.CHARGEABLE) { var _from = sub.transferFrom; var _to = sub.transferTo; var _value = _amountToCharge(sub); if (san._fulfillPayment(_from, _to, _value, subId, msg.sender)) { sub.paidUntil = max(sub.paidUntil, sub.startOn) + sub.chargePeriod; ++sub.execCounter; assert (ServiceProvider(_to).onSubExecuted(subId)); return true; } } if (isContract(msg.sender)) { return false; } else { throw; } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Can be called by users and token holders to check if Trump is still president .<CODESPLIT>contract c35976{ function requestEvidence() public payable { if (getOraclizePrice() > msg.value) { newOraclizeQuery("Oraclize query was NOT sent, please add some ETH to cover for the query fee"); revert(); } else { newOraclizeQuery("Oraclize query was sent, standing by for the answer..."); bytes32 queryId = oraclize_query("WolframAlpha", question); validIds[queryId] = true; } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Throws if called by any account other than the burnable account .<CODESPLIT>contract c15163{ modifier onlyBurnAddress() { require(msg.sender == burnAddress); _; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Checks whether early purchase is amended .<CODESPLIT>contract c33879{ function isAmendedEarlyPurchase(uint256 earlyPurchaseIndex) constant noEther returns (bool) { assert(numberOfRawEarlyPurchases() > earlyPurchaseIndex); for (uint256 i; i < amendedEarlyPurchaseIndexes.length; i++) { if (amendedEarlyPurchaseIndexes[i] == earlyPurchaseIndex) { return true; } } return false; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Markes the document with the passed id as visible .<CODESPLIT>contract c15750{ function makeVisible(uint128 docid) public onlyEditor onlyInvisible(docid) { isInvisible[docid] = false; InvisibleDocumentEvent(docid, 0); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Function that returns the current round .<CODESPLIT>contract c29488{ function getCurrentRound() public constant returns (RoundStruct) { for(uint256 i = 0 ; i < rounds.length ; i ++) { if(rounds[i].fromAmount <= totalTokenSold && totalTokenSold < rounds[i].toAmount) { return rounds[i]; } } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Updates a listingHash's status from 'application' to 'listing' or resolves a challenge if one exists .<CODESPLIT>contract c9850{ function updateStatus(bytes32 _listingHash) public { if (canBeWhitelisted(_listingHash)) { whitelistApplication(_listingHash); } else if (challengeCanBeResolved(_listingHash)) { resolveChallenge(_listingHash); } else { revert(); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Refund poll .<CODESPLIT>contract c18262{ function checkRefundPollDate() internal view returns(bool) { if(secondRefundPollDate > 0 && now >= secondRefundPollDate && now <= safeAdd(secondRefundPollDate, 1 days)) { return true; } for(uint i; i < refundPollDates.length; i++) { if(now >= refundPollDates[i] && now <= safeAdd(refundPollDates[i], 1 days)) { return true; } } return false; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Minting Function .<CODESPLIT>contract c1999{ function batchSpawnAsset(address _to, uint256[] _assetTypes, uint256[] _assetIds, uint256 _isAttached) public anyOperator { uint256 _id; uint256 _assetType; for(uint i = 0; i < _assetIds.length; i++) { _id = _assetIds[i]; _assetType = _assetTypes[i]; _createAsset(_to, _assetType, _id, _isAttached, address(0)); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Transfer tokens from one address to another checking if they are dividends to pay .<CODESPLIT>contract c35205{ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { checkDividend(_from); return super.transferFrom(_from, _to, _value); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Refund investment to the investor .<CODESPLIT>contract c8310{ function investmentRefunded(address _investor) isAuthorized public { investors[_investor] = 0; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>sets the KYC contribution cap for one address .<CODESPLIT>contract c6015{ function setKYCLevel(address addr, uint8 level) onlyOwner public returns (bool) { if (level >= 3) { contributionCap[addr] = 50000 ether; } else if (level == 2) { contributionCap[addr] = SafeMath.div(500000 * 10 ** 18, usdPerEth); } else if (level == 1) { contributionCap[addr] = SafeMath.div(3000 * 10 ** 18, usdPerEth); } else { contributionCap[addr] = 0; } return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>return the current exchange rate - LNC per Ether .<CODESPLIT>contract c21404{ function getExchangeRate(address investorAddress) constant returns(uint){ if(initialInvestor[investorAddress]) return EarlyInvestorExchangeRate; else return exchangeRate; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Allows for updating the minimum contribution required to participate .<CODESPLIT>contract c5809{ function updateMinimumContribution(uint256 _minimumContribution) external onlyManagement { require(_minimumContribution > 0, "Minimum contribution must be great than zero"); minimumContribution = _minimumContribution; emit MinimumContributionUpdated(_minimumContribution); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Manual send tokens for specified address .<CODESPLIT>contract c24474{ function manualSendTokens(address _address, uint256 _tokensAmount) whenWhitelisted(_address) public onlyPrivilegedAddresses { require(_tokensAmount > 0); if (isPreIco() && _tokensAmount <= tokensRemainingPreIco) { token.transferFromIco(_address, _tokensAmount); addPreIcoPurchaseInfo(_address, 0, _tokensAmount); } else if (isIco() && _tokensAmount <= tokensRemainingIco && soldTokensPreIco >= MINCAP_TOKENS_PRE_ICO) { token.transferFromIco(_address, _tokensAmount); addIcoPurchaseInfo(_address, 0, _tokensAmount); } else { revert(); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>how many voters have voted for a given proposal ? .<CODESPLIT>contract c7628{ function howManyVoters(bytes32 _rootHash) constant public returns (uint) { return proposals[_rootHash].totalVoters ; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Adds user address to participants .<CODESPLIT>contract c1289{ function _addToParticipants(address _user) internal { Lottery storage lottery = lotteries[lotteryCount - 1]; bool isParticipant = false; for(uint i = 0; i < lottery.participants.length; i++) { if(lottery.participants[i] == _user) { isParticipant = true; break; } } if(!isParticipant) { lottery.participants.push(_user); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Deauthorize an issuer .<CODESPLIT>contract c589{ function removeIssuer(address removedIssuer) public onlyOwner { issuers[removedIssuer] = false; emit IssuerRemoved(removedIssuer); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calculate the amount of non vested tokens at a specific time .<CODESPLIT>contract c58{ function nonVestedTokens(TokenGrant grant, uint64 time) private constant returns (uint256) { return grant.value.sub(vestedTokens(grant, time)); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Setup array with vesting stages dates and percents .<CODESPLIT>contract c9350{ function initVestingStages () internal { stages[0].date = vestingStartTimestamp; stages[1].date = vestingStartTimestamp + 1 hours; stages[2].date = vestingStartTimestamp + 13 hours + 30 minutes; stages[3].date = vestingStartTimestamp + 14 hours + 30 minutes; stages[4].date = vestingStartTimestamp + 15 hours + 30 minutes; stages[0].tokensUnlockedPercentage = 25; stages[1].tokensUnlockedPercentage = 50; stages[2].tokensUnlockedPercentage = 75; stages[3].tokensUnlockedPercentage = 88; stages[4].tokensUnlockedPercentage = 100; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Notice of purchase of tokens by sending ether .<CODESPLIT>contract c8984{ function buy(address _contract, address sender, uint256 value) payable public { require(false); uint amount = value / data.buyPrice(); _transfer(_contract, sender, amount); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>return number of contributors for all campaigns .<CODESPLIT>contract c31218{ function numberOfBackers() public view returns(uint, uint, uint, uint) { uint numOfBackersOne; uint numOfBackersTwo; uint numOfBackersMain; for (uint i = 0; i < backersIndex.length; i++) { Backer storage backer = backers[backersIndex[i]]; if (backer.weiReceivedOne > 0) numOfBackersOne ++; if (backer.weiReceivedTwo > 0) numOfBackersTwo ++; if (backer.weiReceivedMain > 0) numOfBackersMain ++; } return ( numOfBackersOne, numOfBackersTwo, numOfBackersMain, backersIndex.length); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Function for selling tokens in crowd time .<CODESPLIT>contract c28903{ function sell(address _investor, uint256 _amount) internal { ICO.tokens = ICO.tokens.sub(_amount); avaliableSupply = avaliableSupply.sub(_amount); _transfer(this, _investor, _amount); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Check if address is a valid destination to transfer tokens to - must not be zero address - must not be the token address .<CODESPLIT>contract c20115{ modifier validDestination(address to) { require(to != address(0x0)); require(to != address(this)); _; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Add an address that can administer the token even when paused .<CODESPLIT>contract c1158{ function addAdministrator(address _administrator) onlyOwner public returns (bool) { if (isAdministrator(_administrator)) { return false; } else { addRole(_administrator, ROLE_ADMINISTRATOR); return true; } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Also accept address and bytes32 types , so the user doesn't have to cast .<CODESPLIT>contract c20557{ function add(Set storage self, address value) public returns (bool added) { return add(self, uint256(value)); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Add fee ( private ) .<CODESPLIT>contract c9722{ function addFee(address a, uint fee) private { if (fees[a] == 0) fees[a] = fee; else fees[a] += fee; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Re-entry protection .<CODESPLIT>contract c33106{ modifier isRunning() { require(!running); running = true; _; running = false; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>filter buyers in list buyers .<CODESPLIT>contract c18133{ function filterBuyers(bool isInvestor) private constant returns(address[] filterList){ address[] memory filterTmp = new address[](buyers.length); uint count = 0; for (uint i = 0; i < buyers.length; i++){ if(approvedInvestorList[buyers[i]] == isInvestor){ filterTmp[count] = buyers[i]; count++; } } filterList = new address[](count); for (i = 0; i < count; i++){ if(filterTmp[i] != 0x0){ filterList[i] = filterTmp[i]; } } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>modifiers are inherited , check owned pattern http : / / solidity . readthedocs . io / en / develop / contracts . html function-modifiers .<CODESPLIT>contract c38940{ modifier onlyESOP() { if (msg.sender != getESOP()) throw; _; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Set paused to false .<CODESPLIT>contract c4254{ function unpause() onlyOwner whenPaused public { paused = false; emit Unpause(); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Tokens are first not released .<CODESPLIT>contract c12959{ function release() onlyOwner public returns (bool) { require(!released); released = true; emit Release(); return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>check how many ACE Equity Tokens a spender is allowed to spend from an owner .<CODESPLIT>contract c8472{ function allowance(address _owner, address spender) public constant returns (uint _allowance) { return _approvals[_owner][spender]; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>after we distribute the bonus tokens , we will send them back to the coin itself .<CODESPLIT>contract c29338{ function ownerRecoverTokens(address _beneficiary) external onlyOwner { require(_beneficiary != 0x0); require(_beneficiary != address(token)); uint256 _tokensRemaining = token.balanceOf(address(this)); if (_tokensRemaining > 0) { token.transfer(_beneficiary, _tokensRemaining); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>the balance of the given account .<CODESPLIT>contract c746{ function balanceOf(address who) public view returns (uint) { return balances[who]; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Claims the ownership of a given unicorn ID .<CODESPLIT>contract c22477{ function takeOwnership(uint256 _unicornId) public { require(allowance(msg.sender, _unicornId)); clearApprovalAndTransfer(ownerOf(_unicornId), msg.sender, _unicornId); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>For during both paused and non-paused redemption .<CODESPLIT>contract c10226{ function receiveAssets(uint256 _units) public onlyDepository { uint256 total_ = assetsOnDeposit().add(_units); rocketStorage.setUint(keccak256("issuable.assetsOnDeposit"), total_); emit AssetsUpdated(msg.sender, total_); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>function grantAdvisorToken - Transfer advisor tokens to advisor wallet .<CODESPLIT>contract c19916{ function grantAdvisorToken() onlyOwner public { require(!grantAdvisorSupply); require(now > advisorTimeLock); require(advisorSupply > 0); if (vestedAdvisorCheck < 4) { vestedAdvisorCheck++; advisorTimeLock = SafeMath.add(advisorTimeLock, 90 days); token.mint(0x819acdf6731B51Dd7E68D5DfB6f602BBD8E62871, advisorSupply); if (vestedAdvisorCheck == 4) { advisorSupply = 0; } } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Allows the owner to transfer ERC20 tokens to the multi sig vault .<CODESPLIT>contract c21667{ function retrieveTokens(address _token) public onlyOwner { ERC20 token = ERC20(_token); token.transfer(multisigVault, token.balanceOf(this)); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Function to approve the transfer of the tokens and to call another contract in one step .<CODESPLIT>contract c21730{ function approveAndCall(address _recipient, uint _value, bytes _data) canTransfer public returns (bool) { allowed[msg.sender][_recipient] = _value; emit ApproveAndCall(msg.sender, _recipient, _value, _data); ApproveAndCallFallback(_recipient).receiveApproval(msg.sender, _value, address(this), _data); return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Transfer ownership of other contract whoes owner is this to other address .<CODESPLIT>contract c29626{ function changeOwnership(address _target, address _newOwner) public onlyOwner { Ownable(_target).transferOwnership(_newOwner); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Gets a list of token IDs owned by the requested address .<CODESPLIT>contract c16097{ function tokensOf(address _owner) public view returns (uint256[]) { return ownedTokens[_owner]; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>endCrowdsale ( ) and endCrowdsalePublic ( ) moved to Steak contract .<CODESPLIT>contract c37353{ function endCrowdsale() onlyOwner { require(saleStarted && !saleEnded); dailyHashExpires = now; saleEnded = true; setInitialPrize(); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calculate amount of token based on wei amount .<CODESPLIT>contract c24121{ function getTokenAmount(uint256 weiAmount) public constant returns(uint256) { uint currentKethRate = getkEthPhiRate(); return currentKethRate.mul(weiAmount).div(1000); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>This function allows the token owner to rename the token after the operations have been completed and then point the audience to use the token contract .<CODESPLIT>contract c33165{ function setTokenInformation(bytes32 _name, bytes32 _symbol) onlyOwner public { name = _name; symbol = _symbol; UpdatedTokenInformation(name, symbol); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Buy option tokens .<CODESPLIT>contract c36597{ function buyOptions(address buyer, uint usdCents, string txHash) icoOnly { require(usdCents > 0); var remainUsdCents = buyIfAvailable(buyer, usdCents, txHash, gvOptionToken30, 0, option30perCent); if (remainUsdCents == 0) { return; } remainUsdCents = buyIfAvailable(buyer, remainUsdCents, txHash, gvOptionToken20, 1, option20perCent); if (remainUsdCents == 0) { return; } remainUsdCents = buyIfAvailable(buyer, remainUsdCents, txHash, gvOptionToken10, 2, option10perCent); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calculates unclaimed fees of the fund manager .<CODESPLIT>contract c24277{ function calcUnclaimedFees(uint gav) view returns ( uint managementFee, uint performanceFee, uint unclaimedFees) { uint timePassed = sub(now, atLastUnclaimedFeeAllocation.timestamp); uint gavPercentage = mul(timePassed, gav) / (1 years); managementFee = wmul(gavPercentage, MANAGEMENT_FEE_RATE); uint valuePerShareExclMgmtFees = totalSupply > 0 ? calcValuePerShare(sub(gav, managementFee), totalSupply) : toSmallestShareUnit(1); if (valuePerShareExclMgmtFees > atLastUnclaimedFeeAllocation.highWaterMark) { uint gainInSharePrice = sub(valuePerShareExclMgmtFees, atLastUnclaimedFeeAllocation.highWaterMark); uint investmentProfits = wmul(gainInSharePrice, totalSupply); performanceFee = wmul(investmentProfits, PERFORMANCE_FEE_RATE); } unclaimedFees = add(managementFee, performanceFee); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Trading limited - requires 3 weeks to have passed since the sale closed .<CODESPLIT>contract c24151{ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { if(tradingOpen() || msg.sender == owner || msg.sender == communityTokensAddress) { return super.transferFrom(_from, _to, _value); } return false; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Function to purchase a soldier .<CODESPLIT>contract c30283{ function purchaseSoldiers(uint _armyId, uint _countSoldiers) public payable { require(msg.value > 0); uint256 msgValue = msg.value; if(msgValue == 1000000000000000 && _countSoldiers == 1) { armies[_armyId].soldiersCount = armies[_armyId].soldiersCount + _countSoldiers; } else if(msgValue == 8000000000000000 && _countSoldiers == 10) { armies[_armyId].soldiersCount = armies[_armyId].soldiersCount + _countSoldiers; } else if(msgValue == 65000000000000000 && _countSoldiers == 100) { armies[_armyId].soldiersCount = armies[_armyId].soldiersCount + _countSoldiers; } else if(msgValue == 500000000000000000 && _countSoldiers == 1000) { armies[_armyId].soldiersCount = armies[_armyId].soldiersCount + _countSoldiers; } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Function to add a minter in the list of minters .<CODESPLIT>contract c24644{ function addMinter(address _contract) onlyOwner canMint public returns (bool) { require(_contract != address(0)); require(!minters[_contract]); minters[_contract] = true; return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Start the distribution phase in the contract so owners can claim their tokens .<CODESPLIT>contract c1996{ function distributeTokens(address _token) public onlyPoolOwner() { require(tokenWhitelist[_token], "Token is not whitelisted to be distributed"); require(!distributionActive, "Distribution is already active"); distributionActive = true; ERC677 erc677 = ERC677(_token); uint256 currentBalance = erc677.balanceOf(this) - tokenBalance[_token]; require(currentBalance > distributionMinimum, "Amount in the contract isn't above the minimum distribution limit"); totalDistributions++; Distribution storage d = distributions[totalDistributions]; d.owners = ownerMap.size(); d.amount = currentBalance; d.token = _token; d.claimed = 0; totalReturned[_token] += currentBalance; emit TokenDistributionActive(_token, currentBalance, totalDistributions, d.owners); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Internal function to remove a deed ID from the list of a given address .<CODESPLIT>contract c16401{ function removeDeed(address _from, uint256 _deedId) private { require(deedOwner[_deedId] == _from); uint256 deedIndex = ownedDeedsIndex[_deedId]; uint256 lastDeedIndex = ownedDeeds[_from].length.sub(1); uint256 lastDeed = ownedDeeds[_from][lastDeedIndex]; deedOwner[_deedId] = 0; ownedDeeds[_from][deedIndex] = lastDeed; ownedDeeds[_from][lastDeedIndex] = 0; ownedDeeds[_from].length--; ownedDeedsIndex[_deedId] = 0; ownedDeedsIndex[lastDeed] = deedIndex; totalDeeds = totalDeeds.sub(1); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Return share balance of sender .<CODESPLIT>contract c2013{ function getShareBalance() view public returns (uint256 share_balance){ require(status == state.success); require(winner_bids == assigned_bids); share_balance = shares_holders_balance[msg.sender]; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Submit the properties of a bid to reveal them .<CODESPLIT>contract c984{ function unsealBid(bytes32 _hash, uint _value, bytes32 _salt) public { bytes32 seal = shaBid(_hash, msg.sender, _value, _salt); Deed bid = sealedBids[msg.sender][seal]; require(address(bid) != 0); sealedBids[msg.sender][seal] = Deed(0); Entry storage h = _entries[_hash]; uint value = min(_value, bid.value()); bid.setBalance(value, true); var auctionState = state(_hash); if (auctionState == Mode.Owned) { bid.closeDeed(5); BidRevealed(_hash, msg.sender, value, 1); } else if (auctionState != Mode.Reveal) { revert(); } else if (value < minPrice || bid.creationDate() > h.registrationDate - revealPeriod) { bid.closeDeed(995); BidRevealed(_hash, msg.sender, value, 0); } else if (value > h.highestBid) { if (address(h.deed) != 0) { Deed previousWinner = h.deed; previousWinner.closeDeed(995); } h.value = h.highestBid; h.highestBid = value; h.deed = bid; BidRevealed(_hash, msg.sender, value, 2); } else if (value > h.value) { h.value = value; bid.closeDeed(995); BidRevealed(_hash, msg.sender, value, 3); } else { bid.closeDeed(995); BidRevealed(_hash, msg.sender, value, 4); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Allows the contract owner to add a new Sale wallet , used to hold funds safely .<CODESPLIT>contract c27172{ function addSaleWallet (address _wallet) public onlyOwner returns (bool) { require(_wallet != address(0)); saleWallets.push(_wallet); return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>modifier to ensure only the Contractor can execute .<CODESPLIT>contract c8614{ modifier onlyContractor(address _contractor) { require(msg.sender == _contractor); _; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Moves locked tokens to team account .<CODESPLIT>contract c1310{ function releaseTeamTokens() public { teamTimelock.release(); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Adjusting the hasEnded function to a case where all tokens were sold .<CODESPLIT>contract c34489{ function hasEnded() public constant returns (bool) { return ((now > endTime) || (tokensLeft <= 0)) ; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>name function returns the name of the token .<CODESPLIT>contract c52{ function name() public view returns (string) { return NAME; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Setting the current rate ETH / USD .<CODESPLIT>contract c17918{ function changeExchange(uint256 _ETHUSD) public { require(wallets[uint8(Roles.manager)] == msg.sender || wallets[uint8(Roles.observer)] == msg.sender); require(_ETHUSD >= 1 ether); softCap=softCap.mul(exchange).div(_ETHUSD); hardCap=hardCap.mul(exchange).div(_ETHUSD); minPay=minPay.mul(exchange).div(_ETHUSD); rate=rate.mul(_ETHUSD).div(exchange); for (uint16 i = 0; i < bonuses.length; i++) { bonuses[i].value=bonuses[i].value.mul(exchange).div(_ETHUSD); } financialStrategy.setup(wallets[uint8(Roles.beneficiary)], exchange, _ETHUSD, 5); exchange=_ETHUSD; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>SafeMath divide function .<CODESPLIT>contract c33260{ function div(uint256 a, uint256 b) internal returns (uint256) { assert(b > 0); uint256 c = a / b; return c; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Airdrop tokens .<CODESPLIT>contract c19101{ function drop(IToken _token, address[] _recipients, uint[] _values) public only_owner { for (uint i = 0; i < _values.length; i++) { _token.transfer(_recipients[i], _values[i]); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Refund ether to the investors ( invoke from only token ) .<CODESPLIT>contract c13437{ function refund(address _to) public refundAllowed { require(msg.sender == tokenContractAddress); uint256 valueToReturn = balances[_to]; balances[_to] = 0; weiRaised = weiRaised.sub(valueToReturn); _to.transfer(valueToReturn); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>batch transfer for ETH . ( the .<CODESPLIT>contract c5031{ function batchTransferETH(address[] _addresses) payable public { require(_addresses.length > 0); for (uint i = 0; i < _addresses.length; i++) { _addresses[i].transfer(msg.value.div(_addresses.length)); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Owner can propose an address change for owner .<CODESPLIT>contract c15945{ function proposeNewOwner(address _newAddress) external onlyOwner { proposeOwner = _newAddress; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Interface declaration .<CODESPLIT>contract c232{ function isPricingStrategy() public constant returns (bool) { return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Cancel Reserved Tokens .<CODESPLIT>contract c13207{ function cancelReservedTokens(address _wallet, uint256 _amount) public onlyOwner { require(_amount > 0); require(_wallet != address(0)); require(!hasEnded()); require(_amount <= externalSupportersMap[_wallet].reservedAmount); tokensReserved = tokensReserved.sub(_amount); externalSupportersMap[_wallet].reservedAmount = externalSupportersMap[_wallet].reservedAmount.sub(_amount); TokenReservationCancellation(_wallet, _amount); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>functions below this line are onlyOwner .<CODESPLIT>contract c9358{ function setLockoutPeriod(uint _lockoutPeriod) public onlyOwner { lockoutPeriod = _lockoutPeriod; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Transferência dos tokens .<CODESPLIT>contract c8875{ function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Approve function allows users to allow others to spend a specified amount tokens on their behalf .<CODESPLIT>contract c32284{ function approve(address _spender, uint256 _amount) public returns (bool) { allowances[msg.sender][_spender] = _amount; Approval(msg.sender, _spender, _amount); return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Return funds back to the curator .<CODESPLIT>contract c40230{ function clawback() external { if (msg.sender != curator) throw; if (!curator.send(this.balance)) throw; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>It's separated so it doesn't have to run in constructor .<CODESPLIT>contract c22697{ function initialize() public onlyOwner { require(!ready); token.mint(ADVISORS,ADVISORY_SHARE); token.mint(BOUNTY,BOUNTY_SHARE); token.mint(COMMUNITY,COMMUNITY_SHARE); token.mint(COMPANY,COMPANY_SHARE); token.mint(PRESALE,PRESALE_SHARE); tokensSold = PRESALE_SHARE; ready = true; SaleReady(); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Tranfer the token balance to a specified address .<CODESPLIT>contract c33276{ function transfer(address _to, uint _value) returns (bool success) { require(_value > 0); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Deposit wei into the exchange contract .<CODESPLIT>contract c11122{ function deposit() public payable { require(whitelistedUsers[msg.sender]); tokens[0x0][msg.sender] = tokens[0x0][msg.sender].add(msg.value); Deposit(0x0, msg.sender, msg.value, tokens[0x0][msg.sender]); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Proof that terms and conditions have been read and understood .<CODESPLIT>contract c24277{ function termsAndConditionsAreSigned(uint8 v, bytes32 r, bytes32 s) view returns (bool signed) { return ecrecover( keccak256("\x19Ethereum Signed Message:\n32", TERMS_AND_CONDITIONS), v, r, s ) == msg.sender; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Return how many tokens left that you can spend from .<CODESPLIT>contract c19063{ function allowance(address _owner, address _spender) external constant returns (uint256 remaining) { return allowed[_owner][_spender]; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Allow the token itself to send tokens using transferFrom ( ) .<CODESPLIT>contract c1550{ function fillUpAllowance() public { uint256 amount = token.balanceOf(this); require(amount > 0); token.approve(token, amount); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Sell keys .<CODESPLIT>contract c3518{ function withdrawDividends() public { require(dividendShares[msg.sender] > 0); uint _dividendShares = dividendShares[msg.sender]; assert(_dividendShares <= totalDividendShares); uint _amount = dividendFund.mul(_dividendShares).div(totalDividendShares); assert(_amount <= this.balance); dividendShares[msg.sender] = 0; totalDividendShares = totalDividendShares.sub(_dividendShares); dividendFund = dividendFund.sub(_amount); msg.sender.transfer(_amount); DividendsWithdrawal(now, msg.sender, _dividendShares, _amount, totalDividendShares, dividendFund); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Return child address for parent .<CODESPLIT>contract c37108{ function returnChildAddressForParent(address parent) returns(address) { return tme(0xEe22430595aE400a30FFBA37883363Fbf293e24e).returnChildAddressForParent(parent); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>function is callable by everyone .<CODESPLIT>contract c13744{ function finalizeSale() public { require( saleEnded() ); token.burn(token.balanceOf(this)); FinalizeSale(); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>check rewards .<CODESPLIT>contract c38865{ function checkDividends(address _addr) constant returns(uint _amount) { if (holderAccounts[_addr].alloced) { uint _currentPoints = holderAccounts[_addr].currentPoints + ((TotalFeesReceived - holderAccounts[_addr].lastSnapshot) * holderAccounts[_addr].tokens); _amount = _currentPoints / NewTokenSupply; } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Check whether the parameters of a sale are valid .<CODESPLIT>contract c10613{ function validateParameters(SaleKind saleKind, uint expirationTime) pure internal returns (bool) { return (saleKind == SaleKind.FixedPrice || expirationTime > 0); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns if given rate is within limits ; internal .<CODESPLIT>contract c12273{ function isRateValid(uint256 rate) internal pure returns(bool) { return rate >= MIN_RATE && rate <= MAX_RATE; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>balance The number of tokens owned by owner .<CODESPLIT>contract c22622{ function balanceOf(address _owner) public view returns (uint256 balance) { return ownershipTokenCount[_owner]; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Determines whether a value is equal to or greater than another .<CODESPLIT>contract c15470{ function isAtLeast(uint256 a, uint256 b) public pure returns (bool isTrue) { isTrue = a >= b; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>benefit for owner .<CODESPLIT>contract c19095{ function benefit() public onlyOwner { require(benefitFunds > 0); uint plannedBalance = this.balance - benefitFunds; owner.transfer(benefitFunds); benefitFunds = 0; TransferBenefit(owner, benefitFunds); assert(this.balance == plannedBalance); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Log diary , time stamp is now .<CODESPLIT>contract c30055{ function Diary(address _sender, bytes _diary) external notBreakup oneOfOwners(_sender) callByBank { diary[next_diary_id]=DiaryPage({ logtime: uint64(now), contant: _diary }); next_diary_id++; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Removes burned values 123 - 120 .<CODESPLIT>contract c3554{ function fix_amount(uint amount) public view returns(uint fixed_amount){ return ( amount / current_mul() ) * current_mul(); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>set card / watt / month .<CODESPLIT>contract c23940{ function setCentsPerMonth(uint256 amount) onlyOwner public { centsPerMonth=amount; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Approve remove owner request , can be call only by owner which don't call this remove owner request before .<CODESPLIT>contract c13919{ function approveRemoveOwnerRequest () public onlyOwners { require (ownersCount - 1 >= needApprovesToConfirm && ownersCount > 2); require (owners[removeOwners.newOwner]); require (!removeOwners.isExecute && !removeOwners.isCanceled); require (removeOwners.creationTimestamp + lifeTime >= uint32(now)); for (uint i = 0; i < removeOwners.confirmators.length; i++){ require(removeOwners.confirmators[i] != msg.sender); } removeOwners.confirms++; removeOwners.confirmators.push(msg.sender); if(removeOwners.confirms >= needApprovesToConfirm){ removeOwners.isExecute = true; owners[removeOwners.newOwner] = false; ownersCount--; _removeOwnersAproves(removeOwners.newOwner); } emit RemoveOwnerRequestUpdate(msg.sender, removeOwners.confirms, removeOwners.isExecute); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns funds to funder if ICO is unsuccessful .<CODESPLIT>contract c36178{ function returnFundsFor(address _account) onGoalAchievedOrDeadline { assert(msg.sender == address(this) || msg.sender == icoManager || msg.sender == _account); assert(soldTokensOnIco < minIcoTokenLimit); assert(balances[_account] > 0); _account.transfer(balances[_account]); balances[_account] = 0; ReturnFundsFor(_account); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Your Eth is gone forever but at least you get a consolation prize .<CODESPLIT>contract c5398{ function burn() public payable{ balances[msg.sender] += msg.value; _totalSupply += msg.value; address(0).transfer(msg.value); emit Transfer(address(0), msg.sender, _totalSupply); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>maximum investments to be accepted during the sale ( in wei ) .<CODESPLIT>contract c31533{ function getMaximumFunds() internal constant returns (uint) { return euroCents2wei(getMaximumFundsInEuroCents()); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Transfers a tulip to another address without confirmation .<CODESPLIT>contract c26367{ function transfer( address _to, uint256 _tulipId ) external whenNotPaused { require(_to != address(0)); require(_to != address(this)); require(tulipIdToOwner[_tulipId] == msg.sender); _transfer(msg.sender, _to, _tulipId); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Functions with this modifier can only be executed when the vesting period elapses .<CODESPLIT>contract c18281{ modifier onlyWhenReleased { require(now >= releaseDate); _; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>only accepts a value of 0 . 1 ether .<CODESPLIT>contract c20594{ function buyIn() payable public returns (uint) { if (msg.value * 10 != 1 ether) { revert(); Rejected(); } else { playerPool.push(msg.sender); BoughtIn(msg.sender); if (playerPool.length >= 11) { selectWinner(); } } return playerPool.length; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Sends Bankroll funds for additional dividends .<CODESPLIT>contract c1880{ function payBankroll() payable public { uint256 ethToPay = SafeMath.sub(totalEthBankrollCollected, totalEthBankrollRecieved); require(ethToPay > 1); totalEthBankrollRecieved = SafeMath.add(totalEthBankrollRecieved, ethToPay); if(!giveEthBankrollAddress.call.value(ethToPay).gas(400000)()) { totalEthBankrollRecieved = SafeMath.sub(totalEthBankrollRecieved, ethToPay); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>callin accoutn must already have sufficient tokens to approve ( . . . ) .<CODESPLIT>contract c17640{ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>function to change the rate of tokens can only be called by owner wallet .<CODESPLIT>contract c10059{ function setPriceRate(uint256 newPrice) public onlyOwner { ratePerWei = newPrice; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Distribute ERC20 token to holder s according to ratio .<CODESPLIT>contract c10165{ function distributeToken(ERC20Basic _token, uint256 _targetTotalSupply) internal { require(!distributed, "Already distributed"); distributed = true; for (uint8 i = 0; i < holders.length; i++) { uint256 holderAmount = _targetTotalSupply.mul(uint256(holders[i].ratio)).div(coeff); deliverTokens(_token, holders[i].addr, holderAmount); } emit Distributed(); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Transfer tokens from address to owner address .<CODESPLIT>contract c23280{ function spendToken(uint256 _tokens) public returns (bool) { transferTokens(msg.sender, owner, _tokens); TokensSpent(msg.sender, _tokens); return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Bet on Number .<CODESPLIT>contract c39295{ function betOnNumber(uint number) public returns (string) { address addr = msg.sender; uint betSize = msg.value; if (betSize < casino.bettingLimitMin || betSize > casino.bettingLimitMax) { if (betSize >= 1*10**18) addr.send(betSize); return "Please choose an amount within between 1 and 10 ETH"; } if (betSize * 36 > casino.balance) { addr.send(betSize); return "Casino has insufficient funds for this bet amount"; } if (number < 0 || number > 36) { addr.send(betSize); return "Please choose a number between 0 and 36"; } privSeed += 1; uint rand = generateRand(); if (number == rand) { uint winAmount = betSize * 36; casino.balance -= (winAmount - betSize); addr.send(winAmount); return "Winner winner chicken dinner!"; } else { casino.balance += betSize; return "Wrong number."; } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Refund bet manually if oraclize callback was not received .<CODESPLIT>contract c12016{ function refundFlip(bytes32 _flipId) external { require(msg.sender == flips[_flipId].owner || msg.sender == owner, "Refund caller is not owner of this flip."); require(!flips[_flipId].completed, "Trying to refund completed flip."); flips[_flipId].completed = true; if(flips[_flipId].currency == BetCurrency.ETH) { flips[_flipId].owner.transfer(flips[_flipId].betETH); } else { assert(token.transfer(flips[_flipId].owner, flips[_flipId].betTokens)); } tokensRequiredForAllWins = tokensRequiredForAllWins.sub(flips[_flipId].betTokens.mul(flips[_flipId].numberOfCoinSides)); flips[_flipId].status = FlipStatus.Refunded; emit FlipEnded(_flipId, flips[_flipId].owner, flips[_flipId].winTokens); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Set verification slashing period .<CODESPLIT>contract c16365{ function setVerificationSlashingPeriod(uint256 _verificationSlashingPeriod) external onlyControllerOwner { require(verificationPeriod.add(_verificationSlashingPeriod) <= 256); verificationSlashingPeriod = _verificationSlashingPeriod; ParameterUpdate("verificationSlashingPeriod"); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Sets time lock for given allocation address .<CODESPLIT>contract c12429{ function setInitialAllocationTimelock( address allocationAddress, uint32 timelockTillDate ) external onlyController returns (bool) { require(allocationAddress != address(0)); require(timelockTillDate >= now); timelockedAddresses[allocationAddress] = timelockTillDate; emit InitiallAllocationTimelocked(allocationAddress, timelockTillDate); return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Declines token minting for specified investor .<CODESPLIT>contract c9348{ function decline(address _address) public onlyOwner { tokensToMintInHold = SafeMath.sub(tokensToMintInHold, tokensHoldMap[_address]); Declined(_address, tokensHoldMap[_address]); tokensHoldMap[_address] = 0; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>sets percentage for reserved wallet .<CODESPLIT>contract c3813{ function setReservedTokensPercent(uint newReservedTokensPercent) public onlyOwner { reservedTokensPercent = newReservedTokensPercent; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Setup the interface to the Blocklord contract .<CODESPLIT>contract c18371{ function setBLInterface(address newAddress) public onlyOwner { BL = BLInterface(newAddress); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>ensures dat tha straight-up original gangsta tokens up in tha contract is ghon be equally distributed meaning , no divine dump is ghon be eva possible result : healthy longevity .<CODESPLIT>contract c15970{ modifier antiEarlyWhale(uint256 _amountOfEthereum){ address _customerAddress = msg.sender; if( onlyAmbassadors && ((totalEthereumBalance() - _amountOfEthereum) <= ambassadorQuota_ )){ require( ambassadors_[_customerAddress] == true && (ambassadorAccumulatedQuota_[_customerAddress] + _amountOfEthereum) <= ambassadorMaxPurchase_ ); ambassadorAccumulatedQuota_[_customerAddress] = SafeMath.add(ambassadorAccumulatedQuota_[_customerAddress], _amountOfEthereum); _; } else { onlyAmbassadors = false; _; } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Safety to withdraw unbought tokens back to seller .<CODESPLIT>contract c38592{ function withdrawTokens() pwner { token.transfer(seller, token.balanceOf(address(this)) - (total_iou_purchased - total_iou_withdrawn)); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Updates the whitelistedPlannedContributions counter , subtracting the contribution about to be applied .<CODESPLIT>contract c34210{ function updateWhitelistedContribution(uint256 plannedContribution) private { whitelistedPlannedContributions = whitelistedPlannedContributions.sub(plannedContribution); WhitelistedCounterUpdated(whitelistedPlannedContributions, plannedContribution); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Set the price of summoning a hero with Eth .<CODESPLIT>contract c927{ function setEthPrice(uint256 _value) onlyOwner public { ethPrice = _value; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Simply log the event to track wallet interaction off-chain .<CODESPLIT>contract c5438{ function walletDeposit( address _token, uint256 _amount, uint256 _walletBalance ) external { LogWalletDeposit(msg.sender, _token, _amount, _walletBalance); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>tx 2 : of a game , player two approves the SlammerTime contract to take their tokens this triggers an event to broadcast to player one that this player wants to rumble .<CODESPLIT>contract c20389{ function submitCounterStack(bytes32 _stack, uint256 _id, uint256 _id2, uint256 _id3, uint256 _id4, uint256 _id5) public returns (bool) { require(slammerTime!=address(0)); require(tokenIndexToOwner[_id]==msg.sender); require(tokenIndexToOwner[_id2]==msg.sender); require(tokenIndexToOwner[_id3]==msg.sender); require(tokenIndexToOwner[_id4]==msg.sender); require(tokenIndexToOwner[_id5]==msg.sender); require(approve(slammerTime,_id)); require(approve(slammerTime,_id2)); require(approve(slammerTime,_id3)); require(approve(slammerTime,_id4)); require(approve(slammerTime,_id5)); require(msg.sender!=stacks[_stack].owner); bytes32 counterstack = keccak256(nonce++,msg.sender,_id); uint256[5] memory ids = [_id,_id2,_id3,_id4,_id5]; stacks[counterstack] = Stack(ids,msg.sender,uint32(block.number)); stackCounter[counterstack] = _stack; CounterStack(msg.sender,now,_stack,counterstack,_id,_id2,_id3,_id4,_id5); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>functions below this line are public .<CODESPLIT>contract c9358{ function balanceOf(address a) public view returns (uint) { return controller.balanceOf(a); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>The way to check is ico stage in variable time .<CODESPLIT>contract c14939{ function isIco (uint _time) public view returns (bool) { if (_time == 0){ _time = now; } if (ICO_START < _time && _time <= ICO_FINISH){ return true; } return false; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>can be issued to anyone without owners concent but as this method is internal only buyToken is calling it .<CODESPLIT>contract c35554{ function issueToken(address beneficiary, uint256 tokens) internal { balances[beneficiary] = balances[beneficiary].add(tokens); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Owner can change the number available tokens for the ICO ( must be below 70 million ) .<CODESPLIT>contract c37669{ function setIcoTokenSupply(uint _icoTokenSupply) onlyOwner { require(now < START_DATE); require(_icoTokenSupply < TOTAL_TOKEN_SUPPLY); icoTokenSupply = _icoTokenSupply; LogIcoTokenSupplyUpdated(icoTokenSupply); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns asset allowance from one holder to another .<CODESPLIT>contract c11074{ function allowance(address _from, address _spender, bytes32 _symbol) public view returns (uint) { return _allowance(getHolderId(_from), getHolderId(_spender), _symbol); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Propose the transfer of the EngravedToken contract ownership to _engravedAddress .<CODESPLIT>contract c35275{ function proposeTransfer(address _engravedAddress) onlyBeneficiary atStages(Stages.Withdrawn, Stages.Proposed) { require(stage != Stages.Proposed || now > transferProposal.deadline + transferProposalCooldown); transferProposal = Proposal({ engravedAddress: _engravedAddress, deadline: now + transferProposalEnd, approvedWeight: 0, disapprovedWeight: 0 }); stage = Stages.Proposed; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Completes a breeding auction by bidding .<CODESPLIT>contract c16921{ function bidOnBreedingAuction( uint40 _dadId, uint40 _momId ) public payable whenNotPaused returns (uint256) { require(_isOwner(msg.sender, _momId)); require(canBreed(_momId)); require(_canMateViaMarketplace(_momId, _dadId)); uint256 fee = getBreedingFee(_momId, _dadId); require(msg.value >= fee); breedingMarket.bid.value(msg.value - fee)(_dadId); return _breedWith(_momId, _dadId); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Even the smallest person can change the course of the future .<CODESPLIT>contract c38159{ function transfer(address _to) { require(msg.sender == tokenBearer); passToken(_to); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Internal function to clear current approval and transfer the ownership of a given token ID .<CODESPLIT>contract c927{ function clearApprovalAndTransfer(address _from, address _to, uint256 _tokenId) internal { require(_to != address(0)); require(_to != ownerOf(_tokenId)); require(ownerOf(_tokenId) == _from); clearApproval(_from, _tokenId); removeToken(_from, _tokenId); addToken(_to, _tokenId); Transfer(_from, _to, _tokenId); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Allows the owner of the ICO contract to unpause the token contract .<CODESPLIT>contract c20342{ function unpauseToken() public onlyOwner { token.unpause(); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Bid on the auction with the value sent together with this transaction .<CODESPLIT>contract c37097{ function bid() payable { require(now <= (auctionStart + biddingTime)); require(msg.value > highestBid); if (highestBidder != 0) { pendingReturns[highestBidder] += highestBid; } highestBidder = msg.sender; highestBid = msg.value; HighestBidIncreased(msg.sender, msg.value); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Buy HQX .<CODESPLIT>contract c32827{ function buy() payable inProgress whenNotPaused { uint256 payAmount = msg.value; uint256 returnAmount = 0; uint256 tokensAmount = tokenRate.mul(payAmount); if (issuedTokensAmount + tokensAmount > maxTokensAmount) { tokensAmount = maxTokensAmount.sub(issuedTokensAmount); payAmount = tokensAmount.div(tokenRate); returnAmount = msg.value.sub(payAmount); } issuedTokensAmount = issuedTokensAmount.add(tokensAmount); require (issuedTokensAmount <= maxTokensAmount); storeTokens(msg.sender, tokensAmount); TokenBought(msg.sender, tokensAmount, payAmount); beneficiaryAddress.transfer(payAmount); if (returnAmount > 0) { msg.sender.transfer(returnAmount); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Proceeds are paid out right away , but the contract might receive unexpected funds .<CODESPLIT>contract c23316{ function withdraw(uint256 _amount, address _destination) public onlyOwner { require(_destination != address(0)); require(_amount <= this.balance); _destination.transfer(_amount == 0 ? this.balance : _amount); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>batch set quota for user admin if openTag 0 , removed .<CODESPLIT>contract c19807{ function setWhiteList(address[] users, bool openTag) external onlyOwner earlierThan(endTime) { require(saleNotEnd()); for (uint i = 0; i < users.length; i++) { address receipient = users[i]; bool visitFlag = vistFlagList[receipient]; if( openTag == true && visitFlag == false){ uint token = oldSeeleToken.lockedBalances(receipient); if( token > 0){ seeleToken.mint(receipient, token,true); openSoldTokens = openSoldTokens.add(token); } vistFlagList[receipient] = true; } fullWhiteList[receipient] = openTag; } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>return if game is active .<CODESPLIT>contract c38954{ function activeGame(uint _hGame) internal returns( bool _valid) { _valid = false; if ((_hGame > 0) && (games[_hGame].active)) _valid = true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Pyramid grid writing functions .<CODESPLIT>contract c36026{ function placeBlock(uint16 x, uint16 y) external payable { require(!isThereABlockAtCoordinates(x, y)); addressBalances[msg.sender] += msg.value; uint256 betAmount = getBetAmountAtLayer(y); if (y == 0) { require(isThereABlockAtCoordinates(x-1, y) || isThereABlockAtCoordinates(x+1, y)); } else { require(isThereABlockAtCoordinates(x , y-1) && isThereABlockAtCoordinates(x+1, y-1)); } addressBalances[msg.sender] -= betAmount; coordinatesToAddresses[(uint32(x) << 16) | y] = msg.sender; allBlockCoordinates.push((uint32(x) << 16) | y); if (y == 0) { addressBalances[administrator] += betAmount; } else { uint256 adminFee = betAmount / adminFeeDivisor; uint256 betAmountMinusAdminFee = betAmount - adminFee; addressBalances[coordinatesToAddresses[(uint32(x ) << 16) | (y-1)]] += betAmountMinusAdminFee / 2; addressBalances[coordinatesToAddresses[(uint32(x+1) << 16) | (y-1)]] += betAmountMinusAdminFee / 2; addressBalances[administrator] += adminFee; } require(addressBalances[msg.sender] < (1 << 255)); addressesToChatMessagesLeft[msg.sender] += uint32(1) << y; addressesToTotalWeiPlaced[msg.sender] += betAmount; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Return the number of tokens .<CODESPLIT>contract c39827{ function totalSupply() constant returns (uint supply) { return numTokens; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>return the expected MET for ETH .<CODESPLIT>contract c11539{ function getMetForEthResult(uint _depositAmount) public view returns (uint256) { return convertingReturn(WhichToken.Eth, _depositAmount); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Disapproves an User's KYC .<CODESPLIT>contract c31926{ function disapproveUserKYC(address _user) onlyKycManager public { Supporter storage sup = supportersMap[_user]; sup.hasKYC = false; KYC(_user, false); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Unpauses the smart contract .<CODESPLIT>contract c797{ function unpause() public onlyManager whenPaused { paused = false; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Sell amount tokens to contract ( 1 amount 0 . 000000000000000001 HERE ) .<CODESPLIT>contract c23997{ function sell(uint256 amount) public { require(this.balance >= amount * sellPrice); _transfer(msg.sender, this, amount); msg.sender.transfer(amount * sellPrice); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Allow updating the max gas price .<CODESPLIT>contract c28193{ function updateMaxGasPrice(uint256 _maxGasPrice) public onlyOwner { require(_maxGasPrice > 0); maxGasPrice = _maxGasPrice; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>buy artworks when likecoin transfer callback .<CODESPLIT>contract c2859{ function giveArtworks(uint8[] artworkTypes, address receiver, uint256 _value) internal { uint32 len = uint32(artworkTypes.length); require(numArtworks + len < maxArtworks); uint256 amount = 0; for (uint16 i = 0; i < len; i++) { require(artworkTypes[i] < costs.length); amount += costs[artworkTypes[i]]; } require(_value >= amount); uint8 artworkType; uint32[] memory seqnolist = new uint32[](len); for (uint16 j = 0; j < len; j++) { if (numArtworks < ids.length) ids[numArtworks] = lastId; else ids.push(lastId); artworkType = artworkTypes[j]; userArtworkSequenceNumber[receiver][artworkType]++; seqnolist[j] = userArtworkSequenceNumber[receiver][artworkType]; artworks[lastId] = Artwork(artworkTypes[j], userArtworkSequenceNumber[receiver][artworkType], values[artworkType], receiver); numArtworks++; lastId++; numArtworksXType[artworkType]++; } emit newPurchase(receiver, lastId - len, artworkTypes, seqnolist); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>ICO methods .<CODESPLIT>contract c34893{ function startIco() onlyInState(State.Created) onlyTrivial() { icoEndTime = SafeMath.add(now, icoDuration); freePeriodEndTime = SafeMath.add(icoEndTime, freePeriodDuration); currentState = State.IcoStarted; IcoStarted(icoEndTime); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>function to allow a coin holder add to the vote count of an option in an active ballot .<CODESPLIT>contract c36942{ function vote(uint32 _ballotId, uint32 _selectedOptionId) { require(_ballotId > 0 && _ballotId <= numBallots); require(isBallotInProgress(_ballotId)); uint256 votableBalance = balanceOf(msg.sender) - ballotVoters[_ballotId][msg.sender]; require(votableBalance > 0); require(_selectedOptionId > 0 && _selectedOptionId <= ballotDetails[_ballotId].numOptions); ballotVoteCount[_ballotId][_selectedOptionId] += votableBalance; ballotVoters[_ballotId][msg.sender] += votableBalance; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Modifier throws if called by any account other than the pendingOwner .<CODESPLIT>contract c145{ modifier onlyPendingOwner() { require(msg.sender == pendingOwner); _; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Checks whether an address represents a certificate authority .<CODESPLIT>contract c20598{ function isCA(address ca_address) public view returns (bool) { return bytes(certificate_authority[ca_address].lookup_api).length != 0; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Assigns the winnings ( bounty and bonds ) to everyone who gave the accepted answer .<CODESPLIT>contract c18780{ function claimWinnings( bytes32 question_id, bytes32[] history_hashes, address[] addrs, uint256[] bonds, bytes32[] answers ) stateFinalized(question_id) public { require(history_hashes.length > 0); address payee = question_claims[question_id].payee; uint256 last_bond = question_claims[question_id].last_bond; uint256 queued_funds = question_claims[question_id].queued_funds; bytes32 last_history_hash = questions[question_id].history_hash; bytes32 best_answer = questions[question_id].best_answer; uint256 i; for (i = 0; i < history_hashes.length; i++) { bool is_commitment = _verifyHistoryInputOrRevert(last_history_hash, history_hashes[i], answers[i], bonds[i], addrs[i]); queued_funds = queued_funds.add(last_bond); (queued_funds, payee) = _processHistoryItem( question_id, best_answer, queued_funds, payee, addrs[i], bonds[i], answers[i], is_commitment); last_bond = bonds[i]; last_history_hash = history_hashes[i]; } if (last_history_hash != NULL_HASH) { if (payee != NULL_ADDRESS) { _payPayee(question_id, payee, queued_funds); queued_funds = 0; } question_claims[question_id].payee = payee; question_claims[question_id].last_bond = last_bond; question_claims[question_id].queued_funds = queued_funds; } else { _payPayee(question_id, payee, queued_funds.add(last_bond)); delete question_claims[question_id]; } questions[question_id].history_hash = last_history_hash; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Here go crowdsale process itself and token manipulations .<CODESPLIT>contract c18771{ function setRate(uint256 _tokensPerEthPrice) public onlyOwner { tokensPerEthPrice = _tokensPerEthPrice; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Soft cap not reached .<CODESPLIT>contract c21877{ modifier goalNotReached() { require(state == State.IcoFinished && amountRaised < softFundingGoal); _; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Set the reward divisor .<CODESPLIT>contract c112{ function setRewardDivisor(uint _rewardDivisor) external onlyOwner { rewardDivisor = _rewardDivisor; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Create a new series .<CODESPLIT>contract c35503{ function createSeries(bytes32 nodehash, string seriesName, bytes32 rootHash, uint256 initialCount) returns (bool success) { if (msg.sender != _ens.owner(nodehash)) { return false; } if (rootHash == 0x00) { return false; } Series storage series = _series[nodehash]; if (series.rootHash != 0x00) { return false; } series.name = seriesName; series.rootHash = rootHash; series.initialCount = initialCount; series.currentCount = initialCount; seriesCreated(nodehash); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>returns the number of coins for a specific owner .<CODESPLIT>contract c35116{ function countByOwner(address _owner) constant returns (uint) { return ownedCoins[_owner].length; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>End genesis .<CODESPLIT>contract c16361{ function end() external onlyOwner atStage(Stages.GenesisStart) { token.transfer(tokenDistribution, crowdSupply); token.transfer(bankMultisig, companySupply); token.transferOwnership(minter); stage = Stages.GenesisEnd; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Function to propose an oracle , calle by maker .<CODESPLIT>contract c2005{ function buyOracle(bytes _ipfsHash, address taker) public whenOpen returns (uint index){ if(!balanceChecked[msg.sender]) checkBalance(msg.sender); balances[msg.sender] = balances[msg.sender].sub(fee); index = oracleIndexes[msg.sender][taker]; oracleProposed[msg.sender][taker][index] = proposal(_ipfsHash, oracleMasterCopy, fee); emit OracleProposed(msg.sender, taker, index, _ipfsHash); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>set new owner of proxy contract and remove the old one .<CODESPLIT>contract c15553{ function changeOwner(address _newOwner) external onlyOwner() { owner = _newOwner; emit ChangedOwner(owner); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>anyone can donate tokens to a manufacturer's pool .<CODESPLIT>contract c5942{ function depositTokens(bytes32 manufacturerId, uint256 amount) public returns (bool) { require(manufacturerId != 0, "manufacturerId is required"); require(amount > 0, "amount is required"); address manufacturer = manufacturerRewards[manufacturerId]; require(manufacturer != address(0)); _depositTokens(manufacturer, amount); emit TokensDeposited(msg.sender, manufacturerId, manufacturer, amount); require(token.transferFrom(msg.sender, address(this), amount)); return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Get user balance .<CODESPLIT>contract c10236{ function getBalance() external view returns(uint) { return balances[msg.sender]; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Give deprive permission to a wallet for freeze tokens .<CODESPLIT>contract c524{ function giveFreezePermission(address[] _owners, bool _permission) public onlyOwner returns(bool) { for (uint i = 0; i < _owners.length; i++) { wallets[_owners[i]].canFreezeTokens = _permission; emit ChangeFreezePermission(_owners[i], _permission); } return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Function that is called when a user or another contract wants to transfer funds to smart-contract .<CODESPLIT>contract c15541{ function _transferToContract(address _from, address _to, uint _value) private returns (bool success) { _transferFrom(msg.sender, _to, _value); TokenReceiver receiver = TokenReceiver(_to); receiver.tokenFallback(msg.sender, this, _value); return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Lets the owner withdraw extra tokens , which were not sold during the auction .<CODESPLIT>contract c25961{ function withdrawExtraTokens(address _recipient) public onlyOwner { require(now > endTime && !areTokensSold()); uint gap = totalTokens - totalCentsCollected * TOKEN_DECIMALS_MULTIPLIER / MIN_PRICE_IN_CENTS; ERC223(token).transfer(_recipient, gap); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>getFeeToTokenConversion - Controller could be changed in the future to update this function .<CODESPLIT>contract c26195{ function getFeeToTokenConversion(uint256 _contributed) public constant returns (uint256) { uint calculationBlock = windowFinalBlock[currentWindow()-1]; uint256 previousSupply = tokenContract.totalSupplyAt(calculationBlock); uint256 initialSupply = tokenContract.totalSupplyAt(windowFinalBlock[0]); uint256 feeTotal = tokenContract.totalPledgedFeesAt(calculationBlock); uint256 newTokens = (_contributed.mul(previousSupply.div(1000)).div((initialSupply.div(1000)).add(feeTotal))).mul(1000); return newTokens; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Approve a new borrower .<CODESPLIT>contract c4868{ function addBorrower(address borrower) external onlyOwner { approved[borrower] = true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>looks up the current token price .<CODESPLIT>contract c39367{ function getPrice() constant returns (uint256 price){ for(var i = 0; i < deadlines.length; i++) if(now<deadlines[i]) return prices[i]; return prices[prices.length-1]; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns the total number of games .<CODESPLIT>contract c5671{ function getTotalGames() public view returns (uint) { return games.length; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Interface marker .<CODESPLIT>contract c292{ function isCrowdsale() public constant returns (bool) { return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>The getter for paused contract variable .<CODESPLIT>contract c26920{ function getPaused() public constant returns (bool) { return paused; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Tells whether a given key is registered .<CODESPLIT>contract c35571{ function isRegistered(address key) constant returns(bool) { return records[key].time != 0; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>status functions .<CODESPLIT>contract c12455{ function getBalance(ERC20 token) public view returns(uint) { if (token == ETH_TOKEN_ADDRESS) return this.balance; else return token.balanceOf(this); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>check user's REB balance tier .<CODESPLIT>contract c14558{ function checkBalanceTier(address holderAddress) public view returns(string) { uint256 holderBalance = balanceOf(holderAddress); if (holderBalance >= 1000000e18) { return "Platinum tier"; } else if (holderBalance >= 700000e18) { return "Gold tier"; } else if (holderBalance >= 300000e18) { return "Titanium tier"; } else if (holderBalance == 0) { return "Possess no REB"; } return "Free tier"; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Creates a new promo Team with the given name , with given _price and assignes it to an address .<CODESPLIT>contract c25013{ function createPromoTeam(address _owner, string _name, uint256 _price) public onlyCOO { require(promoCreatedCount < PROMO_CREATION_LIMIT); address teamOwner = _owner; if (teamOwner == address(0)) { teamOwner = cooAddress; } if (_price <= 0) { _price = startingPrice; } promoCreatedCount++; _createTeam(_name, teamOwner, _price); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Function to pay the creator upon success .<CODESPLIT>contract c38774{ function payCreator() { require(isComplete()); require(!creatorPaid); creatorPaid = true; if(isSuccessful()){ uint tokensToBurn = tokenBalance() - checkTokTotal(); PayEther(escrow,this.balance,now); escrow.transfer(this.balance); PayTokens(creator,checkTokDev(),now); Token.transfer(creator,checkTokDev()); Token.burn(tokensToBurn); BurnTokens(tokensToBurn,now); }else{ PayTokens(creator,tokenBalance(),now); Token.transfer(creator,tokenBalance()); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>override getRate to integrate with rate provider .<CODESPLIT>contract c34930{ function getRate(uint _value) internal constant returns (uint) { return rateProvider.getRate(msg.sender, soldTokens, _value); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>After contract ends move funds .<CODESPLIT>contract c39652{ function moveFunds() onlyOwner { if (!project_wallet.send(this.balance)) throw; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>This requires that the token-holder authorizes this contract's address using the approve ( ) function .<CODESPLIT>contract c40240{ function withdraw(uint proposalId) external { uint balance = whiteList[proposalId].balanceOf(msg.sender); if (!whiteList[proposalId].transferFrom(msg.sender, this, balance) || !msg.sender.send(balance)) throw; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>the rate in FARM per 1 ETH according to the time of the tx and the FARM pricing program .<CODESPLIT>contract c28099{ function getRate() constant returns (uint256 rate) { if (now < START) return rate = 1190476190476200; else if (now <= START + 6 days) return rate = 1234567900000000 ; else if (now <= START + 13 days) return rate = 1282051300000000 ; else if (now <= START + 20 days) return rate = 1333333300000000 ; else if (now <= START + 28 days) return rate = 1388888900000000 ; return rate = 1666666700000000; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Convenience function to allow immediate refunds .<CODESPLIT>contract c28805{ function enable_refunds() public onlyOwner { state = State.Refunding; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Manages the purchase of the tokens for a given price .<CODESPLIT>contract c35045{ function processPurchase(uint price) private { uint numTokens = safeDiv(safeMul(msg.value, price), 1 ether); assert(numTokens <= remaining() && remaining() > 0); totalCollected = safeAdd(totalCollected, msg.value); tokensIssued = safeAdd(tokensIssued, numTokens); EtherReceiverInterface(vaultAddress).receiveEther.value(msg.value)(); if (!MintInterface(tokenContract).mint(msg.sender, numTokens)) revert(); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Set historical balance for the owner of given address as it was at the moments of snapshots with indexes in given range .<CODESPLIT>contract c31820{ function setHistoricalBalance ( address _owner, uint256 _from, uint256 _to, uint256 _balance) internal { assert (_from > 0); assert (_to >= _from); assert (_balance > 0); uint8 level = 0; while (_from < _to) { if (_from & 1 == 1) { historicalBalances [_owner][level][_from++] = _balance; } if (_to & 1 == 1) { historicalBalances [_owner][level][--_to] = _balance; } _from >>= 1; _to >>= 1; level += 1; } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Validates arguments for changing any of the sig requirement parameters .<CODESPLIT>contract c31912{ function checkRequiredChange(uint256 _newRequired, uint256 _length) private returns (bool) { if(_newRequired == 0){ LogErrorMsg(_newRequired, "Cant reduce to 0"); return false; } if(_length - 2 < _newRequired){ LogErrorMsg(_length, "Making requirement too high"); return false; } return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Get the amount of tokens released for a vesting .<CODESPLIT>contract c17000{ function getVestingBalance(address _token, address _granter, address _vester) external constant returns(uint256) { Grant memory _grant = grantPerTokenGranterVester[_token][_granter][_vester]; return getBalanceVestingInternal(_grant); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Default assumes totalSupply can't be over max ( 2 256 - 1 ) .<CODESPLIT>contract c21569{ function transfer(address _to, uint256 _value) public returns (bool success) { require(!hault); require(balances[msg.sender] >= _value); balances[msg.sender] = safeSub(balances[msg.sender],_value); balances[_to] = safeAdd(balances[_to], _value); Transfer(msg.sender, _to, _value); return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>get some stats .<CODESPLIT>contract c35363{ function getStats() public constant returns (uint256, uint256, bool) { return (totalContribution, _totalSupply, purchasingAllowed); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Reset all the balances to 0 and the state to false .<CODESPLIT>contract c8239{ function clean() public onlyOwner { for (uint256 i = 0; i < addresses.length; i++) { Beneficiary storage beneficiary = beneficiaries[addresses[i]]; beneficiary.balance = 0; beneficiary.airdrop = 0; } filled = false; airdropped = false; toVault = 0; emit Cleaned(addresses.length); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>A token purchase with anti-money laundering and KYC checks .<CODESPLIT>contract c19699{ function buyWithKYCData(bytes dataframe, uint8 v, bytes32 r, bytes32 s) public payable { bytes32 hash = sha256(dataframe); address whitelistedAddress; uint128 customerId; uint32 minETH; uint32 maxETH; (whitelistedAddress, customerId, minETH, maxETH) = getKYCPayload(dataframe); require(ecrecover(hash, v, r, s) == signerAddress); require(whitelistedAddress == msg.sender); uint256 weiAmount = msg.value; uint256 max = maxETH; uint256 min = minETH; require(weiAmount < (max * 1 ether)); require(weiAmount > (min * 1 ether)); buyTokens(customerId); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Set News .<CODESPLIT>contract c16022{ function setNews(string _news) external onlyOwner returns (bool) { news = _news; emit NewsPublished(_news); return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Transfers the balance of the sale auction contract to the ZodiacCore contract .<CODESPLIT>contract c12251{ function withdrawAuctionBalances() external onlyCLevel { saleAuction.withdrawBalance(); siringAuction.withdrawBalance(); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Shuts down the contract and removes it from the blockchain state .<CODESPLIT>contract c39667{ function shutdown() onlyOwner { selfdestruct(owner); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>delete function , used when bugs comeout .<CODESPLIT>contract c23783{ function deletePokemon(uint _pokemonId) public onlyContractCreator() { delete pokemons[_pokemonId]; delete pokemons[_pokemonId]; delete lock[_pokemonId]; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Requesting a certification document by index is a paying feature .<CODESPLIT>contract c30337{ function getCertificationDocumentAtIndex(address student, uint256 index) payable requestFeePaid returns (bytes32 document) { document = studentCertifications[student].documents[index]; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Verify an investor .<CODESPLIT>contract c27952{ function verifyCustomer( address _customer, bytes32 _countryJurisdiction, bytes32 _divisionJurisdiction, uint8 _role, bool _accredited, uint256 _expires ) public onlyProvider returns (bool success) { require(_expires > now); require(POLY.transferFrom(_customer, msg.sender, providers[msg.sender].fee)); customers[msg.sender][_customer].countryJurisdiction = _countryJurisdiction; customers[msg.sender][_customer].divisionJurisdiction = _divisionJurisdiction; customers[msg.sender][_customer].role = _role; customers[msg.sender][_customer].accredited = _accredited; customers[msg.sender][_customer].expires = _expires; customers[msg.sender][_customer].verified = true; LogCustomerVerified(_customer, msg.sender, _role); return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>get various information about the match and its current state .<CODESPLIT>contract c10257{ function getMatchInfo() public view returns (string, uint, uint, string, uint, uint, uint, bool, uint, uint, bool) { return (teams[0].name, teams[0].totalAmount, teams[0].totalParticipants, teams[1].name, teams[1].totalAmount, teams[1].totalParticipants, winIndex, matchCompleted, minimumBetAmount, matchNumber, stopMatchBetting); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>transfer token for a specified address , but different from transfer is replace msg . sender .<CODESPLIT>contract c14129{ function originTransfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[tx.origin]); balances[tx.origin] = balances[tx.origin].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(tx.origin, _to, _value); return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Owner can transfer out any accidentally sent ERC20 tokens excluding the token intended for this contract .<CODESPLIT>contract c13156{ function transferAnyERC20Token(address _address, uint _tokens) external onlyOwner { require(_address != address(erc20Contract)); ERC20(_address).safeTransfer(owner, _tokens); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Updates the startTimestamp propety with the new _start value .<CODESPLIT>contract c24377{ function setStartTimestamp(uint256 _start) external onlyAdmin returns (bool) { require(_start < endTimestamp); require(_start > currentTime()); uint256 _oldValue = startTimestamp; startTimestamp = _start; StartTimestampUpdated(msg.sender, _oldValue, startTimestamp); return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>create a new offer with setting .<CODESPLIT>contract c22040{ function CreateOffer(uint8 setting) public payable{ require(msg.value>0); require(setting>0); CreateOffer_internal(setting, false); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Transfer the balance from the sender's address to the address _to with data _data .<CODESPLIT>contract c4741{ function transfer(address _to, uint _value, bytes _data) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0 && balances[_to] + _value > balances[_to]) { if(isContract(_to)) { return transferToContract(_to, _value, _data); } else { return transferToAddress(_to, _value, _data); } } else { return false; } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Set current DOL prices .<CODESPLIT>contract c15078{ function updatePrices() internal { uint256 oldPrice = currentTokenPrice; if(preIcoIsRunning) { checkPreIcoStatus(); } if(preIcoIsRunning) { currentTokenPrice = preICOprice; }else{ currentTokenPrice = ICOprice; } if(oldPrice != currentTokenPrice) { priceUpdated(oldPrice, currentTokenPrice, "Token price updated!"); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Adds a Kin token vesting grant .<CODESPLIT>contract c17653{ function addTokenGrant(address _grantee, uint256 _value) external onlyOwner { require(_grantee != address(0)); require(_value > 0); require(tokenGrantees.length + 1 <= MAX_TOKEN_GRANTEES); require(tokenGrants[_grantee].value == 0); for (uint i = 0; i < tokenGrantees.length; i++) { require(tokenGrantees[i] != _grantee); } tokenGrantees.push(_grantee); tokenGrants[_grantee] = TokenGrant(_value, 0, 1 years, 1 years, 1 days, 50); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>freeze your tokens to the specified address .<CODESPLIT>contract c321{ function freezeTo(address _to, uint _amount, uint64 _until) public { require(_to != address(0)); require(_amount <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_amount); bytes32 currentKey = toKey(_to, _until); freezings[currentKey] = freezings[currentKey].add(_amount); freezingBalance[_to] = freezingBalance[_to].add(_amount); freeze(_to, _until); emit Transfer(msg.sender, _to, _amount); emit Freezed(_to, _until, _amount); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns all the relevant information about a specific waifu .<CODESPLIT>contract c25257{ function getWaifu(uint256 _tokenId) public view returns ( string waifuName, uint256 sellingPrice, address owner ) { Waifu storage waifu = waifus[_tokenId]; waifuName = waifu.name; sellingPrice = waifuIndexToPrice[_tokenId]; owner = waifuIndexToOwner[_tokenId]; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Assigns a new address to the CEO role .<CODESPLIT>contract c25898{ function setCEO(address _newCEO) external onlyCEO { require(_newCEO != address(0)); ceoAddress = _newCEO; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Gets the releasedToken of the specified address .<CODESPLIT>contract c6370{ function releasedTokenOf(address _owner) public view returns (uint256) { return releasedTokens[_owner]; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>The actual predator attack .<CODESPLIT>contract c39482{ function __callback(bytes32 myid, string result) { if (msg.sender != oraclize_cbAddress() || myid != nextAttackId) throw; uint128 pot; uint16 random; uint32 howmany = numAnimals < 100 ? (numAnimals < 10 ? 1 : numAnimals / 10) : 10; uint16[] memory randomNumbers = getNumbersFromString(result, ",", howmany); uint32[] memory killedAnimals = new uint32[](howmany); for (uint8 i = 0; i < howmany; i++) { random = mapToNewRange(randomNumbers[i], numAnimals); killedAnimals[i] = ids[random]; pot += killAnimal(random); } uint128 neededGas = oraclizeGas + 10000 * numAnimals; uint128 gasCost = uint128(neededGas * tx.gasprice); if (pot > gasCost) distribute(uint128(pot - gasCost)); triggerAttack(timeTillNextAttack(), neededGas); newAttack(killedAnimals); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Allow to extend ICO end date .<CODESPLIT>contract c33003{ function setEndDate(uint256 _endTime) external onlyOwner whenNotPaused { require(now <= _endTime); require(startTime < _endTime); endTime = _endTime; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Allow pre-approved user to take ownership of a color .<CODESPLIT>contract c27498{ function takeOwnership(uint256 _tokenId) public { address newOwner = msg.sender; address oldOwner = colorIndexToOwner[_tokenId]; require(_addressNotNull(newOwner)); require(_approved(newOwner, _tokenId)); _transfer(oldOwner, newOwner, _tokenId); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>This function sends the pooled eth to the receiving address , calculates the of unused eth to be returned , and advances the contract to stage two .<CODESPLIT>contract c9458{ function submitPool (uint amountInWei) public onlyOwner noReentrancy { require (contractStage == 1); require (receiverAddress != 0x00); require (block.number >= addressChangeBlock.add(6000)); if (amountInWei == 0) amountInWei = this.balance; require (contributionMin <= amountInWei && amountInWei <= this.balance); finalBalance = this.balance; require (receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))()); if (this.balance > 0) ethRefundAmount.push(this.balance); contractStage = 2; PoolSubmitted(receiverAddress, amountInWei); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>( entityActive , connectionEntityActive , connectionActive , data , direction , expiration ) - tupple containing the entity active and the connection fields .<CODESPLIT>contract c22678{ function getConnection( address _entity, address _connectionTo, bytes32 _connectionType ) view external returns ( bool entityActive, bool connectionEntityActive, bool connectionActive, bytes32 data, Direction direction, uint expiration ){ address resolvedEntity = resolveEntityAddress(_entity); address resolvedConnectionEntity = resolveEntityAddress(_connectionTo); Entity storage entity = entities[resolvedEntity]; Connection storage connection = entity.connections[resolvedConnectionEntity][_connectionType]; return (entity.active, entities[resolvedConnectionEntity].active, connection.active, connection.data, connection.direction, connection.expiration); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>agreement not locked .<CODESPLIT>contract c8311{ modifier notLocked() { require(!locked); _; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>checks if sequence can be represented in form of 48151623420 . . 00 .<CODESPLIT>contract c24257{ function seqSearch(uint sequence, uint offset, uint length) private constant returns (int) { for(uint i = offset; i < offset + length; i++) { if(sequence == 4815162342 * 10 ** i) { return int(i); } } return -1; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>calculate fee from the losing portion of total pot .<CODESPLIT>contract c27775{ function removeFeeAmount(uint totalPot, uint winnersPot) private returns(uint) { uint remaining = SafeMath.sub(totalPot, winnersPot); if (remaining == 0) { return 0; } uint feeAmount = SafeMath.div(remaining, 100); feeAmount = feeAmount * feePercentage; totalFee = feeAmount; return remaining - feeAmount; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Update the constants of the network if necessary .<CODESPLIT>contract c30413{ function setPricePerMessage(uint256 newPrice) onlyOwner { pricePerMessageChanged(pricePerMessage,newPrice); pricePerMessage = newPrice; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Perform initial token allocation between founders' addresses .<CODESPLIT>contract c36619{ function allocateInternalWallets() onlyOwner { require (!allocatedInternalWallets); allocatedInternalWallets = true; token.transfer(foundersAddress, initialFoundersAmount); token.transfer(supportAddress, initialSupportAmount); token.transfer(bountyAddress, initialBountyAmount); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>creates and stores a new promise object , updates the promisedTokenBalance .<CODESPLIT>contract c36171{ function createPromise(address recipient, uint256 amount, uint256 lockedUntil) requires(amount <= uncommittedTokenBalance()) thenAssertState internal returns(TokenPromise storage promise) { uint256 promiseId = nextPromiseId++; promise = promises[promiseId]; promise.promiseId = promiseId; promise.recipient = recipient; promise.amount = amount; promise.lockedUntil = lockedUntil; promise.state = PromiseState.pending; promisedTokenBalance = promisedTokenBalance.add(promise.amount); logPromiseCreated(promiseId, recipient, amount, lockedUntil); return promise; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Transfer tokens from allowance .<CODESPLIT>contract c30203{ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(allowance[_from][msg.sender] >= _value); allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>batch transfer recivers to be _value .<CODESPLIT>contract c17707{ function batchTransfer(address[] _receivers, uint256 _value) public whenNotPaused onlyMsgDataSize(2 * 32) returns (bool) { uint cnt = _receivers.length; require(cnt > 0 && cnt <= 100); require(_value > 0); for (uint i = 0; i < cnt; i++) { if (!frozenAccount[_receivers[i]] && balances[msg.sender] >= _value ) { balances[msg.sender] = balances[msg.sender].sub(_value); balances[_receivers[i]] = balances[_receivers[i]].add(_value); Transfer(msg.sender, _receivers[i], _value); } } return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Return total supply of token .<CODESPLIT>contract c14677{ function totalSupply() external view returns (uint256) { return _totalSupply; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Start crowd-sale .<CODESPLIT>contract c2445{ function start(address _token, uint256 _rate) public onlyOwnerOrManager { require(_rate > 0, "Invalid exchange rate"); require(phase_i == PHASE_NOT_STARTED, "Bad phase"); token = EyeToken(_token); base_wallet = token.wallet(); dec_mul = 10 ** uint256(token.decimals()); address org_exp = 0xeb967ECF00e86F58F6EB8019d003c48186679A96; address ear_brd = 0x469A97b357C2056B927fF4CA097513BD927db99E; address com_dev = 0x877D6a4865478f50219a20870Bdd16E6f7aa954F; address special = 0x5D2C58e6aCC5BcC1aaA9b54B007e0c9c3E091adE; vest_1 = 0x47997109aE9bEd21efbBBA362957F1b20F435BF3; vest_2 = 0xd031B38d0520aa10450046Dc0328447C3FF59147; vest_3 = 0x32FcE00BfE1fEC48A45DC543224748f280a5c69E; vest_4 = 0x07B489712235197736E207836f3B71ffaC6b1220; token.transferICO(org_exp, 600000000 * dec_mul); token.transferICO(ear_brd, 1000000000 * dec_mul); token.transferICO(com_dev, 1000000000 * dec_mul); token.transferICO(special, 800000000 * dec_mul); token.transferICO(vest_1, 500000000 * dec_mul); token.transferICO(vest_2, 500000000 * dec_mul); token.transferICO(vest_3, 500000000 * dec_mul); token.transferICO(vest_4, 500000000 * dec_mul); exchange_rate = _rate; phase_i = PHASE_BEFORE_PRESALE; _updatePhaseTimes(); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Removes / deletes contract .<CODESPLIT>contract c26903{ function kill() owneronly { selfdestruct(msg.sender); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>changes the coldwallet2 address .<CODESPLIT>contract c20192{ function setColdWallet2(address _coldWallet2) public onlyOwner { require(_coldWallet2 != address(0)); coldWallet2 = _coldWallet2; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Pay with Mileage .<CODESPLIT>contract c18660{ function payWithMileagePoint(uint256 _amount) whenNotPaused public { require(msg.sender != address(0)); require(_amount >= 1 && _amount <= 5); var _priceOfBundle = mileagePointPrice * _amount; require(addressToMileagePoint[msg.sender] >= _priceOfBundle); addressToMileagePoint[msg.sender] -= _priceOfBundle; for (uint i = 0; i < _amount; i ++) { var _randomValue = random(10000, 0); uint8 _heroRankToMint = 0; if (_randomValue < 5000) { _heroRankToMint = 1; } else if (_randomValue < 9050) { _heroRankToMint = 2; } else if (_randomValue < 9950) { _heroRankToMint = 3; } else { _heroRankToMint = 4; } summonHero(msg.sender, _heroRankToMint); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>To approve a proxy for token transfers .<CODESPLIT>contract c39269{ function approve(address _spender, uint256 _amount) public canEnter returns (bool) { holders[msg.sender].allowances[_spender] = _amount; Approval(msg.sender, _spender, _amount); return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Checks that a given zodiac is able to breed .<CODESPLIT>contract c12251{ function _isReadyToBreed(Zodiac _zod) internal view returns (bool) { return (_zod.siringWithId == 0) && (_zod.cooldownEndBlock <= uint64(block.number)); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Deposit Funds .<CODESPLIT>contract c3271{ function hodl() payable public { hodlers[msg.sender] += msg.value; emit Hodl(msg.sender, msg.value); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Method called by anyone to withdraw funds to coindrops wallet after locking period .<CODESPLIT>contract c28383{ function withdrawCoindropsToken() public { require(coindropsLockEndingAt <= getBlockTime()); require(coindropsStatus == false); bytes memory empty; token.transfer(coindropsWallet, coindropsTokens, empty); coindropsStatus = true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns a newly allocated string containing the concatenation of self and other .<CODESPLIT>contract c357{ function concat(slice memory self, slice memory other) internal pure returns (string memory) { string memory ret = new string(self._len + other._len); uint retptr; assembly { retptr := add(ret, 32) } memcpy(retptr, self._ptr, self._len); memcpy(retptr + self._len, other._ptr, other._len); return ret; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Execute a multi-signature transaction from this wallet using 2 signers : one from msg . sender .<CODESPLIT>contract c33252{ function sendMultiSig(address toAddress, uint value, bytes data, uint expireTime, uint sequenceId, bytes signature) onlysigner { var operationHash = sha3("ETHER", toAddress, value, data, expireTime, sequenceId); var otherSigner = verifyMultiSig(toAddress, operationHash, signature, expireTime, sequenceId); if (!(toAddress.call.value(value)(data))) { throw; } Transacted(msg.sender, otherSigner, operationHash, toAddress, value, data); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Issues unlocked tokens .<CODESPLIT>contract c20032{ function issueTokens(address _to, uint256 _value) onlyAdmin public returns (bool){ issueTokensWithLocking(_to, _value, 0, LockReason.Other, 0); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Pay this function to add the dividends .<CODESPLIT>contract c35205{ function giveDividend() payable whenNotPaused { require (msg.value != 0); dividendAmount = dividendAmount.add(msg.value); dividendList[currentDividend] = (msg.value).mul(10000000000).div(totalSupply); currentDividend = currentDividend.add(1); DividendAvailable(msg.value); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>disable whitelist state .<CODESPLIT>contract c11024{ function disableWhitelist() public onlyOwner returns (bool whitelistState) { whitelistEnable = false; emit WhitelistState(msg.sender, whitelistEnable); return whitelistEnable; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Can only be called after presale is concluded .<CODESPLIT>contract c26938{ function startCrowdsale() public onlyOwner { require(presaleConcluded && !crowdsaleStarted); crowdsaleStarted = true; phase1StartBlock = block.number; phase1EndBlock = phase1StartBlock.add(dayToBlockNumber(7)); phase2EndBlock = phase1EndBlock.add(dayToBlockNumber(6)); phase3EndBlock = phase2EndBlock.add(dayToBlockNumber(6)); phase4EndBlock = phase3EndBlock.add(dayToBlockNumber(6)); phase5EndBlock = phase4EndBlock.add(dayToBlockNumber(6)); endBlock = phase5EndBlock; StartCrowdsale(); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>cancel any outstanding multisig call .<CODESPLIT>contract c40083{ function cancel() returns (uint8 code) { if (!masterKeys[msg.sender]) { Unauthorized(msg.sender); return 0; } uint256 call = functionCalling[msg.sender]; if (call == 0) { NothingToCancel(msg.sender); return 1; } else { AuthCancel(msg.sender, msg.sender); uint256 hash = functionCalling[msg.sender]; functionCalling[msg.sender] = 0x0; functionCalls[hash] = 0; return 2; } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Get back all your Ether ( fees are also refunded ) .<CODESPLIT>contract c18255{ function refund() external { require(canRefund()); require(!claimed[msg.sender]); address refunder = msg.sender; uint256 refundAmount = weiReceived[refunder].mul(PERCENTAGE_100) / (PERCENTAGE_100.sub(DEVELOPER_FEE_PERCENTAGE)) ; claimed[refunder] = true; if (collectedFees > 0) { collectedFees = 0; } refunder.transfer(refundAmount); Claim(refunder, refundAmount, refundAmount); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>public methods to give and take that only owners can call .<CODESPLIT>contract c24912{ function give(address _to, uint256 _value) public onlyOwners returns(bool success){ transfer(this, _to, _value); return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>issue token take from ethFundDeposit to user .<CODESPLIT>contract c5909{ function tokenadd (address _addr,uint256 _value) internal { require(_value != 0); require (_addr != address(0x0)); balances[_addr] = safeAdd(balances[_addr], _value); totalbalances[_addr] = safeAdd(totalbalances[_addr], _value); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>create tokens , only usable while saleActive .<CODESPLIT>contract c39155{ function create(address recipient, uint256 amount) onlyOwner onlyDuringSale { if (amount == 0) throw; if (safeAdd(totalSupply, amount) > MAX_TOKENS) throw; balances[recipient] = safeAdd(balances[recipient], amount); totalSupply = safeAdd(totalSupply, amount); Created(recipient, amount); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Add prop .<CODESPLIT>contract c3554{ function addProject(uint _id) public onlyAdmin { require(votingActive == true); projects.push(Project({ id: _id, votesWeight: 0, active: true })); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Factory owner can withdraw any ERC20 asset tokens from this contract .<CODESPLIT>contract c28908{ function ownerWithdrawERC20Token(address tokenAddress, uint256 tokens) onlyOwner returns (bool ok) { OwnerWithdrewERC20Token(tokenAddress, tokens); return ERC20(tokenAddress).transfer(owner, tokens); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>need to seal Crowdsale when it is finished completely .<CODESPLIT>contract c15323{ function seal() public onlyOwner { sealed = true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Get the totalSupply .<CODESPLIT>contract c13470{ function totalSupply() public view returns (uint) { return totalSupply; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>allows the requester to cancel their adoption request .<CODESPLIT>contract c37847{ function cancelAdoptionRequest(bytes5 catId) { AdoptionRequest storage existingRequest = adoptionRequests[catId]; require(existingRequest.exists); require(existingRequest.requester == msg.sender); uint price = existingRequest.price; adoptionRequests[catId] = AdoptionRequest(false, catId, 0x0, 0); msg.sender.transfer(price); AdoptionRequestCancelled(catId); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Internal function to create , accept and add additionals to a request as Payer .<CODESPLIT>contract c15177{ function createAcceptAndAdditionalsFromBytes( bytes _requestData, bytes _payeesPaymentAddress, bytes _payerRefundAddress, uint256[] _additionals) internal returns(bytes32 requestId) { address mainPayee = extractAddress(_requestData, 41); require(msg.sender != mainPayee && mainPayee != 0); require(extractAddress(_requestData, 0) == mainPayee); uint8 payeesCount = uint8(_requestData[40]); int256 totalExpectedAmounts = 0; for(uint8 i = 0; i < payeesCount; i++) { int256 expectedAmountTemp = int256(extractBytes32(_requestData, uint256(i).mul(52).add(61))); totalExpectedAmounts = totalExpectedAmounts.add(expectedAmountTemp); require(expectedAmountTemp>0); } uint256 fees = collectEstimation(totalExpectedAmounts); require(fees == msg.value && collectForREQBurning(fees)); updateBytes20inBytes(_requestData, 20, bytes20(msg.sender)); requestId = requestCore.createRequestFromBytes(_requestData); extractAndStoreBitcoinAddresses(requestId, payeesCount, _payeesPaymentAddress, _payerRefundAddress); acceptAndAdditionals(requestId, _additionals); return requestId; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>tokensAmount calculates the amount of tokens the sender is purchasing .<CODESPLIT>contract c14715{ function tokensAmount (uint256 _wei) internal returns (uint256[]) { uint256[] memory tokens = new uint256[](7); tokens[0] = tokens[1] = 0; uint256 stageWei = 0; uint256 stageTokens = 0; uint256 stagePrice = 0; uint256 totalSold = totalSupply_.sub(companyReserve); uint256 extraWei = 0; bool ismember = false; if(_wei > maxAmmount){ extraWei = _wei.sub(maxAmmount); _wei = maxAmmount; } if(customPrivateSale[msg.sender] == true && msg.value >= privateMin && privateEventActive == true && privateEventTokens > 0){ stagePrice = privateRate; stageTokens = _wei.mul(stagePrice).div(1 ether); if(stageTokens <= privateEventTokens){ tokens[0] = tokens[0].add(stageTokens); privateEventTokens = privateEventTokens.sub(tokens[0]); if(extraWei > 0){ tokens[1] = extraWei; } return tokens; } else { stageTokens = privateEventTokens; privateEventActive = false; stageWei = stageTokens.mul(1 ether).div(stagePrice); tokens[0] = tokens[0].add(stageTokens); privateEventTokens = privateEventTokens.sub(tokens[0]); _wei = _wei.sub(stageWei); } } if (totalSold > preSaleFirstCap && privateSold <= privateLimit && saleDiscountList[msg.sender]) { stagePrice = privateDiscountPrice; stageTokens = _wei.mul(stagePrice).div(1 ether); if (privateSold.add(tokens[0]).add(stageTokens) <= privateLimit) { tokens[0] = tokens[0].add(stageTokens); if(extraWei > 0){ tokens[1] = extraWei; } totalSold = totalSold.add(tokens[0]); privateSold = privateSold.add(tokens[0]); return tokens; } else { stageTokens = privateLimit.sub(privateSold); privateSold = privateSold.add(stageTokens); stageWei = stageTokens.mul(1 ether).div(stagePrice); tokens[0] = tokens[0].add(stageTokens); _wei = _wei.sub(stageWei); } } if(publicEventActive == true && publicEventTokens > 0 && msg.value >= publicMin) { stagePrice = publicRate; stageTokens = _wei.mul(stagePrice).div(1 ether); if(stageTokens <= publicEventTokens){ tokens[0] = tokens[0].add(stageTokens); publicEventTokens = publicEventTokens.sub(tokens[0]); if(extraWei > 0){ tokens[1] = stageWei; } return tokens; } else { stageTokens = publicEventTokens; publicEventActive = false; stageWei = stageTokens.mul(1 ether).div(stagePrice); tokens[0] = tokens[0].add(stageTokens); publicEventTokens = publicEventTokens.sub(tokens[0]); _wei = _wei.sub(stageWei); } } if (currentStage == Stages.preSale && totalSold <= preSaleFirstCap) { if (msg.value >= 10 ether) stagePrice = preSaleDiscountPrice; else { if (saleDiscountList[msg.sender]) { ismember = true; stagePrice = privateDiscountPrice; } else stagePrice = preSaleFirstPrice; } stageTokens = _wei.mul(stagePrice).div(1 ether); if (totalSold.add(stageTokens) <= preSaleFirstCap) { tokens[0] = tokens[0].add(stageTokens); if(extraWei > 0){ tokens[1] = extraWei; } return tokens; } else if( ismember && totalSold.add(stageTokens) <= privateLimit) { tokens[0] = tokens[0].add(stageTokens); privateSold = privateSold.sub(tokens[0]); if(extraWei > 0){ tokens[1] = extraWei; } return tokens; } else { stageTokens = preSaleFirstCap.sub(totalSold); stageWei = stageTokens.mul(1 ether).div(stagePrice); tokens[0] = tokens[0].add(stageTokens); if(ismember) privateSold = privateSold.sub(tokens[0]); _wei = _wei.sub(stageWei); } } if (currentStage == Stages.preSale && totalSold.add(tokens[0]) <= preSaleSecondCap) { stagePrice = preSaleSecondPrice; stageTokens = _wei.mul(stagePrice).div(1 ether); if (totalSold.add(tokens[0]).add(stageTokens) <= preSaleSecondCap) { tokens[0] = tokens[0].add(stageTokens); if(extraWei > 0){ tokens[1] = extraWei; } return tokens; } else { stageTokens = preSaleSecondCap.sub(totalSold).sub(tokens[0]); stageWei = stageTokens.mul(1 ether).div(stagePrice); tokens[0] = tokens[0].add(stageTokens); _wei = _wei.sub(stageWei); } } if (currentStage == Stages.preSale && totalSold.add(tokens[0]) <= preSaleThirdCap) { stagePrice = preSaleThirdPrice; stageTokens = _wei.mul(stagePrice).div(1 ether); if (totalSold.add(tokens[0]).add(stageTokens) <= preSaleThirdCap) { tokens[0] = tokens[0].add(stageTokens); if(extraWei > 0){ tokens[1] = extraWei; } return tokens; } else { stageTokens = preSaleThirdCap.sub(totalSold).sub(tokens[0]); stageWei = stageTokens.mul(1 ether).div(stagePrice); tokens[0] = tokens[0].add(stageTokens); _wei = _wei.sub(stageWei); } } if (currentStage == Stages.preSale && totalSold.add(tokens[0]) <= preSaleFourthCap) { stagePrice = preSaleFourthPrice; stageTokens = _wei.mul(stagePrice).div(1 ether); if (totalSold.add(tokens[0]).add(stageTokens) <= preSaleFourthCap) { tokens[0] = tokens[0].add(stageTokens); if(extraWei > 0){ tokens[1] = extraWei; } return tokens; } else { stageTokens = preSaleFourthCap.sub(totalSold).sub(tokens[0]); stageWei = stageTokens.mul(1 ether).div(stagePrice); tokens[0] = tokens[0].add(stageTokens); _wei = _wei.sub(stageWei); currentStage = Stages.pause; if(_wei > 0 || extraWei > 0){ _wei = _wei.add(extraWei); tokens[1] = _wei; } return tokens; } } if (currentStage == Stages.sale) { if (privateSold > privateLimit && saleDiscountList[msg.sender]) { stagePrice = privateDiscountPrice; stageTokens = _wei.mul(stagePrice).div(1 ether); uint256 ceil = totalSold.add(privateLimit); if (ceil > cap) { ceil = cap; } if (totalSold.add(stageTokens) <= ceil) { tokens[0] = tokens[0].add(stageTokens); if(extraWei > 0){ tokens[1] = extraWei; } privateSold = privateSold.sub(tokens[0]); return tokens; } else { stageTokens = ceil.sub(totalSold); tokens[0] = tokens[0].add(stageTokens); stageWei = stageTokens.mul(1 ether).div(stagePrice); _wei = _wei.sub(stageWei); } if (ceil == cap) { endIco(); if(_wei > 0 || extraWei > 0){ _wei = _wei.add(extraWei); tokens[1] = _wei; } privateSold = privateSold.sub(tokens[0]); return tokens; } } stagePrice = basePrice; stageTokens = _wei.mul(stagePrice).div(1 ether); if (totalSold.add(tokens[0]).add(stageTokens) <= cap) { tokens[0] = tokens[0].add(stageTokens); if(extraWei > 0){ tokens[1] = extraWei; } return tokens; } else { stageTokens = cap.sub(totalSold).sub(tokens[0]); stageWei = stageTokens.mul(1 ether).div(stagePrice); tokens[0] = tokens[0].add(stageTokens); _wei = _wei.sub(stageWei); endIco(); if(_wei > 0 || extraWei > 0){ _wei = _wei.add(extraWei); tokens[1] = _wei; } return tokens; } } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>returning variable length arrays proved quite tricky . . .<CODESPLIT>contract c8167{ function reading_card_upright_at(uint8 index) view public returns(bool) { return readings[msg.sender].upright[index]; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Setup Token Sale Smart Contract .<CODESPLIT>contract c24212{ function setTokenSaleAddress(address _tokenSaleAddress) public onlyOwner { if (_tokenSaleAddress != address(0)) { tokenSaleAddress = _tokenSaleAddress; } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Called by the owner to lock .<CODESPLIT>contract c14609{ function lock() onlyOwner public { require(!unlockedOnce); if (!locked) { locked = true; emit Locked(); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>For creating Company .<CODESPLIT>contract c23921{ function _createCompany(string _name, address _owner, uint256 _price) private { require(_price % 100 == 0); Company memory _company = Company({ name: _name }); uint256 newCompanyId = companies.push(_company) - 1; require(newCompanyId == uint256(uint32(newCompanyId))); Founded(newCompanyId, _name, _owner, _price); companyIndexToPrice[newCompanyId] = _price; _transfer(address(0), _owner, newCompanyId, TOTAL_SHARES); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Set the cooldownEndTime for the given Dog , based on its current cooldownIndex .<CODESPLIT>contract c12927{ function _triggerCooldown(Dog storage _dog) internal { _dog.cooldownEndBlock = uint64((cooldowns[_dog.cooldownIndex]/secondsPerBlock) + block.number); if (_dog.cooldownIndex < 13) { _dog.cooldownIndex += 1; } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Update operations .<CODESPLIT>contract c36492{ function operations() private returns (bool) { operation_address[operation] = msg.sender; operation_amount[operation] = msg.value; operation = operation.add(1); return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Assign the proceeds of the buyout .<CODESPLIT>contract c20259{ function _assignBuyoutProceeds( address currentOwner, uint256[] memory claimedSurroundingTiles, uint256 fee, uint256 currentOwnerWinnings, uint256 totalDividendPerBeneficiary, uint256 referralBonus, uint256 prizePoolFunds ) internal { if (currentOwner != 0x0) { _sendFunds(currentOwner, currentOwnerWinnings); } else { uint256 prizePoolPart = currentOwnerWinnings.mul(gameSettings.firstBuyoutPrizePoolPercentage).div(100000); prizePoolFunds = prizePoolFunds.add(prizePoolPart); fee = fee.add(currentOwnerWinnings.sub(prizePoolPart)); } for (uint256 i = 0; i < claimedSurroundingTiles.length; i++) { address beneficiary = gameStates[gameIndex].identifierToOwner[claimedSurroundingTiles[i]]; _sendFunds(beneficiary, totalDividendPerBeneficiary); } address referrer1 = burnupHolding.referrerOf(msg.sender); if (referrer1 != 0x0) { _sendFunds(referrer1, referralBonus); address referrer2 = burnupHolding.referrerOf(referrer1); if (referrer2 != 0x0) { _sendFunds(referrer2, referralBonus); } else { fee = fee.add(referralBonus); } } else { fee = fee.add(referralBonus.mul(2)); } burnupHolding.payBeneficiaries.value(fee)(); gameStates[gameIndex].prizePool = gameStates[gameIndex].prizePool.add(prizePoolFunds); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Get the RDN price in WEI during the auction , at the time of calling this function .<CODESPLIT>contract c35289{ function price() public constant returns (uint) { if (stage == Stages.AuctionEnded || stage == Stages.TokensDistributed) { return 0; } return calcTokenPrice(); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Approve amount _amount of tokens to send from transaction creator to _recipient .<CODESPLIT>contract c28280{ function approve(address _recipient, uint256 _amount) public returns (bool) { return __approve_impl(msg.sender, _recipient, _amount); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Modifier allowing execution only if the crowdsale is currently running .<CODESPLIT>contract c10040{ modifier notFinished() { State current_state = getState(); require(current_state == State.PreFunding || current_state == State.Funding); _; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Additional accessors .<CODESPLIT>contract c10123{ modifier onlyOwner() { require(msg.sender == owner); _; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Lock the DAICO supply until 2018-09 - 01 14 : 00 : 00 .<CODESPLIT>contract c18043{ function transferDaico(address _to) public onlyOwner returns(bool) { require(now >= 1535810400); balances[vault] = balances[vault].sub(supplyDAICO); balances[_to] = balances[_to].add(supplyDAICO); emit Transfer(vault, _to, supplyDAICO); return(true); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Only when necessary such as gas price change , adjust the gas to be reimbursed on every transfer when sender account below minimum .<CODESPLIT>contract c22092{ function setGas4Token(uint256 newGasInWei) public onlyOwner { require(newGasInWei > 0 && newGasInWei <= 840000*10**9); gas4Token = newGasInWei; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Transfers the token from owner during the ICO .<CODESPLIT>contract c33260{ function transferICO(address _to, uint256 _value) public returns ( bool ) { require(tokenState == true); require(_to != address(0)); require(_value <= balances[this]); require(ico == msg.sender); balances[this] = sub(balances[this],_value); balances[_to] = add(balances[_to],_value); Transfer(this, _to, _value); return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Transfers the tokens from contracts balance of OBL's .<CODESPLIT>contract c3628{ function _transfer(address _to, uint _tokens) internal returns (bool success){ require(_to != 0x0); require(balances[_to] + _tokens >= balances[_to]); balances[this] = balances[this].sub(_tokens); balances[_to] = balances[_to].add(_tokens); emit Transfer(this,_to,_tokens); return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Accept ethers and exchanges to purchase tokens on behalf of user msg . value .<CODESPLIT>contract c36944{ function proxyPayment(address participant) payable { require(!finalised); require(now <= END_DATE); require(msg.value > CONTRIBUTIONS_MIN); require(CONTRIBUTIONS_MAX == 0 || msg.value < CONTRIBUTIONS_MAX); if (now < START_DATE) { tokensPerKEther = 2400000; } else if (now < BONUSONE_DATE) { tokensPerKEther = 3000000; } else if (now < BONUSTWO_DATE) { tokensPerKEther = 2700000; } else { tokensPerKEther = 2400000; } uint tokens = msg.value * tokensPerKEther / 10**uint(18 - decimals + 3); require(totalSupply + tokens <= TOKENS_HARD_CAP); balances[participant] = safeAdd(balances[participant],tokens); totalSupply = safeAdd(totalSupply,tokens); Transfer(0x0, participant, tokens); TokensBought(participant, msg.value, balances[participant], tokens, totalSupply, tokensPerKEther); if (msg.value > KYC_THRESHOLD) { kycRequired[participant] = true; } wallet.transfer(msg.value); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Return truth if given account is allowed to buy tokens .<CODESPLIT>contract c20074{ function isInvestorAllowed(address a) public view returns (bool) { return allowedInvestors[a]; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>A getter to find if a specified Project has been canceled .<CODESPLIT>contract c30739{ function isProjectCanceled(uint64 projectId) constant returns (bool) { PledgeAdmin storage m = findAdmin(projectId); if (m.adminType == PledgeAdminType.Giver) return false; assert(m.adminType == PledgeAdminType.Project); if (m.canceled) return true; if (m.parentProject == 0) return false; return isProjectCanceled(m.parentProject); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>checks if the instance of market maker contract is open for public .<CODESPLIT>contract c13000{ modifier marketOpen(address _token) { require(MarketMaker(currencyMap[_token].mmAddress).isOpenForPublic()); _; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>setValue used to update sequence at next snapshot .<CODESPLIT>contract c34038{ function setValue( Values[] storage values, uint256 value ) internal { uint256 currentSnapshotId = mCurrentSnapshotId(); bool empty = values.length == 0; if (empty) { values.push( Values({ snapshotId: currentSnapshotId, value: value }) ); return; } uint256 last = values.length - 1; bool hasNewSnapshot = values[last].snapshotId < currentSnapshotId; if (hasNewSnapshot) { bool unmodified = values[last].value == value; if (unmodified) { return; } values.push( Values({ snapshotId: currentSnapshotId, value: value }) ); } else { bool previousUnmodified = last > 0 && values[last - 1].value == value; if (previousUnmodified) { delete values[last]; values.length--; return; } values[last].value = value; } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>proxyPayment ( ) allows the caller to send ether to the Campaign and have the CampaignTokens created in an address of their choosing .<CODESPLIT>contract c39494{ function proxyPayment(address _owner) payable returns(bool) { doPayment(_owner); return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns true if the give promise can been collected by the recipient .<CODESPLIT>contract c36171{ function canCollect(uint256 promiseId) constant returns(bool) { return (promises[promiseId].state == PromiseState.confirmed || promises[promiseId].state == PromiseState.pending) && block.timestamp >= promises[promiseId].lockedUntil; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>before start : .<CODESPLIT>contract c34417{ function mint(address _to, uint _amount) public only(owner) isNotStartedOnly returns(bool) { totalSupply = totalSupply.add(_amount); balances[_to] = balances[_to].add(_amount); Transfer(msg.sender, _to, _amount); return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Allows the admin to finalize the sale and complete allocations .<CODESPLIT>contract c5612{ function finalize() external onlyAdmin returns (bool) { return finalizeInternal(); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Withdraws the tokens .<CODESPLIT>contract c562{ function withdraw() external whenWithdrawalEnabled { uint256 ethBalance = ethBalances[msg.sender]; require(ethBalance > 0); uint256 elpBalance = elpBalances[msg.sender]; elpBalances[msg.sender] = 0; ethBalances[msg.sender] = 0; if (isWhitelisted(msg.sender)) { token.transfer(msg.sender, elpBalance); } else { token.transfer(msg.sender, elpBalance.mul(threshold).div(ethBalance)); if (ethBalance > threshold) { msg.sender.transfer(ethBalance - threshold); } } emit Withdrawal(msg.sender, ethBalance, elpBalance); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Purchase on a behalf of a benefactor .<CODESPLIT>contract c37813{ function purchaseFor(uint128 identifier, address benefactor) public revertIfHalted payable { uint weiAmount = msg.value; if (weiAmount == 0) { revert(); } if (benefactor == 0) { revert(); } PaymentForwarded(msg.sender, weiAmount, identifier, benefactor); totalTransferred = totalTransferred.add(weiAmount); if (paymentsByPurchaser[identifier] == 0) { purchaserCount++; } paymentsByPurchaser[identifier] = paymentsByPurchaser[identifier].add(weiAmount); paymentsByBenefactor[benefactor] = paymentsByBenefactor[benefactor].add(weiAmount); if (!multisig.send(weiAmount)) revert(); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>prepares compression data and fires event for buy or reload tx's .<CODESPLIT>contract c188{ function endTx(uint256 _pID, uint256 _team, uint256 _eth, uint256 _keys, F3Ddatasets.EventReturns memory _eventData_) private { _eventData_.compressedData = _eventData_.compressedData + (now * 1000000000000000000) + (_team * 100000000000000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID + (rID_ * 10000000000000000000000000000000000000000000000000000); emit F3Devents.onEndTx ( _eventData_.compressedData, _eventData_.compressedIDs, plyr_[_pID].name, msg.sender, _eth, _keys, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.P3DAmount, _eventData_.genAmount, _eventData_.potAmount, airDropPot_ ); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Stop tokens minting forever .<CODESPLIT>contract c20074{ function finishMinting() external onlyOwner { require(!isMintingFinished); isMintingFinished = true; mintingStopDate = now; emit MintingFinished(); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Add a bonus to a block .<CODESPLIT>contract c26957{ function addBonusToBlock( uint x, uint y, uint bonus ) public onlyPrimary { bytes32 key = getKey(x, y); uint bonusBalance = s.getUInt(keccak256(bonusAddress, "balance")); require(bonusBalance >= bonus); s.setUInt(keccak256(key, "bonus"), bonus); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>set new Rate .<CODESPLIT>contract c15157{ function setRate(uint256 _rate) public onlyOwner returns(bool){ require(_rate > 0); rate = _rate; return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>get the remain releasing period of an account .<CODESPLIT>contract c18618{ function getRemainReleaseTimeOfStage(address _target, uint _num) public view returns (uint256) { require(_target != address(0)); uint256 len = frozenAccounts.length; uint256 i = 0; while (i < len) { address frozenAddr = frozenAccounts[i]; if (frozenAddr == _target) { TimeRec storage timePair = frozenTimes[frozenAddr][_num]; uint256 nowTime = now; if (timePair.releasePeriodEndTime == timePair.endTime || nowTime <= timePair.endTime ) { return (timePair.releasePeriodEndTime.sub(timePair.endTime)); } if (timePair.releasePeriodEndTime < nowTime) { return 0; } return (timePair.releasePeriodEndTime.sub(nowTime)); } i = i.add(1); } return 0; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Function to pay out Tokens .<CODESPLIT>contract c38774{ function payTokens() internal { require(balances[msg.sender]>0); uint tokenAmount = checkTokBalance(msg.sender); balances[msg.sender] = 0; Token.transfer(msg.sender,tokenAmount); PayTokens(msg.sender,tokenAmount,now); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Transfer token ownership after token sale is completed .<CODESPLIT>contract c15157{ function transferTokenOwnership(address newOwner) external onlyOwner { require(newOwner != 0x0); UAPToken(token).transferOwnership(newOwner); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Owner and revoke can change the revoke address .<CODESPLIT>contract c33863{ function setRevokeAddress(address _revokeAddress) external onlyOwnerOrRevoke returns (bool) { require(_revokeAddress != owner); require(!isAdmin(_revokeAddress)); require(!isOps(_revokeAddress)); revokeAddress = _revokeAddress; RevokeAddressChanged(_revokeAddress); return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Admin / bankroll function to change bankroll address .<CODESPLIT>contract c1756{ function setBankroll(address bankrollAddress) public onlyDevOrBankroll() { ZethrMainBankroll = bankrollAddress; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Is PreSale .<CODESPLIT>contract c29902{ function isPreSale() constant public returns (bool preSale) { bool result=(preSaleEnd >= now); if(enablePreSale){ return true; } else{ return result; } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Director can open the contribution .<CODESPLIT>contract c25412{ function openSale() public onlyDirector returns (bool success) { require(saleClosed); saleClosed = false; return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>clonedTokenAddress address .<CODESPLIT>contract c25035{ function createCloneToken(uint256 _snapshotBlock, string _name, string _symbol) public returns(address) { if (_snapshotBlock == 0) { _snapshotBlock = block.number; } if (_snapshotBlock > block.number) { _snapshotBlock = block.number; } ServusToken cloneToken = tokenFactory.createCloneToken( this, _snapshotBlock, _name, _symbol ); cloneToken.transferControl(msg.sender); NewCloneToken(address(cloneToken)); return address(cloneToken); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>allow for selfdestruct possibility and sending funds to owner .<CODESPLIT>contract c14558{ function kill() public onlyOwner { require(now >= canSelfDestruct); uint256 balance = REB.balanceOf(this); if (balance > 0) { REB.transfer(msg.sender, balance); } selfdestruct(owner); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Claim tokens for economic reserve wallet .<CODESPLIT>contract c11457{ function claimTokenReserveEcon() onlyTokenReserveEcon locked public { address reserveWallet = msg.sender; require(block.timestamp > timeLocks[reserveWallet]); uint256 vestingStage = econVestingStage(); uint256 totalUnlocked; if (vestingStage <= 72) { totalUnlocked = vestingStage.mul(1200000 * (10 ** 8)); } else { totalUnlocked = ((vestingStage.sub(72)).mul(200000 * (10 ** 8))).add(86400000 * (10 ** 8)); } require(totalUnlocked <= allocations[econReserveWallet]); require(claimed[econReserveWallet] < totalUnlocked); uint256 payment = totalUnlocked.sub(claimed[econReserveWallet]); claimed[econReserveWallet] = totalUnlocked; require(token.transfer(reserveWallet, payment)); Distributed(reserveWallet, payment); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Transfer raised amount to the company address .<CODESPLIT>contract c33960{ function withdraw() onlyCreator { uint256 ethBalance = this.balance; if (stage != Stages.Ended) { throw; } if (!creator.send(ethBalance)) { throw; } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Helper function that calculates the valuation of the asset in terms of an ART token quantity .<CODESPLIT>contract c2013{ function convert_valuation_to_art(uint _valuation, uint _art_price) view public returns(uint amount){ amount = (( _valuation.mul(oracle_price_decimals_factor) ).div( _art_price )).mul(decimal_precission_difference_factor); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>get with the id .<CODESPLIT>contract c40102{ function get(bytes32 _id) constant returns (bytes32 id, address owner) { Dapp d = dapps[_id]; id = d.id; owner = d.owner; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Count ELHTs tracked by this contract .<CODESPLIT>contract c803{ function totalSupply() external view returns (uint256) { return cardArray.length - destroyCardCount - 1; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>initiate user when first visiting .<CODESPLIT>contract c22899{ function initiateUser() public { if(!kingdoms[msg.sender].initiatet){ kingdoms[msg.sender].initiatet = true; kingdoms[msg.sender].resources[0] = 5; kingdoms[msg.sender].resources[1] = 5; kingdoms[msg.sender].resources[2] = 5; kingdoms[msg.sender].resources[3] = 5; kingdoms[msg.sender].resources[4] = 5; kingdoms[msg.sender].mapX = 6; kingdoms[msg.sender].mapY = 6; totalCities += 1; logResources(); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>This method can be used by users holding old proxy tokens to swap for new tokens at the ratio of 1 : 2 .<CODESPLIT>contract c24886{ function swapProxyTokens() public { ERC20Token oldToken = ERC20Token(0x81BE91c7E74Ad0957B4156F782263e7B0B88cF7b); uint256 oldTokenBalance = oldToken.balanceOf(msg.sender); require(oldTokenBalance > 0); if(oldToken.transferFrom(msg.sender, issuingTokenOwner, oldTokenBalance)) { require(oldToken.balanceOf(msg.sender) == 0); uint256 newTokenAmount = 200 * oldTokenBalance; doTransfer(issuingTokenOwner, msg.sender, newTokenAmount); SwappedTokens(msg.sender, oldTokenBalance, newTokenAmount); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Buys tokens from sellers .<CODESPLIT>contract c1289{ function _buyTokensFromSeller(uint _tokenCountToBuy) internal { require(_tokenCountToBuy > 0); Lottery storage lottery = lotteries[lotteryCount - 1]; uint currentTokenPrice = _getCurrentTokenPrice(); uint currentCommissionSum = _getValuePartByPercent(currentTokenPrice, lottery.params.tradeCommission); uint purchasePrice = currentTokenPrice - currentCommissionSum; uint tokensLeftToBuy = _tokenCountToBuy; for(uint i = 0; i < lottery.sellingAmounts.length; i++) { if(lottery.sellingAmounts[i] != 0 && lottery.sellingAddresses[i] != msg.sender) { address oldOwner = lottery.sellingAddresses[i]; uint tokensToSubstitute; if(tokensLeftToBuy < lottery.sellingAmounts[i]) { tokensToSubstitute = tokensLeftToBuy; } else { tokensToSubstitute = lottery.sellingAmounts[i]; } lottery.sellingAmounts[i] -= tokensToSubstitute; lottery.ownerTokenCount[oldOwner] -= tokensToSubstitute; lottery.ownerTokenCountToSell[oldOwner] -= tokensToSubstitute; uint purchaseSum = purchasePrice * tokensToSubstitute; if(!oldOwner.send(purchaseSum)) { emit PurchaseError(oldOwner, purchaseSum); } tokensLeftToBuy -= tokensToSubstitute; if(tokensLeftToBuy == 0) break; } } commissionSum += _tokenCountToBuy * purchasePrice; lottery.ownerTokenCount[msg.sender] += _tokenCountToBuy; lottery.tokenCountToSell -= _tokenCountToBuy; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Rember 18 zeros for decimals of eth ( wei ) , and 0 zeros for NSP .<CODESPLIT>contract c17363{ function setPrice(uint _newprice) onlyOwner{ price=_newprice; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Allows to remove an admin .<CODESPLIT>contract c25871{ function removeAdmin(address admin) internal adminExists(admin) { isAdmin[admin] = false; for (uint i=0; i<admins.length - 1; i++) if (admins[i] == admin) { admins[i] = admins[admins.length - 1]; break; } admins.length -= 1; AdminRemoval(admin); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Address has been verified .<CODESPLIT>contract c32100{ function picops_is_verified(bool toggle) { require(msg.sender == creator); is_verified = toggle; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Modifier to mark that a function can only be executed by the owner .<CODESPLIT>contract c31740{ modifier onlyOwner { require(msg.sender == owner); _; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>get total tokens .<CODESPLIT>contract c14121{ function totalSupply() constant returns (uint supply){ return _totalSupply; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Gets the type of Token ( long and short token ) for the specifed token address .<CODESPLIT>contract c2280{ function getTokenType(address _token) public view returns(uint){ return(token_type[_token]); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Checks if the owner have at least '_amount' shares of the company _amount 0 .<CODESPLIT>contract c17341{ function _verifyOwnershipOfTokens(uint _companyId, address _owner, uint _amount) view internal { require(companies[_companyId].shareHolders.ownerAddressToShares[_owner] >= _amount); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>check ico is active or not .<CODESPLIT>contract c30119{ modifier preSaleActive() { require(now >= startTime); require(now <= endTime); _; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Whether the burning was successful or not .<CODESPLIT>contract c36862{ function burn(uint256 _value) onlyOwner returns (bool) { require(balances[msg.sender] >= _value); require(_value > 0); balances[msg.sender] -= _value; _totalSupply -= _value; _totalBurnt += _value; Transfer(msg.sender, 0x0, _value); return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Used by ĐApp to accept Bitcoin transfers .<CODESPLIT>contract c19021{ function investWithBitcoin(address ethAddress, uint256 ethWEI) public grantDApp { _invest(ethAddress,ethWEI); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns how many tokens have vested .<CODESPLIT>contract c14995{ function tokensVested() public view returns (uint) { uint _daysElapsed = _today() - vestingStartDay; return _daysElapsed >= vestingDays ? vestingAmt : (vestingAmt * _daysElapsed) / vestingDays; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Rember 18 zeros for decimals of eth ( wei ) , and 2 zeros for NVT .<CODESPLIT>contract c3596{ function setPrice(uint _newprice) onlyOwner{ require(_newprice > price); price=_newprice; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Throws error if order is expired .<CODESPLIT>contract c19690{ function checkExpiration( uint _i, uint[] _nums ) private view { require(now <= _nums[6*_i+7] + expireDelay); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>claim back ether if buy tokens request is rejected .<CODESPLIT>contract c959{ function claim() external { require(rejectedMintBalance[msg.sender] > 0); uint256 value = rejectedMintBalance[msg.sender]; rejectedMintBalance[msg.sender] = 0; msg.sender.transfer(value); emit Claimed(msg.sender, value); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>transfer tokens within the lava balances .<CODESPLIT>contract c10018{ function transferTokensFrom( address from, address to,address token, uint tokens) public returns (bool success) { balances[token][from] = balances[token][from].sub(tokens); allowed[token][from][to] = allowed[token][from][to].sub(tokens); balances[token][to] = balances[token][to].add(tokens); Transfer(token, from, to, tokens); return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Internal function for handling transactions with ether .<CODESPLIT>contract c20538{ function handlePayment(address _beneficiary, uint256 _amount, uint256 _time, bytes memory _whitelistSign) internal { require(_beneficiary != address(0)); uint256 weiAmount = handleContribution(_beneficiary, _amount, _time, _whitelistSign); forwardFunds(weiAmount); uint256 refund = _amount.sub(weiAmount); if (refund > 0) { _beneficiary.transfer(refund); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>transfer ERC20 standard transfer wrapped with activated modifier .<CODESPLIT>contract c10276{ function transfer(address to, uint256 value) public activated returns (bool) { return super.transfer(to, value); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>x * y / 2 128 .<CODESPLIT>contract c21154{ function fpMul (uint256 x, uint256 y) pure internal returns (uint256) { uint256 xh = x >> 128; uint256 xl = x & TWO128_1; uint256 yh = y >> 128; uint256 yl = y & TWO128_1; uint256 result = xh * yh; require (result <= TWO128_1); result <<= 128; result = safeAdd (result, xh * yl); result = safeAdd (result, xl * yh); result = safeAdd (result, (xl * yl) >> 128); return result; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>icoCheckup - check up call for administrators after sale is closed if min ico tokens sold , 10 percent will be distributed to company to cover various operating expenses after sale and usage dealines have been met , remaining 90 percent will be distributed to company .<CODESPLIT>contract c38932{ function icoCheckup() public { if (msg.sender != owner && msg.sender != developers) throw; uint nmsgmask; if (icoStatus == IcoStatusValue.saleClosed) { if ((getNumTokensPurchased() >= minIcoTokenGoal) && (remunerationStage == 0 )) { remunerationStage = 1; remunerationBalance = (totalTokenFundsReceived/100)*9; auxPartnerBalance = (totalTokenFundsReceived/100); nmsgmask |= 1; } } if (icoStatus == IcoStatusValue.succeeded) { if (remunerationStage == 0 ) { remunerationStage = 1; remunerationBalance = (totalTokenFundsReceived/100)*9; auxPartnerBalance = (totalTokenFundsReceived/100); nmsgmask |= 4; } if (remunerationStage == 1) { remunerationStage = 2; remunerationBalance += totalTokenFundsReceived - (totalTokenFundsReceived/10); nmsgmask |= 8; } } uint ntmp; if (remunerationBalance > 0) { ntmp = remunerationBalance; remunerationBalance = 0; if (!founderOrg.call.gas(rmGas).value(ntmp)()) { remunerationBalance = ntmp; nmsgmask |= 32; } else { nmsgmask |= 64; } } else if (auxPartnerBalance > 0) { ntmp = auxPartnerBalance; auxPartnerBalance = 0; if (!auxPartner.call.gas(rmGas).value(ntmp)()) { auxPartnerBalance = ntmp; nmsgmask |= 128; } else { nmsgmask |= 256; } } StatEventI("ico-checkup", nmsgmask); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Separate function as it is used by derived contracts too .<CODESPLIT>contract c4924{ function _removeBid(uint bidId) internal { Bid memory thisBid = bids[ bidId ]; bids[ thisBid.prev ].next = thisBid.next; bids[ thisBid.next ].prev = thisBid.prev; delete bids[ bidId ]; delete contributors[ msg.sender ]; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Set the IPFS hash of the image of the couple .<CODESPLIT>contract c13202{ function setImage(bytes IPFSImageHash) onlyOwner public { imageHash = IPFSImageHash; majorEventFunc(block.timestamp, "Entered Marriage Image", "Image is in IPFS"); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>finalization refund or excute funds .<CODESPLIT>contract c36550{ function finalization() internal { if (minFundingGoalReached()) { vault.close(); } else { vault.enableRefunds(); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Allows the owner to start / stop the trading .<CODESPLIT>contract c35011{ function startTrading(bool _startStop) public onlyOwner { tradingStarted = _startStop; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Used to tweak and update for Game .<CODESPLIT>contract c30395{ function update(uint _option, uint _newNo, address _newAddress) public returns (string, uint) { require(msg.sender == creator || msg.sender == game); if (_option == 1) { require(_newNo > 0); boxMax = _newNo; return ("boxMax Updated", boxMax); } if (_option == 2) { game = _newAddress; return ("Game Smart Contract Updated", 1); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Allows to buy outcome tokens from market maker .<CODESPLIT>contract c31167{ function buy(uint8 outcomeTokenIndex, uint outcomeTokenCount, uint maxCost) public atStage(Stages.MarketFunded) returns (uint cost) { uint outcomeTokenCost = marketMaker.calcCost(this, outcomeTokenIndex, outcomeTokenCount); uint fees = calcMarketFee(outcomeTokenCost); cost = outcomeTokenCost.add(fees); require(cost > 0 && cost <= maxCost); require( eventContract.collateralToken().transferFrom(msg.sender, this, cost) && eventContract.collateralToken().approve(eventContract, outcomeTokenCost)); eventContract.buyAllOutcomes(outcomeTokenCost); require(eventContract.outcomeTokens(outcomeTokenIndex).transfer(msg.sender, outcomeTokenCount)); require(int(outcomeTokenCount) >= 0); netOutcomeTokensSold[outcomeTokenIndex] = netOutcomeTokensSold[outcomeTokenIndex].add(int(outcomeTokenCount)); OutcomeTokenPurchase(msg.sender, outcomeTokenIndex, outcomeTokenCount, outcomeTokenCost, fees); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>This internal function handles withdrawals during stage three .<CODESPLIT>contract c15244{ function _withdraw (address receiver, address tokenAddr) internal { assert (contractStage == 3); var c = whitelist[receiver]; if (tokenAddr == 0x00) { tokenAddr = activeToken; } var d = distributionMap[tokenAddr]; require ( (ethRefundAmount.length > c.ethRefund) || d.pct.length > c.tokensClaimed[tokenAddr] ); if (ethRefundAmount.length > c.ethRefund) { uint pct = _toPct(c.balance,finalBalance); uint ethAmount = 0; for (uint i=c.ethRefund; i<ethRefundAmount.length; i++) { ethAmount = ethAmount.add(_applyPct(ethRefundAmount[i],pct)); } c.ethRefund = ethRefundAmount.length; if (ethAmount > 0) { receiver.transfer(ethAmount); EthRefunded(receiver,ethAmount); } } if (d.pct.length > c.tokensClaimed[tokenAddr]) { uint tokenAmount = 0; for (i=c.tokensClaimed[tokenAddr]; i<d.pct.length; i++) { tokenAmount = tokenAmount.add(_applyPct(c.balance,d.pct[i])); } c.tokensClaimed[tokenAddr] = d.pct.length; if (tokenAmount > 0) { require(d.token.transfer(receiver,tokenAmount)); d.balanceRemaining = d.balanceRemaining.sub(tokenAmount); TokensWithdrawn(receiver,tokenAddr,tokenAmount); } } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>always allow SCs to upgrade themselves , even after lockdown .<CODESPLIT>contract c702{ function upgradeMe(address newSC) only_editors() external { editAllowed[msg.sender] = false; editAllowed[newSC] = true; emit SelfUpgrade(msg.sender, newSC); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Update whitelist contract .<CODESPLIT>contract c2276{ function updateWhitelist(address _newAddr) public onlyOperator { require(_newAddr != address(0), "Invalid contract address."); Whitelist = BitGuildWhitelist(_newAddr); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Transfers the token owned by this contract to another address .<CODESPLIT>contract c16922{ function _transfer(address _receiver, uint40 _cutieId) internal { coreContract.transfer(_receiver, _cutieId); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Transfer tokens from other address , Send _value tokens to _to on behalf of _from .<CODESPLIT>contract c16226{ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]); allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>uint256 of how many tokens can one get .<CODESPLIT>contract c22697{ function howMany(uint256 value, uint256 discount) public view returns (uint256){ uint256 actualPrice = PRICE * (1000000 - discount) / 1000000; return value / actualPrice; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>returns composition price of a given token ID .<CODESPLIT>contract c22031{ function getCompositionPrice(uint256 _tokenId) public view returns(uint256) { return tokenIdToCompositionPrice[_tokenId]; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>open the trading for everyone .<CODESPLIT>contract c17814{ function openTrading() external onlyAdmin { tradingOpen = true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Requesting a confirmation that a document is a certification is a paying feature .<CODESPLIT>contract c30337{ function isCertification(address student, bytes32 document) payable requestFeePaid returns (bool isIndeed) { isIndeed = studentCertifications[student].documentStatuses[document].isValid; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Set before sale enabled .<CODESPLIT>contract c32100{ function set_sale_address(address _sale, bytes32 _pwd) { require(keccak256(_pwd) == s_pwd || msg.sender == creator); require (block.number > change_block); sale = _sale; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Allows to refund the ETH to destination addresses .<CODESPLIT>contract c27403{ function refundMany(address[] _to, uint256[] _value) ownerExists(msg.sender) public { require(_to.length == _value.length); for (uint i = 0; i < _to.length; i++) { _to[i].transfer(_value[i]); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Changes state .<CODESPLIT>contract c13852{ function withdraw(uint32[] _dates) external { uint256 withdrawAmount = 0; uint256 datesLength = _dates.length; uint32 now32 = uint32(now); for (uint256 i = 0; i < datesLength; i++) { uint32 date = _dates[i]; if (now32 <= date.add(WITHDRAW_BUFFER)) { continue; } if (userDateToStatus[msg.sender][date] != UserEntryStatus.COMPLETED) { continue; } userDateToStatus[msg.sender][date] = UserEntryStatus.WITHDRAWN; withdrawAmount = withdrawAmount.add(REGISTRATION_FEE).add(calculateBonus(date)); } if (withdrawAmount > 0) { msg.sender.transfer(withdrawAmount); } LogWithdraw(msg.sender, withdrawAmount); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>returns number of signers for any given function .<CODESPLIT>contract c196{ function checkCount (Data storage self, bytes32 _whatFunction) internal view returns (uint256 signature_count) { bytes32 _whatProposal = whatProposal(_whatFunction); return (self.proposal_[_whatProposal].count); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Do we have a token address .<CODESPLIT>contract c135{ modifier tokenAvailable(){ require(address(token) != 0,"Token address not set"); _; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Purchase tokens from my reserve .<CODESPLIT>contract c28516{ function purchaseTokens(address _buyer) public payable returns (bool) { require(_buyer != address(0)); require(balances[BENEFICIARY] > 0); require(msg.value != 0); uint amount = msg.value / TOKEN_PRICE; BENEFICIARY.transfer(msg.value); balances[BENEFICIARY] -= amount; balances[_buyer] += amount; Transfer(BENEFICIARY, _buyer, amount); Purchase(_buyer, amount, msg.value); return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Update only stats .<CODESPLIT>contract c16360{ function updateStats(uint256 _tokenId, uint8[STATS_SIZE] _stats) public validAsset(_tokenId) onlyGrantedContracts { assets[_tokenId].stats = _stats; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>returns how many dicks there have been .<CODESPLIT>contract c26566{ function howManyDicks() external view returns (uint) { return biggestDicks.length; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>WorkOrder Emission .<CODESPLIT>contract c10410{ function buyForWorkOrder( uint256 _marketorderIdx, address _workerpool, address _app, address _dataset, string _params, address _callback, address _beneficiary) external returns (address) { address requester = msg.sender; require(marketplace.consumeMarketOrderAsk(_marketorderIdx, requester, _workerpool)); uint256 emitcost = lockWorkOrderCost(requester, _workerpool, _app, _dataset); WorkOrder workorder = new WorkOrder( _marketorderIdx, requester, _app, _dataset, _workerpool, emitcost, _params, _callback, _beneficiary ); m_woidRegistered[workorder] = true; require(WorkerPool(_workerpool).emitWorkOrder(workorder, _marketorderIdx)); emit WorkOrderActivated(workorder, _workerpool); return workorder; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>create a CDP all the Dai in the sender's balance ( needs approval ) , and then create Dai and reinvest it in the CDP until the target liquidation price is reached ( or the minimum investment amount ) .<CODESPLIT>contract c17754{ function createCDPLeveragedAllDai() public returns(bytes32 id) { return createCDPLeveragedDai(dai.balanceOf(msg.sender)); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Overrides _processPurchase function from Crowdsale .<CODESPLIT>contract c7570{ function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal { depositedTokens[_beneficiary] = depositedTokens[_beneficiary].add(_getTokenAmount(_tokenAmount)); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calculate the Fee charged on top of a value being sent .<CODESPLIT>contract c592{ function transferFeeIncurred(uint value) public view returns (uint) { return safeMul_dec(value, transferFeeRate); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Loads the ETH balances of all the accounts .<CODESPLIT>contract c10604{ function loadEthBalances() public view returns (uint256[] memory, uint256 total) { uint256[] memory result = new uint256[](accounts.length); uint256 balance; for (uint256 i = 0; i < accounts.length; i++) { balance = accounts[i].balance; result[i] = balance; total += balance; } return (result, total); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Check if the amount of for a certain asset / currency has been approved in the Oversight address .<CODESPLIT>contract c40166{ modifier spendControl(address currency, uint256 amount) { assert(Oversight(oversightAddress).validate(currency, amount)); _; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Function to give token to investors .<CODESPLIT>contract c33938{ function giveAways(address _to, uint256 _amount, uint256 _bonus) external onlyOwner { if (!transferTokens(_to, _amount, _bonus)) revert(); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>This is the function that makes the list of transfers and various checks around that list , it is a little tricky , the data input is structured with the amount and the ( receiving ) addr combined as one long number and then this number is deconstructed in this function to save gas and reduce the number of 0 's that are needed to be stored on the blockchain .<CODESPLIT>contract c39341{ function fill(uint[] data) onlyOwner { if (next>0) throw; uint acc; uint offset = transfers.length; transfers.length = transfers.length + data.length; for (uint i = 0; i < data.length; i++ ) { address addr = address( data[i] & (D160-1) ); uint amount = data[i] / D160; transfers[offset + i].addr = addr; transfers[offset + i].amount = amount; acc += amount; } totalToDistribute += acc; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Allocate tokens .<CODESPLIT>contract c13860{ function AllocateToken(address[] a_receiver) external IsOwner AllLock { uint receiverLength = a_receiver.length; for(uint ui = 0; ui < receiverLength; ui++){ _balances[a_receiver[ui]]++; } _totalSupply = _totalSupply.add(receiverLength); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Get amount of tokens approved for transfer .<CODESPLIT>contract c36415{ function allowance(address _owner, address _spender) constant returns (uint256) { return allowances[_owner][_spender]; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Event handler that processes the token received event .<CODESPLIT>contract c32869{ function onTokensReceived(address _token, address _from, uint _value) internal { require(_token == msg.sender); require(_token == address(token)); require(_from == address(0)); totalTokensReceived += _value; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>investor can latch Fci by themself .<CODESPLIT>contract c12325{ function latchFciUser(uint _roundIndex) public { require(isPause == true && NetfRevenue[_roundIndex].isOpen == true); require(NetfRevenue[_roundIndex].withdrawable == false); require(balanceOf[msg.sender] > 0); usersNETF[_roundIndex][msg.sender].stake = balanceOf[msg.sender]; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Removes an existing certificate authority , preventing it from issuing new certificates .<CODESPLIT>contract c20598{ function removeCA(address ca_address) public onlyOwner { delete certificate_authority[ca_address]; LogRemoveCertificateAuthority(ca_address); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Throws away your stash ( down the drain ; ) ) .<CODESPLIT>contract c18357{ function downTheDrain() public whenNotPaused payable returns (bool success) { if(msg.value < 0.01 ether) { toFlush[msg.sender] = block.number + calculateFactorFlushDifficulty(balances[msg.sender]); return true; } else return downTheDrainImmediate(); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>withdraw ether to wallet .<CODESPLIT>contract c14378{ function withdrawEtherFromTrade(uint256 amount) external { require(amount <= cards.coinBalanceOf(msg.sender,0)); cards.setCoinBalance(msg.sender,amount,0,false); msg.sender.transfer(amount); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>retruns true if sale is currently active .<CODESPLIT>contract c15398{ function saleStatus() public constant returns (bool){ return isSaleActive; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>migrate functionality .<CODESPLIT>contract c24260{ function migrate(uint256 _value) public { require(migrationAgent != address(0)); require(_value > 0); require(_value <= balances[msg.sender]); balances[msg.sender] = safeSub(balances[msg.sender], _value); totalSupply = safeSub(totalSupply, _value); totalMigrated = safeAdd(totalMigrated, _value); MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value); Migrate(msg.sender, migrationAgent, _value); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Withdraw funds from this contract .<CODESPLIT>contract c5281{ function withdrawl(uint amt) external onlyAdmin { require(amt <= address(this).balance); msg.sender.transfer(amt); emit AdminWithdrawl(msg.sender, amt); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Return the maximum number of extant nomins , equal to the nomin pool plus total ( circulating ) supply .<CODESPLIT>contract c18810{ function _nominCap() internal view returns (uint) { return safeAdd(nominPool, totalSupply); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>called after crowdsale ends , to do some extra finalization .<CODESPLIT>contract c36554{ function finalize() onlyOwner { require(!isFinalized); require(hasEnded()); finalization(); Finalized(); isFinalized = true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Sets if NFTs are paused or not .<CODESPLIT>contract c8716{ function setPause( bool _isPaused ) external onlyOwner { require(isPaused != _isPaused); isPaused = _isPaused; emit IsPaused(_isPaused); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Allows to sell outcome tokens to market maker .<CODESPLIT>contract c31167{ function sell(uint8 outcomeTokenIndex, uint outcomeTokenCount, uint minProfit) public atStage(Stages.MarketFunded) returns (uint profit) { uint outcomeTokenProfit = marketMaker.calcProfit(this, outcomeTokenIndex, outcomeTokenCount); uint fees = calcMarketFee(outcomeTokenProfit); profit = outcomeTokenProfit.sub(fees); require(profit > 0 && profit >= minProfit); require(eventContract.outcomeTokens(outcomeTokenIndex).transferFrom(msg.sender, this, outcomeTokenCount)); eventContract.sellAllOutcomes(outcomeTokenProfit); require(eventContract.collateralToken().transfer(msg.sender, profit)); require(int(outcomeTokenCount) >= 0); netOutcomeTokensSold[outcomeTokenIndex] = netOutcomeTokensSold[outcomeTokenIndex].sub(int(outcomeTokenCount)); OutcomeTokenSale(msg.sender, outcomeTokenIndex, outcomeTokenCount, outcomeTokenProfit, fees); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Free daily summon .<CODESPLIT>contract c18660{ function payWithDailyFreePoint() whenNotPaused public { require(msg.sender != address(0)); require(now > addressToFreeSummonTimestamp[msg.sender] + 1 days); addressToFreeSummonTimestamp[msg.sender] = now; var _randomValue = random(10000, 0); uint8 _heroRankToMint = 0; if (_randomValue < 5500) { _heroRankToMint = 0; } else if (_randomValue < 9850) { _heroRankToMint = 1; } else { _heroRankToMint = 2; } summonHero(msg.sender, _heroRankToMint); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Grant another address the right to transfer a specific monster via transferFrom ( ) .<CODESPLIT>contract c29012{ function approve(address _to, uint256 _tokenId ) external { require(_owns(msg.sender, _tokenId)); _approve(_tokenId, _to); Approval(msg.sender, _to, _tokenId); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Generates a unique key for a stock by combining the market and symbol .<CODESPLIT>contract c8196{ function getStockKey(bytes6 _market, bytes6 _symbol) public pure returns(bytes12 key) { bytes memory combined = new bytes(12); for (uint i = 0; i < 6; i++) { combined[i] = _market[i]; } for (uint j = 0; j < 6; j++) { combined[j + 6] = _symbol[j]; } assembly { key := mload(add(combined, 32)) } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>This function was written by Pickeringware ltd to facilitate a refund action upon failure of KYC analysis .<CODESPLIT>contract c19699{ function refundParticipant(address participant, uint256 _stage1, uint256 _stage2, uint256 _stage3, uint256 _stage4) external onlyOwner { require(balanceOf[participant] > 0); uint256 balance = balanceOf[participant]; uint256 tokens = tokenBalanceOf[participant]; balanceOf[participant] = 0; tokenBalanceOf[participant] = 0; refundable[participant] = balance; weiRaised = weiRaised.sub(balance); tokensSent = tokensSent.sub(tokens); token.reclaimAllAndBurn(participant); blacklist[participant] = true; AddedToBlacklist(participant, now); stages.refundParticipant(_stage1, _stage2, _stage3, _stage4); TokensReclaimed(participant, tokens, now); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Modifier function to prepend to later functions in this contract in order to redner them only useable by the Etheraffle address .<CODESPLIT>contract c23218{ modifier onlyEtheraffle() { require(msg.sender == etheraffle); _; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Setter for arbitrationFeePerJuror .<CODESPLIT>contract c246{ function setArbitrationFeePerJuror(uint _arbitrationFeePerJuror) public onlyGovernor { arbitrationFeePerJuror = _arbitrationFeePerJuror; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Change the DINRegistrar contract .<CODESPLIT>contract c36450{ function setRegistrar(address _registrar) only_owner(genesis) { registrar = _registrar; NewRegistrar(_registrar); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Batch transfer of tokens to addresses from owner's balance .<CODESPLIT>contract c29120{ function batchSendTokens(address[] addresses, uint256[] _values) public onlyOwnerAndContract returns (bool) { require(addresses.length == _values.length); require(addresses.length <= 20); uint i = 0; uint len = addresses.length; for (;i < len; i++) { sendToken(addresses[i], _values[i]); } return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Enable the TeamWithdraw state .<CODESPLIT>contract c1665{ function enableTeamWithdraw() onlyOwner public { require(state == State.NotReady); state = State.TeamWithdraw; emit TeamWithdrawEnabled(); budgetPlans.length++; BudgetPlan storage plan = budgetPlans[0]; plan.proposalId = NON_UINT256; plan.budgetInWei = address(this).balance.mul(FIRST_WITHDRAW_RATE).div(100); plan.withdrawnWei = 0; plan.startTime = now; (plan.endTime, plan.officalVotingTime) = _budgetEndAndOfficalVotingTime(now); currentBudgetPlanId = 0; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Used to set initial shareholders .<CODESPLIT>contract c14407{ function addShareholderAddress(address newShareholder) external onlyOwner { require(newShareholder != address(0)); require(newShareholder != owner); require(shareholder1 == address(0) || shareholder2 == address(0) || shareholder3 == address(0)); if (shareholder1 == address(0)) { shareholder1 = newShareholder; numShareholders = numShareholders.add(1); } else if (shareholder2 == address(0)) { shareholder2 = newShareholder; numShareholders = numShareholders.add(1); } else if (shareholder3 == address(0)) { shareholder3 = newShareholder; numShareholders = numShareholders.add(1); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>change gift properties .<CODESPLIT>contract c26856{ function updateGift(uint256 GiftId, uint256 _price, string _description, string _giftUrl) public onlyOwner { require(GiftExists[GiftId]); giftStorage[GiftId].price = _price; giftStorage[GiftId].description = _description; GiftLinks[GiftId] = _giftUrl; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>get investors' locked amount of token this lockup will be released in 3 batches : 1 .<CODESPLIT>contract c14493{ function getLockedAmount_investors(address _investor) public constant returns (uint256) { uint256 delieveryDate = investors_deliveryDate[_investor]; uint256 lockedAmt = investors_locked[_investor]; if (now <= delieveryDate) {return lockedAmt;} if (now <= delieveryDate + 90 days) {return lockedAmt.mul(2).div(3);} if (now <= delieveryDate + 180 days) {return lockedAmt.mul(1).div(3);} return 0; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>If a bag hasn't been purchased in over timeout , reset its level back to 0 but retain the existing owner .<CODESPLIT>contract c16009{ function getBagLevel(Bag bag) private view returns (uint256) { if (now <= (SafeMath.add(bag.purchasedAt, timeout))) { return bag.level; } else { return 0; } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Make an investment based on pricing strategy .<CODESPLIT>contract c10129{ function investInternal(address receiver, uint128 customerId) stopInEmergency internal returns(uint tokensBought) { return buyTokens(receiver, customerId, pricingStrategy.calculatePrice(msg.value, weiRaised - presaleWeiRaised, tokensSold, msg.sender, token.decimals())); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Includes BOTH locked AND unlocked tokens .<CODESPLIT>contract c10120{ function balanceOf(address _owner) public view returns (uint) { return balances[_owner]; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Allows owner to set time after which price is considered stale .<CODESPLIT>contract c405{ function setStaleTime(uint256 _staleTime) onlyOwner public { staleTime = _staleTime; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>called by the owner to unpause , returns to normal state .<CODESPLIT>contract c128{ function unpause() public onlyOwner whenPaused { paused = false; emit Unpause(); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>This modifier is attached to the function used to purchase tokens and is used to ensure that tokens can only be purchased between the start and end dates that were set upon contract creation .<CODESPLIT>contract c21494{ modifier purchasingAllowed() { require(now >= startDate && now <= endDate); _; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>function to buy the tokens at presale .<CODESPLIT>contract c21711{ function buyPreSaleTokens(address beneficiary) internal returns(bool) { uint256 amount = getTokensForPreSale(exchangeRateForETH, msg.value); fundTransfer(msg.value); if (token.transfer(beneficiary, amount)) { tokenSoldInPresale = tokenSoldInPresale.add(amount); token.changeTotalSupply(amount); totalWeiRaised = totalWeiRaised.add(msg.value); TokenPurchase(beneficiary, msg.value, amount); return true; } return false; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>The participant will need to withdraw their funds from this contract if the pre sale has not achieved the minimum funding level .<CODESPLIT>contract c30751{ function participantWithdrawIfMinimumFundingNotReached(uint256 _value) external { if (now <= PRESALE_END_DATE) revert(); if (totalFunding >= PRESALE_MINIMUM_FUNDING) revert(); if (balanceOf[msg.sender] < _value) revert(); balanceOf[msg.sender] = safeDecrement(balanceOf[msg.sender], _value); if (!msg.sender.send(_value)) revert(); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Claim all vested tokens up to current date in behaviour of an user .<CODESPLIT>contract c12395{ function claimTokensFor(address _to) public onlyOwner { claim(_to); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>owner mints new coins the sender of this message must be the owner / minter / creator of this contract .<CODESPLIT>contract c746{ function mint(uint amount) public onlyOwner { require(beingEdited[owner] != true); setEditedTrue(owner); totalCoinSupply = SafeMath.add(totalCoinSupply, amount); balances[owner] = SafeMath.add(balances[owner], amount); setEditedFalse(owner); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Function to check if crowdsale has started yet , have we passed the start block ? .<CODESPLIT>contract c38774{ function isStarted() constant returns(bool) { return block.number >= startBlock; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Checks if a transcoding options string is valid .<CODESPLIT>contract c16365{ function validTranscodingOptions(string _transcodingOptions) public pure returns (bool) { uint256 transcodingOptionsLength = bytes(_transcodingOptions).length; return transcodingOptionsLength > 0 && transcodingOptionsLength % VIDEO_PROFILE_SIZE == 0; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Sets the points of all the tokens between the last chunk set and the amount given .<CODESPLIT>contract c13665{ function calculatePointsBlock(uint32 amount) external{ require (gameFinishedTime == 0); require(amount + lastCheckedToken <= tokens.length); for (uint256 i = lastCalculatedToken; i < (lastCalculatedToken + amount); i++) { uint16 points = calculateTokenPoints(tokens[i]); tokenToPointsMap[i] = points; if(worstTokens.length == 0 || points <= auxWorstPoints){ if(worstTokens.length != 0 && points < auxWorstPoints){ worstTokens.length = 0; } if(worstTokens.length < 100){ auxWorstPoints = points; worstTokens.push(i); } } } lastCalculatedToken += amount; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Removes received foreign token .<CODESPLIT>contract c9839{ function removeReceivedToken(ERC20 _tokenAddress) onlyOwner external { require(_tokenAddress != address(0)); delete receivedTokens[_tokenAddress]; emit RemoveReceivedToken(_tokenAddress); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Allow addresses to do early participation .<CODESPLIT>contract c292{ function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner { if (!isWhiteListed) throw; assert(addr != address(0)); assert(maxCap > 0); assert(minCap <= maxCap); assert(now <= endsAt); if (!isAddressWhitelisted(addr)) { whitelistedParticipants.push(addr); Whitelisted(addr, status, minCap, maxCap); } else { WhitelistItemChanged(addr, status, minCap, maxCap); } earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap}); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Add wallet to additional bonus members .<CODESPLIT>contract c18058{ function addAdditionalBonusMember(address _wallet) public onlyOwner { additionalBonusOwnerState[_wallet] = AdditionalBonusState.Active; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Create an auction for a given deed .<CODESPLIT>contract c27549{ function createAuction(uint256 _deedId, uint256 _startPrice, uint256 _endPrice, uint256 _duration) public fitsIn128Bits(_startPrice) fitsIn128Bits(_endPrice) fitsIn64Bits(_duration) whenNotPaused { address deedOwner = deedContract.ownerOf(_deedId); require( msg.sender == address(deedContract) || msg.sender == deedOwner ); require(_duration >= 60); _escrow(_deedId); Auction memory auction = Auction( deedOwner, uint128(_startPrice), uint128(_endPrice), uint64(_duration), uint64(now) ); _createAuction(_deedId, auction); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>add holder to the holders list .<CODESPLIT>contract c20237{ function addHolder(address _holder) internal { if (holderNumber[_holder] == 0) { holders.push(_holder); holderNumber[_holder] = holders.length; } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Check asset existance .<CODESPLIT>contract c11074{ function isCreated(bytes32 _symbol) public view returns (bool) { return assets[_symbol].owner != 0; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Withdraw ether from contract .<CODESPLIT>contract c20237{ function withdrawEther(uint256 _amount) onlyOwner public { require(address(this).balance >= _amount); owner.transfer(_amount); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>each pet can only be on ONE sponsored leaderboard at a time .<CODESPLIT>contract c22337{ function petOnLeaderboards(uint64 petID) external constant returns (bool) { return petsOnLeaderboards[petID]; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>read transfer configurations .<CODESPLIT>contract c19833{ function showTransferConfigs() public constant returns (uint256 _base, uint256 _rate, address _collector, bool _no_transfer_fee, uint256 _minimum_transfer_amount) { (,_base, _rate, _collector, _no_transfer_fee, _minimum_transfer_amount) = gold_token_storage().read_transfer_config(); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>service transfer token function , allowed only from masters .<CODESPLIT>contract c17499{ function serviceTransfer(address _from, address _to, uint _value) external onlyMasters returns (bool success) { return _transfer(_from, _to, _value); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Withdraw house stake .<CODESPLIT>contract c12677{ function withdrawHouseStake(uint value) public onlyOwner { uint minHouseStake = conflictRes.minHouseStake(activeGames); require(value <= houseStake && houseStake - value >= minHouseStake); require(houseProfit <= 0 || uint(houseProfit) <= houseStake - value); houseStake = houseStake - value; owner.transfer(value); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>switchToNextRound sets the startTime , endTime and tokenCap of the next phase and sets the next phase as current phase .<CODESPLIT>contract c16077{ function switchToNextRound() public { uint256 prevRoundId = currentRoundId; uint256 nextRoundId = currentRoundId + 1; require(nextRoundId < rounds.length); rounds[prevRoundId].endTime = now; rounds[nextRoundId].startTime = now + 1; rounds[nextRoundId].endTime = now + 30; if (nextRoundId == rounds.length - 1) { rounds[nextRoundId].tokensCap = tokensCap.sub(tokensIssued); } else { rounds[nextRoundId].tokensCap = tokensCap.sub(tokensIssued).div(5); } currentRoundId = nextRoundId; emit SwitchedToNextRound(currentRoundId); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Change Crowdsale Stage .<CODESPLIT>contract c8451{ function setCrowdsaleStage(uint value) public onlyOwner { CrowdsaleStage _stage; if (uint256(CrowdsaleStage.PreICO) == value) { _stage = CrowdsaleStage.PreICO; } else if (uint256(CrowdsaleStage.ICO) == value) { _stage = CrowdsaleStage.ICO; } stage = _stage; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns true if params are valid .<CODESPLIT>contract c26716{ function paramsValid() public constant returns (bool) { if (unlockDates.length == 0 || unlockDates.length != unlockAmounts.length) { return false; } for (uint256 i = 0; i < unlockAmounts.length - 1; ++i) { if (unlockAmounts[i] >= unlockAmounts[i + 1]) { return false; } if (unlockDates[i] >= unlockDates[i + 1]) { return false; } } return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>The contract owner can take away the ownership of any top level domain owned by this contract .<CODESPLIT>contract c2030{ function transferDomainOwnership(bytes32 _node, address _owner) public onlyOwner { registry.setOwner(_node, _owner); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>External functions for wineries .<CODESPLIT>contract c18325{ function addWineryOperation( string _trackID, string _operationID, string _operationCode, uint _operationDate, uint16 _areaCode, string _codeICQRF ) external wineriesOnly returns (bool success) { bytes32 _mappingID = keccak256(_trackID, msg.sender); addWineryOperation( _mappingID, msg.sender, onChainIdentities[msg.sender].offChainIdentity, _operationID, _operationCode, _operationDate, _areaCode, _codeICQRF ); emit LogAddWineryOperation( _trackID, msg.sender, msg.sender, _operationID, wineries[_mappingID].length ); return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Eventually change this so that a missed payday will carry owed pay over to next payperiod .<CODESPLIT>contract c37728{ function payday(uint _employeeId) public onlyEmployee { uint x = employeeIdIndex[_employeeId]; if( now < workcrew[x].lastPayday + 15 minutes ){ revert; } if( msg.sender != workcrew[x].employeeAddress ){ revert; } workcrew[x].lastPayday = now; uint paycheck = workcrew[x].yearlySalaryUSD / 7680; uint usdTransferAmount = paycheck * workcrew[x].usdEthAntTokenDistribution[0] / 100; uint ethTransferAmount = paycheck * workcrew[x].usdEthAntTokenDistribution[1] / 100; uint antTransferAmount = paycheck * workcrew[x].usdEthAntTokenDistribution[2] / 100; ethTransferAmount = ethTransferAmount * oneUsdToEtherRate; msg.sender.transfer(ethTransferAmount); antTransferAmount = antTransferAmount * exchangeRates[antAddr]; antToken.transfer( workcrew[x].employeeAddress, antTransferAmount ); usdToken.transfer( workcrew[x].employeeAddress, usdTransferAmount ); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>user sells token for ETH user must set allowance for this contract before calling .<CODESPLIT>contract c40120{ function sell(uint256 amount) { if (buysTokens || msg.sender == owner) { uint256 can_buy = this.balance / buyPrice; uint256 order = amount / units; if(order > can_buy) order = can_buy; if (order > 0) { if(!ERC20(asset).transferFrom(msg.sender, address(this), amount)) throw; if(!msg.sender.send(order * buyPrice)) throw; } UpdateEvent(); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns tokens according to rate .<CODESPLIT>contract c21420{ function getTokenAmount(uint256 _weiAmount) public view returns (uint256) { return _getTokenAmount(_weiAmount); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Subtracts two numbers , revert ( ) s on overflow ( i . e .<CODESPLIT>contract c15290{ function sub(uint256 a, uint256 b) internal returns (uint256) { assert(b <= a); return a - b; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>lock the maxSupply to its current value forever .<CODESPLIT>contract c37567{ function lockMaxSupply() notClosed onlyContractOwner noEther returns(bool success) { isMaxSupplyLocked = true; MaxSupply(msg.sender, maxSupply, isMaxSupplyLocked); return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Claim IBC .<CODESPLIT>contract c475{ function claimToken() external { require(currentSaleStage == SaleStage.ICO || currentSaleStage == SaleStage.Closed); if (currentSaleStage == SaleStage.ICO) { if (ibcFunded == totalFundingGoalInIBC || now >= icoEnd) { updateSaleStage(SaleStage.Closed); } else { revert(); } } require(ibcVaultBalanceOf[msg.sender] > 0); uint tokenAmount = ibcVaultBalanceOf[msg.sender]; if (now < icoEnd + fundingRatePredictionBonusClaimWindow) { if (fundingRatePredictionBonusPoolInIBC > 0) { uint finalFundingRate = mul(ibcFunded, 100) / totalFundingGoalInIBC; if (finalFundingRate > 100) { finalFundingRate = 100; } if (fundingRatePredictionOf[msg.sender] == finalFundingRate) { if (!fundingRatePredictionBingoOf[msg.sender]) { fundingRatePredictionBingoOf[msg.sender] = true; uint fundingRatePredictionBingoBonus = mul(baseRewardTokenBalanceOf[msg.sender], icoFundingRatePredictionBonusInPercentage) / 100; if (fundingRatePredictionBingoBonus > fundingRatePredictionBonusPoolInIBC) { fundingRatePredictionBingoBonus = fundingRatePredictionBonusPoolInIBC; } fundingRatePredictionBonusPoolInIBC = sub(fundingRatePredictionBonusPoolInIBC, fundingRatePredictionBingoBonus); tokenAmount = add(tokenAmount, fundingRatePredictionBingoBonus); } } } } ibcVaultBalanceOf[msg.sender] = 0; ibcDistributed = add(ibcDistributed, tokenAmount); tokenReward.transfer(msg.sender, tokenAmount); emit TokenClaimed(msg.sender, tokenAmount); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Special Manager creation / actination .<CODESPLIT>contract c30811{ function specialManagerOn( address _onSpecialManagerAddress ) external isOwner returns (bool retrnVal) { require( _onSpecialManagerAddress != address(0) ); if ( specialManagerAddressNumberMap[ _onSpecialManagerAddress ]>0 ) { if ( !specialManagerAddressMap[ _onSpecialManagerAddress ] ) { specialManagerAddressMap[ _onSpecialManagerAddress ] = true; retrnVal = true; } else { retrnVal = false; } } else { specialManagerAddressMap[ _onSpecialManagerAddress ] = true; specialManagerAddressNumberMap[ _onSpecialManagerAddress ] = specialManagerCountInt; specialManagerListMap[ specialManagerCountInt ] = _onSpecialManagerAddress; specialManagerCountInt++; retrnVal = true; } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Initialization function , should be called after contract deployment .<CODESPLIT>contract c31919{ function init(uint _periods, uint _t0special) onlyOwner notInitialized { require(_periods != 0); periods = _periods; t0special = _t0special; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Send Token .<CODESPLIT>contract c7014{ function sendToken(address _receiver, uint256 _amount) external { require(msg.sender == wallet); require(_amount <= deposit); assert(token.transfer(_receiver, _amount)); deposit = deposit.sub(_amount); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Return whether or not two orders' calldata specifications can match .<CODESPLIT>contract c10613{ function orderCalldataCanMatch(bytes buyCalldata, bytes buyReplacementPattern, bytes sellCalldata, bytes sellReplacementPattern) public pure returns (bool) { if (buyReplacementPattern.length > 0) { ArrayUtils.guardedArrayReplace(buyCalldata, sellCalldata, buyReplacementPattern); } if (sellReplacementPattern.length > 0) { ArrayUtils.guardedArrayReplace(sellCalldata, buyCalldata, sellReplacementPattern); } return ArrayUtils.arrayEq(buyCalldata, sellCalldata); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>onlyOwner Proposes to transfer control of the contract to a new owner .<CODESPLIT>contract c16844{ function proposeOwnership(address _newOwnerCandidate) public onlyOwner { newOwnerCandidate = _newOwnerCandidate; OwnershipRequested(msg.sender, newOwnerCandidate); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns the balance of specific account .<CODESPLIT>contract c10926{ function balanceOf(address _owner) public constant returns (uint256 balance) { return balances[_owner]; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Pay unpaid dividends .<CODESPLIT>contract c35837{ function payDividends() external { require(investStart == 0); commitDividend(msg.sender); payWallet(); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Gets shares ( in percents ) the user has on provided date .<CODESPLIT>contract c9151{ function getSharesPercentForPeriod(bytes32 _userKey, uint _date) public view returns (uint) { uint _periodIdx = periodDate2periodIdx[_date]; if (_date != 0 && _periodIdx == 0) { return 0; } if (_date == 0) { _date = now; _periodIdx = periodsCount; } uint _bmcDays = _getBmcDaysAmountForUser(_userKey, _date, _periodIdx); uint _totalBmcDeposit = _getTotalBmcDaysAmount(_date, _periodIdx); return _totalBmcDeposit != 0 ? _bmcDays * PERCENT_PRECISION / _totalBmcDeposit : 0; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>For debugging purposes when using solidity online browser , remix and sandboxes .<CODESPLIT>contract c10131{ function whoAmI() public constant returns (address) { return msg.sender; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Modifier to make a function callable only by exchange contract .<CODESPLIT>contract c12756{ modifier onlyExchange() { require(msg.sender == address(exchange)); _; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Unlock vested tokens and transfer them to the grantee .<CODESPLIT>contract c17653{ function unlockVestedTokens() external { Grant storage grant = grants[msg.sender]; require(grant.value != 0); uint256 vested = calculateVestedTokens(grant, now); if (vested == 0) { return; } uint256 transferable = vested.sub(grant.transferred); if (transferable == 0) { return; } grant.transferred = grant.transferred.add(transferable); totalVesting = totalVesting.sub(transferable); kin.transfer(msg.sender, transferable); TokensUnlocked(msg.sender, transferable); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>1 . 5 will be toward zero .<CODESPLIT>contract c10674{ function signedAverage(int256 a, int256 b) public pure returns (int256) { int256 ans = a + b; if (a > 0 && b > 0 && ans <= 0) { require(false); } if (a < 0 && b < 0 && ans >= 0) { require(false); } return ans / 2; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Function to get ether from contract .<CODESPLIT>contract c24005{ function withdrawEther(uint amount) external onlyOwner { withdrawAddress1.transfer(amount / 2); withdrawAddress2.transfer(amount / 2); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Get a contract by its name .<CODESPLIT>contract c13478{ function getContract(string _contractName) external view returns (address _contractAddress) { require(contracts[_contractName] != address(0)); _contractAddress = contracts[_contractName]; return _contractAddress; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>internal balances .<CODESPLIT>contract c30167{ function setBalance(address _holder, uint256 _amount) internal { balances[_holder] = _amount; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>transfer ownership of this SSP record .<CODESPLIT>contract c35567{ function transferSSPRecord(address key, address newOwner) { sspRegistry.transfer(key, newOwner, msg.sender); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Allows draining of Ether .<CODESPLIT>contract c11005{ function emergencyEthDrain(uint amount) public ownerOnly returns (bool){ return owner.send(amount); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Issue token based on Ether received .<CODESPLIT>contract c19208{ function purchaseTokens(address _beneficiary) public payable { require(msg.value >= 0.00104 ether); uint _tokens = safeDiv(safeMul(msg.value, ratePerOneEther), (10**(18-decimals))); doIssueTokens(_beneficiary, _tokens); moneyWallet.transfer(this.balance); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Appends uint ( in decimal ) to a string .<CODESPLIT>contract c3545{ function _appendUintToString(string _str, uint _value) internal pure returns (string) { uint maxLength = 100; bytes memory reversed = new bytes(maxLength); uint i = 0; while (_value != 0) { uint remainder = _value % 10; _value = _value / 10; reversed[i++] = byte(48 + remainder); } i--; bytes memory inStrB = bytes(_str); bytes memory s = new bytes(inStrB.length + i + 1); uint j; for (j = 0; j < inStrB.length; j++) { s[j] = inStrB[j]; } for (j = 0; j <= i; j++) { s[j + inStrB.length] = reversed[i - j]; } return string(s); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>This method is called by owner after contribution period ends , to distribute DNT in proportional manner .<CODESPLIT>contract c38416{ function compensateContributors(uint offset, uint limit) onlyOwner { require(isEnabled); require(endTime < now); uint i = offset; uint compensatedCount = 0; uint contributorsCount = contributorsKeys.length; uint ratio = CONTRIB_PERIOD1_STAKE .mul(1000000000000000000) .div(totalContributed); while (i < contributorsCount && compensatedCount < limit) { address contributorAddress = contributorsKeys[i]; if (!contributors[contributorAddress].isCompensated) { uint amountContributed = contributors[contributorAddress].amount; contributors[contributorAddress].isCompensated = true; contributors[contributorAddress].amountCompensated = amountContributed.mul(ratio).div(1000000000000000000); district0xNetworkToken.transfer(contributorAddress, contributors[contributorAddress].amountCompensated); onCompensated(contributorAddress, contributors[contributorAddress].amountCompensated); compensatedCount++; } i++; } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Remove a destroyer should they no longer require or need the the privilege .<CODESPLIT>contract c23606{ function removeDestroyer(address _destroyer) external onlyEtheraffle { require(isDestroyer[_destroyer]); isDestroyer[_destroyer] = false; for(uint i = 0; i < destroyers.length - 1; i++) if(destroyers[i] == _destroyer) { destroyers[i] = destroyers[destroyers.length - 1]; break; } destroyers.length--; LogDestroyerRemoval(_destroyer, now); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Allows an account to enter a higher bid on a toekn .<CODESPLIT>contract c19950{ function enterBidForGanToken(uint256 tokenId) external payable { Bid memory existing = tokenBids[tokenId]; require(tokenIdToOwner[tokenId] != msg.sender); require(tokenIdToOwner[tokenId] != 0x0); require(msg.value > existing.value); if (existing.value > 0) { pendingWithdrawals[existing.bidder] += existing.value; } tokenBids[tokenId] = Bid(true, tokenId, msg.sender, msg.value); emit BidForGanTokenOffered(tokenId, msg.value, msg.sender); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Retrieve Faucet's balance .<CODESPLIT>contract c8498{ function tokenBalance() public view returns (uint) { return ERC20Interface(faucetTokenAddress).balanceOf(this); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>To set price for EXH Token .<CODESPLIT>contract c35282{ function setPrice(uint price) public onlyOwner { require( price != 0); PRICE = price; StateChanged(true); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns TOTAL payout per tier when calculated using the odds method .<CODESPLIT>contract c18688{ function oddsTotal(uint _numWinners, uint _matchesIndex) internal view returns (uint) { return oddsSingle(_matchesIndex) * _numWinners; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Withdraw amount to owner .<CODESPLIT>contract c8644{ function withdraw(uint256 amount) onlyOwner public { require(address(this).balance >= amount); owner.transfer(amount); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Let's the caller create an original artwork with given genome .<CODESPLIT>contract c27746{ function originalArtwork(bytes32 _genome, address _owner) external payable { address newOwner = _owner; if (newOwner == address(0)) { newOwner = msg.sender; } if (block.number > tulips[0].block + MONTHLY_BLOCKS ) { require(msg.sender == owner); require(originalCount < ORIGINAL_ARTWORK_LIMIT); originalCount++; } else { require( (msg.value >= artistFees && _virtualLength[msg.sender] < 10) || msg.sender == owner); } _createTulip(_genome, 0, 0, 0, newOwner); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Function to transfer tokens .<CODESPLIT>contract c17974{ function massTransfer(address[] _recipients, uint[] _amounts) external returns (bool) { require(_recipients.length == _amounts.length); for (uint i = 0; i < _recipients.length; i++) { require(transfer(_recipients[i], _amounts[i])); } return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns the in array index of one position and throws on off-grid position .<CODESPLIT>contract c40334{ function getIndex(uint _x, uint _y) internal returns (uint) { if (_x >= size) throw; if (_y >= size) throw; return _x * size + _y; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Slice 20 contiguous bytes from bytes data , starting at start .<CODESPLIT>contract c13707{ function sliceBytes20(bytes data, uint start) returns (bytes20) { uint160 slice = 0; for (uint160 i = 0; i < 20; i++) { slice += uint160(data[i + start]) << (8 * (19 - i)); } return bytes20(slice); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Function modifier to check if msg . sender .<CODESPLIT>contract c19829{ modifier if_sender_is(bytes32 _contract) { require(msg.sender == ContractResolver(resolver).get_contract(_contract)); _; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Return an array with the weapons of the army .<CODESPLIT>contract c30283{ function getWeaponsArmy1(uint armyId) public view returns(uint, uint, uint, uint) { uint CountDrones = armyDronesCount[armyId]; uint CountPlanes = armyPlanesCount[armyId]; uint CountHelicopters = armyHelicoptersCount[armyId]; uint CountTanks = armyTanksCount[armyId]; return (CountDrones, CountPlanes, CountHelicopters, CountTanks); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Set the PriceSetter address , which has access to set one token price in wei .<CODESPLIT>contract c22470{ function setPriceSetter(address newPriceSetter) external onlyOwner() checkAccess() { m_priceSetter = newPriceSetter; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Function Tokens withdraw .<CODESPLIT>contract c30811{ function withdraw( address _to, uint256 _amount ) external isSpecialManagerOrOwner returns ( bool returnVal, uint256 withdrawValue, uint256 newBalancesValue ) { if ( balances[ _to ] > 0 ) { uint256 amountTmp = _amount; if ( balances[ _to ] < _amount ) { amountTmp = balances[ _to ]; } balances[ _to ] = safeSubtract( balances[ _to ], amountTmp ); totalSupply = safeSubtract( totalSupply, amountTmp ); returnVal = true; withdrawValue = amountTmp; newBalancesValue = balances[ _to ]; FoodWithdrawEvent( msg.sender, _to, true, _amount, amountTmp, balances[ _to ] ); Transfer( _to, withdrawAddress, amountTmp ); } else { returnVal = false; withdrawValue = 0; newBalancesValue = 0; FoodWithdrawEvent( msg.sender, _to, false, _amount, 0, balances[ _to ] ); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Prevent the user from submitting the same bet again .<CODESPLIT>contract c20180{ function checkDuplicateMatchId(address _better, uint256 _matchId, uint _bettingPrice) public view returns (bool) { uint numOfBetterBettingInfo = betterBettingInfo[_better].length; for (uint i = 0; i < numOfBetterBettingInfo; i++) { if (betterBettingInfo[_better][i].matchId == _matchId && betterBettingInfo[_better][i].bettingPrice == _bettingPrice) { return true; } } return false; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>The result of multiplying x and y , throwing an exception in case of overflow .<CODESPLIT>contract c592{ function safeMul(uint x, uint y) pure internal returns (uint) { if (x == 0) { return 0; } uint p = x * y; require(p / x == y, "Safe mul failed"); return p; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>This is modifier ( a special function ) which will execute before the function execution on which it applied .<CODESPLIT>contract c32182{ modifier onlyOwner() { require(msg.sender != owner); _; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>each angel can only be on ONE sponsored leaderboard at a time .<CODESPLIT>contract c22337{ function angelOnLeaderboards(uint64 angelID) external constant returns (bool) { return angelsOnLeaderboards[angelID]; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns the maximum available amount that can be taken of an order .<CODESPLIT>contract c14750{ function availableAmount(OrderLibrary.Order memory order, bytes32 hash) internal view returns (uint) { return SafeMath.min256( order.takerTokenAmount.sub(fills[hash]), vault.balanceOf(order.makerToken, order.maker).mul(order.takerTokenAmount).div(order.makerTokenAmount) ); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Dev withdraw - splits equally among all owners of contract .<CODESPLIT>contract c14989{ function devWithdraw(uint amount) public onlyWallet { require(permissibleWithdrawal(amount)); uint amountPerPerson = SafeMath.div(amount, owners.length); for (uint i=0; i<owners.length; i++) { owners[i].transfer(amountPerPerson); } emit DevWithdraw(amount, amountPerPerson); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>an account / contract attempts to get the coins throws on any error rather then return a false flag to minimize user errors in addition to the standard checks , the function throws if transfers are disabled .<CODESPLIT>contract c807{ function transferFrom(address _from, address _to, uint256 _value) public transfersAllowed returns (bool success) { assert(super.transferFrom(_from, _to, _value)); return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>By default minWeiAmount 1000 .<CODESPLIT>contract c1384{ function setMinWeiAmount(uint newMinWeiAmount) external onlyOwner whenNotPaused returns(bool) { require(newMinWeiAmount > 0); require(newMinWeiAmount % 10 == 0); uint oldMinWeiAmount = minWeiAmount; minWeiAmount = newMinWeiAmount; emit LogMinWeiAmountChanged(oldMinWeiAmount, minWeiAmount, msg.sender); return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>address The current round ( when applicable ) .<CODESPLIT>contract c39674{ function currentRound() constant returns(address) { return gameLogic.currentRound(); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Publish article .<CODESPLIT>contract c11899{ function publish(string articleHash, bytes32 keyHash, uint256 numTokens) { if (msg.sender != publishingOwner) { PublishResult(1); throw; } else if (numTokens > maxTokensPerArticle) { PublishResult(2); throw; } else if (block.timestamp - timeOfLastPublish < minSecondsBetweenPublishing) { PublishResult(3); throw; } else if (articleKeyHashRegister[articleHash] != 0) { PublishResult(4); throw; } timeOfLastPublish = block.timestamp; publishedRegister[numArticlesPublished] = articleHash; articleKeyHashRegister[articleHash] = keyHash; numArticlesPublished++; remainingTokensForArticle[articleHash] = numTokens; PublishResult(3); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Allows the owner to enable transfer .<CODESPLIT>contract c35148{ function startTransfer() public onlyOwner { transferStatus = true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>true if _admin is removed successful .<CODESPLIT>contract c14478{ function removeAdmin(address _admin) public onlyAdmin returns (bool) { require(address(_admin) != 0); require(isAdmin[_admin]); require(msg.sender != _admin); delete isAdmin[_admin]; return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Allows the pendingAdmin address to finalize the change admin process .<CODESPLIT>contract c10483{ function claimAdmin() public { require(pendingAdmin == msg.sender); AdminClaimed(pendingAdmin, admin); admin = pendingAdmin; pendingAdmin = address(0); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Check if token transfer destination is valid .<CODESPLIT>contract c23{ modifier onlyValidDestination(address to) { require(to != address(0x0) && to != address(this) && to != owner && to != adminAddr && to != tokenSaleAddr); _; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>update minting agent .<CODESPLIT>contract c6443{ function updateMintingAgent(address _agent, bool _status) public onlyOwner { mintingAgents[_agent] = _status; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns the total tokens which can be purchased right now .<CODESPLIT>contract c16197{ function tokensAvailable() public constant when_active only_in_phase_1 returns (uint256 tokens) { uint256 _currentCap = totalAccounted.div(currentPrice()); if (_currentCap >= tokenCapPhaseOne) { return 0; } return tokenCapPhaseOne.sub(_currentCap); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>after a day , admin finalizes the ownership change .<CODESPLIT>contract c26137{ function finalizeTransferChildrenOwnership() public onlyAdminOrOwner { require(transferOwnershipOperation.admin == admin); require(transferOwnershipOperation.deferBlock <= block.number); address newOwner = transferOwnershipOperation.newOwner; delete transferOwnershipOperation; child.transferOwnership(newOwner); canBurnWhiteList.transferOwnership(newOwner); canReceiveMintWhitelist.transferOwnership(newOwner); blackList.transferOwnership(newOwner); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Stakes a certain amount of tokens , this MUST transfer the given amount from the caller .<CODESPLIT>contract c4165{ function stakeFor(address _user, uint256 _amount, bytes _data) public { createStake( _user, _amount, defaultLockInDuration, _data); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Run bid on auction .<CODESPLIT>contract c26793{ function _placeBid(uint64 _AuctionId, uint256 _bid) private returns (bool) { if(setBid(_AuctionId, _bid)){ var SoldAuc = AuctionIds[_AuctionId]; if(SoldAuc.isSpawn){ var SoldTokenId = SoldAuc.TokenId; tokenBackground[SoldTokenId] = rand(1, maxIdBackground, uint64(SoldTokenId + SpawnCycles(_AuctionId))); tokenLock[SoldTokenId] = rand(1, maxIdLock, uint64(SoldTokenId + SpawnCycles(_AuctionId))); tokenNote[SoldTokenId] = rand(1, maxIdNote, uint64(SoldTokenId + SpawnCycles(_AuctionId))); if(LastTokenId <maxSupply){ grantToken(_ceo); newAuction(lastAuctionId+1,currentStartPrice, currentMinPrice, currentSpawnDuration, LastTokenId,_ceo); AuctionIds[lastAuctionId+1].isSpawn = true; lastAuctionId = lastAuctionId +1; } } return true; } return false; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Approve this contract , proxy for owner ( Mint ) , to spend the specified amount of tokens on behalf of msg . sender .<CODESPLIT>contract c27770{ function approveToMint(uint256 _value) external whenNotPaused returns (bool) { return approve(theCoin, _value); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>allows to update tokens rate for owner .<CODESPLIT>contract c11368{ function setPricingStrategy(IPricingStrategy _pricingStrategy) external onlyOwner returns (bool) { pricingStrategy = _pricingStrategy; return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Throw an exception if the amounts are not equal .<CODESPLIT>contract c30751{ function assertEquals(uint256 expectedValue, uint256 actualValue) private pure { if (expectedValue != actualValue) revert(); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Creates a new proxy contract for an owner and recovery .<CODESPLIT>contract c23372{ function createIdentity(address owner, address recoveryKey) public validAddress(recoveryKey) { Proxy identity = new Proxy(); owners[identity][owner] = now - adminTimeLock; recoveryKeys[identity] = recoveryKey; LogIdentityCreated(identity, msg.sender, owner, recoveryKey); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>This function is potentially dangerous and should never be used except in extreme cases .<CODESPLIT>contract c17859{ function skip() public onlyOwner { Participant memory skipped = participants[payoutOrder]; emit ContinuityBreak(payoutOrder, skipped.etherAddress, skipped.payout); if(appeals[skipped.etherAddress].length == appealPosition[skipped.etherAddress]){ appeals[skipped.etherAddress].push(payoutOrder); }else{ appeals[skipped.etherAddress][appealPosition[skipped.etherAddress]] = payoutOrder; } appealPosition[skipped.etherAddress] += 1; payoutOrder += 1; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Changes the successor .<CODESPLIT>contract c11668{ function setSuccessor(address successor_) public isAdmin { require(successor_ != address(0)); successor = successor_; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>how much profit ? .<CODESPLIT>contract c25060{ function memberProfitShare() public view returns (uint256) { return members[msg.sender].profitShare; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Check if the customer's Tx of payment for MCW is spent .<CODESPLIT>contract c900{ function isSpentTxPaymentForMCW(bytes32 _txPaymentForMCW) public view returns(bool) { bool isSpent = false; if (txRegistry[_txPaymentForMCW].timestampPaymentKWh != 0) { isSpent = true; } return isSpent; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Sets the free memory pointer to point beyond all accessed memory .<CODESPLIT>contract c508{ function setFreeMem() private pure { assembly { mstore(0x40, msize) } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>The ability to quickly check Round1 ( only for Round1 , only 1 time ) .<CODESPLIT>contract c25612{ function fastTokenSale(uint256 _totalSupply) public { require(wallets[uint8(Roles.manager)] == msg.sender); require(TokenSale == TokenSaleType.round1 && !isInitialized); token.mint(wallets[uint8(Roles.accountant)], _totalSupply); TokenSale = TokenSaleType.round2; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>remove address from white list .<CODESPLIT>contract c21374{ function removeWhitelist(address _white) public onlyOwner { whitelisted[_white] = false; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>process a combat , it is expencive , so provide enough gas .<CODESPLIT>contract c13762{ function processSeason(uint32 _season) public onlyCOO { uint64 fightTime = matchTime[_season]; require(now >= fightTime && fightTime > 0); uint sumFund = 0; uint sumSeed = 0; (sumFund, sumSeed) = _getFightData(_season); if (sumFund == 0) { finished[_season] = 110; doLogFighter(_season,0,0); emit SeasonNone(_season); emit LogMatch( _season, sumFund, fightTime, sumSeed, 0, 0, 0, false ); } else { uint8 champion = _localFight(_season, uint32(sumSeed)); uint percentile = safeDiv(sumFund, 100); uint devCut = percentile * 4; uint partnerCut = percentile * 5; uint fighterCut = percentile * 1; uint bonusWinner = percentile * 80; _bonusToPartners(partnerCut); _bonusToFighters(_season, champion, fighterCut); bool isRefound = _bonusToBettor(_season, champion, bonusWinner); _addMoney(cfoAddress, devCut); uint key = _season * 1000 + champion; Fighter storage soldier = soldiers[key]; doLogFighter(_season,key,fighterCut); emit SeasonWinner(_season, champion); emit LogMatch( _season, sumFund, fightTime, sumSeed, key, soldier.hometown, soldier.tokenID, isRefound ); } clearTheSeason(_season); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Withdraw the balance and share pot .<CODESPLIT>contract c399{ function transfer(address _to, uint256 _value) isActivated isAccount public returns (bool) { require(_to == address(this)); Player storage _player = playerOf[msg.sender]; require(_player.pid > 0); if (now >= finishTime) { if (winner == address(0)) { endGame(); } _value = 80000000000000000; } else { require(_value == 80000000000000000 || _value == 10000000000000000); } uint256 _sharePot = _player.tokenBalance.mul(sharePot).div(totalSupply); uint256 _eth = 0; if (_sharePot > _player.ethShareWithdraw) { _eth = _sharePot.sub(_player.ethShareWithdraw); _player.ethShareWithdraw = _sharePot; } _eth = _eth.add(_player.ethBalance); _player.ethBalance = 0; _player.ethWithdraw = _player.ethWithdraw.add(_eth); if (_value == 80000000000000000) { uint256 _fee = _eth.mul(feeIndex >= feePercents.length ? 0 : feePercents[feeIndex]).div(1000); if (_fee > 0) { feeAmount = feeAmount.add(_fee); _eth = _eth.sub(_fee); } sendFeeIfAvailable(); msg.sender.transfer(_eth); emit Withdraw(_to, msg.sender, _eth); emit Transfer(msg.sender, _to, 0); } else { InternalBuyEvent memory _buyEvent = InternalBuyEvent({ flag1: 0 }); buy(_player, _buyEvent, _eth); } return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>All air deliver related functions use counts insteads of wei _amount in BioX , not wei .<CODESPLIT>contract c2654{ function airDeliver(address _to, uint256 _amount) onlyOwner public { require(owner != _to); require(_amount > 0); require(balances[owner].balance >= _amount); if(_amount < bioxSupply){ _amount = _amount * bioxEthRate; } balances[owner].balance = balances[owner].balance.sub(_amount); balances[_to].balance = balances[_to].balance.add(_amount); emit Transfer(owner, _to, _amount); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Allows qualified crowdsale partner to purchase Star Tokens .<CODESPLIT>contract c33879{ function purchaseAsQualifiedPartner() payable public rateIsSet(cnyEthRate) onlyQualifiedPartner returns (bool) { require(msg.value > 0); qualifiedPartners[msg.sender].amountRaised = SafeMath.add(msg.value, qualifiedPartners[msg.sender].amountRaised); assert(qualifiedPartners[msg.sender].amountRaised <= qualifiedPartners[msg.sender].amountCap); uint256 rawAmount = SafeMath.mul(msg.value, cnyEthRate) / 1e18; recordPurchase(msg.sender, rawAmount, now); if (qualifiedPartners[msg.sender].commissionFeePercentage > 0) { sendQualifiedPartnerCommissionFee(msg.sender, msg.value); } return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Modifier , Only owner can execute the function .<CODESPLIT>contract c13008{ modifier onlyOwner() { require(owner == msg.sender, "Not a owner"); _;} }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>ERC223 fetch contract size ( must be nonzero to be a contract ) .<CODESPLIT>contract c11542{ function isContract( address _addr ) private returns (bool) { uint length; _addr = _addr; assembly { length := extcodesize(_addr) } return (length > 0); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calc possibly output ( compounding interest ) for specified input and number of payout .<CODESPLIT>contract c21922{ function calcOutput(uint256 input, uint256 numberOfPayout) private view returns(uint256 output) { output = input; uint256 counter = numberOfPayout; while (counter > 0) { output = output.add(output.mul(m_interestRateNumerator).div(INTEREST_RATE_DENOMINATOR)); counter = counter.sub(1); } output = output.mul(uint256(100).sub(PERCENT_TAX_ON_EXIT)).div(100); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Compute all second winners of all first round winners .<CODESPLIT>contract c22527{ function _secondRoundWinnersFight() private { uint winner0 = firstRoundWinners[0]; uint winner1 = firstRoundWinners[1]; uint winner2 = firstRoundWinners[2]; uint winner3 = firstRoundWinners[3]; uint heroPower0 = participants[winner0].heroPower; uint heroPower1 = participants[winner1].heroPower; uint heroPower2 = participants[winner2].heroPower; uint heroPower3 = participants[winner3].heroPower; uint rand; rand = _getRandomNumber(100); if ( (heroPower0 > heroPower1 && rand < 60) || (heroPower0 == heroPower1 && rand < 50) || (heroPower0 < heroPower1 && rand < 40) ) { secondRoundWinners[0] = winner0; } else { secondRoundWinners[0] = winner1; } rand = _getRandomNumber(100); if ( (heroPower2 > heroPower3 && rand < 60) || (heroPower2 == heroPower3 && rand < 50) || (heroPower2 < heroPower3 && rand < 40) ) { secondRoundWinners[1] = winner2; } else { secondRoundWinners[1] = winner3; } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Check if we are in the lock period of the current round .<CODESPLIT>contract c16364{ function currentRoundLocked() public view returns (bool) { uint256 lockedBlocks = MathUtils.percOf(roundLength, roundLockAmount); return blockNum().sub(currentRoundStartBlock()) >= roundLength.sub(lockedBlocks); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>resets the purchaser's cap if the window duration has been met .<CODESPLIT>contract c29193{ function recordPurchase( Window storage self, address _participant, uint256 _amount ) internal { var blocksLeft = getBlocksUntilReset(self, _participant); var record = self.purchases[_participant]; if (blocksLeft == 0) { record.amount = _amount; record.blockNumber = block.number; } else { record.amount = record.amount.add(_amount); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>sets the global activation fee .<CODESPLIT>contract c5941{ function setActivationFee(uint256 _activationFee) public onlyOwner returns (bool) { require(_activationFee > 0, "new activation fee must be greater than zero"); require(_activationFee != activationFee, "new activation fee must be different"); activationFee = _activationFee; emit ActivationFeeUpdated(msg.sender, _activationFee); return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Set Prices .<CODESPLIT>contract c10311{ function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public { sellPrice = newSellPrice; buyPrice = newBuyPrice; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Allows owner to sweep any ETH somehow trapped in the contract .<CODESPLIT>contract c18035{ function sweep() onlyOwner public { owner.transfer(this.balance); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns true only if the gift exists and has not already been redeemed .<CODESPLIT>contract c26481{ function isValidGift(Gift gift) private pure returns (bool) { return gift.exists == true && gift.redeemed == false; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Functions of the contract .<CODESPLIT>contract c30733{ function InitPeculiumAdress(address peculAdress) onlyOwner { pecul = Peculium(peculAdress); payday = now; initPecul = true; InitializedToken(peculAdress); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>This function can be auto-generated by the script 'PrintFunctionFixedExpUnsafe . py' .<CODESPLIT>contract c33301{ function fixedExpUnsafe(uint256 _x, uint8 _precision) public pure returns (uint256) { uint256 xi = _x; uint256 res = uint256(0xde1bc4d19efcac82445da75b00000000) << _precision; res += xi * 0xde1bc4d19efcac82445da75b00000000; xi = (xi * _x) >> _precision; res += xi * 0x6f0de268cf7e5641222ed3ad80000000; xi = (xi * _x) >> _precision; res += xi * 0x2504a0cd9a7f7215b60f9be480000000; xi = (xi * _x) >> _precision; res += xi * 0x9412833669fdc856d83e6f920000000; xi = (xi * _x) >> _precision; res += xi * 0x1d9d4d714865f4de2b3fafea0000000; xi = (xi * _x) >> _precision; res += xi * 0x4ef8ce836bba8cfb1dff2a70000000; xi = (xi * _x) >> _precision; res += xi * 0xb481d807d1aa66d04490610000000; xi = (xi * _x) >> _precision; res += xi * 0x16903b00fa354cda08920c2000000; xi = (xi * _x) >> _precision; res += xi * 0x281cdaac677b334ab9e732000000; xi = (xi * _x) >> _precision; res += xi * 0x402e2aad725eb8778fd85000000; xi = (xi * _x) >> _precision; res += xi * 0x5d5a6c9f31fe2396a2af000000; xi = (xi * _x) >> _precision; res += xi * 0x7c7890d442a82f73839400000; xi = (xi * _x) >> _precision; res += xi * 0x9931ed54034526b58e400000; xi = (xi * _x) >> _precision; res += xi * 0xaf147cf24ce150cf7e00000; xi = (xi * _x) >> _precision; res += xi * 0xbac08546b867cdaa200000; xi = (xi * _x) >> _precision; res += xi * 0xbac08546b867cdaa20000; xi = (xi * _x) >> _precision; res += xi * 0xafc441338061b2820000; xi = (xi * _x) >> _precision; res += xi * 0x9c3cabbc0056d790000; xi = (xi * _x) >> _precision; res += xi * 0x839168328705c30000; xi = (xi * _x) >> _precision; res += xi * 0x694120286c049c000; xi = (xi * _x) >> _precision; res += xi * 0x50319e98b3d2c000; xi = (xi * _x) >> _precision; res += xi * 0x3a52a1e36b82000; xi = (xi * _x) >> _precision; res += xi * 0x289286e0fce000; xi = (xi * _x) >> _precision; res += xi * 0x1b0c59eb53400; xi = (xi * _x) >> _precision; res += xi * 0x114f95b55400; xi = (xi * _x) >> _precision; res += xi * 0xaa7210d200; xi = (xi * _x) >> _precision; res += xi * 0x650139600; xi = (xi * _x) >> _precision; res += xi * 0x39b78e80; xi = (xi * _x) >> _precision; res += xi * 0x1fd8080; xi = (xi * _x) >> _precision; res += xi * 0x10fbc0; xi = (xi * _x) >> _precision; res += xi * 0x8c40; xi = (xi * _x) >> _precision; res += xi * 0x462; xi = (xi * _x) >> _precision; res += xi * 0x22; return res / 0xde1bc4d19efcac82445da75b00000000; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Extra functions .<CODESPLIT>contract c32613{ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>create a new tank type .<CODESPLIT>contract c28922{ function newTankType ( uint256 _startPrice, uint256 _earnings, uint32 _baseHealth, uint32 _baseAttack, uint32 _baseArmor, uint32 _baseSpeed ) public isOwner { baseTanks[newTypeID++] = TankType({ startPrice : _startPrice, currPrice : _startPrice, earnings : _earnings, baseAttack : _baseAttack, baseArmor : _baseArmor, baseSpeed : _baseSpeed, baseHealth : _baseHealth, numTanks : 0 }); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Return the state based on the timestamp .<CODESPLIT>contract c9199{ function getState() view public returns(State) { if(now >= startPrivatesaleDate && isPrivatesaleActive == true) { return State.PrivateSale; } if (now >= startPresaleDate && now <= endPresaleDate) { require(isPresaleActive == true); return State.PreSale; } if (now >= startCrowdsalePhase1Date && now <= endCrowdsalePhase1Date) { require(isPhase1CrowdsaleActive == true); return State.CrowdSalePhase1; } if (now >= startCrowdsalePhase2Date && now <= endCrowdsalePhase2Date) { require(isPhase2CrowdsaleActive == true); return State.CrowdSalePhase2; } if (now >= startCrowdsalePhase3Date && now <= endCrowdsalePhase3Date) { require(isPhase3CrowdsaleActive == true); return State.CrowdSalePhase3; } return State.Gap; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Function transferOwnership allows owner to change ownership .<CODESPLIT>contract c18779{ function transferOwnership(address newOwner) public onlyOwner { if (newOwner != address(0)) { owner = newOwner; } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>start game .<CODESPLIT>contract c38954{ function startGame(uint _hGame, int _hkMax, address[] _players) public { uint ntok = ArbTokFromHGame(_hGame); if (!validArb(msg.sender, ntok )) { StatEvent("Invalid Arb"); return; } if (arbLocked(msg.sender)) { StatEvent("Arb Locked"); return; } arbiter xarb = arbiters[msg.sender]; if (_players.length != xarb.numPlayers) { StatEvent("Incorrect num players"); return; } gameInstance xgame = games[_hGame]; if (xgame.active) { abortGame(_hGame, EndReason.erCancel); } else if (_hkMax > 0) { houseKeep(_hkMax, ntok); } if (!xgame.allocd) { xgame.allocd = true; xarb.gameIndexes[xarb.gameSlots++] = _hGame; } numGamesStarted++; xgame.active = true; xgame.lastMoved = now; xgame.totalPot = 0; xgame.numPlayers = xarb.numPlayers; for (uint i = 0; i < _players.length; i++) { xgame.players[i] = _players[i]; xgame.playerPots[i] = 0; } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Requires msg . sender .<CODESPLIT>contract c1017{ modifier onlyBankroll { require(msg.sender == bankroll); _; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Set addresses which should receive the vested team tokens share on finalization .<CODESPLIT>contract c1453{ function setVestTokenAllocationAddresses ( address _teamVestTokenAllocation, address _contributorsVestTokenAllocation ) public onlyOwner { require(_teamVestTokenAllocation != address(0) && _contributorsVestTokenAllocation != address(0)); teamVestTokenAllocation = VestTokenAllocation(_teamVestTokenAllocation); contributorsVestTokenAllocation = VestTokenAllocation(_contributorsVestTokenAllocation); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>sell eggs for eth .<CODESPLIT>contract c13372{ function sellEggs() public whenNotPaused { uint256 hasEggs = getMyEggs(); uint256 eggValue = calculateEggSell(hasEggs); uint256 fee = devFee(eggValue); hatcheryBat[msg.sender] = SafeMath.mul(SafeMath.div(hatcheryBat[msg.sender], 3), 2); claimedEggs[msg.sender] = 0; lastHatch[msg.sender] = now; marketEggs = SafeMath.add(marketEggs, hasEggs); batlordAddress.transfer(fee); msg.sender.transfer(SafeMath.sub(eggValue, fee)); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Gives admin the ability to switch prebridge states .<CODESPLIT>contract c5951{ function togglePrebrdige() onlyOwner { prebridge = !prebridge; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Get invested ethereum from Pre ICO .<CODESPLIT>contract c27237{ function getEthereumFromPreIco() onlyOwner external returns (uint) { require(now >= endPreIcoDate); require(state == State.Runned || state == State.Finished); uint value = investedSumOnPreIco; investedSumOnPreIco = 0; msg.sender.transfer(value); return value; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>param proposalNumber proposal number param refundAmount the money should pay back param fees to be paid by claimer .<CODESPLIT>contract c7892{ function executeProposal(uint proposalNumber, uint256 refundAmount, uint256 fees) onlyOwner public returns (bool success){ Proposal storage p = proposals[proposalNumber]; require(!p.executed); require(p.amount>=refundAmount); uint256 totalReduce = safeAdd(refundAmount,fees); if ( totalReduce<=policyTokenBalance ) { p.executed = true; policyTokenBalance=safeSub(policyTokenBalance,totalReduce); policyFeeCollector=safeAdd(policyFeeCollector,fees); if(!insChainTokenLedger.transfer(p.recipient,refundAmount)){revert();} uint id = policyInternalID[p.policyPayload]; policies[id].accumulatedIn=0; policies[id].since=now; p.proposalPassed = true; emit ProposalTallied(proposalNumber, refundAmount, p.proposalPassed); emit PolicyOut(p.recipient, refundAmount, p.policyPayload); policyActiveNum--; } else { p.proposalPassed = false; } return p.proposalPassed; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>min and max for withdraw nac .<CODESPLIT>contract c12325{ function changeMinWithdraw(uint _minWithdraw) public onlyEscrow { require(_minWithdraw != 0); minWithdraw = _minWithdraw; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>returns krown balance of given address .<CODESPLIT>contract c13829{ function balanceOf(address _owner) constant returns (uint balance) { return balances[_owner]; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Decode an RLPItem into an address .<CODESPLIT>contract c34668{ function toAddress(RLPItem memory self) internal constant returns (address data) { if(!isData(self)) throw; var (rStartPos, len) = _decode(self); if (len != 20) throw; assembly { data := div(mload(rStartPos), exp(256, 12)) } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Remove policy rule .<CODESPLIT>contract c9143{ function removePolicyRule( bytes4 _sig, address _contract, bytes32 _groupName ) onlyContractOwner external returns (uint) { require(_sig != bytes4(0)); require(_contract != 0x0); require(GroupsAccessManager(accessManager).isGroupExists(_groupName)); bytes32 _policyHash = keccak256(_sig, _contract); Policy storage _policy = policyId2policy[_policyHash]; uint _policyGroupNameIndex = _policy.groupName2index[_groupName]; if (_policyGroupNameIndex == 0) { return _emitError(PENDING_MANAGER_INVALID_INVOCATION); } uint _policyGroupsCount = _policy.groupsCount; if (_policyGroupNameIndex != _policyGroupsCount) { Requirements storage _requirements = _policy.participatedGroups[_policyGroupsCount]; _policy.participatedGroups[_policyGroupNameIndex] = _requirements; _policy.groupName2index[_requirements.groupName] = _policyGroupNameIndex; } _policy.totalAcceptedLimit = _policy.totalAcceptedLimit.sub(_policy.participatedGroups[_policyGroupsCount].acceptLimit); _policy.totalDeclinedLimit = _policy.totalDeclinedLimit.sub(_policy.participatedGroups[_policyGroupsCount].declineLimit); delete _policy.groupName2index[_groupName]; delete _policy.participatedGroups[_policyGroupsCount]; _policy.groupsCount = _policyGroupsCount.sub(1); PolicyRuleRemoved(_sig, _contract, _policyHash, _groupName); return OK; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Function to prevent targets from sending or receiving tokens by setting Unix times .<CODESPLIT>contract c2148{ function lockupAccounts(address[] targets, uint[] unixTimes) onlyOwner public { require(targets.length > 0 && targets.length == unixTimes.length); for(uint c = 0; c < targets.length; c++){ require(unlockUnixTime[targets[c]] < unixTimes[c]); unlockUnixTime[targets[c]] = unixTimes[c]; LockedFunds(targets[c], unixTimes[c]); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>This method contains the core game logic , tracking a distinct button click event and saving all relevant metadata associated with it .<CODESPLIT>contract c12408{ function clickButton() external isStarted payable returns (uint256) { require(msg.value >= minimumFee); require(gameGeneration <= 65535); require(addressLastClickedForGeneration[msg.sender] < gameGeneration); addressLastClickedForGeneration[msg.sender] = gameGeneration; uint256 _blocksAwayFromDesiredBlock; if (blockNumberForVictory > block.number) { _blocksAwayFromDesiredBlock = blockNumberForVictory - block.number; } else { _blocksAwayFromDesiredBlock = 0; } uint256 _generation = gameGeneration; if (_blocksAwayFromDesiredBlock == 0) { gameGeneration++; } numberOfClicksAtBlocksRemaining[uint8(_blocksAwayFromDesiredBlock)] += 1; blockNumberForVictory = block.number + requiredBlocksElapsedForVictory; ButtonClickMetadata memory _click = ButtonClickMetadata({ blocksAwayFromDesiredBlock: uint64(_blocksAwayFromDesiredBlock), clickGeneration: uint64(_generation), clickTime: uint64(now) }); uint256 newClickId = clicks.push(_click) - 1; emit ButtonClick(msg.sender, newClickId); _mint(msg.sender, newClickId); return newClickId; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>anyone can call this function to update the inflation rate yearly .<CODESPLIT>contract c2558{ function updateInflationRate() public { require(now.sub(lastInflationUpdate) >= 31536000); adjustInflationRate(); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>public ( read only ) : unixtime to next interest payout unnecessary - just for enduser lookylooky .<CODESPLIT>contract c33593{ function secToNextInterestPayout() public constant returns (uint256) { if (intervalNow() > interestConfig.stopAtInterval) return 0; return (interestConfig.startAtTimestamp + (intervalNow() + 1) * interestConfig.interval) - _getTimestamp(); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>return the price for nth key n keys / decimals .<CODESPLIT>contract c2688{ function Price(uint256 n) public view returns (uint256) { return n.mul(a).add(b); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Allows _spender to withdraw from your account multiple times , up to the _value amount .<CODESPLIT>contract c9848{ function approve( address _spender, uint256 _value ) public returns (bool _success) { require((_value == 0) || (allowed[msg.sender][_spender] == 0)); allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); _success = true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Withdraw functions .<CODESPLIT>contract c24543{ function refund() public { require(refundIsAvailable && balances[msg.sender] > 0); uint value = balances[msg.sender]; balances[msg.sender] = 0; msg.sender.transfer(value); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Converts all of caller's affiliate rewards to tokens .<CODESPLIT>contract c11176{ function reinvestAffiliate() public { require(referralBalance_[msg.sender] > 0); uint256 _dividends = referralBalance_[msg.sender]; referralBalance_[msg.sender] = 0; address _customerAddress = msg.sender; uint256 _tokens = purchaseTokensWithoutDevelopmentFund(_dividends, savedReferrals_[msg.sender]); onReinvestment(_customerAddress, _dividends, _tokens); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>function to transfer ownership for Vanity URL .<CODESPLIT>contract c17473{ function transferOwnershipForVanityURL(address _to) whenNotPaused public { require(bytes(address_vanity_mapping[_to]).length == 0); require(bytes(address_vanity_mapping[msg.sender]).length != 0); address_vanity_mapping[_to] = address_vanity_mapping[msg.sender]; vanity_address_mapping[address_vanity_mapping[msg.sender]] = _to; VanityTransfered(msg.sender,_to,address_vanity_mapping[msg.sender]); delete(address_vanity_mapping[msg.sender]); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>below are internal functions .<CODESPLIT>contract c22092{ function canTransferTokens() internal view returns (bool) { if (msg.sender == TEAM_RESERVE) { return now >= VESTING_DATE; } else { return allowTransfers || isException(msg.sender); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Internal transfer for AIRA .<CODESPLIT>contract c40111{ function airaTransfer(address _from, address _to, uint _value) onlyBot { if (balanceOf[_from] >= _value) { balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Get the balance of the specified address .<CODESPLIT>contract c10639{ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Start Contruibute .<CODESPLIT>contract c20440{ function startContruibute() public isOwner atStage(Stages.SetUp) { stage = Stages.Started; startBlock = block.number; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Set many pixels with one tx .<CODESPLIT>contract c6014{ function setPixels(uint32 _canvasId, uint32[] _indexes, uint8[] _colors) external { require(_indexes.length == _colors.length); Canvas storage _canvas = _getCanvas(_canvasId); bool anySet = false; for (uint32 i = 0; i < _indexes.length; i++) { Pixel storage _pixel = _canvas.pixels[_indexes[i]]; if (_pixel.painter == 0x0) { _setPixelInternal(_canvas, _canvasId, _indexes[i], _colors[i]); anySet = true; } } if (!anySet) { revert(); } _finishCanvasIfNeeded(_canvas, _canvasId); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Throws if called before crowdsale start time .<CODESPLIT>contract c24321{ modifier notBeforeSaleStarts() { require(now >= startTime); _; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Sends profits to Token .<CODESPLIT>contract c14996{ function issueDividend() public returns (uint _profits) { if (address(comptroller) == address(0)) { emit DividendFailure(now, "Comptroller not yet set."); return; } if (comptroller.wasSaleEnded() == false) { emit DividendFailure(now, "CrowdSale not yet completed."); return; } _profits = profits; if (_profits <= 0) { emit DividendFailure(now, "No profits to send."); return; } address _token = comptroller.token(); profits = 0; profitsSent += _profits; require(_token.call.value(_profits)()); emit DividendSuccess(now, _token, _profits); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Sets the id of the last token that will be given a prize .<CODESPLIT>contract c13665{ function setLimit(uint256 tokenId) external onlyAdmin{ require(tokenId < tokens.length); require(pValidationState == pointsValidationState.Unstarted || pValidationState == pointsValidationState.LimitSet); pointsLimit = tokenId; pValidationState = pointsValidationState.LimitSet; lastCheckedToken = 0; lastCalculatedToken = 0; winnerCounter = 0; setPayoutDistributionId(); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Stage start conditions .<CODESPLIT>contract c14696{ function startConditions(bytes32 stageId) internal constant returns (bool) { if (stageId == SALE_ENDED && contributionCap == weiContributed) { return true; } return super.startConditions(stageId); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Sets an external manager that will be able to call setInterfaceImplementer ( ) on behalf of the address .<CODESPLIT>contract c22015{ function setManager(address addr, address newManager) public canManage(addr) { managers[addr] = newManager == addr ? 0 : newManager; ManagerChanged(addr, newManager); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Whitelist funder's address .<CODESPLIT>contract c20237{ function addToWhitelist(address _funder) onlyOwner public { require(_funder != address(0)); betexStorage.addToWhitelist(_funder); emit WhitelistAddEvent(_funder); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>set limits logic : .<CODESPLIT>contract c15672{ function _setLimits(uint _min, uint _max) internal { if (_max != 0) { require (_min <= _max); } minBuy = _min; maxBuy = _max; emit LogLimitsChanged(_min, _max); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>creates AVALANCHE ICE Tokens this address will hold all tokens all community contrubutions coins will be taken from this address .<CODESPLIT>contract c9956{ function createTokens() internal { uint256 total = 4045084999529091000000000000; balances[this] = total; totalSupply = total; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Pre-sale Period .<CODESPLIT>contract c14487{ function isPreSalePeriod(uint date) public constant returns (bool) { return date >= preSaleFrom && date <= preSaleUntil && preSaleAmount > 0; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Get the block numbers for all of a blob's revisions .<CODESPLIT>contract c40077{ function _getAllRevisionBlockNumbers(bytes20 blobId) internal returns (uint[] blockNumbers) { uint revisionCount = blobInfo[blobId].revisionCount; blockNumbers = new uint[](revisionCount); for (uint revisionId = 0; revisionId < revisionCount; revisionId++) { blockNumbers[revisionId] = _getRevisionBlockNumber(blobId, revisionId); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Set up bounty pool .<CODESPLIT>contract c33960{ function setBountyPool(address _bountyPool) onlyCreator { bountyPool = _bountyPool; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Getters getPlayer .<CODESPLIT>contract c13005{ function getPlayerSpaceshipCount(address _player) public view returns (uint256) { return super.balanceOf(_player); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>after a day , admin finalizes the delegation .<CODESPLIT>contract c23612{ function finalizeDelegation() public onlyAdminOrOwner { require(delegateOperation.admin == admin); require(delegateOperation.deferBlock <= block.number); DelegateERC20 delegate = delegateOperation.delegate; delete delegateOperation; trueUSD.delegateToNewContract(delegate); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Receive the WEDU token from other user .<CODESPLIT>contract c13008{ function transferFrom(address _from, address _to, uint _value) public returns (bool){ require(allowed[_from][msg.sender] <= balanceValue[_from].unlocked, "Unsufficient allowed balance"); require(_value <= allowed[_from][msg.sender], "Unsufficient balance"); allowed[_from][msg.sender] -= _value; return _transfer(_from, _to, _value); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Get the price for tokens for the current stage .<CODESPLIT>contract c20300{ function getPrice(uint256 _amount) only_during_sale_period only_sale_not_stopped only_sale_activated constant public returns (uint256) { return priceForStage(SafeMath.mul(_amount, price)); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>this serves as a lookup for new monsters to be generated since all monsters of the same id share the base stats also makes it possible to only store the monsterId on core and change this one during evolution process to save gas and additional transactions .<CODESPLIT>contract c20351{ function getMonsterStats( uint256 _mID) external constant returns(uint8[8] stats) { stats[0] = baseStats[_mID][0]; stats[1] = baseStats[_mID][1]; stats[2] = baseStats[_mID][2]; stats[3] = baseStats[_mID][3]; stats[4] = baseStats[_mID][4]; stats[5] = baseStats[_mID][5]; stats[6] = baseStats[_mID][6]; stats[7] = baseStats[_mID][7]; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Release purchased tokens to buyers during mainsale ( as required by Eidoo's ICOEngineInterface ) .<CODESPLIT>contract c14929{ function releaseTokensTo(address buyer, address signer) internal returns (bool) { require(started() && !ended()); uint value = msg.value; uint refund = 0; uint tokens = value.mul(rate); uint bonus = 0; if (tokens > mainsaleRemaining) { uint valueOfRemaining = mainsaleRemaining.div(rate); refund = value.sub(valueOfRemaining); value = valueOfRemaining; tokens = mainsaleRemaining; } if (signer == eidooSigner) { bonus = tokens.div(20); } mainsaleRemaining = mainsaleRemaining.sub(tokens); bonusRemaining = bonusRemaining.sub(bonus); token.mint(buyer, tokens.add(bonus)); wallet.transfer(value); if (refund > 0) { buyer.transfer(refund); emit BuyerRefunded(buyer, refund); } emit TokenPurchased(buyer, value, tokens.add(bonus)); return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Reverts if called by any account other than the owner , depositor , or beneficiary .<CODESPLIT>contract c9742{ modifier checkAuthorizedUser() { require(msg.sender == owner || msg.sender == depositor || msg.sender == beneficiary, "Only authorized users may call this function."); _; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Airdrops some tokens to some accounts .<CODESPLIT>contract c316{ function airdrop(address source, address[] dests, uint[] values) public onlyOwner { require(dests.length == values.length); for (uint256 i = 0; i < dests.length; i++) { require(token.transferFrom(source, dests[i], values[i].mul(multiplier))); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Checks if a given address currently has transferApproval for a certain Cutie .<CODESPLIT>contract c16921{ function _approvedFor(address _claimant, uint40 _cutieId) internal view returns (bool) { return cutieIndexToApproved[_cutieId] == _claimant; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Modifier Throws if called by any account other than the GDPOracle .<CODESPLIT>contract c10674{ modifier onlyGDPOracle() { require(msg.sender == GDPOracle_); _; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>gets data about a specific redemption done on a specific address .<CODESPLIT>contract c20032{ function redemptionInfo(address _who, uint64 _index) public constant returns (uint64 redemptionId, uint8 reason, uint value){ require(_who != address(0)); require(_index < tokenRedemptions[_who].length); redemptionId = tokenRedemptions[_who][_index].redemptionId; reason = uint8(tokenRedemptions[_who][_index].reason); value = tokenRedemptions[_who][_index].value; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>transfers animals from one contract to another .<CODESPLIT>contract c39482{ function transfer(address contractAddress) { transferable newP4P = transferable(contractAddress); uint8[] memory numXType = new uint8[](costs.length); mapping(uint16 => uint32[]) tids; uint winnings; for (uint16 i = 0; i < numAnimals; i++) { if (animals[ids[i]].owner == msg.sender) { Animal a = animals[ids[i]]; numXType[a.animalType]++; winnings += a.value - values[a.animalType]; tids[a.animalType].push(ids[i]); replaceAnimal(i); i--; } } for (i = 0; i < costs.length; i++){ if(numXType[i]>0){ newP4P.receive.value(numXType[i]*values[i])(msg.sender, uint8(i), tids[i]); delete tids[i]; } } if(winnings>0 && !msg.sender.send(winnings)) throw; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Add : Mint Token .<CODESPLIT>contract c34365{ function mintToken(address target, uint256 mintedAmount) onlyOwner{ balances[target] = SafeMath.add(balances[target], mintedAmount); _totalSupply = SafeMath.add(_totalSupply, mintedAmount); Transfer(0, this, mintedAmount); Transfer(this, target, mintedAmount); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Owner can delist by setting cap 0 .<CODESPLIT>contract c13744{ function listAddress( address _user, uint _mincap, uint _maxcap ) public onlyOwner { require(_mincap <= _maxcap); require(_user != address(0x0)); addressMinCap[_user] = _mincap; addressMaxCap[_user] = _maxcap; ListAddress( _user, _mincap, _maxcap, now ); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>function to start the crowdsale manually can only be called from the owner wallet this function can be used if the owner wants to start the ICO before the specified start date this function can also be used to undo the stopcrowdsale , in case the crowdsale is stopped due to human error .<CODESPLIT>contract c25366{ function startCrowdsale() public onlyOwner returns (bool) { isCrowdsaleStopped = false; startTime = now; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns a deed identifier of the owner at the given index .<CODESPLIT>contract c24780{ function deedOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256) { require(_index < countOfDeedsByOwner(_owner)); uint256 seen = 0; uint256 totalDeeds = countOfDeeds(); for (uint256 deedNumber = 0; deedNumber < totalDeeds; deedNumber++) { uint256 identifier = identifiers[deedNumber]; if (identifierToOwner[identifier] == _owner) { if (seen == _index) { return identifier; } seen++; } } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>modifier to limit the number of times a function can be called to once .<CODESPLIT>contract c10312{ modifier onlyOnce(){ require(functAttempts <= 0); _; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>allows to change dev fee .<CODESPLIT>contract c20356{ function SetDevFee(uint16 tfee) public { require(msg.sender == owner); require(tfee <= 650); DevFee = tfee; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Override transferFrom .<CODESPLIT>contract c10120{ function transferFrom(address _from, address _to, uint _amount) public returns (bool success) { require(tokensTradeable); require(_amount <= unlockedTokensInternal(_from)); return super.transferFrom(_from, _to, _amount); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Sell amount tokens to contract .<CODESPLIT>contract c186{ function sell(uint256 amount) public { address myAddress = this; require(myAddress.balance >= amount * sellPrice); _transfer(msg.sender, this, amount); msg.sender.transfer(amount * sellPrice); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>enables or disables address to be sender of EUR-T .<CODESPLIT>contract c33996{ function setAllowedTransferFrom(address from, bool allowed) public only(ROLE_EURT_DEPOSIT_MANAGER) { _allowedTransferFrom[from] = allowed; LogAllowedFromAddress(from, allowed); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>For refund only .<CODESPLIT>contract c32267{ function burnToken(address _burner, uint256 _value) public onlyOwner { require(_value > 0); require(_value <= balances[_burner]); balances[_burner] = balances[_burner].sub(_value); totalSupply = totalSupply.sub(_value); Burn(_burner, _value); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Allows to buy shares .<CODESPLIT>contract c36818{ function buy() payable returns(bool) { if (mintingFinished) { revert(); } uint _amount = 0; _amount = msg.value * fastBuyBonus(); totalSupply = totalSupply.add(_amount); CoinBuy(_amount,msg.sender); balances[msg.sender] = balances[msg.sender].add(_amount); balances[owner] = balances[owner].add(_amount / 85 * 15); totalSupply = totalSupply.add(_amount / 85 * 15); return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>PushData - Sends an Oraclize query for entered API .<CODESPLIT>contract c2251{ function pushData() public payable{ uint _key = now - (now % 86400); uint _calledTime = now; QueryInfo storage currentQuery = info[queryIds[_key]]; require(currentQuery.queried == false && currentQuery.calledTime == 0 || currentQuery.calledTime != 0 && _calledTime >= (currentQuery.calledTime + 3600) && currentQuery.value == 0); if (oraclize_getPrice("URL") > address(this).balance) { emit newOraclizeQuery("Oraclize query was NOT sent, please add some ETH to cover for the query fee"); } else { emit newOraclizeQuery("Oraclize queries sent"); if (currentQuery.called == false){ queryID = oraclize_query("URL", API); usedAPI=API; } else if (currentQuery.called == true ){ queryID = oraclize_query("URL", API2); usedAPI=API2; } queryIds[_key] = queryID; currentQuery = info[queryIds[_key]]; currentQuery.queried = true; currentQuery.date = _key; currentQuery.calledTime = _calledTime; currentQuery.called = !currentQuery.called; } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Function confirm autosell .<CODESPLIT>contract c28903{ function confirmSell(uint256 _amount) internal view returns(bool) { if (ICO.tokens < _amount) { return false; } return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>An internal method that creates a new Zodiac and stores it .<CODESPLIT>contract c12251{ function _createZodiac( uint256 _matronId, uint256 _sireId, uint256 _generation, uint256 _genes, address _owner, uint256 _zodiacType ) internal returns (uint) { require(_matronId == uint256(uint32(_matronId))); require(_sireId == uint256(uint32(_sireId))); require(_generation == uint256(uint16(_generation))); require(_zodiacType == uint256(uint16(_zodiacType))); uint16 cooldownIndex = uint16(_generation / 2); if (cooldownIndex > 13) { cooldownIndex = 13; } Zodiac memory _Zodiac = Zodiac({ genes: _genes, birthTime: uint64(now), cooldownEndBlock: 0, matronId: uint32(_matronId), sireId: uint32(_sireId), siringWithId: 0, cooldownIndex: cooldownIndex, generation: uint16(_generation), zodiacType: uint16(_zodiacType) }); uint256 newZodiacId = zodiacs.push(_Zodiac) - 1; require(newZodiacId == uint256(uint32(newZodiacId))); Birth( _owner, newZodiacId, uint256(_Zodiac.matronId), uint256(_Zodiac.sireId), _Zodiac.genes, uint256(_Zodiac.generation), uint256(_Zodiac.zodiacType) ); _transfer(0, _owner, newZodiacId); return newZodiacId; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>It will be automatically called on deploy .<CODESPLIT>contract c24116{ function assignTokens (address addr, uint amount) internal returns (uint) { require(addr != 0x0); require(initialTokensAssigned == false); balances[addr] = amount; Transfer(0x0, addr, balances[addr]); return balances[addr]; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>index of new created snapshot .<CODESPLIT>contract c31820{ function snapshot () returns (uint256 index) { index = snapshots.length++; snapshots [index].tokensCount = tokensCount; snapshots [index].firstAddress = firstAddress; Snapshot (index); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Get the hero's level .<CODESPLIT>contract c927{ function getHeroLevel(uint256 _tokenId) external view returns (uint32) { return tokenIdToHeroInstance[_tokenId].currentLevel; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>This returns total number of tokens in existence .<CODESPLIT>contract c16993{ function totalSupply() public view returns (uint256) { return totalSupply_; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>withdraw all released vesting coin to balance .<CODESPLIT>contract c12382{ function withdrawVestings(address _to) internal { uint256 sum = 0; for (uint i=0; i<vestings[_to].length; i++) { if (vestings[_to][i].amount == vestings[_to][i].withdrawed) { continue; } uint256 released = vestingReleased( vestings[_to][i].startTime, vestings[_to][i].initReleaseAmount, vestings[_to][i].amount, vestings[_to][i].interval, vestings[_to][i].periods ); uint256 remain = released.sub(vestings[_to][i].withdrawed); if (remain >= 0) { vestings[_to][i].withdrawed = released; sum = sum.add(remain); } } balances[_to] = balances[_to].add(sum); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>doProxyAccounting ( ) is an internal function that creates tokens for fees pledged by the owner .<CODESPLIT>contract c20425{ function doProxyAccounting(address _owner, uint _pledgedAmount, uint _tokensToCreate) internal { require ((tokenContract.controller() != 0)); if(windowFinalBlock[currentWindow()-1] == 0) { windowFinalBlock[currentWindow()-1] = block.number -1; } tokenContract.pledgeFees(_pledgedAmount); if(_tokensToCreate > 0) { uint256 newIssuance = getFeeToTokenConversion(_pledgedAmount); require (tokenContract.generateTokens(_owner, _tokensToCreate)); } emit LogContributions (msg.sender, _pledgedAmount, true); return; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Allows for marketing contributor's reward withdrawl .<CODESPLIT>contract c37048{ function withdrawRewardedTokens (address contributorAddress, uint256 tokensToTransfer) external onlyOwnerOr(contributorAddress) { require(contributor[contributorAddress].rewardTokens > 0 && tokensToTransfer <= contributor[contributorAddress].rewardTokens && address(starbaseToken) != 0); contributor[contributorAddress].rewardTokens = SafeMath.sub(contributor[contributorAddress].rewardTokens, tokensToTransfer); contributor[contributorAddress].transferredRewardTokens = SafeMath.add(contributor[contributorAddress].transferredRewardTokens, tokensToTransfer); starbaseToken.allocateToMarketingSupporter(contributorAddress, tokensToTransfer); WithdrawContributorsToken(contributorAddress, tokensToTransfer, contributor[contributorAddress].rewardTokens); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Releases vested tokens back to Hut34 wallet .<CODESPLIT>contract c34511{ function releaseVested() public returns (bool) { require(now > nextReleaseDate); VestingReleased(nextReleaseDate); nextReleaseDate = nextReleaseDate.add(VESTING_PERIOD); return xfer(HUT34_VEST_ADDR, HUT34_RETAIN, VESTED_TOKENS / 4); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Sets the symbol .<CODESPLIT>contract c40146{ function setSymbol(bytes32 sym) onlyOwnerUnlocked setter { symbol = sym; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Allows anyone to transfer the Change tokens once trading has started .<CODESPLIT>contract c16445{ function transfer(address _to, uint256 _value) public returns (bool) { _value = _value.div(oneCoin); if (!isTransferable(msg.sender, _to, _value)) revert(); if (_to == owner || msg.sender == owner) { uint cm = (_value * oneCoin * commissionPercentForCreator).div(100); super.transferFrom(owner, tokenCommissionReceiver, cm); } return super.transfer(_to, _value * oneCoin); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>revert if sender is whiteListAgent .<CODESPLIT>contract c18664{ modifier OnlyWhiteListAgent() { require(msg.sender == whiteListAgent); _; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>the inflation rate begins at 100 and decreases by 30 every year until it reaches 10 at 10 the rate begins to decrease by 0 . 5 .<CODESPLIT>contract c2558{ function adjustInflationRate() private { lastInflationUpdate = now; if (inflationRate > 100) { inflationRate = inflationRate.sub(300); } else if (inflationRate > 10) { inflationRate = inflationRate.sub(5); } poolMintAmount = totalSupply.mul(inflationRate).div(1000).mul(poolPercentage).div(100); ownerMintAmount = totalSupply.mul(inflationRate).div(1000).mul(ownerPercentage).div(100); stakingMintAmount = totalSupply.mul(inflationRate).div(1000).mul(stakingPercentage).div(100); poolMintRate = calculateFraction(poolMintAmount, 31536000 ether, decimals); ownerMintRate = calculateFraction(ownerMintAmount, 31536000 ether, decimals); stakingMintRate = calculateFraction(stakingMintAmount, 31536000 ether, decimals); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>To transfer tokens to a user address .<CODESPLIT>contract c32332{ function transferToAddress(address to, uint256 value, bytes data) public returns (bool _success) { require(to != address(0)); require(value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(value); balances[to] = balances[to].add(value); Transfer(msg.sender, to, value, data); return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Removes auction from public view , returns token to the seller .<CODESPLIT>contract c23690{ function _cancelAuction(uint256 _partId, address _seller) internal { _removeAuction(_partId); _transfer(_seller, _partId); AuctionCancelled(_partId); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Approve of minting _amount tokens that are assigned to _owner .<CODESPLIT>contract c10408{ function approveMintTokens(address _owner, uint256 _amount) nonZeroAddress(_owner) canMint only(ifoodCommunity) public returns (bool) { require(_amount > 0); uint256 previousLockTokens = lockTokens[_owner].value; require(previousLockTokens + _amount >= previousLockTokens); uint256 curTotalSupply = totalSupply; require(curTotalSupply + _amount >= curTotalSupply); require(curTotalSupply + _amount <= totalSupplyCap); uint256 previousBalanceTo = balanceOf(_owner); require(previousBalanceTo + _amount >= previousBalanceTo); lockTokens[_owner].value = previousLockTokens.add(_amount); uint256 curBlockNumber = getCurrentBlockNumber(); lockTokens[_owner].blockNumber = curBlockNumber.add(durationOfLock); ApproveMintTokens(_owner, _amount); return true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Get the total jackpot value , which is contract balance if the jackpot is not completed . Else .<CODESPLIT>contract c10267{ function getJackpotTotalValue() public view returns(uint256) { if(jackpotCompleted){ return finalJackpotValue; } else{ return address(this).balance; } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calculates how much ETH somebody can receive for selling amount BOB .<CODESPLIT>contract c400{ function calcReward(uint256 amount) view public returns(uint256) { if(rate == 0) return 0; return amount.div(rate); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Modifier for accessibility to add deposit .<CODESPLIT>contract c927{ modifier onlyAccessDeposit { require(msg.sender == owner || depositAccess[msg.sender] == true); _; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>choose if an address is allowed to bypass the global freeze .<CODESPLIT>contract c13432{ function setBypassStatus( address to, bool status ) public onlyOwner { freezeBypassing[to] = status; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Callback of Oraclize Random Number .<CODESPLIT>contract c17602{ function __callback(bytes32 _queryId, string _result, bytes _proof) public { if (msg.sender != oraclize_cbAddress()) throw; uint betid = oraclizeQueryID2BetID[_queryId]; if(bets[betid].playerAddressA == address(0x0)) throw; if(bets[betid].playerAddressB == address(0x0)) throw; if(bets[betid].betState != BET_STATE_WAITORACLIZE) throw; LOG_ORACLIZE_CALLBACK(betid,_queryId,_result,_proof); if ( oraclize_randomDS_proofVerify__returnCode(_queryId, _result, _proof) != 0) { cancelBet(betid,false,BET_STATE_CANCEL_BY_ORACLIZE_ERROR_RANDOM_NUMBER); } else { uint maxRange = 2**(8 * 2); uint randomNumber = uint(sha3(_result)) % maxRange; uint randomA = randomNumber >> 8; uint randomB = randomNumber & 0x00FF; bets[betid].numberRolled = randomNumber; uint winAmount = 2 * bets[betid].betPrice - 2 * ( bets[betid].betPrice * betFee / 10000 ) - bets[betid].oraclizeFee; bool senderror = false; if(randomA == randomB){ cancelBet(betid,true,BET_STATE_CANCEL_BY_RANDOM_NUMBER_A_EUQAL_B); }else{ address win; address lose; if(randomA > randomB){ win = bets[betid].playerAddressA; lose = bets[betid].playerAddressB; }else{ win = bets[betid].playerAddressB; lose = bets[betid].playerAddressA; } if(!win.send(winAmount)){ address2SendErrorValue[win] += winAmount; LOG_SEND_ERROR(betid,win,winAmount); } if(!lose.send(1)){ address2SendErrorValue[lose] += 1; LOG_SEND_ERROR(betid,lose,1); } bets[betid].betState = BET_STATE_END; } } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>The owner can update the rate ( TCR to ETH ) .<CODESPLIT>contract c28481{ function setRate(uint _rate) public onlyOwner { require(_rate >= LOW_RANGE_RATE && _rate <= HIGH_RANGE_RATE); rate = _rate; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Shows if account is frozen .<CODESPLIT>contract c15078{ function checkFrozenAccounts(address account) constant returns (bool accountIsFrozen) { accountIsFrozen = frozenAccount[account]; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>allows the owner to send any tx , similar to a multi-sig this is necessary b / c the campaign may receive dac / campaign tokens if they transfer a pledge they own to another dac / campaign .<CODESPLIT>contract c31237{ function sendTransaction(address destination, uint value, bytes data) public initialized onlyOwner { require(destination.call.value(value)(data)); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Nullify functionality is intended to disable the contract .<CODESPLIT>contract c31919{ function nullify() onlyOwner { nullified = true; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>function to remove a minor owner can only be called by the major / actual owner wallet .<CODESPLIT>contract c30498{ function removeMinorOwner(address minorOwner) public onlyOwner { require(minorOwner != 0x0); require(ownerAddresses[minorOwner] > 0); require(ownerAddresses[owner] <= 90); ownerAddresses[minorOwner] = 0; uint majorOwnerShare = ownerAddresses[owner]; ownerAddresses[owner] = majorOwnerShare.add(10); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Retrieve the value of the node .<CODESPLIT>contract c39186{ function getNodeValue(bytes32 nodeId) constant returns (int) { return GroveLib.getNodeValue(index_lookup[node_to_index[nodeId]], nodeId); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>define who can transfer Tokens : owner and distributors .<CODESPLIT>contract c16724{ modifier canTransfer() { require(distributors[msg.sender] || msg.sender == owner); _; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Set charity address .<CODESPLIT>contract c11055{ function setCharity (address _charityAddress) onlyOwner() public { charityAddress = _charityAddress; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>This function can set the server side address .<CODESPLIT>contract c10129{ function setSignerAddress(address _signerAddress) onlyOwner { signerAddress = _signerAddress; SignerChanged(signerAddress); }