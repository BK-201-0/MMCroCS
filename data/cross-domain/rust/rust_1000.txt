1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>~^ ERROR cannot find value `n` in this scope ~| ERROR cannot find value `n` in this scope ~| ERROR cannot find value `n` in this scope ~| ERROR cannot find value `n` in this scope<CODESPLIT>fn main() -> (){ for n in 0..1 { println!("{}", f!()); } if let Some(n) = None { println!("{}", f!()); } if false { } else if let Some(n) = None { println!("{}", f!()); } while let Some(n) = None { println!("{}", f!()); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Recognize lines of text in an image. `lines` is an ordered list of the text line boxes in an image, produced by [OcrEngine::find_text_lines]. The output is a list of [TextLine]s corresponding to the input image regions. Entries can be `None` if no text was found in a given line.<CODESPLIT>pub fn recognize_text( &self, input: &OcrInput, lines: &[Vec<RotatedRect>], ) -> anyhow::Result<Vec<Option<TextLine>>> { if let Some(recognizer) = self.recognizer.as_ref() { recognizer.recognize_text_lines( input.image.view(), lines, RecognitionOpt { debug: self.debug, decode_method: self.decode_method, alphabet: &self.alphabet, excluded_char_labels: self.excluded_char_labels.as_deref(), }, ) } else { Err(anyhow!("Recognition model not loaded")) } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns a field writer for field number `n`. It's legal to write fields in any order and to write fields that duplicate previous fields. By convention, later fields overwrite previous ones (or append, in the case of sequences).<CODESPLIT>pub fn field(&mut self, n: u32) -> FieldWriter<'_, 'buf, R> { self.state.field_number = n; self.state.in_sequence = false; FieldWriter { state: self.state } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Whether this builtin attribute is encoded cross crate. This means it can be used cross crate.<CODESPLIT>pub fn encode_cross_crate(name: Symbol) -> bool { if let Some(attr) = BUILTIN_ATTRIBUTE_MAP.get(&name) { attr.encode_cross_crate == EncodeCrossCrate::Yes } else { true } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Compares two `TokenStream`s, checking equality without regarding span information.<CODESPLIT>pub fn eq_unspanned(&self, other: &TokenStream) -> bool { let mut t1 = self.trees(); let mut t2 = other.trees(); for (t1, t2) in iter::zip(&mut t1, &mut t2) { if !t1.eq_unspanned(t2) { return false; } } t1.next().is_none() && t2.next().is_none() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Convert an ApplicationProto into a byte slice.<CODESPLIT>pub fn to_slice(&self) -> &[u8] { match self { Self::Interop => b"hq-interop", Self::Http09 => b"http/0.9", Self::H3 => b"h3", } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `matchOrders` (0xa8174404) function<CODESPLIT>pub fn match_orders( &self, orders: ::std::vec::Vec<Order>, fulfillments: ::std::vec::Vec<Fulfillment>, ) -> ::ethers::contract::builders::ContractCall<M, ::std::vec::Vec<Execution>> { self.0 .method_hash([168, 23, 68, 4], (orders, fulfillments)) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Set the delta in copa slow start state.<CODESPLIT>pub fn set_copa_slow_start_delta(&mut self, v: f64) { self.recovery.copa_slow_start_delta = v; }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Sends the datagram in `buf`.<CODESPLIT>fn send<'a>(&'a mut self, buf: &'a [u8]) -> Send<'a, Self> { Send { send: self, buf } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>This is the primary entrypoint for finding and resolving the right grit files for a given directory It handles traversing upwards to find the .grit directory, initializing it, and parsing the .grit files<CODESPLIT>pub async fn find_and_resolve_grit_dir( cwd: Option<PathBuf>, global_dir: Option<PathBuf>, ) -> Result<PatternsDirectory> { let existing_config = if let Some(cwd) = cwd { find_grit_dir_from(cwd).await } else { None }; match existing_config { Some(config) => get_grit_files_from_known_grit_dir(&config, vec![]).await, None => match global_dir { Some(global_dir) => { let stdlib_modules = get_stdlib_modules(); let repo = ModuleRepo::from_dir(&global_dir).await; get_grit_files(&repo, &global_dir.to_string_lossy(), Some(stdlib_modules)).await } None => Ok(PatternsDirectory::new()), }, } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Add object files for allocator code linked once for the whole crate tree.<CODESPLIT>fn add_local_crate_allocator_objects(cmd: &mut dyn Linker, codegen_results: &CodegenResults) { if let Some(obj) = codegen_results.allocator_module.as_ref().and_then(|m| m.object.as_ref()) { cmd.add_object(obj); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Moves the leaf edge handle to the previous leaf edge and returns the key and value in between, deallocating any node left behind while leaving the corresponding edge in its parent node dangling. # Safety - There must be another KV in the direction travelled. - That leaf edge was not previously returned by counterpart `deallocating_next_unchecked` on any copy of the handles being used to traverse the tree. The only safe way to proceed with the updated handle is to compare it, drop it, or call this method or counterpart `deallocating_next_unchecked` again.<CODESPLIT>unsafe fn deallocating_next_back_unchecked<A: Allocator + Clone>( &mut self, alloc: A, ) -> Handle<NodeRef<marker::Dying, K, V, marker::LeafOrInternal>, marker::KV> { super::mem::replace(self, |leaf_edge| unsafe { leaf_edge.deallocating_next_back(alloc).unwrap() }) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Add an Id that appeared in a trait<CODESPLIT>fn add_trait_item_id(&mut self, id: &'a Id) { self.add_id_checked(id, Kind::can_appear_in_trait, "Trait inner item"); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns a list of `Ty`s for each upvar.<CODESPLIT>fn final_upvar_tys(&self, closure_id: LocalDefId) -> Vec<Ty<'tcx>> { self.typeck_results .borrow() .closure_min_captures_flattened(closure_id) .map(|captured_place| { let upvar_ty = captured_place.place.ty(); let capture = captured_place.info.capture_kind; debug!(?captured_place.place, ?upvar_ty, ?capture, ?captured_place.mutability); apply_capture_kind_on_capture_ty( self.tcx, upvar_ty, capture, self.tcx.lifetimes.re_erased, ) }) .collect() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>EMIT_MIR match_arm_scopes.complicated_match SimplifyCfg-initial.after ElaborateDrops.after<CODESPLIT>fn complicated_match(cond: bool, items: (bool, bool, String)) -> i32 { match items { (false, a, s) | (a, false, s) if if cond { return 3 } else { a } => 1, (true, b, t) | (false, b, t) => 2, } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Ensures the independence of each side in `binding @ subpat` determine their binding modes independently of each other. That is, `binding` does not influence `subpat`. This is important because we might want to allow `p1 @ p2`, where both `p1` and `p2` are syntactically unrestricted patterns. If `binding` is allowed to influence `subpat`, this would create problems for the generalization aforementioned.<CODESPLIT>fn main() { struct NotCopy; fn f1(a @ b: &NotCopy) { let _: &NotCopy = a; } fn f2(ref a @ b: &NotCopy) { let _: &&NotCopy = a; } let a @ b = &NotCopy; let _: &NotCopy = a; let ref a @ b = &NotCopy; let _: &&NotCopy = a; let ref a @ b = NotCopy; let _a: &NotCopy = a; let _b: NotCopy = b; let ref mut a @ b = NotCopy; let _a: &NotCopy = a; let _b: NotCopy = b; match Ok(NotCopy) { Ok(ref a @ b) | Err(b @ ref a) => { let _a: &NotCopy = a; let _b: NotCopy = b; } } match NotCopy { ref a @ b => { let _a: &NotCopy = a; let _b: NotCopy = b; } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Attempts to find `node` inside `syntax` via `node`'s text range while compensating for the offset introduced by the fake ident. This is wrong if `node` comes before the insertion point! Use `find_node_in_file` instead.<CODESPLIT>fn find_node_in_file_compensated<N: AstNode>( sema: &Semantics<'_, RootDatabase>, in_file: &SyntaxNode, node: &N, ) -> Option<N> { ancestors_in_file_compensated(sema, in_file, node.syntax())?.find_map(N::cast) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Given a match expression, find extracting and diverging arms.<CODESPLIT>fn find_arms( ctx: &AssistContext<'_>, match_expr: &ast::MatchExpr, ) -> Option<(ast::MatchArm, ast::MatchArm)> { let arms = match_expr.match_arm_list()?.arms().collect::<Vec<_>>(); if arms.len() != 2 { return None; } let mut extracting = None; let mut diverging = None; for arm in arms { if ctx.sema.type_of_expr(&arm.expr()?)?.original().is_never() { diverging = Some(arm); } else { extracting = Some(arm); } } match (extracting, diverging) { (Some(extracting), Some(diverging)) => Some((extracting, diverging)), _ => { cov_mark::hit!(non_diverging_match); None } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Attempts to map the node out of macro expanded files. This only work for attribute expansions, as other ones do not have nodes as input.<CODESPLIT>pub fn original_syntax_node_rooted(&self, node: &SyntaxNode) -> Option<SyntaxNode> { let InFile { file_id, .. } = self.find_file(node); InFile::new(file_id, node).original_syntax_node_rooted(self.db.upcast()).map( |InRealFile { file_id, value }| { self.cache(find_root(&value), file_id.into()); value }, ) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Return `true` when the given `def_id` is a function that has `impl Trait` ty as one of its parameter types.<CODESPLIT>fn fn_inputs_has_impl_trait_ty(cx: &LateContext<'_>, def_id: LocalDefId) -> bool { let inputs = cx.tcx.fn_sig(def_id).instantiate_identity().inputs().skip_binder(); inputs.iter().any(|input| { matches!( input.kind(), ty::Alias(ty::AliasTyKind::Weak, alias_ty) if cx.tcx.type_of(alias_ty.def_id).skip_binder().is_impl_trait() ) }) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Synchronizes the line level of the interrupt line with the state of status register C.<CODESPLIT>fn update_interrupt_line_level(&self) { let status_c = StatusRegC::from(self.state.cmos[CmosReg::STATUS_C]); if status_c.irq_update() || status_c.irq_periodic() || status_c.irq_alarm() { assert!(status_c.irq_combined()); if self.enlightened_interrupts { self.interrupt.set_level(false); } self.interrupt.set_level(true); } else { assert!(!status_c.irq_combined()); self.interrupt.set_level(false); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Check each block's terminator for calls to pointer to integer transmutes in const functions or associated constants and emit a lint.<CODESPLIT>fn visit_terminator(&mut self, terminator: &Terminator<'tcx>, location: Location) { if let TerminatorKind::Call { func, .. } = &terminator.kind && let Some((func_def_id, _)) = func.const_fn_def() && self.tcx.is_intrinsic(func_def_id, sym::transmute) && self.is_ptr_to_int_in_const(func) && let Some(call_id) = self.body.source.def_id().as_local() { let hir_id = self.tcx.local_def_id_to_hir_id(call_id); let span = self.body.source_info(location).span; self.tcx.emit_node_span_lint( PTR_TO_INTEGER_TRANSMUTE_IN_CONSTS, hir_id, span, errors::UndefinedTransmute, ); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `getAllHeldIds` (0x2f4fefaf) function<CODESPLIT>pub fn get_all_held_ids( &self, ) -> ::ethers::contract::builders::ContractCall< M, ::std::vec::Vec<::ethers::core::types::U256>, > { self.0 .method_hash([47, 79, 239, 175], ()) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Check if a moved place at `idx` is a part of a BID. The use of this check is that we will consider drops on these as a drop of the overall BID and, thus, we can exclude it from the diagnosis.<CODESPLIT>fn place_descendent_of_bids<'tcx>( mut idx: MovePathIndex, move_data: &MoveData<'tcx>, bids: &UnordSet<&Place<'tcx>>, ) -> bool { loop { let path = &move_data.move_paths[idx]; if bids.contains(&path.place) { return true; } if let Some(parent) = path.parent { idx = parent; } else { return false; } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Checks whether a node is an `Internal` node or a `Leaf` node.<CODESPLIT>pub fn force( self, ) -> ForceResult< NodeRef<BorrowType, K, V, marker::Leaf>, NodeRef<BorrowType, K, V, marker::Internal>, > { if self.height == 0 { ForceResult::Leaf(NodeRef { height: self.height, node: self.node, _marker: PhantomData, }) } else { ForceResult::Internal(NodeRef { height: self.height, node: self.node, _marker: PhantomData, }) } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns a new child context with a timeout. The new context is notified when either this context is cancelled, or the timeout has expired.<CODESPLIT>pub fn with_timeout(&self, timeout: Duration) -> Self { match Deadline::now().checked_add(timeout) { Some(deadline) => self.with_deadline(deadline), None => self.clone(), } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `changeSpotPrice` (0xd8a1890c) function<CODESPLIT>pub fn change_spot_price( &self, new_spot_price: u128, ) -> ::ethers::contract::builders::ContractCall<M, ()> { self.0 .method_hash([216, 161, 137, 12], new_spot_price) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Increase inflight_hi if appropriate.<CODESPLIT>fn probe_inflight_hi_upward(&mut self, is_cwnd_limited: bool) { if !is_cwnd_limited || self.cwnd < self.inflight_hi { return; } self.bw_probe_up_acks += self.ack_state.newly_acked_bytes; if self.bw_probe_up_acks >= self.bw_probe_up_cnt { let delta = self.bw_probe_up_acks / self.bw_probe_up_cnt; self.bw_probe_up_acks = self .bw_probe_up_acks .saturating_sub(delta * self.bw_probe_up_cnt); self.inflight_hi = self .inflight_hi .saturating_add(delta * self.config.max_datagram_size); } if self.is_round_start() { self.raise_inflight_hi_slope(); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Creates a new [`Queue`] with the provided capacity<CODESPLIT>pub fn new(capacity: usize) -> Self { Self { data_ptr: OwningPointer::<MaybeUninit<T>>::new_with_alloc(capacity), capacity, len: 0, is_initialized: IoxAtomicBool::new(true), _phantom_data: PhantomData, } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Create new route handler for the specified path, controller and path type.<CODESPLIT>pub fn new(path: &str, controller: impl Controller + 'static, path_type: PathType) -> Self { Self { path: Path::parse(path).unwrap().with_regex(path_type).unwrap(), controller: Box::new(controller), name: None, rank: 0, } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Make sure this Rc doesn't fall apart when touched<CODESPLIT>fn check_unique_rc<T: ?Sized>(mut r: Rc<T>) { let r2 = r.clone(); assert!(Rc::get_mut(&mut r).is_none()); drop(r2); assert!(Rc::get_mut(&mut r).is_some()); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Make sure that we cannot return a `&mut` that got already invalidated, not even in a tuple.<CODESPLIT>fn foo(x: &mut (i32, i32)) -> (&mut i32,) { let xraw = x as *mut (i32, i32); let ret = (unsafe { &mut (*xraw).1 },); let _val = unsafe { *xraw }; ret }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Check if we should generate C++ like names and debug information.<CODESPLIT>pub fn cpp_like_debuginfo(tcx: TyCtxt<'_>) -> bool { tcx.sess.target.is_like_msvc }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Sets multiple environment variables for the command.<CODESPLIT>pub fn envs<I, K, V>(mut self, vars: I) -> Self where I: IntoIterator<Item = (K, V)>, K: AsRef<str>, V: AsRef<str>, { for (k, v) in vars.into_iter() { self = self.env(k.as_ref(), v.as_ref()); } self }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>The counterpart of `add_subtract_columns` for evaluating decimal expressions.<CODESPLIT>pub(crate) fn scale_and_add_subtract_eval<S: Scalar>( lhs_eval: S, rhs_eval: S, lhs_scale: i8, rhs_scale: i8, is_subtract: bool, ) -> S { let max_scale = lhs_scale.max(rhs_scale); let left_scaled_eval = lhs_eval * S::pow10(max_scale.abs_diff(lhs_scale)); let right_scaled_eval = rhs_eval * S::pow10(max_scale.abs_diff(rhs_scale)); if is_subtract { left_scaled_eval - right_scaled_eval } else { left_scaled_eval + right_scaled_eval } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>CHECK-LABEL: fn main(<CODESPLIT>fn main() { let local = (&[1u32, 2, 3] as &[u32])[1]; const SLICE: &[u32] = &[1, 2, 3]; let constant = SLICE[1]; }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `routerStatus` (0xa93ec68b) function<CODESPLIT>pub fn router_status( &self, p0: ::ethers::core::types::Address, ) -> ::ethers::contract::builders::ContractCall<M, (bool, bool)> { self.0 .method_hash([169, 62, 198, 139], p0) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>vec![0xd] followed by extend_from_slice looks weird<CODESPLIT>pub fn encode_string(value: &[u8]) -> Vec<u8> { let mut byte_stream: Vec<u8> = Vec::new(); byte_stream.push(0xd); byte_stream.extend_from_slice(value); byte_stream.push(0); byte_stream }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Check that we can const-prop into `from_raw_parts`<CODESPLIT>fn slice_const_length(x: &[i32]) -> *const [i32] { let ptr = x.as_ptr(); let len = 123; std::intrinsics::aggregate_raw_ptr(ptr, len) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Return the `DefId` of this `Res` if it represents a module.<CODESPLIT>pub fn mod_def_id(&self) -> Option<DefId> { match *self { Res::Def(DefKind::Mod, id) => Some(id), _ => None, } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>EMIT_MIR duplicate_switch_targets.ub_if_b.PreCodegen.after.mir<CODESPLIT>pub unsafe fn ub_if_b(t: Thing) -> Thing { match t { Thing::A => t, Thing::B => std::hint::unreachable_unchecked(), } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Performs a single point get using an index.<CODESPLIT>async fn index_get( &self, index_id: IndexId, tablet_id: TabletId, read_timestamp: Timestamp, key: IndexKey, retention_validator: Arc<dyn RetentionValidator>, ) -> anyhow::Result<Option<(Timestamp, ResolvedDocument)>> { let mut stream = self.index_scan( index_id, tablet_id, read_timestamp, &Interval::prefix(key.into_bytes().into()), Order::Asc, 2, retention_validator, ); match stream.try_next().await? { Some((key, ts, doc)) => { anyhow::ensure!( stream.try_next().await?.is_none(), "Got multiple values for key {:?}", key ); Ok(Some((ts, doc))) }, None => Ok(None), } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `changeDelta` (0x6809f664) function<CODESPLIT>pub fn change_delta( &self, new_delta: u128, ) -> ::ethers::contract::builders::ContractCall<M, ()> { self.0 .method_hash([104, 9, 246, 100], new_delta) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns `true` when the outermost type cannot be further normalized, resolved, or instantiated. This includes all primitive types, but also things like ADTs and trait objects, since even if their arguments or nested types may be further simplified, the outermost [`TyKind`] or type constructor remains the same.<CODESPLIT>pub fn is_known_rigid(self) -> bool { match self.kind() { Bool | Char | Int(_) | Uint(_) | Float(_) | Adt(_, _) | Foreign(_) | Str | Array(_, _) | Pat(_, _) | Slice(_) | RawPtr(_, _) | Ref(_, _, _) | FnDef(_, _) | FnPtr(..) | Dynamic(_, _, _) | Closure(_, _) | CoroutineClosure(_, _) | Coroutine(_, _) | CoroutineWitness(..) | Never | Tuple(_) => true, Error(_) | Infer(_) | Alias(_, _) | Param(_) | Bound(_, _) | Placeholder(_) => false, } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns the current time. # Examples ```ignore use iceoryx2_bb_posix::clock::*; let now: Time = Time::now_with_clock(ClockType::Monotonic).unwrap(); ```<CODESPLIT>pub fn now_with_clock(clock_type: ClockType) -> Result<Self, TimeError> { let mut current_time = posix::timespec { tv_sec: 0, tv_nsec: 0, }; handle_errno!(TimeError, from "Time::now", errno_source unsafe { posix::clock_gettime(clock_type as _, &mut current_time).into() }, success Errno::ESUCCES => Time { clock_type, seconds: current_time.tv_sec as u64, nanoseconds: current_time.tv_nsec as u32}, Errno::ENOSYS => (ClockTypeIsNotSupported, "Failed to get time {{ clock_type: {:?} }} since the clock is not supported.", clock_type), v => (UnknownError(v as i32), "Failed to get time {{ clock_type: {:?} }} since an unknown error occurred ({}).", clock_type, v) ); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Attempt to create a new client by connecting to a given endpoint.<CODESPLIT>pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error> where D: TryInto<tonic::transport::Endpoint>, D::Error: Into<StdError>, { let conn = tonic::transport::Endpoint::new(dst)?.connect().await?; Ok(Self::new(conn)) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Spawn a new task on the executor.<CODESPLIT>pub fn spawn<F, R>(&self, f: F) -> JoinHandle<R> where F: FnOnce() -> R + Send + 'static, R: Send + 'static, { tokio::task::spawn_blocking(f) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Parse a `Vec<Value>` from it respective sort keys.<CODESPLIT>pub fn bytes_to_values<R: Read>(reader: &mut R) -> anyhow::Result<Vec<Option<ConvexValue>>> { let reader = &mut BytePeeker::new(reader); let mut values = vec![]; while reader.peek()?.is_some() { let value = ConvexValue::_read_sort_key(reader)?; values.push(Some(value)); } Ok(values) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Convert a Linux stat struct to FUSE attributes.<CODESPLIT>pub fn stat_to_fuse_attr(stat: &lx::Stat) -> fuse_attr { fuse_attr { ino: stat.inode_nr, size: stat.file_size, blocks: stat.block_count, atime: stat.access_time.seconds as u64, mtime: stat.write_time.seconds as u64, ctime: stat.change_time.seconds as u64, atimensec: stat.access_time.nanoseconds as u32, mtimensec: stat.write_time.nanoseconds as u32, ctimensec: stat.change_time.nanoseconds as u32, mode: stat.mode, nlink: stat.link_count as _, uid: stat.uid, gid: stat.gid, rdev: stat.device_nr_special as u32, blksize: stat.block_size as _, padding: 0, } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Creates credentials from the network and private key<CODESPLIT>pub fn new( network: Network, master_key: ExtendedPrivKey, index: u32, ) -> StacksResult<Self> { let private_key = derive_key(master_key, stacks_derivation_path(index)?) .to_priv() .inner; Ok(Self { network, private_key, }) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Make sure casts between thin-pointer <-> fat pointer obey RFC401<CODESPLIT>fn main() { let a: &[i32] = &[1, 2, 3]; let b: Box<[i32]> = Box::new([1, 2, 3]); let p = a as *const [i32]; let q = a.as_ptr(); a as usize; a as isize; a as i16; a as u32; b as usize; p as usize; q as *const [i32]; let t: *mut (dyn Trait + 'static) = 0 as *mut _; let mut fail: *const str = 0 as *const str; let mut fail2: *const str = 0isize as *const str; }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>@ edition: 2021 @ check-pass<CODESPLIT>pub fn f1() -> impl std::future::Future<Output = Result<(), String>> + Send { async { should_work().await?; Ok(()) } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>@ pp-exact:issue-31073.pp<CODESPLIT>fn main() { fn f1(x: i32, y: i32) -> i32 { y } let f: fn(_, i32) -> i32 = f1; f(1, 2); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Create a new instance of `RwLockWriteGuard<T>` from a `RwLock<T>`. SAFETY: if and only if `lock.inner.write()` (or `lock.inner.try_write()`) has been successfully called from the same thread before instantiating this object.<CODESPLIT>unsafe fn new(lock: &'rwlock RwLock<T>) -> LockResult<RwLockWriteGuard<'rwlock, T>> { Ok(RwLockWriteGuard { lock, poison: () }) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>If we're looking at a block that is supposed to return `()`, type inference will just tell us it has type `()`. We have to look at the tail expression to see the mismatched actual type. This 'unpeels' the various blocks to hopefully let us see the type the user intends. (This still doesn't handle all situations fully correctly; the 'ideal' way to handle this would be to run type inference on the function again, but with a variable as the return type.)<CODESPLIT>fn peel_blocks(mut expr: ast::Expr) -> ast::Expr { loop { match_ast! { match (expr.syntax()) { ast::BlockExpr(it) => { if let Some(tail) = it.tail_expr() { expr = tail.clone(); } else { break; } }, ast::IfExpr(it) => { if let Some(then_branch) = it.then_branch() { expr = ast::Expr::BlockExpr(then_branch.clone()); } else { break; } }, ast::MatchExpr(it) => { if let Some(arm_expr) = it.match_arm_list().and_then(|l| l.arms().next()).and_then(|a| a.expr()) { expr = arm_expr; } else { break; } }, _ => break, } } } expr }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Update the low bits of the generation id pointer<CODESPLIT>pub(crate) fn write_generation_id_low(&mut self, data: u32) { self.service.generation_id.write_generation_id_low(data) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Using a raw invalidates derived `&mut` even for reading.<CODESPLIT>fn main() { let mut x = 2; let xref1 = &mut x; let xraw = xref1 as *mut _; let xref2 = unsafe { &mut *xraw }; let _val = unsafe { *xraw }; let _illegal = *xref2; }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Set the maximum number of undecryptable packets that can be stored by one connection. The default value is `10`. A value of 0 will be treated as default value.<CODESPLIT>pub fn set_max_undecryptable_packets(&mut self, v: usize) { if v > 0 { self.max_undecryptable_packets = v; } else { self.max_undecryptable_packets = 10; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>A type that produces an [`OperandValue::Ref`] when loaded. AKA one that's not a ZST, not `is_backend_immediate`, and not `is_backend_scalar_pair`. For such a type, a [`load_operand`] doesn't actually `load` anything. [`OperandValue::Ref`]: crate::mir::operand::OperandValue::Ref [`load_operand`]: super::BuilderMethods::load_operand<CODESPLIT>fn is_backend_ref(&self, layout: TyAndLayout<'tcx>) -> bool { !(layout.is_zst() || self.is_backend_immediate(layout) || self.is_backend_scalar_pair(layout)) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `assetRecipient` (0x3bfa67fe) function<CODESPLIT>pub fn asset_recipient( &self, ) -> ::ethers::contract::builders::ContractCall< M, ::ethers::core::types::Address, > { self.0 .method_hash([59, 250, 103, 254], ()) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Sends a request to the host and waits for a fixed-size response. Fails if the response's message ID does not match the request's message ID.<CODESPLIT>async fn send_request_fixed_size<T: AsBytes + ?Sized, U: AsBytes + FromBytes>( &mut self, data: &T, ) -> Result<U, FatalError> { self.send_message(data.as_bytes().to_vec()); let req_header = get_protocol::HeaderHostRequest::read_from_prefix(data.as_bytes()).unwrap(); self.recv_response_fixed_size(req_header.message_id).await }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>@ build-pass @ compile-flags:-Zpolymorphize=on -Csymbol-mangling-version=v0<CODESPLIT>fn foo(f: impl Fn()) { let outer = Vec::<u32>::new(); let x = move |_: ()| { let inner = outer; () }; let y = || x(()); f(); y(); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns the relative path from the source directory to the recipe.<CODESPLIT>pub fn manifests(&self) -> Vec<String> { self.recipe_dir .strip_prefix(&self.source_dir) .unwrap_or(&self.recipe_dir) .join("meta.yaml") .to_str() .map(|s| s.to_string()) .into_iter() .collect() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `getBuyNFTQuote` (0xa5cb2b91) function<CODESPLIT>pub fn get_buy_nft_quote( &self, num_nf_ts: ::ethers::core::types::U256, ) -> ::ethers::contract::builders::ContractCall< M, ( u8, ::ethers::core::types::U256, ::ethers::core::types::U256, ::ethers::core::types::U256, ::ethers::core::types::U256, ), > { self.0 .method_hash([165, 203, 43, 145], num_nf_ts) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `getBuyNFTQuote` (0xa5cb2b91) function<CODESPLIT>pub fn get_buy_nft_quote( &self, num_nf_ts: ::ethers::core::types::U256, ) -> ::ethers::contract::builders::ContractCall< M, ( u8, ::ethers::core::types::U256, ::ethers::core::types::U256, ::ethers::core::types::U256, ::ethers::core::types::U256, ), > { self.0 .method_hash([165, 203, 43, 145], num_nf_ts) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Converts `r` into a local inference variable: `r` can either be a `ReVar` (i.e., already a reference to an inference variable) or it can be `'static` or some early-bound region. This is useful when taking the results from type-checking and trait-matching, which may sometimes reference those regions from the `ParamEnv`. It is also used during initialization. Relies on the `indices` map having been fully initialized.<CODESPLIT>fn to_region_vid(&self, r: ty::Region<'tcx>) -> RegionVid { if let ty::ReVar(..) = *r { r.as_var() } else if let ty::ReError(guar) = *r { self.tainted_by_errors.set(Some(guar)); // We use the `'static` `RegionVid` because `ReError` doesn't actually exist in the self.fr_static } else { *self .indices .get(&r) .unwrap_or_else(|| bug!("cannot convert `{:?}` to a region vid", r)) } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Add system index. Indexes won't be backfilled and available for queries until after the transaction has committed.<CODESPLIT>pub async fn add_system_index( &mut self, namespace: TableNamespace, index: IndexMetadata<TableName>, ) -> anyhow::Result<()> { anyhow::ensure!( self.tx.identity().is_admin() || self.tx.identity().is_system(), unauthorized_error("add_system_index") ); self._add_index(namespace, index).await?; Ok(()) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>EMIT_MIR nrvo_simple.nrvo.RenameReturnPlace.diff<CODESPLIT>fn nrvo(init: fn(&mut [u8; 1024])) -> [u8; 1024] { let mut buf = [0; 1024]; init(&mut buf); buf }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Deletes a row See also: * [Model::delete_rows]<CODESPLIT>pub fn delete_row(&mut self, sheet: u32, row: i32) -> Result<(), String> { let mut row_data = None; let worksheet = self.model.workbook.worksheet(sheet)?; for rd in &worksheet.rows { if rd.r == row { row_data = Some(rd.clone()); break; } } let data = match worksheet.sheet_data.get(&row) { Some(s) => s.clone(), None => return Err(format!("Row number '{row}' is not valid.")), }; let old_data = Box::new(RowData { row: row_data, data, }); let diff_list = vec![Diff::DeleteRow { sheet, row, old_data, }]; self.push_diff_list(diff_list); self.model.delete_rows(sheet, row, 1) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>custom error is called `ConvexError` in udfs<CODESPLIT>pub fn deserialize_udf_custom_error( message: String, serialized_data: Option<String>, ) -> anyhow::Result<(String, Option<ConvexValue>)> { Ok(if let Some(serialized_data) = serialized_data { let deserialized_custom_data = deserialize_udf_custom_error_data(&serialized_data)?; match deserialized_custom_data { Ok(custom_data) => (message, Some(custom_data)), Err(custom_data_format_error) => (custom_data_format_error.message, None), } } else { (message, None) }) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns the waiting duration until the next deadline is reached. If there have been already deadlines missed it returns a duration of zero.<CODESPLIT>pub fn duration_until_next_deadline(&self) -> Result<Duration, TimeError> { let now = fail!(from self, when Time::now_with_clock(self.clock_type), "Unable to return next duration since the current time could not be acquired."); let now = now.as_duration().as_nanos(); let mut has_missed_deadline = false; self.handle_missed_deadlines(now, |_| { has_missed_deadline = true; CallbackProgression::Stop }); if has_missed_deadline { return Ok(Duration::ZERO); } *self.previous_iteration.borrow_mut() = now; let mut min_time = u128::MAX; for attachment in &*self.attachments.borrow() { min_time = min_time.min(attachment.period - (now - attachment.start_time) % attachment.period); } Ok(Duration::from_nanos(min_time as _)) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>The skipped method shouldn't right-shift<CODESPLIT>pub unsafe fn _mm256_shufflehi_epi32(a: __m256i, imm8: i32) -> __m256i { let imm8 = (imm8 & 0xFF) as u8; let a = a.as_i16x16(); macro_rules! shuffle_done { ($x01:expr, $x23:expr, $x45:expr, $x67:expr) => { #[cfg_attr(rustfmt, rustfmt_skip)] simd_shuffle32(a, a, [ 0, 1, 2, 3, 4+$x01, 4+$x23, 4+$x45, 4+$x67, 8, 9, 10, 11, 12+$x01, 12+$x23, 12+$x45, 12+$x67 ]); }; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Collect garbage from the manifest store. This will delete any manifests that are older than the minimum age specified in the options.<CODESPLIT>async fn collect_garbage_manifests(&self) -> Result<(), SlateDBError> { let utc_now = Utc::now(); let min_age = self .options .manifest_options .map_or(DEFAULT_MIN_AGE, |opts| opts.min_age); let mut manifest_metadata_list = self.manifest_store.list_manifests(..).await?; manifest_metadata_list.pop(); for manifest_metadata in manifest_metadata_list { let min_age = chrono::Duration::from_std(min_age).expect("invalid duration"); if utc_now.signed_duration_since(manifest_metadata.last_modified) > min_age { if let Err(e) = self .manifest_store .delete_manifest(manifest_metadata.id) .await { error!("Error deleting manifest: {}", e); } else { self.db_stats.gc_manifest_count.inc(); } } } Ok(()) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Import exported macros from another crate. `names`, if `Some(_)`, specifies the name of macros to be imported. Otherwise this method imports all exported macros. Exported macros are just all macros in the root module scope. Note that it contains not only all `#[macro_export]` macros, but also all aliases created by `use` in the root module, ignoring the visibility of `use`.<CODESPLIT>fn import_macros_from_extern_crate( &mut self, krate: CrateId, names: Option<Vec<Name>>, extern_crate: Option<ExternCrateId>, ) { let def_map = self.db.crate_def_map(krate); let root_scope = &def_map[DefMap::ROOT].scope; match names { Some(names) => { for name in names { if let Some(def) = root_scope.get(&name).take_macros() { self.def_map.macro_use_prelude.insert(name, (def, extern_crate)); } } } None => { for (name, def) in root_scope.macros() { self.def_map.macro_use_prelude.insert(name.clone(), (def, extern_crate)); } } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Convert an CHW float tensor with values in the range [0, 1] to `Vec<u8>` with values scaled to [0, 255].<CODESPLIT>fn image_from_tensor(tensor: NdTensorView<f32, 3>) -> Vec<u8> { tensor .iter() .map(|x| (x.clamp(0., 1.) * 255.0) as u8) .collect() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Return a copy of `self` that owns an allocated `String` but does not borrow an `&Url`.<CODESPLIT>pub fn to_owned(&self) -> Host<String> { match *self { Host::Domain(domain) => Host::Domain(domain.to_owned()), Host::Ipv4(address) => Host::Ipv4(address), Host::Ipv6(address) => Host::Ipv6(address), } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Helper function to write an OsStr as a null-terminated sequence of bytes, which is what the Unix APIs usually handle. Returns `(success, full_len)`, where length includes the null terminator. On failure, nothing is written.<CODESPLIT>fn write_os_str_to_c_str( &mut self, os_str: &OsStr, ptr: Pointer, size: u64, ) -> InterpResult<'tcx, (bool, u64)> { let bytes = os_str.as_encoded_bytes(); self.eval_context_mut().write_c_str(bytes, ptr, size) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>FIXME: rustc's ty is dependent on the adt type, maybe we need to do that as well<CODESPLIT>pub fn discr_ty() -> Ty { TyKind::Scalar(chalk_ir::Scalar::Int(chalk_ir::IntTy::I128)).intern(Interner) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>This function takes a selection vector and a set of columns and returns a new set of columns that only contains the selected rows. The function panics if the selection vector is a different length than the columns. The function returns a tuple of the filtered columns and the number of rows in the filtered columns. # Panics This function requires that `columns` and `selection` have the same length.<CODESPLIT>pub fn filter_columns<'a, S: Scalar>( alloc: &'a Bump, columns: &[Column<'a, S>], selection: &[bool], ) -> (Vec<Column<'a, S>>, usize) { for col in columns { assert_eq!(col.len(), selection.len()); } let indexes: Vec<_> = selection .iter() .enumerate() .filter(|(_, &b)| b) .map(|(i, _)| i) .collect(); let result_length = indexes.len(); let filtered_result: Vec<_> = columns .iter() .map(|column| filter_column_by_index(alloc, column, &indexes)) .collect(); (filtered_result, result_length) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>bindings_after_at + slice_patterns + or_patterns + box_patterns<CODESPLIT>fn bindings_after_at_slice_patterns_or_patterns_box_patterns_borrows( mut x: [Option<Box<Test>>; 4] ) { let r = match x { [_, ref a @ Some(box Test::Foo | box Test::Bar), ..] => Some(a), _ => None, }; &mut x; drop(r); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>checks if this reference requires `&mut` access inside node<CODESPLIT>fn reference_is_exclusive( reference: &FileReference, node: &dyn HasTokenAtOffset, ctx: &AssistContext<'_>, ) -> bool { // FIXME: this quite an incorrect way to go about doing this :-) // `FileReference` is an IDE-type --- it encapsulates data communicated to the human, // but doesn't necessary fully reflect all the intricacies of the underlying language semantics if reference.category.contains(ReferenceCategory::WRITE) { return true; } let path = match path_element_of_reference(node, reference) { Some(path) => path, None => return false, }; expr_require_exclusive_access(ctx, &path).unwrap_or(false) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns true if the corresponding type is inhabited in the given `ParamEnv` and module.<CODESPLIT>pub fn apply( self, tcx: TyCtxt<'tcx>, typing_env: TypingEnv<'tcx>, module_def_id: DefId, ) -> bool { self.apply_revealing_opaque(tcx, typing_env, module_def_id, &|_| None) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>rustfmt-normalize_comments: true<CODESPLIT>fn main() { match x { S(true, .., true) => (), S(true, ..) => (), S(.., true) => (), S(..) => (), S(_) => (), S( ..) => (), S( .., true) => (), } match y { (true, .., true) => (), (true, ..) => (), (.., true) => (), (..) => (), (_,) => (), ( ..) => (), ( .., true) => (), } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Applies the Poseidon2 hash function to the given array. Reference: [p3_symmetric::PaddingFreeSponge]<CODESPLIT>fn poseidon2_hash(builder: &mut Builder<C>, input: &[Felt<C::F>]) -> [Felt<C::F>; DIGEST_SIZE] { let mut state = core::array::from_fn(|_| builder.eval(C::F::zero())); for input_chunk in input.chunks(HASH_RATE) { state[..input_chunk.len()].copy_from_slice(input_chunk); state = Self::poseidon2_permute(builder, state); } let digest: [Felt<C::F>; DIGEST_SIZE] = state[..DIGEST_SIZE].try_into().unwrap(); digest }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Use internal API to find a function in a crate.<CODESPLIT>fn get_item<'a>( items: &'a stable_mir::CrateItems, item: (ItemKind, &str), ) -> Option<&'a stable_mir::CrateItem> { items.iter().find(|crate_item| { crate_item.kind() == item.0 && crate_item.name() == item.1 }) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns an iterator of dates in a given year.<CODESPLIT>fn dates_in_year(year: i32) -> impl Iterator<Item=NaiveDate>+Clone { InGroup { it: NaiveDate::from_ymd(year, 1, 1).., f: |d: &NaiveDate| d.year(), g: year } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Join two `Certainty`s preserving their `DefId`s (if any). Generally speaking, this method should be used only when `self` and `other` refer directly to types. Otherwise, `join_clearing_def_ids` should be used.<CODESPLIT>pub fn join(self, other: Self) -> Self { match (self, other) { (Certainty::Contradiction, _) | (_, Certainty::Contradiction) => Certainty::Contradiction, (Certainty::Certain(lhs), Certainty::Certain(rhs)) => { if let Some(inner) = lhs.try_join(rhs) { Certainty::Certain(inner) } else { debug_assert!(false, "Contradiction with {lhs:?} and {rhs:?}"); Certainty::Contradiction } }, (Certainty::Certain(inner), _) | (_, Certainty::Certain(inner)) => Certainty::Certain(inner), (Certainty::Uncertain, Certainty::Uncertain) => Certainty::Uncertain, } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>@ run-fail @ compile-flags: -Copt-level=3 -Cdebug-assertions=no -Zub-checks=yes @ error-pattern: unsafe precondition(s) violated: slice::from_raw_parts_mut requires @ revisions: null misaligned toolarge<CODESPLIT>fn main() { unsafe { #[cfg(null)] let _s: &mut [u8] = std::slice::from_raw_parts_mut(std::ptr::null_mut(), 0); #[cfg(misaligned)] let _s: &mut [u16] = std::slice::from_raw_parts_mut(1usize as *mut u16, 0); #[cfg(toolarge)] let _s: &mut [u16] = std::slice::from_raw_parts_mut(2usize as *mut u16, isize::MAX as usize); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>The normal borrows here should be preserved EMIT_MIR address_of.borrow_and_cast.SimplifyCfg-initial.after.mir<CODESPLIT>fn borrow_and_cast(mut x: i32) { let p = &x as *const i32; let q = &mut x as *const i32; let r = &mut x as *mut i32; }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>returns an empty range with the nextlsn set to the first lsn of the target range<CODESPLIT>pub fn empty_preceeding(range: &LsnRange) -> Self { LsnRange::Empty { nextlsn: match range { LsnRange::Empty { nextlsn } => *nextlsn, LsnRange::NonEmpty { first, .. } => *first, }, } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>rustfmt-brace_style: SameLineWhere rustfmt-where_single_line: true<CODESPLIT>fn lorem_multi_line_clauseless<Ipsum, Dolor, Sit, Amet>( a: Aaaaaaaaaaaaaaa, b: Bbbbbbbbbbbbbbbb, c: Ccccccccccccccccc, d: Ddddddddddddddddddddddddd, e: Eeeeeeeeeeeeeeeeeee, ) -> T { }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Foreign Write on a Reserved turns it Disabled.<CODESPLIT>unsafe fn int_unprotected_write() { print("[] Foreign Write: Res -> Dis"); let base = &mut 0u8; name!(base); let alloc_id = alloc_id!(base); let x = &mut *(base as *mut u8); name!(x); let y = (&mut *base) as *mut u8; name!(y); *y = 1; print_state!(alloc_id); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Verify that we do not try to reason when there are mutable pointers involved.<CODESPLIT>fn mutable_ref() -> bool { let mut x = 5; let a = std::ptr::addr_of_mut!(x); x = 7; unsafe { *a = 8 }; if x == 7 { true } else { false } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns whether the given function is nested within the body of another function.<CODESPLIT>fn is_nested_function(function: &ast::Fn) -> bool { function.syntax().ancestors().skip(1).find_map(ast::Item::cast).map_or(false, |it| { matches!(it, ast::Item::Fn(_) | ast::Item::Static(_) | ast::Item::Const(_)) }) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Helper method to construct an MADT without constructing the rest of the ACPI tables.<CODESPLIT>pub fn build_madt(&self) -> Vec<u8> { self.with_madt(|t| t.to_vec(&OEM_INFO)) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Insert the `file_id, path` pair into the set. # Note Multiple [`FileId`] can be mapped to the same [`VfsPath`], and vice-versa.<CODESPLIT>pub fn insert(&mut self, file_id: FileId, path: VfsPath) { self.files.insert(path.clone(), file_id); self.paths.insert(file_id, path); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `safeTransferFrom` (0x42842e0e) function<CODESPLIT>pub fn safe_transfer_from( &self, from: ::ethers::core::types::Address, to: ::ethers::core::types::Address, token_id: ::ethers::core::types::U256, ) -> ::ethers::contract::builders::ContractCall<M, ()> { self.0 .method_hash([66, 132, 46, 14], (from, to, token_id)) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Compile `expr`, yielding a compile-time constant. Assumes that `expr` is a valid compile-time constant!<CODESPLIT>pub(crate) fn as_constant(&mut self, expr: &Expr<'tcx>) -> ConstOperand<'tcx> { let this = self; let tcx = this.tcx; let Expr { ty, temp_lifetime: _, span, ref kind } = *expr; match kind { ExprKind::Scope { region_scope: _, lint_level: _, value } => { this.as_constant(&this.thir[*value]) } _ => as_constant_inner( expr, |user_ty| { Some(this.canonical_user_type_annotations.push(CanonicalUserTypeAnnotation { span, user_ty: user_ty.clone(), inferred_ty: ty, })) }, tcx, ), } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns default server configuration along with its certificate.<CODESPLIT>fn configure_server() -> Result<(ServerConfig, Vec<u8>), Box<dyn Error>> { let (certs, key) = get_insecure_tls_cert(); let mut server_config = ServerConfig::with_single_cert(certs.clone(), key.into())?; let transport_config = Arc::get_mut(&mut server_config.transport).unwrap(); transport_config.max_concurrent_uni_streams(10_u8.into()); transport_config.max_concurrent_bidi_streams(10_u8.into()); Ok((server_config, certs[0].to_vec())) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Extract the secret key from configuration. It should be provided as a base64 string encoding 256 bits of entropy.<CODESPLIT>pub fn secret_key(&self) -> Result<Vec<u8>, Error> { use base64::{engine::general_purpose, Engine as _}; let bytes = general_purpose::STANDARD.decode(&self.secret_key)?; if bytes.len() == 256 / 8 { Ok(bytes) } else { Err(Error::SecretKey) } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>A hint to the backend specifying the guest VP associated with spawned tasks and IO. Backends can use this to ensure that spawned tasks and async IO will run near or on the target VP.<CODESPLIT>pub fn target_vp(&mut self, target_vp: u32) -> &mut Self { self.target_vp = Some(target_vp); self }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>FIXME: remove when no one depends on `generate_impl_text_inner`<CODESPLIT>pub fn type_bound_text(bound: &str) -> ast::TypeBound { ast_from_text(&format!("fn f<T: {bound}>() {{ }}")) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns a new result set. `leaves` may contain multiple results for the same function and index. In this case, they are merged internally (respecting their mask bits), with later leaves overriding earlier ones.<CODESPLIT>pub fn new(mut leaves: Vec<CpuidLeaf>) -> Self { leaves.sort_by(|x, y| x.cmp_key(y)); leaves.dedup_by(|right, left| { if left.cmp_key(right).is_ne() { return false; } right.apply(&mut left.result); for (x, y) in left.mask.iter_mut().zip(right.mask) { *x |= y; } true }); Self { leaves } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Set the `initial_max_stream_data_bidi_remote` transport parameter. The value is capped by the setting `max_stream_window`. The default value is `2097152`.<CODESPLIT>pub fn set_initial_max_stream_data_bidi_remote(&mut self, v: u64) { self.local_transport_params .initial_max_stream_data_bidi_remote = cmp::min(v, self.max_stream_window); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `getAssetRecipient` (0x79eac6c2) function<CODESPLIT>pub fn get_asset_recipient( &self, ) -> ::ethers::contract::builders::ContractCall< M, ::ethers::core::types::Address, > { self.0 .method_hash([121, 234, 198, 194], ()) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns the set index for the given `path`. `scratch_space` is used as a buffer and will be entirely replaced.<CODESPLIT>fn classify(&self, path: &VfsPath, scratch_space: &mut Vec<u8>) -> usize { let path = path.parent().unwrap_or_else(|| path.clone()); scratch_space.clear(); path.encode(scratch_space); let automaton = PrefixOf::new(scratch_space.as_slice()); let mut longest_prefix = self.len() - 1; let mut stream = self.map.search(automaton).into_stream(); while let Some((_, v)) = stream.next() { longest_prefix = v as usize; } longest_prefix }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Apply a binary operator to a slice and a single value with left upcasting returning results.<CODESPLIT>pub(crate) fn try_slice_lit_binary_op_left_upcast<S, T, U, F>( lhs: &[S], rhs: &T, op: F, ) -> ColumnOperationResult<Vec<U>> where S: Copy + Into<T>, T: Copy, F: Fn(&T, &T) -> ColumnOperationResult<U>, { try_slice_lit_binary_op(lhs, rhs, |l, r| op(&Into::<T>::into(*l), r)) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>issue: 120878<CODESPLIT>fn main() { struct StructA<A, B = A> { _marker: std::marker::PhantomData<fn() -> (A, B)>, } struct StructB { a: StructA<isize, [u8]>, } trait Trait { type P<X>; } impl Trait for () { type P<X> = [u8]; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>CHECK: define{{.*}}5foo14{{.*}}!type ![[TYPE14:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}<CODESPLIT>pub fn foo15(_: fn(i32) -> i32, _: fn(i32) -> i32, _: fn(i32) -> i32) {}
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Polls the ring for successful write of `packet`.<CODESPLIT>pub fn poll_write( &mut self, cx: &mut Context<'_>, packet: &OutgoingPacket<'_, '_>, ) -> Poll<Result<(), Error>> { let mut send_size = 32; let r = loop { std::task::ready!(self.write.poll_ready(cx, self.core, send_size)) .map_err(ErrorInner::from)?; match self.try_write(packet) { Ok(()) => break Ok(()), Err(TryWriteError::Full(len)) => send_size = len, Err(TryWriteError::Queue(err)) => break Err(err), } }; Poll::Ready(r) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Associates a `Notifier` with the server.<CODESPLIT>pub fn with_notifier<'a, T: Notifier>( &'a mut self, notifier: &'a mut T, ) -> ServerWithNotifier<'a, T> { self.validate(); ServerWithNotifier { inner: self, notifier, } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Note below: bounds in impl decl are in reverse order.<CODESPLIT>fn combine<T:B+A>(&self, t: &T) -> usize { (t.a() * 100) + t.b() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>return the pivot at the separating `,`<CODESPLIT>pub(crate) fn parse_pair(s: &str) -> Result<usize, &'static str> { let mut depth = 0; for (i, c) in s[..s.len() - 1].chars().enumerate() { if c == ',' && depth == 0 { return Ok(i); } if c == '<' { depth += 1; } if c == '>' { depth -= 1; } } if depth != 0 { return Err("unmatched < >"); } return Err("cannot find ,"); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>fake function that shouldn't trigger the lint<CODESPLIT>pub fn from_str_radix(_: &str, _: u32) -> Result<(), std::num::ParseIntError> { unimplemented!() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Verify (via Merkle tree) that the vkey digests of a proof belong to a specified set (encoded the Merkle tree proofs in input).<CODESPLIT>pub fn verify( builder: &mut Builder<C>, digests: Vec<SC::DigestVariable>, input: SP1MerkleProofWitnessVariable<C, SC>, value_assertions: bool, ) { let SP1MerkleProofWitnessVariable { vk_merkle_proofs, values, root } = input; for ((proof, value), expected_value) in vk_merkle_proofs.into_iter().zip(values).zip(digests) { verify(builder, proof, value, root); if value_assertions { SC::assert_digest_eq(builder, expected_value, value); } else { SC::assert_digest_eq(builder, value, value); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Write a byte to a port. # Safety The caller must be sure that the given port is safe to write to, and that the given value is safe for it.<CODESPLIT>unsafe fn outb(port: u16, data: u8) { unsafe { asm! { "out dx, al", in("dx") port, in("al") data, } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Parses a desugared `while` loop<CODESPLIT>pub const fn hir(expr: &Expr<'hir>) -> Option<Self> { if let ExprKind::Loop( Block { expr: Some(Expr { kind: ExprKind::If( Expr { kind: ExprKind::DropTemps(condition), .. }, body, _, ), .. }), .. }, _, LoopSource::While, span, ) = expr.kind { return Some(Self { condition, body, span }); } None }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>rustfmt-indent_style: Block Function call style<CODESPLIT>fn main() { lorem( "lorem", "ipsum", "dolor", "sit", "amet", "consectetur", "adipiscing", "elit", ); let hyper = Arc::new(Client::with_connector( HttpsConnector::new(TlsClient::new()), )); let x = yooooooooooooo .fooooooooooooooo .baaaaaaaaaaaaar(hello, world); { { let creds = self .client .client_credentials(&self.config.auth.oauth2.id, &self.config.auth.oauth2.secret)?; } } try!(foo( xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx )); try!(foo(try!( xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx ))); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Resolve an instance starting from a function definition and generic arguments.<CODESPLIT>pub fn resolve(def: FnDef, args: &GenericArgs) -> Result<Instance, crate::Error> { with(|context| { context.resolve_instance(def, args).ok_or_else(|| { crate::Error::new(format!("Failed to resolve `{def:?}` with `{args:?}`")) }) }) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Hashes the bytes to a field element and returns the byte representation<CODESPLIT>pub(crate) fn sum(&self) -> Result<Vec<u8>, PlonkError> { let res = Self::hash(self.to_hash.clone(), self.domain.clone(), 1)?; Ok(res[0].clone()) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>This is a callback from `rustc_hir` as it cannot access the implicit state in `rustc_middle` otherwise.<CODESPLIT>fn def_id_debug(def_id: rustc_hir::def_id::DefId, f: &mut fmt::Formatter<'_>) -> fmt::Result { write!(f, "DefId({}:{}", def_id.krate, def_id.index.index())?; tls::with_opt(|opt_tcx| { if let Some(tcx) = opt_tcx { write!(f, " ~ {}", tcx.def_path_debug_str(def_id))?; } Ok(()) })?; write!(f, ")") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Check that associated paths starting with `<<` are successfully parsed.<CODESPLIT>fn main() { let _: <<A>::B>::C; let _ = <<A>::B>::C; let <<A>::B>::C; let 0 ..= <<A>::B>::C; <<A>::B>::C; }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>even without panics, this helps for Miri backtraces<CODESPLIT>pub const unsafe fn unreachable_unchecked() -> ! { ub_checks::assert_unsafe_precondition!( check_language_ub, "hint::unreachable_unchecked must never be reached", () => false ); unsafe { intrinsics::unreachable() } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns `None` if the first `col` chars of `s` contain a non-whitespace char. Otherwise returns `Some(k)` where `k` is first char offset after that leading whitespace. Note that `k` may be outside bounds of `s`.<CODESPLIT>fn all_whitespace(s: &str, col: CharPos) -> Option<usize> { let mut idx = 0; for (i, ch) in s.char_indices().take(col.to_usize()) { if !ch.is_whitespace() { return None; } idx = i + ch.len_utf8(); } Some(idx) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>FIXME: Move this out, its not a diagnostic only thing anymore, and handle unsafe pattern accesses as well<CODESPLIT>pub fn unsafe_expressions( db: &dyn HirDatabase, infer: &InferenceResult, def: DefWithBodyId, body: &Body, current: ExprId, unsafe_expr_cb: &mut dyn FnMut(UnsafeExpr), ) { walk_unsafe( db, infer, body, &mut resolver_for_expr(db.upcast(), def, current), def, current, false, unsafe_expr_cb, ) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Run a future to completion on the current thread.<CODESPLIT>fn block_on<T>(fut: impl Future<Output = T>) -> T { let mut fut = Box::pin(fut); let t = thread::current(); let waker = Arc::new(ThreadWaker(t)).into(); let mut cx = Context::from_waker(&waker); loop { match fut.as_mut().poll(&mut cx) { Poll::Ready(res) => return res, Poll::Pending => thread::park(), } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>~^ ERROR defaults for type parameters are only allowed in `struct`, `enum`, `type`, or `trait` definitions ~| WARNING this was previously accepted by the compiler but is being phased out ~| ERROR `impl Trait` is not allowed in generic parameter defaults<CODESPLIT>fn main() { let _in_local_variable: impl Fn() = || {}; let _in_return_in_local_variable = || -> impl Fn() { || {} }; }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Derives a key from a master key and a derivation path<CODESPLIT>pub fn derive_key( master_key: ExtendedPrivKey, path: DerivationPath, ) -> ExtendedPrivKey { master_key.derive_priv(&Secp256k1::new(), &path).unwrap() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Visits leaf nodes and internal KVs in order of ascending keys, and also visits internal nodes as a whole in a depth first order, meaning that internal nodes precede their individual KVs and their child nodes.<CODESPLIT>pub fn visit_nodes_in_order<F>(self, mut visit: F) where F: FnMut(Position<marker::Immut<'a>, K, V>), { match self.force() { Leaf(leaf) => visit(Position::Leaf(leaf)), Internal(internal) => { visit(Position::Internal(internal)); let mut edge = internal.first_edge(); loop { edge = match edge.descend().force() { Leaf(leaf) => { visit(Position::Leaf(leaf)); match edge.next_kv() { Ok(kv) => { visit(Position::InternalKV); kv.right_edge() } Err(_) => return, } } Internal(internal) => { visit(Position::Internal(internal)); internal.first_edge() } } } } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Get the search patterns to use for the given path<CODESPLIT>fn qpath_search_pat(path: &QPath<'_>) -> (Pat, Pat) { match path { QPath::Resolved(ty, path) => { let start = if ty.is_some() { Pat::Str("<") } else { path.segments.first().map_or(Pat::Str(""), |seg| { if seg.ident.name == kw::PathRoot { Pat::Str("::") } else { Pat::Sym(seg.ident.name) } }) }; let end = path.segments.last().map_or(Pat::Str(""), |seg| { if seg.args.is_some() { Pat::Str(">") } else { Pat::Sym(seg.ident.name) } }); (start, end) }, QPath::TypeRelative(_, name) => (Pat::Str(""), Pat::Sym(name.ident.name)), QPath::LangItem(..) => (Pat::Str(""), Pat::Str("")), } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `getOrderHash` (0x79df72bd) function<CODESPLIT>pub fn get_order_hash( &self, order: OrderComponents, ) -> ::ethers::contract::builders::ContractCall<M, [u8; 32]> { self.0 .method_hash([121, 223, 114, 189], (order,)) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>handle_storage_change checks if the storage change affects this query sets the state to dirty if it does returns self.is_dirty()<CODESPLIT>pub fn handle_storage_change(&mut self, change: &StorageChange) -> bool { match self.state { State::Dirty => {} State::Monitoring { root_pages_sorted: ref root_pages } => match change { StorageChange::Full => self.state = State::Dirty, StorageChange::Tables { root_pages_sorted: ref changed_root_pages, } => { if has_sorted_intersection(root_pages, changed_root_pages) { self.state = State::Dirty; } } }, State::Error => self.state = State::Dirty, } self.is_dirty() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Ok, dropping opt doesn't access the reference<CODESPLIT>fn optional_tuple(opt: Option<(&mut i32, String)>) -> Option<&mut i32> { match opt { Some((&mut ref mut r, _)) => { Some(r) }, None => None, } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Tires to get the value of Const `size` as usize.<CODESPLIT>pub fn try_resolve_const_size(size: Const) -> Result<usize, &'static str> { let (scalar, ty) = match size.try_to_scalar() { Some(value) => Ok(value), None => Err("Can't resolve scalar array size!"), }?; let value = scalar.to_u64().expect("Could not convert scalar to u64!"); Ok(usize::try_from(value).expect("Const size value too big.")) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Makes duplicate argument names unique by appending incrementing numbers. ``` let mut names: Vec<String> = vec!["foo".into(), "foo".into(), "bar".into(), "baz".into(), "bar".into()]; deduplicate_arg_names(&mut names); let expected: Vec<String> = vec!["foo_1".into(), "foo_2".into(), "bar_1".into(), "baz".into(), "bar_2".into()]; assert_eq!(names, expected); ```<CODESPLIT>fn deduplicate_arg_names(arg_names: &mut [String]) { let mut arg_name_counts = FxHashMap::default(); for name in arg_names.iter() { *arg_name_counts.entry(name).or_insert(0) += 1; } let duplicate_arg_names: FxHashSet<String> = arg_name_counts .into_iter() .filter(|(_, count)| *count >= 2) .map(|(name, _)| name.clone()) .collect(); let mut counter_per_name = FxHashMap::default(); for arg_name in arg_names.iter_mut() { if duplicate_arg_names.contains(arg_name) { let counter = counter_per_name.entry(arg_name.clone()).or_insert(1); arg_name.push('_'); arg_name.push_str(&counter.to_string()); *counter += 1; } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Offers a simple vmbus device, creates a unit for it, and adds it to `state_units`.<CODESPLIT>pub async fn offer_simple_device_unit<T: SimpleVmbusDevice>( driver_source: &VmTaskDriverSource, state_units: &StateUnits, vmbus: &VmbusServerHandle, device: T, ) -> anyhow::Result<SpawnedUnit<SimpleChannelUnit<T>>> { let offer = device.offer(); let name = format!("{}:{}", offer.interface_name, offer.instance_id); let handle = offer_simple_device(driver_source, vmbus.control.as_ref(), device).await?; let unit = state_units .add(name) .depends_on(vmbus.unit.handle()) .spawn(driver_source.simple(), |recv| { run_async_unit(SimpleChannelUnit(handle), recv) })?; Ok(unit) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns a suitable node for resolving paths in the current scope. If we create a scope based on a statement node, then we can't resolve local variables that were defined in the current scope (only in parent scopes). So we find another node, ideally a child of the statement where local variable resolution is permitted.<CODESPLIT>fn pick_node_for_resolution(node: SyntaxNode) -> SyntaxNode { match node.kind() { SyntaxKind::EXPR_STMT => { if let Some(n) = node.first_child() { cov_mark::hit!(cursor_after_semicolon); return n; } } SyntaxKind::LET_STMT | SyntaxKind::IDENT_PAT => { if let Some(next) = node.next_sibling() { return pick_node_for_resolution(next); } } SyntaxKind::NAME => { if let Some(parent) = node.parent() { return pick_node_for_resolution(parent); } } _ => {} } node }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Assumes this is only called by the thread that owns the Parker, which means that `self.state != PARKED`. This implementation doesn't require `Pin`, but other implementations do.<CODESPLIT>pub unsafe fn park_timeout(self: Pin<&Self>, timeout: Duration) { if self.state.fetch_sub(1, Acquire) == NOTIFIED { return; } #[cfg(target_vendor = "win7")] if c::WaitOnAddress::option().is_none() { return keyed_events::park_timeout(self, timeout); } c::WaitOnAddress(self.ptr(), &PARKED as *const _ as *const c_void, 1, dur2timeout(timeout)); if self.state.swap(EMPTY, Acquire) == NOTIFIED { } else { } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Extend the table with a iterator of new records.<CODESPLIT>pub async fn extend<T: IntoIterator<Item = R> + Send>(&self, iter: T) -> anyhow::Result<Vec<Id>> where R: AsRef<Document> + Serialize + DeserializeOwned, K: Sync, { let entries = iter.into_iter().collect::<Vec<_>>(); let documents = entries.iter().map(|v| v.as_ref()).collect::<Vec<_>>(); let embeddings = self .chunker .chunk_batch(documents, &self.embedding_model) .await?; let mut ids = Vec::new(); for (value, embeddings) in entries.into_iter().zip(embeddings) { let id = self.table.insert(embeddings, value).await?; ids.push(id); } Ok(ids) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Set the name of the model to use.<CODESPLIT>pub fn with_model(self, model: impl ToString) -> RemoteOpenAICompatibleModelBuilder<true> { RemoteOpenAICompatibleModelBuilder { model: Some(model.to_string()), config: self.config, } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Wrap the column output name and its type within the [`ColumnField`]<CODESPLIT>pub fn get_column_field(&self) -> ColumnField { ColumnField::new(self.column_ref.column_id(), *self.column_ref.column_type()) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>SAFETY: caller must ensure the attribute type `n` matches type `T`.<CODESPLIT>unsafe fn attribute<T>(&self, n: u32) -> Option<&T> { if (self.header.ValidAttributes & n) != 0 { unsafe { Some( AlpcGetMessageAttribute(std::ptr::from_ref(&self.header).cast_mut(), n) .cast::<T>() .as_ref() .unwrap(), ) } } else { None } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Try to read the features from the auxiliary vector, and if that fails, try to read them from ` proc cpuinfo`.<CODESPLIT>fn detect_features() -> cache::Initializer { let mut value = cache::Initializer::default(); let enable_feature = |value: &mut cache::Initializer, f, enable| { if enable { value.set(f as u32); } }; if let Ok(auxv) = auxvec::auxv() { enable_feature(&mut value, Feature::msa, bit::test(auxv.hwcap, 1)); return value; } value }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Should not trigger lint since `String::as_str` returns a reference (i.e., `&str`) to the locked data (i.e., the `String`) and it is not surprising that matching such a reference needs to keep the data locked until the end of the match block.<CODESPLIT>fn should_not_trigger_lint_for_string_as_str() { let mutex1 = Mutex::new(StateWithField { s: "one".to_owned() }); { let mutex2 = Mutex::new(StateWithField { s: "two".to_owned() }); let mutex3 = Mutex::new(StateWithField { s: "three".to_owned() }); match mutex3.lock().unwrap().s.as_str() { "three" => { println!("started"); mutex1.lock().unwrap().s.len(); mutex2.lock().unwrap().s.len(); println!("done"); }, _ => {}, }; match (true, mutex3.lock().unwrap().s.as_str()) { (_, "three") => { println!("started"); mutex1.lock().unwrap().s.len(); mutex2.lock().unwrap().s.len(); println!("done"); }, (_, _) => {}, }; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Note that `self` must be nonempty.<CODESPLIT>pub fn first_kv(self) -> Handle<Self, marker::KV> { let len = self.len(); assert!(len > 0); unsafe { Handle::new_kv(self, 0) } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Client send default body to server. Return the body on success.<CODESPLIT>pub fn client_send_body(&mut self, stream: u64, fin: bool) -> Result<Bytes> { let mut body = Bytes::from("Quic Century"); let sent = self .client .send_body(&mut self.pair.client, stream, body.clone(), fin)?; self.move_forward().ok(); body.truncate(sent); Ok(body) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>When SIGSEGV is delivered to the process, print a stack trace and then exit.<CODESPLIT>pub(super) fn install() { unsafe { let alt_stack_size: usize = min_sigstack_size() + 64 * 1024; let mut alt_stack: libc::stack_t = mem::zeroed(); alt_stack.ss_sp = alloc(Layout::from_size_align(alt_stack_size, 1).unwrap()).cast(); alt_stack.ss_size = alt_stack_size; libc::sigaltstack(&alt_stack, ptr::null_mut()); let mut sa: libc::sigaction = mem::zeroed(); sa.sa_sigaction = print_stack_trace as libc::sighandler_t; sa.sa_flags = libc::SA_NODEFER | libc::SA_RESETHAND | libc::SA_ONSTACK; libc::sigemptyset(&mut sa.sa_mask); libc::sigaction(libc::SIGSEGV, &sa, ptr::null_mut()); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Formats the step with the provided parameters and executes it using the associated executor. This function takes a reference to a `Parameters` struct, formats the step with the provided parameters, and executes it using the associated executor. The result of the execution is returned as `E::Output`.<CODESPLIT>pub async fn format_and_execute( &self, parameters: &Parameters, ) -> Result<Output, FormatAndExecuteError> { let prompt = self.step.format(parameters)?; Ok(self.executor.execute(self.step.options(), &prompt).await?) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>@ check-pass @ revisions: default edition2021 @[edition2021] compile-flags: --edition 2021<CODESPLIT>fn main() { type T = impl Copy; let foo: T = Some((1u32, 2u32)); match foo { None => (), Some((a, b)) => (), } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Wait until this node is marked as [`complete`](Node::complete)d by another thread. # Safety May only be called from the thread that created the node.<CODESPLIT>unsafe fn wait(&self) { while !self.completed.load(Acquire) { unsafe { self.thread.get().unwrap().park(); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>rustfmt-max_width: 160 rustfmt-fn_call_width: 96 rustfmt-fn_args_layout: Compressed rustfmt-trailing_comma: Always rustfmt-wrap_comments: true<CODESPLIT>fn foo() { for elem in try!(gen_epub_book::ops::parse_descriptor_file( &mut try!(File::open(&opts.source_file.1).map_err(|_| { gen_epub_book::Error::Io { desc: "input file", op: "open", more: None, } })), "input file" )) { println!("{}", elem); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>~^ ERROR invalid `sym` operand<CODESPLIT>fn main() { unsafe { let x: u64 = 0; const C: i32 = 0; static S: i32 = 0; asm!("{}", sym S); asm!("{}", sym main); asm!("{}", sym C); asm!("{}", sym x); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>this goes to stdout and each line has to be occurred in the following backtrace to stderr with a correct order.<CODESPLIT>fn dump_filelines(filelines: &[Pos]) { for &(file, line) in filelines.iter().rev() { let basename = file.split(&['/', '\\'][..]).last().unwrap(); println!("{}:{}", basename, line); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Computes the wrapping negative of the value. This could perhaps be more efficient.<CODESPLIT>fn neg(self) -> Self { let mut res = ark_ff::BigInt([0; 4]); res.sub_with_borrow(&ark_ff::BigInt(self.0)); Self(res.0) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Adds a sheet with a specific name Fails if a worksheet with that name already exists or the name is invalid<CODESPLIT>pub fn add_sheet(&mut self, sheet_name: &str) -> Result<(), String> { self.insert_sheet(sheet_name, self.workbook.worksheets.len() as u32, None) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>~ ERROR: using raw pointers as const generic parameters<CODESPLIT>fn main() { let _: Const<{ 15 as *const _ }> = Const::<{ 10 as *const _ }>; let _: Const<{ 10 as *const _ }> = Const::<{ 10 as *const _ }>; }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>A "synthetic write" causes the system to act *as though* some input of durability `durability` has changed. This is mostly useful for profiling scenarios. **WARNING:** Just like an ordinary write, this method triggers cancellation. If you invoke it while a snapshot exists, it will block until that snapshot is dropped -- if that snapshot is owned by the current thread, this could trigger deadlock.<CODESPLIT>pub fn synthetic_write(&mut self, durability: Durability) { self.with_incremented_revision(|_next_revision| Some(durability)); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>This expands to either - `$crate::panic::panic_2015!(...)` or - `$crate::panic::panic_2021!(...)` depending on the edition. This is used for both std::panic!() and core::panic!(). `$crate` will refer to either the `std` or `core` crate depending on which one we're expanding from.<CODESPLIT>pub(crate) fn expand_panic<'cx>( cx: &'cx mut ExtCtxt<'_>, sp: Span, tts: TokenStream, ) -> MacroExpanderResult<'cx> { let mac = if use_panic_2021(sp) { sym::panic_2021 } else { sym::panic_2015 }; expand(mac, cx, sp, tts) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Advances the range list by `len` bytes.<CODESPLIT>pub fn skip(&mut self, mut len: usize) { assert!(self.len() >= len); while len > 0 { let n = self.current(len).len(); self.advance(n); len -= n; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>bindings_after_at + slice_patterns + or_patterns<CODESPLIT>fn bindings_after_at_slice_patterns_or_patterns_moves(x: [Option<Test>; 4]) { match x { a @ [.., Some(Test::Foo | Test::Bar)] => (), _ => (), }; &x; }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Prepare to execute the given program on the given input (without generating a proof). Prefer using [ProverClient::execute](super::ProverClient::execute). See there for more documentation.<CODESPLIT>pub fn new( prover: &'a dyn Prover<DefaultProverComponents>, elf: &'a [u8], stdin: SP1Stdin, ) -> Self { Self { prover, elf, stdin, context_builder: Default::default() } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Removes a key-value pair from the tree, and returns that pair, as well as the leaf edge corresponding to that former pair. It's possible this empties a root node that is internal, which the caller should pop from the map holding the tree. The caller should also decrement the map's length.<CODESPLIT>pub fn remove_kv_tracking<F: FnOnce(), A: Allocator + Clone>( self, handle_emptied_internal_root: F, alloc: A, ) -> ((K, V), Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>) { match self.force() { Leaf(node) => node.remove_leaf_kv(handle_emptied_internal_root, alloc), Internal(node) => node.remove_internal_kv(handle_emptied_internal_root, alloc), } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Give appropriate suggestion when encountering `[("a", 0) ("b", 1)]`, where the likely intention is to create an array containing tuples.<CODESPLIT>fn maybe_suggest_bad_array_definition( &self, err: &mut Diag<'_>, call_expr: &'tcx hir::Expr<'tcx>, callee_expr: &'tcx hir::Expr<'tcx>, ) -> bool { let parent_node = self.tcx.parent_hir_node(call_expr.hir_id); if let ( hir::Node::Expr(hir::Expr { kind: hir::ExprKind::Array(_), .. }), hir::ExprKind::Tup(exp), hir::ExprKind::Call(_, args), ) = (parent_node, &callee_expr.kind, &call_expr.kind) && args.len() == exp.len() { let start = callee_expr.span.shrink_to_hi(); err.span_suggestion( start, "consider separating array elements with a comma", ",", Applicability::MaybeIncorrect, ); return true; } false }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>EMIT_MIR early_otherwise_branch_noopt.noopt1.EarlyOtherwiseBranch.diff<CODESPLIT>fn noopt1(x: Option<u32>, y: Option<u32>) -> u32 { match (x, y) { (Some(a), Some(b)) => 0, (Some(a), None) => 1, (None, Some(b)) => 2, (None, None) => 3, } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `onERC1155Received` (0xf23a6e61) function<CODESPLIT>pub fn on_erc1155_received( &self, p0: ::ethers::core::types::Address, p1: ::ethers::core::types::Address, p2: ::ethers::core::types::U256, p3: ::ethers::core::types::U256, p4: ::ethers::core::types::Bytes, ) -> ::ethers::contract::builders::ContractCall<M, [u8; 4]> { self.0 .method_hash([242, 58, 110, 97], (p0, p1, p2, p3, p4)) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Increases the size of an previously allocated chunk of memory or allocates a new chunk with the provided properties. If the chunk can be resized only the difference in size will be zeroed. It returns a failure when the size decreases. # Safety * `ptr` must be allocated previously with [`BaseAllocator::allocate()`] or [`BaseAllocator::allocate_zeroed()`] * `old_layout` must have the same value as in the allocation or, when the memory was resized, the same value as it was resized to<CODESPLIT>unsafe fn grow_zeroed( &self, ptr: NonNull<u8>, old_layout: Layout, new_layout: Layout, ) -> Result<NonNull<[u8]>, AllocationGrowError> { let memory = self.grow(ptr, old_layout, new_layout)?; std::ptr::write_bytes( memory.as_ref().as_ptr().add(old_layout.size()) as *mut u8, 0, memory.as_ref().len() - old_layout.size(), ); Ok(memory) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Check that we do simplify when there is no provenance, and do not ICE.<CODESPLIT>fn wide_ptr_integer() { let a: *const [u8] = unsafe { transmute((1usize, 1usize)) }; let b: *const [u8] = unsafe { transmute((1usize, 2usize)) }; opaque(a == b); opaque(a != b); opaque(a < b); opaque(a <= b); opaque(a > b); opaque(a >= b); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Creates a directory walker with a root path and strategy.<CODESPLIT>pub fn new(p: &S::P, strategy: S) -> io::Result<Subpaths<S>> { let stack = strategy.get_more(p)?; Ok(Subpaths { stack: stack, strategy: strategy }) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>@ compile-flags: -D while-true @ run-rustfix<CODESPLIT>fn main() { let mut i = 0; 'a: while true { //~ ERROR denote infinite loops with `loop i += 1; if i == 5 { break 'a; } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Assuming all system tables are in the table mapping, does a table id correspond to a system table?<CODESPLIT>pub fn is_system_tablet(&self, tablet_id: TabletId) -> bool { match self.tablet_to_table.get(&tablet_id) { Some((_, _, t)) => t.is_system(), None => false, } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Often crashes, if not prints invalid strings.<CODESPLIT>pub fn panics() { let mut acc = Counter{map: HashMap::new()}; for line in vec!["123456789".to_string(), "12345678".to_string()] { let v: Vec<&str> = line.split_whitespace().collect(); let mut map = HashMap::new(); for str_ref in v { let e = map.entry(str_ref); println!("entry: {:?}", e); let count = e.or_insert(0); *count += 1; } let cnt2 = Counter{map}; acc += cnt2; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>This operation takes a slice and casts it to a mutable slice of a different type using the provided function.<CODESPLIT>pub fn slice_cast_mut_with<'a, F, T>( value: &'a [F], result: &mut [T], cast: impl Fn(&'a F) -> T + Sync, ) where F: Sync, T: Send + Sync, { if_rayon!( value.par_iter().with_min_len(super::MIN_RAYON_LEN), value.iter() ) .zip(result) .for_each(|(a, b)| *b = cast(a)); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Split the stream into windows of a given duration.<CODESPLIT>fn window(self, duration: std::time::Duration) -> WindowedStream<Self, I> where Self: Sized, { WindowedStream::new(self, duration) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Takes a path to a source file and cleans the path to it. This canonicalizes things like ".." to components which preserve the "top down" hierarchy of a static HTML tree. Each component in the cleaned path will be passed as an argument to `f`. The very last component of the path (ie the file name) is ignored. If a `..` is encountered, the `parent` closure will be called to allow the callee to handle it.<CODESPLIT>pub(crate) fn clean_path<F, P>(src_root: &Path, p: &Path, mut f: F, mut parent: P) where F: FnMut(&OsStr), P: FnMut(), { let p = p.strip_prefix(src_root).unwrap_or(p); let mut iter = p.components().peekable(); while let Some(c) = iter.next() { if iter.peek().is_none() { break; } match c { Component::ParentDir => parent(), Component::Normal(c) => f(c), _ => continue, } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Only Built-in Result and Some types should suggest the negated alternative<CODESPLIT>fn warn_for_built_in_methods_with_negation() { let res: Result<usize, usize> = Ok(1); if !res.is_ok() {} if !res.is_err() {} let res = Some(1); if !res.is_some() {} if !res.is_none() {} }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Closes the current token buffer, resets the position to the start of the buffer and returns the range of buffered tokens.<CODESPLIT>pub fn close_buffer(&mut self) -> Range<usize> { let token_buffer = self.token_buffer.unwrap(); let token_range = token_buffer..self.whitespace_token_buffer.unwrap_or(self.pos); self.token_buffer = None; self.pos = token_buffer; token_range }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>* 18.8.3 bgColor tint algorithm *<CODESPLIT>fn hex_with_tint_to_rgb(hex: &str, tint: f64) -> String { if tint == 0.0 { return hex.to_string(); } let mut hsl = rgb_to_hsl(hex_to_rgb(hex)); let l = hsl[2] as f64; if tint < 0.0 { hsl[2] = (l * (1.0 + tint)).round() as i32; } else { hsl[2] = (l + (100.0 - l) * tint).round() as i32; }; rgb_to_hex(hsl_to_rgb(hsl)) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>FIXME: This can be simplified to `Copy`. EMIT_MIR gvn_copy_aggregate.all_copy_use_changed.GVN.diff<CODESPLIT>fn all_copy_use_changed(v: &mut AllCopy) -> AllCopy { let mut a = v.a; v.a = 1; a = v.a; let b = v.b; let c = v.c; AllCopy { a, b, c } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `fulfillAdvancedOrder` (0xe7acab24) function<CODESPLIT>pub fn fulfill_advanced_order( &self, advanced_order: AdvancedOrder, criteria_resolvers: ::std::vec::Vec<CriteriaResolver>, fulfiller_conduit_key: [u8; 32], recipient: ::ethers::core::types::Address, ) -> ::ethers::contract::builders::ContractCall<M, bool> { self.0 .method_hash( [231, 172, 171, 36], ( advanced_order, criteria_resolvers, fulfiller_conduit_key, recipient, ), ) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>@ build-fail @ known-bug: #95134 @ compile-flags: -Copt-level=0 @ dont-check-failure-status @ dont-check-compiler-stderr<CODESPLIT>pub fn encode_num<Writer: ExampleWriter>(n: u32, mut writer: Writer) -> Result<(), Writer::Error> { if n > 15 { encode_num(n / 16, &mut writer)?; } Ok(()) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `matchAdvancedOrders` (0x55944a42) function<CODESPLIT>pub fn match_advanced_orders( &self, advanced_orders: ::std::vec::Vec<AdvancedOrder>, criteria_resolvers: ::std::vec::Vec<CriteriaResolver>, fulfillments: ::std::vec::Vec<Fulfillment>, ) -> ::ethers::contract::builders::ContractCall<M, ::std::vec::Vec<Execution>> { self.0 .method_hash( [85, 148, 74, 66], (advanced_orders, criteria_resolvers, fulfillments), ) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>@ revisions: leak noleak @[noleak] compile-flags:-Zno-leak-check<CODESPLIT>fn foo(x: for<'a, 'b> fn(&'a u8, &'b u8) -> &'a u8, y: for<'a> fn(&'a u8, &'a u8) -> &'a u8) { // The two types above are not equivalent. With the older LUB/GLB // algorithm, this may have worked (I don't remember), but now it let z = match 22 { 0 => x, _ => y, }; }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>@ check-fail @ compile-flags: -Z tiny-const-eval-limit<CODESPLIT>const fn labelled_loop(n: u32) -> u32 { let mut i = 0; 'mylabel: loop { //~^ ERROR is taking a long time if i > n { break 'mylabel; } i += 1; } 0 }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Verifies that a buffer of bytes contains a size prefixed `GuestLogData` and returns it. Note that verification is still experimental and may not catch every error, or be maximally performant. For the previous, unchecked, behavior use `size_prefixed_root_as_guest_log_data_unchecked`.<CODESPLIT>pub fn size_prefixed_root_as_guest_log_data( buf: &[u8], ) -> Result<GuestLogData, flatbuffers::InvalidFlatbuffer> { flatbuffers::size_prefixed_root::<GuestLogData>(buf) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>For PCI devices: place the device at the following PCI address<CODESPLIT>pub fn with_pci_addr(mut self, bus: u8, device: u8, function: u8) -> Self { self.pci_addr = Some((bus, device, function)); self }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Verifies that the current thread is associated with the registry and returns its unique index within the registry. This panics if the current thread is not associated with this registry. Note that there's a race possible where the identifier in `THREAD_DATA` could be reused so this can succeed from a different registry.<CODESPLIT>fn verify(self) -> usize { let (id, index) = THREAD_DATA.with(|data| (data.registry_id.get(), data.index.get())); if id == self { index } else { outline(|| panic!("Unable to verify registry association")) } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>@ run-pass @ edition: 2021<CODESPLIT>fn main() { assert_eq!( c"\xEF\x80\u{1F980}".to_bytes_with_nul(), &[0xEF, 0x80, 0xF0, 0x9F, 0xA6, 0x80, 0xF0, 0x9F, 0xA6, 0x80, 0x00], ); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>rustfmt-single_line_let_else_max_width: 100<CODESPLIT>fn main() { let Some(x) = opt else {}; let Some(x) = opt else { return }; let Some(x) = opt else { return }; let Some(x) = opt else { return; }; let Some(x) = opt else { return; }; let Some(x) = opt else { let y = 1; return y; }; let Some(x) = y.foo( "abc", fairly_long_identifier, "def", "123456", "string", "cheese", ) else { bar() }; let Some(x) = abcdef() .foo( "abc", some_really_really_really_long_ident, "ident", "123456", ) .bar() .baz() .qux("fffffffffffffffff") else { foo_bar() }; }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Suggest name of impl trait type # Current implementation In current implementation, the function tries to get the name from the first character of the name for the first type bound. If the name conflicts with existing generic parameters, it will try to resolve the conflict with `for_unique_generic_name`.<CODESPLIT>pub fn for_impl_trait_as_generic(&mut self, ty: &ast::ImplTraitType) -> SmolStr { let c = ty .type_bound_list() .and_then(|bounds| bounds.syntax().text().char_at(0.into())) .unwrap_or('T'); self.suggest_name(&c.to_string()) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Unsizing coercion from `&[&str; 1]` to `&[&str]`<CODESPLIT>fn unsize_slice_str_coercion() { fn sync_example() -> &'static [&'static str] { &["hi"] } async fn async_example() -> &'static [&'static str] { &["hi"] } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>These assertions all diverge, so their target blocks should become None. EMIT_MIR intrinsic_asserts.panics.InstSimplify-after-simplifycfg.diff<CODESPLIT>pub fn panics() { core::intrinsics::assert_inhabited::<Never>(); core::intrinsics::assert_zero_valid::<&u8>(); core::intrinsics::assert_mem_uninitialized_valid::<&u8>(); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns the statement at the given offset with its range in the document<CODESPLIT>pub fn statement_at_offset_with_range( &self, offset: &TextSize, ) -> Option<(TextRange, StatementRef)> { self.statement_ranges .iter() .position(|r| r.contains(offset)) .map(|idx| self.statement_ref_with_range(idx)) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Get the bytes corresponding to the supplied key if exists in trie. Implementation-wise, this is a simpler version of `insert` since no need to branch nodes. We can just use `seek` and use the last element in the trail.<CODESPLIT>pub fn get<Q>(&self, key: &Q) -> Option<&V> where K: Borrow<Q>, Q: AsRef<[u8]> + ?Sized, { let mut last_state = self.root?; let seek_succeeded = self.seek(key.as_ref(), |state, _, _| { last_state = state; }); if seek_succeeded { self.get_validated_node(last_state).get_value() } else { None } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns true if given type is `Any` trait.<CODESPLIT>fn is_any_trait(cx: &LateContext<'_>, t: &hir::Ty<'_>) -> bool { if let TyKind::TraitObject(traits, ..) = t.kind { return traits.iter().any(|bound| { if let Some(trait_did) = bound.trait_ref.trait_def_id() && cx.tcx.is_diagnostic_item(sym::Any, trait_did) { return true; } false }); } false }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Proof counts can be dependent on how bits are distributed in a column of data. This method provides access to the bit distributions of a proof during the counting pass of verification.<CODESPLIT>pub fn consume_bit_distribution(&mut self) -> Result<BitDistribution, ProofError> { if self.bit_distributions.is_empty() { Err(ProofError::VerificationError { error: "expected prover to provide bit distribution", }) } else { let res = self.bit_distributions[0].clone(); self.bit_distributions = &self.bit_distributions[1..]; Ok(res) } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Given a linked list starting at `source_list` and another linked list starting at `target_list`, modify `target_list` so that it is followed by `source_list`. Before: ```text target_list: A -> B -> C -> (None) source_list: D -> E -> F -> (None) ``` After: ```text target_list: A -> B -> C -> D -> E -> F -> (None) ```<CODESPLIT>fn append_list( constraints: &mut IndexSlice<NllMemberConstraintIndex, NllMemberConstraint<'_>>, target_list: NllMemberConstraintIndex, source_list: NllMemberConstraintIndex, ) { let mut p = target_list; loop { let r = &mut constraints[p]; match r.next_constraint { Some(q) => p = q, None => { r.next_constraint = Some(source_list); return; } } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Append data of the provided table to the exiting [`TableCommitment`]. Will error on a variety of mismatches. See [`ColumnCommitmentsMismatch`] for an enumeration of these errors. # Panics Panics if `owned_table` has duplicate identifiers. Panics if `owned_table` contains columns of mixed length.<CODESPLIT>pub fn append_owned_table<S>( &mut self, owned_table: &OwnedTable<S>, setup: &C::PublicSetup<'_>, ) -> Result<(), ColumnCommitmentsMismatch> where S: Scalar, { self.try_append_rows(owned_table.inner_table(), setup) .map_err(|e| match e { AppendTableCommitmentError::AppendColumnCommitments { source: e } => match e { AppendColumnCommitmentsError::Mismatch { source: e } => e, AppendColumnCommitmentsError::DuplicateIdentifiers { .. } => { panic!("OwnedTables cannot have duplicate identifiers"); } }, AppendTableCommitmentError::MixedLengthColumns { .. } => { panic!("OwnedTables cannot have columns of mixed length"); } }) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Computes the size for a signed variable-sized integer.<CODESPLIT>pub fn svarint(mut self, n: i64) { if n != 0 || self.state.in_sequence { self.add(varint_size(zigzag(n))); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>normalize `Wrapper<T>::Metadata` -> `T::Metadata`<CODESPLIT>fn wrapper_to_tail<T: ?Sized>(ptr: *const T) -> *const Wrapper<T> { cast_same_meta(ptr) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>~^ WARN ambiguous wide pointer comparison<CODESPLIT>fn cmp<T: ?Sized>(a: *mut T, b: *mut T) -> bool { let _ = a == b; let _ = a != b; let _ = a < b; let _ = a <= b; let _ = a > b; let _ = a >= b; let _ = PartialEq::eq(&a, &b); let _ = PartialEq::ne(&a, &b); let _ = a.eq(&b); let _ = a.ne(&b); let a = &a; let b = &b; &*a == &*b }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `name` (0x06fdde03) function<CODESPLIT>pub fn name( &self, ) -> ::ethers::contract::builders::ContractCall<M, ::std::string::String> { self.0 .method_hash([6, 253, 222, 3], ()) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Initializes the logger with the given default log level. Provide your crate names to enable logging for them.<CODESPLIT>pub fn init(default_level: Option<Level>, mut crates: Vec<String>) -> Result<()> { crates.push(env!("CARGO_PKG_NAME").to_string()); let mut env_filter = EnvFilter::builder() .from_env_lossy() .add_directive("none".parse()?); for crate_name in crates { env_filter = env_filter.add_directive( format!("{}={}", crate_name, default_level.unwrap_or(Level::INFO)).parse()?, ); } tracing_subscriber::fmt().with_env_filter(env_filter).init(); Ok(()) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>#[cfg(proc_macro)]<CODESPLIT>pub fn derive(input: TokenStream) -> TokenStream { "impl B { fn foo(&self) {} } fn foo() {} mod bar { pub fn foo() {} } ".parse().unwrap() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Removes a given suffix from the string. If the suffix was not found it returns false, otherwise the suffix is removed and the function returns true.<CODESPLIT>pub fn strip_suffix(&mut self, bytes: &[u8]) -> bool { if self.len() < bytes.len() { return false; } let pos = self.len() - bytes.len(); match self.rfind(bytes) { Some(v) => { if v != pos { return false; } self.remove_range(pos, bytes.len()); true } None => false, } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>rustfmt-control_brace_style: ClosingNextLine Control brace style<CODESPLIT>fn main() { if lorem { println!("ipsum!"); } else { println!("dolor!"); } match magi { Homura => "Akemi", Madoka => "Kaname", } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>FIXME(#17451) Use `expected: f128` once `f128` is stabilised.<CODESPLIT>fn check_float_value(lit: &str, expected: &str) { let expected = Some(expected.parse::<f128>().unwrap()); assert_eq!( FloatNumber { syntax: make::tokens::literal(lit) }.value_string().parse::<f128>().ok(), expected ); assert_eq!( IntNumber { syntax: make::tokens::literal(lit) }.value_string().parse::<f128>().ok(), expected ); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Sizes the message as `n` bytes.<CODESPLIT>pub fn bytes(&mut self, n: usize) { self.state.message_sizes[self.state.index] = MessageSize { len: n, ..Default::default() }; }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>dup SetStdHandle not supported by Miri<CODESPLIT>fn switch_stdout() { let temp = common::tmpdir(); let path = temp.join("switch-stdout-output"); let f = File::create(&path).unwrap(); let mut stdout = std::io::stdout(); stdout.write(b"foo\n").unwrap(); stdout.flush().unwrap(); let orig_hdl = switch_stdout_to(f.into()); stdout.write(b"bar\n").unwrap(); stdout.flush().unwrap(); switch_stdout_to(orig_hdl); let mut contents = String::new(); File::open(&path).unwrap().read_to_string(&mut contents).unwrap(); assert_eq!(contents, "bar\n"); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Reads a signed (zigzag-encoded) varint. Returns `Ok(None)` if there are no more values.<CODESPLIT>pub fn svarint(&mut self) -> Result<Option<i64>> { if self.data.is_empty() { Ok(None) } else { read_varint(&mut self.data).map(|n| Some(unzigzag(n))) } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Active(Only) is valid in reverse-mode AD for scalar float returns (f16 f32 ...). Dual(Only) is valid in forward-mode AD for scalar float returns (f16 f32 ...). Const is valid for all cases and means that we don't compute derivatives wrt. this output. That usually means we have a &mut or *mut T output and compute derivatives wrt. that arg, but this is too complex to verify here. Also it's just a logic error if users get this wrong.<CODESPLIT>pub fn valid_ret_activity(mode: DiffMode, activity: DiffActivity) -> bool { if activity == DiffActivity::None { return true; } match mode { DiffMode::Error => false, DiffMode::Source => false, DiffMode::Forward | DiffMode::ForwardFirst => { activity == DiffActivity::Dual || activity == DiffActivity::DualOnly || activity == DiffActivity::Const } DiffMode::Reverse | DiffMode::ReverseFirst => { activity == DiffActivity::Const || activity == DiffActivity::Active || activity == DiffActivity::ActiveOnly } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>@ run-pass Issue #2005: Check that boxed fixed-size arrays are properly accounted for (namely, only deallocated if they were actually created) when they appear as temporaries in unused arms of a match expression.<CODESPLIT>pub fn foo(box_1: fn () -> Box<[i8; 1]>, box_2: fn () -> Box<[i8; 20]>, box_3: fn () -> Box<[i8; 300]>, box_4: fn () -> Box<[i8; 4000]>, ) { println!("Hello World 1"); let _: Box<[i8]> = match 3 { 1 => box_1(), 2 => box_2(), 3 => box_3(), _ => box_4(), }; println!("Hello World 2"); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `changeDelta` (0x6809f664) function<CODESPLIT>pub fn change_delta( &self, new_delta: u128, ) -> ::ethers::contract::builders::ContractCall<M, ()> { self.0 .method_hash([104, 9, 246, 100], new_delta) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Evaluation order for `a op= b` where typeof(a) and typeof(b) are primitives is first `b` then `a`.<CODESPLIT>fn primitive_compound() { let mut side_order = vec![]; let mut int = Wrapper(0); { side_order.push(Side::Lhs); int }.0 += { side_order.push(Side::Rhs); 0 }; assert!(matches!(side_order[..], [Side::Rhs, Side::Lhs])); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Sets the last OS error and writes -1 to dest place.<CODESPLIT>fn set_last_error_and_return( &mut self, err: impl Into<IoError>, dest: &MPlaceTy<'tcx>, ) -> InterpResult<'tcx> { let this = self.eval_context_mut(); this.set_last_error(err)?; this.write_int(-1, dest)?; interp_ok(()) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Creates a dynamic array for a length.<CODESPLIT>pub fn dyn_array<V: MemVariable<C>>(&mut self, len: impl Into<Usize<C::N>>) -> Array<C, V> { let len = match len.into() { Usize::Const(len) => self.eval(C::N::from_canonical_usize(len)), Usize::Var(len) => len, }; let len = Usize::Var(len); let ptr = self.alloc(len, V::size_of()); Array::Dyn(ptr, len) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>~^ ERROR: manual `Debug` impl does not include all fields<CODESPLIT>fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result { let mut f = formatter.debug_struct("MultiExprDebugImpl"); f.field("a", &self.a); f.finish() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `factory` (0xc45a0155) function<CODESPLIT>pub fn factory( &self, ) -> ::ethers::contract::builders::ContractCall< M, ::ethers::core::types::Address, > { self.0 .method_hash([196, 90, 1, 85], ()) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `onERC1155Received` (0xf23a6e61) function<CODESPLIT>pub fn on_erc1155_received( &self, operator: ::ethers::core::types::Address, from: ::ethers::core::types::Address, id: ::ethers::core::types::U256, value: ::ethers::core::types::U256, data: ::ethers::core::types::Bytes, ) -> ::ethers::contract::builders::ContractCall<M, [u8; 4]> { self.0 .method_hash([242, 58, 110, 97], (operator, from, id, value, data)) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>LUB-coercion should also have the exact same effect when `&'b [&'a T; N]` needs to be coerced, i.e., the resulting type is not &'b [&'static T], but rather the `&'b [&'a T]` LUB.<CODESPLIT>fn long_and_short_lub2<'a, 'b, T>(xs: &'b [&'static T], ys: &'b [&'a T; 1]) { let _order1 = [xs, ys]; let _order2 = [ys, xs]; }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>create a tool prompt from a chat completion request message.<CODESPLIT>fn append_tool_message( &self, chat_history: impl AsRef<str>, message: &ChatCompletionToolMessage, ) -> Result<String> { let content = message.content(); Ok(format!( "{chat_history}\n<|im_start|>tool\n{tool_message}<|im_end|>", chat_history = chat_history.as_ref().trim(), tool_message = content.trim(), )) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>This parses Sheet1!AS23 into sheet, column and row FIXME: This is buggy. Does not check that is a valid sheet name There is a similar named function in ironcalc_base. We probably should fix both at the same time. NB: Maybe use regexes for this?<CODESPLIT>fn parse_reference(s: &str) -> Result<CellReferenceRC, ParseReferenceError> { let bytes = s.as_bytes(); let mut sheet_name = "".to_string(); let mut column = "".to_string(); let mut row = "".to_string(); let mut state = "sheet"; for &byte in bytes { match state { "sheet" => { if byte == b'!' { state = "col" } else { sheet_name.push(byte as char); } } "col" => { if byte.is_ascii_alphabetic() { column.push(byte as char); } else { state = "row"; row.push(byte as char); } } _ => { row.push(byte as char); } } } Ok(CellReferenceRC { sheet: sheet_name, row: row.parse::<i32>().map_err(ParseReferenceError::RowError)?, column: column_to_number(&column).map_err(ParseReferenceError::ColumnError)?, }) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>A hint to the backend specifies whether the driver should spawned tasks that always on a thread handling the target VP. If `false` (the default), then when spawned tasks are awoken, they may run on any executor (such as the current one). If `true`, the backend will run them on the same thread that would drive async IO. Some devices will want to override the default to reduce jitter or ensure that IO is issued from the correct processor.<CODESPLIT>pub fn run_on_target(&mut self, run_on_target: bool) -> &mut Self { self.run_on_target = run_on_target; self }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>`'b` is not in scope for the outlives bound.<CODESPLIT>fn two_htrb_outlives_uses() -> impl for<'a> Bar<'a, Assoc = impl for<'b> Sized + 'b> {}
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Replace the parts of the nushell completion script that need different functionality.<CODESPLIT>fn replace_nushell_completion(script: &str) -> Cow<str> { let pattern = r#"(#.*\n export extern "pixi run".*\n.*...task: string)([^\]]*--environment\(-e\): string)"#; let replacement = r#" def "nu-complete pixi run" [] { ^pixi info --json | from json | get environments_info | get tasks | flatten | uniq } def "nu-complete pixi run environment" [] { ^pixi info --json | from json | get environments_info | get name } ${1}@"nu-complete pixi run"${2}@"nu-complete pixi run environment""#; let re = Regex::new(pattern).unwrap(); re.replace(script, replacement) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Construct a new `llvm-objcopy` invocation. This assumes that `llvm-objcopy` is available at `$LLVM_BIN_DIR llvm-objcopy`.<CODESPLIT>pub fn new() -> Self { let llvm_objcopy = llvm_bin_dir().join("llvm-objcopy"); let cmd = Command::new(llvm_objcopy); Self { cmd } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Foreign Read on a Protected Reserved turns it Frozen.<CODESPLIT>unsafe fn int_protected_read() { print("[protected] Foreign Read: Res -> Frz"); let base = &mut 0u8; let alloc_id = alloc_id!(base); name!(base); let x = &mut *(base as *mut u8); name!(x); let y = (&mut *base) as *mut u8; name!(y); read_second(x, y); print_state!(alloc_id); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Should NOT lint if bound to return type<CODESPLIT>fn ret_stmt(b: bool) -> (i32, i32) { if b { return (0, 1); } (0, 0) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>@ run-fail @ error-pattern:Number is odd @ ignore-emscripten no processes<CODESPLIT>fn even(x: usize) -> bool { if x < 2 { return false; } else if x == 2 { return true; } else { return even(x - 2); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Given a prompt, the model will return one or more predicted completions along with the probabilities of alternative tokens at each position.<CODESPLIT>pub async fn completions(request: &CompletionRequest) -> Result<CompletionObject, LlamaCoreError> { #[cfg(feature = "logging")] info!(target: "stdout", "Generate completions"); let running_mode = running_mode()?; if running_mode == RunningMode::Embeddings || running_mode == RunningMode::Rag { let err_msg = format!( "The completion is not supported in the {} mode.", running_mode ); #[cfg(feature = "logging")] error!(target: "stdout", "{}", &err_msg); return Err(LlamaCoreError::Operation(err_msg)); } let prompt = match &request.prompt { CompletionPrompt::SingleText(prompt) => prompt.to_owned(), CompletionPrompt::MultiText(prompts) => prompts.join(" "), }; compute(prompt.trim(), request.model.as_ref()) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>create a tool prompt from a chat completion request message.<CODESPLIT>fn append_tool_message( &self, chat_history: impl AsRef<str>, message: &ChatCompletionToolMessage, ) -> String { format!( "{chat_history}<|start_header_id|>tool<|end_header_id|>\n\n{tool_message}<|eot_id|>", chat_history = chat_history.as_ref().trim(), tool_message = message.content().trim(), ) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Starts the authentication process with Auth0.<CODESPLIT>pub async fn start_auth() -> Result<AuthSession> { let client = reqwest::Client::new(); let params = AuthCodeRequest { client_id: AUTH0_CLI_CLIENT_ID.as_str().to_string(), scope: "offline_access".to_string(), audience: AUTH0_API_AUDIENCE.as_str().to_string(), }; let res = client .post(format!( "https://{}/oauth/device/code", AUTH0_TENANT_DOMAIN.as_str(), )) .header("Content-Type", "application/x-www-form-urlencoded") .form(&params) .send() .await?; let body = res.json::<AuthCodeResponse>().await?; Ok(AuthSession::new(body)) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>convenience to access internal mutable object<CODESPLIT>fn borrow_counter(&self) -> &mut usize { #[deny(clippy::mut_from_ref)] unsafe { &mut *self.borrow_counter.get() } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns true if we should ignore `link` due to it being unlikely that it is an intra-doc link. `link` should still have disambiguators if there were any. The difference between this and [`should_ignore_link()`] is that this check should only be used on links that still have disambiguators.<CODESPLIT>fn should_ignore_link_with_disambiguators(link: &str) -> bool { link.contains(|ch: char| !(ch.is_alphanumeric() || ":_<>, !*&;@()".contains(ch))) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `getAssetRecipient` (0x79eac6c2) function<CODESPLIT>pub fn get_asset_recipient( &self, ) -> ::ethers::contract::builders::ContractCall< M, ::ethers::core::types::Address, > { self.0 .method_hash([121, 234, 198, 194], ()) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns if the [`UniqueIndexSet`] is locked or not. If the set is locked no more indices can be borrowed.<CODESPLIT>pub fn is_locked(&self) -> bool { let s = HeadDetails::from(self.head.load(Ordering::Relaxed)).borrowed_indices; s == LOCK_ACQUIRE }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns true if the corresponding type is inhabited in the given `ParamEnv` and module, revealing opaques when possible.<CODESPLIT>pub fn apply_revealing_opaque( self, tcx: TyCtxt<'tcx>, typing_env: TypingEnv<'tcx>, module_def_id: DefId, reveal_opaque: &impl Fn(OpaqueTypeKey<'tcx>) -> Option<Ty<'tcx>>, ) -> bool { let Ok(result) = self.apply_inner::<!>( tcx, typing_env, &mut Default::default(), &|id| Ok(tcx.is_descendant_of(module_def_id, id)), reveal_opaque, ); result }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Requires imports to match exactly instead of fuzzily.<CODESPLIT>pub fn path_fuzzy_name_to_exact(&mut self) { if let ImportCandidate::Path(PathImportCandidate { name: to_import, .. }) = &mut self.import_candidate { let (name, case_sensitive) = match to_import { NameToImport::Fuzzy(name, case_sensitive) => { (std::mem::take(name), *case_sensitive) } _ => return, }; *to_import = NameToImport::Exact(name, case_sensitive); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Parses the hypercall parameters to input and output types.<CODESPLIT>pub fn parse(params: HypercallParameters<'_>) -> (&Hdr, &[u64], &[In], &mut [Out], &mut usize) { let (header, rest) = Ref::<_, Hdr>::new_from_prefix(params.input).unwrap(); let (var_header, rest) = u64::slice_from_prefix(rest, params.control.variable_header_size()).unwrap(); let input = if size_of::<In>() == 0 { &[] } else { &In::slice_from(rest).unwrap()[params.control.rep_start()..] }; let output = if size_of::<Out>() == 0 { &mut [] } else { &mut Out::mut_slice_from(params.output).unwrap()[params.control.rep_start()..] }; ( header.into_ref(), var_header, input, output, params.elements_processed.unwrap(), ) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Write out a static file with the ID tracker's (empty) deleted bitset.<CODESPLIT>pub fn write(&mut self, mut out: impl Write) -> anyhow::Result<()> { self.check_invariants()?; let count = self.len(); let num_deleted = self.num_deleted as u32; let expected_blocks = count.next_multiple_of(64) / 64; anyhow::ensure!(self.deleted.as_raw_slice().len() == expected_blocks); anyhow::ensure!(mem::size_of::<usize>() * 8 == 64); out.write_u8(DELETED_BITSET_VERSION)?; out.write_u32::<LittleEndian>(count.try_into()?)?; out.write_u32::<LittleEndian>(num_deleted)?; for block in self.deleted.as_raw_slice() { out.write_u64::<LittleEndian>(*block as u64)?; } out.flush()?; Ok(()) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Schedule a re-start of the cargo check worker to do a package wide check.<CODESPLIT>pub(crate) fn restart_for_package(&self, package: String, target: Option<Target>) { self.sender .send(StateChange::Restart { package: Some(package), saved_file: None, target }) .unwrap(); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Custom serializer for a map of exposed names to executable names.<CODESPLIT>fn serialize_expose_mappings<S>( mappings: &IndexSet<Mapping>, serializer: S, ) -> Result<S::Ok, S::Error> where S: Serializer, { let mut map = serializer.serialize_map(Some(mappings.len()))?; for mapping in mappings { map.serialize_entry(&mapping.exposed_name(), &mapping.executable_name())?; } map.end() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns the length of the [`SafelyOverflowingIndexQueue`]. Note: This method may make only sense in a non-concurrent setup since the information could be out-of-date as soon as it is acquired.<CODESPLIT>pub fn len(&self) -> usize { let (write_position, read_position) = self.acquire_read_and_write_position(); write_position - read_position }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Iterates over associated types that may be specified after the given path (using `Ty::Assoc` syntax).<CODESPLIT>pub fn assoc_type_shorthand_candidates<R>( &self, resolution: &PathResolution, mut cb: impl FnMut(&Name, TypeAlias) -> Option<R>, ) -> Option<R> { let def = self.resolver.generic_def()?; hir_ty::associated_type_shorthand_candidates( self.db, def, resolution.in_type_ns()?, |name, id| cb(name, id.into()), ) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `delta` (0x12b495a8) function<CODESPLIT>pub fn delta(&self) -> ::ethers::contract::builders::ContractCall<M, u128> { self.0 .method_hash([18, 180, 149, 168], ()) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>@ check-pass @ compile-flags: -Znext-solver Issue 94358<CODESPLIT>fn foo<C>(_: C) where for <'a> &'a C: IntoIterator, for <'a> <&'a C as IntoIterator>::IntoIter: ExactSizeIterator, {}
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `matchOrders` (0xa8174404) function<CODESPLIT>pub fn match_orders( &self, orders: ::std::vec::Vec<Order>, fulfillments: ::std::vec::Vec<Fulfillment>, ) -> ::ethers::contract::builders::ContractCall<M, ::std::vec::Vec<Execution>> { self.0 .method_hash([168, 23, 68, 4], (orders, fulfillments)) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>issue #105028, suggest removing the field only for shorthand<CODESPLIT>fn use_match(x: Foo) { match x { Foo { foo: unused, .. } => { } } match x { Foo { foo, .. } => { } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Runs the classifier on the given input.<CODESPLIT>pub fn run(&self, input: Embedding<S>) -> candle_core::Result<ClassifierOutput<T>> { self.model.run(&input.to_vec()) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns a mutable iterator for the entries.<CODESPLIT>pub fn iter_mut(&mut self) -> impl Iterator<Item = (usize, &'_ mut T)> { self.0 .iter_mut() .enumerate() .filter_map(|(i, v)| v.as_mut().map(|v| (i, v))) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>@ run-fail @ error-pattern:index out of bounds: the len is 5 but the index is 5 @ ignore-emscripten no processes<CODESPLIT>fn main() { let s: String = "hello".to_string(); assert_eq!(s.as_bytes()[5], 0x0 as u8); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>This is your barebones dot product implementation: Take 2 vectors, multiply them element wise and *then* go along the resulting array and add up the result. In the next example we will see if there is any difference to adding and multiplying in tandem.<CODESPLIT>pub fn dot_prod_scalar_0(a: &[f32], b: &[f32]) -> f32 { assert_eq!(a.len(), b.len()); a.iter().zip(b.iter()).map(|(a, b)| a * b).sum() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Aliased as STSMAXx and STSMAXLx<CODESPLIT>const fn ldsmax(size: u8, acquire: bool, release: bool, rs: u8, rn: u8, rt: u8) -> u32 { assert!(rs < 32); assert!(rn < 32); assert!(rt < 32); let acquire = if acquire { 0x00800000 } else { 0 }; let release = if release { 0x00400000 } else { 0 }; 0x38204000 | (size as u32) << 30 | acquire | release | (rs as u32) << 16 | (rn as u32) << 5 | (rt as u32) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Sets the last OS error and return `-1` as a `i64`-typed Scalar<CODESPLIT>fn set_last_error_and_return_i64( &mut self, err: impl Into<IoError>, ) -> InterpResult<'tcx, Scalar> { let this = self.eval_context_mut(); this.set_last_error(err)?; interp_ok(Scalar::from_i64(-1)) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>This always returns `Ok(...)`.<CODESPLIT>fn success( adj: Vec<Adjustment>, target: Ty, goals: Vec<InEnvironment<Goal<Interner>>>, ) -> CoerceResult { Ok(InferOk { goals, value: (adj, target) }) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Adds new sheet See also: * [Model::new_sheet]<CODESPLIT>pub fn new_sheet(&mut self) -> Result<(), String> { let (name, index) = self.model.new_sheet(); self.set_selected_sheet(index)?; self.push_diff_list(vec![Diff::NewSheet { index, name }]); Ok(()) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Creates a new, empty, unmapped region. Returns a handle that will remove the region on drop.<CODESPLIT>pub async fn new_region( &self, name: String, range: MemoryRange, priority: u8, ) -> Result<RegionHandle, AddRegionError> { let params = RegionParams { name, range, priority, }; let id = self .req_send .call(RegionRequest::AddRegion, params) .await .unwrap()?; Ok(RegionHandle { id: Some(id), req_send: self.req_send.clone(), }) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Apply a binary operator to two slices of the same length with left upcasting returning results.<CODESPLIT>pub(crate) fn try_slice_binary_op_left_upcast<S, T, U, F>( lhs: &[S], rhs: &[T], op: F, ) -> ColumnOperationResult<Vec<U>> where S: Copy + Into<T>, F: Fn(&T, &T) -> ColumnOperationResult<U>, { try_slice_binary_op(lhs, rhs, |l, r| -> ColumnOperationResult<U> { op(&Into::<T>::into(*l), r) }) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Set the reason for the vtl return into the vp assist page<CODESPLIT>pub fn set_return_reason(&self, reason: HvVtlEntryReason) -> Result<(), GuestMemoryError> { let gpa = (self.vp_assist_page.gpa_page_number() * HV_PAGE_SIZE) + offset_of!(hvdef::HvVpAssistPage, vtl_control) as u64 + offset_of!(HvVpVtlControl, entry_reason) as u64; self.guest_memory.write_plain(gpa, &(reason.0)) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Creates a suspended, (nearly) empty process, hosted in a new job object. It will terminate when the job object is closed.<CODESPLIT>pub fn empty_process() -> io::Result<EmptyProcess> { let job = Job::new()?; job.set_terminate_on_close()?; let mut builder = Builder::new("empty"); builder .application_name(std::env::current_exe()?) .env_clear() .stdin(Stdio::Null) .stdout(Stdio::Null) .stderr(Stdio::Null) .job(job.as_handle()) .suspended(true); let process = builder.spawn()?; Ok(EmptyProcess { process, job }) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `assetRecipient` (0x3bfa67fe) function<CODESPLIT>pub fn asset_recipient( &self, ) -> ::ethers::contract::builders::ContractCall< M, ::ethers::core::types::Address, > { self.0 .method_hash([59, 250, 103, 254], ()) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Runs the activation scripts of the prefix and returns the environment variables that were modified as part of this process.<CODESPLIT>pub async fn run_activation(&self) -> miette::Result<HashMap<String, String>> { let activator = Activator::from_path(self.root(), ShellEnum::default(), Platform::current()) .into_diagnostic() .context("failed to constructor environment activator")?; activator .run_activation(ActivationVariables::from_env().unwrap_or_default(), None) .into_diagnostic() .context("failed to run activation") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `information` (0xf47b7740) function<CODESPLIT>pub fn information( &self, ) -> ::ethers::contract::builders::ContractCall< M, (::std::string::String, [u8; 32], ::ethers::core::types::Address), > { self.0 .method_hash([244, 123, 119, 64], ()) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Updates media metadata properties in a `MediaSession`.<CODESPLIT>fn update_media_properties( session_output: &mut MediaSession, session: &GsmtcSession, ) -> anyhow::Result<()> { let properties = session.TryGetMediaPropertiesAsync()?.get()?; let title = properties.Title()?.to_string(); let artist = properties.Artist()?.to_string(); let album_title = properties.AlbumTitle()?.to_string(); let album_artist = properties.AlbumArtist()?.to_string(); session_output.title = (!title.is_empty()).then_some(title); session_output.artist = (!artist.is_empty()).then_some(artist); session_output.album_title = (!album_title.is_empty()).then_some(album_title); session_output.album_artist = (!album_artist.is_empty()).then_some(album_artist); session_output.track_number = properties.TrackNumber()? as u32; Ok(()) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns the column as a slice of booleans if it is a boolean column. Otherwise, returns None.<CODESPLIT>pub(crate) fn as_boolean(&self) -> Option<&'a [bool]> { match self { Self::Boolean(col) => Some(col), _ => None, } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>This may evict 'waiting' entries under high load. That will cause a channel error for callers who could choose to retry. If this becomes an issue, we can iterate over the entries, collect a set of keys to evict and manually pop each key from the LRU.<CODESPLIT>fn trim_to_size(inner: &mut Inner<RT, Key, Value>) { while inner.current_size > inner.max_size { let (_, evicted) = inner .cache .pop_lru() .expect("Over max size, but no more entries"); if let CacheResult::Ready { ref value, size, ref added, } = evicted { if size != value.size() { tracing::warn!( "Value changed size from {} to {} while in the {} cache!", size, value.size(), inner.label ) } async_lru_log_eviction(inner.label, added.elapsed()); } inner.current_size -= evicted.size(); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Saves the classifier to the given path.<CODESPLIT>pub fn save<P: AsRef<std::path::Path>>(&self, path: P) -> candle_core::Result<()> { self.model.save(path) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Aligns and appends the raw byte data of a potentially dynamically sized structure and its appropriate header to the configuration blob.<CODESPLIT>pub fn add_raw(&mut self, structure_type: BlobStructureType, data: &[u8]) -> &mut Self { self.add_raw_inner(structure_type, data, false) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Tiny Vecs are dumb. Skip to: - 8 if the element size is 1, because any heap allocators is likely to round up a request of less than 8 bytes to at least 8 bytes. - 4 if elements are moderate-sized (<= 1 KiB). - 1 otherwise, to avoid wasting too much space for very short Vecs.<CODESPLIT>const fn min_non_zero_cap(size: usize) -> usize { if size == 1 { 8 } else if size <= 1024 { 4 } else { 1 } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>normalize `WrapperProject<T>::Metadata` -> `T::Assoc::Metadata` -> `()`<CODESPLIT>fn wrapper_project_unit<T: ?Sized + Project>(ptr: *const ()) -> *const WrapperProject<T> where T::Assoc: Sized, { cast_same_meta(ptr) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Creates a new time keeper with the specified current guest time.<CODESPLIT>pub fn new(driver: &impl SpawnDriver, uptime: VmTime) -> Self { let (new_send, new_recv) = mesh::mpsc_channel(); let (req_send, req_recv) = mesh::channel(); let time = TimeState::Stopped(uptime); let task = driver.spawn("vm-time-keeper", async move { let mut primary = PrimaryKeeper { req_recv, new_recv, keepers: Vec::new(), next_id: 0, time, }; primary.run().await; }); Self { time, req_send, builder: VmTimeSourceBuilder { new_send }, _task: task, } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Warning; two input lifetimes, but the output lifetime is not elided, i.e., the following is valid: fn alias_with_lt4a<'a>(_foo: &'a FooAlias<'_>) -> &'a str ^^<CODESPLIT>fn alias_with_lt4a<'a, 'b>(_foo: &'a FooAlias<'b>) -> &'a str { unimplemented!() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Mutable reference allows only mutation of !Drop place.<CODESPLIT>pub const fn f() { let mut x: (Option<String>, u32) = (None, 0); let mut a = 10; *(&mut a) = 11; x.1 = a; }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Create a session with the task's system prompt.<CODESPLIT>fn create_session(&mut self, model: &mut impl SyncModel<Session = S>) -> Result<S> { let read = &self.session; match read { Some(cache) => match cache.try_clone() { Ok(cache) => Ok(cache), Err(err) => { tracing::error!("Failed to clone session: {}", err); Ok(self.create_new_session(model)?) } }, None => Ok(self.create_new_session(model)?), } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>The purpose of this text is to ensure that we get good diagnostics when a `bool` is expected but that due to an assignment expression `x = y` the type is `()`.<CODESPLIT>fn main() { let _: bool = 0 = 0; let _: bool = match 0 { 0 => 0 = 0, _ => 0 = 0, }; let _: bool = match true { true => 0 = 0, _ => (), }; if 0 = 0 {} let _: bool = if { 0 = 0 } { 0 = 0 } else { 0 = 0 }; let _ = (0 = 0) && { 0 = 0 } || (0 = 0); let _: usize = 0 = 0; let foo = &String::new(); let bar = ""; if foo = bar {} }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Add a header to the headers storage. The name will be converted to lowercase. # Example ``` # use rwf::http::Headers; let mut headers = Headers::new(); headers.insert("x-my-header", "134"); ``` #### Implementation note This implementation doesn't support adding multiple headers with the same name. This is only needed for the `Set-Cookie` header which is handled separately.<CODESPLIT>pub fn insert(&mut self, name: impl ToString, value: impl ToString) { self.headers .insert(name.to_string().to_lowercase(), value.to_string()); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>FIXME(81658): should be used + lint reinstated after #83171 relands.<CODESPLIT>fn handle_assign(&mut self, expr: &'tcx hir::Expr<'tcx>) { if self .typeck_results() .expr_adjustments(expr) .iter() .any(|adj| matches!(adj.kind, ty::adjustment::Adjust::Deref(_))) { self.visit_expr(expr); } else if let hir::ExprKind::Field(base, ..) = expr.kind { self.handle_assign(base); } else { self.visit_expr(expr); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns the length of the [`IndexQueue`]. Note: This method may make only sense in a non-concurrent setup since the information could be out-of-date as soon as it is acquired.<CODESPLIT>pub fn len(&self) -> usize { let (write_position, read_position) = self.acquire_read_and_write_position(); write_position - read_position }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>If this `DefMap` is for a block expression, returns the module containing the block (which might again be a block, or a module inside a block).<CODESPLIT>pub fn parent(&self) -> Option<ModuleId> { let BlockRelativeModuleId { block, local_id } = self.block?.parent; Some(ModuleId { krate: self.krate, block, local_id }) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Creates a node within a new mesh.<CODESPLIT>pub fn new(driver: impl Driver + Spawn + Clone) -> io::Result<Self> { let directory = create_object_directory(&ObjectAttributes::new(), DIRECTORY_ALL_ACCESS)?; Self::with_id(driver, NodeId::new(), directory) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>If possible, extract some result from the preceding KV and move to the edge beyond it.<CODESPLIT>fn perform_next_back_checked<F, R>(&mut self, f: F) -> Option<R> where F: Fn(&Handle<NodeRef<BorrowType, K, V, marker::LeafOrInternal>, marker::KV>) -> R, { if self.is_empty() { None } else { super::mem::replace(self.back.as_mut().unwrap(), |back| { let kv = back.next_back_kv().ok().unwrap(); let result = f(&kv); (kv.next_back_leaf_edge(), Some(result)) }) } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Assignment to a deref field projection: the `*list.0` assignment should clear the existing borrows of `list.0.value` and `list.0.next`<CODESPLIT>fn assignment_to_deref_field_projection<T>(mut list: (Box<&mut List<T>>,)) -> Vec<&mut T> { let mut result = vec![]; loop { result.push(&mut list.0.value); if let Some(n) = list.0.next.as_mut() { *list.0 = n; } else { return result; } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>A non-child node was read-accessed: keep `Reserved` but mark it as `conflicted` if it is protected; invalidate `Active`.<CODESPLIT>fn foreign_read(state: PermissionPriv, protected: bool) -> Option<PermissionPriv> { Some(match state { non_writeable @ (Frozen | Disabled) => non_writeable, ReservedFrz { .. } if protected => ReservedFrz { conflicted: true }, res @ (ReservedFrz { .. } | ReservedIM) => { assert!(!protected); res } Active => if protected { Disabled } else { Frozen }, }) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `isValidOrderIncludingExtraData` (0x33131570) function<CODESPLIT>pub fn is_valid_order_including_extra_data( &self, order_hash: [u8; 32], caller: ::ethers::core::types::Address, order: AdvancedOrder, prior_order_hashes: ::std::vec::Vec<[u8; 32]>, criteria_resolvers: ::std::vec::Vec<CriteriaResolver>, ) -> ::ethers::contract::builders::ContractCall<M, [u8; 4]> { self.0 .method_hash( [51, 19, 21, 112], (order_hash, caller, order, prior_order_hashes, criteria_resolvers), ) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Return a "error message-able" ident for the last segment of the `Path`<CODESPLIT>fn path_name_to_string(path: &Path<'_>) -> String { path.segments.last().unwrap().ident.name.to_ident_string() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Requires imports to by prefix instead of fuzzily.<CODESPLIT>pub fn path_fuzzy_name_to_prefix(&mut self) { if let ImportCandidate::Path(PathImportCandidate { name: to_import, .. }) = &mut self.import_candidate { let (name, case_sensitive) = match to_import { NameToImport::Fuzzy(name, case_sensitive) => { (std::mem::take(name), *case_sensitive) } _ => return, }; *to_import = NameToImport::Prefix(name, case_sensitive); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `executeArb` (0x650dc8e5) function<CODESPLIT>pub fn execute_arb( &self, basic_order: BasicOrderParameters, payment_value: ::ethers::core::types::U256, sudo_pool: ::ethers::core::types::Address, ) -> ::ethers::contract::builders::ContractCall<M, ()> { self.0 .method_hash( [101, 13, 200, 229], (basic_order, payment_value, sudo_pool), ) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>This caused a failure in #18906<CODESPLIT>fn bar<Q>(k: &K, q: &Q) where K: Borrow<Q>, Q: Foo { q.foo(k.borrow()) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>TOP-LEVEL FN'S<CODESPLIT>fn escaping_borrow_of_fn_params_1() { fn g<'a>(x: usize, y:usize) -> Box<dyn Fn(bool) -> usize + 'a> { let f = |t: bool| if t { x } else { y }; return Box::new(f); }; }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Writes the buffer to the disk if it is dirty.<CODESPLIT>async fn flush(&mut self) -> io::Result<()> { if self.buffer_dirty { let guest_mem = GuestMemory::allocate(self.inner.sector_size() as usize); guest_mem.write_at(0, &self.buffer).unwrap(); let write_buffers = OwnedRequestBuffers::linear(0, self.inner.sector_size() as usize, true); let binding = write_buffers.buffer(&guest_mem); let future = self.inner.write_vectored( &binding, self.pos / self.inner.sector_size() as u64, true, ); let result = future.await; self.buffer_dirty = false; result.map_err(|e| io::Error::new(io::ErrorKind::Other, format!("Fetch error: {}", e))) } else { Ok(()) } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Begins opening a database by reading the database header.<CODESPLIT>pub fn begin_open(page_io: Rc<dyn DatabaseStorage>) -> Result<Rc<RefCell<DatabaseHeader>>> { sqlite3_ondisk::begin_read_database_header(page_io) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>`None` if function without a body; some bool to guess if function can panic<CODESPLIT>fn can_panic(ast_func: &ast::Fn) -> Option<bool> { let body = ast_func.body()?.to_string(); let can_panic = body.contains("panic!(") || body.contains("assert!(") || body.contains(".unwrap()") || body.contains(".expect("); Some(can_panic) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Gets the contract's `TokenDeposit` event<CODESPLIT>pub fn token_deposit_filter( &self, ) -> ::ethers::contract::builders::Event< ::std::sync::Arc<M>, M, TokenDepositFilter, > { self.0.event() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `incrementCounter` (0x5b34b966) function<CODESPLIT>pub fn increment_counter( &self, ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::U256> { self.0 .method_hash([91, 52, 185, 102], ()) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Get the status of a given proof. If the status is Fulfilled, the proof is also returned.<CODESPLIT>pub async fn get_proof_request_status<P: DeserializeOwned>( &self, request_id: &[u8], ) -> Result<(GetProofRequestStatusResponse, Option<P>)> { let mut rpc = self.get_rpc().await?; let res = rpc .get_proof_request_status(GetProofRequestStatusRequest { request_id: request_id.to_vec(), }) .await? .into_inner(); let status = ProofStatus::try_from(res.status)?; let proof = match status { ProofStatus::Fulfilled => { log::info!("Proof request fulfilled"); let proof_uri = res .proof_uri .as_ref() .ok_or_else(|| anyhow::anyhow!("No proof URL provided"))?; let proof_bytes = self.download_artifact(proof_uri).await?; Some(bincode::deserialize(&proof_bytes).context("Failed to deserialize proof")?) } _ => None, }; Ok((res, proof)) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `fulfillBasicOrder` (0xfb0f3ee1) function<CODESPLIT>pub fn fulfill_basic_order( &self, parameters: BasicOrderParameters, ) -> ::ethers::contract::builders::ContractCall<M, bool> { self.0 .method_hash([251, 15, 62, 225], (parameters,)) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Makes all future work submitted to the given stream wait for this event. Does not block the CPU. Note: cudaStreamWaitEvent must be called on the same device as the stream.<CODESPLIT>pub fn wait(&self, stream: &CudaStream) { unsafe { check_res( "cuda_event_block_C", cuda_event_block_C(self.cu_ev.ptr, stream.cu_str), ) }; }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Element-wise AND on two boolean slices of the same length. We do not check for length equality here.<CODESPLIT>pub(super) fn slice_and(lhs: &[bool], rhs: &[bool]) -> Vec<bool> { slice_binary_op(lhs, rhs, |l, r| -> bool { *l && *r }) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>@ revisions: current next @ ignore-compare-mode-next-solver (explicit revisions) @[next] compile-flags: -Znext-solver<CODESPLIT>fn changer<'a>(mut things: Box<dyn Iterator<Item=&'a mut u8>>) { for item in *things { *item = 0 } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Get the value of a flowey Var as a ADO runtime variable.<CODESPLIT>pub fn get_var(&mut self, var: ClaimedReadVar<String>) -> AdoRuntimeVar { let backing_var = if let ReadVarBacking::RuntimeVar(var) = &var.backing_var { var } else { todo!("support inline ado read vars") }; let new_ado_var_name = (self.fresh_ado_var)(); self.rust_to_ado.push(( backing_var.clone(), new_ado_var_name.clone(), var.is_secret, )); AdoRuntimeVar::dangerous_from_global(new_ado_var_name, var.is_secret) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>FIXME: This is only used in collection, we should move the relevant parts of it out of ItemScope<CODESPLIT>pub(crate) fn unnamed_trait_vis(&self, tr: TraitId) -> Option<Visibility> { self.unnamed_trait_imports.get(&tr).copied().map(|(a, _)| a) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Retrieves the Process Environment Block (PEB) of the current process. This function uses architecture-specific intrinsics to access the Thread Environment Block (TEB) and extract the PEB pointer. # Returns A mutable pointer to the PEB structure.<CODESPLIT>pub unsafe fn get_peb() -> *mut PEB { let teb_offset = ntapi::FIELD_OFFSET!(NT_TIB, _Self) as u32; #[cfg(target_arch = "x86_64")] unsafe { use ntapi::winapi_local::um::winnt::__readgsqword; let teb = __readgsqword(teb_offset) as *mut TEB; (*teb).ProcessEnvironmentBlock } #[cfg(target_arch = "x86")] unsafe { use ntapi::winapi_local::um::winnt::__readfsdword; let teb = __readfsdword(teb_offset) as *mut TEB; (*teb).ProcessEnvironmentBlock } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Sets the last OS error and return `-1` as a `i32`-typed Scalar<CODESPLIT>fn set_last_error_and_return_i32( &mut self, err: impl Into<IoError>, ) -> InterpResult<'tcx, Scalar> { let this = self.eval_context_mut(); this.set_last_error(err)?; interp_ok(Scalar::from_i32(-1)) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Print error message, along with (optional) stack trace, then exit<CODESPLIT>fn print_error(message: &str, sub_message: &str, error: Option<&Error>) { eprintln!( "{}{}{}", format!("{}", message).red(), match error { Some(err) => format!("\n{}", err).red().dimmed(), None => "".red().dimmed(), }, format!("\n{}", sub_message).yellow(), ); std::process::exit(1); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>EMIT_MIR lower_intrinsics.transmute_ref_dst.LowerIntrinsics.diff<CODESPLIT>pub unsafe fn transmute_ref_dst<T: ?Sized>(u: &T) -> *const T { unsafe { std::mem::transmute(u) } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Spins forever, preserving some context in the registers.<CODESPLIT>pub fn dead_loop(code0: u64, code1: u64, code2: u64) -> ! { unsafe { core::arch::asm!("1: jmp 1b", in ("rdi") code0, in ("rsi") code1, in ("rax") code2, options(att_syntax)); core::hint::unreachable_unchecked() } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Not re-exported outside the crate<CODESPLIT>pub fn new(url: &mut Url) -> PathSegmentsMut<'_> { let after_path = url.take_after_path(); let old_after_path_position = to_u32(url.serialization.len()).unwrap(); // Special urls always have a non empty path if SchemeType::from(url.scheme()).is_special() { debug_assert!(url.byte_at(url.path_start) == b'/'); } else { debug_assert!( url.serialization.len() == url.path_start as usize || url.byte_at(url.path_start) == b'/' ); } PathSegmentsMut { after_first_slash: url.path_start as usize + "/".len(), url, old_after_path_position, after_path, } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>returns the the path of simpleguest binary. Picks rust c version depending on environment variable GUEST (or rust by default if unset)<CODESPLIT>pub(crate) fn get_c_or_rust_simpleguest_path() -> String { let guest_type = std::env::var("GUEST").unwrap_or("rust".to_string()); match guest_type.as_str() { "rust" => simple_guest_as_string().unwrap(), "c" => c_simple_guest_as_string().unwrap(), _ => panic!("Unknown guest type '{guest_type}', use either 'rust' or 'c'"), } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Counts how many base-10 digits are required to represent n in the given base<CODESPLIT>fn count_digits(n: u16) -> usize { match n { 0..=9 => 1, 10..=99 => 2, 100..=999 => 3, 1000..=9999 => 4, 10000..=65535 => 5, } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Adds a assistant message to the conversation by templating the specified template string and parameters. # Arguments * `body` - A template string representing the message body. * `parameters` - Parameters used to template the message body # Returns Result<Self, StringTemplateError> If Ok() A Result containing a modified `ChatMessageCollection` with the new assistant message added on success, or an error if the body couldn't be templated<CODESPLIT>pub fn with_assistant_template( self, body: &str, parameters: &Parameters, ) -> Result<Self, StringTemplateError> { match StringTemplate::tera(body).format(parameters) { Err(e) => Err(e), Ok(templated_body) => Ok(self.with_assistant(templated_body)), } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>while static methods can *assume* this, we should still *check* that it holds at the use site.<CODESPLIT>fn evil<'a, 'b>(b: &'b u32) -> &'a u32 { <()>::static_evil(b) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Used to prefetch queries which will be needed later by metadata encoding. Only a subset of the queries are actually prefetched to keep this code smaller.<CODESPLIT>fn prefetch_mir(tcx: TyCtxt<'_>) { if !tcx.sess.opts.output_types.should_codegen() { // We won't emit MIR, so don't prefetch it. return; } let reachable_set = tcx.reachable_set(()); par_for_each_in(tcx.mir_keys(()), |&def_id| { let (encode_const, encode_opt) = should_encode_mir(tcx, reachable_set, def_id); if encode_const { tcx.ensure_with_value().mir_for_ctfe(def_id); } if encode_opt { tcx.ensure_with_value().optimized_mir(def_id); } if encode_opt || encode_const { tcx.ensure_with_value().promoted_mir(def_id); } }) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Get the tensor map for this cache. This can be used to save the cache to disk.<CODESPLIT>pub fn get_tensor_map(&self, device: &Device) -> HashMap<String, Tensor> { let mut map = HashMap::with_capacity(self.blocks.len()); for (i, kv_cache) in self.blocks.iter().enumerate() { if let (Ok(Some(k)), Ok(Some(v))) = (kv_cache.cache().k(), kv_cache.cache().v()) { map.insert(format!("llama.cache.blocks.{}.key", i), k); map.insert(format!("llama.cache.blocks.{}.value", i), v); } } map.insert( "llama.cache.tokens".to_string(), Tensor::from_iter(self.tokens.iter().copied(), device).unwrap(), ); map.insert( "llama.cache.max_seq_len".to_string(), Tensor::new(self.max_seq_len as u32, device).unwrap(), ); map }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>`.len()` on arrays ends up being something like this<CODESPLIT>fn array_len(x: &mut [i32; 42]) -> usize { let x: &[i32] = x; std::intrinsics::ptr_metadata(x) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `onERC1155Received` (0xf23a6e61) function<CODESPLIT>pub fn on_erc1155_received( &self, p0: ::ethers::core::types::Address, p1: ::ethers::core::types::Address, p2: ::ethers::core::types::U256, p3: ::ethers::core::types::U256, p4: ::ethers::core::types::Bytes, ) -> ::ethers::contract::builders::ContractCall<M, [u8; 4]> { self.0 .method_hash([242, 58, 110, 97], (p0, p1, p2, p3, p4)) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>HACK(eddyb) this can't be a closure due to lifetime elision.<CODESPLIT>fn loop_initial_states( func_at_loop_node: FuncAtMut<'_, ControlNode>, ) -> &mut SmallVec<[Value; 2]> { match &mut func_at_loop_node.def().kind { ControlNodeKind::Loop { initial_inputs, .. } => initial_inputs, _ => unreachable!(), } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>get_group_by_tracking_id<CODESPLIT>pub async fn get_group_by_tracking_id( data: web::Path<GetGroupByTrackingIDData>, dataset_org_plan_sub: DatasetAndOrgWithSubAndPlan, _user: LoggedUser, pool: web::Data<Pool>, ) -> Result<HttpResponse, actix_web::Error> { let group = get_group_from_tracking_id_query( data.tracking_id.clone(), dataset_org_plan_sub.dataset.id, pool.clone(), ) .await?; Ok(HttpResponse::Ok().json(group)) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Removes an environment variable for the command.<CODESPLIT>pub fn env_remove(mut self, key: impl AsRef<str>) -> Self { self.env_changes .push(EnvChange::Remove(key.as_ref().to_owned())); self }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Copy the contents of the sandbox at the specified offset into the slice<CODESPLIT>pub fn copy_from_slice(&self, slice: &[u8], offset: usize) -> Result<()> { bounds_check!(offset, slice.len(), self.mem_size()); let base = self.base_ptr().wrapping_add(offset); let guard = self .lock .try_read() .map_err(|e| new_error!("Error locking at {}:{}: {}", file!(), line!(), e))?; for (i, b) in slice.iter().enumerate() { unsafe { base.wrapping_add(i).write_volatile(*b); } } drop(guard); Ok(()) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Look for `self: &'a Self` - also desugared from `&'a self`<CODESPLIT>fn is_self_ty(&self, ty: &Ty) -> bool { match ty.kind { TyKind::ImplicitSelf => true, TyKind::Path(None, _) => { let path_res = self.r.partial_res_map[&ty.id].full_res(); if let Some(Res::SelfTyParam { .. } | Res::SelfTyAlias { .. }) = path_res { return true; } self.impl_self.is_some() && path_res == self.impl_self } _ => false, } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Write output in the optionally specified color. The output is written in the specified color if this OutputWriter instance contains a Terminal in its `terminal` field.<CODESPLIT>pub(crate) fn writeln(&mut self, msg: &str, color: Option<term::color::Color>) { match &mut self.terminal { Some(ref mut t) => { if let Some(color) = color { t.fg(color).unwrap(); } writeln!(t, "{msg}").unwrap(); if color.is_some() { t.reset().unwrap(); } } None => println!("{msg}"), } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Run the sequence of passes without validating the MIR after each pass. The MIR is still validated at the end.<CODESPLIT>pub(super) fn run_passes_no_validate<'tcx>( tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>, passes: &[&dyn MirPass<'tcx>], phase_change: Option<MirPhase>, ) { run_passes_inner(tcx, body, passes, phase_change, false); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>#11067 and #9626<CODESPLIT>fn assoc_tys_generics<'a, 'b, T, U>() where T: IntoIterator<Item = ()> + IntoIterator<Item = i32>, U: From<&'a str> + From<&'b [u16]>, { }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>This used to fail MIR validation due to the types on both sides of an assignment not being equal. The failure doesn't occur with a check-only build.<CODESPLIT>fn iter_slice<'a, T>(xs: &'a [T]) -> impl Iterator<Item = &'a T> { xs.iter() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Make sure that reading from an `&mut` does, like reborrowing to `&`, NOT invalidate other reborrows.<CODESPLIT>fn read_does_not_invalidate1() { fn foo(x: &mut (i32, i32)) -> &i32 { let xraw = x as *mut (i32, i32); let ret = unsafe { &(*xraw).1 }; let _val = x.1; ret } assert_eq!(*foo(&mut (1, 2)), 2); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Generate periodic labels to render on the y-axis (query count)<CODESPLIT>fn generate_y_labels(max: i32, count: usize) -> Vec<Span<'static>> { let step = max / (count - 1) as i32; (0..count) .map(|x| Span::raw(format!("{}", x * step as usize))) .collect::<Vec<Span<'static>>>() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>If `ty` is a type variable with known type, returns that type; otherwise, return ty.<CODESPLIT>pub(crate) fn resolve_ty_shallow(&mut self, ty: &Ty) -> Ty { self.resolve_obligations_as_possible(); self.var_unification_table.normalize_ty_shallow(Interner, ty).unwrap_or_else(|| ty.clone()) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>This is an identity function (`|x| x`), but implemented using recursion. Each step we increment accumulator and decrement the number. With normal calls this fails compilation because of the recursion limit, but with tail calls `become` we don't grow the stack spend recursion limit so this should compile.<CODESPLIT>const fn rec_id(n: u32) -> u32 { const fn inner(acc: u32, n: u32) -> u32 { match n { 0 => acc, #[cfg(r#become)] _ => become inner(acc + 1, n - 1), #[cfg(r#return)] _ => return inner(acc + 1, n - 1), } } inner(0, n) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Bump the amount of mock time that's passed.<CODESPLIT>pub fn tick(&self, d: std::time::Duration) { let mut time = self.time.lock(); *time = *time + LocalClockDelta::from_millis(d.as_millis().try_into().unwrap()) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Guarantees that each returned number is unique.<CODESPLIT>pub fn next(&mut self) -> u32 { self.count += 1; assert!(self.count <= 70029); let x = self.x; let t = x ^ (x << 11); self.x = self.y; self.y = self.z; self.z = self.w; let w_ = self.w; self.w = w_ ^ (w_ >> 19) ^ (t ^ (t >> 8)); self.w }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>If you pass in an array, it will not be sorted.<CODESPLIT>pub(crate) fn serialize<T: Serialize>(item: T) -> Result<Self, serde_json::Error> { Ok(Self(serde_json::to_string(&item)?)) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Loads a classifier from the given path.<CODESPLIT>pub fn load<P: AsRef<std::path::Path>>( path: P, device: &Device, config: ClassifierConfig, ) -> candle_core::Result<Self> { let model = Classifier::load(path, device, config)?; Ok(Self::new(model)) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Get the closest N embeddings to the given embedding.<CODESPLIT>pub fn search<'a>(&'a self, embedding: &'a Embedding<S>) -> VectorDBSearchBuilder<'a, S> { VectorDBSearchBuilder { db: self, embedding, results: None, filter: None, } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>DevkitA64 doesn't natively support debug info, but the build system will place debug info at the path `romfs: debug_info.elf`.<CODESPLIT>pub(super) fn native_libraries() -> Vec<Library> { extern "C" { static __start__: u8; } let bias = core::ptr::addr_of!(__start__) as usize; let mut ret = Vec::new(); let mut segments = Vec::new(); segments.push(LibrarySegment { stated_virtual_memory_address: 0, len: usize::max_value() - bias, }); let path = "romfs:/debug_info.elf"; ret.push(Library { name: path.into(), segments, bias, }); ret }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>EMIT_MIR slice_iter.enumerated_loop.PreCodegen.after.mir<CODESPLIT>pub fn enumerated_loop<'a, T>(slice: &'a [T], f: impl Fn(usize, &T)) { for (i, x) in slice.iter().enumerate() { f(i, x) } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns true if the filename at `path` is not in `expected`.<CODESPLIT>pub fn filename_not_in_denylist<P: AsRef<Path>, V: AsRef<[String]>>(path: P, expected: V) -> bool { let expected = expected.as_ref(); path.as_ref() .file_name() .is_some_and(|name| !expected.contains(&name.to_str().unwrap().to_owned())) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Puts a value, returning as soon as the value is written to the memtable but before it is flushed to durable storage.<CODESPLIT>fn put(&self, key: Bytes, value: Bytes, attrs: RowAttributes) { self.maybe_subtract_old_val_from_size(key.clone()); self.size.fetch_add( key.len() + value.len() + sizeof_attributes(&attrs), Ordering::Relaxed, ); self.map.insert( key, ValueWithAttributes { value: ValueDeletable::Value(value), attrs, }, ); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Whether the error is due to malformed data in the signature lists<CODESPLIT>pub fn key_var_error(&self) -> bool { match self { FormatError::SignatureList(_) | FormatError::SignatureListX509(_) => true, FormatError::AuthVarPkcs7Der(_) | FormatError::AuthVarPkcs7DerHeader(_) => false, } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Inverse of [`Ty::to_opt_closure_kind`]. See docs on that method for explanation of the relationship between `Ty` and [`ty::ClosureKind`].<CODESPLIT>pub fn from_closure_kind(tcx: TyCtxt<'tcx>, kind: ty::ClosureKind) -> Ty<'tcx> { match kind { ty::ClosureKind::Fn => tcx.types.i8, ty::ClosureKind::FnMut => tcx.types.i16, ty::ClosureKind::FnOnce => tcx.types.i32, } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Diagnostic: typed-hole This diagnostic is triggered when an underscore expression is used in an invalid position.<CODESPLIT>pub(crate) fn typed_hole(ctx: &DiagnosticsContext<'_>, d: &hir::TypedHole) -> Diagnostic { let display_range = ctx.sema.diagnostics_display_range(d.expr.map(|it| it.into())); let (message, fixes) = if d.expected.is_unknown() { ("`_` expressions may only appear on the left-hand side of an assignment".to_owned(), None) } else { ( format!( "invalid `_` expression, expected type `{}`", d.expected .display(ctx.sema.db, ctx.edition) .with_closure_style(ClosureStyle::ClosureWithId), ), fixes(ctx, d), ) }; Diagnostic::new(DiagnosticCode::RustcHardError("typed-hole"), message, display_range) .with_fixes(fixes) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Creates a new opaque origin that is only equal to itself.<CODESPLIT>pub fn new_opaque() -> Origin { static COUNTER: AtomicUsize = AtomicUsize::new(0); Origin::Opaque(OpaqueOrigin(COUNTER.fetch_add(1, Ordering::SeqCst))) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Offers a new channel, returning a typed handle to get back the original channel when it's revoked.<CODESPLIT>pub async fn offer_simple_device<T: 'static + SimpleVmbusDevice>( driver_source: &VmTaskDriverSource, bus: &(impl ParentBus + ?Sized), device: T, ) -> anyhow::Result<SimpleDeviceHandle<T>> { let driver = driver_source.builder().target_vp(0).build("simple-vmbus"); let channel = SimpleDeviceWrapper::new(driver, device); Ok(SimpleDeviceHandle( offer_channel(&driver_source.simple(), bus, channel).await?, )) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>EMIT_MIR casts.redundant.InstSimplify-after-simplifycfg.diff<CODESPLIT>pub fn redundant<'a, 'b: 'a>(x: *const &'a u8) -> *const &'a u8 { // CHECK-LABEL: fn redundant( // CHECK: inlined generic_cast // CHECK-NOT: as generic_cast::<&'a u8, &'b u8>(x) as *const &'a u8 }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Replays all transactions in a block returning the requested traces for each transaction<CODESPLIT>pub async fn trace_replay_block_transactions( &self, block: BlockNumber, trace_types: Vec<TraceType>, ) -> Result<Vec<BlockTrace>> { let _permit = self.permit_request().await; Self::map_err( source_provider!(self, trace_replay_block_transactions(block, trace_types)).await, ) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Resolves the path to an absolute path.<CODESPLIT>pub fn resolve(&self, project_root: &Path) -> PathBuf { let native_path = Path::new(self.path.as_str()); if native_path.is_absolute() { native_path.to_path_buf() } else { project_root.join(native_path) } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>return the lsn the cursor is currently pointing at<CODESPLIT>pub fn lsn(&mut self) -> Option<Lsn> { self.state.as_ref().map(|(lsn, _)| *lsn) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Warning; two input lifetimes, but the output lifetime is not elided, i.e., the following is valid: fn struct_with_lt4b<'b>(_foo: &Foo<'b>) -> &'b str ^^^^<CODESPLIT>fn struct_with_lt4b<'a, 'b>(_foo: &'a Foo<'b>) -> &'b str { unimplemented!() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>We have `size < min_align`. Round `size` *down* to the next power of two and use that.<CODESPLIT>fn prev_power_of_two(x: u64) -> u64 { let next_pow2 = x.next_power_of_two(); if next_pow2 == x { x } else { next_pow2 / 2 } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Provide the patterns that need to be matched.<CODESPLIT>pub fn patterns<P: AsRef<Path>>(&mut self, path: P) -> &mut Self { self.cmd.arg(path.as_ref()); self }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Reports that the currently active query read the result from another query. Also checks whether the "cycle participant" flag is set on the current stack frame -- if so, panics with `CycleParticipant` value, which should be caught by the code executing the query. # Parameters - `database_key`: the query whose result was read - `changed_revision`: the last revision in which the result of that query had changed<CODESPLIT>pub(crate) fn report_query_read_and_unwind_if_cycle_resulted( &self, input: DatabaseKeyIndex, durability: Durability, changed_at: Revision, ) { self.local_state .report_query_read_and_unwind_if_cycle_resulted(input, durability, changed_at); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns true if the requirement is a direct dependency. I.e. a url, path or git requirement.<CODESPLIT>pub fn is_direct_dependency(&self) -> bool { matches!( self, PyPiRequirement::Git { .. } | PyPiRequirement::Path { .. } | PyPiRequirement::Url { .. } ) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns the amount of memory required to create a [`SafelyOverflowingIndexQueue`] with the provided capacity.<CODESPLIT>pub const fn const_memory_size(capacity: usize) -> usize { unaligned_mem_size::<UnsafeCell<usize>>(capacity + 1) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>EMIT_MIR issue_59352.num_to_digit.PreCodegen.after.mir @ compile-flags: -Z mir-opt-level=3 -Z span_free_formats<CODESPLIT>pub fn num_to_digit(num: char) -> u32 { if num.is_digit(8) { num.to_digit(8).unwrap() } else { 0 } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>EMIT_MIR matches_reduce_branches.match_u8_i8.MatchBranchSimplification.diff<CODESPLIT>fn match_u8_i8(i: EnumAu8) -> i8 { match i { EnumAu8::u0_0x00 => 0, EnumAu8::u127_0x7f => 127, EnumAu8::u128_0x80 => -128, EnumAu8::u255_0xff => -1, } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>This function shows quite directly what is going on: We have a reborrow of contents within the box.<CODESPLIT>fn return_borrow_from_dropped_box_1(x: Box<&mut u32>) -> &mut u32 { &mut **x }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Set the `initial_max_stream_data_uni` transport parameter. The value is capped by the setting `max_stream_window`. The default value is `1048576`.<CODESPLIT>pub fn set_initial_max_stream_data_uni(&mut self, v: u64) { self.local_transport_params.initial_max_stream_data_uni = cmp::min(v, self.max_stream_window); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Computes the size for a byte slice.<CODESPLIT>pub fn bytes(mut self, len: usize) { if len != 0 || self.state.in_sequence { self.add(varint_size(len as u64) + len); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Produce the evaluation of a subpolynomial used in sumcheck<CODESPLIT>pub fn produce_sumcheck_subpolynomial_evaluation( &mut self, subpolynomial_type: &SumcheckSubpolynomialType, eval: S, ) { self.sumcheck_evaluation += self.subpolynomial_multipliers[self.produced_subpolynomials] * match subpolynomial_type { SumcheckSubpolynomialType::Identity => { eval * self.mle_evaluations.random_evaluation } SumcheckSubpolynomialType::ZeroSum => eval, }; self.produced_subpolynomials += 1; }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Creates a new `OfferResources`.<CODESPLIT>pub fn new(untrusted_memory: GuestMemory, private_memory: Option<GuestMemory>) -> Self { OfferResources { untrusted_memory, private_memory, } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>assume there is only single cert per signature list see comment associated with `SignatureList::X509` for rationale<CODESPLIT>fn next_inner(&mut self) -> Result<Option<SignatureData<X509Data<'a>>>, ParseError> { if self.buf.is_empty() { return Ok(None); } let (header, buf) = EFI_SIGNATURE_DATA::read_from_prefix_split(self.buf) .ok_or(ParseError::X509InvalidHeader)?; let val: Cow<'a, [u8]> = buf.into(); let res = SignatureData::new_x509(header.signature_owner, val); self.buf = &[]; Ok(Some(res)) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>lifetime pointers with 'static lifetime are ok<CODESPLIT>fn static_lifime_ok<'a,T,U:Send>(_: &'a isize) { assert_send::<&'static isize>(); assert_send::<&'static str>(); assert_send::<&'static [isize]>(); // whether or not they are mutable assert_send::<&'static mut isize>(); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>EMIT_MIR address_of_pair.fn0.GVN.diff<CODESPLIT>pub fn fn0() -> bool { let mut pair = (1, false); let ptr = core::ptr::addr_of_mut!(pair.1); pair = (1, false); unsafe { *ptr = true; } let ret = !pair.1; return ret; }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>@ edition:2018 @ aux-crate:reexported_trait=reexported-trait.rs<CODESPLIT>fn main() { reexported_trait::FooStruct.trait_method(); reexported_trait::FooStruct.trait_method_b(); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>~ ERROR unconstrained opaque type<CODESPLIT>fn bar<'a: 'a>() where Self::Assoc<'a>:, { let _ = |x: &'a ()| { let _: Self::Assoc<'a> = x; //~^ ERROR `<() as Foo>::Assoc<'a>` captures lifetime that does not appear in bound }; }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Create a new cache for a model with the given configuration.<CODESPLIT>pub fn new(config: &Config) -> Self { let mut blocks = Vec::with_capacity(config.n_layer); for _ in 0..config.n_layer { blocks.push(ParallelBlockCache(None)) } Self { blocks, first_token: true, } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Abort is a required command, but a legal implementation is to just complete it with a status that means "I'm sorry, that command couldn't be aborted."<CODESPLIT>fn handle_abort(&self) -> Result<Option<CommandResult>, NvmeError> { Ok(Some(CommandResult { status: spec::Status::SUCCESS, dw: [1, 0], })) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Determine the uppermost bounds for the x and y axis<CODESPLIT>fn find_bounds(stats: &StatsResponse) -> (f64, f64) { let mut max_length = 0; let mut max_value = f64::MIN; for dataset in &[&stats.dns_queries_chart, &stats.blocked_filtering_chart] { let length = dataset.len(); if length > max_length { max_length = length; } let max_in_dataset = dataset .iter() .map(|&(_, y)| y) .fold(f64::MIN, f64::max); if max_in_dataset > max_value { max_value = max_in_dataset; } } (max_length as f64, max_value) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>@ run-fail @ check-run-results @ exec-env:RUST_BACKTRACE=0 ignore-tidy-linelength<CODESPLIT>fn main() { assert!(1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20 + 21 + 22 + 23 + 24 + 25 == 0); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `transferFrom` (0x23b872dd) function<CODESPLIT>pub fn transfer_from( &self, from: ::ethers::core::types::Address, to: ::ethers::core::types::Address, token_id: ::ethers::core::types::U256, ) -> ::ethers::contract::builders::ContractCall<M, ()> { self.0 .method_hash([35, 184, 114, 221], (from, to, token_id)) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Converts an `ast::PathType` to a `hir::TraitRef`.<CODESPLIT>pub(crate) fn from_ast(ctx: &mut LowerCtx<'_>, node: ast::Type) -> Option<Self> { match node { ast::Type::PathType(path) => { path.path().and_then(|it| ctx.lower_path(it)).map(|path| TraitRef { path }) } _ => None, } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Read a null-terminated sequence of bytes, and perform path separator conversion if needed.<CODESPLIT>fn read_path_from_c_str<'a>(&'a self, ptr: Pointer) -> InterpResult<'tcx, Cow<'a, Path>> where 'tcx: 'a, { let this = self.eval_context_ref(); let os_str = this.read_os_str_from_c_str(ptr)?; interp_ok(match this.convert_path(Cow::Borrowed(os_str), PathConversion::TargetToHost) { Cow::Borrowed(x) => Cow::Borrowed(Path::new(x)), Cow::Owned(y) => Cow::Owned(PathBuf::from(y)), }) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `assetRecipient` (0x3bfa67fe) function<CODESPLIT>pub fn asset_recipient( &self, ) -> ::ethers::contract::builders::ContractCall< M, ::ethers::core::types::Address, > { self.0 .method_hash([59, 250, 103, 254], ()) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Important: we *cannot* use bx.emit() here, because this is called in contexts where the emitter is already locked. Doing so may cause subtle rare bugs.<CODESPLIT>pub fn def(self, bx: &builder::Builder<'_, '_>) -> Word { self.def_with_span(bx, bx.span()) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns a `Url` object from a given path, will lowercase drive letters if present. This will only happen when processing windows paths. When processing non-windows path, this is essentially the same as `Url::from_file_path`.<CODESPLIT>pub(crate) fn url_from_abs_path(path: &AbsPath) -> lsp_types::Url { let url = lsp_types::Url::from_file_path(path).unwrap(); match path.components().next() { Some(Utf8Component::Prefix(prefix)) if matches!(prefix.kind(), Utf8Prefix::Disk(_) | Utf8Prefix::VerbatimDisk(_)) => { } _ => return url, } let driver_letter_range = { let (scheme, drive_letter, _rest) = match url.as_str().splitn(3, ':').collect_tuple() { Some(it) => it, None => return url, }; let start = scheme.len() + ':'.len_utf8(); start..(start + drive_letter.len()) }; let mut url: String = url.into(); url[driver_letter_range].make_ascii_lowercase(); lsp_types::Url::parse(&url).unwrap() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>This function only works when `mode::is_dyn_thread_safe()`.<CODESPLIT>pub fn scope<'scope, OP, R>(op: OP) -> R where OP: FnOnce(&rayon::Scope<'scope>) -> R + DynSend, R: DynSend, { let op = FromDyn::from(op); rayon::scope(|s| FromDyn::from(op.into_inner()(s))).into_inner() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>In this case, the control flow break happens *before* we construct `Foo(Noisy(1),Noisy(2))`, so there should be no record of it in the event log.<CODESPLIT>fn leak_3_ret() -> Foo { let _old_foo = || Foo { n0: Noisy(1), n1: Noisy(2) }; Foo { n1: { return Foo { n0: Noisy(3), n1: Noisy(4) } }, .._old_foo() }; }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Helper: see [`Runtime::try_block_on_or_unwind`].<CODESPLIT>fn block_on_or_unwind<MutexGuard>( &self, db: &<Q as QueryDb<'_>>::DynDb, runtime: &Runtime, other_id: RuntimeId, mutex_guard: MutexGuard, ) { runtime.block_on_or_unwind( db.ops_database(), self.database_key_index(), other_id, mutex_guard, ) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Create a variable, where we already know the scope and index it will be bound to<CODESPLIT>pub fn new(scope: usize, index: usize) -> Self { Self { internal: VariableInternal::Static(VariableScope { scope: scope as u16, index: index as u16, }), } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Dispatches a non-latency-sensitive request onto the thread pool. When the VFS is marked not ready this will return a `default` constructed [`R::Result`].<CODESPLIT>pub(crate) fn on_with<R>( &mut self, f: fn(GlobalStateSnapshot, R::Params) -> anyhow::Result<R::Result>, default: impl FnOnce() -> R::Result, on_cancelled: fn() -> ResponseError, ) -> &mut Self where R: lsp_types::request::Request< Params: DeserializeOwned + panic::UnwindSafe + Send + fmt::Debug, Result: Serialize, > + 'static, { if !self.global_state.vfs_done { if let Some(lsp_server::Request { id, .. }) = self.req.take_if(|it| it.method == R::METHOD) { self.global_state.respond(lsp_server::Response::new_ok(id, default())); } return self; } self.on_with_thread_intent::<true, false, R>(ThreadIntent::Worker, f, on_cancelled) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Read a pointer-sized unsigned integer from a place.<CODESPLIT>pub fn read_target_usize( &self, op: &impl Projectable<'tcx, M::Provenance>, ) -> InterpResult<'tcx, u64> { self.read_scalar(op)?.to_target_usize(self) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Parses the channels, getting channel config and default channels from config<CODESPLIT>pub(crate) fn resolve_from_config(&self, config: &Config) -> miette::Result<IndexSet<Channel>> { self.resolve(config.global_channel_config(), config.default_channels()) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Gets the contract's `TokenDeposit` event<CODESPLIT>pub fn token_deposit_filter( &self, ) -> ::ethers::contract::builders::Event< ::std::sync::Arc<M>, M, TokenDepositFilter, > { self.0.event() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Gets the linear IP of the CPU, taking into account the code segment. Returns None if IP EIP does not fit into the code segment.<CODESPLIT>pub fn linear_ip(&self, offset: u64) -> Option<u64> { let rip = self.state.rip.wrapping_add(offset); match self.state.bitness() { Bitness::Bit64 => Some(rip), Bitness::Bit32 | Bitness::Bit16 => { self.verify_segment_access( Register::CS, OperationKind::AddressComputation, offset, 1, ) .ok()?; let cs = &self.state.segs[CpuState::CS]; Some(cs.base.wrapping_add(rip)) } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns the number of elements in `row`.<CODESPLIT>pub fn count(&self, row: R) -> usize { let (start, end) = self.range(row); self.words[start..end].iter().map(|e| e.count_ones() as usize).sum() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns `true` if the local variable (or some part of it) is initialized at the current cursor position. Callers should call one of the `seek` methods immediately before to point the cursor to the desired location.<CODESPLIT>fn initialized_at_curr_loc(&self, mpi: MovePathIndex) -> bool { let state = self.flow_inits.get(); if state.contains(mpi) { return true; } let move_paths = &self.flow_inits.analysis().move_data().move_paths; move_paths[mpi].find_descendant(move_paths, |mpi| state.contains(mpi)).is_some() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Strip items marked `#[doc(hidden)]`<CODESPLIT>pub(crate) fn strip_hidden(krate: clean::Crate, cx: &mut DocContext<'_>) -> clean::Crate { let mut retained = ItemIdSet::default(); let is_json_output = cx.is_json_output(); let krate = { let mut stripper = Stripper { retained: &mut retained, update_retained: true, tcx: cx.tcx, is_in_hidden_item: false, last_reexport: None, }; stripper.fold_crate(krate) }; let mut stripper = ImplStripper { tcx: cx.tcx, retained: &retained, cache: &cx.cache, is_json_output, document_private: cx.render_options.document_private, document_hidden: cx.render_options.document_hidden, }; stripper.fold_crate(krate) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Token logits obtained from the last call to llama_eval() The logits for the last token are stored in the last row Can be mutated in order to change the probabilities of the next token Rows: n_tokens Cols: n_vocab<CODESPLIT>pub fn llama_get_logits_as_slice(&self, n_tokens: usize, n_vocab: usize) -> Vec<f32> { let len = n_tokens * n_vocab; unsafe { std::slice::from_raw_parts_mut(llama_get_logits(self.ctx), len) }.to_vec() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>The span is that of the surrounding type pattern expr whatever.<CODESPLIT>fn visit_qpath(&mut self, qpath: &'v QPath<'v>, id: HirId, _span: Span) -> Self::Result { walk_qpath(self, qpath, id) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns a VA mapper for this guest memory. This will single instance the mapper, so this is safe to call multiple times.<CODESPLIT>pub async fn new_mapper(&self) -> Result<Arc<VaMapper>, VaMapperError> { MAPPER_CACHE .get_or_insert_with(&self.id, async { VaMapper::new(self.req_send.clone(), self.max_addr, None).await }) .await }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>The type of `y` ends up getting inferred to the type of the block.<CODESPLIT>fn broken() { let mut x = 3; let mut _y = vec![&mut x]; while x < 10 { let mut z = x; _y.push(&mut z); x += 1; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Gets the name of a enum variant with index `idx`<CODESPLIT>pub fn variant_name(ty: Ty, idx: u32) -> crate::IString { match ty.kind() { TyKind::Adt(adt_def, _subst) => { let variant_def = &adt_def.variants()[idx.into()]; variant_def.name.to_string().into() } _ => todo!("Can't yet get fields of typr {ty:?}"), } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns true if this result is intended for the given `eax` and `ecx` input values.<CODESPLIT>pub fn matches(&self, eax: u32, ecx: u32) -> bool { self.function == eax && (self.index.is_none() || self.index == Some(ecx)) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>MSVC names enums differently than other platforms so that the debugging visualization format (natvis) is able to understand enums and render the active variant correctly in the debugger. For more information, look in rustc_codegen_llvm src debuginfo metadata enums cpp_like.rs.<CODESPLIT>fn msvc_enum_fallback<'tcx>( tcx: TyCtxt<'tcx>, ty_and_layout: TyAndLayout<'tcx>, push_inner: &dyn Fn(/*output*/ &mut String, /*visited*/ &mut FxHashSet<Ty<'tcx>>), output: &mut String, visited: &mut FxHashSet<Ty<'tcx>>, ) { assert!(!wants_c_like_enum_debuginfo(tcx, ty_and_layout)); output.push_str("enum2$<"); push_inner(output, visited); push_close_angle_bracket(true, output); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Loads documents within the given table and the given timestamp range. page_size is how many documents to fetch with a single query. It doesn't affect load_documents results, just efficiency of the internal queries. NOTE: The filter is implemented entirely in memory. We can potentially add indexes to the documents table to allow for an efficient database version of this query, but have not yet done so.<CODESPLIT>fn load_documents_from_table( &self, tablet_id: TabletId, range: TimestampRange, order: Order, page_size: u32, retention_validator: Arc<dyn RetentionValidator>, ) -> DocumentStream<'_> { self.load_documents(range, order, page_size, retention_validator) .try_filter(move |(_, doc_id, _)| future::ready(doc_id.table() == tablet_id)) .boxed() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>@compile-flags: -Zmiri-permissive-provenance C's memcpy is 0 bytes is UB for some pointers that are allowed in Rust's `copy_nonoverlapping`.<CODESPLIT>fn main() { let from = 42 as *const u8; let to = 23 as *mut u8; unsafe { to.copy_from(from, 0); libc::memcpy(to.cast(), from.cast(), 0); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Gets the current payload, or None if the end was reached. This function takes care of moving to the next payload buffer if the current offset matches the end.<CODESPLIT>fn get_payload(&mut self) -> Option<&'payload VirtioQueuePayload> { let payload = self.current?; if self.offset == payload.length as usize { self.next_payload(); self.offset = 0; } self.current }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Check that all arguments are shown in the error message, even if they're across multiple lines.<CODESPLIT>fn bar( a: i32, b: i32, c: i32, d: i32, e: i32, f: i32, ) { println!("{}", a); println!("{}", b); println!("{}", c); println!("{}", d); println!("{}", e); println!("{}", f); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>The RUSTFLAGS passed to all SPIR-V builds. FIXME(eddyb) expose most of these from `spirv-builder`.<CODESPLIT>fn rust_flags(codegen_backend_path: &Path) -> String { let target_features = [ "Int8", "Int16", "Int64", "Float64", "ShaderClockKHR", "ext:SPV_KHR_shader_clock", ]; [ &*format!("-Zcodegen-backend={}", codegen_backend_path.display()), "-Zbinary-dep-depinfo", "-Csymbol-mangling-version=v0", "-Zcrate-attr=feature(register_tool)", "-Zcrate-attr=register_tool(rust_gpu)", "-Coverflow-checks=off", "-Cdebug-assertions=off", "-Zinline-mir=off", "-Zmir-enable-passes=-GVN", "-Cdebuginfo=2", "-Cembed-bitcode=no", &format!("-Ctarget-feature=+{}", target_features.join(",+")), ] .join(" ") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Verify that we can thread jumps when we assign from an aggregate constant.<CODESPLIT>fn aggregate(x: u8) -> u8 { const FOO: (u8, u8) = (5, 13); let (a, b) = FOO; if a == 7 { b } else { a } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Helper function to send HierarchyControl command. # Arguments * `auth_handle`: The authorization handle used in the command. * `hierarchy`: The hierarchy to control. * `state`: Enable the target hierarchy or not.<CODESPLIT>pub fn hierarchy_control( &mut self, auth_handle: ReservedHandle, hierarchy: ReservedHandle, state: bool, ) -> Result<(), TpmCommandError> { use tpm20proto::protocol::HierarchyControlCmd; let session_tag = SessionTagEnum::Sessions; let mut cmd = HierarchyControlCmd::new( session_tag.into(), auth_handle, CmdAuth::new(TPM20_RS_PW, 0, 0, 0), hierarchy, state, ); self.tpm_engine .execute_command(cmd.as_bytes_mut(), &mut self.reply_buffer) .map_err(TpmCommandError::TpmExecuteCommand)?; match HierarchyControlCmd::base_validate_reply(&self.reply_buffer, session_tag) { Err(error) => Err(TpmCommandError::InvalidResponse(error))?, Ok((res, false)) => Err(TpmCommandError::TpmCommandFailed { response_code: res.header.response_code.get(), })?, Ok((_res, true)) => Ok(()), } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Check that underscore and unused bindings within and outwith more complex patterns are dropped after the method with self is polled.<CODESPLIT>async fn foobar_async( &'a self, ref mut x: D, (ref mut a, _, ref mut _c): (D, D, D), _: D, ref mut _y: D, ) { x.1.borrow_mut().push(DropOrder::Function); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Turn the wide MPlace into a string (must already be dereferenced!)<CODESPLIT>pub fn read_str(&self, mplace: &MPlaceTy<'tcx, M::Provenance>) -> InterpResult<'tcx, &str> { let len = mplace.len(self)?; let bytes = self.read_bytes_ptr_strip_provenance(mplace.ptr(), Size::from_bytes(len))?; let str = std::str::from_utf8(bytes).map_err(|err| err_ub!(InvalidStr(err)))?; interp_ok(str) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Signals the interrupt if it is enabled.<CODESPLIT>pub fn _signal(&self) { if self.enabled.load(Ordering::Relaxed) { if let Some(event) = &self.irqfd_event { event.signal(); } else if let Some(partition) = self.partition.upgrade() { assert!(cfg!(target_arch = "x86_64")); partition .kvm .irq_line(self.gsi, true) .expect("interrupt delivery failure"); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Gets the work queue for sending requests.<CODESPLIT>pub fn wq(&self) -> queues::Wq { if self.is_send { queues::Wq::new_sq(self.wq_mem.clone(), self.doorbell.clone(), self.wq_id) } else { queues::Wq::new_rq(self.wq_mem.clone(), self.doorbell.clone(), self.wq_id) } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Waits for a response message from the host. The caller is responsible for validating the message ID.<CODESPLIT>async fn recv_response(&mut self) -> Vec<u8> { self.response_message_recv .as_mut() .unwrap() .recv() .await .unwrap() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Adjust a Unix path to Windows conventions such that it un-does everything that `windows_to_unix` did, and such that if the Unix input path was absolute, then the Windows output path is absolute.<CODESPLIT>fn unix_to_windows<T>(path: &mut Vec<T>) where T: From<u8> + Copy + Eq, { let sep = T::from(b'\\'); for c in path.iter_mut() { if *c == b'/'.into() { *c = sep; } } if path.get(2..4) == Some(&[b':'.into(), sep]) && path[0] == sep { path.remove(0); } else if path.first() == Some(&sep) && path.get(1) != Some(&sep) { path.splice(0..0, [sep, sep, b'?'.into()]); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>~^ NOTE function defined here ~| NOTE function defined here ~| NOTE function defined here ~| NOTE function defined here ~| NOTE function defined here ~| NOTE function defined here ~| NOTE function defined here ~| NOTE function defined here ~| NOTE function defined here ~| NOTE function defined here ~| NOTE function defined here ~| NOTE ~| NOTE ~| NOTE ~| NOTE ~| NOTE ~| NOTE ~| NOTE ~| NOTE ~| NOTE ~| NOTE ~| NOTE<CODESPLIT>fn main() { foo::<u32>(42_usize); foo::<u32>(42_u64); foo::<u32>(42_u32); foo::<u32>(42_u16); foo::<u32>(42_u8); foo::<u32>(42_isize); foo::<u32>(42_i64); foo::<u32>(42_i32); foo::<u32>(42_i16); foo::<u32>(42_i8); foo::<u32>(42.0_f64); foo::<u32>(42.0_f32); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>rustfmt-format_strings: true<CODESPLIT>fn foo() -> &'static str { let sql = "ATTACH DATABASE ':memory:' AS my_attached; BEGIN; CREATE TABLE my_attached.foo(x INTEGER); INSERT INTO my_attached.foo VALUES(42); END;"; sql }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Convert an opcode to a byte opcode.<CODESPLIT>fn from(value: Opcode) -> Self { match value { Opcode::AND => Self::AND, Opcode::OR => Self::OR, Opcode::XOR => Self::XOR, Opcode::SLL => Self::SLL, _ => panic!("Invalid opcode for ByteChip: {value:?}"), } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Put a key-value pair into the batch. Keys must not be empty.<CODESPLIT>pub fn put_with_options(&mut self, key: &[u8], value: &[u8], options: &PutOptions) { assert!(!key.is_empty(), "key cannot be empty"); self.ops.push(WriteOp::Put( Bytes::copy_from_slice(key), Bytes::copy_from_slice(value), options.clone(), )); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Convenience wrapper around `doc_link_resolutions`. This also handles resolving `true` and `false` as booleans. NOTE: `doc_link_resolutions` knows only about paths, not about types. Associated items will never be resolved by this function.<CODESPLIT>fn resolve_path( &self, path_str: &str, ns: Namespace, item_id: DefId, module_id: DefId, ) -> Option<Res> { if let res @ Some(..) = self.resolve_self_ty(path_str, ns, item_id) { return res; } let result = self .cx .tcx .doc_link_resolutions(module_id) .get(&(Symbol::intern(path_str), ns)) .copied() .unwrap_or_else(|| { span_bug!( self.cx.tcx.def_span(item_id), "no resolution for {path_str:?} {ns:?} {module_id:?}", ) }) .and_then(|res| res.try_into().ok()) .or_else(|| resolve_primitive(path_str, ns)); debug!("{path_str} resolved to {result:?} in namespace {ns:?}"); result }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Detect text pixels in an image. Returns an (H, W) tensor indicating the probability of each pixel in the input being part of a text word. This is a low-level API that is useful for debugging purposes. Use [detect_words](OcrEngine::detect_words) for a higher-level API that returns oriented bounding boxes of words.<CODESPLIT>pub fn detect_text_pixels(&self, input: &OcrInput) -> anyhow::Result<NdTensor<f32, 2>> { if let Some(detector) = self.detector.as_ref() { detector.detect_text_pixels(input.image.view(), self.debug) } else { Err(anyhow!("Detection model not loaded")) } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>The range of the identifier that is being completed.<CODESPLIT>pub(crate) fn source_range(&self) -> TextRange { let kind = self.original_token.kind(); match kind { CHAR => { cov_mark::hit!(completes_if_lifetime_without_idents); TextRange::at(self.original_token.text_range().start(), TextSize::from(1)) } LIFETIME_IDENT | UNDERSCORE | INT_NUMBER => self.original_token.text_range(), _ if kind.is_any_identifier() => self.original_token.text_range(), _ => TextRange::empty(self.position.offset), } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `balanceOf` (0x70a08231) function<CODESPLIT>pub fn balance_of( &self, p0: ::ethers::core::types::Address, ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::U256> { self.0 .method_hash([112, 160, 130, 49], p0) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Maps this region to a guest address.<CODESPLIT>pub async fn map(&self, params: MapParams) { self.req_send .call(RegionRequest::MapRegion, (self.id.unwrap(), params)) .await .unwrap() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Does not need `Pin`, but other implementation do.<CODESPLIT>pub unsafe fn park_timeout(self: Pin<&Self>, dur: Duration) { if self.state.fetch_sub(1, Acquire) == NOTIFIED { return; } let nanos = dur.as_nanos().try_into().unwrap_or(i64::MAX); let timeout = dispatch_time(DISPATCH_TIME_NOW, nanos); let timeout = dispatch_semaphore_wait(self.semaphore, timeout) != 0; let state = self.state.swap(EMPTY, Acquire); if state == NOTIFIED && timeout { while dispatch_semaphore_wait(self.semaphore, DISPATCH_TIME_FOREVER) != 0 {} } else { } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Will add <$1> to the refname if it contains spaces<CODESPLIT>fn completion_text_edit(&self, display: Option<&str>, refname: &str) -> CompletionTextEdit { let ext = if self.settings().include_md_extension_md_link { ".md" } else { "" }; let link_ref_text = match refname.contains(' ') { true => format!("<{}{}>", refname, ext), false => format!("{}{}", refname, ext), }; CompletionTextEdit::Edit(TextEdit { range: Range { start: Position { line: self.line_nr as u32, character: self.full_range.start as u32, }, end: Position { line: self.line_nr as u32, character: self.full_range.end as u32, }, }, new_text: format!("[{}]({})", display.unwrap_or(""), link_ref_text), }) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Pushes a host request handler that sends a single host request and waits for its response.<CODESPLIT>fn push_basic_host_request_handler<Req, I, Resp>( &mut self, req: mesh::rpc::Rpc<I, Resp>, f: impl 'static + Send + FnOnce(I) -> Req, ) where Req: AsBytes + 'static + Send + Sync, I: 'static + Send, Resp: 'static + AsBytes + FromBytes + Send, { self.push_host_request_handler(|mut access| { req.handle_must_succeed(move |input| async move { access.send_request_fixed_size(&f(input)).await }) }); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Temporarily takes out another immutable handle on the same location.<CODESPLIT>pub fn reborrow(&self) -> Handle<NodeRef<marker::Immut<'_>, K, V, NodeType>, HandleType> { // We can't use Handle::new_kv or Handle::new_edge because we don't know our type Handle { node: self.node.reborrow(), idx: self.idx, _marker: PhantomData } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>EMIT_MIR slice_iter.range_loop.PreCodegen.after.mir<CODESPLIT>pub fn range_loop<'a, T>(slice: &'a [T], f: impl Fn(usize, &T)) { for i in 0..slice.len() { let x = &slice[i]; f(i, x) } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>EMIT_MIR dont_ice_on_generic_rust_call.call.Inline.diff<CODESPLIT>pub fn call<I: Tuple>(mut mock: Box<dyn FnMut<I, Output = ()>>, input: I) { mock.call_mut(input) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Insert the provided suffix into a filename just before the extension.<CODESPLIT>pub(crate) fn suffix_path(filename: &str, suffix: &str) -> PathBuf { let (base, ext) = filename.split_once('.').unwrap(); let filename = format!("{base}{suffix}.{ext}"); filename.into() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Get a `Block` of memory representing this immediate.<CODESPLIT>pub fn as_block(&self) -> Block<F> { match self { Imm::F(f) => Block::from(*f), Imm::EF(ef) => ef.as_base_slice().into(), } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Updates the current media session ID and marks the correct session as the current one.<CODESPLIT>fn update_current_session( &mut self, manager: &GsmtcManager, ) -> anyhow::Result<()> { self.current_session_id = manager .GetCurrentSession() .ok() .and_then(|session| session.SourceAppUserModelId().ok()) .map(|session_id| session_id.to_string()); for (session_id, state) in self.session_states.iter_mut() { state.output.is_current_session = Some(session_id) == self.current_session_id.as_ref(); } Ok(()) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Format a connection ID for a given channel.<CODESPLIT>pub fn new(channel_id: u32, vtl: Vtl, sint: u8) -> Self { Self(channel_id | (sint as u32) << 12 | (vtl as u32) << 16) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>If the active query is registered as a cycle participant, remove and return that cycle.<CODESPLIT>pub(crate) fn take_cycle(&self) -> Option<Cycle> { self.local_state.with_query_stack(|stack| stack.last_mut()?.cycle.take()) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns whether the given nested function has a trailing semicolon.<CODESPLIT>fn has_semicolon(function: &ast::Fn) -> bool { function .syntax() .next_sibling_or_token() .map(|t| t.kind() == SyntaxKind::SEMICOLON) .unwrap_or(false) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Borrows exclusive access to the data of an internal node.<CODESPLIT>fn as_internal_mut(&mut self) -> &mut InternalNode<K, V> { let ptr = Self::as_internal_ptr(self); unsafe { &mut *ptr } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Maps [`crate::Level`] to [`annotate_snippets::Level`]<CODESPLIT>fn annotation_level_for_level(level: Level) -> annotate_snippets::Level { match level { Level::Bug | Level::Fatal | Level::Error | Level::DelayedBug => { annotate_snippets::Level::Error } Level::ForceWarning(_) | Level::Warning => annotate_snippets::Level::Warning, Level::Note | Level::OnceNote => annotate_snippets::Level::Note, Level::Help | Level::OnceHelp => annotate_snippets::Level::Help, Level::FailureNote => annotate_snippets::Level::Error, Level::Allow => panic!("Should not call with Allow"), Level::Expect(_) => panic!("Should not call with Expect"), } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Check that `'static` lifetimes are not introduced by the specializing impl. For example forbid the following: ```ignore (illustrative) impl<A> Tr for A { } impl Tr for &'static i32 { } ```<CODESPLIT>fn check_static_lifetimes<'tcx>( tcx: TyCtxt<'tcx>, parent_args: &Vec<GenericArg<'tcx>>, span: Span, ) -> Result<(), ErrorGuaranteed> { if tcx.any_free_region_meets(parent_args, |r| r.is_static()) { return Err(tcx.dcx().emit_err(errors::StaticSpecialize { span })); } Ok(()) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>~^^ ERROR `d1` does not live long enough<CODESPLIT>fn f_mwsa() { let (_d, d1); d1 = D_HasMethodWithSelfArg(1); _d = D_HasMethodWithSelfArg(&d1); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>All of these should trigger the lint.<CODESPLIT>fn not_ok() { { let ptr = cstring().as_ptr(); consume(ptr); } consume({ let ptr = cstring().as_ptr(); ptr }); consume({ let s = cstring(); s.as_ptr() }); let _ptr: *const u8 = cstring().as_ptr().cast(); let _ptr: *const u8 = { cstring() }.as_ptr().cast(); let _ptr: *const u8 = { cstring().as_ptr() }.cast(); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Assign `TOP` to the discriminant of `place` and all places that may alias it.<CODESPLIT>pub fn flood_discr(&mut self, place: PlaceRef<'_>, map: &Map<'_>) where V: HasTop, { self.flood_discr_with(place, map, V::TOP) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns an iterator to parse the MADT entries.<CODESPLIT>pub fn entries(&self) -> MadtIter<'_> { MadtIter { entries: &self.0[size_of::<Madt>()..], } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Finds where to put the new enum definition. Tries to find the ast node at the nearest module or at top-level, otherwise just returns the input node.<CODESPLIT>fn node_to_insert_before(target_node: SyntaxNode) -> SyntaxNode { target_node .ancestors() .take_while(|it| !matches!(it.kind(), SyntaxKind::MODULE | SyntaxKind::SOURCE_FILE)) .filter(|it| ast::Item::can_cast(it.kind())) .last() .unwrap_or(target_node) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Should trigger lint when either side of an assign expression contains a temporary with a significant drop, because the temporary's lifetime will be extended to the end of the match. To avoid potential unnecessary copies or creating references that would trigger the significant drop problem, the lint recommends moving the entire binary operation.<CODESPLIT>fn should_trigger_lint_in_assign_expr() { let mutex = Mutex::new(StateWithIntField { i: 10 }); let mut i = 100; match mutex.lock().unwrap().i = i { _ => { println!("{}", mutex.lock().unwrap().i); }, }; match i = mutex.lock().unwrap().i { _ => { println!("{}", mutex.lock().unwrap().i); }, }; match mutex.lock().unwrap().i += 1 { _ => { println!("{}", mutex.lock().unwrap().i); }, }; match i += mutex.lock().unwrap().i { _ => { println!("{}", mutex.lock().unwrap().i); }, }; }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Consumes and returns the first message from the incoming message queue if there are any messages available.<CODESPLIT>pub fn try_recv(&mut self) -> Result<U, TryRecvError> { self.generic .try_recv()? .try_parse() .or_else(|m| lazy_parse(m, &mut self.deserialize)) .map_err(|err| TryRecvError::Error(err.into())) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Retrieves the IO memory. Panics if the IO has started and has not yet completed.<CODESPLIT>pub fn into_mem(mut self) -> T { match std::mem::replace(&mut self.state, IoState::Invalid) { IoState::Started(_) => { panic!("io is not complete"); } IoState::NotStarted(_, io_mem) | IoState::Completed(_, io_mem) => io_mem, IoState::Invalid => unreachable!(), } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Matching errors are added to the `Match`.<CODESPLIT>pub(super) fn match_(pattern: &MetaTemplate, input: &tt::Subtree<Span>, edition: Edition) -> Match { let mut res = match_loop(pattern, input, edition); res.bound_count = count(res.bindings.bindings()); return res; fn count<'a>(bindings: impl Iterator<Item = &'a Binding>) -> usize { bindings .map(|it| match it { Binding::Fragment(_) => 1, Binding::Empty => 1, Binding::Missing(_) => 1, Binding::Nested(it) => count(it.iter()), }) .sum() } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Create a new document from the raw parts.<CODESPLIT>pub fn from_parts(title: impl Into<String>, body: impl Into<String>) -> Self { Self { title: title.into(), body: body.into(), summary: None, created_at: None, updated_at: None, } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `fee` (0xddca3f43) function<CODESPLIT>pub fn fee(&self) -> ::ethers::contract::builders::ContractCall<M, u128> { self.0 .method_hash([221, 202, 63, 67], ()) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Checks if an application is installed and available in the system PATH. Returns `true` if the application is found in PATH, `false` otherwise.<CODESPLIT>fn is_app_installed(app_name: &str) -> bool { #[cfg(target_os = "windows")] { std::process::Command::new("where") .arg(app_name) .output() .map(|output| output.status.success()) .unwrap_or(false) } #[cfg(any(target_os = "macos", target_os = "linux"))] { std::process::Command::new("which") .arg(app_name) .output() .map(|output| output.status.success()) .unwrap_or(false) } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Set the gid lines in the worksheet to visible (`true`) or hidden (`false`)<CODESPLIT>pub fn set_show_grid_lines(&mut self, sheet: u32, show_grid_lines: bool) -> Result<(), String> { let old_value = self.model.workbook.worksheet(sheet)?.show_grid_lines; self.model.set_show_grid_lines(sheet, show_grid_lines)?; self.push_diff_list(vec![Diff::SetShowGridLines { sheet, new_value: show_grid_lines, old_value, }]); Ok(()) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT># Safety Caller must ensure the attribute type `n` matches type `T`.<CODESPLIT>unsafe fn set_attribute<T>(&mut self, n: u32, val: T) { let ptr = unsafe { AlpcGetMessageAttribute(&mut self.header, n).cast::<T>() }; let ptr = NonNull::new(ptr).unwrap().as_ptr(); unsafe { ptr.write(val) }; self.header.ValidAttributes |= n; }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>The same as `reserve_exact`, but returns on errors instead of panicking or aborting.<CODESPLIT>pub fn try_reserve_exact( &mut self, len: usize, additional: usize, ) -> Result<(), TryReserveError> { self.inner.try_reserve_exact(len, additional, T::LAYOUT) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `getOrderStatus` (0x46423aa7) function<CODESPLIT>pub fn get_order_status( &self, order_hash: [u8; 32], ) -> ::ethers::contract::builders::ContractCall< M, (bool, bool, ::ethers::core::types::U256, ::ethers::core::types::U256), > { self.0 .method_hash([70, 66, 58, 167], order_hash) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Verifies that a buffer of bytes contains a `FunctionCall` and returns it. Note that verification is still experimental and may not catch every error, or be maximally performant. For the previous, unchecked, behavior use `root_as_function_call_unchecked`.<CODESPLIT>pub fn root_as_function_call(buf: &[u8]) -> Result<FunctionCall, flatbuffers::InvalidFlatbuffer> { flatbuffers::root::<FunctionCall>(buf) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>rustfmt-indent_style: Visual<CODESPLIT>fn main() { something.aaaaaaaaaaaa() .aaaaaaaaaaaa() .aaaaaaaaaaaa() .aaaaaaaaaaaa() .aaaaaaaaaaaa() .aaaaaaaaaaaa() .aaaaaaaaaaaa() .bench_function(|| { let x = hello(); }); something.aaaaaaaaaaaa() .aaaaaaaaaaaa() .aaaaaaaaaaaa() .aaaaaaaaaaaa() .aaaaaaaaaaaa() .aaaaaaaaaaaa() .aaaaaaaaaaaa() .bench_function(arg, || { let x = hello(); }); something.aaaaaaaaaaaa() .aaaaaaaaaaaa() .aaaaaaaaaaaa() .aaaaaaaaaaaa() .aaaaaaaaaaaa() .aaaaaaaaaaaa() .aaaaaaaaaaaa() .bench_function(arg, || { let x = hello(); }, arg); AAAAAAAAAAA.function(|| { let _ = (); }); AAAAAAAAAAA.chain().function(|| { let _ = (); }) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Relaunches all currently open widgets.<CODESPLIT>pub async fn relaunch_all(&self) -> anyhow::Result<()> { let widget_ids = { self.widget_states.lock().await.keys().cloned().collect() }; self.relaunch_by_ids(&widget_ids).await }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Defines `name` in namespace `ns` of module `parent` to be `def` if it is not yet defined; otherwise, reports an error.<CODESPLIT>pub(crate) fn define<T>(&mut self, parent: Module<'ra>, ident: Ident, ns: Namespace, def: T) where T: ToNameBinding<'ra>, { let binding = def.to_name_binding(self.arenas); let key = self.new_disambiguated_key(ident, ns); if let Err(old_binding) = self.try_define(parent, key, binding, false) { self.report_conflict(parent, ident, ns, old_binding, binding); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `changeDelta` (0x6809f664) function<CODESPLIT>pub fn change_delta( &self, new_delta: u128, ) -> ::ethers::contract::builders::ContractCall<M, ()> { self.0 .method_hash([104, 9, 246, 100], new_delta) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Checks if two slices are equal as per `eq_fn`.<CODESPLIT>pub fn over<X>(left: &[X], right: &[X], mut eq_fn: impl FnMut(&X, &X) -> bool) -> bool { left.len() == right.len() && left.iter().zip(right).all(|(x, y)| eq_fn(x, y)) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>returning `y` requires that `'b: 'a`, but it's not known to be true<CODESPLIT>fn missing_subset<'a, 'b>(x: &'a u32, y: &'b u32) -> &'a u32 { y }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `getAssetRecipient` (0x79eac6c2) function<CODESPLIT>pub fn get_asset_recipient( &self, ) -> ::ethers::contract::builders::ContractCall< M, ::ethers::core::types::Address, > { self.0 .method_hash([121, 234, 198, 194], ()) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Add a header to the response. Header name is lowercased automatically. The value is set as-is. # Example ``` use rwf::http::Response; let response = Response::new() .text("don't cache me") .header("Cache-Control", "no-cache"); ```<CODESPLIT>pub fn header(mut self, name: impl ToString, value: impl ToString) -> Self { self.headers.insert(name.to_string(), value.to_string()); self }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Callee knows that: 'x: 'a 'y: 'b so the only way we can ensure that `'x: 'y` is to show that `'a: 'static`.<CODESPLIT>fn establish_relationships<'a, 'b, F>(_cell_a: &Cell<&'a u32>, _cell_b: &Cell<&'b u32>, _closure: F) where F: for<'x, 'y> FnMut( &Cell<&'a &'x u32>, &Cell<&'b &'y u32>, &Cell<&'x u32>, &Cell<&'y u32>, ), { }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `factory` (0xc45a0155) function<CODESPLIT>pub fn factory( &self, ) -> ::ethers::contract::builders::ContractCall< M, ::ethers::core::types::Address, > { self.0 .method_hash([196, 90, 1, 85], ()) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>create a tool prompt from a chat completion request message.<CODESPLIT>fn append_tool_message( &self, chat_history: impl AsRef<str>, message: &ChatCompletionToolMessage, ) -> String { format!( "{chat_history}<|start_header_id|>ipython<|end_header_id|>\n\n{tool_message}<|eot_id|>", chat_history = chat_history.as_ref().trim(), tool_message = message.content().trim(), ) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Visits the expression and returns its data type.<CODESPLIT>fn visit_expr(&mut self, expr: &Expression) -> ConversionResult<ColumnType> { match expr { Expression::Wildcard => Ok(ColumnType::BigInt), Expression::Literal(literal) => self.visit_literal(literal), Expression::Column(_) => self.visit_column_expr(expr), Expression::Unary { op, expr } => self.visit_unary_expr((*op).into(), expr), Expression::Binary { op, left, right } => { self.visit_binary_expr(&(*op).into(), left, right) } Expression::Aggregation { op, expr } => self.visit_agg_expr(*op, expr), } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Check that underscore patterns are dropped after the method with self is polled.<CODESPLIT>async fn bar_async(&'a self, x: D, _: D) { x.1.borrow_mut().push(DropOrder::Function); NeverReady.await; }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>rustfmt-control_brace_style: ClosingNextLine<CODESPLIT>fn main() { if false { (); (); } if false { (); (); } let a = if 0 > 1 { unreachable!() } else { 0x0 }; if true { (); } else if false { (); (); } else { (); (); (); } if true { (); } else if false { (); (); } else { (); (); (); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `poolType` (0xb1dd61b6) function<CODESPLIT>pub fn pool_type(&self) -> ::ethers::contract::builders::ContractCall<M, u8> { self.0 .method_hash([177, 221, 97, 182], ()) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Set the maximum size of the stream flow control window. The value should not be greater than the setting `max_connection_window`. The default value is MAX_STREAM_WINDOW (6 MB).<CODESPLIT>pub fn set_max_stream_window(&mut self, v: u64) { self.max_stream_window = cmp::min(v, VINT_MAX); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Non-ZST uninhabited types are, nonetheless, uninhabited.<CODESPLIT>fn yawning_void_struct() { enum Void {} struct YawningVoid(Void, u128); const _: () = { assert!(std::mem::size_of::<YawningVoid>() == std::mem::size_of::<u128>()); assert!(false); }; assert::is_maybe_transmutable::<YawningVoid, u128>(); assert::is_maybe_transmutable::<(), Void>(); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Tries to set the thread handle for the current thread. Fails if a handle was already set or if the thread ID of `thread` would change an already-set ID.<CODESPLIT>pub(crate) fn set_current(thread: Thread) -> Result<(), Thread> { if CURRENT.get() != NONE { return Err(thread); } match id::get() { Some(id) if id == thread.id() => {} None => id::set(thread.id()), _ => return Err(thread), } crate::sys::thread_local::guard::enable(); CURRENT.set(thread.into_raw().cast_mut()); Ok(()) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>If we have only exposed read-only pointers, doing a write through a wildcard ptr should fail.<CODESPLIT>fn main() { let mut x = 0; let _fool = &mut x as *mut i32; let addr = (&x as *const i32).expose_provenance(); let ptr = std::ptr::with_exposed_provenance_mut::<i32>(addr); unsafe { *ptr = 0 }; }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>same as cci_iter_lib, more-or-less, but not marked inline<CODESPLIT>pub fn iter<F>(v: Vec<usize> , mut f: F) where F: FnMut(usize) { let mut i = 0; let n = v.len(); while i < n { f(v[i]); i += 1; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>~^ WARN unnecessary lifetime parameter `'a` ~| WARN lifetime parameter `'b` never used<CODESPLIT>fn static_id_indirect<'a,'b>(t: &'a ()) -> &'static () where 'a: 'b, 'b: 'static { t }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>~^ NOTE `x` dropped here while still borrowed<CODESPLIT>fn is_moved() { let x = vec![1]; let a = display_len(&x); fn mv(_: impl Sized) {} mv(x); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>@error-in-other-file: retag .* for Unique permission .* only grants SharedReadOnly permission<CODESPLIT>fn main() { unsafe { let x = 0u8; let x = core::ptr::addr_of!(x); core::ptr::drop_in_place(x.cast_mut()); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns a builder initialized from host information (via CPUID). Note that this only queries SMT state and the socket size, it does not otherwise affect APIC configuration.<CODESPLIT>pub fn from_host_topology() -> Result<Self, HostTopologyError> { fn cpuid(leaf: u32, sub_leaf: u32) -> [u32; 4] { #[cfg(not(target_arch = "x86_64"))] { let (_, _) = (leaf, sub_leaf); unimplemented!("cannot invoke from_host_topology: host arch is not x86_64"); } #[cfg(target_arch = "x86_64")] { let result = safe_intrinsics::cpuid(leaf, sub_leaf); [result.eax, result.ebx, result.ecx, result.edx] } } Self::from_cpuid(&mut cpuid) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `assetRecipient` (0x3bfa67fe) function<CODESPLIT>pub fn asset_recipient( &self, ) -> ::ethers::contract::builders::ContractCall< M, ::ethers::core::types::Address, > { self.0 .method_hash([59, 250, 103, 254], ()) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>FIXME(eddyb) maybe cache this?<CODESPLIT>fn qualif_local<Q: qualifs::Qualif>(&mut self, local: Local) -> bool { let TempState::Defined { location: loc, .. } = self.temps[local] else { return false; }; let stmt_or_term = self.body.stmt_at(loc); match stmt_or_term { Left(statement) => { let Some((_, rhs)) = statement.kind.as_assign() else { span_bug!(statement.source_info.span, "{:?} is not an assignment", statement) }; qualifs::in_rvalue::<Q, _>(self.ccx, &mut |l| self.qualif_local::<Q>(l), rhs) } Right(terminator) => { assert_matches!(terminator.kind, TerminatorKind::Call { .. }); let return_ty = self.body.local_decls[local].ty; Q::in_any_value_of_ty(self.ccx, return_ty) } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `getSellQuote` (0x6e1a8597) function<CODESPLIT>pub fn get_sell_quote( &self, pool_address: ::ethers::core::types::Address, ) -> ::ethers::contract::builders::ContractCall<M, SellQuote> { self.0 .method_hash([110, 26, 133, 151], pool_address) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Parse a file with `Key: value` entries such as WHEEL and METADATA<CODESPLIT>fn parse_key_value_file( file: impl Read, debug_filename: &str, ) -> miette::Result<HashMap<String, Vec<String>>> { let mut data: HashMap<String, Vec<String>> = HashMap::default(); let file = BufReader::new(file); for (line_no, line) in file.lines().enumerate() { let line = line.into_diagnostic()?.trim().to_string(); if line.is_empty() { continue; } let (key, value) = line.split_once(':').ok_or_else(|| { miette::miette!( "Line {} of the {debug_filename} file is invalid", line_no + 1 ) })?; data.entry(key.trim().to_string()) .or_default() .push(value.trim().to_string()); } Ok(data) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>EMIT_MIR lower_intrinsics.non_const.LowerIntrinsics.diff<CODESPLIT>pub fn non_const<T>() -> usize { let size_of_t = core::intrinsics::size_of::<T>; size_of_t() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Move filter between VTL2 VF vport and VTL0 VF vport<CODESPLIT>pub async fn move_filter(&self, direction_to_vtl0: u8) -> anyhow::Result<()> { if let Some(to_vtl0) = self.vport_state.get_direction_to_vtl0() { if to_vtl0 == (direction_to_vtl0 == 1) { return Ok(()); } } let mut gdma = self.inner.gdma.lock().await; let hwc_activity_id = BnicDriver::new(&mut *gdma, self.inner.dev_id) .move_vport_filter(self.config.vport, direction_to_vtl0) .await?; self.vport_state .set_direction_to_vtl0(direction_to_vtl0 == 1); tracing::info!( mac_address = %self.mac_address(), direction_to_vtl0, hwc_activity_id, "switch data path for mac", ); Ok(()) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>FIXME: This can be simplified to `Copy`. EMIT_MIR gvn_copy_aggregate.all_copy_use_changed_2.GVN.diff<CODESPLIT>fn all_copy_use_changed_2(v: &mut AllCopy) -> AllCopy { let mut a = v.a; let b = v.b; let c = v.c; v.a = 1; a = v.a; AllCopy { a, b, c } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Constructs a new instance of [`State`].<CODESPLIT>pub fn new(analyzer: Analyzer<'a>, accent_color: Option<Color>) -> Result<Self> { let mut state = Self { running: true, tab: Tab::default(), info_index: 0, block_index: 2, list: SelectableList::default(), analyzer, show_heh: false, show_details: false, input: Input::default(), input_mode: false, strings_loaded: false, system_calls_loaded: false, dynamic_scroll_index: 0, general_scroll_index: 0, notes_scroll_index: 0, headers_scroll_index: 0, accent_color: accent_color.unwrap_or(Color::White), logo: Logo::default(), }; state.handle_tab()?; Ok(state) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Unsafely asserts to the compiler the static information that the handle's node is a `Leaf`.<CODESPLIT>pub unsafe fn cast_to_leaf_unchecked( self, ) -> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, Type> { let node = unsafe { self.node.cast_to_leaf_unchecked() }; Handle { node, idx: self.idx, _marker: PhantomData } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns a future that will resolve to the solved repodata records for the given environment or `None` if no task was spawned to instantiate the prefix.<CODESPLIT>pub(crate) fn get_conda_prefix( &self, environment: &GroupedEnvironment<'p>, ) -> Option<impl Future<Output = (Prefix, PythonStatus)>> { let cell = self.instantiated_conda_prefixes.get(environment)?.clone(); Some(async move { cell.wait().await.clone() }) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Iterate over each varying bit for the absolute values and the sign bit if it varies<CODESPLIT>pub fn for_each_varying_bit<F>(&self, mut f: F) where F: FnMut(usize, usize), { for i in 0..4 { let bitset = self.vary_mask[i]; for pos in BitIter::from(bitset) { f(i, pos); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Same as `implements_trait` but allows using a `ParamEnv` different from the lint context. The `callee_id` argument is used to determine whether this is a function call in a `const fn` environment, used for checking const traits.<CODESPLIT>pub fn implements_trait_with_env<'tcx>( tcx: TyCtxt<'tcx>, typing_env: ty::TypingEnv<'tcx>, ty: Ty<'tcx>, trait_id: DefId, callee_id: Option<DefId>, args: &[GenericArg<'tcx>], ) -> bool { implements_trait_with_env_from_iter(tcx, typing_env, ty, trait_id, callee_id, args.iter().map(|&x| Some(x))) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Either get a previously existing entry, or create a new one if it is not yet present.<CODESPLIT>pub fn get_or_insert(&mut self, key: K) -> UniIndex { self.get(&key).unwrap_or_else(|| self.insert(key)) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Number of implicit inputs -- notably the "environment" parameter for closures -- that appear in MIR but not in the user's code.<CODESPLIT>pub(crate) fn implicit_inputs(self) -> usize { match self { DefiningTy::Closure(..) | DefiningTy::CoroutineClosure(..) | DefiningTy::Coroutine(..) => 1, DefiningTy::FnDef(..) | DefiningTy::Const(..) | DefiningTy::InlineConst(..) => 0, } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>This method manipulates left and right such that right[i] = left[i] * p and left[i] = left[i] * (1 - p)<CODESPLIT>fn compute_evaluation_vector_impl<F>(left: &mut [F], right: &mut [F], p: F) where F: One + Sub<Output = F> + MulAssign + SubAssign + Mul<Output = F> + Send + Sync + Copy, { let k = cmp::min(left.len(), right.len()); let one_minus_p = F::one() - p; if_rayon!( left.par_iter_mut().with_min_len(MIN_PARALLEL_LEN), left.iter_mut() ) .zip(right) .for_each(|(li, ri)| { *ri = *li * p; *li -= *ri; }); if_rayon!( left[k..].par_iter_mut().with_min_len(MIN_PARALLEL_LEN), left[k..].iter_mut() ) .for_each(|li| { *li *= one_minus_p; }); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Get a name from current module scope, legacy macros are not included<CODESPLIT>pub(crate) fn get(&self, name: &Name) -> PerNs { PerNs { types: self.types.get(name).copied(), values: self.values.get(name).copied(), macros: self.macros.get(name).copied(), } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Tree Borrows has no issue with several mutable references existing at the same time, as long as they are used only immutably. I.e. multiple Reserved can coexist.<CODESPLIT>pub fn aliasing_read_only_mutable_refs() { unsafe { let base = &mut 42u64; let r1 = &mut *(base as *mut u64); let r2 = &mut *(base as *mut u64); let _l = *r1; let _l = *r2; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Allows a retention validator to be explicitly passed in<CODESPLIT>pub async fn previous_revisions_with_validator( &self, ids: BTreeSet<(InternalDocumentId, Timestamp)>, retention_validator: Arc<dyn RetentionValidator>, ) -> anyhow::Result< BTreeMap<(InternalDocumentId, Timestamp), (Timestamp, Option<ResolvedDocument>)>, > { for (_, ts) in &ids { anyhow::ensure!(*ts <= self.upper_bound.succ()?); } self.reader .previous_revisions(ids, retention_validator.clone()) .await }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>create a tool prompt from a chat completion request message.<CODESPLIT>fn append_tool_message( &self, chat_history: impl AsRef<str>, message: &ChatCompletionToolMessage, ) -> String { format!( "{chat_history}\n<|im_start|>environment name=<|plugin|>\n{tool_message}<|im_end|>", chat_history = chat_history.as_ref().trim(), tool_message = message.content().trim(), ) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Dispatches a latency-sensitive request onto the thread pool. When the VFS is marked not ready this will return a default constructed [`R::Result`].<CODESPLIT>pub(crate) fn on_latency_sensitive<const ALLOW_RETRYING: bool, R>( &mut self, f: fn(GlobalStateSnapshot, R::Params) -> anyhow::Result<R::Result>, ) -> &mut Self where R: lsp_types::request::Request< Params: DeserializeOwned + panic::UnwindSafe + Send + fmt::Debug, Result: Serialize + Default, > + 'static, { if !self.global_state.vfs_done { if let Some(lsp_server::Request { id, .. }) = self.req.take_if(|it| it.method == R::METHOD) { self.global_state.respond(lsp_server::Response::new_ok(id, R::Result::default())); } return self; } self.on_with_thread_intent::<true, ALLOW_RETRYING, R>( ThreadIntent::LatencySensitive, f, Self::content_modified_error, ) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `getCounter` (0xf07ec373) function<CODESPLIT>pub fn get_counter( &self, offerer: ::ethers::core::types::Address, ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::U256> { self.0 .method_hash([240, 126, 195, 115], offerer) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Sends the datagram in `bufs`.<CODESPLIT>fn send_vectored<'a>(&'a mut self, bufs: &'a [IoSlice<'a>]) -> SendVectored<'a, Self> { SendVectored { send: self, bufs } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Assist: generate_enum_variant Adds a variant to an enum. ``` enum Countries { Ghana, } fn main() { let country = Countries::Lesotho$0; } ``` -> ``` enum Countries { Ghana, Lesotho, } fn main() { let country = Countries::Lesotho; } ```<CODESPLIT>pub(crate) fn generate_enum_variant(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> { let path: ast::Path = ctx.find_node_at_offset()?; let parent = path_parent(&path)?; if ctx.sema.resolve_path(&path).is_some() { // No need to generate anything if the path resolves return None; } let name_ref = path.segment()?.name_ref()?; if name_ref.text().starts_with(char::is_lowercase) { // Don't suggest generating variant if the name starts with a lowercase letter return None; } if let Some(hir::PathResolution::Def(hir::ModuleDef::Adt(hir::Adt::Enum(e)))) = ctx.sema.resolve_path(&path.qualifier()?) { let target = path.syntax().text_range(); return add_variant_to_accumulator(acc, ctx, target, e, &name_ref, parent); } None }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Format the exception when it is or will be nested inside of another RedactedJsError In particular we don't want to print 'Server Error' or the request id multiple times in the same stack trace.<CODESPLIT>pub fn nested_to_string(&self) -> String { if self.block_logging { "Server Error".to_string() } else { format!("{}", self.error) } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Verify that jump threading succeeds seeing through copies of aggregates.<CODESPLIT>fn aggregate_copy() -> u32 { const Foo: (u32, u32) = (5, 3); let a = Foo; let b = a; let c = b.1; if c == 2 { b.0 } else { 13 } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>@ revisions: edition2021 edition2024 @ [edition2024] compile-flags: -Zunstable-options @ [edition2024] edition: 2024 @ [edition2021] check-pass<CODESPLIT>fn why_would_you_do_this() -> bool { let mut x = None; x.replace(std::cell::RefCell::new(123).borrow()).is_some() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>convert block-derived data to dataframe<CODESPLIT>async fn transform_channel( mut receiver: mpsc::Receiver<R<Self::Response>>, query: &Arc<Query>, ) -> R<Self> { let mut columns = Self::default(); while let Some(message) = receiver.recv().await { match message { Ok(message) => Self::transform(message, &mut columns, query)?, Err(e) => return Err(e), } } Ok(columns) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Construct a new [`ColumnCommitmentMetadata`]. Will error if the supplied metadata are invalid. i.e., if The Bounds variant and column type do not match.<CODESPLIT>pub fn try_new( column_type: ColumnType, bounds: ColumnBounds, ) -> Result<ColumnCommitmentMetadata, InvalidColumnCommitmentMetadata> { match (column_type, bounds) { (ColumnType::TinyInt, ColumnBounds::TinyInt(_)) | (ColumnType::SmallInt, ColumnBounds::SmallInt(_)) | (ColumnType::Int, ColumnBounds::Int(_)) | (ColumnType::BigInt, ColumnBounds::BigInt(_)) | (ColumnType::Int128, ColumnBounds::Int128(_)) | (ColumnType::TimestampTZ(_, _), ColumnBounds::TimestampTZ(_)) | ( ColumnType::Boolean | ColumnType::VarChar | ColumnType::Scalar | ColumnType::Decimal75(..), ColumnBounds::NoOrder, ) => Ok(ColumnCommitmentMetadata { column_type, bounds, }), _ => Err(InvalidColumnCommitmentMetadata::TypeBoundsMismatch { column_type, column_bounds: bounds, }), } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>EMIT_MIR gvn_copy_aggregate.all_copy.GVN.diff<CODESPLIT>fn all_copy(v: &AllCopy) -> AllCopy { let a = v.a; let b = v.b; let c = v.c; AllCopy { a, b, c } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Shouldn't lint `binding to `_` prefixed variable with no side-effect`<CODESPLIT>async fn foo(_i: u64) { let _a = 0; let _b = num(); let _ = async { let _c = 0; let _d = num(); } .await; }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns the [`Gateway`] used by this project.<CODESPLIT>fn repodata_gateway(&self) -> &Gateway { self.repodata_gateway.get_or_init(|| { Self::repodata_gateway_init( self.authenticated_client().clone(), self.config().clone().into(), ) }) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>This lists the fields of a variant along with their types.<CODESPLIT>fn list_variant_fields<'a>( &'a self, ty: &'a Ty, variant: VariantId, ) -> impl Iterator<Item = (LocalFieldId, Ty)> + Captures<'a> + Captures<'db> { let (_, substs) = ty.as_adt().unwrap(); let field_tys = self.db.field_types(variant); let fields_len = variant.variant_data(self.db.upcast()).fields().len() as u32; (0..fields_len).map(|idx| LocalFieldId::from_raw(idx.into())).map(move |fid| { let ty = field_tys[fid].clone().substitute(Interner, substs); let ty = normalize(self.db, self.db.trait_environment_for_body(self.body), ty); (fid, ty) }) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>rustfmt-match_arm_blocks: false rustfmt-match_block_trailing_comma: true Match expressions, no unwrapping of block arms or wrapping of multiline expressions.<CODESPLIT>fn foo() { match x { a => { "line1"; "line2" }, b => ( aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa, bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb, ), } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>rustfmt-max_width: 80<CODESPLIT>fn foo() { polyfill::slice::fill( &mut self.pending[padding_pos..(self.algorithm.block_len - 8)], 0, ); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Tries to pop a value out of the queue. If the queue was empty it returns [`None`] otherwise the value packed inside the Option.<CODESPLIT>pub fn try_pop(&self) -> Option<T> { match self.used_slots.try_wait().unwrap() { true => self.pop(), false => None, } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `totalSupply` (0x18160ddd) function<CODESPLIT>pub fn total_supply( &self, ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::U256> { self.0 .method_hash([24, 22, 13, 221], ()) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns the value of the first `doc_hint` attribute in the given slice or `None` if `doc_hint` attribute is not available.<CODESPLIT>pub fn find_doc_hint(attrs: &[syn::Attribute]) -> Option<String> { attrs.iter().filter_map(doc_hint).next() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Creates a new [`LazySingleton`] where the underlying value is not yet initialized.<CODESPLIT>pub const fn new() -> Self { Self { data: UnsafeCell::new(None), is_initialized: IoxAtomicBool::new(false), is_finalized: IoxAtomicBool::new(false), } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Warns against some misuses of `#[must_use]`<CODESPLIT>fn check_must_use(&self, hir_id: HirId, attr: &Attribute, target: Target) { if !matches!( target, Target::Fn | Target::Enum | Target::Struct | Target::Union | Target::Method(_) | Target::ForeignFn | Target::Trait ) { let article = match target { Target::ExternCrate | Target::Enum | Target::Impl | Target::Expression | Target::Arm | Target::AssocConst | Target::AssocTy => "an", _ => "a", }; self.tcx.emit_node_span_lint( UNUSED_ATTRIBUTES, hir_id, attr.span, errors::MustUseNoEffect { article, target }, ); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns an iterator over all block expressions in this body that define inner items.<CODESPLIT>pub fn blocks<'a>( &'a self, db: &'a dyn DefDatabase, ) -> impl Iterator<Item = (BlockId, Arc<DefMap>)> + 'a { self.block_scopes.iter().map(move |&block| (block, db.block_def_map(block))) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Constructs a new executable task from a task graph node.<CODESPLIT>pub fn from_task_graph(task_graph: &TaskGraph<'p>, task_id: TaskId) -> Self { let node = &task_graph[task_id]; Self { project: task_graph.project(), name: node.name.clone(), task: node.task.clone(), run_environment: node.run_environment.clone(), additional_args: node.additional_args.clone(), } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>replace with `NonZeroUsize::new(n).unwrap()` once `unwrap()` is const stabilized<CODESPLIT>pub(crate) const fn create_dim(n: usize) -> NonZeroUsize { match NonZeroUsize::new(n) { None => panic!("dim must not be 0"), Some(n) => n, } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns the combined dependencies to install for this collection. The `build` dependencies overwrite the `host` dependencies which overwrite the `run` dependencies. The dependencies of all features are combined. This means that if two features define a requirement for the same package that both requirements are returned. The different requirements per package are sorted in the same order as the features they came from. If the `platform` is `None` no platform specific dependencies are taken into consideration.<CODESPLIT>fn combined_dependencies(&self, platform: Option<Platform>) -> CondaDependencies { self.features() .filter_map(|f| f.combined_dependencies(platform)) .into() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Splits a unique reference into a pair of leaf edges delimiting the full range of the tree. The results are non-unique references allowing massively destructive mutation, so must be used with the utmost care.<CODESPLIT>pub fn full_range(self) -> LazyLeafRange<marker::Dying, K, V> { let self2 = unsafe { ptr::read(&self) }; full_range(self, self2) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Methods that are unstable const should not be suggested within a const context, see issue #5697. However, in Rust 1.48.0 the methods `is_some` and `is_none` of `Option` were stabilized as const, so the following should be linted.<CODESPLIT>const fn issue6067() { if let Some(_) = Some(42) {} if let None = None::<()> {} while let Some(_) = Some(42) {} while let None = None::<()> {} match Some(42) { Some(_) => true, None => false, }; match None::<()> { Some(_) => false, None => true, }; }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Checks if `code` matches the search pattern found in `search_scope`, returning information about the match, if it does. Since we only do matching in this module and searching is done by the parent module, we don't populate nested matches.<CODESPLIT>pub(crate) fn get_match( debug_active: bool, rule: &ResolvedRule, code: &SyntaxNode, restrict_range: &Option<FileRange>, sema: &Semantics<'_, ide_db::RootDatabase>, ) -> Result<Match, MatchFailed> { record_match_fails_reasons_scope(debug_active, || { Matcher::try_match(rule, code, restrict_range, sema) }) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Apply the select transformation to the given `OwnedTable`.<CODESPLIT>fn apply(&self, owned_table: OwnedTable<S>) -> PostprocessingResult<OwnedTable<S>> { let cols: IndexMap<Identifier, OwnedColumn<S>> = self .aliased_result_exprs .iter() .map( |aliased_result_expr| -> PostprocessingResult<(Identifier, OwnedColumn<S>)> { let result_column = owned_table.evaluate(&aliased_result_expr.expr)?; Ok((aliased_result_expr.alias, result_column)) }, ) .collect::<PostprocessingResult<_>>()?; Ok(OwnedTable::try_new(cols)?) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Replaces the universe of this canonical variable with `ui`. In case this is a float or int variable, this causes an ICE if the updated universe is not the root.<CODESPLIT>pub fn with_updated_universe(self, ui: UniverseIndex) -> CanonicalVarKind<I> { match self { CanonicalVarKind::Ty(CanonicalTyVarKind::General(_)) => { CanonicalVarKind::Ty(CanonicalTyVarKind::General(ui)) } CanonicalVarKind::Region(_) => CanonicalVarKind::Region(ui), CanonicalVarKind::Const(_) => CanonicalVarKind::Const(ui), CanonicalVarKind::PlaceholderTy(placeholder) => { CanonicalVarKind::PlaceholderTy(placeholder.with_updated_universe(ui)) } CanonicalVarKind::PlaceholderRegion(placeholder) => { CanonicalVarKind::PlaceholderRegion(placeholder.with_updated_universe(ui)) } CanonicalVarKind::PlaceholderConst(placeholder) => { CanonicalVarKind::PlaceholderConst(placeholder.with_updated_universe(ui)) } CanonicalVarKind::Ty(CanonicalTyVarKind::Int | CanonicalTyVarKind::Float) => { assert_eq!(ui, UniverseIndex::ROOT); self } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Checks that an attribute is used at the crate level. Returns `true` if valid.<CODESPLIT>fn check_attr_crate_level( &self, attr: &Attribute, meta: &MetaItemInner, hir_id: HirId, ) -> bool { if hir_id != CRATE_HIR_ID { let bang_span = attr.span.lo() + BytePos(1); let sugg = (attr.style == AttrStyle::Outer && self.tcx.hir().get_parent_item(hir_id) == CRATE_OWNER_ID) .then_some(errors::AttrCrateLevelOnlySugg { attr: attr.span.with_lo(bang_span).with_hi(bang_span), }); self.tcx.emit_node_span_lint( INVALID_DOC_ATTRIBUTES, hir_id, meta.span(), errors::AttrCrateLevelOnly { sugg }, ); return false; } true }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Client send a new request with default headers. Return stream_id and the headers list on success.<CODESPLIT>pub fn send_request(&mut self, fin: bool) -> Result<(u64, Vec<Header>)> { let req_headers = Session::default_request_headers(); let stream_id = self.client.stream_new(&mut self.pair.client)?; self.client .send_headers(&mut self.pair.client, stream_id, &req_headers, fin)?; self.move_forward().ok(); Ok((stream_id, req_headers)) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Parse a `Value` from a sort key.<CODESPLIT>pub fn read_sort_key<R: Read>(reader: &mut R) -> anyhow::Result<Self> { Self::_read_sort_key(&mut BytePeeker::new(reader)) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Make sure that creating a raw ptr next to a shared ref works but the shared ref still gets invalidated when the raw ptr is used for writing.<CODESPLIT>fn main() { unsafe { use std::mem; let x = &mut 0; let y1: &i32 = mem::transmute(&*x); let y2 = x as *mut _; let _val = *y2; let _val = *y1; *y2 += 1; let _fail = *y1; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>EMIT_MIR mem_replace.manual_replace.PreCodegen.after.mir<CODESPLIT>pub fn manual_replace(r: &mut u32, v: u32) -> u32 { let temp = *r; *r = v; temp }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Return an error if the file is already open.<CODESPLIT>fn check_not_open(&self) -> lx::Result<()> { if self.file.is_some() { return Err(lx::Error::EINVAL); } Ok(()) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Get the value at this index mutably, if it exists.<CODESPLIT>pub fn get_mut(&mut self, idx: UniIndex) -> Option<&mut V> { self.data.get_mut(idx.idx as usize).and_then(Option::as_mut) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Gets the contract's `SpotPriceUpdate` event<CODESPLIT>pub fn spot_price_update_filter( &self, ) -> ::ethers::contract::builders::Event< ::std::sync::Arc<M>, M, SpotPriceUpdateFilter, > { self.0.event() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>EMIT_MIR lower_intrinsics.unchecked.LowerIntrinsics.diff<CODESPLIT>pub unsafe fn unchecked(a: i32, b: i32, c: u32) { let _a = core::intrinsics::unchecked_add(a, b); let _b = core::intrinsics::unchecked_sub(a, b); let _c = core::intrinsics::unchecked_mul(a, b); let _x = core::intrinsics::unchecked_div(a, b); let _y = core::intrinsics::unchecked_rem(a, b); let _i = core::intrinsics::unchecked_shl(a, b); let _j = core::intrinsics::unchecked_shr(a, b); let _k = core::intrinsics::unchecked_shl(a, c); let _l = core::intrinsics::unchecked_shr(a, c); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Assuming the hidden type is `[&'?15 u8; 1]`, we have two distinct member constraints: - '?15 member ['static, 'a, 'b] from outer impl-trait - '?15 member ['static, 'a, 'b] from inner impl-trait To satisfy both we can choose 'a or 'b, so it's a failure due to ambiguity.<CODESPLIT>fn fail_early_bound<'s, 'a, 'b>(a: &'s u8) -> impl IntoIterator<Item = impl Cap<'a> + Cap<'b>> where 's: 'a, 's: 'b, { [a] }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Used for on-demand inspect calls.<CODESPLIT>pub fn inspect_proc(req: Request<'_>) { req.respond() .sensitivity_child("meminfo", SensitivityLevel::Safe, inspect_meminfo) .sensitivity_child("interrupts", SensitivityLevel::Safe, inspect_interrupts) .sensitivity_child("processes", SensitivityLevel::Safe, inspect_userspace_procs); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>~^ NOTE: in Rust 2018, `tup` is dropped here, but in Rust 2021, only `tup.0` will be dropped here as part of the closure<CODESPLIT>fn main() { test1_all_need_migration(); test2_only_precise_paths_need_migration(); test3_only_by_value_need_migration(); test4_type_contains_drop_need_migration(); test5_drop_non_drop_aggregate_need_migration(); test6_significant_insignificant_drop_aggregate_need_migration(); test7_move_closures_non_copy_types_might_need_migration(); test8_drop_order_and_blocks(); test9_drop_order_and_nested_closures(); test10_vec_of_significant_drop_type(); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>create a tool prompt from a chat completion request message.<CODESPLIT>fn append_tool_message( &self, chat_history: impl AsRef<str>, message: &ChatCompletionToolMessage, ) -> String { format!( "{chat_history}\n<|im_start|>tool\n<tool_response>\n{tool_message}\n</tool_response>\n<|im_end|>", chat_history = chat_history.as_ref().trim(), tool_message = message.content().trim(), ) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Sanity check for the dirty-clean system. We add #[rustc_clean] attributes in places that are not checked and make sure that this causes an error.<CODESPLIT>fn main() { #[rustc_clean(except="hir_owner", cfg="cfail2")] { } #[rustc_clean(cfg="cfail2")] { } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Creates a new logger that uses the given framebuffer.<CODESPLIT>pub fn new(framebuffer: &'static mut [u8], info: FrameBufferInfo) -> Self { let mut logger = Self { framebuffer, info, x_pos: 0, y_pos: 0, level: 0, }; logger.clear(); logger }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Add options making relocation sections in the produced ELF files read-only and suppressing lazy binding.<CODESPLIT>fn add_relro_args(cmd: &mut dyn Linker, sess: &Session) { match sess.opts.cg.relro_level.unwrap_or(sess.target.relro_level) { RelroLevel::Full => cmd.full_relro(), RelroLevel::Partial => cmd.partial_relro(), RelroLevel::Off => cmd.no_relro(), RelroLevel::None => {} } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Replace the parts of the zsh completion script that need different functionality.<CODESPLIT>fn replace_zsh_completion(script: &str) -> Cow<str> { let pattern = r"(?ms)(\(run\))(?:.*?)(_arguments.*?)(\*::task)"; let replacement = r#"$1 local tasks tasks=("$${(@s/ /)$$(pixi task list --machine-readable 2> /dev/null)}") if [[ -n "$$tasks" ]]; then _values 'task' "$${tasks[@]}" else return 1 fi $2::task"#; let re = Regex::new(pattern).unwrap(); re.replace(script, replacement) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>lint not just `return None`, but also `return None;` (note the semicolon)<CODESPLIT>fn issue11993(y: Option<i32>) -> Option<i32> { let Some(x) = y else { return None; }; let Some(x) = y else { todo!(); return None; }; let Some(x) = y else { return None; }; None }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>* use rust_embed::RustEmbed; #[derive(RustEmbed)] #[folder = "target rnacos-web"] struct Asset; *<CODESPLIT>fn handle_embedded_file(path: &str) -> HttpResponse { match get_embedded_file(path) { Some(content) => HttpResponse::Ok() .content_type(from_path(path).first_or_octet_stream().as_ref()) .body(content.data.into_owned()), None => HttpResponse::NotFound().body("404 Not Found"), } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>@ compile-flags: --force-warn while_true @ compile-flags: --force-warn unused_variables @ compile-flags: --force-warn unused_mut @ check-pass<CODESPLIT>fn expect_early_pass_lint(terminate: bool) { #[expect(while_true)] while !terminate { println!("Do you know what a spin lock is?") } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns the path spec if this instance is a path spec.<CODESPLIT>pub fn into_path(self) -> Option<PinnedPathSpec> { match self { MutablePinnedSourceSpec::Path(spec) => Some(spec), } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Process incoming events, seeing if we can arb new orders, and updating the internal state on new blocks.<CODESPLIT>async fn process_event(&mut self, event: Event) -> Vec<Action> { match event { Event::OpenseaOrder(order) => self .process_order_event(*order) .await .map_or(vec![], |a| vec![a]), Event::NewBlock(block) => match self.process_new_block_event(block).await { Ok(_) => vec![], Err(e) => { panic!("Strategy is out of sync {}", e); } }, } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Dispatches a non-latency-sensitive request onto the thread pool. When the VFS is marked not ready this will return a default constructed [`R::Result`].<CODESPLIT>pub(crate) fn on<const ALLOW_RETRYING: bool, R>( &mut self, f: fn(GlobalStateSnapshot, R::Params) -> anyhow::Result<R::Result>, ) -> &mut Self where R: lsp_types::request::Request< Params: DeserializeOwned + panic::UnwindSafe + Send + fmt::Debug, Result: Serialize + Default, > + 'static, { if !self.global_state.vfs_done { if let Some(lsp_server::Request { id, .. }) = self.req.take_if(|it| it.method == R::METHOD) { self.global_state.respond(lsp_server::Response::new_ok(id, R::Result::default())); } return self; } self.on_with_thread_intent::<true, ALLOW_RETRYING, R>( ThreadIntent::Worker, f, Self::content_modified_error, ) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>~^ ERROR: future cannot be sent between threads safely<CODESPLIT>fn main() { let rc = Rc::new([1, 2, 3]); private_future(rc.clone(), &Cell::new(42)); public_future(rc.clone()); let arc = Arc::new([4, 5, 6]); public_send(arc); generic_future(42); generic_future_send(42); let dummy = Dummy { rc }; dummy.public_future(); dummy.public_send(); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>rustfmt-control_brace_style: AlwaysNextLine<CODESPLIT>fn main() { if false { (); (); } if false { (); (); } let a = if 0 > 1 { unreachable!() } else { 0x0 }; if true { (); } else if false { (); (); } else { (); (); (); } if true { (); } else if false { (); (); } else { (); (); (); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>compute stats for Vec of Partition's<CODESPLIT>pub fn meta_chunks_stats(chunks: &[Partition]) -> PartitionStats { chunks .iter() .map(|chunk| chunk.stats()) .fold(PartitionStats { ..Default::default() }, |acc, stats| acc.fold(stats)) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Check that the destructor can be blocked joining another thread.<CODESPLIT>fn check_blocking() { struct JoinCell { value: RefCell<Option<thread::JoinHandle<u8>>>, } impl Drop for JoinCell { fn drop(&mut self) { for _ in 0..10 { thread::yield_now(); } let join_handle = self.value.borrow_mut().take().unwrap(); println!( "Joining: {} (should be before 'Continue main 2').", join_handle.join().unwrap() ); } } thread_local! { static B: JoinCell = JoinCell { value: RefCell::new(None) }; } thread::spawn(|| { B.with(|f| { assert!(f.value.borrow().is_none()); let handle = thread::spawn(|| 7); *f.value.borrow_mut() = Some(handle); }); }) .join() .unwrap(); println!("Continue main 2."); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `name` (0x06fdde03) function<CODESPLIT>pub fn name( &self, ) -> ::ethers::contract::builders::ContractCall<M, ::std::string::String> { self.0 .method_hash([6, 253, 222, 3], ()) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Removes files for a given work product.<CODESPLIT>pub(crate) fn delete_workproduct_files(sess: &Session, work_product: &WorkProduct) { for (_, path) in work_product.saved_files.items().into_sorted_stable_ord() { let path = in_incr_comp_dir_sess(sess, path); if let Err(err) = std_fs::remove_file(&path) { sess.dcx().emit_warn(errors::DeleteWorkProduct { path: &path, err }); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Creates an allocation initialized by the given bytes<CODESPLIT>pub fn from_bytes<'a>( slice: impl Into<Cow<'a, [u8]>>, align: Align, mutability: Mutability, ) -> Self { let bytes = Bytes::from_bytes(slice, align); let size = Size::from_bytes(bytes.len()); Self { bytes, provenance: ProvenanceMap::new(), init_mask: InitMask::new(size, true), align, mutability, extra: (), } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Adds a key-value pair to the end of the node, and returns the mutable reference of the inserted value.<CODESPLIT>pub fn push(&mut self, key: K, val: V) -> *mut V { unsafe { self.push_with_handle(key, val).into_val_mut() } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `changeSpotPrice` (0xd8a1890c) function<CODESPLIT>pub fn change_spot_price( &self, new_spot_price: u128, ) -> ::ethers::contract::builders::ContractCall<M, ()> { self.0 .method_hash([216, 161, 137, 12], new_spot_price) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Read existing configuration of trampoline from the root path.<CODESPLIT>pub async fn from_root_path( root_path: PathBuf, exposed_name: &ExposedName, ) -> miette::Result<Self> { let manifest_path = root_path .join(TRAMPOLINE_CONFIGURATION) .join(exposed_name.to_string() + ".json"); let manifest_str = tokio_fs::read_to_string(manifest_path) .await .into_diagnostic()?; serde_json::from_str(&manifest_str).into_diagnostic() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>rustfmt-max_width: 120 rustfmt-match_arm_blocks: false rustfmt-match_block_trailing_comma: true<CODESPLIT>fn a_very_very_very_very_very_very_very_very_very_very_very_long_function_name() -> i32 { 42 }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>@ignore-target: windows # no libc socketpair on Windows This is temporarily here because blocking on fd is not supported yet. When blocking is eventually supported, this will be moved to pass-dep libc libc-socketpair<CODESPLIT>fn main() { let mut fds = [-1, -1]; let _ = unsafe { libc::socketpair(libc::AF_UNIX, libc::SOCK_STREAM, 0, fds.as_mut_ptr()) }; let arr1: [u8; 212992] = [1; 212992]; let _ = unsafe { libc::write(fds[0], arr1.as_ptr() as *const libc::c_void, 212992) }; let data = "abc".as_bytes().as_ptr(); let _ = unsafe { libc::write(fds[0], data as *const libc::c_void, 3) }; let mut buf: [u8; 3] = [0; 3]; let _res = unsafe { libc::read(fds[1], buf.as_mut_ptr().cast(), buf.len() as libc::size_t) }; }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>FIXME: remove all these methods, they belong to ast::StmtList<CODESPLIT>pub fn statements(&self) -> impl Iterator<Item = ast::Stmt> { self.stmt_list().into_iter().flat_map(|it| it.statements()) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>For each `path` we add each folder component to `folder_segments` and if the file name is `mod.rs` we add it's parent folder to `mod_folders`.<CODESPLIT>fn process_paths_for_mod_files<'a>( path: &'a Path, folder_segments: &mut FxIndexSet<&'a OsStr>, mod_folders: &mut FxHashSet<&'a OsStr>, ) { let mut comp = path.components().rev().peekable(); let _: Option<_> = comp.next(); if path.ends_with("mod.rs") { mod_folders.insert(comp.peek().map(|c| c.as_os_str()).unwrap_or_default()); } let folders = comp.filter_map(|c| if let Component::Normal(s) = c { Some(s) } else { None }); folder_segments.extend(folders); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>C says that passing "invalid" pointers is UB for all string functions. It is unclear whether `(int*)42` is "invalid", but there is no actually a `char` living at that address, so arguably it cannot be a valid pointer. Hence this is UB.<CODESPLIT>fn main() { let ptr = 42 as *const u8; unsafe { libc::memcmp(ptr.cast(), ptr.cast(), 0); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Gets the contract's `Transfer` event<CODESPLIT>pub fn transfer_filter( &self, ) -> ::ethers::contract::builders::Event< ::std::sync::Arc<M>, M, TransferFilter, > { self.0.event() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Constructs a ROM from the specified data.<CODESPLIT>fn build_from_slice(self, data: &[u8]) -> std::io::Result<Rom> { let backing = sparse_mmap::alloc_shared_memory(data.len())?; let mapping = sparse_mmap::SparseMapping::new(data.len())?; mapping.map_file(0, data.len(), &backing, 0, true)?; mapping.write_at(0, data).unwrap(); Ok(Rom { name: self.name, mapper: self.mapper, len: data.len() as u64, backing, }) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Verifies that a buffer of bytes contains a `GuestLogData` and returns it. Note that verification is still experimental and may not catch every error, or be maximally performant. For the previous, unchecked, behavior use `root_as_guest_log_data_unchecked`.<CODESPLIT>pub fn root_as_guest_log_data(buf: &[u8]) -> Result<GuestLogData, flatbuffers::InvalidFlatbuffer> { flatbuffers::root::<GuestLogData>(buf) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Don't break from the loop, to allow for loop unrolling. Should only be used for small Nodes (KEYS <= 16). Ideally, we could express this with feature(generic_const_exprs)<CODESPLIT>fn linear_search_child(&self, byte: u8) -> Option<usize> { let mut idx = None; for i in 0..KEYS { if self.keys[i] == Some(byte) { idx = Some(i); } } idx }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>~^ NOTE required by a bound in `assert_send` ~| NOTE required by this bound in `assert_send` ~| NOTE required by a bound in `assert_send` ~| NOTE required by this bound in `assert_send`<CODESPLIT>fn main() { let x: &*mut () = &std::ptr::null_mut(); let y: &mut *mut () = &mut std::ptr::null_mut(); assert_send(#[coroutine] move || { yield; let _x = x; }); assert_send(#[coroutine] move || { yield; let _y = y; }); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Detect text words in an image. Returns an unordered list of the oriented bounding rectangles of each word found.<CODESPLIT>pub fn detect_words(&self, input: &OcrInput) -> anyhow::Result<Vec<RotatedRect>> { if let Some(detector) = self.detector.as_ref() { detector.detect_words(input.image.view(), self.debug) } else { Err(anyhow!("Detection model not loaded")) } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Issue #118164: recovery path leaving unemitted error behind<CODESPLIT>fn bar() -> String { #[cfg(feature = )] [1, 2, 3].iter().map().collect::<String>() #[attr] }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>XXX-FIXME(vvv): Some packets (e.g. GRE) may have several "ip" layers. We should take the last one, not the first one.<CODESPLIT>pub(crate) fn new(pkt: &Packet) -> Result<Self> { let ttl = if let Some(ip) = pkt.find_proto("ip") { ip.first("ip.ttl")?.parse::<u8>()? } else if let Some(ipv6) = pkt.find_proto("ipv6") { ipv6.first("ipv6.hlim")?.parse::<u8>()? } else { panic!("BUG"); }; Ok(Self(ttl)) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Emit an intermediate note on the given `Diag` if the involved regions are suggestable.<CODESPLIT>pub(crate) fn intermediate_suggestion( &mut self, mbcx: &MirBorrowckCtxt<'_, '_, '_>, errci: &ErrorConstraintInfo<'_>, diag: &mut Diag<'_>, ) { let fr_name = self.region_vid_to_name(mbcx, errci.fr); let outlived_fr_name = self.region_vid_to_name(mbcx, errci.outlived_fr); if let (Some(fr_name), Some(outlived_fr_name)) = (fr_name, outlived_fr_name) && !matches!(outlived_fr_name.source, RegionNameSource::Static) { diag.help(format!( "consider adding the following bound: `{fr_name}: {outlived_fr_name}`", )); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Removes the environment variable `key`.<CODESPLIT>pub fn env_remove<K: AsRef<OsStr>>(&mut self, key: K) -> &mut Self { self.env.insert(key.as_ref().to_owned(), None); self }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>We can't see use the `T::Assoc::This: Copy` bound to prove `T::Assoc: Copy`<CODESPLIT>fn foo<T: Trait>(x: T::Assoc) -> (T::Assoc, T::Assoc) where T::Assoc: Id<This = T::Assoc>, { (x, x) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Handles MessageType::TL_CONNECT_REQUEST, which requests for an hvsocket connection.<CODESPLIT>fn handle_tl_connect_request(&mut self, request: protocol::TlConnectRequest2) { self.notifier.notify_hvsock(&request.into()); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns the topological order of the tasks in the graph. The topological order is the order in which the tasks should be executed to ensure that all dependencies of a task are executed before the task itself.<CODESPLIT>pub fn topological_order(&self) -> Vec<TaskId> { let mut visited = HashSet::new(); let mut order = Vec::new(); for i in 0..self.nodes.len() { visit(TaskId(i), &self.nodes, &mut visited, &mut order); } return order; fn visit( id: TaskId, nodes: &[TaskNode<'_>], visited: &mut HashSet<TaskId>, order: &mut Vec<TaskId>, ) { if !visited.insert(id) { return; } for dependency in nodes[id.0].dependencies.iter() { visit(*dependency, nodes, visited, order); } order.push(id); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Iterates through all the columns set to true in a given row of the matrix.<CODESPLIT>pub fn iter(&self, row: R) -> impl Iterator<Item = C> + '_ { self.row(row).into_iter().flat_map(|r| r.iter()) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Aborts the program with a code and a message. # Safety This function is unsafe because it dereferences a raw pointer.<CODESPLIT>pub unsafe fn abort_with_code_and_message(code: i32, message_ptr: *const c_char) -> ! { let peb_ptr = P_PEB.unwrap(); copy_nonoverlapping( message_ptr, (*peb_ptr).guestPanicContextData.guestPanicContextDataBuffer as *mut c_char, CStr::from_ptr(message_ptr).count_bytes() + 1, ); outb(OutBAction::Abort as u16, code as u8); unreachable!() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>If only the paths are available, create a FileRegistry with empty owners This is *unsafe* if you do not later insert the appropriate owners before get_file_owner is called<CODESPLIT>pub fn new_from_paths(file_paths: Vec<&'a PathBuf>) -> Self { Self { version_count: file_paths.iter().map(|_| 0).collect(), owners: file_paths.iter().map(|_| Vec::new()).collect(), file_paths, } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Multiple arguments should each get their own line.<CODESPLIT>fn do_bar( a: u8, mut b: u8, c: &u8, d: &mut u8, closure: &Fn(i32) -> i32, ) -> i32 { let bar = |x: i32, y: i32| -> i32 { x + y }; bar(a, b) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Here we need something outlived by `'a` *and* outlived by `'b`, but we can only name `'a` and `'b` (and neither suits). So we get an error. Somewhat unfortunate, though, since the caller would have to consider the loans for both `'a` and `'b` alive.<CODESPLIT>fn upper_bounds<'a, 'b>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'a, 'b> { if condition() { a } else { b } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>~^ ERROR unconstrained opaque type<CODESPLIT>fn execute_transaction_fut<'f, F, O>( //~^ ERROR: item does not constrain f: F, ) -> impl FnOnce(&mut dyn Transaction) -> TransactionFuture<'_, O> where F: FnOnce(&mut dyn Transaction) -> TransactionFuture<'_, O> + 'f { f }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Loads a [Workbook] from the bytes of an xlsx file. This is useful, for instance, when bytes are transferred over the network<CODESPLIT>pub fn load_from_xlsx_bytes( bytes: &[u8], name: &str, locale: &str, tz: &str, ) -> Result<Workbook, XlsxError> { let cursor = Cursor::new(bytes); let reader = BufReader::new(cursor); load_xlsx_from_reader(name.to_string(), reader, locale, tz) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Applies the Poseidon2 compression to the given array. Reference: [p3_symmetric::TruncatedPermutation]<CODESPLIT>pub fn poseidon2_compress_x( &mut self, result: &mut Array<C, Felt<C::F>>, left: &Array<C, Felt<C::F>>, right: &Array<C, Felt<C::F>>, ) { self.push_op(DslIr::Poseidon2CompressBabyBear(Box::new(( result.clone(), left.clone(), right.clone(), )))); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>same as above but there is a late-bound lifetime named `'b`.<CODESPLIT>async fn bar2<'b>(_dummy: &'a u8, arg: A, lt: Inv<'_>) { check_bound(arg, lt); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Some helpers for reading from binary files.<CODESPLIT>pub fn read_usize(file: &mut File) -> usize { let mut buf = [0u8; 4]; file.read_exact(&mut buf).unwrap(); i32::from_le_bytes(buf) as usize }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>If an entry point references a zombie'd value, then the entry point would normally get removed. That's an absolutely horrible experience to debug, though, so instead, create a nice error message containing the stack trace of how the entry point got to the zombie value.<CODESPLIT>fn report_all(mut self) -> super::Result<()> { let mut result = Ok(()); for root_id in super::dce::collect_roots(self.module) { if let Some(zombie) = self.zombies.get_zombie_by_id(root_id) { for (_, err) in self.build_errors_keyed_by_leaf_id(zombie) { result = Err(err.emit()); } } } result }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Gets the contract's `TokenWithdrawal` event<CODESPLIT>pub fn token_withdrawal_filter( &self, ) -> ::ethers::contract::builders::Event< ::std::sync::Arc<M>, M, TokenWithdrawalFilter, > { self.0.event() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Create a new `FfiFunctionCall` by consuming a FunctionCall.<CODESPLIT>pub fn from_function_call(value: FunctionCall) -> Result<Self> { let leaked_function_name = CString::new(value.function_name.as_str()) .expect("Failed to convert function name to CString") .into_raw(); let (parameters, parameter_len) = match value.parameters { Some(p) => { let parameters: Vec<FfiParameter> = p .into_iter() .map(|param| FfiParameter::from_parameter_value(param).unwrap()) .collect(); let boxed = parameters.into_boxed_slice(); let parameters_len = boxed.len(); let leaked_param_vec = Box::into_raw(boxed); (leaked_param_vec as *const FfiParameter, parameters_len) } None => (core::ptr::null(), 0), }; Ok(Self { function_name: leaked_function_name, parameters, parameters_len: parameter_len, return_type: value.expected_return_type, }) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Finds the last occurrence of a byte string in the given string. If the byte string was found the start position of the byte string is returned, otherwise [`None`].<CODESPLIT>pub fn rfind(&self, bytes: &[u8]) -> Option<usize> { if self.len() < bytes.len() { return None; } for i in (0..self.len() - bytes.len() + 1).rev() { let mut has_found = true; for (n, byte) in bytes.iter().enumerate() { if unsafe { *self.data[i + n].as_ptr() } != *byte { has_found = false; break; } } if has_found { return Some(i); } } None }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>The following three functions are only meant to check partial structural equivalence of `TokenTree`s, see the last assertion in `check()`.<CODESPLIT>fn check_leaf_eq(a: &tt::Leaf, b: &tt::Leaf) -> bool { match (a, b) { (tt::Leaf::Literal(a), tt::Leaf::Literal(b)) => a.symbol == b.symbol, (tt::Leaf::Punct(a), tt::Leaf::Punct(b)) => a.char == b.char, (tt::Leaf::Ident(a), tt::Leaf::Ident(b)) => a.sym == b.sym, _ => false, } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Remove node if it only has n dests<CODESPLIT>pub fn safe_remove_node(&mut self, node: NodeIndex, dests: usize) { if self .graph .edges_directed(node, Direction::Outgoing) .filter(|e| !e.weight().is_schedule()) .count() <= dests { self.graph.remove_node(node); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Called when a command was not found.<CODESPLIT>fn command_not_found<'p>(project: &'p Project, explicit_environment: Option<Environment<'p>>) { let available_tasks: HashSet<TaskName> = if let Some(explicit_environment) = explicit_environment { explicit_environment.get_filtered_tasks() } else { project .environments() .into_iter() .filter(|env| verify_current_platform_has_required_virtual_packages(env).is_ok()) .flat_map(|env| env.get_filtered_tasks()) .collect() }; if !available_tasks.is_empty() { eprintln!( "\nAvailable tasks:\n{}", available_tasks .into_iter() .sorted() .format_with("\n", |name, f| { f(&format_args!("\t{}", name.fancy_display().bold())) }) ); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Gets the type of the metric for its field in metric struct.<CODESPLIT>fn metric_field(foundations: &Path, fn_: &ItemFn) -> proc_macro2::TokenStream { let ItemFn { attrs: FnAttrs { cfg, ctor, .. }, args, ty: metric_ty, ident: metric_name, .. } = fn_; let field_ty = if args.is_empty() { metric_ty.to_token_stream() } else if let Some(ExprStruct { path: ctor_path, .. }) = ctor { quote! { #foundations::reexports_for_macros::prometools::serde::Family< #metric_name, #metric_ty, #ctor_path, > } } else { quote! { #foundations::reexports_for_macros::prometools::serde::Family< #metric_name, #metric_ty, > } }; quote! { #(#cfg)* #metric_name: #field_ty } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Perform a search and summarize the corresponding search results<CODESPLIT>pub async fn summarize_search<T: Serialize>( &self, search_input: &T, ) -> Result<String, LlamaCoreError> { let search_output = self.perform_search(&search_input).await?; let summarization_prompts = self.summarization_prompts.clone().unwrap_or(( "The following are search results I found on the internet:\n\n".to_string(), "\n\nTo sum up them up: ".to_string(), )); let summarize_ctx_size = self .summarize_ctx_size .unwrap_or((self.size_limit_per_result * self.max_search_results as u16) as usize); summarize( search_output, summarize_ctx_size, summarization_prompts.0, summarization_prompts.1, ) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>This function needs to be big so that it does not get inlined by ThinLTO but *does* get inlined into foo() when it is declared `internal` in cfail1 (alone).<CODESPLIT>pub fn bar(){ println!("quux1"); println!("quux2"); println!("quux3"); println!("quux4"); println!("quux5"); println!("quux6"); println!("quux7"); println!("quux8"); println!("quux9"); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>This will only compare against the tag, namespace and data same except element data. for element data compare against the tag, namespace and attributes without order. Both nodes could still have other parents and children.<CODESPLIT>fn matches_tag_and_attrs_without_order(&self, other_data: &ElementData<C>) -> bool { if self.name != other_data.name || self.namespace != other_data.namespace { return false; } if self.name != other_data.name { return false; } if self.namespace != other_data.namespace { return false; } self.attributes.eq(&other_data.attributes) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Reads as much as possible into the given buffer `ptr`. `len` indicates how many bytes we should try to read. `dest` is where the return value should be stored: number of bytes read, or `-1` in case of error.<CODESPLIT>fn read<'tcx>( &self, _self_ref: &FileDescriptionRef, _communicate_allowed: bool, _ptr: Pointer, _len: usize, _dest: &MPlaceTy<'tcx>, _ecx: &mut MiriInterpCx<'tcx>, ) -> InterpResult<'tcx> { throw_unsup_format!("cannot read from {}", self.name()); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Tokens to be returned when the macro cannot proceed.<CODESPLIT>fn failed(crate_name: &Ident) -> proc_macro::TokenStream { finish(quote! { pub mod #crate_name {} }, quote! { "" }) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Request `cnt` more post result challenges. Specifically, these are the challenges that the verifier sends to the prover after the prover sends the result, but before the prover send commitments to the intermediate witness columns. Note: this must be matched with the same count in the [`CountBuilder`](crate::sql::proof::CountBuilder).<CODESPLIT>pub fn request_post_result_challenges(&mut self, cnt: usize) { self.num_post_result_challenges += cnt; }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Gets the underlying OS event, if there is one.<CODESPLIT>pub fn event(&self) -> Option<&Event> { match &self.0 { Inner::Event(e) => Some(e), Inner::SlimEvent(_) => None, } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `poolType` (0xb1dd61b6) function<CODESPLIT>pub fn pool_type(&self) -> ::ethers::contract::builders::ContractCall<M, u8> { self.0 .method_hash([177, 221, 97, 182], ()) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Splits a unique reference into a pair of leaf edges delimiting a specified range. The result are non-unique references allowing (some) mutation, which must be used carefully. The result is meaningful only if the tree is ordered by key, like the tree in a `BTreeMap` is. # Safety Do not use the duplicate handles to visit the same KV twice.<CODESPLIT>pub fn range_search<Q, R>(self, range: R) -> LeafRange<marker::ValMut<'a>, K, V> where Q: ?Sized + Ord, K: Borrow<Q>, R: RangeBounds<Q>, { unsafe { self.find_leaf_edges_spanning_range(range) } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>object safety was renamed to dyn-compatibility but still remains here in chalk. This will be removed since we are going to migrate to next-gen trait solver.<CODESPLIT>fn is_object_safe(&self, trait_id: chalk_ir::TraitId<Interner>) -> bool { let trait_ = from_chalk_trait_id(trait_id); crate::dyn_compatibility::dyn_compatibility(self.db, trait_).is_none() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Readable explanation of the consequences of an event. Fits in the sentence "This transition corresponds to {trans.summary()}".<CODESPLIT>pub fn summary(&self) -> &'static str { assert!(self.is_possible()); assert!(!self.is_noop()); match (self.from, self.to) { (_, Active) => "the first write to a 2-phase borrowed mutable reference", (_, Frozen) => "a loss of write permissions", (ReservedFrz { conflicted: false }, ReservedFrz { conflicted: true }) => "a temporary loss of write permissions until function exit", (Frozen, Disabled) => "a loss of read permissions", (_, Disabled) => "a loss of read and write permissions", (old, new) => unreachable!("Transition from {old:?} to {new:?} should never be possible"), } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>N.B., even when there are multiple `#[path = ...]` attributes, we just need to examine the first one, since rustc ignores the second and the subsequent ones as unused attributes.<CODESPLIT>fn find_path_value(attrs: &[ast::Attribute]) -> Option<Symbol> { attrs.iter().flat_map(path_value).next() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `delta` (0x12b495a8) function<CODESPLIT>pub fn delta(&self) -> ::ethers::contract::builders::ContractCall<M, u128> { self.0 .method_hash([18, 180, 149, 168], ()) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Reverses specialization by the `Missing` constructor by pushing a whole new pattern.<CODESPLIT>fn push_pattern(&mut self, pat: WitnessPat<Cx>) { for witness in self.0.iter_mut() { witness.push_pattern(pat.clone()) } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>const EPS: f64 = f64::EPSILON;<CODESPLIT>fn numbers_are_close(x: f64, y: f64, eps: f64) -> bool { let norm = (x * x + y * y).sqrt(); if norm == 0.0 { return true; } let d = f64::abs(x - y); if d < eps { return true; } d / norm < eps }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>EMIT_MIR matches_reduce_branches.match_u8_i8_2_failed.MatchBranchSimplification.diff<CODESPLIT>fn match_u8_i8_2_failed(i: EnumAu8) -> (i8, i8) { let a: i8; let b: i8; match i { EnumAu8::u0_0x00 => { a = 0; b = 0; () } EnumAu8::u127_0x7f => { a = 127; b = 127; () } EnumAu8::u128_0x80 => { a = -128; b = -128; () } EnumAu8::u255_0xff => { a = -1; b = 1; () } }; (a, b) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Executes the program without tracing and without emitting events. # Errors This function will return an error if the program execution fails.<CODESPLIT>pub fn run_fast(&mut self) -> Result<(), ExecutionError> { self.executor_mode = ExecutorMode::Simple; self.print_report = true; while !self.execute()? {} Ok(()) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>We used to not lower the extra `b @ ..` into `b @ _` which meant that no type was registered for the binding `b` although it passed through resolve. This resulted in an ICE (#69103).<CODESPLIT>fn main() { let [a @ .., b @ ..] = &mut [1, 2]; b; let [.., c @ ..] = [1, 2]; c; let (.., d @ ..) = (1, 2); d; }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Parse args. RUST_LOG=sqlite3Parser=debug<CODESPLIT>fn main() { env_logger::init(); let args = env::args(); for arg in args.skip(1) { let mut parser = Parser::new(arg.as_bytes()); loop { match parser.next() { Ok(None) => break, Err(err) => { eprintln!("Err: {err} in {arg}"); break; } Ok(Some(cmd)) => { println!("{cmd}"); } } } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Creates a new instance for the given initiator.<CODESPLIT>pub fn new(initiator: T) -> Self { Timer { initiator, target_deadline: Instant::from_nanos(0), state: None, } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Reads a file from the guest into a string.<CODESPLIT>pub async fn read_file(&self, path: impl AsRef<Utf8Path<T>>) -> anyhow::Result<String> { let path = self.path(path); let v = self.client.read_file(path.as_str()).await?; String::from_utf8(v).with_context(|| format!("file '{}' is not valid utf-8", path.as_str())) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Only 'a should be linted here<CODESPLIT>fn split_once<'a>(base: &'a str, other: &'_ str) -> (&'a str, Option<&'a str>) { base.split_once(other) .map(|(left, right)| (left, Some(right))) .unwrap_or((base, None)) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Sets the 'Grad' image operand<CODESPLIT>pub fn grad<T>(grad_x: T, grad_y: T) -> SampleParams<NoneTy, NoneTy, SomeTy<(T, T)>, NoneTy> { SampleParams { bias: NoneTy, lod: NoneTy, grad: SomeTy((grad_x, grad_y)), sample_index: NoneTy, } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Are `\x80`..`\xff` allowed?<CODESPLIT>fn allow_high_bytes(self) -> bool { match self { Char | Str => false, Byte | ByteStr | CStr => true, RawStr | RawByteStr | RawCStr => unreachable!(), } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Create a new Stacks address with a pay-2-script-hash<CODESPLIT>pub fn p2sh<'a>( version: AddressVersion, keys: impl IntoIterator<Item = &'a PublicKey>, signature_threshold: usize, ) -> Self { Self::new(version, hash_p2sh(keys, signature_threshold)) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>@ revisions: edition2021 edition2024 @ [edition2021] edition: 2021 @ [edition2024] edition: 2024 @ [edition2024] compile-flags: -Zunstable-options @ [edition2024] check-pass<CODESPLIT>fn main() { let cell = std::cell::RefCell::new(0u8); if let Ok(mut byte) = cell.try_borrow_mut() { *byte = 1; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Call this on things you got out of the MIR (so it is as generic as the current stack frame), to bring it into the proper environment for this interpreter.<CODESPLIT>pub(super) fn instantiate_from_current_frame_and_normalize_erasing_regions< T: TypeFoldable<TyCtxt<'tcx>>, >( &self, value: T, ) -> Result<T, ErrorHandled> { self.instantiate_from_frame_and_normalize_erasing_regions(self.frame(), value) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns a [`InstallBuilder`]. To execute the command and await the result call `.await` on the return value.<CODESPLIT>pub fn install(&self) -> InstallBuilder { InstallBuilder { args: Args { environment: None, project_config: ProjectConfig { manifest_path: Some(self.manifest_path()), }, lock_file_usage: LockFileUsageArgs { frozen: false, locked: false, }, config: Default::default(), all: false, }, } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns paths in the given `dir` (non-recursively), optionally with the given `suffix`. The `suffix` should contain the leading dot.<CODESPLIT>pub fn get_files_from_dir( dir: &Utf8Path, suffix: Option<&str>, ) -> anyhow::Result<Vec<Utf8PathBuf>> { let path = format!("{dir}/*{}", suffix.unwrap_or("")); Ok(glob::glob(&path)? .map(|p| p.map(|p| Utf8PathBuf::from_path_buf(p).unwrap())) .collect::<Result<Vec<_>, _>>()?) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>@ known-bug: #105275 @ compile-flags: -Copt-level=0<CODESPLIT>pub fn encode_num<Writer: ExampleWriter>(n: u32, mut writer: Writer) -> Result<(), Writer::Error> { if n > 15 { encode_num(n / 16, &mut writer)?; } Ok(()) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Converts the scalar to produce a machine-pointer-sized unsigned integer. Fails if the scalar is a pointer.<CODESPLIT>pub fn to_target_usize(self, cx: &impl HasDataLayout) -> InterpResult<'tcx, u64> { let b = self.to_uint(cx.data_layout().pointer_size)?; interp_ok(u64::try_from(b).unwrap()) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Sets the attributes of the open file.<CODESPLIT>pub fn set_attr(&self, arg: &fuse_setattr_in, request_uid: lx::uid_t) -> lx::Result<()> { let attr = util::fuse_set_attr_to_lxutil(arg, request_uid); self.file.read().set_attr(attr) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Verify non-generic ZST -> generic ZST transmute<CODESPLIT>unsafe fn cast_zst0<T>(from: ()) -> [T; 0] { ::std::mem::transmute::<(), [T; 0]>(from) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT># Panics This method will panic if the byte array is not of the expected length (32 bytes) or if it cannot be converted to a valid canonical scalar. However, under normal conditions, valid `Curve25519Scalar` values should always satisfy these requirements.<CODESPLIT>fn from(value: &Curve25519Scalar) -> Self { let bytes = ark_ff::BigInteger::to_bytes_le(&value.0.into_bigint()); curve25519_dalek::scalar::Scalar::from_canonical_bytes(bytes.try_into().unwrap()).unwrap() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns the `SyntaxNode` of the module. If this is a file module, returns the `SyntaxNode` of the *definition* file, not of the *declaration*.<CODESPLIT>pub fn module_definition_node(&self, module: Module) -> InFile<SyntaxNode> { let def_map = module.id.def_map(self.db.upcast()); let definition = def_map[module.id.local_id].origin.definition_source(self.db.upcast()); let definition = definition.map(|it| it.node()); let root_node = find_root(&definition.value); self.cache(root_node, definition.file_id); definition }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>[old]~^ ERROR: unconstrained opaque type<CODESPLIT>fn weird_bound<X>(x: &<X as Trait<'static>>::Out<Foo>) -> X //[old]~^ ERROR: item does not constrain //[next]~^^ ERROR: cannot satisfy `Foo == _` where for<'a> X: Trait<'a>, for<'a> <X as Trait<'a>>::Out<()>: Copy, { let x = *x; todo!(); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>EMIT_MIR range_iter.inclusive_loop.PreCodegen.after.mir<CODESPLIT>pub fn inclusive_loop(start: u32, end: u32, f: impl Fn(u32)) { for x in start..=end { f(x) } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Ensure that leaks through `thread_local` statics *not in the main thread* are detected.<CODESPLIT>pub fn main() { #[thread_local] static TLS: Cell<Option<&'static i32>> = Cell::new(None); std::thread::spawn(|| { TLS.set(Some(Box::leak(Box::new(123)))); }) .join() .unwrap(); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `getAssetRecipient` (0x79eac6c2) function<CODESPLIT>pub fn get_asset_recipient( &self, ) -> ::ethers::contract::builders::ContractCall< M, ::ethers::core::types::Address, > { self.0 .method_hash([121, 234, 198, 194], ()) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Gets the contract's `TokenDeposit` event<CODESPLIT>pub fn token_deposit_filter( &self, ) -> ::ethers::contract::builders::Event< ::std::sync::Arc<M>, M, TokenDepositFilter, > { self.0.event() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Binary numbers are 10 bits and the most significant bit is the sign<CODESPLIT>fn from_binary_to_decimal(value: f64) -> Result<i64, String> { let value = format!("{value}"); let result = match i64::from_str_radix(&value, 2) { Ok(b) => b, Err(_) => { return Err("cannot parse into binary".to_string()); } }; if !(0..=1023).contains(&result) { return Err("too large".to_string()); } else if result > 511 { return Ok(result - 1024); }; Ok(result) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns the variant's name or "" if unknown.<CODESPLIT>pub fn variant_name(self) -> Option<&'static str> { match self { Self::none => Some("none"), Self::guest => Some("guest"), Self::host => Some("host"), _ => None, } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Assert that two float values are close together.<CODESPLIT>pub fn assert_approx_equal(left: f64, right: f64) { let diff = (left - right).abs(); let add = left.abs() + right.abs(); if diff > 0.0005 * add { panic!("assertion failed: `(left ~= right) left: {left} right: {right}"); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `withdraw` (0x3ccfd60b) function<CODESPLIT>pub fn withdraw(&self) -> ::ethers::contract::builders::ContractCall<M, ()> { self.0 .method_hash([60, 207, 214, 11], ()) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Run the built-in `pgml.embed()` function. # Arguments * `model` - The model to use. * `text` - The text to embed.<CODESPLIT>pub async fn embed(&self, model: &str, text: &str) -> anyhow::Result<Json> { let pool = get_or_initialize_pool(&self.database_url).await?; let query = sqlx::query("SELECT embed FROM pgml.embed($1, $2)"); let result = query.bind(model).bind(text).fetch_one(&pool).await?; let result = result.get::<Vec<f32>, _>(0); let result = serde_json::to_value(result)?; Ok(Json(result)) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns the number of elements stored in the queue<CODESPLIT>pub fn len(&self) -> usize { let (write_position, read_position) = self.acquire_read_and_write_position(); write_position - read_position }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Initialize a text recognizer from a trained RTen model. Fails if the model does not have the expected inputs or outputs.<CODESPLIT>pub fn from_model(model: Model) -> anyhow::Result<TextRecognizer> { let input_id = model .input_ids() .first() .copied() .ok_or(anyhow!("recognition model has no inputs"))?; let input_shape = model .node_info(input_id) .and_then(|info| info.shape()) .ok_or(anyhow!("recognition model does not specify input shape"))?; let output_id = model .output_ids() .first() .copied() .ok_or(anyhow!("recognition model has no outputs"))?; Ok(TextRecognizer { model, input_id, input_shape: input_shape.into_iter().collect(), output_id, }) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Load the tokenizer and return the first tokens from the prompt in context.<CODESPLIT>fn load_tokenizer(ctx: &Context) -> Result<(Tokenizer, Option<u32>)> { let tokenizer_filename = ctx.data_path.join("tokenizer.json"); log::info!("loading tokenizer from {}", tokenizer_filename.display()); let tokenizer = Tokenizer::from_file(tokenizer_filename).map_err(anyhow::Error::msg)?; let eos_token_id = ctx .config .as_ref() .expect("No config specified") .eos_token_id .or_else(|| tokenizer.token_to_id(DEFAULT_EOS_TOKEN)); Ok((tokenizer, eos_token_id)) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Computes a unique semi-human-readable hash for this key. Some parts of the input are hashes and others are included directly in the name this is to make it easier to identify the cache files.<CODESPLIT>pub fn hash_key(&self) -> String { let BuildInput { channel_urls, target_platform, name, version, build, host_platform, host_virtual_packages, build_virtual_packages, } = self; let mut hasher = Xxh3::new(); build.hash(&mut hasher); channel_urls.hash(&mut hasher); host_platform.hash(&mut hasher); host_virtual_packages.hash(&mut hasher); build_virtual_packages.hash(&mut hasher); let hash = URL_SAFE_NO_PAD.encode(hasher.finish().to_ne_bytes()); format!("{name}-{version}-{target_platform}-{hash}",) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>rust-lang rust#78174: ICE: "cannot convert ReErased to a region vid"<CODESPLIT>fn issue_78174() { match "foo" { const { concat!("fo", "o") } => (), _ => unreachable!(), } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `changeDelta` (0x6809f664) function<CODESPLIT>pub fn change_delta( &self, new_delta: u128, ) -> ::ethers::contract::builders::ContractCall<M, ()> { self.0 .method_hash([104, 9, 246, 100], new_delta) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>def and def_cx are separated, because Builder has a span associated with what it's currently emitting.<CODESPLIT>pub fn def_cx(self, cx: &CodegenCx<'_>) -> Word { self.def_with_span(cx, DUMMY_SP) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Parses a string containing a number followed by a unit (`px`, `%`). Allows for negative numbers. Example: ``` LengthValue::from_str("100px") { amount: 100.0, unit: LengthUnit::Pixel } ```<CODESPLIT>fn from_str(unparsed: &str) -> anyhow::Result<Self> { let units_regex = Regex::new(r"([+-]?\d+)(%|px)?")?; let err_msg = format!( "Not a valid length value '{}'. Must be of format '10px' or '10%'.", unparsed ); let captures = units_regex .captures(unparsed) .context(err_msg.to_string())?; let unit_str = captures.get(2).map_or("", |m| m.as_str()); let unit = match unit_str { "px" | "" => LengthUnit::Pixel, "%" => LengthUnit::Percentage, _ => bail!(err_msg), }; let amount = captures .get(1) .and_then(|amount_str| f32::from_str(amount_str.into()).ok()) .context(err_msg.to_string())?; Ok(LengthValue { amount, unit }) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Handles the shared interrupt by signaling all channels whose bit is set in the receive page. All bits in the receive page are cleared during this operation.<CODESPLIT>pub fn handle_shared_interrupt(&self) { let bitmap = AtomicBitmap::new(self.get_recv_page()); let channel_table = self.channel_table.read(); bitmap.scan_and_clear(|event_flag| { let event = channel_table.get(event_flag); if let Some(Some(event)) = event { event.deliver(); } else { tracelimit::warn_ratelimited!(event_flag, "Guest signaled unknown channel"); } }); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Creates a new `StateChanges` instance with a single environment name and an empty vector as its value.<CODESPLIT>pub(crate) fn new_with_env(env_name: EnvironmentName) -> Self { Self { changes: HashMap::from([(env_name, Vec::new())]), } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Generates the code for a field with no attributes.<CODESPLIT>fn generate_field_arg(&mut self, binding_info: &BindingInfo<'_>) -> TokenStream { let diag = &self.parent.diag; let field = binding_info.ast(); let mut field_binding = binding_info.binding.clone(); field_binding.set_span(field.ty.span()); let ident = field.ident.as_ref().unwrap(); let ident = format_ident!("{}", ident); quote! { #diag.arg( stringify!(#ident), #field_binding ); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>EMIT_MIR gvn_copy_aggregate.enum_identical_variant.GVN.diff<CODESPLIT>fn enum_identical_variant(v: &Enum1) -> Enum1 { match v { Enum1::A(v) => { let a = v.a; let b = v.b; let c = v.c; let all_copy = AllCopy { a, b, c }; Enum1::A(all_copy) } Enum1::B(v) => { let a = v.a; let b = v.b; let c = v.c; let all_copy = AllCopy { a, b, c }; Enum1::B(all_copy) } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Converts the memory back to an unerased type. Panics if the type is not the same as that of the object passed to `new`.<CODESPLIT>pub fn downcast<T: Any>(self) -> T { let inner: SmallBox<dyn Any, S4> = unsafe { std::mem::transmute(self.0) }; let inner: SmallBox<T, _> = inner.downcast().unwrap(); inner.into_inner() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Get's the type of a field by name.<CODESPLIT>pub fn get_field_by_name<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, name: Symbol) -> Option<Ty<'tcx>> { match *ty.kind() { ty::Adt(def, args) if def.is_union() || def.is_struct() => def .non_enum_variant() .fields .iter() .find(|f| f.name == name) .map(|f| f.ty(tcx, args)), ty::Tuple(args) => name.as_str().parse::<usize>().ok().and_then(|i| args.get(i).copied()), _ => None, } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>@ run-fail @ compile-flags: -Copt-level=3 -Cdebug-assertions=no -Zub-checks=yes @ error-pattern: unsafe precondition(s) violated: slice::get_unchecked_mut requires @ revisions: usize range range_to range_from backwards_range<CODESPLIT>fn main() { unsafe { let mut s = &mut [0]; #[cfg(usize)] s.get_unchecked_mut(1); #[cfg(range)] s.get_unchecked_mut(1..2); #[cfg(range_to)] s.get_unchecked_mut(..2); #[cfg(range_from)] s.get_unchecked_mut(2..); #[cfg(backwards_range)] s.get_unchecked_mut(1..0); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Constructs a new guard for the given prefix but does not perform any locking operations yet.<CODESPLIT>pub fn new(prefix: &Path) -> io::Result<Self> { let guard_path = prefix.join(GUARD_PATH); std::fs::create_dir_all(guard_path.parent().unwrap())?; Ok(Self { guard: fd_lock::RwLock::new( std::fs::File::options() .write(true) .read(true) .create(true) .truncate(false) .open(guard_path)?, ), }) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Checks if there are incoming packets ready to be processed. Fails with `ErrorKind::WouldBlock` if there are no packets ready.<CODESPLIT>fn process_in(&mut self) -> io::Result<()> { if self.state.in_next_full.0 != self.state.in_next_pending { Ok(()) } else { match self.state.in_overlapped[self.state.in_next_pending].io_status() { Some((ntstatus::STATUS_SUCCESS, _)) => { self.state.in_next_pending = (self.state.in_next_pending + 1) % IN_OP_COUNT; Ok(()) } None => Err(ErrorKind::WouldBlock.into()), Some((status, _)) => Err(status_to_error(status)), } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Evaluation order for `a op=b` otherwise is first `a` then `b`.<CODESPLIT>fn generic_compound<T: AddAssign<T> + Default>() { let mut side_order = vec![]; let mut add_assignable: Wrapper<T> = Wrapper(Default::default()); { side_order.push(Side::Lhs); add_assignable }.0 += { side_order.push(Side::Rhs); Default::default() }; assert!(matches!(side_order[..], [Side::Lhs, Side::Rhs])); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Whether to package these target-specific docs for another similar target.<CODESPLIT>pub(crate) fn use_docs_fallback(&self) -> bool { match self { PkgType::JsonDocs | PkgType::HtmlDocs => true, _ => false, } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>The argument coerces to a subtype of the return type.<CODESPLIT>fn long_to_short<'a, 'b, T>(xs: &'b [&'static T; 1]) -> &'b [&'a T] { xs }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Waits for a new value to be set.<CODESPLIT>pub async fn wait_next(&mut self) { poll_fn(|cx| { let mut old_waker = None; let inner = &mut *self.0; inner.port.with_handler(|state| { if inner.last_id == state.id { old_waker = state.waker.replace(cx.waker().clone()); return Poll::Pending; } inner.last_id = state.id; Poll::Ready(()) }) }) .await }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Pushes an event to the event list.<CODESPLIT>fn push(&mut self, port: PortRef, seq: Seq, event: PortEvent) { match port { PortRef::LocalPort(port) => self.push_local(port, seq, event), PortRef::RemotePort(remote_node, port_id) => { self.remote_events.push((remote_node, port_id, seq, event)); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>For closures, we first visit the parameters and then the content, as we prefer those.<CODESPLIT>fn visit_body(&mut self, body: &Body<'tcx>) { for param in body.params { debug!( "param: span {:?}, ty_span {:?}, pat.span {:?}", param.span, param.ty_span, param.pat.span ); if param.ty_span != param.pat.span { debug!("skipping param: has explicit type"); continue; } let Some(param_ty) = self.opt_node_type(param.hir_id) else { continue }; if self.generic_arg_contains_target(param_ty.into()) { self.update_infer_source(InferSource { span: param.pat.span, kind: InferSourceKind::ClosureArg { insert_span: param.pat.span.shrink_to_hi(), ty: param_ty, }, }) } } intravisit::walk_body(self, body); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>We can't optimize it because y may be an invalid value. EMIT_MIR early_otherwise_branch.opt1.EarlyOtherwiseBranch.diff<CODESPLIT>fn opt1(x: Option<u32>, y: Option<u32>) -> u32 { match (x, y) { (Some(a), Some(b)) => 0, _ => 1, } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>@ check-pass @ aux-crate:bar=bar.rs @ compile-flags:--crate-type lib -Wunused-crate-dependencies<CODESPLIT>pub fn fib(n: u32) -> Vec<u32> { let mut prev = 0; let mut cur = 1; let mut v = vec![]; for _ in 0..n { v.push(prev); let n = prev + cur; prev = cur; cur = n; } v }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>~^ ERROR cannot find type `double` in this scope ~| HELP perhaps you intended to use this type<CODESPLIT>fn main() { let x: Real = 3.5; let y: long = 74802374902374923; let v1: Boolean = true; let v2: Bool = true; }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>even without panics, this helps for Miri backtraces<CODESPLIT>pub unsafe fn gather_select_ptr( source: Simd<*const T, N>, enable: Mask<isize, N>, or: Self, ) -> Self { unsafe { core::intrinsics::simd::simd_gather(or, source, enable.to_int()) } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>The caller must guarantee that the given provenance list is already sorted by address and contain no duplicates.<CODESPLIT>pub fn from_presorted_ptrs(r: Vec<(Size, Prov)>) -> Self { ProvenanceMap { ptrs: SortedMap::from_presorted_elements(r), bytes: None } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Groups an iterator of dates by week.<CODESPLIT>fn by_week(it: impl DateIterator) -> impl Iterator<Item=(u32, impl DateIterator)> + Clone { it.group_by(|d| d.succ().isoweekdate().1) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns an iterator over the items in a list. Returns `None` if the binding is not bound to a list.<CODESPLIT>fn list_items(&self) -> Option<impl Iterator<Item = NodeWithSource<'a>> + Clone> { match self { Self::List(parent_node, field_id) => { Some(parent_node.named_children_by_field_id(*field_id)) } Self::Empty(..) | Self::Node(..) | Self::String(..) | Self::ConstantRef(..) | Self::FileName(..) => None, } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Walks through the expansion ancestors of `original_span` to find a span that is contained in `body_span` and has the same [syntax context] as `body_span`. If the returned span represents a bang-macro invocation (e.g. `foo!(..)`), the returned symbol will be the name of that macro (e.g. `foo`).<CODESPLIT>pub(crate) fn unexpand_into_body_span_with_expn_kind( original_span: Span, body_span: Span, ) -> Option<(Span, Option<ExpnKind>)> { let (span, prev) = unexpand_into_body_span_with_prev(original_span, body_span)?; let expn_kind = prev.map(|prev| prev.ctxt().outer_expn_data().kind); Some((span, expn_kind)) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Implementation of the date() SQL function.<CODESPLIT>pub fn exec_date(values: &[OwnedValue]) -> OwnedValue { let maybe_dt = match values.first() { None => parse_naive_date_time(&OwnedValue::Text(Rc::new("now".to_string()))), Some(value) => parse_naive_date_time(value), }; if maybe_dt.is_none() { return OwnedValue::Text(Rc::new(String::new())); } let mut dt = maybe_dt.unwrap(); for modifier in values.iter().skip(1) { if let OwnedValue::Text(modifier_str) = modifier { if apply_modifier(&mut dt, modifier_str).is_err() { return OwnedValue::Text(Rc::new(String::new())); } } else { return OwnedValue::Text(Rc::new(String::new())); } } OwnedValue::Text(Rc::new(get_date_from_naive_datetime(dt))) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>The hash is encoded based on `base-62` and the final terminator `_` is removed because it does not help prevent hash collisions<CODESPLIT>fn push_hash64(hash: u64, output: &mut String) { let hash = v0::encode_integer_62(hash); let hash_len = hash.len(); let _ = write!(output, "{hash_len}H{}", &hash[..hash_len - 1]); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Extend the table from [`IntoDocuments`]<CODESPLIT>pub async fn add_context(&self, context: impl IntoDocuments) -> anyhow::Result<Vec<Id>> where R: From<Document> + AsRef<Document> + Serialize + DeserializeOwned, K: Sync, { let documents = context.into_documents().await?; let iter = documents.into_iter().map(|v| v.into()); self.extend(iter).await }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Should trigger lint when both sides of a binary operation creates a temporary with a significant drop. To avoid potential unnecessary copies or creating references that would trigger the significant drop problem, the lint recommends moving the entire binary operation.<CODESPLIT>fn should_trigger_lint_for_accessing_fields_in_mutex_in_both_sides_of_binary_op() { let mutex1 = Mutex::new(StateWithField { s: "state".to_owned() }); let mutex2 = Mutex::new(StateWithField { s: "statewithfield".to_owned(), }); match mutex1.lock().unwrap().s.len() < mutex2.lock().unwrap().s.len() { true => { println!( "{} < {}", mutex1.lock().unwrap().s.len(), mutex2.lock().unwrap().s.len() ); }, false => {}, }; match mutex1.lock().unwrap().s.len() >= mutex2.lock().unwrap().s.len() { true => { println!( "{} >= {}", mutex1.lock().unwrap().s.len(), mutex2.lock().unwrap().s.len() ); }, false => {}, }; }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Converts a slice to a string, capturing repetitions to save space. E.g. `[4, 4, 4, 3, 2, 1, 1, 1, 1, 1]` -> "[4 (x3), 3, 2, 1 (x5)]".<CODESPLIT>fn list(ns: &[usize]) -> String { let mut v = Vec::new(); if ns.is_empty() { return "[]".to_string(); } let mut elem = |curr, curr_count| { if curr_count == 1 { v.push(format!("{curr}")); } else { v.push(format!("{curr} (x{curr_count})")); } }; let mut curr = ns[0]; let mut curr_count = 1; for &n in &ns[1..] { if n != curr { elem(curr, curr_count); curr = n; curr_count = 1; } else { curr_count += 1; } } elem(curr, curr_count); format!("[{}]", v.join(", ")) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Visit the right-hand-side of a `&&`. Used for if-let chains. Returns `Some` if the expression was ultimately a `let ... = ...`, and `None` if it was a normal boolean expression. This must call `visit_expr` on the subexpressions we are not handling ourselves.<CODESPLIT>fn visit_land_rhs( &mut self, ex: &'p Expr<'tcx>, ) -> Result<Option<(Span, RefutableFlag)>, ErrorGuaranteed> { match ex.kind { ExprKind::Scope { value, lint_level, .. } => { self.with_lint_level(lint_level, |this| this.visit_land_rhs(&this.thir[value])) } ExprKind::Let { box ref pat, expr } => { let expr = &self.thir()[expr]; self.with_let_source(LetSource::None, |this| { this.visit_expr(expr); }); Ok(Some((ex.span, self.is_let_irrefutable(pat, Some(expr))?))) } _ => { self.with_let_source(LetSource::None, |this| { this.visit_expr(ex); }); Ok(None) } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Unions `row` with `set`. `set` can be either `BitSet` or `HybridBitSet`. Returns true if the row was changed.<CODESPLIT>pub fn union_row<Set>(&mut self, row: R, set: &Set) -> bool where HybridBitSet<C>: BitRelations<Set>, { self.ensure_row(row).union(set) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Assumes, without verification, that a buffer of bytes contains a GuestLogData and returns it. # Safety Callers must trust the given bytes do indeed contain a valid `GuestLogData`.<CODESPLIT>pub unsafe fn root_as_guest_log_data_unchecked(buf: &[u8]) -> GuestLogData { flatbuffers::root_unchecked::<GuestLogData>(buf) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>FIXME: Consider if `#[rustc_diagnostic_item = "ptr_drop_in_place"]` is needed?<CODESPLIT>unsafe fn async_drop_in_place_raw<T: ?Sized>( to_drop: *mut T, ) -> <T as AsyncDestruct>::AsyncDestructor { unsafe { async_drop_in_place_raw(to_drop) } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Fill the remaining space of the vector by calling the provided closure repeatedly<CODESPLIT>pub fn fill_with<F: FnMut() -> T>(&mut self, f: F) { unsafe { self.fill_with_impl(f) } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>EMIT_MIR lower_intrinsics.transmute_to_box_uninhabited.LowerIntrinsics.diff<CODESPLIT>pub unsafe fn transmute_to_box_uninhabited() -> ! { let x: Box<Never> = std::mem::transmute(1usize); match *x {} }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Finds the `BasicBlock` to which this `SwitchInt` will branch given the specific value. This cannot fail, as it'll return the `otherwise` branch if there's not a specific match for the value.<CODESPLIT>pub fn target_for_value(&self, value: u128) -> BasicBlockId { self.iter().find_map(|(v, t)| (v == value).then_some(t)).unwrap_or_else(|| self.otherwise()) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns the position just before rarrow ```rust,ignore fn into(self) -> () {} ^ in case of unformatted code fn into2(self)-> () {} ^ fn into3(self) -> () {} ^ ```<CODESPLIT>pub fn position_before_rarrow(s: &str) -> Option<usize> { s.rfind("->").map(|rpos| { let mut rpos = rpos; let chars: Vec<char> = s.chars().collect(); while rpos > 1 { if let Some(c) = chars.get(rpos - 1) { if c.is_whitespace() { rpos -= 1; continue; } } break; } rpos }) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>While typechecking a body, we need to be able to define the opaque types defined by that body.<CODESPLIT>pub fn analysis_in_body(cx: I, body_def_id: I::LocalDefId) -> TypingMode<I> { TypingMode::Analysis { defining_opaque_types: cx.opaque_types_defined_by(body_def_id) } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Find all pools that were touched in a given block range.<CODESPLIT>async fn get_touched_pools(&self, from_block: u64, to_block: u64) -> Result<Vec<H160>> { let address_list = self.pool_bids.keys().cloned().collect::<Vec<_>>(); let filter = Filter::new() .from_block(from_block) .to_block(to_block) .address(address_list) .events(&*POOL_EVENT_SIGNATURES); let events = self.client.get_logs(&filter).await?; let touched_pools = events.iter().map(|event| event.address).collect::<Vec<_>>(); Ok(touched_pools) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>@ known-bug: rust-lang rust#129095 @ compile-flags: -Zmir-opt-level=5 -Zvalidate-mir<CODESPLIT>pub fn function_with_bytes<const BYTES: &'static [u8; 4]>() -> &'static [u8] { BYTES }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>* Note: This function is only called for ix>=0x40000000 (see above) *<CODESPLIT>fn pone(x: f64) -> f64 { let ix = high_word(x) & 0x7fffffff; let (p, q) = if ix >= 0x40200000 { (PR8, PS8) } else if ix >= 0x40122E8B { (PR5, PS5) } else if ix >= 0x4006DB6D { (PR3, PS3) } else { (PR2, PS2) }; let z = 1.0 / (x * x); let r = p[0] + z * (p[1] + z * (p[2] + z * (p[3] + z * (p[4] + z * p[5])))); let s = 1.0 + z * (q[0] + z * (q[1] + z * (q[2] + z * (q[3] + z * q[4])))); 1.0 + r / s }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>It's common to define a constructor sort of function to create struct instances. If there is a canonical constructor it is typically named the same as the type. Other constructor sort of functions are typically named from_foo, from_bar, etc.<CODESPLIT>fn AsciiArt(width: usize, height: usize, fill: char) -> AsciiArt { let lines = vec![vec!['.'; width]; height]; AsciiArt {width: width, height: height, fill: fill, lines: lines} }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Gets the contract's `SpotPriceUpdate` event<CODESPLIT>pub fn spot_price_update_filter( &self, ) -> ::ethers::contract::builders::Event< ::std::sync::Arc<M>, M, SpotPriceUpdateFilter, > { self.0.event() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns a new instance that waits for `fd` to be ready via `fd_ready`, then reads `read_size` bytes from it. Panics if `read_size` is greater than [`MAXIMUM_WAIT_READ_SIZE`].<CODESPLIT>pub fn new(fd: RawFd, fd_ready: T, read_size: usize) -> Self { assert!(read_size <= MAXIMUM_WAIT_READ_SIZE); Self { fd_ready, fd, read_size, } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Wether this expression would be valid somewhere that expects a value, for example, an `if` condition.<CODESPLIT>pub fn returns(&self) -> bool { if let ExprKind::Block(ref block) = self.node { match block.stmts.last().map(|last_stmt| &last_stmt.node) { Some(&StmtKind::Expr(_)) => true, Some(&StmtKind::Semi(ref expr)) => { if let ExprKind::Ret(_) = expr.node { true } else { false } } _ => false, } } else { true } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Makes `expected <: actual`.<CODESPLIT>pub fn sub<T>( self, define_opaque_types: DefineOpaqueTypes, expected: T, actual: T, ) -> InferResult<'tcx, ()> where T: ToTrace<'tcx>, { if self.infcx.next_trait_solver { NextSolverRelate::relate(self.infcx, self.param_env, expected, ty::Covariant, actual) .map(|goals| self.goals_to_obligations(goals)) } else { let mut op = TypeRelating::new( self.infcx, ToTrace::to_trace(self.cause, expected, actual), self.param_env, define_opaque_types, ty::Covariant, ); op.relate(expected, actual)?; Ok(InferOk { value: (), obligations: op.into_obligations() }) } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>@revisions: stack tree @[tree]compile-flags: -Zmiri-tree-borrows @error-in-other-file: expected a pointer to 4 bytes of memory<CODESPLIT>fn main() { unsafe { let ptr = Box::into_raw(Box::new(0u16)); drop(Box::from_raw(ptr as *mut u32)); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Gets the argument type at the given offset. For closures this will also get the type as written. This will return `None` when the index is out of bounds only for variadic functions, otherwise this will panic.<CODESPLIT>pub fn input_with_hir(self, i: usize) -> Option<(Option<&'tcx hir::Ty<'tcx>>, Binder<'tcx, Ty<'tcx>>)> { match self { Self::Sig(sig, _) => { if sig.c_variadic() { sig.inputs() .map_bound(|inputs| inputs.get(i).copied()) .transpose() .map(|arg| (None, arg)) } else { Some((None, sig.input(i))) } }, Self::Closure(decl, sig) => Some(( decl.and_then(|decl| decl.inputs.get(i)), sig.input(0).map_bound(|ty| ty.tuple_fields()[i]), )), Self::Trait(inputs, _, _) => Some((None, inputs.map_bound(|ty| ty.tuple_fields()[i]))), } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>~ MONO_ITEM fn <Indexable as std::ops::Index<usize>>::index<CODESPLIT>fn index(&self, index: usize) -> &Self::Output { if index >= 3 { &self.data[0] } else { &self.data[index] } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns a pipe (reader, writer combo)<CODESPLIT>fn pipe() -> (i32, i32) { let mut fds = [0; 2]; assert_eq!(unsafe { libc::pipe(fds.as_mut_ptr()) }, 0); (fds[0], fds[1]) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Convert a query to embeddings. # Arguments * `embedding_request` - A reference to an `EmbeddingRequest` object.<CODESPLIT>pub async fn rag_query_to_embeddings( embedding_request: &EmbeddingRequest, ) -> Result<EmbeddingsResponse, LlamaCoreError> { #[cfg(feature = "logging")] info!(target: "stdout", "Compute embeddings for the user query."); let running_mode = running_mode()?; if running_mode != RunningMode::Rag { let err_msg = format!("The RAG query is not supported in the {running_mode} mode.",); #[cfg(feature = "logging")] error!(target: "stdout", "{}", &err_msg); return Err(LlamaCoreError::Operation(err_msg)); } embeddings(embedding_request).await }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Might lose data if multiple thread calls it simultaneously<CODESPLIT>pub fn update<F>(&self, func: F) where F: FnOnce(&mut T), { let mut v = self.0.load(); func(&mut v); self.0.store(v) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `transferOwnership` (0x6d435421) function<CODESPLIT>pub fn transfer_ownership( &self, conduit: ::ethers::core::types::Address, new_potential_owner: ::ethers::core::types::Address, ) -> ::ethers::contract::builders::ContractCall<M, ()> { self.0 .method_hash([109, 67, 84, 33], (conduit, new_potential_owner)) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>EMIT_MIR combine_array_len.norm2.InstSimplify-after-simplifycfg.diff<CODESPLIT>fn norm2(x: [f32; 2]) -> f32 { let a = x[0]; let b = x[1]; a * a + b * b }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `getOrderStatus` (0x46423aa7) function<CODESPLIT>pub fn get_order_status( &self, order_hash: [u8; 32], ) -> ::ethers::contract::builders::ContractCall< M, (bool, bool, ::ethers::core::types::U256, ::ethers::core::types::U256), > { self.0 .method_hash([70, 66, 58, 167], order_hash) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>cluster datatypes into MultiDatatype ScalarDatatype groups<CODESPLIT>pub fn cluster_datatypes(dts: Vec<Datatype>) -> Vec<MetaDatatype> { let mdts: Vec<MultiDatatype> = MultiDatatype::variants() .iter() .filter(|mdt| mdt.datatypes().iter().filter(|x| dts.contains(x)).count() >= 2) .cloned() .collect(); let mdt_dts: Vec<Datatype> = mdts.iter().flat_map(|mdt| mdt.datatypes()).filter(|dt| dts.contains(dt)).collect(); let other_dts: Vec<Datatype> = dts.iter().filter(|dt| !mdt_dts.contains(dt)).copied().collect(); [ mdts.iter().map(|mdt| MetaDatatype::Multi(*mdt)).collect::<Vec<MetaDatatype>>(), other_dts.into_iter().map(MetaDatatype::Scalar).collect(), ] .concat() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Issue 46095 Built-in indexing should be used even when the index is not trivially an integer Overloaded indexing would cause wrapped to be borrowed mutably<CODESPLIT>fn main() { let mut a1 = A; let mut a2 = A; let wrapped = [&mut a1, &mut a2]; { wrapped[0 + 1 - 1].take_mutably(); } { wrapped[identity(0)].take_mutably(); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns whether the remote node connection has failed.<CODESPLIT>fn node_status(&self) -> Result<(), NodeError> { if !self.failed.load(Ordering::SeqCst) { return Ok(()); } self.node_error.lock().clone() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Adjust the congestion window See draft-cardwell-iccrg-bbr-congestion-control-00 Section 4.2.3.6<CODESPLIT>fn set_cwnd(&mut self) { let bytes_in_flight = self.stats.bytes_in_flight; self.update_target_cwnd(); self.modulate_cwnd_for_recovery(bytes_in_flight); if !self.packet_conservation { if self.is_filled_pipe() { self.cwnd = self .target_cwnd .min(self.cwnd + self.ack_state.newly_acked_bytes); } else if self.cwnd < self.target_cwnd || self.delivery_rate_estimator.delivered() < self.config.initial_cwnd { self.cwnd += self.ack_state.newly_acked_bytes; } self.cwnd = self.cwnd.max(self.config.min_cwnd); } self.modulate_cwnd_for_probe_rtt(); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Convert a BigUint to a Vec of F limbs (with len NB_LIMBS).<CODESPLIT>fn to_limbs_field_vec<E: From<F>, F: Field>(x: &BigUint) -> Vec<E> { Self::to_limbs(x).into_iter().map(|x| F::from_canonical_u8(x).into()).collect::<Vec<_>>() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Sets every cell in `row` to true.<CODESPLIT>pub fn insert_all_into_row(&mut self, row: R) { assert!(row.index() < self.num_rows); let (start, end) = self.range(row); let words = &mut self.words[..]; for index in start..end { words[index] = !0; } clear_excess_bits_in_final_word(self.num_columns, &mut self.words[..end]); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Apply a binary operator to two slices of the same length with right upcasting returning results.<CODESPLIT>pub(crate) fn try_slice_binary_op_right_upcast<S, T, U, F>( lhs: &[S], rhs: &[T], op: F, ) -> ColumnOperationResult<Vec<U>> where T: Copy + Into<S>, F: Fn(&S, &S) -> ColumnOperationResult<U>, { try_slice_binary_op(lhs, rhs, |l, r| -> ColumnOperationResult<U> { op(l, &Into::<S>::into(*r)) }) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Some locals are part of the function's interface and can not be removed. Note that these locals *can* still be merged with non-required locals by removing that other local.<CODESPLIT>fn is_local_required(local: Local, body: &Body<'_>) -> bool { match body.local_kind(local) { LocalKind::Arg | LocalKind::ReturnPointer => true, LocalKind::Temp => false, } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Gets the contract's `TokenWithdrawal` event<CODESPLIT>pub fn token_withdrawal_filter( &self, ) -> ::ethers::contract::builders::Event< ::std::sync::Arc<M>, M, TokenWithdrawalFilter, > { self.0.event() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Check that underscore patterns within more complex patterns are dropped after the method is polled.<CODESPLIT>async fn baz_async((x, _): (D, D)) { x.1.borrow_mut().push(DropOrder::Function); NeverReady.await; }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `getApproved` (0x081812fc) function<CODESPLIT>pub fn get_approved( &self, token_id: ::ethers::core::types::U256, ) -> ::ethers::contract::builders::ContractCall< M, ::ethers::core::types::Address, > { self.0 .method_hash([8, 24, 18, 252], token_id) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Adds a byte slice at the end. When the capacity is exceeded, the byte slice contains illegal characters or the content would result in an illegal content it fails.<CODESPLIT>fn push_bytes(&mut self, bytes: &[u8]) -> Result<(), SemanticStringError> { self.insert_bytes(self.len(), bytes) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Ensures that the lock-file is up-to-date with the project information. Returns the lock-file and any potential derived data that was computed as part of this operation.<CODESPLIT>pub async fn update_lock_file( &self, options: UpdateLockFileOptions, ) -> miette::Result<LockFileDerivedData<'_>> { self::update_lock_file(self, options).await }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>~^ WARN non-local `macro_rules!` definition<CODESPLIT>fn main() { #[macro_export] macro_rules! m { () => { } }; struct InsideMain; impl InsideMain { fn bar() { #[macro_export] macro_rules! m2 { () => { } }; } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>This fn should be called on startup. All `run_function` calls will fail if actions callbacks are not set.<CODESPLIT>fn set_action_callbacks(&self, action_callbacks: Arc<dyn ActionCallbacks>) { *self.action_callbacks.write() = Some(Arc::downgrade(&action_callbacks)); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Check for resolve collisions between a trait and its derive. These are common and we should just resolve to the trait in that case.<CODESPLIT>fn is_derive_trait_collision<T>(ns: &PerNS<Result<Vec<(Res, T)>, ResolutionFailure<'_>>>) -> bool { if let (Ok(type_ns), Ok(macro_ns)) = (&ns.type_ns, &ns.macro_ns) { type_ns.iter().any(|(res, _)| matches!(res, Res::Def(DefKind::Trait, _))) && macro_ns .iter() .any(|(res, _)| matches!(res, Res::Def(DefKind::Macro(MacroKind::Derive), _))) } else { false } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Function to wait for an input element to be focused and then using AX to fill it<CODESPLIT>pub fn autofill(value: &str, password: bool, prev: &str) -> Option<String> { unsafe { swift!( fn autofill(value: SRString, password: Bool, prev: SRString) -> Option<SRString>); autofill( SRString::from(value), Bool::from(password), SRString::from(prev), ) } .map(|s| s.to_string()) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns true if the given node has been marked as red during the current compilation session. Used in various assertions<CODESPLIT>pub fn is_red(&self, dep_node: &DepNode) -> bool { matches!(self.node_color(dep_node), Some(DepNodeColor::Red)) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>line!(): expands to the current line number<CODESPLIT>pub(crate) fn expand_line( cx: &mut ExtCtxt<'_>, sp: Span, tts: TokenStream, ) -> MacroExpanderResult<'static> { let sp = cx.with_def_site_ctxt(sp); check_zero_tts(cx, sp, tts, "line!"); let topmost = cx.expansion_cause().unwrap_or(sp); let loc = cx.source_map().lookup_char_pos(topmost.lo()); ExpandResult::Ready(MacEager::expr(cx.expr_u32(topmost, loc.line as u32))) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Gets the contract's `CallTargetStatusUpdate` event<CODESPLIT>pub fn call_target_status_update_filter( &self, ) -> ::ethers::contract::builders::Event< ::std::sync::Arc<M>, M, CallTargetStatusUpdateFilter, > { self.0.event() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>get statistics for partition NOTE: this function is not exhaustive<CODESPLIT>pub fn stats(&self) -> PartitionStats { let chunk = self.clone(); PartitionStats { block_numbers: chunk.block_numbers.map(|c| c.stats()), transactions: chunk.transactions.map(|c| c.stats()), call_datas: chunk.call_datas.map(|c| c.stats()), addresses: chunk.addresses.map(|c| c.stats()), contracts: chunk.contracts.map(|c| c.stats()), from_addresses: chunk.from_addresses.map(|c| c.stats()), to_addresses: chunk.to_addresses.map(|c| c.stats()), slots: chunk.slots.map(|c| c.stats()), topic0s: chunk.topic0s.map(|c| c.stats()), topic1s: chunk.topic1s.map(|c| c.stats()), topic2s: chunk.topic2s.map(|c| c.stats()), topic3s: chunk.topic3s.map(|c| c.stats()), } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>EMIT_MIR gvn_copy_aggregate.all_copy_move.GVN.diff<CODESPLIT>fn all_copy_move(v: AllCopy) -> AllCopy { let a = v.a; let b = v.b; let c = v.c; AllCopy { a, b, c } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Code for standard non-quantized matrix vector models.<CODESPLIT>const fn int_div_up(x: usize, y: usize) -> usize { x / y + if x % y == 0 { 0 } else { 1 } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `fulfillAdvancedOrder` (0xe7acab24) function<CODESPLIT>pub fn fulfill_advanced_order( &self, advanced_order: AdvancedOrder, criteria_resolvers: ::std::vec::Vec<CriteriaResolver>, fulfiller_conduit_key: [u8; 32], recipient: ::ethers::core::types::Address, ) -> ::ethers::contract::builders::ContractCall<M, bool> { self.0 .method_hash( [231, 172, 171, 36], ( advanced_order, criteria_resolvers, fulfiller_conduit_key, recipient, ), ) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns the [`Time`] when the [`UniqueSystemId`] was created<CODESPLIT>pub fn creation_time(&self) -> Time { Time { clock_type: ClockType::default(), seconds: self.seconds as u64, nanoseconds: self.nanoseconds, } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Gets the contract's `TokenDeposit` event<CODESPLIT>pub fn token_deposit_filter( &self, ) -> ::ethers::contract::builders::Event< ::std::sync::Arc<M>, M, TokenDepositFilter, > { self.0.event() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Set the boolean flag indicating if the HTTP request should hang until the bundle is either included, or the timeout is reached (default: false)<CODESPLIT>pub fn set_await_receipt(&mut self, await_receipt: bool) { self.echo_features .get_or_insert_with(Default::default) .await_receipt = await_receipt; }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>FIXME(blyxyas): In a future revision, we should also graph #![allow]s, but that is handled with more care<CODESPLIT>fn visit_attribute(&mut self, attribute: &'tcx ast::Attribute) { if matches!( Level::from_attr(attribute), Some( Level::Warn | Level::Deny | Level::Forbid | Level::Expect(..) | Level::ForceWarn(..), ) ) { let store = unerased_lint_store(self.tcx.sess); let Some(meta) = attribute.meta() else { return }; let Some(meta_item_list) = meta.meta_item_list() else { return }; for meta_list in meta_item_list { let Some(meta_item) = meta_list.meta_item() else { return }; let ident: &str = &meta_item .path .segments .iter() .map(|segment| segment.ident.as_str()) .collect::<Vec<&str>>() .join("::"); let Ok(lints) = store.find_lints( ident, ) else { return; }; for lint in lints { self.dont_need_to_run.swap_remove(&lint); } } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>~^ ERROR: consider implementing `TryFrom` instead<CODESPLIT>fn from(s: Option<String>) -> Invalid { let s = s.unwrap(); if !s.is_empty() { panic!("42"); } else if s.parse::<u32>().unwrap() != 42 { panic!("{:?}", s); } Invalid }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns true if an interrupt should be asserted. Interrupts should be asserted for all ATA defined IDE errors. All other errors are traced with ERROR level and no interrupt is asserted.<CODESPLIT>fn log_and_update_error(&mut self, error: IdeError, register: Option<DriveRegister>) { let ide_error = match error { IdeError::IdeBadLocation { .. } | IdeError::ZeroSector | IdeError::LbaBitNotSet => { ErrorReg::ERR_BAD_LOCATION } IdeError::IdeBadSector { .. } => ErrorReg::ERR_BAD_SECTOR, IdeError::Flush { .. } => ErrorReg::ERR_UNKNOWN_COMMAND, }; tracelimit::warn_ratelimited!( path = %self.disk_path, error = error.as_error(), ?register, "io port failure" ); self.state.regs.error = ide_error; self.state.error_pending = true; self.state.command = None; self.state.buffer = None; self.state.pending_interrupt = true; }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `name` (0x06fdde03) function<CODESPLIT>pub fn name( &self, ) -> ::ethers::contract::builders::ContractCall<M, ::std::string::String> { self.0 .method_hash([6, 253, 222, 3], ()) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Stops all submission queues and drains them of any pending IO. This future may be dropped and reissued.<CODESPLIT>pub async fn drain(&mut self) { for sq in &mut self.io_sqs { sq.task.stop().await; if let Some(state) = sq.task.state_mut() { state.drain().await; sq.task.remove(); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Keep this in sync with `Token::can_begin_literal_maybe_minus` excluding unary negation.<CODESPLIT>pub fn from_token(token: &Token) -> Option<Lit> { match token.uninterpolate().kind { Ident(name, IdentIsRaw::No) if name.is_bool_lit() => Some(Lit::new(Bool, name, None)), Literal(token_lit) => Some(token_lit), Interpolated(ref nt) if let NtExpr(expr) | NtLiteral(expr) = &**nt && let ast::ExprKind::Lit(token_lit) = expr.kind => { Some(token_lit) } _ => None, } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Read an escaped, null-terminated byte string from the input stream.<CODESPLIT>pub fn read_escaped_bytes<R: Read>(reader: &mut BytePeeker<R>) -> io::Result<Vec<u8>> { let mut out = vec![]; loop { let byte = reader.read_u8()?; if byte == TERMINATOR_BYTE { if let Some(ESCAPE_BYTE) = reader.peek()? { reader.read_u8()?; out.push(TERMINATOR_BYTE); } else { break; } } else { out.push(byte); } } Ok(out) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>... and this version does not work (the lifetime of `one` is supposed to match the lifetime `'a`) ...<CODESPLIT>fn foo<'a>(map: RefCell<HashMap<&'static str, &'a [u8]>>) { let one = [1]; assert_eq!(map.borrow().get("one"), Some(&&one[..])); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Equality up to trailing `None`s of two maps, i.e. do they represent the same mapping ?<CODESPLIT>pub fn equivalent(&self, other: &Self) -> bool { let min_len = self.data.len().min(other.data.len()); self.data[min_len..].iter().all(Option::is_none) && other.data[min_len..].iter().all(Option::is_none) && (self.data[..min_len] == other.data[..min_len]) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>convert transaction-derived data to dataframe<CODESPLIT>async fn transform_channel( mut receiver: mpsc::Receiver<R<Self::Response>>, query: &Arc<Query>, ) -> R<Self> { let mut columns = Self::default(); while let Some(message) = receiver.recv().await { match message { Ok(message) => Self::transform(message, &mut columns, query)?, Err(e) => return Err(e), } } Ok(columns) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Sets the `i`th to `j`th bits.<CODESPLIT>pub fn set_range(&mut self, range: Range<u32>) { let bits = T::FILLED .checked_shl(range.end - range.start) .unwrap_or(T::ZERO) .not() .checked_shl(range.start) .unwrap_or(T::ZERO); self.0 |= bits; }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `approve` (0x095ea7b3) function<CODESPLIT>pub fn approve( &self, to: ::ethers::core::types::Address, token_id: ::ethers::core::types::U256, ) -> ::ethers::contract::builders::ContractCall<M, ()> { self.0 .method_hash([9, 94, 167, 179], (to, token_id)) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>~ ERROR `#[start]` function is not allowed to be `#[track_caller]`<CODESPLIT>fn start(_argc: isize, _argv: *const *const u8) -> isize { panic!("{}: oh no", std::panic::Location::caller()); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Taken from `deno_core::bindings::module_origin`.<CODESPLIT>pub fn module_origin<'a>( s: &mut v8::HandleScope<'a>, resource_name: v8::Local<'a, v8::String>, ) -> v8::ScriptOrigin<'a> { let source_map_url = strings::empty.create(s).unwrap(); v8::ScriptOrigin::new( s, resource_name.into(), 0, 0, false, 0, source_map_url.into(), true, false, true, ) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>~^ ERROR cannot borrow value as mutable more than once at a time<CODESPLIT>fn f3( ref mut a @ [ [ref b @ .., _], [_, ref mut mid @ ..], .., [..], ] : [[U; 4]; 5] ) {}
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Reduce a dimension of the tensor by taking the mean of all elements along that axis.<CODESPLIT>pub fn mean_reduce(self, axes: impl ToAxes) -> GraphTensor { let reduced_elements = axes .to_axes() .into_iter() .map(|i| self.dims()[i]) .product::<Expression>(); (self / reduced_elements).sum_reduce(axes) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>@ error-pattern:can't use generic parameters from outer item<CODESPLIT>fn hd<U>(v: Vec<U> ) -> U { fn hd1(w: [U]) -> U { return w[0]; } return hd1(v); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>When a thread yields, Miri's scheduler used to pick the thread with the lowest ID that can run. IDs are assigned in thread creation order. This means we could make 2 threads infinitely ping-pong with each other while really there is a 3rd thread that we should schedule to make progress.<CODESPLIT>fn two_player_ping_pong() { static FLAG: AtomicUsize = AtomicUsize::new(0); let waiter1 = thread::spawn(|| { while FLAG.load(Ordering::Acquire) == 0 { thread::yield_now(); } }); let waiter2 = thread::spawn(|| { while FLAG.load(Ordering::Acquire) == 0 { thread::yield_now(); } }); let progress = thread::spawn(|| { FLAG.store(1, Ordering::Release); }); waiter1.join().unwrap(); waiter2.join().unwrap(); progress.join().unwrap(); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Kill the docker container. # Arguments * `name` - A container name. * `signal` - A enum value representing the signal type.<CODESPLIT>pub fn kill_container(name: &str, signal: KillportSignal) -> Result<(), Error> { let rt = Runtime::new()?; rt.block_on(async { let docker = Docker::connect_with_socket_defaults() .map_err(|e| Error::new(std::io::ErrorKind::Other, e.to_string()))?; let options = KillContainerOptions { signal: signal.to_string(), }; docker .kill_container(name, Some(options)) .await .map_err(|e| Error::new(std::io::ErrorKind::Other, e.to_string())) }) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>[min]~^ ERROR `&'static ()` is forbidden as the type of a const generic parameter [adt_const_params]~^^ ERROR `&'static ()` can't be used as a const parameter type<CODESPLIT>fn main() { const A: &'static () = unsafe { std::mem::transmute(10 as *const ()) }; let _ = Const::<{ A }>; }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Helper function that canonicalizes and runs the query. If an overflow results, we re-run it in the local context so we can report a nice error.<CODESPLIT>fn evaluate_obligation_no_overflow( &self, obligation: &PredicateObligation<'tcx>, ) -> EvaluationResult { match self.evaluate_obligation(obligation) { Ok(result) => result, Err(OverflowError::Canonical) => { let mut selcx = SelectionContext::new(self); selcx.evaluate_root_obligation(obligation).unwrap_or_else(|r| match r { OverflowError::Canonical => { span_bug!( obligation.cause.span, "Overflow should be caught earlier in standard query mode: {:?}, {:?}", obligation, r, ) } OverflowError::Error(_) => EvaluationResult::EvaluatedToErr, }) } Err(OverflowError::Error(_)) => EvaluationResult::EvaluatedToErr, } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns the result value to return for inputs `eax` and `ecx`. `default` provides the base value which is used for a missing leaf or for any bits of the result whose mask bits are clear.<CODESPLIT>pub fn result(&self, eax: u32, ecx: u32, default: &[u32; 4]) -> [u32; 4] { let mut result = *default; if let Some(x) = self.leaves.iter().find(|x| x.matches(eax, ecx)) { x.apply(&mut result); } result }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Create an assistant prompt from a chat completion request message.<CODESPLIT>fn append_assistant_message( &self, chat_history: impl AsRef<str>, message: &ChatCompletionAssistantMessage, ) -> Result<String> { let content = match message.content() { Some(content) => content.to_string(), None => match message.tool_calls().is_some() { true => String::new(), false => return Err(PromptError::NoAssistantMessage), }, }; Ok(format!( "{chat_history} <|start_header_id|>assistant<|end_header_id|>\n\n{assistant_message}<|eot_id|>", chat_history = chat_history.as_ref().trim(), assistant_message = content.trim(), )) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Like [`SyntaxMapping::upmap_child`] but for syntax elements.<CODESPLIT>pub fn upmap_child_element( &self, child: &SyntaxElement, input_ancestor: &SyntaxNode, output_ancestor: &SyntaxNode, ) -> Result<SyntaxElement, MissingMapping> { match child { SyntaxElement::Node(node) => { self.upmap_child(node, input_ancestor, output_ancestor).map(SyntaxElement::Node) } SyntaxElement::Token(token) => { let upmap_parent = self.upmap_child(&token.parent().unwrap(), input_ancestor, output_ancestor)?; let element = upmap_parent.children_with_tokens().nth(token.index()).unwrap(); debug_assert!( element.as_token().is_some_and(|it| it.kind() == token.kind()), "token upmapping mapped to the wrong node ({token:?} -> {element:?})" ); Ok(element) } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Takes a contents of a string literal (without quotes) and produces a sequence of characters or errors. NOTE: Raw strings do not perform any explicit character escaping, here we only produce errors on bare CR.<CODESPLIT>fn check_raw_common<F>(src: &str, mode: Mode, callback: &mut F) where F: FnMut(Range<usize>, Result<char, EscapeError>), { let mut chars = src.chars(); let allow_unicode_chars = mode.allow_unicode_chars(); while let Some(c) = chars.next() { let start = src.len() - chars.as_str().len() - c.len_utf8(); let res = match c { '\r' => Err(EscapeError::BareCarriageReturnInRawString), _ => ascii_check(c, allow_unicode_chars), }; let end = src.len() - chars.as_str().len(); callback(start..end, res); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Creates a new [`OwnedTable`].<CODESPLIT>pub fn try_from_iter<T: IntoIterator<Item = (Identifier, OwnedColumn<S>)>>( iter: T, ) -> Result<Self, OwnedTableError> { Self::try_new(IndexMap::from_iter(iter)) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>~^ ERROR assigning to `&T` is undefined behavior<CODESPLIT>unsafe fn generic_assign_to_ref<T>(this: &T, a: T) { *(this as *const _ as *mut _) = a; }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Create a new OutputWriter instance based on the caller's preference for colorized output and the capabilities of the terminal.<CODESPLIT>pub(crate) fn new(color: Color) -> Self { if let Some(t) = term::stdout() { if color.use_colored_tty() && t.supports_color() { return OutputWriter { terminal: Some(t) }; } } OutputWriter { terminal: None } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Return attributes with the given attribute name. Single segmented name like `#[inline]` is specified as `&["inline".to_string()]`. Multi-segmented name like `#[rustfmt::skip]` is specified as `&["rustfmt".to_string(), "skip".to_string()]`.<CODESPLIT>fn attrs_by_path(&self, attr: &[Symbol]) -> Vec<Attribute> { let def_id = self.def_id(); with(|cx| cx.get_attrs_by_path(def_id, attr)) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>dropping returned value of a function like in the following snippet is considered idiomatic, see #9482 for examples match <var> { <pat> => drop(fn_with_side_effect_and_returning_some_value()), .. }<CODESPLIT>fn is_single_call_in_arm<'tcx>(cx: &LateContext<'tcx>, arg: &'tcx Expr<'_>, drop_expr: &'tcx Expr<'_>) -> bool { if matches!(arg.kind, ExprKind::Call(..) | ExprKind::MethodCall(..)) { if let Node::Arm(Arm { body, .. }) = cx.tcx.parent_hir_node(drop_expr.hir_id) { return body.hir_id == drop_expr.hir_id; } } false }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Formats the given string based on the formatting arguments and data provided<CODESPLIT>pub fn format(&self, args: &[&dyn fmt::Display]) -> String { let mut s = String::new(); for arg in args { s.push_str(&format!("{arg} ")); } s.trim_end().to_owned() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Fetch the destination register and input operand values for an ALU instruction.<CODESPLIT>fn alu_rr(&mut self, instruction: &Instruction) -> (Register, u32, u32) { if !instruction.imm_c { let (rd, rs1, rs2) = instruction.r_type(); let c = self.rr(rs2, MemoryAccessPosition::C); let b = self.rr(rs1, MemoryAccessPosition::B); (rd, b, c) } else if !instruction.imm_b && instruction.imm_c { let (rd, rs1, imm) = instruction.i_type(); let (rd, b, c) = (rd, self.rr(rs1, MemoryAccessPosition::B), imm); (rd, b, c) } else { assert!(instruction.imm_b && instruction.imm_c); let (rd, b, c) = (Register::from_u32(instruction.op_a), instruction.op_b, instruction.op_c); (rd, b, c) } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Assumes this is only called by the thread that owns the Parker, which means that `self.state != PARKED`. This implementation doesn't require `Pin`, but other implementations do.<CODESPLIT>pub unsafe fn park_timeout(self: Pin<&Self>, timeout: Duration) { if self.state.fetch_sub(1, Acquire) == NOTIFIED { return; } futex_wait(&self.state, PARKED, Some(timeout)); if self.state.swap(EMPTY, Acquire) == NOTIFIED { } else { } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>For the overloaded place expressions (`*x`, `x[3]`), the trait returns a type of `&T`, but the actual type we assign to the *expression* is `T`. So this function just peels off the return type by one layer to yield `T`.<CODESPLIT>pub(crate) fn make_overloaded_place_return_type(&self, method: MethodCallee<'tcx>) -> Ty<'tcx> { let ret_ty = method.sig.output(); ret_ty.builtin_deref(true).unwrap() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>@ no-prefer-dynamic @ compile-flags:-g<CODESPLIT>pub fn generic_function<T: Clone>(val: T) -> (T, T) { let result = (val.clone(), val.clone()); let a_variable: u32 = 123456789; let another_variable: f64 = 123456789.5; zzz(); result }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Verifies that a buffer of bytes contains a size prefixed `FunctionCall` and returns it. Note that verification is still experimental and may not catch every error, or be maximally performant. For the previous, unchecked, behavior use `size_prefixed_root_as_function_call_unchecked`.<CODESPLIT>pub fn size_prefixed_root_as_function_call( buf: &[u8], ) -> Result<FunctionCall, flatbuffers::InvalidFlatbuffer> { flatbuffers::size_prefixed_root::<FunctionCall>(buf) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `token` (0xfc0c546a) function<CODESPLIT>pub fn token( &self, ) -> ::ethers::contract::builders::ContractCall< M, ::ethers::core::types::Address, > { self.0 .method_hash([252, 12, 84, 106], ()) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>CHECK: define{{.*}}5foo10{{.*}}!type ![[TYPE10:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}<CODESPLIT>pub fn foo11(_: &dyn FnOnce(i32) -> i32, _: &dyn FnOnce(i32) -> i32) {}
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Walk to a child, and make sure it exists.<CODESPLIT>fn walk(&self, name: &lx::LxStr) -> lx::Result<Qid> { let mut state = self.state.write(); state.path.push_lx(name)?; state.validate_exists()?; Ok(state.qid) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Turns option of iterator into an iterator (this is just flatten)<CODESPLIT>fn maybe_iter<I: Iterator>(i: Option<I>) -> impl Iterator<Item = I::Item> { i.into_iter().flatten() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Not used just yet, but allows triggering an NMI to another processor.<CODESPLIT>pub fn ipi_nmi(&self, apic_id: u32) { let shift = { 56 }; self.set_icr((u64::from(apic_id) << shift) | (1 << 14) | (0b100 << 8)); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Low-level method that assigns to a place. This does nothing if the place is not tracked. The target place must have been flooded before calling this method.<CODESPLIT>fn insert_idx(&mut self, target: PlaceIndex, result: ValueOrPlace<V>, map: &Map<'_>) { match result { ValueOrPlace::Value(value) => self.insert_value_idx(target, value, map), ValueOrPlace::Place(source) => self.insert_place_idx(target, source, map), } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Write the NatVis debugger visualizer files for each crate to the temp directory and gather the file paths.<CODESPLIT>fn collect_natvis_visualizers( tmpdir: &Path, sess: &Session, crate_name: &Symbol, natvis_debugger_visualizers: &BTreeSet<DebuggerVisualizerFile>, ) -> Vec<PathBuf> { let mut visualizer_paths = Vec::with_capacity(natvis_debugger_visualizers.len()); for (index, visualizer) in natvis_debugger_visualizers.iter().enumerate() { let visualizer_out_file = tmpdir.join(format!("{}-{}.natvis", crate_name.as_str(), index)); match fs::write(&visualizer_out_file, &visualizer.src) { Ok(()) => { visualizer_paths.push(visualizer_out_file); } Err(error) => { sess.dcx().emit_warn(errors::UnableToWriteDebuggerVisualizer { path: visualizer_out_file, error, }); } }; } visualizer_paths }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `getConduit` (0x6e9bfd9f) function<CODESPLIT>pub fn get_conduit( &self, conduit_key: [u8; 32], ) -> ::ethers::contract::builders::ContractCall< M, (::ethers::core::types::Address, bool), > { self.0 .method_hash([110, 155, 253, 159], conduit_key) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>S<&'a T> is in the return type, so we get an implied bound &'a T: 'static<CODESPLIT>fn foo<'a, T>(x: &'a T) -> (S<&'a T>, Box<dyn Any + 'static>) { let y = S(x); let z = Box::new(y.clone()) as Box<dyn Any + 'static>; (y, z) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Call this on things you got out of the MIR (so it is as generic as the provided stack frame), to bring it into the proper environment for this interpreter.<CODESPLIT>pub(super) fn instantiate_from_frame_and_normalize_erasing_regions< T: TypeFoldable<TyCtxt<'tcx>>, >( &self, frame: &Frame<'tcx, M::Provenance, M::FrameExtra>, value: T, ) -> Result<T, ErrorHandled> { frame .instance .try_instantiate_mir_and_normalize_erasing_regions( *self.tcx, self.typing_env, ty::EarlyBinder::bind(value), ) .map_err(|_| ErrorHandled::TooGeneric(self.cur_span())) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Helper method to interpret `target = result`.<CODESPLIT>pub fn assign(&mut self, target: PlaceRef<'_>, result: ValueOrPlace<V>, map: &Map<'_>) where V: HasTop, { self.flood(target, map); if let Some(target) = map.find(target) { self.insert_idx(target, result, map); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Pretends to be expensive finding a suitable bin for the layout.<CODESPLIT>fn find_bin(&self, layout: Layout) -> Option<&MyBin> { if layout == Layout::new::<usize>() { Some(&self.bins[0]) } else { None } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>FIXME: Find a better way to know if it is a dylib.<CODESPLIT>fn is_dylib(path: &Utf8Path) -> bool { match path.extension().map(|e| e.to_owned().to_lowercase()) { None => false, Some(ext) => matches!(ext.as_str(), "dll" | "dylib" | "so"), } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>@ run-fail @ error-pattern:index out of bounds: the len is 1 but the index is 2 @ ignore-emscripten no processes<CODESPLIT>fn main() { let v: Vec<isize> = vec![10]; let x: usize = 0; assert_eq!(v[x], 10); assert_eq!(v[x + 2], 20); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Make sure that with -Zmiri-retag-fields=scalar, we do *not* retag the fields of `Newtype`.<CODESPLIT>fn main() { let ptr = Box::into_raw(Box::new(0i32)); #[rustfmt::skip] unsafe { dealloc_while_running( Newtype(&mut *ptr, 0, 0), || drop(Box::from_raw(ptr)), ) }; }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Creates a new empty [`FixedSizeIndexQueue`].<CODESPLIT>pub fn new() -> Self { let mut new_self = Self { state: unsafe { RelocatableIndexQueue::new_uninit(CAPACITY) }, data: core::array::from_fn(|_| UnsafeCell::new(0)), }; let allocator = BumpAllocator::new(core::ptr::addr_of!(new_self.data) as usize); unsafe { new_self .state .init(&allocator) .expect("All required memory is preallocated.") }; new_self }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT># Panics Will panic if: - `self.column_mapping.get(alias)` returns `None`, which can occur if the alias is not found in the column mapping.<CODESPLIT>pub fn add_result_columns(mut self, columns: &[EnrichedExpr]) -> Self { let mut has_nonprovable_column = false; for enriched_expr in columns { if let Some(plan) = &enriched_expr.dyn_proof_expr { self.filter_result_expr_list.push(AliasedDynProofExpr { expr: plan.clone(), alias: enriched_expr.residue_expression.alias, }); } else { has_nonprovable_column = true; } } if has_nonprovable_column { for alias in self.column_mapping.keys().sorted() { let column_ref = self.column_mapping.get(alias).unwrap(); self.filter_result_expr_list.push(AliasedDynProofExpr { expr: DynProofExpr::new_column(*column_ref), alias: *alias, }); } } self }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Gets a handle to the thread that invokes it, if the handle has been initialized.<CODESPLIT>pub(crate) fn try_current() -> Option<Thread> { let current = CURRENT.get(); if current > DESTROYED { unsafe { let current = ManuallyDrop::new(Thread::from_raw(current)); Some((*current).clone()) } } else { None } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Set the length of source cid. Applicable to Endpoint only.<CODESPLIT>pub fn set_cid_len(&mut self, v: usize) { self.cid_len = cmp::min(v, MAX_CID_LEN); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Return `Some(..)` with the `DefId` of this `Res` if it has a ID, else `None`.<CODESPLIT>pub fn opt_def_id(&self) -> Option<DefId> { match *self { Res::Def(_, id) => Some(id), Res::Local(..) | Res::PrimTy(..) | Res::SelfTyParam { .. } | Res::SelfTyAlias { .. } | Res::SelfCtor(..) | Res::ToolMod | Res::NonMacroAttr(..) | Res::Err => None, } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>~^ ERROR: 8 bindings with single-character names in scope<CODESPLIT>fn bindings2() { let (a, b, c, d, e, f, g, h): (bool, bool, bool, bool, bool, bool, bool, bool) = unimplemented!(); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>W (d,n) @ x (n,) -> xout (d,) by far the most amount of time is spent inside this little function Rust note: par_iter_mut is from the RAYON library. It run in parallel. Rust note: x is passed by reference, xout as mutiple reference.<CODESPLIT>pub fn matvec<const B: usize>(self: &Self, xout: &mut [[f32; OUT]; B], x: &[[f32; IN]; B]) { for (xout, x) in xout.iter_mut().zip(x) { xout.par_iter_mut().enumerate().for_each(|(i, v)| { *v = self.w[i] .iter() .zip(x.iter()) .fold(0.0, |acc, (&_w, &_x)| acc + _w * _x); }); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>`'a == 'b` so `*mut &'a i32` is fine as the return type<CODESPLIT>fn equal_regions_inv_rev<'a: 'b, 'b: 'a>(x: *mut &'a i32) -> impl Sized + 'b { let y: *mut &'a i32 = x; let z: *mut &'b i32 = y; x }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>~^ NOTE required by a bound ~| NOTE required by a bound ~| NOTE required by this bound ~| NOTE required by this bound<CODESPLIT>fn make_non_send_coroutine() -> impl Coroutine<Return = Arc<RefCell<i32>>> { make_gen1(Arc::new(RefCell::new(0))) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>We should evaluate `*x` and copy the value out *before* evaluating the LHS and dropping `x`.<CODESPLIT>fn evaluate_fru_to_temp_before_assign_box() { let x = Box::new(S(0)); let y = &mut S(1); *{ drop(x); &mut *y } = S { ..*x }; assert_eq!(0, y.0); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Converts a variable to bits inside a circuit.<CODESPLIT>pub fn num2bits_v_circuit(&mut self, num: Var<C::N>, bits: usize) -> Vec<Var<C::N>> { let mut output = Vec::new(); for _ in 0..bits { output.push(self.uninit()); } self.push_op(DslIr::CircuitNum2BitsV(num, bits, output.clone())); output }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>CHECK-LABEL: @wider_reduce_into_iter<CODESPLIT>pub fn wider_reduce_into_iter(x: Simd<u8, N>) -> u16 { x.to_array().into_iter().map(u16::from).sum() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>This returns `Vec` because a module may be included from several places.<CODESPLIT>pub(crate) fn crates_for(db: &RootDatabase, file_id: FileId) -> Vec<CrateId> { db.relevant_crates(file_id) .iter() .copied() .filter(|&crate_id| db.crate_def_map(crate_id).modules_for_file(file_id).next().is_some()) .sorted() .collect() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Like above. FIXME(#51525) -- the shorter notation `T::Assoc` winds up referencing `'static` here<CODESPLIT>fn foo2_pass<'a, T: Trait<'a, Assoc = ()> + 'a>() -> impl FooLike<Output = <T as Trait<'a>>::Assoc> + 'a { Foo(()) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Remove dependencies from the project. Returns a [`RemoveBuilder`].<CODESPLIT>pub fn remove(&self, spec: &str) -> RemoveBuilder { RemoveBuilder { args: remove::Args { project_config: ProjectConfig { manifest_path: Some(self.manifest_path()), }, dependency_config: AddBuilder::dependency_config_with_specs(vec![spec]), prefix_update_config: PrefixUpdateConfig { no_lockfile_update: false, no_install: true, lock_file_usage: LockFileUsageArgs::default(), config: Default::default(), revalidate: false, }, }, } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Try returning an immediate for the operand. If the layout does not permit loading this as an immediate, return where in memory we can find the data. Note that for a given layout, this operation will either always return Left or Right! succeed! Whether it returns Left depends on whether the layout can be represented in an `Immediate`, not on which data is stored there currently. This is an internal function that should not usually be used; call `read_immediate` instead. ConstProp needs it, though.<CODESPLIT>pub fn read_immediate_raw( &self, src: &impl Projectable<'tcx, M::Provenance>, ) -> InterpResult<'tcx, Either<MPlaceTy<'tcx, M::Provenance>, ImmTy<'tcx, M::Provenance>>> { interp_ok(match src.to_op(self)?.as_mplace_or_imm() { Left(ref mplace) => { if let Some(val) = self.read_immediate_from_mplace_raw(mplace)? { Right(val) } else { Left(mplace.clone()) } } Right(val) => Right(val), }) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Formatting requests should never block on waiting a for task thread to open up, editors will wait on the response and a late formatting update might mess with the document and user. We can't run this on the main thread though as we invoke rustfmt which may take arbitrary time to complete!<CODESPLIT>pub(crate) fn on_fmt_thread<R>( &mut self, f: fn(GlobalStateSnapshot, R::Params) -> anyhow::Result<R::Result>, ) -> &mut Self where R: lsp_types::request::Request + 'static, R::Params: DeserializeOwned + panic::UnwindSafe + Send + fmt::Debug, R::Result: Serialize, { self.on_with_thread_intent::<false, false, R>( ThreadIntent::LatencySensitive, f, Self::content_modified_error, ) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Creates a new content. If it contains invalid characters or exceeds the maximum supported length of the system or contains illegal strings it fails.<CODESPLIT>fn new(value: &[u8]) -> Result<Self, SemanticStringError> { let msg = "Unable to create SemanticString"; let origin = "SemanticString::new()"; let mut new_self = unsafe { <Self as internal::SemanticStringAccessor<CAPACITY>>::new_empty() }; fail!(from origin, when new_self.push_bytes(value), "{} due to an invalid value \"{}\".", msg, as_escaped_string(value)); Ok(new_self) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `balanceOf` (0x70a08231) function<CODESPLIT>pub fn balance_of( &self, p0: ::ethers::core::types::Address, ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::U256> { self.0 .method_hash([112, 160, 130, 49], p0) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Gets a fixed version of the array.<CODESPLIT>pub fn vec(&self) -> Vec<V> { match self { Self::Fixed(vec) => vec.clone(), _ => panic!("array is dynamic, not fixed"), } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>NOTE: This constructor should only be used when converting from protos. Otherwise, prefer the [`FromStr`] implementation since it includes validation.<CODESPLIT>pub fn new( path: PathBuf, is_system: bool, is_deps: bool, is_http: bool, is_cron: bool, ) -> Self { Self { path, is_system, is_deps, is_http, is_cron, } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>EMIT_MIR try_identity.new.PreCodegen.after.mir<CODESPLIT>fn new<T, E>(x: Result<T, E>) -> Result<T, E> { Ok( match { match x { Ok(v) => ControlFlow::Continue(v), Err(e) => ControlFlow::Break(e), } } { ControlFlow::Continue(v) => v, ControlFlow::Break(e) => return Err(e), }, ) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Called for `Rvalue::Repeat` when the elem is neither a ZST nor optimizable using memset.<CODESPLIT>fn write_operand_repeatedly( &mut self, cg_elem: OperandRef<'tcx, Self::Value>, count: u64, dest: PlaceRef<'tcx, Self::Value>, ) { let zero = self.const_usize(0); let start = dest.project_index(self, zero).val.llval; let elem_layout = dest.layout.field(self.cx(), 0); let elem_ty = elem_layout.spirv_type(self.span(), self); let align = dest.val.align.restrict_for_offset(elem_layout.size); for i in 0..count { let current = self.inbounds_gep(elem_ty, start, &[self.const_usize(i)]); cg_elem.val.store( self, PlaceRef::new_sized_aligned(current, cg_elem.layout, align), ); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Asynchronously updates the value in the associated cells.<CODESPLIT>pub fn set(&mut self, value: T) -> impl '_ + Future<Output = ()> + Unpin { self.send_value(value); self.process_incoming() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>create a tool prompt from a chat completion request message.<CODESPLIT>fn append_tool_message( &self, chat_history: impl AsRef<str>, message: &ChatCompletionToolMessage, ) -> String { format!( "{chat_history}\n<extra_id_1>Tool\n{tool_message}", chat_history = chat_history.as_ref().trim(), tool_message = message.content().trim(), ) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Treat this page table as a page table of a given level, and locate the entry corresponding to a va.<CODESPLIT>pub fn entry(&mut self, gva: u64, level: u8) -> &mut PageTableEntry { let index = get_amd64_pte_index(gva, level as u64) as usize; &mut self.entries[index] }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Attempt to create a new client by connecting to a given endpoint.<CODESPLIT>pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error> where D: TryInto<tonic::transport::Endpoint>, D::Error: Into<StdError>, { let conn = tonic::transport::Endpoint::new(dst)?.connect().await?; Ok(Self::new(conn)) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Gets the current GPA of the monitor page, or None if no monitor page is in use.<CODESPLIT>pub fn gpa(&self) -> Option<u64> { let gpa = self.gpa.load(Ordering::Relaxed); (gpa != INVALID_MONITOR_GPA).then_some(gpa) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Get a list of all available audio devices.<CODESPLIT>pub fn get_devices() -> Result<Vec<(String, rodio::Device)>> { Ok(rodio::cpal::default_host() .output_devices()? .map(|d| (d.name().unwrap_or("Unknown".to_string()), d)) .collect()) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>If `sampling_rate` is not in the range `0.0...1.0`, it will return an error with the kind `ErrorKind::InvalidInput`.<CODESPLIT>pub(crate) fn new(settings: &ActiveSamplingSettings) -> Result<Self> { let rate_limiter = if settings.rate_limit.enabled { settings .rate_limit .max_events_per_second .try_into() .ok() .map(|r| RateLimiter::direct(Quota::per_second(r))) } else { None }; Ok(Self { inner: ProbabilisticSampler::new(settings.sampling_ratio)?, rate_limiter, }) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `getSellNFTQuote` (0x0c295e56) function<CODESPLIT>pub fn get_sell_nft_quote( &self, num_nf_ts: ::ethers::core::types::U256, ) -> ::ethers::contract::builders::ContractCall< M, ( u8, ::ethers::core::types::U256, ::ethers::core::types::U256, ::ethers::core::types::U256, ::ethers::core::types::U256, ), > { self.0 .method_hash([12, 41, 94, 86], num_nf_ts) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Compute the evaluations of the columns of the matrix M that is derived from `a`. In this context `hi_vec` is the left `L` vector in the vector-matrix-vector product LMR. `1 << nu` is the side length of M. # Panics This function requires that `hi_vec` has length at least as big as the number of rows in `M` that is created by `a`. In practice, `hi_vec` is normally length `1 << nu`.<CODESPLIT>pub(super) fn compute_dynamic_v_vec(a: &[F], hi_vec: &[F], nu: usize) -> Vec<F> { a.iter() .enumerate() .fold(vec![F::ZERO; 1 << nu], |mut v_vec, (i, v)| { let (row, column) = row_and_column_from_index(i); v_vec[column] += hi_vec[row] * v; v_vec }) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `targetArtifactSelectors` (0x66d9a9a0) function<CODESPLIT>pub fn target_artifact_selectors( &self, ) -> ::ethers::contract::builders::ContractCall< M, ::std::vec::Vec<FuzzSelector>, > { self.0 .method_hash([102, 217, 169, 160], ()) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Adds a finalizer record into an `Echo` kind of resource. If the finalizer already exists, this action has no effect. # Arguments: - `client` - Kubernetes client to modify the `Echo` resource with. - `name` - Name of the `Echo` resource to modify. Existence is not verified - `namespace` - Namespace where the `Echo` resource with given `name` resides. Note: Does not check for resource's existence for simplicity.<CODESPLIT>pub async fn add(client: Client, name: &str, namespace: &str) -> Result<Bionic, Error> { let api: Api<Bionic> = Api::namespaced(client, namespace); let finalizer: Value = json!({ "metadata": { "finalizers": ["bionics.bionic-gpt.com/finalizer"] } }); let patch: Patch<&Value> = Patch::Merge(&finalizer); api.patch(name, &PatchParams::default(), &patch).await }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Parse the program from a list of tokens.<CODESPLIT>pub fn parse(tokens: Vec<TokenWithContext>) -> Result<Self, Error> { let mut iter = tokens.into_iter().peekable(); let mut statements = vec![]; while iter.peek().is_some() { let statement = Statement::parse(&mut iter)?; statements.push(statement); } Ok(Program { statements }) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Create a new request from the specified data.<CODESPLIT>pub fn new(mut reader: impl RequestReader) -> lx::Result<Self> { let header: fuse_in_header = reader.read_type()?; let operation = Self::read_operation(&header, reader); Ok(Self { header, operation }) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Write to the file descriptor the whole contents of byte stream Vec.<CODESPLIT>fn send_message(&mut self, buf: Vec<u8>) { self.pipe_channels .message_send .send(WriteRequest::Message(buf)); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Verify that we do not merge fn pointers created by casts.<CODESPLIT>fn fn_pointers() { let f = identity as fn(u8) -> u8; opaque(f); let g = identity as fn(u8) -> u8; opaque(g); let closure = || {}; let cf = closure as fn(); opaque(cf); let cg = closure as fn(); opaque(cg); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `getSellNFTQuote` (0x0c295e56) function<CODESPLIT>pub fn get_sell_nft_quote( &self, num_nf_ts: ::ethers::core::types::U256, ) -> ::ethers::contract::builders::ContractCall< M, ( u8, ::ethers::core::types::U256, ::ethers::core::types::U256, ::ethers::core::types::U256, ::ethers::core::types::U256, ), > { self.0 .method_hash([12, 41, 94, 86], num_nf_ts) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Adding a type annotation used to change how MIR is generated, make sure we cover both cases.<CODESPLIT>fn dangling_let_type_annotation() { unsafe { let ptr = ptr::without_provenance::<bool>(0x40); let _: bool = *ptr; } unsafe { let ptr = ptr::without_provenance::<!>(0x40); let _: ! = *ptr; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>The path at `binding_place` is a binding that is being initialized. This covers cases such as `let x = 42;`<CODESPLIT>fn bind(&mut self, binding_place: &PlaceWithHirId<'tcx>, diag_expr_id: HirId) { self.mutate(binding_place, diag_expr_id) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>~^ ERROR invalid type for `const` operand<CODESPLIT>fn main() { unsafe { asm!("{}", const 0); asm!("{}", const 0i32); asm!("{}", const 0i128); asm!("{}", const 0f32); asm!("{}", const 0 as *mut u8); asm!("{}", const &0); let x = 0; const fn const_foo(x: i32) -> i32 { x } const fn const_bar<T>(x: T) -> T { x } asm!("{}", const x); asm!("{}", const const_foo(0)); asm!("{}", const const_foo(x)); asm!("{}", const const_bar(0)); asm!("{}", const const_bar(x)); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Gets the transaction receipt with transaction_hash<CODESPLIT>pub async fn get_transaction_receipt( &self, tx_hash: TxHash, ) -> Result<Option<TransactionReceipt>> { let _permit = self.permit_request().await; Self::map_err(source_provider!(self, get_transaction_receipt(tx_hash)).await) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `changeDelta` (0x6809f664) function<CODESPLIT>pub fn change_delta( &self, new_delta: u128, ) -> ::ethers::contract::builders::ContractCall<M, ()> { self.0 .method_hash([104, 9, 246, 100], new_delta) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Make sure we do not have bad enum layout optimizations.<CODESPLIT>fn rust_issue_68303() { let optional = Some(RefCell::new(false)); let mut handle = optional.as_ref().unwrap().borrow_mut(); assert!(optional.is_some()); *handle = true; }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Finds the first occurrence of a byte string in the given string. If the byte string was found the start position of the byte string is returned, otherwise [`None`].<CODESPLIT>pub fn find(&self, bytes: &[u8]) -> Option<usize> { if self.len() < bytes.len() { return None; } for i in 0..self.len() - bytes.len() + 1 { let mut has_found = true; for (n, byte) in bytes.iter().enumerate() { if unsafe { *self.data[i + n].as_ptr() } != *byte { has_found = false; break; } } if has_found { return Some(i); } } None }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Create a new [`SemanticChunker`].<CODESPLIT>pub const fn new() -> Self { Self { target_score: 0.65, small_chunk_merge_bonus: 10.0, small_chunk_exponent: -2.0, large_chunk_penalty: 200.0, large_chunk_exponent: 1.5, } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns a text range which declares this module, either a `mod foo;` or a `mod foo {}`. `None` for the crate root.<CODESPLIT>pub fn declaration_source_range(self, db: &dyn HirDatabase) -> Option<InFile<TextRange>> { let def_map = self.id.def_map(db.upcast()); def_map[self.id.local_id].declaration_source_range(db.upcast()) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>A version of `self.size_align_of` which returns error if the type is unsized. `what` argument should be something that complete this: `error: type {ty} was unsized. {what} should be sized`<CODESPLIT>fn size_align_of_sized( &self, ty: &Ty, locals: &Locals, what: &'static str, ) -> Result<(usize, usize)> { match self.size_align_of(ty, locals)? { Some(it) => Ok(it), None => Err(MirEvalError::TypeIsUnsized(ty.clone(), what)), } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Creates a new [TransformerPipeline] # Arguments * `task` - The task to run * `model` - The model to use * `args` - The arguments to pass to the task * `database_url` - The database url to use. If None, the `PGML_DATABASE_URL` environment variable will be used<CODESPLIT>pub fn new(task: &str, model: &str, args: Option<Json>, database_url: Option<String>) -> Self { let mut args = args.unwrap_or_default(); let a = args.as_object_mut().expect("args must be an object"); a.insert("task".to_string(), task.to_string().into()); a.insert("model".to_string(), model.into()); for field in ["gpu_layers"] { if let Some(v) = a.remove(field) { let x: u64 = CustomU64Convertor(v).into(); a.insert(field.to_string(), x.into()); } } Self { task: args, database_url, } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Replaces a region in a file delimited by two lines matching regexes. `path` is the relative path to the file on which you want to perform the replacement. See `replace_region_in_text` for documentation of the other options. # Panics Panics if the path could not read or then written<CODESPLIT>fn replace_region_in_file( update_mode: UpdateMode, path: &Path, start: &str, end: &str, write_replacement: impl FnMut(&mut String), ) { let contents = fs::read_to_string(path).unwrap_or_else(|e| panic!("Cannot read from `{}`: {e}", path.display())); let new_contents = match replace_region_in_text(&contents, start, end, write_replacement) { Ok(x) => x, Err(delim) => panic!("Couldn't find `{delim}` in file `{}`", path.display()), }; match update_mode { UpdateMode::Check if contents != new_contents => exit_with_failure(), UpdateMode::Check => (), UpdateMode::Change => { if let Err(e) = fs::write(path, new_contents.as_bytes()) { panic!("Cannot write to `{}`: {e}", path.display()); } }, } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns whether `path` contains a placeholder, but ignores any placeholders within type arguments.<CODESPLIT>fn path_contains_placeholder(&self, path: &ast::Path) -> bool { if let Some(segment) = path.segment() { if let Some(name_ref) = segment.name_ref() { if self.placeholders_by_stand_in.contains_key(name_ref.text().as_str()) { return true; } } } if let Some(qualifier) = path.qualifier() { return self.path_contains_placeholder(&qualifier); } false }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Gets a channel by guest channel ID.<CODESPLIT>fn get_by_channel_id_mut( &mut self, assigned_channels: &AssignedChannels, channel_id: ChannelId, ) -> Result<(OfferId, &mut Channel), ChannelError> { let offer_id = assigned_channels .get(channel_id) .ok_or(ChannelError::UnknownChannelId)?; let channel = &mut self[offer_id]; if channel.state.is_released() { return Err(ChannelError::ChannelReleased); } assert_eq!( channel.info.as_ref().map(|info| info.channel_id), Some(channel_id) ); Ok((offer_id, channel)) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>One-time runtime cleanup. Runs after `main` or at program exit. NOTE: this is not guaranteed to run, for example when the program aborts.<CODESPLIT>pub(crate) fn cleanup() { static CLEANUP: Once = Once::new(); CLEANUP.call_once(|| unsafe { crate::io::cleanup(); sys::cleanup(); }); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>because of `x`, it is implied that `'b: 'a` holds<CODESPLIT>fn implied_bounds_subset<'a, 'b>(x: &'a &'b mut u32) -> &'a u32 { x }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>~^ ERROR the size for values of type ~| ERROR the size for values of type<CODESPLIT>fn main() { println!("{:?} {:?} {:?} {:?}", &CONST_0, &CONST_FOO, &STATIC_1, &STATIC_BAR); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>If the project has any source dependencies, like `git` or `path` dependencies. for pypi dependencies, we need to limit the solve to 1, because of uv internals<CODESPLIT>fn determine_pypi_solve_permits(project: &Project) -> usize { let environments = project.environments(); for environment in environments { for (_, req) in environment.pypi_dependencies(None).iter() { for dep in req { if dep.is_direct_dependency() { return 1; } } } } default_max_concurrent_solves() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>CHECK-LABEL: @unsigned_cmp CHECK-SAME: (i16{{.*}} %a, i16{{.*}} %b)<CODESPLIT>pub fn unsigned_cmp(a: u16, b: u16) -> std::cmp::Ordering { three_way_compare(a, b) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>=== === === Descriptions === === ===<CODESPLIT>pub fn get_description(&mut self, book_id: i32) -> Result<Option<String>, ()> { use crate::schema::comments::dsl::*; let mut connection = self.client.lock().unwrap(); comments .filter(book.eq(book_id)) .select(text) .first(&mut *connection) .optional() .or(Err(())) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Lint a `match` or `if let .. { .. } else { .. }` expr that could be replaced by `matches!`<CODESPLIT>pub(crate) fn check_if_let<'tcx>( cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, let_pat: &'tcx Pat<'_>, let_expr: &'tcx Expr<'_>, then_expr: &'tcx Expr<'_>, else_expr: &'tcx Expr<'_>, ) { find_matches_sugg( cx, let_expr, IntoIterator::into_iter([ (&[][..], Some(let_pat), then_expr, None), (&[][..], None, else_expr, None), ]), expr, true, ); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Gets the contract's `SpotPriceUpdate` event<CODESPLIT>pub fn spot_price_update_filter( &self, ) -> ::ethers::contract::builders::Event< ::std::sync::Arc<M>, M, SpotPriceUpdateFilter, > { self.0.event() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Convert the Tlopen flags to Linux open flags.<CODESPLIT>fn open_flags_to_o_flags(flags: u32) -> i32 { let mut result = (flags & !OPEN_FLAG_DIRECTORY) as i32; if flags & OPEN_FLAG_DIRECTORY != 0 { result |= lx::O_DIRECTORY; } result }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Neither of the uninits below are currently accepted as not UB, however, this code does not run and is merely checking that we do not ICE on this pattern, so this is fine.<CODESPLIT>fn foo<const SIZE: usize>() { let arr: [u8; SIZE] = unsafe { #[allow(deprecated)] let array: [u8; SIZE] = mem::uninitialized(); array }; }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Think: `iter.all( * is certain * )`<CODESPLIT>pub fn meet(iter: impl Iterator<Item = Certainty>) -> Certainty { iter.fold(Certainty::Certain(None), Certainty::meet) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>find relevant `ast::Expr` for reference # Preconditions `node` must cover `reference`, that is `node.text_range().contains_range(reference.range)`<CODESPLIT>fn path_element_of_reference( node: &dyn HasTokenAtOffset, reference: &FileReference, ) -> Option<ast::Expr> { let token = node.token_at_offset(reference.range.start()).right_biased().or_else(|| { stdx::never!(false, "cannot find token at variable usage: {:?}", reference); None })?; let path = token.parent_ancestors().find_map(ast::Expr::cast).or_else(|| { stdx::never!(false, "cannot find path parent of variable usage: {:?}", token); None })?; stdx::always!( matches!(path, ast::Expr::PathExpr(_) | ast::Expr::MacroExpr(_)), "unexpected expression type for variable usage: {:?}", path ); Some(path) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `fee` (0xddca3f43) function<CODESPLIT>pub fn fee(&self) -> ::ethers::contract::builders::ContractCall<M, u128> { self.0 .method_hash([221, 202, 63, 67], ()) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Gets a store buffer associated with an atomic object in this allocation. Returns `None` if there is no store buffer.<CODESPLIT>fn get_store_buffer<'tcx>( &self, range: AllocRange, ) -> InterpResult<'tcx, Option<Ref<'_, StoreBuffer>>> { let access_type = self.store_buffers.borrow().access_type(range); let pos = match access_type { AccessType::PerfectlyOverlapping(pos) => pos, // If there is nothing here yet, that means there wasn't an atomic write yet so _ => return interp_ok(None), }; let store_buffer = Ref::map(self.store_buffers.borrow(), |buffer| &buffer[pos]); interp_ok(Some(store_buffer)) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Creates a new `FdReady` for the given file descriptor and initiator.<CODESPLIT>pub fn new(initiator: T, fd: RawFd) -> Self { FdReady { fd, initiator, interests: Default::default(), } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Ensure that unsizable fields that might be accessed don't get reordered<CODESPLIT>fn nonzero_size() { let sized: (u8, [u32; 2]) = (123, [456, 789]); let unsize: &(u8, [u32]) = &sized; assert_eq!(unsize.0, 123); assert_eq!(unsize.1.len(), 2); assert_eq!(unsize.1[0], 456); assert_eq!(unsize.1[1], 789); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>If `include_nonconstraining` is false, returns the list of parameters that are constrained by `value` - i.e., the value of each parameter in the list is uniquely determined by `value` (see RFC 447). If it is true, return the list of parameters whose values are needed in order to constrain `value` - these differ, with the latter being a superset, in the presence of projections.<CODESPLIT>pub(crate) fn parameters_for<'tcx>( tcx: TyCtxt<'tcx>, value: impl TypeFoldable<TyCtxt<'tcx>>, include_nonconstraining: bool, ) -> Vec<Parameter> { let mut collector = ParameterCollector { parameters: vec![], include_nonconstraining }; let value = if !include_nonconstraining { tcx.expand_weak_alias_tys(value) } else { value }; value.visit_with(&mut collector); collector.parameters }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Add a new set of predicates to the caller_bounds of an existing param_env.<CODESPLIT>fn augment_param_env<'tcx>( tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>, new_predicates: Option<&FxIndexSet<ty::Clause<'tcx>>>, ) -> ty::ParamEnv<'tcx> { let Some(new_predicates) = new_predicates else { return param_env; }; if new_predicates.is_empty() { return param_env; } let bounds = tcx.mk_clauses_from_iter( param_env.caller_bounds().iter().chain(new_predicates.iter().cloned()), ); ty::ParamEnv::new(bounds, param_env.reveal()) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Make an association between a sub-expression and an extended lifetime<CODESPLIT>pub fn record_rvalue_scope(&mut self, var: hir::ItemLocalId, lifetime: Option<Scope>) { debug!("record_rvalue_scope(var={var:?}, lifetime={lifetime:?})"); if let Some(lifetime) = lifetime { assert!(var != lifetime.item_local_id()); } self.map.insert(var, lifetime); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Get around the limitations of CTFE in today's Rust.<CODESPLIT>const fn choice_u64(c: bool, a: u64, b: u64) -> u64 { (-(c as i64) as u64) & a | (-(!c as i64) as u64) & b }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns `true` if types `a` and `b` are same types having same `Const` generic args, otherwise returns `false`<CODESPLIT>pub fn same_type_and_consts<'tcx>(a: Ty<'tcx>, b: Ty<'tcx>) -> bool { match (&a.kind(), &b.kind()) { (&ty::Adt(did_a, args_a), &ty::Adt(did_b, args_b)) => { if did_a != did_b { return false; } args_a .iter() .zip(args_b.iter()) .all(|(arg_a, arg_b)| match (arg_a.unpack(), arg_b.unpack()) { (GenericArgKind::Const(inner_a), GenericArgKind::Const(inner_b)) => inner_a == inner_b, (GenericArgKind::Type(type_a), GenericArgKind::Type(type_b)) => { same_type_and_consts(type_a, type_b) }, _ => true, }) }, _ => a == b, } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `changeSpotPrice` (0xd8a1890c) function<CODESPLIT>pub fn change_spot_price( &self, new_spot_price: u128, ) -> ::ethers::contract::builders::ContractCall<M, ()> { self.0 .method_hash([216, 161, 137, 12], new_spot_price) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>@ compile-flags: -Z unpretty=stable-mir --crate-type lib -C panic=abort @ check-pass @ only-x86_64 @ needs-unwind unwind edges are different with panic=abort ! Check how stable mir pretty printer prints different operands and abort strategy.<CODESPLIT>pub fn operands(val: u8) { let array = [val; 10]; let first = array[0]; let last = array[10 - 1]; assert_eq!(first, last); let reference = &first; let dereferenced = *reference; assert_eq!(dereferenced, first); let tuple = (first, last); let (first_again, _) = tuple; let first_again_again = tuple.0; assert_eq!(first_again, first_again_again); let length = array.len(); let size_of = std::mem::size_of_val(&length); assert_eq!(length, size_of); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Reads guest memory and logs the boot status to the host.<CODESPLIT>pub(crate) fn event_log_flush(&mut self, data: u32) { if let Err(err) = self .service .event_log .event_log_flush_inner(data.into(), &self.gm) { tracelimit::error_ratelimited!( error = &err as &dyn std::error::Error, "event log flush error" ); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Is the interval `(-inf, end)` disjoint with `[start, +inf)`?<CODESPLIT>pub fn is_disjoint(&self, start: &Start) -> bool { match (self, start) { (End::Unbounded, _) => false, (End::Excluded(ref s), Start::Included(ref t)) => s <= t, } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>shr shl sal rol ror rcl rcr rm, 1 imm cl<CODESPLIT>pub(super) async fn shift_sign_unextended<Op: ShiftingOp>( &mut self, instr: &Instruction, ) -> Result<(), InternalError<T::Error>> { let left = self.op_value(instr, 0).await?; self.shift::<Op>(instr, left, 1).await }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Get a source CID requiring to be advertised to the peer through the NEW_CONNECTION_ID frame, if any.<CODESPLIT>pub fn next_scid_to_advertise(&self) -> Option<u64> { self.scids_to_advertise.front().copied() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Check that we can mutate when one deref is required<CODESPLIT>fn mut_ref_1() { let mut x = String::new(); let rx = &mut x; let mut c = || { *rx = String::new(); }; c(); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Sums the puts and gets in the windows that are contained in the lookback. Partially continued windows are excluded. The lookback starts from the start of the active window, so the active window is not included in the sum.<CODESPLIT>fn sum_windows( windows: &VecDeque<Window>, lookback: Duration, ) -> Option<(Range<Instant>, u64, u64)> { let mut puts = 0; let mut gets = 0; let mut windows_iter = windows.iter(); let active_window = windows_iter.next(); let mut range = if let Some(window) = active_window { (window.range.start)..window.range.start } else { return None; }; for window in windows_iter.filter(|w| w.range.start >= range.end - lookback) { puts += window.puts; gets += window.gets; range.start = window.range.start; } Some((range, puts, gets)) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>skip-filecheck EMIT_MIR_FOR_EACH_PANIC_STRATEGY @ compile-flags: -Zmir-opt-level=1<CODESPLIT>fn foo<T>() { if let (Some(a), None) = (Option::<u8>::None, Option::<T>::None) { if a > 42u8 {} } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Allocates memory to fit in a T and fills the memory with values provided by the fill callback.<CODESPLIT>pub fn new<F: FnMut(usize) -> u8>(mut fill: F) -> Self { let layout = Layout::new::<T>(); let memory = unsafe { alloc(layout) }; for i in 0..layout.size() { unsafe { memory.add(i).write(fill(i)) } } Self { memory: memory.cast(), } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Given an internal edge handle, returns [`Result::Ok`] with a handle to the neighboring KV on the right side, which is either in the same internal node or in an ancestor node. If the internal edge is the last one in the tree, returns [`Result::Err`] with the root node.<CODESPLIT>fn next_kv( self, ) -> Result< Handle<NodeRef<BorrowType, K, V, marker::Internal>, marker::KV>, NodeRef<BorrowType, K, V, marker::Internal>, > { let mut edge = self; loop { edge = match edge.right_kv() { Ok(internal_kv) => return Ok(internal_kv), Err(last_edge) => match last_edge.into_node().ascend() { Ok(parent_edge) => parent_edge, Err(root) => return Err(root), }, } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>@no-rustfix Checks implementation of `ITER_SKIP_NEXT` lint<CODESPLIT>fn main() { let test_string = "1|1 2"; let sp = test_string.split('|').map(|s| s.trim()); let _: Vec<&str> = sp.skip(1).next().unwrap().split(' ').collect(); if let Some(s) = Some(test_string.split('|').map(|s| s.trim())) { let _: Vec<&str> = s.skip(1).next().unwrap().split(' ').collect(); }; fn check<T>(s: T) where T: Iterator<Item = String>, { let _: Vec<&str> = s.skip(1).next().unwrap().split(' ').collect(); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>@ edition: 2021 @ min-llvm-version: 19 @ compile-flags: -Zcoverage-options=mcdc @ llvm-cov-flags: --show-branches=count --show-mcdc<CODESPLIT>fn nested_if_in_condition(a: bool, b: bool, c: bool) { if a && if b || c { true } else { false } { say("yes"); } else { say("no"); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>FIXME(eddyb) consider deduplicating the `OpString` and `OpSource` created for file-level debuginfo (but using SPIR-T for linking might be better?).<CODESPLIT>pub fn remove_duplicate_extensions(module: &mut Module) { let mut set = FxHashSet::default(); module.extensions.retain(|inst| { inst.class.opcode != Op::Extension || set.insert(inst.operands[0].unwrap_literal_string().to_string()) }); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Turn an arbitrary path into a resolved and normalized absolute path<CODESPLIT>fn resolve_path_fn<'a>( args: &'a [Option<Pattern<MarzanoQueryContext>>], context: &'a MarzanoContext<'a>, state: &mut State<'a, MarzanoQueryContext>, logs: &mut AnalysisLogs, ) -> Result<MarzanoResolvedPattern<'a>> { let args = MarzanoResolvedPattern::from_patterns(args, state, context, logs)?; let current_file = get_absolute_file_name(state, context.language())?; let target_path = match &args[0] { Some(resolved_pattern) => resolved_pattern.text(&state.files, context.language())?, None => return Err(anyhow!("No path argument provided for resolve function")), }; let resolved_path = resolve(target_path, current_file.into())?; Ok(ResolvedPattern::from_string(resolved_path)) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Copies the parameters and adds a new key-value pair.<CODESPLIT>pub fn with<K: Into<String>, V: Into<String>>(&self, key: K, value: V) -> Parameters { let mut copy = self.clone(); copy.map .insert(key.into(), Box::new(StringParam::new(value.into()))); copy }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Registers obligations that all `args` are well-formed.<CODESPLIT>pub(crate) fn add_wf_bounds(&self, args: GenericArgsRef<'tcx>, expr: &hir::Expr<'_>) { for arg in args.iter().filter(|arg| { matches!(arg.unpack(), GenericArgKind::Type(..) | GenericArgKind::Const(..)) }) { self.register_wf_obligation(arg, expr.span, ObligationCauseCode::WellFormed(None)); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>rustfmt-indent_style: Visual Where predicate indent<CODESPLIT>fn lorem<Ipsum, Dolor, Sit, Amet>() -> T where Ipsum: Eq, Dolor: Eq, Sit: Eq, Amet: Eq { }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `getAssetRecipient` (0x79eac6c2) function<CODESPLIT>pub fn get_asset_recipient( &self, ) -> ::ethers::contract::builders::ContractCall< M, ::ethers::core::types::Address, > { self.0 .method_hash([121, 234, 198, 194], ()) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>even without panics, this helps for Miri backtraces<CODESPLIT>pub unsafe fn scatter_ptr(self, dest: Simd<*mut T, N>) { unsafe { self.scatter_select_ptr(dest, Mask::splat(true)) } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Records in the `outlives_relation` (and `inverse_outlives_relation`) that `fr_a: fr_b`.<CODESPLIT>fn relate_universal_regions(&mut self, fr_a: RegionVid, fr_b: RegionVid) { debug!("relate_universal_regions: fr_a={:?} outlives fr_b={:?}", fr_a, fr_b); self.outlives.add(fr_a, fr_b); self.inverse_outlives.add(fr_b, fr_a); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT># Safety `pidfd` must either be -1 (representing no file descriptor) or a valid, exclusively owned file descriptor (See [I O Safety]). [I O Safety]: crate::io#io-safety<CODESPLIT>unsafe fn new(pid: pid_t, pidfd: pid_t) -> Self { use crate::os::unix::io::FromRawFd; use crate::sys_common::FromInner; let pidfd = (pidfd >= 0).then(|| PidFd::from_inner(sys::fd::FileDesc::from_raw_fd(pidfd))); Process { pid, status: None, pidfd } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>FIXME(tschottdorf): This should compile. See #44912.<CODESPLIT>pub fn main() { let x = &Some((3, 3)); let _: &i32 = match x { Some((x, 3)) | &Some((ref x, 5)) => x, _ => &5i32, }; }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Removes an index from the map, returning the value at the index if the index was previously in the map.<CODESPLIT>pub fn remove(&mut self, idx: Idx<T>) -> Option<V> { self.v.get_mut(Self::to_idx(idx))?.take() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Gets the argument type at the given offset. This will return `None` when the index is out of bounds only for variadic functions, otherwise this will panic.<CODESPLIT>pub fn input(self, i: usize) -> Option<Binder<'tcx, Ty<'tcx>>> { match self { Self::Sig(sig, _) => { if sig.c_variadic() { sig.inputs().map_bound(|inputs| inputs.get(i).copied()).transpose() } else { Some(sig.input(i)) } }, Self::Closure(_, sig) => Some(sig.input(0).map_bound(|ty| ty.tuple_fields()[i])), Self::Trait(inputs, _, _) => Some(inputs.map_bound(|ty| ty.tuple_fields()[i])), } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Visit a nested chain of `&&`. Used for if-let chains. This must call `visit_expr` on the subexpressions we are not handling ourselves.<CODESPLIT>fn visit_land( &mut self, ex: &'p Expr<'tcx>, accumulator: &mut Vec<Option<(Span, RefutableFlag)>>, ) -> Result<(), ErrorGuaranteed> { match ex.kind { ExprKind::Scope { value, lint_level, .. } => self.with_lint_level(lint_level, |this| { this.visit_land(&this.thir[value], accumulator) }), ExprKind::LogicalOp { op: LogicalOp::And, lhs, rhs } => { let res_lhs = self.visit_land(&self.thir[lhs], accumulator); let res_rhs = self.visit_land_rhs(&self.thir[rhs])?; accumulator.push(res_rhs); res_lhs } _ => { let res = self.visit_land_rhs(ex)?; accumulator.push(res); Ok(()) } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Allocates a new writable view from the section heap. The caller has exclusive access to this view until it is sent to the other endpoint.<CODESPLIT>pub fn alloc_view(&self, len: usize) -> io::Result<WritablePortSectionView<'a>> { unsafe { let mut attr = ALPC_DATA_VIEW_ATTR { SectionHandle: self.handle as *mut _, ViewSize: len, ..std::mem::zeroed() }; chk_status(NtAlpcCreateSectionView( self.port.0.as_raw_handle(), 0, &mut attr, ))?; Ok(WritablePortSectionView(PortSectionView { port: self.port, attr, unmap: true, })) } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns `self`'s base name and file extension. # Returns - `None` if `self` ends with `" "`. - `Some((name, None))` if `self`'s base contains no `.`, or only one `.` at the start. - `Some((name, Some(extension))` else. # Note The extension will not contains `.`. This means `" foo bar.baz.rs"` will return `Some(("bar.baz", Some("rs"))`.<CODESPLIT>fn name_and_extension(&self) -> Option<(&str, Option<&str>)> { let file_path = if self.0.ends_with('/') { &self.0[..&self.0.len() - 1] } else { &self.0 }; let file_name = match file_path.rfind('/') { Some(position) => &file_path[position + 1..], None => file_path, }; if file_name.is_empty() { None } else { let mut file_stem_and_extension = file_name.rsplitn(2, '.'); let extension = file_stem_and_extension.next(); let file_stem = file_stem_and_extension.next(); match (file_stem, extension) { (None, None) => None, (None | Some(""), Some(_)) => Some((file_name, None)), (Some(file_stem), extension) => Some((file_stem, extension)), } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Uses the artifact store to to create an artifact, upload the content, and return the URI.<CODESPLIT>async fn create_artifact_with_content<T: Serialize>( &self, store: &mut ArtifactStoreClient<Channel>, item: &T, ) -> Result<String> { let signature = self.signer.sign_message_sync("create_artifact".as_bytes())?; let request = CreateArtifactRequest { signature: signature.as_bytes().to_vec() }; let response = store.create_artifact(request).await?.into_inner(); let presigned_url = response.artifact_presigned_url; let uri = response.artifact_uri; let response = self.http.put(&presigned_url).body(bincode::serialize::<T>(item)?).send().await?; if !response.status().is_success() { log::debug!("Artifact upload failed with status: {}", response.status()); } assert!(response.status().is_success()); Ok(uri) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Formula is: $$\sum_{i=1}^n\frac{v_i}{(1+r)^{\frac{(d_j-d_1)}{365}}}$$ where $v_i$ is the ith-1 value and $d_i$ is the ith-1 date<CODESPLIT>pub(crate) fn compute_xnpv( rate: f64, values: &[f64], dates: &[f64], ) -> Result<f64, (Error, String)> { let mut xnpv = values[0]; let d0 = dates[0]; let n = values.len(); for i in 1..n { let vi = values[i]; let di = dates[i]; xnpv += vi / ((1.0 + rate).powf((di - d0) / 365.0)) } if xnpv.is_infinite() || xnpv.is_nan() { return Err((Error::NUM, "NaN".to_string())); } Ok(xnpv) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Sets the node's link to its parent edge, without invalidating other references to the node.<CODESPLIT>fn set_parent_link(&mut self, parent: NonNull<InternalNode<K, V>>, parent_idx: usize) { let leaf = Self::as_leaf_ptr(self); unsafe { (*leaf).parent = Some(parent) }; unsafe { (*leaf).parent_idx.write(parent_idx as u16) }; }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>OPTIMIZATION: It is cheaper to do this in one pass than using `.parent()` and `.file_name()`.<CODESPLIT>fn split_path_dir_and_file(path: &Path) -> (&Path, &OsStr) { let mut iter = path.components(); let file_name = match iter.next_back() { Some(Component::Normal(p)) => p, component => { panic!( "Path component {:?} of path {} is an invalid filename", component, path.display() ); } }; let parent = iter.as_path(); (parent, file_name) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>apply all successful updates to the state must have at least one successful match return soft and failed on failure<CODESPLIT>fn execute<'a>( &'a self, binding: &Q::ResolvedPattern<'a>, init_state: &mut State<'a, Q>, context: &'a Q::ExecContext<'a>, logs: &mut AnalysisLogs, ) -> GritResult<bool> { let mut matched = false; let mut cur_state = init_state.clone(); for pattern in &self.patterns { let state = cur_state.clone(); if pattern.execute(binding, &mut cur_state, context, logs)? { matched = true; } else { cur_state = state; } } if matched { *init_state = cur_state; Ok(true) } else { Ok(false) } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Realize the true shape and convert it to usizes. All dyn dims must be replaced already<CODESPLIT>pub fn shape_usize(&self) -> Vec<usize> { self.dims().iter().map(|e| e.to_usize().unwrap()).collect() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>This also works. The `'_` isn't necessary but it's where we arrive to following the suggestions:<CODESPLIT>fn ok2<'a, G: 'a, T>(g: G, dest: &'a mut T) -> impl FnOnce() + '_ + 'a where G: Get<T>, { move || { *dest = g.get(); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>do we want to do an overriding insert? should we return a value depending on update?<CODESPLIT>pub fn insert(&mut self, name: String, body: String, language: Option<PatternLanguage>) { let language = language.unwrap_or_default(); self.pattern_to_language .entry(name.clone()) .or_insert(language); let hashmap = self.get_language_directory_mut(language); hashmap.entry(name).or_insert(body); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>slightly inefficient but ensures the names are consistent<CODESPLIT>pub fn language_name(self) -> &'static str { self.try_into() .map(|l: TargetLanguage| l.language_name()) .unwrap_or("Universal") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Copies the function name of `self into a new `String`. # Safety `self` must be an unmodified version of what `from_function_call` returned.<CODESPLIT>pub unsafe fn copy_function_name(&self) -> String { unsafe { CStr::from_ptr(self.function_name) .to_string_lossy() .into_owned() } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>if the snippet is text consisting of newlines followed by spaces, returns the number of spaces. might not be general enough, but should be good for a first pass<CODESPLIT>pub fn padding( &self, state: &FileRegistry<'a, Q>, language: &Q::Language<'a>, ) -> GritResult<usize> { let text = self.text(state, language)?; let len = text.len(); let trim_len = text.trim_end_matches(' ').len(); Ok(len - trim_len) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>This method factors out how a `MiriAllocBytes` object is allocated, given a specific allocation function. If `size == 0` we allocate using a different `alloc_layout` with `size = 1`, to ensure each allocation has a unique address. Returns `Err(alloc_layout)` if the allocation function returns a `ptr` where `ptr.is_null()`.<CODESPLIT>fn alloc_with( size: u64, align: u64, alloc_fn: impl FnOnce(Layout) -> *mut u8, ) -> Result<MiriAllocBytes, ()> { let size = usize::try_from(size).map_err(|_| ())?; let align = usize::try_from(align).map_err(|_| ())?; let layout = Layout::from_size_align(size, align).map_err(|_| ())?; let alloc_layout = if size == 0 { Layout::from_size_align(1, align).unwrap() } else { layout }; let ptr = alloc_fn(alloc_layout); if ptr.is_null() { Err(()) } else { Ok(Self { ptr, layout }) } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>EMIT_MIR branch_match_arms.main.InstrumentCoverage.diff<CODESPLIT>fn main() { match Enum::A(0) { Enum::D(d) => consume(d), Enum::C(c) => consume(c), Enum::B(b) => consume(b), Enum::A(a) => consume(a), } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>FIXME(arielb1): use this instead of field.ty everywhere Only for fields! Returns <none> for methods> Indifferent to privacy flags<CODESPLIT>pub(crate) fn field_ty( &self, span: Span, field: &'tcx ty::FieldDef, args: GenericArgsRef<'tcx>, ) -> Ty<'tcx> { self.normalize(span, field.ty(self.tcx, args)) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Adjust closure capture just that if taking ownership of data, only move data from enclosing stack frame.<CODESPLIT>fn adjust_for_non_move_closure( mut place: Place<'_>, mut kind: ty::UpvarCapture, ) -> (Place<'_>, ty::UpvarCapture) { let contains_deref = place.projections.iter().position(|proj| proj.kind == ProjectionKind::Deref); match kind { ty::UpvarCapture::ByValue => { if let Some(idx) = contains_deref { truncate_place_to_len_and_update_capture_kind(&mut place, &mut kind, idx); } } ty::UpvarCapture::ByRef(..) => {} } (place, kind) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>order here is pattern then side condition, do we prefer side condition then pattern? should the state be reset on failure?<CODESPLIT>fn execute<'a>( &'a self, binding: &Q::ResolvedPattern<'a>, init_state: &mut State<'a, Q>, context: &'a Q::ExecContext<'a>, logs: &mut AnalysisLogs, ) -> GritResult<bool> { let mut cur_state = init_state.clone(); if !self .pattern .execute(binding, &mut cur_state, context, logs)? { return Ok(false); } if self .side_condition .execute_func(&mut cur_state, context, logs)? .predicator { *init_state = cur_state; Ok(true) } else { Ok(false) } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Converts this function's coverage mappings into an intermediate form that will be used by `mapgen` when preparing for FFI.<CODESPLIT>pub(crate) fn counter_regions( &self, ) -> impl Iterator<Item = (MappingKind, &SourceRegion)> + ExactSizeIterator { self.function_coverage_info.mappings.iter().map(move |mapping| { let Mapping { kind, source_region } = mapping; let kind = kind.map_terms(|term| if self.is_zero_term(term) { CovTerm::Zero } else { term }); (kind, source_region) }) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Concatenate two `Nfa`s.<CODESPLIT>pub(crate) fn concat(self, other: Self) -> Self { if self.start == self.accepting { return other; } else if other.start == other.accepting { return self; } let start = self.start; let accepting = other.accepting; let mut transitions: Map<State, Map<Transition<R>, Set<State>>> = self.transitions; for (source, transition) in other.transitions { let fix_state = |state| if state == other.start { self.accepting } else { state }; let entry = transitions.entry(fix_state(source)).or_default(); for (edge, destinations) in transition { let entry = entry.entry(edge).or_default(); for destination in destinations { entry.insert(fix_state(destination)); } } } Self { transitions, start, accepting } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Note: this also detaches whitespace after comments, since `SyntaxNode::splice_children` (and by extension `ted::insert_all_raw`) detaches nodes. If we only took the comments, we'd leave behind the old whitespace.<CODESPLIT>fn take_all_comments(node: &SyntaxNode) -> Vec<SyntaxElement> { let mut remove_next_ws = false; node.children_with_tokens() .filter_map(move |child| match child.kind() { COMMENT => { remove_next_ws = true; child.detach(); Some(child) } WHITESPACE if remove_next_ws => { remove_next_ws = false; child.detach(); Some(make::tokens::single_newline().into()) } _ => { remove_next_ws = false; None } }) .collect() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>rustfmt-match_arm_blocks: false Match expressions, no unwrapping of block arms or wrapping of multiline expressions.<CODESPLIT>fn foo() { match x { a => foo(), b => ( aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa, bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb, ), } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Compute the CROSS JOIN cartesian product of two tables. # Panics The function if written correctly can not actually panic.<CODESPLIT>pub fn cross_join<'a, S: Scalar>( left: &Table<'a, S>, right: &Table<'a, S>, alloc: &'a Bump, ) -> Table<'a, S> { let left_num_rows = left.num_rows(); let right_num_rows = right.num_rows(); let product_num_rows = left_num_rows * right_num_rows; Table::<'a, S>::try_from_iter_with_options( left.inner_table() .iter() .map(|(&ident, column)| { ( ident, ColumnRepeatOp::column_op(column, alloc, right_num_rows), ) }) .chain(right.inner_table().iter().map(|(&ident, column)| { ( ident, ElementwiseRepeatOp::column_op(column, alloc, left_num_rows), ) })), TableOptions::new(Some(product_num_rows)), ) .expect("Table creation should not fail") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Upon every ACK in Fast Recovery, run the following steps, which help ensure packet conservation on the first round of recovery, and sending at no more than twice the current delivery rate on later rounds of recovery. See draft-cardwell-iccrg-bbr-congestion-control-00 Section 4.2.3.4.<CODESPLIT>fn modulate_cwnd_for_recovery(&mut self, bytes_in_flight: u64) { if self.ack_state.newly_lost_bytes > 0 { self.cwnd = self .cwnd .saturating_sub(self.ack_state.newly_lost_bytes) .max(self.config.min_cwnd); } if self.packet_conservation { self.cwnd = self .cwnd .max(bytes_in_flight + self.ack_state.newly_acked_bytes); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>This, by analogy to previous case, is *also* not okay.<CODESPLIT>fn boxed_boxed_scribbled<'a>(s: Box<Box<Scribble<'a>>>) -> &'a mut u32 { &mut *(**s).0 }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Attempts to find `node` inside `syntax` via `node`'s text range while compensating for the offset introduced by the fake ident.. This is wrong if `node` comes before the insertion point! Use `find_node_in_file` instead.<CODESPLIT>fn find_opt_node_in_file_compensated<N: AstNode>( sema: &Semantics<'_, RootDatabase>, syntax: &SyntaxNode, node: Option<N>, ) -> Option<N> { find_node_in_file_compensated(sema, syntax, &node?) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>This function exists since `quote! {span => && }` doesn't work.<CODESPLIT>fn and_and(span: Span) -> tt::Subtree { let and = tt::Punct { char: '&', spacing: ::tt::Spacing::Joint, span }; quote! {span => #and& } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Specify the name of the executable. The executable will be placed under the current directory and the extension will be determined by [`bin_name`].<CODESPLIT>pub fn out_exe(&mut self, name: &str) -> &mut Self { self.cmd.arg("-o"); self.cmd.arg(bin_name(name)); self }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Set priority for an HTTP 3 stream.<CODESPLIT>pub fn stream_set_priority( &mut self, conn: &mut Connection, stream_id: u64, priority: &Http3Priority, ) -> Result<()> { if !self.streams.contains_key(&stream_id) { return Ok(()); } let urgency = priority.map_to_quic(); conn.stream_set_priority(stream_id, urgency, priority.incremental)?; Ok(()) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Check all VALUES have the same number of terms<CODESPLIT>pub fn push(values: &mut Vec<Vec<Expr>>, v: Vec<Expr>) -> Result<(), ParserError> { if values[0].len() != v.len() { return Err(custom_err!("all VALUES must have the same number of terms")); } values.push(v); Ok(()) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Create a `TokenTree::Token` with joint-hidden spacing.<CODESPLIT>pub fn token_joint_hidden(kind: TokenKind, span: Span) -> TokenTree { TokenTree::Token(Token::new(kind, span), Spacing::JointHidden) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Adds the bits from `with` to the bits from row `write`, and returns `true` if anything changed.<CODESPLIT>pub fn union_row_with(&mut self, with: &BitSet<C>, write: R) -> bool { assert!(write.index() < self.num_rows); assert_eq!(with.domain_size(), self.num_columns); let (write_start, write_end) = self.range(write); bitwise(&mut self.words[write_start..write_end], &with.words, |a, b| a | b) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Block expressions accept outer and inner attributes, but only when they are the outer expression of an expression statement or the final expression of another block expression.<CODESPLIT>pub fn may_carry_attributes(&self) -> bool { matches!( self.syntax().parent().map(|it| it.kind()), Some(SyntaxKind::BLOCK_EXPR | SyntaxKind::EXPR_STMT) ) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Function to compute SHA-256 hash of a file<CODESPLIT>fn compute_sha256(file_path: &str) -> Option<String> { let mut file = File::open(file_path).ok()?; let mut hasher = Sha256::new(); io::copy(&mut file, &mut hasher).ok()?; Some(format!("{:x}", hasher.finalize())) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Prints the number of overridden uv PyPI package requests<CODESPLIT>fn print_overridden_requests(package_requests: &HashMap<uv_normalize::PackageName, u32>) { if !package_requests.is_empty() { let package_requests = package_requests .iter() .map(|(name, value)| format!("[{name}: {value}]")) .collect::<Vec<_>>() .join(","); tracing::debug!("overridden uv PyPI package requests [name: amount]: {package_requests}"); } else { tracing::debug!("no uv PyPI package requests overridden by locked conda dependencies"); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Ensure two arrays are nearly equal to a decimal place<CODESPLIT>pub fn assert_close_precision(a_vec: &[f32], b_vec: &[f32], threshold: f32) { assert_eq!(a_vec.len(), b_vec.len(), "Number of elements doesn't match"); for (i, (a, b)) in a_vec.iter().zip(b_vec.iter()).enumerate() { if (a - b).abs() > threshold { panic!( "{a} is not close to {b}, index {i}, avg distance: {}", a_vec .iter() .zip(b_vec.iter()) .map(|(a, b)| (a - b).abs()) .sum::<f32>() / a_vec.len() as f32 ); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns `self`'s base name and file extension.<CODESPLIT>pub fn name_and_extension(&self) -> Option<(&str, Option<&str>)> { match &self.0 { VfsPathRepr::PathBuf(p) => p.name_and_extension(), VfsPathRepr::VirtualPath(p) => p.name_and_extension(), } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Whether or not these asserts pass isn't known, so they shouldn't be modified. EMIT_MIR intrinsic_asserts.generic.InstSimplify-after-simplifycfg.diff<CODESPLIT>pub fn generic<T>() { core::intrinsics::assert_inhabited::<T>(); core::intrinsics::assert_zero_valid::<T>(); core::intrinsics::assert_mem_uninitialized_valid::<T>(); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Tries to write a packet into the outgoing ring. Fails with `TryReadError::Full(send_size)` if the ring is full.<CODESPLIT>pub fn try_write(&mut self, packet: &OutgoingPacket<'_, '_>) -> Result<(), TryWriteError> { self.batched().try_write(packet) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>TK_ID: [...] `...` "..." some keywords non keywords<CODESPLIT>fn double_quote<S: TokenStream>(name: &str, s: &mut S) -> Result<(), S::Error> { if name.is_empty() { return s.append(TK_ID, Some("\"\"")); } if is_identifier(name) { return s.append(TK_ID, Some(name)); } s.append(TK_ID, Some(name)) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Inserts a single byte at a specific position. When the capacity is exceeded, the byte is an illegal character or the content would result in an illegal content it fails.<CODESPLIT>fn insert(&mut self, idx: usize, byte: u8) -> Result<(), SemanticStringError> { self.insert_bytes(idx, &[byte; 1]) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>@ check-pass @ compile-flags: -Zvalidate-mir<CODESPLIT>fn hello() -> &'static [impl Sized; 0] { if false { let x = hello(); let _: &[i32] = x; } &[] }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>rustfmt-indent_style: Visual<CODESPLIT>fn main() { let (first_variable, second_variable) = (this_is_something_with_an_extraordinarily_long_name, this_variable_name_is_also_pretty_long); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>CHECK: define{{.*}}5foo25{{.*}}!type ![[TYPE25:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}<CODESPLIT>pub fn foo26(_: &dyn Trait5<Type5, 32>, _: &dyn Trait5<Type5, 32>) {}
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Get our internal flowey bootstrap template. See [`Pipeline::gh_set_flowey_bootstrap_template`] [`Pipeline::gh_set_flowey_bootstrap_template`]: flowey::pipeline::prelude::Pipeline::gh_set_flowey_bootstrap_template<CODESPLIT>pub fn get_template() -> String { let template = include_str!("gh_flowey_bootstrap_template.yml").to_string(); template.replace( "{{RUSTUP_TOOLCHAIN}}", flowey_lib_hvlite::_jobs::cfg_versions::RUSTUP_TOOLCHAIN, ) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Converts the [`ColumnarValue`] to a [`Column`]<CODESPLIT>pub fn into_column( &self, num_rows: usize, alloc: &'a Bump, ) -> Result<Column<'a, S>, ColumnarValueError> { match self { Self::Column(column) => { if column.len() == num_rows { Ok(*column) } else { Err(ColumnarValueError::ColumnLengthMismatch { columnar_value_length: column.len(), attempt_to_convert_length: num_rows, }) } } Self::Literal(literal) => { Ok(Column::from_literal_with_length(literal, num_rows, alloc)) } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>this is also OK, because the result could borrow y<CODESPLIT>fn also_works<'a>(x: &'a u32, y: &'a mut u32) -> &'a mut u32 { unsafe { unimplemented!() } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Checks both virtual tables and tables to get the table name to number mapping<CODESPLIT>pub fn all_tables_name_to_number( namespace: TableNamespace, table_mapping: &TableMapping, virtual_system_mapping: &VirtualSystemMapping, ) -> impl Fn(TableName) -> anyhow::Result<TableNumber> { let table_mapping = table_mapping.clone(); let virtual_system_mapping = virtual_system_mapping.clone(); move |name| { let name = if let Some(physical_table) = virtual_system_mapping.virtual_to_system.get(&name) { physical_table.clone() } else { name }; table_mapping .namespace(namespace) .name_to_number_user_input()(name) } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Invokes `closure` with a `&mut ActiveQuery` for each query that participates in the cycle. The cycle runs as follows: 1. The runtime `from_id`, which has the stack `from_stack`, would like to invoke `database_key`... 2. ...but `database_key` is already being executed by `to_id`... 3. ...and `to_id` is transitively dependent on something which is present on `from_stack`.<CODESPLIT>pub(super) fn for_each_cycle_participant( &mut self, from_id: RuntimeId, from_stack: &mut QueryStack, database_key: DatabaseKeyIndex, to_id: RuntimeId, mut closure: impl FnMut(&mut [ActiveQuery]), ) { debug_assert!(self.depends_on(to_id, from_id)); let mut id = to_id; let mut key = database_key; while id != from_id { let edge = self.edges.get_mut(&id).unwrap(); let prefix = edge.stack.iter_mut().take_while(|p| p.database_key_index != key).count(); closure(&mut edge.stack[prefix..]); id = edge.blocked_on_id; key = edge.blocked_on_key; } let prefix = from_stack.iter_mut().take_while(|p| p.database_key_index != key).count(); closure(&mut from_stack[prefix..]); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Wraps the node in a [`InFile`] with the file id it belongs to.<CODESPLIT>fn find_file<'node>(&self, node: &'node SyntaxNode) -> InFile<&'node SyntaxNode> { let root_node = find_root(node); let file_id = self.lookup(&root_node).unwrap_or_else(|| { panic!( "\n\nFailed to lookup {:?} in this Semantics.\n\ Make sure to use only query nodes, derived from this instance of Semantics.\n\ root node: {:?}\n\ known nodes: {}\n\n", node, root_node, self.root_to_file_cache .borrow() .keys() .map(|it| format!("{it:?}")) .collect::<Vec<_>>() .join(", ") ) }); InFile::new(file_id, node) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Checks if the given resolved path is used in the given body.<CODESPLIT>pub fn is_res_used(cx: &LateContext<'_>, res: Res, body: BodyId) -> bool { for_each_expr(cx, cx.tcx.hir().body(body).value, |e| { if let ExprKind::Path(p) = &e.kind { if cx.qpath_res(p, e.hir_id) == res { return ControlFlow::Break(()); } } ControlFlow::Continue(()) }) .is_some() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Set the value of the tensor matching the constant shape<CODESPLIT>pub fn set<T: Data + Clone, D: ToData<T>>(self, data: D) -> Self { let (data, _) = data.to_data_vec(); self.graph().get_op_mut::<Function>(self.id).1 = Box::new(move |_| vec![Tensor::new(data.to_owned())]); self }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Creates a tuple of patterns from an iterator of patterns. Invariant: `pats` must be length > 0<CODESPLIT>pub fn tuple_pat(pats: impl IntoIterator<Item = ast::Pat>) -> ast::TuplePat { let mut count: usize = 0; let mut pats_str = pats.into_iter().inspect(|_| count += 1).join(", "); if count == 1 { pats_str.push(','); } return from_text(&format!("({pats_str})")); fn from_text(text: &str) -> ast::TuplePat { ast_from_text(&format!("fn f({text}: ())")) } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns the column as a slice of i32 if it is an int column. Otherwise, returns None.<CODESPLIT>pub(crate) fn as_int(&self) -> Option<&'a [i32]> { match self { Self::Int(col) => Some(col), _ => None, } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `cancelOwnershipTransfer` (0x7b37e561) function<CODESPLIT>pub fn cancel_ownership_transfer( &self, conduit: ::ethers::core::types::Address, ) -> ::ethers::contract::builders::ContractCall<M, ()> { self.0 .method_hash([123, 55, 229, 97], conduit) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>We do the sorting here since this is what is called by the SorterSort instruction<CODESPLIT>fn rewind(&mut self) -> Result<CursorResult<()>> { self.records.sort_by(|a, b| { let cmp_by_idx = |idx: usize, ascending: bool| { let a = &a.values[idx]; let b = &b.values[idx]; if ascending { a.cmp(b) } else { b.cmp(a) } }; let mut cmp_ret = Ordering::Equal; for (idx, &is_asc) in self.order.iter().enumerate() { cmp_ret = cmp_by_idx(idx, is_asc); if cmp_ret != Ordering::Equal { break; } } cmp_ret }); self.records.reverse(); self.next() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Revokes the channel, returning it if the VMBus server is still running.<CODESPLIT>pub async fn revoke(self) -> Option<T> { Some( *self .0 .revoke() .await? .into_any() .downcast() .expect("type must match the one used to create it"), ) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Fixme: this is still somewhat limited, use hir_ty::diagnostics::match_check?<CODESPLIT>fn does_pat_match_variant(pat: &Pat, var: &Pat) -> bool { match (pat, var) { (Pat::WildcardPat(_), _) => true, (Pat::SlicePat(spat), Pat::SlicePat(svar)) => { spat.pats().zip(svar.pats()).all(|(p, v)| does_pat_match_variant(&p, &v)) } (Pat::TuplePat(tpat), Pat::TuplePat(tvar)) => { tpat.fields().zip(tvar.fields()).all(|(p, v)| does_pat_match_variant(&p, &v)) } (Pat::OrPat(opat), _) => opat.pats().any(|p| does_pat_match_variant(&p, var)), _ => utils::does_pat_match_variant(pat, var), } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>rustfmt-control_brace_style: AlwaysNextLine Control brace style<CODESPLIT>fn main() { if lorem { println!("ipsum!"); } else { println!("dolor!"); } match magi { Homura => "Akemi", Madoka => "Kaname", } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Get handle to pty fork for reading writing<CODESPLIT>pub fn get_file_handle(&self) -> nix::Result<File> { let fd = dup(self.pty.as_raw_fd())?; unsafe { Ok(File::from_raw_fd(fd)) } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Runs `fut` until it completes or the VP should stop.<CODESPLIT>pub async fn until_stop<Fut: Future>(&mut self, fut: Fut) -> Result<Fut::Output, VpStopped> { let mut fut = pin!(fut); poll_fn(|cx| match fut.as_mut().poll(cx) { Poll::Ready(r) => Poll::Ready(Ok(r)), Poll::Pending => { self.check()?; self.source.waker.set(Some(cx.waker().clone())); Poll::Pending } }) .await }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Format vote count to a string that will be displayed. Append `m` and `k` for millions and thousands respectively, and round to the nearest tenth.<CODESPLIT>pub fn format_num(num: i64) -> (String, String) { let truncated = if num >= 1_000_000 || num <= -1_000_000 { format!("{:.1}m", num as f64 / 1_000_000.0) } else if num >= 1000 || num <= -1000 { format!("{:.1}k", num as f64 / 1_000.0) } else { num.to_string() }; (truncated, num.to_string()) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Converts pair of `ops::Bound`s into `ops::Range`. Panics on overflowing indices.<CODESPLIT>pub(crate) fn into_slice_range( len: usize, (start, end): (ops::Bound<usize>, ops::Bound<usize>), ) -> ops::Range<usize> { use ops::Bound; let start = match start { Bound::Included(start) => start, Bound::Excluded(start) => { start.checked_add(1).unwrap_or_else(|| slice_start_index_overflow_fail()) } Bound::Unbounded => 0, }; let end = match end { Bound::Included(end) => { end.checked_add(1).unwrap_or_else(|| slice_end_index_overflow_fail()) } Bound::Excluded(end) => end, Bound::Unbounded => len, }; start..end }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>rustfmt-style_edition: 2015<CODESPLIT>fn main() { trace!( "get some longer length in here yes yes {} {}", "hello", "world" ); debug!( "get some longer length in here yes yes {} {}", "hello", "world" ); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Computes the least-upper-bound of two free regions. In some cases, this is more conservative than necessary, in order to avoid making arbitrary choices. See `TransitiveRelation::postdom_upper_bound` for more details.<CODESPLIT>pub(crate) fn lub_param_regions( &self, tcx: TyCtxt<'tcx>, r_a: Region<'tcx>, r_b: Region<'tcx>, ) -> Region<'tcx> { debug!("lub_param_regions(r_a={:?}, r_b={:?})", r_a, r_b); assert!(r_a.is_param()); assert!(r_b.is_param()); let result = if r_a == r_b { r_a } else { match self.relation.postdom_upper_bound(r_a, r_b) { None => tcx.lifetimes.re_static, Some(r) => r, } }; debug!("lub_param_regions(r_a={:?}, r_b={:?}) = {:?}", r_a, r_b, result); result }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>(ADO only) Declare a new repository resource, returning a type-safe handle which downstream ADO steps are able to consume via [`AdoStepServices::resolve_repository_id`](crate::node::user_facing::AdoStepServices::resolve_repository_id).<CODESPLIT>pub fn ado_add_resources_repository( &mut self, repo: AdoResourcesRepository, ) -> AdoResourcesRepositoryId { let AdoResourcesRepository { repo_type, name, git_ref, endpoint, } = repo; let repo_id = format!("repo{}", self.ado_resources_repository.len()); self.ado_resources_repository .push(InternalAdoResourcesRepository { repo_id: repo_id.clone(), repo_type, name, git_ref: match git_ref { AdoResourcesRepositoryRef::Fixed(s) => AdoResourcesRepositoryRef::Fixed(s), AdoResourcesRepositoryRef::Parameter(p) => { AdoResourcesRepositoryRef::Parameter(p.idx) } }, endpoint, }); AdoResourcesRepositoryId { repo_id } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Define a legacy textual scoped macro in module We use a map `legacy_macros` to store all legacy textual scoped macros visible per module. It will clone all macros from parent legacy scope, whose definition is prior to the definition of current module. And also, `macro_use` on a module will import all legacy macros visible inside to current legacy scope, with possible shadowing.<CODESPLIT>fn define_legacy_macro(&mut self, module_id: LocalModuleId, name: Name, mac: MacroId) { self.def_map.modules[module_id].scope.define_legacy_macro(name, mac); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Provides mutable iteration over all elements. The iterator also provides the range of the given element. How exactly the ranges are split can differ even for otherwise identical maps, so user-visible behavior should never depend on the exact range.<CODESPLIT>pub fn iter_mut_all(&mut self) -> impl Iterator<Item = (ops::Range<u64>, &mut T)> { self.v.iter_mut().map(|elem| (elem.range.clone(), &mut elem.data)) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>@ known-bug: rust-lang rust#130104<CODESPLIT>fn main() { let non_secure_function = core::mem::transmute::<fn() -> _, extern "C-cmse-nonsecure-call" fn() -> _>; }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `fee` (0xddca3f43) function<CODESPLIT>pub fn fee(&self) -> ::ethers::contract::builders::ContractCall<M, u128> { self.0 .method_hash([221, 202, 63, 67], ()) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Easy to lint because these only span one line.<CODESPLIT>fn one_liners() { unsafe { let _: fn() = std::mem::transmute(0 as *const ()); let _: fn() = std::mem::transmute(std::ptr::null::<()>()); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Parses all `-l` options.<CODESPLIT>pub(crate) fn parse_native_libs( early_dcx: &EarlyDiagCtxt, unstable_opts: &UnstableOptions, unstable_features: UnstableFeatures, matches: &getopts::Matches, ) -> Vec<NativeLib> { let cx = ParseNativeLibCx { early_dcx, unstable_options_enabled: unstable_opts.unstable_options, is_nightly: unstable_features.is_nightly_build(), }; matches.opt_strs("l").into_iter().map(|value| parse_native_lib(&cx, &value)).collect() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>We need to tie the lifetime of `G` with the lifetime of `&mut T` and the returned closure:<CODESPLIT>fn ok<'a, G: 'a, T>(g: G, dest: &'a mut T) -> impl FnOnce() + 'a where G: Get<T>, { move || { *dest = g.get(); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT># Safety `ptr` must be valid for writes of `len` bytes<CODESPLIT>unsafe fn volatile_write_zeroize_mem(ptr: *mut u8, len: usize) { for i in 0..len { let ptr_new: *mut u8 = ((ptr as usize) + i) as *mut u8; unsafe { core::ptr::write_volatile(ptr_new, 0u8); } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `safeTransferFrom` (0xf242432a) function<CODESPLIT>pub fn safe_transfer_from( &self, from: ::ethers::core::types::Address, to: ::ethers::core::types::Address, id: ::ethers::core::types::U256, amount: ::ethers::core::types::U256, data: ::ethers::core::types::Bytes, ) -> ::ethers::contract::builders::ContractCall<M, ()> { self.0 .method_hash([242, 66, 67, 42], (from, to, id, amount, data)) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Define the XFG mitigation policy options.<CODESPLIT>pub const fn xtended_control_flow_guard(self, action: MitigationPolicyAction) -> Self { self.set( &PROCESS_CREATION_MITIGATION_POLICY2_XTENDED_CONTROL_FLOW_GUARD, action as u64, ) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Filters out bounds from impl if we're generating the function into the same impl we're generating from.<CODESPLIT>fn filter_bounds_in_scope( generic_params: &mut Vec<ParamBoundWithParams>, where_preds: &mut Vec<WherePredWithParams>, ctx: &AssistContext<'_>, target: &GeneratedFunctionTarget, ) -> Option<()> { let target_impl = target.parent().ancestors().find_map(ast::Impl::cast)?; let target_impl = ctx.sema.to_def(&target_impl)?; // It's sufficient to test only the first element of `generic_params` because of the order of let def = generic_params.first()?.self_ty_param.parent(); if def != hir::GenericDef::Impl(target_impl) { return None; } generic_params.retain(|it| !matches!(it.self_ty_param.parent(), hir::GenericDef::Impl(_))); where_preds.retain(|it| { it.node.syntax().parent().and_then(|it| it.parent()).and_then(ast::Impl::cast).is_none() }); Some(()) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Commit the transaction to the database. The connection is automatically returned into the pool.<CODESPLIT>pub async fn commit(mut self) -> Result<(), Error> { self.rollback = false; let start = Instant::now(); self.connection.query_cached("COMMIT", &[]).await?; if get_config().general.log_queries { info!("COMMIT ({:.3} ms)", start.elapsed().as_secs_f64() * 1000.0); } Ok(()) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>this is OK, because the result borrows y<CODESPLIT>fn works<'a>(x: &u32, y: &'a mut u32) -> &'a mut u32 { unsafe { unimplemented!() } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Check that underscore and unused bindings within and outwith more complex patterns are dropped after the method with self is polled.<CODESPLIT>async fn foobar_async(&'a self, x: D, (a, _, _c): (D, D, D), _: D, _y: D) { x.1.borrow_mut().push(DropOrder::Function); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `getBuyNFTQuote` (0xa5cb2b91) function<CODESPLIT>pub fn get_buy_nft_quote( &self, num_nf_ts: ::ethers::core::types::U256, ) -> ::ethers::contract::builders::ContractCall< M, ( u8, ::ethers::core::types::U256, ::ethers::core::types::U256, ::ethers::core::types::U256, ::ethers::core::types::U256, ), > { self.0 .method_hash([165, 203, 43, 145], num_nf_ts) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Computes the size of a packed value. Calls `f` with a [`PackedSizer`] to sum the size of each element.<CODESPLIT>pub fn packed<F>(mut self, f: F) where F: FnOnce(PackedSizer<'_>), { self.cached_variable(|this| { f(PackedSizer { size: &mut this.state.message_sizes[this.state.index].len, }); }) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Check that bogus field access is non-fatal<CODESPLIT>fn main() { let x = 0; let _ = x.foo; let _ = x.bar; let _ = 0.f; let _ = 2.l; let _ = 12.F; let _ = 34.L; }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>CHECK-LABEL: issue_114508_i32:<CODESPLIT>pub fn issue_114508_i32(a: i32, b: i32) -> i32 { max!(a, b) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>This operation does `result[i] += multiplier * to_mul_add[i]` for `i` in `0..to_mul_add.len()`. # Panics Panics if the length of `result` is less than the length of `to_mul_add`.<CODESPLIT>pub fn mul_add_assign<T, S>(result: &mut [T], multiplier: T, to_mul_add: &[S]) where T: Send + Sync + Mul<Output = T> + AddAssign + Copy, S: Into<T> + Sync + Copy, { assert!(result.len() >= to_mul_add.len(), "The length of result must be greater than or equal to the length of the vector of values to be multiplied and added"); if_rayon!( result.par_iter_mut().with_min_len(super::MIN_RAYON_LEN), result.iter_mut() ) .zip(to_mul_add) .for_each(|(res_i, &data_i)| { *res_i += multiplier * data_i.into(); }); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Creates a new HandleStorage with a predefined handle that must be not initialized.<CODESPLIT>pub fn new(handle: T) -> Self { Self { handle: UnsafeCell::new(handle), is_initialized: IoxAtomicBool::new(false), is_inter_process_capable: IoxAtomicBool::new(false), } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Read and parse an IgvmFile from a File. This assumes the file is a VBS IGVM file.<CODESPLIT>pub fn read_igvm_file(mut file: &std::fs::File) -> Result<IgvmFile, Error> { let mut file_contents = Vec::new(); file.rewind().map_err(Error::Igvm)?; file.read_to_end(&mut file_contents).map_err(Error::Igvm)?; let igvm_file = IgvmFile::new_from_binary(&file_contents, Some(igvm::IsolationType::Vbs)) .map_err(Error::InvalidIgvmFile)?; Ok(igvm_file) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>~^ ERROR `impl Trait` cannot capture higher-ranked lifetime from outer `impl Trait`<CODESPLIT>fn make_weird_impl<'b>(x: &'b ()) -> impl for<'a> Hrtb<'a, Assoc = impl Send + 'a> { &() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `factory` (0xc45a0155) function<CODESPLIT>pub fn factory( &self, ) -> ::ethers::contract::builders::ContractCall< M, ::ethers::core::types::Address, > { self.0 .method_hash([196, 90, 1, 85], ()) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Make sure we find these even with many checks disabled. @compile-flags: -Zmiri-disable-alignment-check -Zmiri-disable-stacked-borrows -Zmiri-disable-validation<CODESPLIT>fn main() { let p = { let b = Box::new(42); &*b as *const i32 as *const (u8, u8, u8, u8) }; unsafe { let _ = (*p).1; } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Entry point to run the CLI application.<CODESPLIT>pub async fn run(args: args::Args) -> Result<Option<FreezeSummary>, CollectError> { if is_help_command(&args) { return handle_help_subcommands(args); } let cryo_dir = build_cryo_directory(std::path::Path::new(&args.output_dir)); let args = if args.datatype.is_empty() { load_or_remember_command(args, &cryo_dir)? } else { args }; if args.remember { println!("remembering this command for future use\n"); remember::save_remembered_command(cryo_dir, &args)?; } run_freeze_process(args).await }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>This, by analogy to previous case, is *also* not okay.<CODESPLIT>fn boxed_scribbled<'a>(s: Box<Scribble<'a>>) -> &'a mut u32 { &mut *(*s).0 }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Assignment to a deref projection: the `*list` assignment should clear the existing borrows of `list.value` and `list.next`<CODESPLIT>fn assignment_to_deref_projection<T>(mut list: Box<&mut List<T>>) -> Vec<&mut T> { let mut result = vec![]; loop { result.push(&mut list.value); if let Some(n) = list.next.as_mut() { *list = n; } else { return result; } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns `true` if `line` from `file_name` is in `self`.<CODESPLIT>pub(crate) fn contains_line(&self, file_name: &FileName, line: usize) -> bool { self.file_range_matches(file_name, |r| r.lo <= line && r.hi >= line) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Excel believes for some reason that TYPE(A1:A7) is an array formula Although we evaluate the same as Excel we cannot, ATM import this from excel<CODESPLIT>pub(crate) fn fn_type(&mut self, args: &[Node], cell: CellReferenceIndex) -> CalcResult { if args.len() != 1 { return CalcResult::new_args_number_error(cell); } match self.evaluate_node_in_context(&args[0], cell) { CalcResult::String(_) => CalcResult::Number(2.0), CalcResult::Number(_) => CalcResult::Number(1.0), CalcResult::Boolean(_) => CalcResult::Number(4.0), CalcResult::Error { .. } => CalcResult::Number(16.0), CalcResult::Range { .. } => CalcResult::Number(64.0), CalcResult::EmptyCell => CalcResult::Number(1.0), CalcResult::EmptyArg => { CalcResult::Number(1.0) } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>The resolver needs to be updated to the surrounding expression when inside assignment (because there, `Pat::Path` can refer to a variable).<CODESPLIT>pub(super) fn infer_top_pat(&mut self, pat: PatId, expected: &Ty) { self.infer_pat(pat, expected, BindingMode::default()); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Get the child document with a given name, or return an error For example, get the "service" doc within the top level doc<CODESPLIT>pub(crate) fn required_child_doc<'a>( doc: &KdlDocument, here: &'a KdlDocument, name: &str, ) -> miette::Result<&'a KdlDocument> { let node = here .get(name) .or_bail(&format!("'{name}' is required!"), doc, here.span())?; node.children() .or_bail("expected a nested node", doc, node.span()) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Sets whether VINA is currently asserted.<CODESPLIT>pub fn set_vina_asserted(&self, value: bool) -> Result<(), GuestMemoryError> { let gpa = (self.vp_assist_page.gpa_page_number() * HV_PAGE_SIZE) + offset_of!(hvdef::HvVpAssistPage, vtl_control) as u64 + offset_of!(HvVpVtlControl, vina_status) as u64; self.guest_memory.write_plain(gpa, &(value as u8)) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Check that underscore patterns within more complex patterns are dropped after the method with self is polled.<CODESPLIT>async fn baz_async(&'a self, (x, _): (D, D)) { x.1.borrow_mut().push(DropOrder::Function); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Adds directories to the list that the linker searches for libraries. Equivalent to `-L`.<CODESPLIT>pub fn library_search_path<P: AsRef<Path>>(&mut self, path: P) -> &mut Self { self.cmd.arg("-L"); self.cmd.arg(path.as_ref()); self }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>@ run-fail @ compile-flags: -Copt-level=3 -Cdebug-assertions=no -Zub-checks=yes @ error-pattern: unsafe precondition(s) violated: slice::get_unchecked requires @ revisions: usize range range_to range_from backwards_range<CODESPLIT>fn main() { unsafe { let s = &[0]; #[cfg(usize)] s.get_unchecked(1); #[cfg(range)] s.get_unchecked(1..2); #[cfg(range_to)] s.get_unchecked(..2); #[cfg(range_from)] s.get_unchecked(2..); #[cfg(backwards_range)] s.get_unchecked(1..0); } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `getSellNFTQuote` (0x0c295e56) function<CODESPLIT>pub fn get_sell_nft_quote( &self, num_nf_ts: ::ethers::core::types::U256, ) -> ::ethers::contract::builders::ContractCall< M, ( u8, ::ethers::core::types::U256, ::ethers::core::types::U256, ::ethers::core::types::U256, ::ethers::core::types::U256, ), > { self.0 .method_hash([12, 41, 94, 86], num_nf_ts) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Generate an AES-256 key<CODESPLIT>fn generate_aes_256() -> [u8; 32] { let mut buf = [0u8; 32]; let result = openssl::rand::rand_bytes(&mut buf[..]); assert!(result.is_ok()); buf }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>EMIT_MIR matches_reduce_branches.match_sext_i8_i16_failed.MatchBranchSimplification.diff Converting `-1i8` to `255i16` is zext.<CODESPLIT>fn match_sext_i8_i16_failed(i: EnumAi8) -> i16 { match i { EnumAi8::_128_0x80 => -128, EnumAi8::_1_0xff => 255, EnumAi8::o0_0x00 => 0, EnumAi8::o1_0x01 => 1, EnumAi8::o127_0x7f => 127, } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Generates a new `loan_invalidated_at(L, B)` fact.<CODESPLIT>fn emit_loan_invalidated_at(&mut self, b: BorrowIndex, l: Location) { let lidx = self.location_table.start_index(l); self.all_facts.loan_invalidated_at.push((lidx, b)); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>this function will create a memory snapshot and push it onto the stack of snapshots It should be used when you want to save the state of the memory, for example, when evolving a sandbox to a new state<CODESPLIT>pub(crate) fn push_state(&mut self) -> Result<()> { let snapshot = SharedMemorySnapshot::new(&mut self.shared_mem)?; self.snapshots .try_lock() .map_err(|e| new_error!("Error locking at {}:{}: {}", file!(), line!(), e))? .push(snapshot); Ok(()) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Calls the contract's `safeTransferFrom` (0xb88d4fde) function<CODESPLIT>pub fn safe_transfer_from_with_from_and_to_and_data( &self, from: ::ethers::core::types::Address, to: ::ethers::core::types::Address, token_id: ::ethers::core::types::U256, data: ::ethers::core::types::Bytes, ) -> ::ethers::contract::builders::ContractCall<M, ()> { self.0 .method_hash([184, 141, 79, 222], (from, to, token_id, data)) .expect("method not found (this should never happen)") }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Connects the NIC to a port on the given switch.<CODESPLIT>pub fn connect(&mut self, id: &SwitchPortId) -> io::Result<()> { let (switch16, port16) = id.c_ids(); unsafe { vmsif::chk(vmsif::VmsIfNicConnect( self.nic.as_raw_handle(), switch16.as_ptr(), port16.as_ptr(), c16(&self.nic_name)?.as_ptr(), Duration::from_secs(10).as_millis() as u32, ))?; Ok(()) } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Assumes values are in ascending order, returns matching index or the smaller value larger than target. Returns None if target is smaller than the smaller value.<CODESPLIT>pub(crate) fn binary_search_or_greater<T: Ord>(target: &T, array: &[T]) -> Option<i32> { let mut l = 0; let mut r = array.len(); while l < r { let mut m = (l + r) / 2; match &array[m].cmp(target) { Ordering::Less => { l = m + 1; } Ordering::Greater => { r = m; } Ordering::Equal => { while m > 1 { if &array[m - 1] == target { m -= 1; } else { break; } } return Some(m as i32); } } } if r == array.len() { return None; } Some(r as i32) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Generate a map of dependencies from a list of locked packages<CODESPLIT>fn generate_dependency_map( locked_deps: &[rattler_lock::LockedPackageRef<'_>], ) -> HashMap<String, Package> { let mut package_dependencies_map = HashMap::new(); for &package in locked_deps { if let Some(package_info) = extract_package_info(package) { package_dependencies_map.insert( package_info.name.clone(), Package { name: package_info.name, version: match package { LockedPackageRef::Conda(conda_data) => { conda_data.record().version.to_string() } LockedPackageRef::Pypi(pypi_data, _) => pypi_data.version.to_string(), }, dependencies: package_info.dependencies.into_iter().unique().collect(), needed_by: Vec::new(), source: package_info.source, }, ); } } package_dependencies_map }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>lazy_static! { pub(crate) static ref FONTS: RwLock<HashMap<String, Arc<Font>>> = Default::default(); }<CODESPLIT>pub fn get_font(font_name: &str) -> Option<Arc<Font>> { if let Ok(Some(font)) = load_font(font_name) { let font = Arc::new(font); Some(font) } else { None } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>CHECK: define{{.*}}5foo11{{.*}}!type ![[TYPE11:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}<CODESPLIT>pub fn foo12( _: &(dyn Trait1 + Send + Sync), _: &(dyn Trait1 + Sync + Send), _: &(dyn Trait1 + Sync + Send), ) { }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Checks if an item is visible and not `doc(hidden)` at the completion site.<CODESPLIT>pub(crate) fn is_visible<I>(&self, item: &I) -> Visible where I: hir::HasVisibility + hir::HasAttrs + hir::HasCrate + Copy, { let vis = item.visibility(self.db); let attrs = item.attrs(self.db); self.is_visible_impl(&vis, &attrs, item.krate(self.db)) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Demo in #48012<CODESPLIT>fn foo3r(n: u64) -> u64 { let mut count = 0; (0..n).for_each(|_| { (0..=n).rev().for_each(|j| { count += j; }) }); count }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Ensure that diagnostics for mutability error (because the root variable isn't mutable) work with `capture_disjoint_fields` enabled.<CODESPLIT>fn mut_error_struct() { let x = (10, 10); let y = (x, 10); let z = (y, 10); let mut c = || { z.0.0.0 = 20; }; c(); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Read a message from ` dev fuse`. An error is assumed to mean that the file system was unmounted.<CODESPLIT>fn read(&mut self, buffer: &mut [u8]) -> usize { match self.fuse_dev.read(buffer) { Ok(size) => size, Err(e) => { tracing::warn!( len = buffer.len(), error = &e as &dyn std::error::Error, "/dev/fuse read failed", ); 0 } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Read a buffer from the input stream. ### Examples ```ignore let data: Vec<u8> = sp1_zkvm::io::read_vec(); ```<CODESPLIT>pub fn read_vec() -> Vec<u8> { let len = unsafe { syscall_hint_len() }; let capacity = (len + 3) / 4 * 4; let layout = Layout::from_size_align(capacity, 4).expect("vec is too large"); let ptr = unsafe { std::alloc::alloc(layout) }; let mut vec = unsafe { Vec::from_raw_parts(ptr, 0, capacity) }; unsafe { syscall_hint_read(ptr, len); vec.set_len(len); } vec }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Gets the contract's `TokenWithdrawal` event<CODESPLIT>pub fn token_withdrawal_filter( &self, ) -> ::ethers::contract::builders::Event< ::std::sync::Arc<M>, M, TokenWithdrawalFilter, > { self.0.event() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>if-ext - if macro from different crate (related to callsite code) | cmd \ attr | no | (unspecified) | external | yes | | no | no | no | no | no | | (unspecified) | no | if-ext | if-ext | yes | | external | no | if-ext | if-ext | yes | | yes | yes | yes | yes | yes |<CODESPLIT>fn get_collapse_debuginfo(sess: &Session, attrs: &[ast::Attribute], ext: bool) -> bool { let flag = sess.opts.cg.collapse_macro_debuginfo; let attr = attr::find_by_name(attrs, sym::collapse_debuginfo) .and_then(|attr| { Self::collapse_debuginfo_by_name(attr) .map_err(|span| { sess.dcx().emit_err(errors::CollapseMacroDebuginfoIllegal { span }) }) .ok() }) .unwrap_or_else(|| { if attr::contains_name(attrs, sym::rustc_builtin_macro) { CollapseMacroDebuginfo::Yes } else { CollapseMacroDebuginfo::Unspecified } }); #[rustfmt::skip] let collapse_table = [ [false, false, false, false], [false, ext, ext, true], [false, ext, ext, true], [true, true, true, true], ]; collapse_table[flag as usize][attr as usize] }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>We should evaluate `x[2]` and copy the value out *before* evaluating the LHS and changing its value.<CODESPLIT>fn evaluate_fru_to_temp_before_assign_slice() { let mut x = &[S(0), S(1), S(2)][..]; let y = &mut S(7); *{ x = &[S(3), S(4), S(5)]; &mut *y } = S { ..x[2] }; assert_eq!(2, y.0); assert_eq!(5, x[2].0); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Returns the specialized log method for a given base if base is constant and is one of 2, 10 and e<CODESPLIT>fn get_specialized_log_method(cx: &LateContext<'_>, base: &Expr<'_>) -> Option<&'static str> { if let Some(value) = ConstEvalCtxt::new(cx).eval(base) { if F32(2.0) == value || F64(2.0) == value { return Some("log2"); } else if F32(10.0) == value || F64(10.0) == value { return Some("log10"); } else if F32(f32_consts::E) == value || F64(f64_consts::E) == value { return Some("ln"); } } None }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Set the key for reset token generation. Applicable to Server only.<CODESPLIT>pub fn set_reset_token_key(&mut self, v: [u8; 64]) { self.reset_token_key = hmac::Key::new(hmac::HMAC_SHA256, &v); }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Insert a new in-progress query. The query won't have a subscription or token, so you'll need to subsequently call `SyncState::complete_fetch` and `SyncState::fill_subscriptions` to fill out these fields.<CODESPLIT>pub fn insert(&mut self, query: Query) -> anyhow::Result<()> { let query_id = query.query_id; if self.in_progress_queries.insert(query_id, query).is_some() { anyhow::bail!("Duplicate query ID: {}", query_id); } self.refill_needed = true; Ok(()) }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Creates a new InternId. # Safety `value` must be less than `MAX`<CODESPLIT>pub const unsafe fn new_unchecked(value: u32) -> Self { debug_assert!(value < InternId::MAX); let value = unsafe { NonZeroU32::new_unchecked(value + 1) }; InternId { value } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Do we need a `QueryFunction` impl for this type of query?<CODESPLIT>fn needs_query_function(&self) -> bool { match self { QueryStorage::Input | QueryStorage::Interned | QueryStorage::InternedLookup { .. } | QueryStorage::Transparent => false, QueryStorage::Memoized | QueryStorage::LruMemoized | QueryStorage::LruDependencies => { true } } }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Same as `apply`, but returns `None` if self contains a module predicate<CODESPLIT>pub fn apply_any_module(self, tcx: TyCtxt<'tcx>, typing_env: TypingEnv<'tcx>) -> Option<bool> { self.apply_inner(tcx, typing_env, &mut Default::default(), &|_| Err(()), &|_| None).ok() }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>~^ ERROR: mutable references are not allowed in the final value of constants<CODESPLIT>const fn trigger() -> [(); unsafe { let s = transmute::<(*const u8, usize), &ManuallyDrop<str>>((S.as_ptr(), 3)); 0 }] { [(); 0] }
1<CODESPLIT>URLA<CODESPLIT>URLB<CODESPLIT>Insert a file description, giving it a file descriptor that is at least `min_fd_num`.<CODESPLIT>fn insert_with_min_num(&mut self, file_handle: FileDescriptionRef, min_fd_num: i32) -> i32 { let candidate_new_fd = self.fds.range(min_fd_num..).zip(min_fd_num..).find_map(|((fd_num, _fd), counter)| { if *fd_num != counter { Some(counter) } else { None } }); let new_fd_num = candidate_new_fd.unwrap_or_else(|| { self.fds.last_key_value().map(|(fd_num, _)| fd_num.strict_add(1)).unwrap_or(min_fd_num) }); self.fds.try_insert(new_fd_num, file_handle).unwrap(); new_fd_num }
