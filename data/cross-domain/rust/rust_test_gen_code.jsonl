[
    {
        "code_input": "I'm sorry, but the code you've provided seems to be incomplete and doesn't contain any information about the context in which it's being used. Could you please provide more details or clarify what you're trying to achieve?\n",
        "nl_input": "~^ ERROR cannot find value `n` in this scope ~| ERROR cannot find value `n` in this scope ~| ERROR cannot find value `n` in this scope ~| ERROR cannot find value `n` in this scope",
        "gt": "fn main() -> (){ for n in 0..1 { println!(\"{}\", f!()); } if let Some(n) = None { println!(\"{}\", f!()); } if false { } else if let Some(n) = None { println!(\"{}\", f!()); } while let Some(n) = None { println!(\"{}\", f!()); } }",
        "url": 0
    },
    {
        "code_input": "use image::{ImageFormat, Rgb};\nuse ocr::{OcrEngine, TextLine};\nuse std::fs::File;\nuse std::io::Read;\n\nfn main() {\n    let file = File::open(\"path_to_your_image_file\").unwrap();\n    let mut buffer = [0u8; 512];\n    let mut image = match ImageFormat::TryFrom(file).unwrap() {\n        Ok(format) => match format.decode(&mut File::open(\"path_to_your_image_file\").unwrap().unwrap().read(&mut buffer) {\n            Ok(img) => img,\n            Err(e) => panic!(\"Error decoding image: {:?}\", e),\n        },\n        Err(e) => panic!(\"Error reading image: {:?}\", e",
        "nl_input": "Recognize lines of text in an image. `lines` is an ordered list of the text line boxes in an image, produced by [OcrEngine::find_text_lines]. The output is a list of [TextLine]s corresponding to the input image regions. Entries can be `None` if no text was found in a given line.",
        "gt": "pub fn recognize_text( &self, input: &OcrInput, lines: &[Vec<RotatedRect>], ) -> anyhow::Result<Vec<Option<TextLine>>> { if let Some(recognizer) = self.recognizer.as_ref() { recognizer.recognize_text_lines( input.image.view(), lines, RecognitionOpt { debug: self.debug, decode_method: self.decode_method, alphabet: &self.alphabet, excluded_char_labels: self.excluded_char_labels.as_deref(), }, ) } else { Err(anyhow!(\"Recognition model not loaded\")) } }",
        "url": 1
    },
    {
        "code_input": "pub struct FieldWriter<T> {\n    current_field: Option<(usize, T)>,\n}\n\nimpl<T> FieldWriter<T> {\n    pub fn new() -> FieldWriter<T> {\n        FieldWriter {\n            current_field: None,\n        }\n    }\n\n    pub fn write_field(&mut self, n: usize, value: T) {\n        self.current_field = Some((n, value));\n    }\n\n    pub fn get_field(&self, n: usize) -> Option<&T> {\n        self.current_field.as_ref()?.1.get(n)\n    }\n}",
        "nl_input": "Returns a field writer for field number `n`. It's legal to write fields in any order and to write fields that duplicate previous fields. By convention, later fields overwrite previous ones (or append, in the case of sequences).",
        "gt": "pub fn field(&mut self, n: u32) -> FieldWriter<'_, 'buf, R> { self.state.field_number = n; self.state.in_sequence = false; FieldWriter { state: self.state } }",
        "url": 2
    },
    {
        "code_input": "#[builtin]\nfn builtin_function() {\n    println!(\"This is a built-in function.\");\n}",
        "nl_input": "Whether this builtin attribute is encoded cross crate. This means it can be used cross crate.",
        "gt": "pub fn encode_cross_crate(name: Symbol) -> bool { if let Some(attr) = BUILTIN_ATTRIBUTE_MAP.get(&name) { attr.encode_cross_crate == EncodeCrossCrate::Yes } else { true } }",
        "url": 3
    },
    {
        "code_input": "pub fn compare_token_streams(stream1: &TokenStream, stream2: &TokenStream) -> bool {\n    if stream1.tokens.len() != stream2.tokens.len() {\n        return false;\n    }\n\n    for (token1, token2) in stream1.tokens.iter().zip(stream2.tokens.iter()) {\n        if token1 != token2 {\n            return false;\n        }\n    }\n\n    true\n}",
        "nl_input": "Compares two `TokenStream`s, checking equality without regarding span information.",
        "gt": "pub fn eq_unspanned(&self, other: &TokenStream) -> bool { let mut t1 = self.trees(); let mut t2 = other.trees(); for (t1, t2) in iter::zip(&mut t1, &mut t2) { if !t1.eq_unspanned(t2) { return false; } } t1.next().is_none() && t2.next().is_none() }",
        "url": 4
    },
    {
        "code_input": "use protobuf_rs::{Message, Field, Field::Tag, Field::Type};\nuse std::io::Read;\nuse std::fs::File;\nuse std::io::SeekFrom;\n\nfn main() {\n    let file = File::open(\"path_to_your_file\").unwrap();\n    let mut reader = file.unwrap().try_into_reader();\n\n    let mut buffer = [0u8; 1024];\n    let mut total_read = 0;\n    while let Some(bytes_read) = reader.read(&mut buffer) {",
        "nl_input": "Convert an ApplicationProto into a byte slice.",
        "gt": "pub fn to_slice(&self) -> &[u8] { match self { Self::Interop => b\"hq-interop\", Self::Http09 => b\"http/0.9\", Self::H3 => b\"h3\", } }",
        "url": 5
    },
    {
        "code_input": "use web3::{Client, types::Address, types::HexString};\nuse serde_json::Value;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    let client = Client::new(\"http://localhost:8545\")?;\n\n    let contract_address = Address::from_str(\"0xa8174404\")?;\n\n    let result = client.call_contract(\n        \"matchOrders\",\n        &",
        "nl_input": "Calls the contract's `matchOrders` (0xa8174404) function",
        "gt": "pub fn match_orders( &self, orders: ::std::vec::Vec<Order>, fulfillments: ::std::vec::Vec<Fulfillment>, ) -> ::ethers::contract::builders::ContractCall<M, ::std::vec::Vec<Execution>> { self.0 .method_hash([168, 23, 68, 4], (orders, fulfillments)) .expect(\"method not found (this should never happen)\") }",
        "url": 6
    },
    {
        "code_input": "// Assume we have a struct named SlowStartState\nstruct SlowStartState {\n    delta: u32,\n}\n\n// Function to set the delta in a slow start state\nfn set_slow_start_state(state: &mut SlowStartState, new_delta: u32) {\n    state.delta = new_delta;\n}",
        "nl_input": "Set the delta in copa slow start state.",
        "gt": "pub fn set_copa_slow_start_delta(&mut self, v: f64) { self.recovery.copa_slow_start_delta = v; }",
        "url": 7
    },
    {
        "code_input": "use std::net::{SocketAddr, UdpSocket};\n\nfn send_datagram(addr: SocketAddr, buf: &[u8]) {\n    let mut socket = UdpSocket::bind(addr).unwrap();\n    socket.send(buf, addr).unwrap();\n}",
        "nl_input": "Sends the datagram in `buf`.",
        "gt": "fn send<'a>(&'a mut self, buf: &'a [u8]) -> Send<'a, Self> { Send { send: self, buf } }",
        "url": 8
    },
    {
        "code_input": "use std::fs;\nuse std::path::Path;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Serialize, Deserialize, Debug)]\nstruct GritFile {\n    name: String,\n    // Add other fields as needed\n}\n\nfn find_grit_files(dir: &Path) -> Vec<GritFile> {\n    let mut grit_files = Vec::new();\n\n    for entry in fs::read_dir(dir).expect(\"Failed to read directory\") {\n        let entry = entry.expect(\"Entry is None\");\n        let entry_path = entry.path();\n\n        if let Some(grit_file) = entry_path.file_name().and_then(|file_name| {\n            if file_name.to_str().unwrap_or(\"\").ends_with(\".grit\") {\n                let file_path = dir.join(file_name);\n                let file_content",
        "nl_input": "This is the primary entrypoint for finding and resolving the right grit files for a given directory It handles traversing upwards to find the .grit directory, initializing it, and parsing the .grit files",
        "gt": "pub async fn find_and_resolve_grit_dir( cwd: Option<PathBuf>, global_dir: Option<PathBuf>, ) -> Result<PatternsDirectory> { let existing_config = if let Some(cwd) = cwd { find_grit_dir_from(cwd).await } else { None }; match existing_config { Some(config) => get_grit_files_from_known_grit_dir(&config, vec![]).await, None => match global_dir { Some(global_dir) => { let stdlib_modules = get_stdlib_modules(); let repo = ModuleRepo::from_dir(&global_dir).await; get_grit_files(&repo, &global_dir.to_string_lossy(), Some(stdlib_modules)).await } None => Ok(PatternsDirectory::new()), }, } }",
        "url": 9
    },
    {
        "code_input": "use std::path::Path;\nuse std::process;\nuse std::fs;\nuse std::env;\n\nfn main() {\n    let root_dir = env::current_dir().unwrap();\n    let allocator_path = root_dir.join(\"allocator.rs\");\n\n    if !Path::new(allocator_path).exists() {\n        println!(\"Allocator not found\");\n        process::exit(1);\n    }\n\n    let allocator_content = fs::read_to_string(allocator_path).unwrap();\n\n    let mut object_files = Vec::new();\n\n    for file in std::process::args().skip(1) {\n        let file_path = Path::new(&file);\n        if file_path.is_file() {\n            let file_content = fs::read_to_string(&file",
        "nl_input": "Add object files for allocator code linked once for the whole crate tree.",
        "gt": "fn add_local_crate_allocator_objects(cmd: &mut dyn Linker, codegen_results: &CodegenResults) { if let Some(obj) = codegen_results.allocator_module.as_ref().and_then(|m| m.object.as_ref()) { cmd.add_object(obj); } }",
        "url": 10
    },
    {
        "code_input": "struct Node {\n    key: i32,\n    value: i32,\n    left: Option<Box<Node>>,\n    right: Option<Box<Node>>,\n}\n\nstruct Tree {\n    root: Option<Box<Node>>,\n    current: Option<Box<Node>>,\n}\n\nimpl Tree {\n    fn new() -> Self {\n        Tree {\n            root: None,\n            current: None,\n        }\n    }\n\n    fn insert(&mut self, key: i32, value: i32) {\n        let mut node = Box::new(Node {\n            key,\n            value,\n            left: None,\n            right: None,\n        });\n\n        if let Some(root) = self.root.take() {\n            self.insert_node(&mut root, &mut node);\n        } else {\n            self.root = Some(node);\n        }\n    }\n\n    fn insert_node(&",
        "nl_input": "Moves the leaf edge handle to the previous leaf edge and returns the key and value in between, deallocating any node left behind while leaving the corresponding edge in its parent node dangling. # Safety - There must be another KV in the direction travelled. - That leaf edge was not previously returned by counterpart `deallocating_next_unchecked` on any copy of the handles being used to traverse the tree. The only safe way to proceed with the updated handle is to compare it, drop it, or call this method or counterpart `deallocating_next_unchecked` again.",
        "gt": "unsafe fn deallocating_next_back_unchecked<A: Allocator + Clone>( &mut self, alloc: A, ) -> Handle<NodeRef<marker::Dying, K, V, marker::LeafOrInternal>, marker::KV> { super::mem::replace(self, |leaf_edge| unsafe { leaf_edge.deallocating_next_back(alloc).unwrap() }) }",
        "url": 11
    },
    {
        "code_input": "trait HasId {\n    fn id(&self) -> u32;\n}\n\nstruct MyStruct {\n    id: u32,\n    // other fields...\n}\n\nimpl HasId for MyStruct {\n    fn id(&self) -> u32 {\n        self.id\n    }\n}\n\nfn main() {\n    let my_struct = MyStruct { id: 1, // other fields... };\n    println!(\"{}\", my_struct.id());\n}",
        "nl_input": "Add an Id that appeared in a trait",
        "gt": "fn add_trait_item_id(&mut self, id: &'a Id) { self.add_id_checked(id, Kind::can_appear_in_trait, \"Trait inner item\"); }",
        "url": 12
    },
    {
        "code_input": "use std::collections::HashMap;\n\nfn get_upvar_list(upvar_list: &HashMap<String, Vec<Ty>>) -> Vec<Ty> {\n    let mut result = Vec::new();\n    for (_, vec) in upvar_list {\n        result.append(&mut vec);\n    }\n    result\n}",
        "nl_input": "Returns a list of `Ty`s for each upvar.",
        "gt": "fn final_upvar_tys(&self, closure_id: LocalDefId) -> Vec<Ty<'tcx>> { self.typeck_results .borrow() .closure_min_captures_flattened(closure_id) .map(|captured_place| { let upvar_ty = captured_place.place.ty(); let capture = captured_place.info.capture_kind; debug!(?captured_place.place, ?upvar_ty, ?capture, ?captured_place.mutability); apply_capture_kind_on_capture_ty( self.tcx, upvar_ty, capture, self.tcx.lifetimes.re_erased, ) }) .collect() }",
        "url": 13
    },
    {
        "code_input": "fn main() {\n    let x = 5;\n\n    match x {\n        1 => println!(\"x is 1\"),\n        2 => println!(\"x is 2\"),\n        3 => println!(\"x is 3\"),\n        _ => println!(\"x is not 1, 2, or 3\"),\n    }\n}",
        "nl_input": "EMIT_MIR match_arm_scopes.complicated_match SimplifyCfg-initial.after ElaborateDrops.after",
        "gt": "fn complicated_match(cond: bool, items: (bool, bool, String)) -> i32 { match items { (false, a, s) | (a, false, s) if if cond { return 3 } else { a } => 1, (true, b, t) | (false, b, t) => 2, } }",
        "url": 14
    },
    {
        "code_input": "fn ensure_independent_binding(binding: &mut Vec<String>, subpat: &mut Vec<String>) {\n    for b in binding.iter() {\n        for s in subpat.iter() {\n            if b.eq(s) {\n                println!(\"Binding and subpatterns are independent\");\n                return;\n            }\n        }\n    }\n    println!(\"Binding and subpatterns are not independent\");\n}\n\nfn main() {\n    let mut binding = vec![\"p1\".to_string(), \"p2\".to_string()];\n    let mut subpat = vec![\"p1\".to_string(), \"p2\".to_string()];\n    ensure_independent_binding(&mut binding, &mut subpat);\n}",
        "nl_input": "Ensures the independence of each side in `binding @ subpat` determine their binding modes independently of each other. That is, `binding` does not influence `subpat`. This is important because we might want to allow `p1 @ p2`, where both `p1` and `p2` are syntactically unrestricted patterns. If `binding` is allowed to influence `subpat`, this would create problems for the generalization aforementioned.",
        "gt": "fn main() { struct NotCopy; fn f1(a @ b: &NotCopy) { let _: &NotCopy = a; } fn f2(ref a @ b: &NotCopy) { let _: &&NotCopy = a; } let a @ b = &NotCopy; let _: &NotCopy = a; let ref a @ b = &NotCopy; let _: &&NotCopy = a; let ref a @ b = NotCopy; let _a: &NotCopy = a; let _b: NotCopy = b; let ref mut a @ b = NotCopy; let _a: &NotCopy = a; let _b: NotCopy = b; match Ok(NotCopy) { Ok(ref a @ b) | Err(b @ ref a) => { let _a: &NotCopy = a; let _b: NotCopy = b; } } match NotCopy { ref a @ b => { let _a: &NotCopy = a; let _b: NotCopy = b; } } }",
        "url": 15
    },
    {
        "code_input": "use std::collections::HashMap;\nuse std::path::Path;\nuse syntax::{Node, SyntaxTree, SyntaxTreeFactory};\n\nfn find_node_in_file(file_path: &Path, node_text: &str, offset: usize) -> Option<Node> {\n    let syntax_tree = SyntaxTreeFactory::from_file(file_path).unwrap();\n\n    let mut node_map = HashMap::new();\n\n    for node in syntax_tree.root().children() {\n        let range = node.range();\n        let start = range.start() + offset;\n        let end = range.end() + offset;\n\n        let node_text = node.text().get(start..end).unwrap",
        "nl_input": "Attempts to find `node` inside `syntax` via `node`'s text range while compensating for the offset introduced by the fake ident. This is wrong if `node` comes before the insertion point! Use `find_node_in_file` instead.",
        "gt": "fn find_node_in_file_compensated<N: AstNode>( sema: &Semantics<'_, RootDatabase>, in_file: &SyntaxNode, node: &N, ) -> Option<N> { ancestors_in_file_compensated(sema, in_file, node.syntax())?.find_map(N::cast) }",
        "url": 16
    },
    {
        "code_input": "fn extract_and_diverge(match_expr: &str) -> Option<(String, String)> {\n    match_expr.parse::<(&str, &str)>()?\n    .map(|(left, right)| (left.to_string(), right.to_string()))\n}",
        "nl_input": "Given a match expression, find extracting and diverging arms.",
        "gt": "fn find_arms( ctx: &AssistContext<'_>, match_expr: &ast::MatchExpr, ) -> Option<(ast::MatchArm, ast::MatchArm)> { let arms = match_expr.match_arm_list()?.arms().collect::<Vec<_>>(); if arms.len() != 2 { return None; } let mut extracting = None; let mut diverging = None; for arm in arms { if ctx.sema.type_of_expr(&arm.expr()?)?.original().is_never() { diverging = Some(arm); } else { extracting = Some(arm); } } match (extracting, diverging) { (Some(extracting), Some(diverging)) => Some((extracting, diverging)), _ => { cov_mark::hit!(non_diverging_match); None } } }",
        "url": 17
    },
    {
        "code_input": "use std::collections::HashMap;\nuse std::path::Path;\n\nfn map_node(path: &Path, node: &str) -> Option<&str> {\n    match node {\n        \"macro_expand\" => Some(\"macro_expand\"),\n        \"attribute_expansion\" => Some(\"attribute_expansion\"),\n        _ => None,\n    }\n}\n\nfn map_file(path: &Path) -> Option<HashMap<String, String>> {\n    let file_name = path.file_name().map_or(None, |name| name.to_str().map_or(None, |s| s.to_string()));\n    match file_name {\n        Some(file_name) if file_name.ends_with(\".rs\") => {\n            let content = std::fs::read_to_string(path).map_or(None, |content",
        "nl_input": "Attempts to map the node out of macro expanded files. This only work for attribute expansions, as other ones do not have nodes as input.",
        "gt": "pub fn original_syntax_node_rooted(&self, node: &SyntaxNode) -> Option<SyntaxNode> { let InFile { file_id, .. } = self.find_file(node); InFile::new(file_id, node).original_syntax_node_rooted(self.db.upcast()).map( |InRealFile { file_id, value }| { self.cache(find_root(&value), file_id.into()); value }, ) }",
        "url": 18
    },
    {
        "code_input": "use std::collections::HashSet;\n\nfn is_function_with_impl_trait(def_id: &str, trait_id: &str) -> bool {\n    let mut seen = HashSet::new();\n    let mut current_id = def_id;\n\n    while current_id.contains(\"impl\") {\n        if seen.contains(&current_id) {\n            return true;\n        }\n\n        seen.insert(current_id);\n\n        let next_id = current_id.split_off(\"impl \").unwrap_or(\"\");\n        current_id = next_id;\n    }\n\n    false\n}\n\nfn main() {\n    let def_id = \"fn foo(x: i32) -> i32 { x *",
        "nl_input": "Return `true` when the given `def_id` is a function that has `impl Trait` ty as one of its parameter types.",
        "gt": "fn fn_inputs_has_impl_trait_ty(cx: &LateContext<'_>, def_id: LocalDefId) -> bool { let inputs = cx.tcx.fn_sig(def_id).instantiate_identity().inputs().skip_binder(); inputs.iter().any(|input| { matches!( input.kind(), ty::Alias(ty::AliasTyKind::Weak, alias_ty) if cx.tcx.type_of(alias_ty.def_id).skip_binder().is_impl_trait() ) }) }",
        "url": 19
    },
    {
        "code_input": "use std::io::{self, Write};\n\nfn main() -> io::Result<()> {\n    // Open the device\n    let mut file = match io::File::open(\"/dev/ttyS0\") {\n        Ok(file) => file,\n        Err(e) => panic!(\"Failed to open the device: {:?}\", e),\n    };\n\n    // Set the baud rate\n    file.set_baud_rate(9600)?;\n\n    // Set the data bits\n    file.set_char_size(8)?;\n\n    // Set the stop bits\n    file.set_stop_bits(1)?;\n\n    // Set the parity\n    file.set_parity(io::Write::Parity::None)?;\n\n    // Set the flow control\n    file.set_flow_",
        "nl_input": "Synchronizes the line level of the interrupt line with the state of status register C.",
        "gt": "fn update_interrupt_line_level(&self) { let status_c = StatusRegC::from(self.state.cmos[CmosReg::STATUS_C]); if status_c.irq_update() || status_c.irq_periodic() || status_c.irq_alarm() { assert!(status_c.irq_combined()); if self.enlightened_interrupts { self.interrupt.set_level(false); } self.interrupt.set_level(true); } else { assert!(!status_c.irq_combined()); self.interrupt.set_level(false); } }",
        "url": 20
    },
    {
        "code_input": "use std::str::FromStr;\nuse std::ascii::AsciiExt;\n\nfn check_for_pointers(code: &str) -> bool {\n    let lines = code.lines();\n    for line in lines {\n        if line.contains(\"*\") {\n            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let code = r#\"\n    const MY_CONST: i32 = 42;\n    fn my_fn() -> i32 {\n    *MY_CONST\n    }\"#;\n\n    if check_for_pointers(&code) {\n        println!(\"Lint: Pointer to integer transmute in const function or associated constant\");\n    }\n}",
        "nl_input": "Check each block's terminator for calls to pointer to integer transmutes in const functions or associated constants and emit a lint.",
        "gt": "fn visit_terminator(&mut self, terminator: &Terminator<'tcx>, location: Location) { if let TerminatorKind::Call { func, .. } = &terminator.kind && let Some((func_def_id, _)) = func.const_fn_def() && self.tcx.is_intrinsic(func_def_id, sym::transmute) && self.is_ptr_to_int_in_const(func) && let Some(call_id) = self.body.source.def_id().as_local() { let hir_id = self.tcx.local_def_id_to_hir_id(call_id); let span = self.body.source_info(location).span; self.tcx.emit_node_span_lint( PTR_TO_INTEGER_TRANSMUTE_IN_CONSTS, hir_id, span, errors::UndefinedTransmute, ); } }",
        "url": 21
    },
    {
        "code_input": "use web3::{Http, JsonRpcClient, Web3};\nuse std::error::Error;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn Error>> {\n    let http = Http::new().expect(\"Failed to create HTTP client\");\n    let client = JsonRpcClient::new(http, \"http://localhost:8545\");\n\n    let contract_address = \"0x2f4fefaf\";\n    let function_name = \"getAllHeldIds\";\n\n    let result = client.call(contract_address, function_name, None).await?;\n\n    print",
        "nl_input": "Calls the contract's `getAllHeldIds` (0x2f4fefaf) function",
        "gt": "pub fn get_all_held_ids( &self, ) -> ::ethers::contract::builders::ContractCall< M, ::std::vec::Vec<::ethers::core::types::U256>, > { self.0 .method_hash([47, 79, 239, 175], ()) .expect(\"method not found (this should never happen)\") }",
        "url": 22
    },
    {
        "code_input": "struct Bid {\n    // Your bid data here\n}\n\nstruct BidIndex {\n    // Your bid index data here\n}\n\nfn is_part_of_bid(bids: &Vec<Bid>, bid_index: BidIndex) -> bool {\n    // Check if the bid at the given index is in the bid vector\n    bids.get(bid_index.idx).is_some()\n}",
        "nl_input": "Check if a moved place at `idx` is a part of a BID. The use of this check is that we will consider drops on these as a drop of the overall BID and, thus, we can exclude it from the diagnosis.",
        "gt": "fn place_descendent_of_bids<'tcx>( mut idx: MovePathIndex, move_data: &MoveData<'tcx>, bids: &UnordSet<&Place<'tcx>>, ) -> bool { loop { let path = &move_data.move_paths[idx]; if bids.contains(&path.place) { return true; } if let Some(parent) = path.parent { idx = parent; } else { return false; } } }",
        "url": 23
    },
    {
        "code_input": "pub enum NodeType {\n    Internal,\n    Leaf,\n}\n\npub struct Node {\n    node_type: NodeType,\n}\n\nimpl Node {\n    pub fn new(node_type: NodeType) -> Node {\n        Node { node_type }\n    }\n\n    pub fn is_internal(&self) -> bool {\n        self.node_type == NodeType::Internal\n    }\n\n    pub fn is_leaf(&self) -> bool {\n        self.node_type == NodeType::Leaf\n    }\n}",
        "nl_input": "Checks whether a node is an `Internal` node or a `Leaf` node.",
        "gt": "pub fn force( self, ) -> ForceResult< NodeRef<BorrowType, K, V, marker::Leaf>, NodeRef<BorrowType, K, V, marker::Internal>, > { if self.height == 0 { ForceResult::Leaf(NodeRef { height: self.height, node: self.node, _marker: PhantomData, }) } else { ForceResult::Internal(NodeRef { height: self.height, node: self.node, _marker: PhantomData, }) } }",
        "url": 24
    },
    {
        "code_input": "use tokio::time::{Duration, Instant};\nuse tokio_postgres::{NoTls, Error, Row};\nuse tokio_postgres::NoTls;\n\n#[tokio::main]\nasync fn main() -> Result<(), Error> {\n    let (client, connection) = tokio_postgres::connect(\n        \"postgres://username:password@localhost:5432/database\",\n        NoTls,\n    )\n    .await?;\n\n    let start_time = Instant::now();\n\n    let child = tokio::spawn(async move {\n        let row = client\n            .query(\n                \"SELECT * FROM table WHERE condition\",\n                &[]\n            )\n            .await?;\n\n        println!(\"{:?}\", row);\n    });\n\n    tok",
        "nl_input": "Returns a new child context with a timeout. The new context is notified when either this context is cancelled, or the timeout has expired.",
        "gt": "pub fn with_timeout(&self, timeout: Duration) -> Self { match Deadline::now().checked_add(timeout) { Some(deadline) => self.with_deadline(deadline), None => self.clone(), } }",
        "url": 25
    },
    {
        "code_input": "use web3::{Client, types::Address, types::HexString};\nuse serde_json::Value;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Create a new client\n    let client = Client::new(\"http://localhost:8545\")?;\n\n    // The address of the contract\n    let contract_address = Address::from_str(\"0xd8a1890c\")?;\n\n    // The",
        "nl_input": "Calls the contract's `changeSpotPrice` (0xd8a1890c) function",
        "gt": "pub fn change_spot_price( &self, new_spot_price: u128, ) -> ::ethers::contract::builders::ContractCall<M, ()> { self.0 .method_hash([216, 161, 137, 12], new_spot_price) .expect(\"method not found (this should never happen)\") }",
        "url": 26
    },
    {
        "code_input": "struct Flight {\n    in_flight_hi: u32,\n    increase_in_flight_hi: u32,\n}\n\nimpl Flight {\n    fn increase_in_flight_hi(&mut self) {\n        self.in_flight_hi += self.increase_in_flight_hi;\n    }\n}",
        "nl_input": "Increase inflight_hi if appropriate.",
        "gt": "fn probe_inflight_hi_upward(&mut self, is_cwnd_limited: bool) { if !is_cwnd_limited || self.cwnd < self.inflight_hi { return; } self.bw_probe_up_acks += self.ack_state.newly_acked_bytes; if self.bw_probe_up_acks >= self.bw_probe_up_cnt { let delta = self.bw_probe_up_acks / self.bw_probe_up_cnt; self.bw_probe_up_acks = self .bw_probe_up_acks .saturating_sub(delta * self.bw_probe_up_cnt); self.inflight_hi = self .inflight_hi .saturating_add(delta * self.config.max_datagram_size); } if self.is_round_start() { self.raise_inflight_hi_slope(); } }",
        "url": 27
    },
    {
        "code_input": "pub struct Queue<T> {\n    data: Vec<T>,\n    head: usize,\n    tail: usize,\n    capacity: usize,\n}\n\nimpl<T> Queue<T> {\n    pub fn new(capacity: usize) -> Self {\n        Queue {\n            data: Vec::with_capacity(capacity),\n            head: 0,\n            tail: 0,\n            capacity,\n        }\n    }\n\n    pub fn enqueue(&mut self, item: T) -> Result<(), &'static str> {\n        if self.tail - self.head == self.capacity {\n            return Err(\"Queue is full\");\n        }\n\n        self.data.push(item);\n        self.tail += 1;\n\n        if self.tail == self.capacity {\n            self",
        "nl_input": "Creates a new [`Queue`] with the provided capacity",
        "gt": "pub fn new(capacity: usize) -> Self { Self { data_ptr: OwningPointer::<MaybeUninit<T>>::new_with_alloc(capacity), capacity, len: 0, is_initialized: IoxAtomicBool::new(true), _phantom_data: PhantomData, } }",
        "url": 28
    },
    {
        "code_input": "use actix_web::{web, App, HttpResponse, HttpServer, Responder};\n\n// Define your data struct\nstruct Data {\n    id: i32,\n    name: String,\n}\n\n// Define your handler function\nasync fn handle_request(data: web::Json<Data>) -> impl Responder {\n    HttpResponse::Ok().json(data)\n}\n\n// Define your application\n#[actix_web::main]\nasync fn main() -> std::io::Result<()> {\n    HttpServer::new(|| {\n        App::new()\n            .route(\"/data\", web::get().to(handle_request))\n    })\n    .bind(\"127.0.0.1:8080\")?\n    .run()\n    .await\n}",
        "nl_input": "Create new route handler for the specified path, controller and path type.",
        "gt": "pub fn new(path: &str, controller: impl Controller + 'static, path_type: PathType) -> Self { Self { path: Path::parse(path).unwrap().with_regex(path_type).unwrap(), controller: Box::new(controller), name: None, rank: 0, } }",
        "url": 29
    },
    {
        "code_input": "use std::rc::Rc;\nuse std::cell::RefCell;\n\nfn main() {\n    let counter = Rc::new(RefCell::new(0));\n\n    let _ = move || {\n        let counter = counter.borrow_mut();\n        *counter += 1;\n        println!(\"Counter: {}\", *counter);\n    };\n}",
        "nl_input": "Make sure this Rc doesn't fall apart when touched",
        "gt": "fn check_unique_rc<T: ?Sized>(mut r: Rc<T>) { let r2 = r.clone(); assert!(Rc::get_mut(&mut r).is_none()); drop(r2); assert!(Rc::get_mut(&mut r).is_some()); }",
        "url": 30
    },
    {
        "code_input": "fn main() {\n    let mut x = 5;\n    let y = &mut x;\n    *y = 10;\n}",
        "nl_input": "Make sure that we cannot return a `&mut` that got already invalidated, not even in a tuple.",
        "gt": "fn foo(x: &mut (i32, i32)) -> (&mut i32,) { let xraw = x as *mut (i32, i32); let ret = (unsafe { &mut (*xraw).1 },); let _val = unsafe { *xraw }; ret }",
        "url": 31
    },
    {
        "code_input": "fn should_generate_cpp_like_names_and_debug_info() -> bool {\n    // This function should return true if we should generate C++-like names and debug information,\n    // and false otherwise. This is a placeholder and should be replaced with actual logic.\n\n    // For the purpose of this example, we'll return true for now.\n    true\n}\n\nfn main() {\n    if should_generate_cpp_like_names_and_debug_info() {\n        println!(\"Generating C++-like names and debug information.\");\n        // This is a placeholder for the actual code that generates C++-like names and debug information.\n        // Replace this with the actual code.\n        println!(\"Generating C++-like names and debug information.\");\n    } else {\n        println!(\"Skipping C++-like names and debug information generation.\");\n    }\n}",
        "nl_input": "Check if we should generate C++ like names and debug information.",
        "gt": "pub fn cpp_like_debuginfo(tcx: TyCtxt<'_>) -> bool { tcx.sess.target.is_like_msvc }",
        "url": 32
    },
    {
        "code_input": "use std::env;\nuse std::process;\n\nfn main() {\n    // Set environment variables\n    env::set(\"MY_VAR\", \"my_value\");\n    env::set(\"OTHER_VAR\", \"other_value\");\n\n    // Get environment variables\n    let my_var = env::var(\"MY_VAR\").unwrap();\n    let other_var = env::var(\"OTHER_VAR\").unwrap();\n\n    // Print environment variables\n    println!(\"MY_VAR: {}\", my_var.value());\n    println!(\"OTHER_VAR: {}\", other_var.value());\n\n    // Run a command with the environment variables\n    process::cmd(\"echo $MY_VAR $OTHER_VAR\").unwrap();\n}",
        "nl_input": "Sets multiple environment variables for the command.",
        "gt": "pub fn envs<I, K, V>(mut self, vars: I) -> Self where I: IntoIterator<Item = (K, V)>, K: AsRef<str>, V: AsRef<str>, { for (k, v) in vars.into_iter() { self = self.env(k.as_ref(), v.as_ref()); } self }",
        "url": 33
    },
    {
        "code_input": "use std::collections::HashMap;\n\nfn add_subtract_columns(matrix: &Vec<Vec<f64>>, operations: &HashMap<String, (String, f64)>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for row in matrix {\n        let mut new_row = Vec::new();\n        for column in 0..row.len() {\n            let operation = operations.get(&row[column].to_string()).unwrap();\n            match operation.0.as_str() {\n                \"add\" => {\n                    let value = operation.1;\n                    new_row.push(row[column] + value);\n                }\n                \"subtract\" => {\n                    let value = operation.1;\n                    new_row.push(row[column] -",
        "nl_input": "The counterpart of `add_subtract_columns` for evaluating decimal expressions.",
        "gt": "pub(crate) fn scale_and_add_subtract_eval<S: Scalar>( lhs_eval: S, rhs_eval: S, lhs_scale: i8, rhs_scale: i8, is_subtract: bool, ) -> S { let max_scale = lhs_scale.max(rhs_scale); let left_scaled_eval = lhs_eval * S::pow10(max_scale.abs_diff(lhs_scale)); let right_scaled_eval = rhs_eval * S::pow10(max_scale.abs_diff(rhs_scale)); if is_subtract { left_scaled_eval - right_scaled_eval } else { left_scaled_eval + right_scaled_eval } }",
        "url": 34
    },
    {
        "code_input": "fn main() {\n    let x = 5;\n    let y = 10;\n    let z = x + y;\n    println!(\"The sum of {} and {} is {}\", x, y, z);\n}",
        "nl_input": "CHECK-LABEL: fn main(",
        "gt": "fn main() { let local = (&[1u32, 2, 3] as &[u32])[1]; const SLICE: &[u32] = &[1, 2, 3]; let constant = SLICE[1]; }",
        "url": 35
    },
    {
        "code_input": "use web3::{Client, types::Address, types::Hex};\nuse serde_json::Value;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Create a new client\n    let client = Client::new(\"http://localhost:8545\")?;\n\n    // The address of the contract\n    let contract_address = Address::from_str(\"0xa93ec68b\")?;",
        "nl_input": "Calls the contract's `routerStatus` (0xa93ec68b) function",
        "gt": "pub fn router_status( &self, p0: ::ethers::core::types::Address, ) -> ::ethers::contract::builders::ContractCall<M, (bool, bool)> { self.0 .method_hash([169, 62, 198, 139], p0) .expect(\"method not found (this should never happen)\") }",
        "url": 36
    },
    {
        "code_input": "let byte_slice: &[u8] = &[0x01, 0x02, 0x03, 0x04];\nlet vec = Vec::from_slice(byte_slice);",
        "nl_input": "vec![0xd] followed by extend_from_slice looks weird",
        "gt": "pub fn encode_string(value: &[u8]) -> Vec<u8> { let mut byte_stream: Vec<u8> = Vec::new(); byte_stream.push(0xd); byte_stream.extend_from_slice(value); byte_stream.push(0); byte_stream }",
        "url": 37
    },
    {
        "code_input": "use std::ptr;\n\nfn from_raw_parts<T: Sized>(ptr: &'static [T]) -> bool {\n    let raw_ptr = ptr.as_ptr();\n    let _ = unsafe { ptr::const_cast::const_cast_ptr::<T>(raw_ptr) };\n    true\n}\n\nfn main() {\n    let array: [u8; 10] = [0; 10];\n    let array_ptr = &array[0..];\n    println!(\"{}\", from_raw_parts(&array_ptr));\n}",
        "nl_input": "Check that we can const-prop into `from_raw_parts`",
        "gt": "fn slice_const_length(x: &[i32]) -> *const [i32] { let ptr = x.as_ptr(); let len = 123; std::intrinsics::aggregate_raw_ptr(ptr, len) }",
        "url": 38
    },
    {
        "code_input": "use crate::{DefId, Res};\n\nfn get_module_def_id(res: &Res) -> DefId {\n    // This is a placeholder, replace with your actual logic\n    res.id\n}",
        "nl_input": "Return the `DefId` of this `Res` if it represents a module.",
        "gt": "pub fn mod_def_id(&self) -> Option<DefId> { match *self { Res::Def(DefKind::Mod, id) => Some(id), _ => None, } }",
        "url": 39
    },
    {
        "code_input": "fn main() {\n    println!(\"{}\", \"duplicate_switch_targets.ub_if_b.PreCodegen.after.mir\");\n}",
        "nl_input": "EMIT_MIR duplicate_switch_targets.ub_if_b.PreCodegen.after.mir",
        "gt": "pub unsafe fn ub_if_b(t: Thing) -> Thing { match t { Thing::A => t, Thing::B => std::hint::unreachable_unchecked(), } }",
        "url": 40
    },
    {
        "code_input": "fn main() {\n    let numbers = vec![1, 2, 3, 4, 5];\n    let index = 2;\n    let result = get_index(&numbers, index);\n    println!(\"{}\", result);\n}\n\nfn get_index(numbers: &Vec<i32>, index: usize) -> i32 {\n    numbers[index]\n}",
        "nl_input": "Performs a single point get using an index.",
        "gt": "async fn index_get( &self, index_id: IndexId, tablet_id: TabletId, read_timestamp: Timestamp, key: IndexKey, retention_validator: Arc<dyn RetentionValidator>, ) -> anyhow::Result<Option<(Timestamp, ResolvedDocument)>> { let mut stream = self.index_scan( index_id, tablet_id, read_timestamp, &Interval::prefix(key.into_bytes().into()), Order::Asc, 2, retention_validator, ); match stream.try_next().await? { Some((key, ts, doc)) => { anyhow::ensure!( stream.try_next().await?.is_none(), \"Got multiple values for key {:?}\", key ); Ok(Some((ts, doc))) }, None => Ok(None), } }",
        "url": 41
    },
    {
        "code_input": "use web3::{Client, types::Address, types::HexString};\nuse serde_json::Value;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Create a new client\n    let client = Client::new(\"http://localhost:8545\")?;\n\n    // The address of the contract\n    let contract_address = Address::from_str(\"0x6809f664\")?;\n\n    // The ABI",
        "nl_input": "Calls the contract's `changeDelta` (0x6809f664) function",
        "gt": "pub fn change_delta( &self, new_delta: u128, ) -> ::ethers::contract::builders::ContractCall<M, ()> { self.0 .method_hash([104, 9, 246, 100], new_delta) .expect(\"method not found (this should never happen)\") }",
        "url": 42
    },
    {
        "code_input": "use std::type::Type;\n\nfn is_primitive_or_adt_or_trait_object(ty: &Type) -> bool {\n    match ty {\n        Type::Primitive(_) => true,\n        Type::Struct(_) => true,\n        Type::Enum(_) => true,\n        Type::Tuple(_) => true,\n        Type::Array(_) => true,\n        Type::Fn(_) => true,\n        Type::I8 => true,\n        Type::U8 => true,\n        Type::I16 => true,\n        Type::U16 => true,\n        Type::I32 => true,\n        Type::U32 => true,\n        Type::I64 => true,\n        Type::U64 => true,\n        Type::Float => true,\n        Type::Double => true,\n        Type::Bool => true,\n        Type::Char => true,\n        Type::Any => true,",
        "nl_input": "Returns `true` when the outermost type cannot be further normalized, resolved, or instantiated. This includes all primitive types, but also things like ADTs and trait objects, since even if their arguments or nested types may be further simplified, the outermost [`TyKind`] or type constructor remains the same.",
        "gt": "pub fn is_known_rigid(self) -> bool { match self.kind() { Bool | Char | Int(_) | Uint(_) | Float(_) | Adt(_, _) | Foreign(_) | Str | Array(_, _) | Pat(_, _) | Slice(_) | RawPtr(_, _) | Ref(_, _, _) | FnDef(_, _) | FnPtr(..) | Dynamic(_, _, _) | Closure(_, _) | CoroutineClosure(_, _) | Coroutine(_, _) | CoroutineWitness(..) | Never | Tuple(_) => true, Error(_) | Infer(_) | Alias(_, _) | Param(_) | Bound(_, _) | Placeholder(_) => false, } }",
        "url": 43
    },
    {
        "code_input": "use iceoryx2_bb_posix::clock::*;\nuse std::time::{SystemTime, Instant};\n\nfn main() {\n    let now: SystemTime = SystemTime::now().unwrap();\n    println!(\"{}\", now);\n}",
        "nl_input": "Returns the current time. # Examples ```ignore use iceoryx2_bb_posix::clock::*; let now: Time = Time::now_with_clock(ClockType::Monotonic).unwrap(); ```",
        "gt": "pub fn now_with_clock(clock_type: ClockType) -> Result<Self, TimeError> { let mut current_time = posix::timespec { tv_sec: 0, tv_nsec: 0, }; handle_errno!(TimeError, from \"Time::now\", errno_source unsafe { posix::clock_gettime(clock_type as _, &mut current_time).into() }, success Errno::ESUCCES => Time { clock_type, seconds: current_time.tv_sec as u64, nanoseconds: current_time.tv_nsec as u32}, Errno::ENOSYS => (ClockTypeIsNotSupported, \"Failed to get time {{ clock_type: {:?} }} since the clock is not supported.\", clock_type), v => (UnknownError(v as i32), \"Failed to get time {{ clock_type: {:?} }} since an unknown error occurred ({}).\", clock_type, v) ); }",
        "url": 44
    },
    {
        "code_input": "use reqwest::Error;\n\n#[tokio::main]\nasync fn main() -> Result<(), Error> {\n    let resp = reqwest::get(\"http://example.com\").await?;\n\n    println!(\"Response status: {}\", resp.status());\n\n    Ok(())\n}",
        "nl_input": "Attempt to create a new client by connecting to a given endpoint.",
        "gt": "pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error> where D: TryInto<tonic::transport::Endpoint>, D::Error: Into<StdError>, { let conn = tonic::transport::Endpoint::new(dst)?.connect().await?; Ok(Self::new(conn)) }",
        "url": 45
    },
    {
        "code_input": "use rayon::prelude::*;\n\nfn main() {\n    let executor = rayon::ThreadPoolBuilder::new()\n        .num_threads(4)\n        .build()\n        .unwrap();\n\n    let result = executor.spawn(|| {\n        // This is your task.\n        println!(\"Task running...\");\n    })\n    .unwrap();\n\n    println!(\"Result: {}\", result);\n}",
        "nl_input": "Spawn a new task on the executor.",
        "gt": "pub fn spawn<F, R>(&self, f: F) -> JoinHandle<R> where F: FnOnce() -> R + Send + 'static, R: Send + 'static, { tokio::task::spawn_blocking(f) }",
        "url": 46
    },
    {
        "code_input": "struct Value {\n    sort_keys: Vec<i32>,\n}\n\nfn parse_values(values: Vec<Value>) -> Vec<Vec<i32>> {\n    values.into_iter().map(|value| value.sort_keys.clone()).collect()\n}",
        "nl_input": "Parse a `Vec<Value>` from it respective sort keys.",
        "gt": "pub fn bytes_to_values<R: Read>(reader: &mut R) -> anyhow::Result<Vec<Option<ConvexValue>>> { let reader = &mut BytePeeker::new(reader); let mut values = vec![]; while reader.peek()?.is_some() { let value = ConvexValue::_read_sort_key(reader)?; values.push(Some(value)); } Ok(values) }",
        "url": 47
    },
    {
        "code_input": "use std::fs::Metadata;\nuse std::os::unix::fs::PermissionsExt;\nuse std::time::SystemTime;\nuse std::time::UNIX_EPOCH;\n\nuse fuse_rs::{Stat, Attr, AttrExt, AttrVec, AttrVecExt, AttrVecMut};\n\nfn stat_to_attr(mut stat: Metadata) -> Attr {\n    let mut attr = Attr::default();\n\n    // Convert the inode number\n    attr.st_ino = stat.inode().id();\n\n    // Convert the number of hard links\n    attr.st_nlink = stat.num_links() as u64;\n\n    // Convert the file mode\n    attr.st_mode = match stat.file_type() {\n        std::fs::FileType::Regular => attr.st_mode.or_in_place",
        "nl_input": "Convert a Linux stat struct to FUSE attributes.",
        "gt": "pub fn stat_to_fuse_attr(stat: &lx::Stat) -> fuse_attr { fuse_attr { ino: stat.inode_nr, size: stat.file_size, blocks: stat.block_count, atime: stat.access_time.seconds as u64, mtime: stat.write_time.seconds as u64, ctime: stat.change_time.seconds as u64, atimensec: stat.access_time.nanoseconds as u32, mtimensec: stat.write_time.nanoseconds as u32, ctimensec: stat.change_time.nanoseconds as u32, mode: stat.mode, nlink: stat.link_count as _, uid: stat.uid, gid: stat.gid, rdev: stat.device_nr_special as u32, blksize: stat.block_size as _, padding: 0, } }",
        "url": 48
    },
    {
        "code_input": "use std::fs::File;\nuse std::io::Read;\nuse std::path::Path;\nuse serde::{Deserialize};\nuse ed25519_dalek::{PublicKey, Signature, Signer, Seed};\n\n#[derive(Debug, Deserialize)]\nstruct Credentials {\n    public_key: String,\n    private_key: String,\n}\n\nfn main() {\n    let path = Path::new(\"credentials.json\");\n    let mut file = File::open(&path).expect(\"File not found\");\n    let mut contents = String::new();\n    file.read_to_string(&mut contents).expect(\"Error reading file\");\n\n    let credentials: Credentials = serde_json::from_str(&contents).expect(\"Error parsing JSON\");\n\n    let public_key = PublicKey::from_slice(&",
        "nl_input": "Creates credentials from the network and private key",
        "gt": "pub fn new( network: Network, master_key: ExtendedPrivKey, index: u32, ) -> StacksResult<Self> { let private_key = derive_key(master_key, stacks_derivation_path(index)?) .to_priv() .inner; Ok(Self { network, private_key, }) }",
        "url": 49
    },
    {
        "code_input": "fn increment_bytes(bytes: Vec<u8>) -> Vec<u8> {\n    let mut new_bytes = Vec::new();\n    for byte in bytes {\n        new_bytes.push(byte + 1);\n    }\n    new_bytes\n}",
        "nl_input": "Make sure casts between thin-pointer <-> fat pointer obey RFC401",
        "gt": "fn main() { let a: &[i32] = &[1, 2, 3]; let b: Box<[i32]> = Box::new([1, 2, 3]); let p = a as *const [i32]; let q = a.as_ptr(); a as usize; a as isize; a as i16; a as u32; b as usize; p as usize; q as *const [i32]; let t: *mut (dyn Trait + 'static) = 0 as *mut _; let mut fail: *const str = 0 as *const str; let mut fail2: *const str = 0isize as *const str; }",
        "url": 50
    },
    {
        "code_input": "fn factorial(n: u64) -> u64 {\n    match n {\n        0 => 1,\n        1 => 1,\n        _ => n * factorial(n - 1),\n    }\n}\n\nfn main() {\n    println!(\"{}\", factorial(5));\n}",
        "nl_input": "@ edition: 2021 @ check-pass",
        "gt": "pub fn f1() -> impl std::future::Future<Output = Result<(), String>> + Send { async { should_work().await?; Ok(()) } }",
        "url": 51
    },
    {
        "code_input": "I'm sorry, but I can't find the issue number 31073. It seems like there might be a typo or the issue might not exist. Could you please provide more details or check the issue number?\n",
        "nl_input": "@ pp-exact:issue-31073.pp",
        "gt": "fn main() { fn f1(x: i32, y: i32) -> i32 { y } let f: fn(_, i32) -> i32 = f1; f(1, 2); }",
        "url": 52
    },
    {
        "code_input": "use std::sync::{RwLock, RwLockReadGuard, RwLockWriteGuard};\n\nfn create_write_guard<T: Clone + Copy>(rw_lock: &RwLock<T>) -> Option<RwLockWriteGuard<T>> {\n    match rw_lock.write().and_then(|guard| guard.clone()) {\n        Ok(guard) => Some(guard),\n        Err(_) => None,\n    }\n}",
        "nl_input": "Create a new instance of `RwLockWriteGuard<T>` from a `RwLock<T>`. SAFETY: if and only if `lock.inner.write()` (or `lock.inner.try_write()`) has been successfully called from the same thread before instantiating this object.",
        "gt": "unsafe fn new(lock: &'rwlock RwLock<T>) -> LockResult<RwLockWriteGuard<'rwlock, T>> { Ok(RwLockWriteGuard { lock, poison: () }) }",
        "url": 53
    },
    {
        "code_input": "fn main() {\n    let _ = ();\n}",
        "nl_input": "If we're looking at a block that is supposed to return `()`, type inference will just tell us it has type `()`. We have to look at the tail expression to see the mismatched actual type. This 'unpeels' the various blocks to hopefully let us see the type the user intends. (This still doesn't handle all situations fully correctly; the 'ideal' way to handle this would be to run type inference on the function again, but with a variable as the return type.)",
        "gt": "fn peel_blocks(mut expr: ast::Expr) -> ast::Expr { loop { match_ast! { match (expr.syntax()) { ast::BlockExpr(it) => { if let Some(tail) = it.tail_expr() { expr = tail.clone(); } else { break; } }, ast::IfExpr(it) => { if let Some(then_branch) = it.then_branch() { expr = ast::Expr::BlockExpr(then_branch.clone()); } else { break; } }, ast::MatchExpr(it) => { if let Some(arm_expr) = it.match_arm_list().and_then(|l| l.arms().next()).and_then(|a| a.expr()) { expr = arm_expr; } else { break; } }, _ => break, } } } expr }",
        "url": 54
    },
    {
        "code_input": "struct GenerationId {\n    id: u32,\n}\n\nstruct Generation {\n    generation_id: GenerationId,\n}\n\nimpl Generation {\n    fn update_generation_id(&mut self, new_id: u32) {\n        self.generation_id.id = new_id;\n    }\n}",
        "nl_input": "Update the low bits of the generation id pointer",
        "gt": "pub(crate) fn write_generation_id_low(&mut self, data: u32) { self.service.generation_id.write_generation_id_low(data) }",
        "url": 55
    },
    {
        "code_input": "fn main() {\n    let s = \"Hello, world!\";\n    let mut r = s.as_mut();\n    *r = \"Goodbye, world!\";\n    println!(\"{}\", r);\n}",
        "nl_input": "Using a raw invalidates derived `&mut` even for reading.",
        "gt": "fn main() { let mut x = 2; let xref1 = &mut x; let xraw = xref1 as *mut _; let xref2 = unsafe { &mut *xraw }; let _val = unsafe { *xraw }; let _illegal = *xref2; }",
        "url": 56
    },
    {
        "code_input": "struct Connection {\n    max_undecryptable_packets: u32,\n}\n\nimpl Default for Connection {\n    fn default() -> Self {\n        Self {\n            max_undecryptable_packets: 10,\n        }\n    }\n}",
        "nl_input": "Set the maximum number of undecryptable packets that can be stored by one connection. The default value is `10`. A value of 0 will be treated as default value.",
        "gt": "pub fn set_max_undecryptable_packets(&mut self, v: usize) { if v > 0 { self.max_undecryptable_packets = v; } else { self.max_undecryptable_packets = 10; } }",
        "url": 57
    },
    {
        "code_input": "use crate::mir::operand::OperandValue;\n\nfn load_operand(self) -> OperandValue::Ref {\n    OperandValue::Ref {\n        // This is a placeholder, it doesn't load anything\n        value: 0,\n        // This is also a placeholder, it doesn't load anything\n        offset: 0,\n        // This is a placeholder, it doesn't load anything\n        size: 0,\n    }\n}",
        "nl_input": "A type that produces an [`OperandValue::Ref`] when loaded. AKA one that's not a ZST, not `is_backend_immediate`, and not `is_backend_scalar_pair`. For such a type, a [`load_operand`] doesn't actually `load` anything. [`OperandValue::Ref`]: crate::mir::operand::OperandValue::Ref [`load_operand`]: super::BuilderMethods::load_operand",
        "gt": "fn is_backend_ref(&self, layout: TyAndLayout<'tcx>) -> bool { !(layout.is_zst() || self.is_backend_immediate(layout) || self.is_backend_scalar_pair(layout)) }",
        "url": 58
    },
    {
        "code_input": "use near_sdk::{env, near_bindgen};\n\n#[near_bindgen]\nimpl env::contract {\n    #[init]\n    fn new(_delegate: env::delegate::Delegate) {}\n\n    #[finality(\"final\")]\n    fn asset_recipient(&self, _msg: env::msg::Msg) {\n        let contract_id = env::current_account_id();\n        let contract_account = env::account_info(contract_id).unwrap();\n        let contract_account_id = contract_account.account_id.to_string_lossy();\n\n        // Replace with your actual contract's address\n        let contract_address = \"0x3bfa67fe\".to_string_lossy();\n\n        // Call the contract's",
        "nl_input": "Calls the contract's `assetRecipient` (0x3bfa67fe) function",
        "gt": "pub fn asset_recipient( &self, ) -> ::ethers::contract::builders::ContractCall< M, ::ethers::core::types::Address, > { self.0 .method_hash([59, 250, 103, 254], ()) .expect(\"method not found (this should never happen)\") }",
        "url": 59
    },
    {
        "code_input": "use reqwest::Error;\nuse tokio::net::TcpStream;\nuse tokio::prelude::*;\nuse tokio::sync::mpsc;\n\n#[tokio::main]\nasync fn main() -> Result<(), Error> {\n    let (tx, rx) = mpsc::channel(1);\n\n    let request_id = \"12345\";\n\n    let client = reqwest::Client::new();\n\n    let url = \"http://example.com\";\n\n    let response = client.get(url)\n        .header(\"Message-ID\", request_id)\n        .send()\n        .await?\n        .text()\n        .await?;\n\n    if response.header(\"Message-ID\") == Some(request_id) {\n        println!(\"Response received successfully\");\n    } else {\n        println!(\"Response",
        "nl_input": "Sends a request to the host and waits for a fixed-size response. Fails if the response's message ID does not match the request's message ID.",
        "gt": "async fn send_request_fixed_size<T: AsBytes + ?Sized, U: AsBytes + FromBytes>( &mut self, data: &T, ) -> Result<U, FatalError> { self.send_message(data.as_bytes().to_vec()); let req_header = get_protocol::HeaderHostRequest::read_from_prefix(data.as_bytes()).unwrap(); self.recv_response_fixed_size(req_header.message_id).await }",
        "url": 60
    },
    {
        "code_input": "I'm sorry, but the code you've provided seems to be a build script for Rust, not a question. Could you please provide more context or clarify what you're asking for?\n",
        "nl_input": "@ build-pass @ compile-flags:-Zpolymorphize=on -Csymbol-mangling-version=v0",
        "gt": "fn foo(f: impl Fn()) { let outer = Vec::<u32>::new(); let x = move |_: ()| { let inner = outer; () }; let y = || x(()); f(); y(); }",
        "url": 61
    },
    {
        "code_input": "use pathfinder::Path;\nuse std::path::PathBuf;\n\nfn get_relative_path_to_recipe(source_dir: &PathBuf, recipe_path: &PathBuf) -> Path {\n    let relative_path = source_dir.relative(recipe_path).unwrap();\n    relative_path\n}",
        "nl_input": "Returns the relative path from the source directory to the recipe.",
        "gt": "pub fn manifests(&self) -> Vec<String> { self.recipe_dir .strip_prefix(&self.source_dir) .unwrap_or(&self.recipe_dir) .join(\"meta.yaml\") .to_str() .map(|s| s.to_string()) .into_iter() .collect() }",
        "url": 62
    },
    {
        "code_input": "use web3::{Client, types::Address, types::HexString};\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Create a new Web3 client\n    let client = Client::new(\"https://mainnet.infura.io/v3/YOUR_INFURA_PROJECT_ID\")?;\n\n    // The address of the contract\n    let contract_address = Address::from_str(\"0xa5cb2b91\")?;\n\n    // The ABI of the contract\n    let abi = r#\"\n    [\n        {\n            \"constant\": true,\n            \"inputs\": [],\n            \"name\": \"getBuyNFTQuote\",\n            \"outputs\": [\n                {\n                    \"name\": \"\",\n                    \"type\":",
        "nl_input": "Calls the contract's `getBuyNFTQuote` (0xa5cb2b91) function",
        "gt": "pub fn get_buy_nft_quote( &self, num_nf_ts: ::ethers::core::types::U256, ) -> ::ethers::contract::builders::ContractCall< M, ( u8, ::ethers::core::types::U256, ::ethers::core::types::U256, ::ethers::core::types::U256, ::ethers::core::types::U256, ), > { self.0 .method_hash([165, 203, 43, 145], num_nf_ts) .expect(\"method not found (this should never happen)\") }",
        "url": 63
    },
    {
        "code_input": "use web3::{Client, types::Address, types::HexString};\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Create a new Web3 client\n    let client = Client::new(\"https://mainnet.infura.io/v3/YOUR_INFURA_PROJECT_ID\")?;\n\n    // The address of the contract\n    let contract_address = Address::from_str(\"0xa5cb2b91\")?;\n\n    // The ABI of the contract\n    let abi = r#\"\n    [\n        {\n            \"constant\": true,\n            \"inputs\": [],\n            \"name\": \"getBuyNFTQuote\",\n            \"outputs\": [\n                {\n                    \"name\": \"\",\n                    \"type\":",
        "nl_input": "Calls the contract's `getBuyNFTQuote` (0xa5cb2b91) function",
        "gt": "pub fn get_buy_nft_quote( &self, num_nf_ts: ::ethers::core::types::U256, ) -> ::ethers::contract::builders::ContractCall< M, ( u8, ::ethers::core::types::U256, ::ethers::core::types::U256, ::ethers::core::types::U256, ::ethers::core::types::U256, ), > { self.0 .method_hash([165, 203, 43, 145], num_nf_ts) .expect(\"method not found (this should never happen)\") }",
        "url": 64
    },
    {
        "code_input": "use std::collections::HashMap;\n\nfn convert_to_local_inference_variable(r: &mut ParamEnv, indices: &mut HashMap<usize, usize>) -> &mut InferenceVariable {\n    let local_indices = indices.get(&r.index).unwrap();\n    match r {\n        InferenceVariable::Local(i) if i == *local_indices => &mut r,\n        _ => {\n            *r.mut_as_mut() = InferenceVariable::Local(local_indices.clone());\n            &mut r\n        }\n    }\n}",
        "nl_input": "Converts `r` into a local inference variable: `r` can either be a `ReVar` (i.e., already a reference to an inference variable) or it can be `'static` or some early-bound region. This is useful when taking the results from type-checking and trait-matching, which may sometimes reference those regions from the `ParamEnv`. It is also used during initialization. Relies on the `indices` map having been fully initialized.",
        "gt": "fn to_region_vid(&self, r: ty::Region<'tcx>) -> RegionVid { if let ty::ReVar(..) = *r { r.as_var() } else if let ty::ReError(guar) = *r { self.tainted_by_errors.set(Some(guar)); // We use the `'static` `RegionVid` because `ReError` doesn't actually exist in the self.fr_static } else { *self .indices .get(&r) .unwrap_or_else(|| bug!(\"cannot convert `{:?}` to a region vid\", r)) } }",
        "url": 65
    },
    {
        "code_input": "use tokio_postgres::{NoTls, Error, Row};\n\n#[tokio::main]\nasync fn main() -> Result<(), Error> {\n    let (client, connection) = tokio_postgres::connect(\n        \"postgres://username:password@localhost/database\",\n        NoTls,\n    )\n    .await?;\n\n    tokio::spawn(async move {\n        // Create the index\n        let _ = client\n            .execute(\n                \"CREATE INDEX IF NOT EXISTS user_name_index ON users (username)\",\n                &[],\n                &[],\n                &[],\n                None,\n                None,\n            )\n            .await?;\n    });\n\n    // Perform some queries\n    let _ = client\n        .query(\n            \"SELECT * FROM users WHERE username = $1\",\n            &",
        "nl_input": "Add system index. Indexes won't be backfilled and available for queries until after the transaction has committed.",
        "gt": "pub async fn add_system_index( &mut self, namespace: TableNamespace, index: IndexMetadata<TableName>, ) -> anyhow::Result<()> { anyhow::ensure!( self.tx.identity().is_admin() || self.tx.identity().is_system(), unauthorized_error(\"add_system_index\") ); self._add_index(namespace, index).await?; Ok(()) }",
        "url": 66
    },
    {
        "code_input": "I'm sorry, but it seems like there's a misunderstanding. The query you've provided seems to be a request for a code snippet, but it's not clear what the exact request is. \n\nIf you're asking for a Rust code snippet that emits a certain string, I'm afraid I can't provide that. The string \"EMIT_MIR nrvo_simple.nrvo.RenameReturnPlace.diff\" doesn't seem to be a valid Rust code or command. \n\nIf you're asking for a Rust function or method, I'd need more information about what you're trying to achieve. Could you please provide more details?\n",
        "nl_input": "EMIT_MIR nrvo_simple.nrvo.RenameReturnPlace.diff",
        "gt": "fn nrvo(init: fn(&mut [u8; 1024])) -> [u8; 1024] { let mut buf = [0; 1024]; init(&mut buf); buf }",
        "url": 67
    },
    {
        "code_input": "use tokio_postgres::{NoTls, Error, Row};\nuse tokio::stream::StreamExt;\n\n#[tokio::main]\nasync fn main() -> Result<(), Error> {\n    let (client, connection) = tokio_postgres::connect(\n        \"postgres://username:password@localhost:5432/database\",\n        NoTls,\n    )\n    .await?;\n\n    let query = \"DELETE FROM table_name WHERE condition\";\n\n    let mut stream = client.query(query",
        "nl_input": "Deletes a row See also: * [Model::delete_rows]",
        "gt": "pub fn delete_row(&mut self, sheet: u32, row: i32) -> Result<(), String> { let mut row_data = None; let worksheet = self.model.workbook.worksheet(sheet)?; for rd in &worksheet.rows { if rd.r == row { row_data = Some(rd.clone()); break; } } let data = match worksheet.sheet_data.get(&row) { Some(s) => s.clone(), None => return Err(format!(\"Row number '{row}' is not valid.\")), }; let old_data = Box::new(RowData { row: row_data, data, }); let diff_list = vec![Diff::DeleteRow { sheet, row, old_data, }]; self.push_diff_list(diff_list); self.model.delete_rows(sheet, row, 1) }",
        "url": 68
    },
    {
        "code_input": "Sure, I can help you with that. However, I need more specific details about the query you're referring to. Could you please provide more information about the UDF (User-Defined Function) and the error `ConvexError`?\n",
        "nl_input": "custom error is called `ConvexError` in udfs",
        "gt": "pub fn deserialize_udf_custom_error( message: String, serialized_data: Option<String>, ) -> anyhow::Result<(String, Option<ConvexValue>)> { Ok(if let Some(serialized_data) = serialized_data { let deserialized_custom_data = deserialize_udf_custom_error_data(&serialized_data)?; match deserialized_custom_data { Ok(custom_data) => (message, Some(custom_data)), Err(custom_data_format_error) => (custom_data_format_error.message, None), } } else { (message, None) }) }",
        "url": 69
    },
    {
        "code_input": "use std::time::{Duration, Instant};\n\nfn waiting_duration(deadlines: &Vec<Option<DateTime>>) -> Duration {\n    let now = Instant::now();\n    let mut total_duration = Duration::new(0, 0);\n    for deadline in deadlines {\n        match deadline {\n            None => (),\n            Some(deadline) => {\n                if now > deadline {\n                    total_duration += now.checked_duration_since(deadline).unwrap_or(Duration::new(0, 0));\n                } else {\n                    total_duration += deadline.checked_duration_since(now).unwrap_or(Duration::new(0, 0));\n                }\n            }\n        }\n    }\n    total_duration\n}",
        "nl_input": "Returns the waiting duration until the next deadline is reached. If there have been already deadlines missed it returns a duration of zero.",
        "gt": "pub fn duration_until_next_deadline(&self) -> Result<Duration, TimeError> { let now = fail!(from self, when Time::now_with_clock(self.clock_type), \"Unable to return next duration since the current time could not be acquired.\"); let now = now.as_duration().as_nanos(); let mut has_missed_deadline = false; self.handle_missed_deadlines(now, |_| { has_missed_deadline = true; CallbackProgression::Stop }); if has_missed_deadline { return Ok(Duration::ZERO); } *self.previous_iteration.borrow_mut() = now; let mut min_time = u128::MAX; for attachment in &*self.attachments.borrow() { min_time = min_time.min(attachment.period - (now - attachment.start_time) % attachment.period); } Ok(Duration::from_nanos(min_time as _)) }",
        "url": 70
    },
    {
        "code_input": "fn right_shift(n: u8, shift: u8) -> u8 {\n    if shift > 8 {\n        return 0;\n    }\n    n >> shift\n}\n\nfn main() {\n    let num = 10;\n    let shift = 2;\n    let result = right_shift(num, shift);\n    println!(\"{}\", result);\n}",
        "nl_input": "The skipped method shouldn't right-shift",
        "gt": "pub unsafe fn _mm256_shufflehi_epi32(a: __m256i, imm8: i32) -> __m256i { let imm8 = (imm8 & 0xFF) as u8; let a = a.as_i16x16(); macro_rules! shuffle_done { ($x01:expr, $x23:expr, $x45:expr, $x67:expr) => { #[cfg_attr(rustfmt, rustfmt_skip)] simd_shuffle32(a, a, [ 0, 1, 2, 3, 4+$x01, 4+$x23, 4+$x45, 4+$x67, 8, 9, 10, 11, 12+$x01, 12+$x23, 12+$x45, 12+$x67 ]); }; } }",
        "url": 71
    },
    {
        "code_input": "use std::time::{SystemTime, Duration};\n\ntrait GarbageCollector {\n    fn collect_garbage(&self, min_age: Duration);\n}\n\nstruct ManifestStore {\n    // ...\n}\n\nimpl ManifestStore {\n    pub fn collect_old_manifests(&mut self, min_age: Duration) {\n        let current_time = SystemTime::now();\n        for manifest in self.manifests.iter_mut() {\n            if let Some(creation_time) = manifest.get_creation_time() {\n                if current_time - creation_time > min_age {\n                    manifest.drop();\n                }\n            }\n        }\n    }\n}\n\n// Usage\nfn main() {\n    let mut store = ManifestStore {\n        manifests: vec![],\n        // ...\n    };\n\n    store.collect",
        "nl_input": "Collect garbage from the manifest store. This will delete any manifests that are older than the minimum age specified in the options.",
        "gt": "async fn collect_garbage_manifests(&self) -> Result<(), SlateDBError> { let utc_now = Utc::now(); let min_age = self .options .manifest_options .map_or(DEFAULT_MIN_AGE, |opts| opts.min_age); let mut manifest_metadata_list = self.manifest_store.list_manifests(..).await?; manifest_metadata_list.pop(); for manifest_metadata in manifest_metadata_list { let min_age = chrono::Duration::from_std(min_age).expect(\"invalid duration\"); if utc_now.signed_duration_since(manifest_metadata.last_modified) > min_age { if let Err(e) = self .manifest_store .delete_manifest(manifest_metadata.id) .await { error!(\"Error deleting manifest: {}\", e); } else { self.db_stats.gc_manifest_count.inc(); } } } Ok(()) }",
        "url": 72
    },
    {
        "code_input": "use std::path::Path;\nuse std::process;\nuse std::env;\n\nuse crate::macros::*;\n\npub fn import_macros(names: Option<&str>) {\n    let root_dir = env::current_dir().unwrap();\n    let mut imported_macros = Vec::new();\n\n    for entry in root_dir.iter() {\n        if entry.path().is_dir() {\n            for file in entry.path().iter_files() {\n                if file.path().extension().unwrap().to_str().unwrap() == \"rs\" {\n                    let file_path = file.path().to_str().unwrap();\n                    if let Some(file_name) = file_path.to_string() {\n                        if names.is_some() && file_name != names.unwrap() {\n                            continue;\n                        }",
        "nl_input": "Import exported macros from another crate. `names`, if `Some(_)`, specifies the name of macros to be imported. Otherwise this method imports all exported macros. Exported macros are just all macros in the root module scope. Note that it contains not only all `#[macro_export]` macros, but also all aliases created by `use` in the root module, ignoring the visibility of `use`.",
        "gt": "fn import_macros_from_extern_crate( &mut self, krate: CrateId, names: Option<Vec<Name>>, extern_crate: Option<ExternCrateId>, ) { let def_map = self.db.crate_def_map(krate); let root_scope = &def_map[DefMap::ROOT].scope; match names { Some(names) => { for name in names { if let Some(def) = root_scope.get(&name).take_macros() { self.def_map.macro_use_prelude.insert(name, (def, extern_crate)); } } } None => { for (name, def) in root_scope.macros() { self.def_map.macro_use_prelude.insert(name.clone(), (def, extern_crate)); } } } }",
        "url": 73
    },
    {
        "code_input": "fn convert_to_u8(tensor: &mut [f32]) -> Vec<u8> {\n    let mut result = vec![];\n    for channel in tensor.iter_mut() {\n        let channel_vec = channel.to_vec();\n        for value in channel_vec.iter_mut() {\n            let scaled_value = (*value as f64 * 255.0) as u8;\n            result.push(scaled_value);\n        }\n    }\n    result\n}",
        "nl_input": "Convert an CHW float tensor with values in the range [0, 1] to `Vec<u8>` with values scaled to [0, 255].",
        "gt": "fn image_from_tensor(tensor: NdTensorView<f32, 3>) -> Vec<u8> { tensor .iter() .map(|x| (x.clamp(0., 1.) * 255.0) as u8) .collect() }",
        "url": 74
    },
    {
        "code_input": "fn get_string(self) -> String {\n    let mut new_string = String::new();\n    new_string.push_str(&self);\n    new_string\n}",
        "nl_input": "Return a copy of `self` that owns an allocated `String` but does not borrow an `&Url`.",
        "gt": "pub fn to_owned(&self) -> Host<String> { match *self { Host::Domain(domain) => Host::Domain(domain.to_owned()), Host::Ipv4(address) => Host::Ipv4(address), Host::Ipv6(address) => Host::Ipv6(address), } }",
        "url": 75
    },
    {
        "code_input": "use std::os::raw::c_char;\nuse std::os::raw::c_void;\nuse std::os::raw::c_uint;\nuse std::os::raw::c_ulong;\nuse std::os::raw::c_wchar;\nuse std::os::raw::c_wchar_t;\nuse std::os::raw::c_wint_t;\nuse std::os::raw::c_ssize_t;\nuse std::os::raw::c_size_t;\nuse std::os::raw::c_int;\nuse std::os::raw::c_uintptr_t;\nuse std::os::raw::c_usize;\nuse std::os::raw::c_ssize;\nuse std::os::raw::c_c_char;\nuse std::os::raw::c_c_wchar;\nuse std::os::raw::c_c_wchar_t;\nuse std::os::raw::c_c_int;\nuse std::os",
        "nl_input": "Helper function to write an OsStr as a null-terminated sequence of bytes, which is what the Unix APIs usually handle. Returns `(success, full_len)`, where length includes the null terminator. On failure, nothing is written.",
        "gt": "fn write_os_str_to_c_str( &mut self, os_str: &OsStr, ptr: Pointer, size: u64, ) -> InterpResult<'tcx, (bool, u64)> { let bytes = os_str.as_encoded_bytes(); self.eval_context_mut().write_c_str(bytes, ptr, size) }",
        "url": 76
    },
    {
        "code_input": "I'm sorry, but I can't provide the help you're looking for without the specific details of the query. Could you please provide more information about the query?\n",
        "nl_input": "FIXME: rustc's ty is dependent on the adt type, maybe we need to do that as well",
        "gt": "pub fn discr_ty() -> Ty { TyKind::Scalar(chalk_ir::Scalar::Int(chalk_ir::IntTy::I128)).intern(Interner) }",
        "url": 77
    },
    {
        "code_input": "pub fn filter_columns<T: AsRef<str>>(columns: Vec<T>, selection: Vec<usize>) -> (Vec<String>, usize) {\n    if columns.len() != selection.len() {\n        panic!(\"The selection vector is a different length than the columns.\");\n    }\n\n    let mut filtered_columns: Vec<String> = Vec::new();\n    let mut count = 0;\n\n    for (i, column) in columns.iter().enumerate() {\n        if i < selection.len() && selection[i] {\n            filtered_columns.push(column.as_ref().to_string());\n            count += 1;\n        }\n    }\n\n    (filtered_columns, count)\n}",
        "nl_input": "This function takes a selection vector and a set of columns and returns a new set of columns that only contains the selected rows. The function panics if the selection vector is a different length than the columns. The function returns a tuple of the filtered columns and the number of rows in the filtered columns. # Panics This function requires that `columns` and `selection` have the same length.",
        "gt": "pub fn filter_columns<'a, S: Scalar>( alloc: &'a Bump, columns: &[Column<'a, S>], selection: &[bool], ) -> (Vec<Column<'a, S>>, usize) { for col in columns { assert_eq!(col.len(), selection.len()); } let indexes: Vec<_> = selection .iter() .enumerate() .filter(|(_, &b)| b) .map(|(i, _)| i) .collect(); let result_length = indexes.len(); let filtered_result: Vec<_> = columns .iter() .map(|column| filter_column_by_index(alloc, column, &indexes)) .collect(); (filtered_result, result_length) }",
        "url": 78
    },
    {
        "code_input": "pub fn match_query(query: &str) -> bool {\n    // Check if the query is empty\n    if query.is_empty() {\n        return false;\n    }\n\n    // Check if the query starts with a '+'\n    if query.starts_with('+') {\n        return false;\n    }\n\n    // Check if the query ends with a '+'\n    if query.ends_with('+') {\n        return false;\n    }\n\n    // Check if the query contains a '+' in the middle\n    if query.contains('+') {\n        return false;\n    }\n\n    // If none of the above conditions are met, the query matches\n    return true;\n}",
        "nl_input": "bindings_after_at + slice_patterns + or_patterns + box_patterns",
        "gt": "fn bindings_after_at_slice_patterns_or_patterns_box_patterns_borrows( mut x: [Option<Box<Test>>; 4] ) { let r = match x { [_, ref a @ Some(box Test::Foo | box Test::Bar), ..] => Some(a), _ => None, }; &mut x; drop(r); }",
        "url": 79
    },
    {
        "code_input": "pub struct Node {\n    data: i32,\n}\n\nimpl Node {\n    pub fn requires_mut(&self) -> bool {\n        // This is a placeholder for the actual implementation.\n        // In a real scenario, you would need to check the specifics of your data structure.\n        true\n    }\n}\n\nfn main() {\n    let node = Node { data: 42 };\n    println!(\"Does the node require mut? {}\", node.requires_mut());\n}",
        "nl_input": "checks if this reference requires `&mut` access inside node",
        "gt": "fn reference_is_exclusive( reference: &FileReference, node: &dyn HasTokenAtOffset, ctx: &AssistContext<'_>, ) -> bool { // FIXME: this quite an incorrect way to go about doing this :-) // `FileReference` is an IDE-type --- it encapsulates data communicated to the human, // but doesn't necessary fully reflect all the intricacies of the underlying language semantics if reference.category.contains(ReferenceCategory::WRITE) { return true; } let path = match path_element_of_reference(node, reference) { Some(path) => path, None => return false, }; expr_require_exclusive_access(ctx, &path).unwrap_or(false) }",
        "url": 80
    },
    {
        "code_input": "pub fn is_inhabited<T: std::marker::Phantom, Module, Type>(env: &ParamEnv<Module, Type>, t: T) -> bool {\n    match env.type_ {\n        Some(ref_type) => match ref_type {\n            Some(ref inner_type) => t.is_same(inner_type),\n            None => false,\n        },\n        None => false,\n    }\n}",
        "nl_input": "Returns true if the corresponding type is inhabited in the given `ParamEnv` and module.",
        "gt": "pub fn apply( self, tcx: TyCtxt<'tcx>, typing_env: TypingEnv<'tcx>, module_def_id: DefId, ) -> bool { self.apply_revealing_opaque(tcx, typing_env, module_def_id, &|_| None) }",
        "url": 81
    },
    {
        "code_input": "fn rustfmt_normalize_comments(code: &str) -> String {\n    let mut lines = code.lines();\n    let mut result = String::new();\n\n    for line in lines {\n        if line.trim().starts_with('#') {\n            // Remove the comment\n            let comment_end = line.find('#').unwrap_or(line.len());\n            result.push_str(&line[0..comment_end]);\n            result.push_str(\"\\n\");\n        } else {\n            // Add the line to the result\n            result.push_str(&line);\n            result.push_str(\"\\n\");\n        }\n    }\n\n    result.trim_end().to_string()\n}\n\nfn main() {\n    let code = r#\"\n# This is a comment\n\n# Another comment\n\nHello, world!\n\n# This is another comment\n\n# And another one\n\"#;\n\n    println!(\"{}\", rustfmt_normalize_comments(code));\n}",
        "nl_input": "rustfmt-normalize_comments: true",
        "gt": "fn main() { match x { S(true, .., true) => (), S(true, ..) => (), S(.., true) => (), S(..) => (), S(_) => (), S( ..) => (), S( .., true) => (), } match y { (true, .., true) => (), (true, ..) => (), (.., true) => (), (..) => (), (_,) => (), ( ..) => (), ( .., true) => (), } }",
        "url": 82
    },
    {
        "code_input": "use p3_symmetric::PaddingFreeSponge;\n\nfn poseidon2_hash(input: &[u8]) -> Vec<u8> {\n    let mut sponge = PaddingFreeSponge::new(256, 128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,",
        "nl_input": "Applies the Poseidon2 hash function to the given array. Reference: [p3_symmetric::PaddingFreeSponge]",
        "gt": "fn poseidon2_hash(builder: &mut Builder<C>, input: &[Felt<C::F>]) -> [Felt<C::F>; DIGEST_SIZE] { let mut state = core::array::from_fn(|_| builder.eval(C::F::zero())); for input_chunk in input.chunks(HASH_RATE) { state[..input_chunk.len()].copy_from_slice(input_chunk); state = Self::poseidon2_permute(builder, state); } let digest: [Felt<C::F>; DIGEST_SIZE] = state[..DIGEST_SIZE].try_into().unwrap(); digest }",
        "url": 83
    },
    {
        "code_input": "use my_crate::*;\n\nfn main() {\n    let result = find_function();\n    println!(\"Result: {}\", result);\n}",
        "nl_input": "Use internal API to find a function in a crate.",
        "gt": "fn get_item<'a>( items: &'a stable_mir::CrateItems, item: (ItemKind, &str), ) -> Option<&'a stable_mir::CrateItem> { items.iter().find(|crate_item| { crate_item.kind() == item.0 && crate_item.name() == item.1 }) }",
        "url": 84
    },
    {
        "code_input": "use chrono::prelude::*;\nuse serde::{Deserialize, Serialize};\nuse std::iter::FromIterator;\n\n#[derive(Serialize, Deserialize, Debug)]\nstruct Date {\n    year: u32,\n    month: u32,\n    day: u32,\n}\n\nfn get_dates_in_year(year: u32) -> impl FromIterator<Local<Date>> {\n    let start_date = LocalDate::new(year, 1, 1);\n    let end_date = LocalDate::new(year + 1, 1, 1);\n\n    start_date..end_date\n}\n\nfn main() {\n    let year = 2022;\n    let dates = get_dates_in_year(year);\n\n    for date in dates {\n        println!(\"{}\", date);\n    }\n}",
        "nl_input": "Returns an iterator of dates in a given year.",
        "gt": "fn dates_in_year(year: i32) -> impl Iterator<Item=NaiveDate>+Clone { InGroup { it: NaiveDate::from_ymd(year, 1, 1).., f: |d: &NaiveDate| d.year(), g: year } }",
        "url": 85
    },
    {
        "code_input": "struct Certainty {\n    def_id: Option<DefId>,\n    // other fields...\n}\n\nstruct DefId {}\n\nimpl Certainty {\n    fn join_clearing_def_ids(&mut self, other: &mut Certainty) {\n        if let Some(other_def_id) = other.def_id {\n            if let Some(self_def_id) = self.def_id {\n                // If both certainty values have a def_id, then we join them\n                // This is a simple example, in a real implementation you would probably want to handle conflicts in a more sophisticated way\n                if self_def_id == other_def_id {\n                    self.def_id = Some(other_def_id);\n                }\n            } else {\n                // If `other` has a def_id but `self` does not, we",
        "nl_input": "Join two `Certainty`s preserving their `DefId`s (if any). Generally speaking, this method should be used only when `self` and `other` refer directly to types. Otherwise, `join_clearing_def_ids` should be used.",
        "gt": "pub fn join(self, other: Self) -> Self { match (self, other) { (Certainty::Contradiction, _) | (_, Certainty::Contradiction) => Certainty::Contradiction, (Certainty::Certain(lhs), Certainty::Certain(rhs)) => { if let Some(inner) = lhs.try_join(rhs) { Certainty::Certain(inner) } else { debug_assert!(false, \"Contradiction with {lhs:?} and {rhs:?}\"); Certainty::Contradiction } }, (Certainty::Certain(inner), _) | (_, Certainty::Certain(inner)) => Certainty::Certain(inner), (Certainty::Uncertain, Certainty::Uncertain) => Certainty::Uncertain, } }",
        "url": 86
    },
    {
        "code_input": "fn main() {\n    let mut s = vec![0; 10];\n    s.as_mut().fill(10);\n}",
        "nl_input": "@ run-fail @ compile-flags: -Copt-level=3 -Cdebug-assertions=no -Zub-checks=yes @ error-pattern: unsafe precondition(s) violated: slice::from_raw_parts_mut requires @ revisions: null misaligned toolarge",
        "gt": "fn main() { unsafe { #[cfg(null)] let _s: &mut [u8] = std::slice::from_raw_parts_mut(std::ptr::null_mut(), 0); #[cfg(misaligned)] let _s: &mut [u16] = std::slice::from_raw_parts_mut(1usize as *mut u16, 0); #[cfg(toolarge)] let _s: &mut [u16] = std::slice::from_raw_parts_mut(2usize as *mut u16, isize::MAX as usize); } }",
        "url": 87
    },
    {
        "code_input": "use mir::address_of;\nuse mir::cast;\n\nfn main() {\n    let x = 5;\n    let y: i32 = address_of(x);\n    let z: i64 = cast::<i32, i64>(y);\n    println!(\"{}\", z);\n}",
        "nl_input": "The normal borrows here should be preserved EMIT_MIR address_of.borrow_and_cast.SimplifyCfg-initial.after.mir",
        "gt": "fn borrow_and_cast(mut x: i32) { let p = &x as *const i32; let q = &mut x as *const i32; let r = &mut x as *mut i32; }",
        "url": 88
    },
    {
        "code_input": "use crate::{Lsn, Range};\n\nfn get_range(target_range: Range) -> Range {\n    let first_lsn = target_range.first_lsn();\n    Range::new(first_lsn, first_lsn)\n}",
        "nl_input": "returns an empty range with the nextlsn set to the first lsn of the target range",
        "gt": "pub fn empty_preceeding(range: &LsnRange) -> Self { LsnRange::Empty { nextlsn: match range { LsnRange::Empty { nextlsn } => *nextlsn, LsnRange::NonEmpty { first, .. } => *first, }, } }",
        "url": 89
    },
    {
        "code_input": "fn main() {\n    println!(\"{}\", 42);\n}",
        "nl_input": "rustfmt-brace_style: SameLineWhere rustfmt-where_single_line: true",
        "gt": "fn lorem_multi_line_clauseless<Ipsum, Dolor, Sit, Amet>( a: Aaaaaaaaaaaaaaa, b: Bbbbbbbbbbbbbbbb, c: Ccccccccccccccccc, d: Ddddddddddddddddddddddddd, e: Eeeeeeeeeeeeeeeeeee, ) -> T { }",
        "url": 90
    },
    {
        "code_input": "I'm sorry, but your question seems to be missing some context. It's not clear what \"Foreign Write on a Reserved\" is referring to in the context of a specific programming language or system. \n\nIf you're referring to a system in a specific programming language, I'd need more information to provide a more accurate answer. For example, if you're talking about a system in a language like C, C++, or Rust, I'd need more context to provide a more accurate answer.\n\nIf you're referring to a system in a different programming language, I'd need more information to provide a more accurate answer.\n\nIf you're referring to a system in a specific operating system, I'd need more information to provide a more accurate answer.\n\nIf you're referring to a system in a specific hardware or software, I'd need more information to provide a more accurate answer.\n\nIf you're referring to a system in a specific software or system, I'd need more information to provide a more accurate answer.\n\nIf you're referring to a system in a specific programming language, I'd need more information to provide a more accurate",
        "nl_input": "Foreign Write on a Reserved turns it Disabled.",
        "gt": "unsafe fn int_unprotected_write() { print(\"[] Foreign Write: Res -> Dis\"); let base = &mut 0u8; name!(base); let alloc_id = alloc_id!(base); let x = &mut *(base as *mut u8); name!(x); let y = (&mut *base) as *mut u8; name!(y); *y = 1; print_state!(alloc_id); }",
        "url": 91
    },
    {
        "code_input": "fn verify_no_mut_ptr<T>(x: &T) {\n    // Check if the value is a reference\n    if x.is_null() {\n        println!(\"The value is a null reference.\");\n        return;\n    }\n\n    // Check if the value is a mutable reference\n    if x.as_ref().is_null() {\n        println!(\"The value is a null mutable reference.\");\n        return;\n    }\n\n    // Check if the value is a mutable pointer\n    if x.as_mut() == &x {\n        println!(\"The value is a mutable pointer to itself.\");\n        return;\n    }\n\n    // If we reach this point, the value is not a null reference or a null mutable reference\n    // and is not a mutable pointer to itself, so we can safely reason.\n    println!(\"We can safely reason when there are mutable pointers involved.\");",
        "nl_input": "Verify that we do not try to reason when there are mutable pointers involved.",
        "gt": "fn mutable_ref() -> bool { let mut x = 5; let a = std::ptr::addr_of_mut!(x); x = 7; unsafe { *a = 8 }; if x == 7 { true } else { false } }",
        "url": 92
    },
    {
        "code_input": "#[derive(Debug)]\nstruct OuterFunction {\n    name: String,\n    body: Vec<InnerFunction>,\n}\n\n#[derive(Debug)]\nstruct InnerFunction {\n    name: String,\n}\n\nfn is_nested(outer: &OuterFunction, inner: &InnerFunction) -> bool {\n    outer.body.contains(inner)\n}\n\nfn main() {\n    let outer = OuterFunction {\n        name: String::from(\"outer\"),\n        body: vec![InnerFunction { name: String::from(\"inner\") }],\n    };\n\n    let inner = &InnerFunction {\n        name: String::from(\"inner\"),\n    };\n\n    println!(\"{}\", is_nested(&outer, inner));\n}",
        "nl_input": "Returns whether the given function is nested within the body of another function.",
        "gt": "fn is_nested_function(function: &ast::Fn) -> bool { function.syntax().ancestors().skip(1).find_map(ast::Item::cast).map_or(false, |it| { matches!(it, ast::Item::Fn(_) | ast::Item::Static(_) | ast::Item::Const(_)) }) }",
        "url": 93
    },
    {
        "code_input": "pub fn construct_madt() -> Vec<u32> {\n    let mut madt = vec![];\n\n    // Add the header\n    madt.push(0x00);\n    madt.push(0x01);\n\n    // Add the length of the MADT\n    madt.push((0x00 as u32).rotate_left(16));\n    madt.push((0x01 as u32).rotate_left(16));\n\n    // Add the flags\n    madt.push(0x00);\n    madt.push(0x00);\n\n    // Add the count of the MADT\n    madt.push((0x01 as u32).rotate_left(16));\n\n    // Add the entries\n    madt.",
        "nl_input": "Helper method to construct an MADT without constructing the rest of the ACPI tables.",
        "gt": "pub fn build_madt(&self) -> Vec<u8> { self.with_madt(|t| t.to_vec(&OEM_INFO)) }",
        "url": 94
    },
    {
        "code_input": "use std::collections::HashMap;\n\nstruct FileSystem {\n    file_id_to_path: HashMap<i32, String>,\n    path_to_file_id: HashMap<String, i32>,\n}\n\nimpl FileSystem {\n    fn new() -> Self {\n        FileSystem {\n            file_id_to_path: HashMap::new(),\n            path_to_file_id: HashMap::new(),\n        }\n    }\n\n    fn insert(&mut self, file_id: i32, path: String) {\n        if let Some(old_file_id) = self.file_id_to_path.get_mut(&file_id) {\n            *old_file_id = path;\n        } else {\n            self.file_id_to_path.insert(file_id, path);\n        }\n\n        if let Some(old_path) = self.path_to",
        "nl_input": "Insert the `file_id, path` pair into the set. # Note Multiple [`FileId`] can be mapped to the same [`VfsPath`], and vice-versa.",
        "gt": "pub fn insert(&mut self, file_id: FileId, path: VfsPath) { self.files.insert(path.clone(), file_id); self.paths.insert(file_id, path); }",
        "url": 95
    },
    {
        "code_input": "use ethers::prelude::*;\nuse ethers::types::Address;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Create a provider instance\n    let provider = Provider::<Http>::try_from(\"http://localhost:8545\")?;\n\n    // Create a signer instance\n    let signer = Signer::new_local(provider, \"your-private-key\");\n\n    // Create a contract instance\n    let contract = Contract::try_from(\"0x42842e0e\")?;\n\n    // Create a message\n    let message = Message::new(\n        contract.address(),\n        \"safeTransferFrom\",\n        vec![\n            // Parameters for the function\n            \"0x70a0823",
        "nl_input": "Calls the contract's `safeTransferFrom` (0x42842e0e) function",
        "gt": "pub fn safe_transfer_from( &self, from: ::ethers::core::types::Address, to: ::ethers::core::types::Address, token_id: ::ethers::core::types::U256, ) -> ::ethers::contract::builders::ContractCall<M, ()> { self.0 .method_hash([66, 132, 46, 14], (from, to, token_id)) .expect(\"method not found (this should never happen)\") }",
        "url": 96
    },
    {
        "code_input": "use num_traits::FromPrimitive;\n\n#[derive(Copy, Clone, Debug)]\nstruct Const<T>(T);\n\nimpl<T: FromPrimitive> Const<T> {\n    fn new(value: T) -> Const<T> {\n        Const(value)\n    }\n\n    fn value(&self) -> T {\n        self.0\n    }\n}\n\nfn main() {\n    let const_val = Const::new(42);\n    let compile_time_val: i32 = const_val.value();\n    println!(\"{}\", compile_time_val);\n}",
        "nl_input": "Compile `expr`, yielding a compile-time constant. Assumes that `expr` is a valid compile-time constant!",
        "gt": "pub(crate) fn as_constant(&mut self, expr: &Expr<'tcx>) -> ConstOperand<'tcx> { let this = self; let tcx = this.tcx; let Expr { ty, temp_lifetime: _, span, ref kind } = *expr; match kind { ExprKind::Scope { region_scope: _, lint_level: _, value } => { this.as_constant(&this.thir[*value]) } _ => as_constant_inner( expr, |user_ty| { Some(this.canonical_user_type_annotations.push(CanonicalUserTypeAnnotation { span, user_ty: user_ty.clone(), inferred_ty: ty, })) }, tcx, ), } }",
        "url": 97
    },
    {
        "code_input": "use reqwest::Error;\nuse std::net::SocketAddr;\nuse std::sync::Arc;\nuse tokio::net::TlsConnector;\nuse tokio_util::compat::TokioAsyncWriteCompatExt;\nuse tokio_util::compat::TokioAsyncWriteCompatExtExt;\n\n#[tokio::main]\nasync fn main() -> Result<(), Error> {\n    let addr = SocketAddr::from(([127, 0, 0, 1], 8080));\n    let tls_connector = Arc::new(TlsConnector::new(addr));\n\n    let resp = reqwest::get(&addr)\n        .bearer_auth(\"username\", \"password\")\n        .tls(tls_connector.clone())\n        .send()\n        .await?;\n\n    let cert = resp.tls_connection().",
        "nl_input": "Returns default server configuration along with its certificate.",
        "gt": "fn configure_server() -> Result<(ServerConfig, Vec<u8>), Box<dyn Error>> { let (certs, key) = get_insecure_tls_cert(); let mut server_config = ServerConfig::with_single_cert(certs.clone(), key.into())?; let transport_config = Arc::get_mut(&mut server_config.transport).unwrap(); transport_config.max_concurrent_uni_streams(10_u8.into()); transport_config.max_concurrent_bidi_streams(10_u8.into()); Ok((server_config, certs[0].to_vec())) }",
        "url": 98
    },
    {
        "code_input": "use std::fs::File;\nuse std::io::Read;\nuse std::path::Path;\nuse std::str::FromStr;\nuse base64::Config;\nuse base64::DecodeError;\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    let file_path = Path::new(\"secret_key.txt\");\n    let mut file = File::open(&file_path)?;\n    let mut contents = String::new();\n    file.read_to_string(&mut contents)?;\n\n    let secret_key = base64::decode(Config::new(), &contents)?;\n\n    println!(\"{}\", String::from_utf8_lossy(&secret_key));\n\n    Ok(())\n}",
        "nl_input": "Extract the secret key from configuration. It should be provided as a base64 string encoding 256 bits of entropy.",
        "gt": "pub fn secret_key(&self) -> Result<Vec<u8>, Error> { use base64::{engine::general_purpose, Engine as _}; let bytes = general_purpose::STANDARD.decode(&self.secret_key)?; if bytes.len() == 256 / 8 { Ok(bytes) } else { Err(Error::SecretKey) } }",
        "url": 99
    },
    {
        "code_input": "use std::sync::Arc;\nuse std::task::{Context, Spawned, Task};\n\nstruct Guest {\n    id: u32,\n}\n\nstruct GuestManager {\n    guests: Vec<Arc<Guest>>,\n}\n\nimpl GuestManager {\n    fn new() -> Self {\n        Self {\n            guests: Vec::new(),\n        }\n    }\n\n    fn add_guest(&mut self, id: u32) {\n        self.guests.push(Arc::new(Guest { id }));\n    }\n\n    fn spawn_task(&self, task: impl FnOnce() -> std::thread::JoinHandle<()>) -> Spawned<()> {\n        let mut",
        "nl_input": "A hint to the backend specifying the guest VP associated with spawned tasks and IO. Backends can use this to ensure that spawned tasks and async IO will run near or on the target VP.",
        "gt": "pub fn target_vp(&mut self, target_vp: u32) -> &mut Self { self.target_vp = Some(target_vp); self }",
        "url": 100
    },
    {
        "code_input": "use std::collections::HashMap;\n\npub fn generate_impl_text_inner(\n    text: &str,\n    replacements: HashMap<&str, &str>,\n) -> String {\n    let mut result = String::new();\n    let mut last_char_was_space = false;\n\n    for c in text.chars() {\n        if c.is_ascii_space() {\n            last_char_was_space = true;\n        } else {\n            if let Some(replacement) = replacements.get(&c.to_string()) {\n                result.push_str(replacement);\n                last_char_was_space = false;\n            } else {\n                result.push(c);\n                last_char_was_space = false;\n            }\n        }\n    }\n\n    result\n}",
        "nl_input": "FIXME: remove when no one depends on `generate_impl_text_inner`",
        "gt": "pub fn type_bound_text(bound: &str) -> ast::TypeBound { ast_from_text(&format!(\"fn f<T: {bound}>() {{ }}\")) }",
        "url": 101
    },
    {
        "code_input": "struct Leaf {\n    index: u32,\n    value: f32,\n}\n\nstruct ResultSet {\n    leaves: Vec<Leaf>,\n}",
        "nl_input": "Returns a new result set. `leaves` may contain multiple results for the same function and index. In this case, they are merged internally (respecting their mask bits), with later leaves overriding earlier ones.",
        "gt": "pub fn new(mut leaves: Vec<CpuidLeaf>) -> Self { leaves.sort_by(|x, y| x.cmp_key(y)); leaves.dedup_by(|right, left| { if left.cmp_key(right).is_ne() { return false; } right.apply(&mut left.result); for (x, y) in left.mask.iter_mut().zip(right.mask) { *x |= y; } true }); Self { leaves } }",
        "url": 102
    },
    {
        "code_input": "fn set_stream_window(max_stream_window: u32) {\n    // Set the initial max stream data bidirectional remote\n    let initial_max_stream_data_bidi_remote: u32 = 2097152;\n\n    // If the new value is less than the current max stream window, set the new value\n    if max_stream_window < initial_max_stream_data_bidi_remote {\n        initial_max_stream_data_bidi_remote = max_stream_window;\n    }\n}",
        "nl_input": "Set the `initial_max_stream_data_bidi_remote` transport parameter. The value is capped by the setting `max_stream_window`. The default value is `2097152`.",
        "gt": "pub fn set_initial_max_stream_data_bidi_remote(&mut self, v: u64) { self.local_transport_params .initial_max_stream_data_bidi_remote = cmp::min(v, self.max_stream_window); }",
        "url": 103
    },
    {
        "code_input": "use ethers::prelude::*;\nuse ethers::types::Address;\nuse ethers::types::HexString;\nuse ethers::types::Result;\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub struct AssetId {\n    id: u64,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub struct Recipient {\n    address: Address,\n}\n\nimpl AssetId {\n    pub fn new(id: u64) -> Self {\n        Self { id }\n    }\n\n    pub fn get_asset_recipient(&self, provider: &Provider) -> Result<Recipient> {\n        let contract = provider.contract_factory()?",
        "nl_input": "Calls the contract's `getAssetRecipient` (0x79eac6c2) function",
        "gt": "pub fn get_asset_recipient( &self, ) -> ::ethers::contract::builders::ContractCall< M, ::ethers::core::types::Address, > { self.0 .method_hash([121, 234, 198, 194], ()) .expect(\"method not found (this should never happen)\") }",
        "url": 104
    },
    {
        "code_input": "fn get_index(path: &str, scratch_space: &mut Vec<String>) -> Option<usize> {\n    for (i, s) in scratch_space.iter().enumerate() {\n        if s == path {\n            return Some(i);\n        }\n    }\n    None\n}",
        "nl_input": "Returns the set index for the given `path`. `scratch_space` is used as a buffer and will be entirely replaced.",
        "gt": "fn classify(&self, path: &VfsPath, scratch_space: &mut Vec<u8>) -> usize { let path = path.parent().unwrap_or_else(|| path.clone()); scratch_space.clear(); path.encode(scratch_space); let automaton = PrefixOf::new(scratch_space.as_slice()); let mut longest_prefix = self.len() - 1; let mut stream = self.map.search(automaton).into_stream(); while let Some((_, v)) = stream.next() { longest_prefix = v as usize; } longest_prefix }",
        "url": 105
    },
    {
        "code_input": "fn main() {\n    let numbers = vec![1, 2, 3, 4, 5];\n    let result = numbers.iter().map(|x| *x + 5).collect::<Vec<_>>();\n    println!(\"{:?}\", result);\n}",
        "nl_input": "Apply a binary operator to a slice and a single value with left upcasting returning results.",
        "gt": "pub(crate) fn try_slice_lit_binary_op_left_upcast<S, T, U, F>( lhs: &[S], rhs: &T, op: F, ) -> ColumnOperationResult<Vec<U>> where S: Copy + Into<T>, T: Copy, F: Fn(&T, &T) -> ColumnOperationResult<U>, { try_slice_lit_binary_op(lhs, rhs, |l, r| op(&Into::<T>::into(*l), r)) }",
        "url": 106
    },
    {
        "code_input": "I'm sorry, but I can't assist with that.\n",
        "nl_input": "issue: 120878",
        "gt": "fn main() { struct StructA<A, B = A> { _marker: std::marker::PhantomData<fn() -> (A, B)>, } struct StructB { a: StructA<isize, [u8]>, } trait Trait { type P<X>; } impl Trait for () { type P<X> = [u8]; } }",
        "url": 107
    },
    {
        "code_input": "// Define a new type\npub struct Type14 {\n    id: u32,\n    name: String,\n    description: String,\n    // other fields...\n}\n\n// Define a new type without a comment\npub type Type1 = Type14;",
        "nl_input": "CHECK: define{{.*}}5foo14{{.*}}!type ![[TYPE14:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}",
        "gt": "pub fn foo15(_: fn(i32) -> i32, _: fn(i32) -> i32, _: fn(i32) -> i32) {}",
        "url": 108
    },
    {
        "code_input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::time::Duration;\n\nstruct Packet {}\n\nstruct Ring {\n    data: Arc<Mutex<Vec<Packet>>>,\n}\n\nimpl Ring {\n    fn new() -> Self {\n        Self {\n            data: Arc::new(Mutex::new(vec![Packet])),\n        }\n    }\n\n    fn write(&self, packet: Packet) {\n        let mut data = self.data.lock().unwrap();\n        *data = vec![*data, packet];\n    }\n\n    fn poll(&self) -> Option<Packet> {\n        let mut data = self.data.lock().unwrap();\n        data.pop()\n    }\n}\n\nfn",
        "nl_input": "Polls the ring for successful write of `packet`.",
        "gt": "pub fn poll_write( &mut self, cx: &mut Context<'_>, packet: &OutgoingPacket<'_, '_>, ) -> Poll<Result<(), Error>> { let mut send_size = 32; let r = loop { std::task::ready!(self.write.poll_ready(cx, self.core, send_size)) .map_err(ErrorInner::from)?; match self.try_write(packet) { Ok(()) => break Ok(()), Err(TryWriteError::Full(len)) => send_size = len, Err(TryWriteError::Queue(err)) => break Err(err), } }; Poll::Ready(r) }",
        "url": 109
    },
    {
        "code_input": "use std::collections::HashMap;\n\nstruct Notifier {\n    server: String,\n}\n\nstruct Server {\n    notifiers: HashMap<String, Notifier>,\n}\n\nimpl Server {\n    fn new() -> Server {\n        Server {\n            notifiers: HashMap::new(),\n        }\n    }\n\n    fn associate_notifier(&mut self, notifier: Notifier) {\n        self.notifiers.insert(notifier.server.clone(), notifier);\n    }\n\n    fn get_notifier(&self, server: &str) -> Option<&Notifier> {\n        self.notifiers.get(server)\n    }\n}",
        "nl_input": "Associates a `Notifier` with the server.",
        "gt": "pub fn with_notifier<'a, T: Notifier>( &'a mut self, notifier: &'a mut T, ) -> ServerWithNotifier<'a, T> { self.validate(); ServerWithNotifier { inner: self, notifier, } }",
        "url": 110
    },
    {
        "code_input": "fn sum_of_elements<T: std::ops::Add<Output = T>>(v: &Vec<T>) -> T {\n    v.iter().fold(T::zero(), |sum, &x| sum + x)\n}",
        "nl_input": "Note below: bounds in impl decl are in reverse order.",
        "gt": "fn combine<T:B+A>(&self, t: &T) -> usize { (t.a() * 100) + t.b() }",
        "url": 111
    },
    {
        "code_input": "fn main() {\n    let s = \"1,2,3,4,5\";\n    let pivot = s.split(',').collect::<Vec<&str>>()[1];\n    println!(\"{}\", pivot);\n}",
        "nl_input": "return the pivot at the separating `,`",
        "gt": "pub(crate) fn parse_pair(s: &str) -> Result<usize, &'static str> { let mut depth = 0; for (i, c) in s[..s.len() - 1].chars().enumerate() { if c == ',' && depth == 0 { return Ok(i); } if c == '<' { depth += 1; } if c == '>' { depth -= 1; } } if depth != 0 { return Err(\"unmatched < >\"); } return Err(\"cannot find ,\"); }",
        "url": 112
    },
    {
        "code_input": "fn fake_function() -> String {\n    \"Hello, World!\".to_string()\n}",
        "nl_input": "fake function that shouldn't trigger the lint",
        "gt": "pub fn from_str_radix(_: &str, _: u32) -> Result<(), std::num::ParseIntError> { unimplemented!() }",
        "url": 113
    },
    {
        "code_input": "use std::collections::HashSet;\n\nstruct MerkleTree {\n    root: String,\n    leaf_nodes: Vec<String>,\n}\n\nimpl MerkleTree {\n    fn new(leaf_nodes: Vec<String>) -> Self {\n        Self {\n            leaf_nodes,\n            root: leaf_nodes[0].clone(),\n        }\n    }\n\n    fn verify(&self, proof: &Vec<String>) -> bool {\n        let mut current_node = self.root.clone();\n\n        for item in proof {\n            if current_node == *item {\n                current_node = current_node.clone();\n            } else {\n                return false;\n            }\n        }\n\n        true\n    }\n}\n\nfn main() {\n    let leaf_nodes = vec![\"leaf1\".into(), \"leaf2",
        "nl_input": "Verify (via Merkle tree) that the vkey digests of a proof belong to a specified set (encoded the Merkle tree proofs in input).",
        "gt": "pub fn verify( builder: &mut Builder<C>, digests: Vec<SC::DigestVariable>, input: SP1MerkleProofWitnessVariable<C, SC>, value_assertions: bool, ) { let SP1MerkleProofWitnessVariable { vk_merkle_proofs, values, root } = input; for ((proof, value), expected_value) in vk_merkle_proofs.into_iter().zip(values).zip(digests) { verify(builder, proof, value, root); if value_assertions { SC::assert_digest_eq(builder, expected_value, value); } else { SC::assert_digest_eq(builder, value, value); } } }",
        "url": 114
    },
    {
        "code_input": "use std::io::{Write, Result};\n\nfn write_byte_to_port(port: u16, byte: u8) -> Result<()> {\n    unsafe {\n        if let Err(e) = write::to_fd(port as i32).map_err(|e| e) {\n            eprintln!(\"Failed to write to port: {:?}\", e);\n        }\n    }\n    Ok(())\n}",
        "nl_input": "Write a byte to a port. # Safety The caller must be sure that the given port is safe to write to, and that the given value is safe for it.",
        "gt": "unsafe fn outb(port: u16, data: u8) { unsafe { asm! { \"out dx, al\", in(\"dx\") port, in(\"al\") data, } } }",
        "url": 115
    },
    {
        "code_input": "use std::str::FromStr;\n\n#[derive(Debug, PartialEq)]\nenum Token {\n    While(String),\n    LeftParen,\n    RightParen,\n    LeftBrace,\n    RightBrace,\n    Colon,\n    Semicolon,\n    Equal,\n    GreaterThan,\n    Identifier(String),\n    Int(String),\n    _(String),\n}\n\n#[derive(Debug, PartialEq)]\nenum Parser {\n    Start(Vec<Token>),\n    Token(Token),\n    Error(String),\n}\n\nimpl FromStr for Token {\n    type Err = String;\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        match s {\n            \"while",
        "nl_input": "Parses a desugared `while` loop",
        "gt": "pub const fn hir(expr: &Expr<'hir>) -> Option<Self> { if let ExprKind::Loop( Block { expr: Some(Expr { kind: ExprKind::If( Expr { kind: ExprKind::DropTemps(condition), .. }, body, _, ), .. }), .. }, _, LoopSource::While, span, ) = expr.kind { return Some(Self { condition, body, span }); } None }",
        "url": 116
    },
    {
        "code_input": "use reqwest::Error;\nuse std::io;\n\n#[tokio::main]\nasync fn main() -> Result<(), Error> {\n    let resp = reqwest::get(\"https://httpbin.org/ip\")\n        .await?\n        .text()\n        .await?;\n\n    println!(\"{}\", resp);\n\n    Ok(())\n}",
        "nl_input": "rustfmt-indent_style: Block Function call style",
        "gt": "fn main() { lorem( \"lorem\", \"ipsum\", \"dolor\", \"sit\", \"amet\", \"consectetur\", \"adipiscing\", \"elit\", ); let hyper = Arc::new(Client::with_connector( HttpsConnector::new(TlsClient::new()), )); let x = yooooooooooooo .fooooooooooooooo .baaaaaaaaaaaaar(hello, world); { { let creds = self .client .client_credentials(&self.config.auth.oauth2.id, &self.config.auth.oauth2.secret)?; } } try!(foo( xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx )); try!(foo(try!( xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx ))); }",
        "url": 117
    },
    {
        "code_input": "fn resolve_instance<T>() -> T {\n    T::new()\n}",
        "nl_input": "Resolve an instance starting from a function definition and generic arguments.",
        "gt": "pub fn resolve(def: FnDef, args: &GenericArgs) -> Result<Instance, crate::Error> { with(|context| { context.resolve_instance(def, args).ok_or_else(|| { crate::Error::new(format!(\"Failed to resolve `{def:?}` with `{args:?}`\")) }) }) }",
        "url": 118
    },
    {
        "code_input": "use curve25519_dalek::{FieldElement, Signature};\nuse std::convert::TryInto;\n\nfn hash_to_field_element(bytes: &[u8]) -> FieldElement {\n    let mut hasher = sha2::Sha256::new();\n    hasher.update(bytes);\n    let result = hasher.finalize();\n    let bytes_as_u32 = result.as_slice().try_into().unwrap();\n    FieldElement::from_slice(&bytes_as_u32)\n}",
        "nl_input": "Hashes the bytes to a field element and returns the byte representation",
        "gt": "pub(crate) fn sum(&self) -> Result<Vec<u8>, PlonkError> { let res = Self::hash(self.to_hash.clone(), self.domain.clone(), 1)?; Ok(res[0].clone()) }",
        "url": 119
    },
    {
        "code_input": "pub fn callback_example(callback: &dyn Fn(i32) -> i32, param: i32) {\n    let result = callback(param);\n    println!(\"Result: {}\", result);\n}\n\nfn main() {\n    let callback = |x: i32| -> i32 { x * 2 };\n    callback_example(&callback, 5);\n}",
        "nl_input": "This is a callback from `rustc_hir` as it cannot access the implicit state in `rustc_middle` otherwise.",
        "gt": "fn def_id_debug(def_id: rustc_hir::def_id::DefId, f: &mut fmt::Formatter<'_>) -> fmt::Result { write!(f, \"DefId({}:{}\", def_id.krate, def_id.index.index())?; tls::with_opt(|opt_tcx| { if let Some(tcx) = opt_tcx { write!(f, \" ~ {}\", tcx.def_path_debug_str(def_id))?; } Ok(()) })?; write!(f, \")\") }",
        "url": 120
    },
    {
        "code_input": "use std::error::Error;\nuse std::fs::File;\nuse std::io::Read;\nuse xml_rs::parse::Document;\n\nfn parse_xml(file_path: &str) -> Result<Document, Box<dyn Error>> {\n    let file = File::open(file_path)?;\n    let mut buffer = String::new();\n    file.read_to_string(&mut buffer)?;\n\n    let document = Document::parse_document(&buffer)?;\n\n    Ok(document)\n}\n\nfn main() {\n    match parse_",
        "nl_input": "Check that associated paths starting with `<<` are successfully parsed.",
        "gt": "fn main() { let _: <<A>::B>::C; let _ = <<A>::B>::C; let <<A>::B>::C; let 0 ..= <<A>::B>::C; <<A>::B>::C; }",
        "url": 121
    },
    {
        "code_input": "fn main() {\n    let result = Ok(\"Hello, world!\".to_string());\n    match result {\n        Ok(value) => println!(\"{}\", value),\n        Err(error) => println!(\"Error: {}\", error),\n    }\n}",
        "nl_input": "even without panics, this helps for Miri backtraces",
        "gt": "pub const unsafe fn unreachable_unchecked() -> ! { ub_checks::assert_unsafe_precondition!( check_language_ub, \"hint::unreachable_unchecked must never be reached\", () => false ); unsafe { intrinsics::unreachable() } }",
        "url": 122
    },
    {
        "code_input": "fn find_char(s: &str) -> Option<usize> {\n    let mut i = 0;\n    while i < s.len() && s.chars().nth(i).unwrap() == ' ' {\n        i += 1;\n    }\n    if i == s.len() {\n        None\n    } else {\n        Some(i)\n    }\n}",
        "nl_input": "Returns `None` if the first `col` chars of `s` contain a non-whitespace char. Otherwise returns `Some(k)` where `k` is first char offset after that leading whitespace. Note that `k` may be outside bounds of `s`.",
        "gt": "fn all_whitespace(s: &str, col: CharPos) -> Option<usize> { let mut idx = 0; for (i, ch) in s.char_indices().take(col.to_usize()) { if !ch.is_whitespace() { return None; } idx = i + ch.len_utf8(); } Some(idx) }",
        "url": 123
    },
    {
        "code_input": "use std::collections::HashMap;\nuse std::collections::HashSet;\nuse std::sync::Arc;\nuse std::sync::Mutex;\nuse std::sync::RwLock;\n\n#[derive(Debug, Clone, Copy)]\nenum Message {\n    Hello,\n    World,\n}\n\n#[derive(Debug, Clone, Copy)]\nenum Color {\n    Red,\n    Green,\n    Blue,\n}\n\n#[derive(Debug, Clone, Copy)]\nenum Shape {\n    Circle,\n    Square,\n    Triangle,\n}\n\n#[derive(Debug, Clone, Copy)]\nenum MessageType {\n    Text,\n    Image,\n    Sound,\n}\n\n#[derive(Debug, Clone, Copy)]\nenum MessageDirection {\n    In,\n    Out,\n}\n\n#[derive(Debug, Clone, Copy)]\nenum MessagePriority {\n    High,\n    Medium,\n    Low,\n}\n\n#[derive(Debug, Clone, Copy)]",
        "nl_input": "FIXME: Move this out, its not a diagnostic only thing anymore, and handle unsafe pattern accesses as well",
        "gt": "pub fn unsafe_expressions( db: &dyn HirDatabase, infer: &InferenceResult, def: DefWithBodyId, body: &Body, current: ExprId, unsafe_expr_cb: &mut dyn FnMut(UnsafeExpr), ) { walk_unsafe( db, infer, body, &mut resolver_for_expr(db.upcast(), def, current), def, current, false, unsafe_expr_cb, ) }",
        "url": 124
    },
    {
        "code_input": "use async_std::prelude::*;\n\n#[tokio::main]\nasync fn main() {\n    let future = async {\n        // Simulate a long-running task\n        let result = std::time::sleep(std::time::Duration::from_secs(5)).await;\n        println!(\"Future completed: {}\", result);\n    };\n\n    // Run the future on the current thread\n    tokio::spawn(future);\n}",
        "nl_input": "Run a future to completion on the current thread.",
        "gt": "fn block_on<T>(fut: impl Future<Output = T>) -> T { let mut fut = Box::pin(fut); let t = thread::current(); let waker = Arc::new(ThreadWaker(t)).into(); let mut cx = Context::from_waker(&waker); loop { match fut.as_mut().poll(&mut cx) { Poll::Ready(res) => return res, Poll::Pending => thread::park(), } } }",
        "url": 125
    },
    {
        "code_input": "fn safe_div<T>(a: T, b: T) -> T {\n    a / b\n}\n\nfn main() {\n    println!(\"{}\", safe_div::<i32>(5, 2));\n}",
        "nl_input": "~^ ERROR defaults for type parameters are only allowed in `struct`, `enum`, `type`, or `trait` definitions ~| WARNING this was previously accepted by the compiler but is being phased out ~| ERROR `impl Trait` is not allowed in generic parameter defaults",
        "gt": "fn main() { let _in_local_variable: impl Fn() = || {}; let _in_return_in_local_variable = || -> impl Fn() { || {} }; }",
        "url": 126
    },
    {
        "code_input": "extern crate rust_crypto;\n\nuse rust_crypto::{Key, Keccak256, SecretKey, SecretKeyInit, X25519};\nuse std::str::FromStr;\n\nfn derive_key(master_key: &str, path: &str) -> Result<Key, Box<dyn std::error::Error>> {\n    let master_key = SecretKeyInit::from_str(master_key)?;\n\n    let mut key = master_key;\n    for part in path.split(\"/\") {\n        match part {\n            \"m\" => key = master_key,\n            \"c\" => key = X25519::derive(&key),\n            \"n\" => key = X25519::derive(&key),\n            \"s\" => key = X25519::derive(&key),\n            \"h\" => key = X2",
        "nl_input": "Derives a key from a master key and a derivation path",
        "gt": "pub fn derive_key( master_key: ExtendedPrivKey, path: DerivationPath, ) -> ExtendedPrivKey { master_key.derive_priv(&Secp256k1::new(), &path).unwrap() }",
        "url": 127
    },
    {
        "code_input": "use std::collections::HashMap;\n\nstruct Node<K, V> {\n    key: K,\n    value: V,\n    left: Option<Box<Node<K, V>>>,\n    right: Option<Box<Node<K, V>>>,\n}\n\nimpl<K: Ord, V> Node<K, V> {\n    fn new(key: K, value: V) -> Node<K, V> {\n        Node {\n            key,\n            value,\n            left: None,\n            right: None,\n        }\n    }\n\n    fn visit_leaf_nodes(&self, order: &mut Vec<(K, V)>) {\n        if self.left.is_none() && self.right.is_none() {\n            order.push((self.key, self.value));\n        }\n    }\n\n    fn",
        "nl_input": "Visits leaf nodes and internal KVs in order of ascending keys, and also visits internal nodes as a whole in a depth first order, meaning that internal nodes precede their individual KVs and their child nodes.",
        "gt": "pub fn visit_nodes_in_order<F>(self, mut visit: F) where F: FnMut(Position<marker::Immut<'a>, K, V>), { match self.force() { Leaf(leaf) => visit(Position::Leaf(leaf)), Internal(internal) => { visit(Position::Internal(internal)); let mut edge = internal.first_edge(); loop { edge = match edge.descend().force() { Leaf(leaf) => { visit(Position::Leaf(leaf)); match edge.next_kv() { Ok(kv) => { visit(Position::InternalKV); kv.right_edge() } Err(_) => return, } } Internal(internal) => { visit(Position::Internal(internal)); internal.first_edge() } } } } } }",
        "url": 128
    },
    {
        "code_input": "use std::fs;\nuse std::path::Path;\n\nfn get_search_patterns(path: &str) -> Vec<String> {\n    let path = Path::new(path);\n    let mut search_patterns = Vec::new();\n\n    if path.is_dir() {\n        for entry in fs::read_dir(path).unwrap() {\n            let entry = entry.unwrap();\n            if entry.path().is_file() {\n                let file_name = entry.path().file_name().unwrap().to_str().unwrap();\n                if file_name.ends_with(\".txt\") {\n                    search_patterns.push(file_name.to_string());\n                }\n            }\n        }\n    } else {\n        let file_name = path.file_name().unwrap().to_str().unwrap();",
        "nl_input": "Get the search patterns to use for the given path",
        "gt": "fn qpath_search_pat(path: &QPath<'_>) -> (Pat, Pat) { match path { QPath::Resolved(ty, path) => { let start = if ty.is_some() { Pat::Str(\"<\") } else { path.segments.first().map_or(Pat::Str(\"\"), |seg| { if seg.ident.name == kw::PathRoot { Pat::Str(\"::\") } else { Pat::Sym(seg.ident.name) } }) }; let end = path.segments.last().map_or(Pat::Str(\"\"), |seg| { if seg.args.is_some() { Pat::Str(\">\") } else { Pat::Sym(seg.ident.name) } }); (start, end) }, QPath::TypeRelative(_, name) => (Pat::Str(\"\"), Pat::Sym(name.ident.name)), QPath::LangItem(..) => (Pat::Str(\"\"), Pat::Str(\"\")), } }",
        "url": 129
    },
    {
        "code_input": "use web3::{Http, JsonRpc};\nuse std::error::Error;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn Error>> {\n    let http = Http::new().chain_err()?;\n    let rpc = JsonRpc::new(http, \"http://localhost:8545\");\n\n    let contract_address = \"0x79df72bd\";\n    let contract_abi = r#\"\n    [\n        {\n            \"constant\": true,\n            \"inputs\": [],\n            \"name\": \"getOrderHash\",\n            \"outputs\": [",
        "nl_input": "Calls the contract's `getOrderHash` (0x79df72bd) function",
        "gt": "pub fn get_order_hash( &self, order: OrderComponents, ) -> ::ethers::contract::builders::ContractCall<M, [u8; 32]> { self.0 .method_hash([121, 223, 114, 189], (order,)) .expect(\"method not found (this should never happen)\") }",
        "url": 130
    },
    {
        "code_input": "pub struct Query {\n    is_dirty: bool,\n}\n\nimpl Query {\n    pub fn new() -> Self {\n        Self {\n            is_dirty: false,\n        }\n    }\n\n    pub fn handle_storage_change(&mut self) -> bool {\n        self.is_dirty = true;\n        self.is_dirty\n    }\n\n    pub fn is_dirty(&self) -> bool {\n        self.is_dirty\n    }\n}",
        "nl_input": "handle_storage_change checks if the storage change affects this query sets the state to dirty if it does returns self.is_dirty()",
        "gt": "pub fn handle_storage_change(&mut self, change: &StorageChange) -> bool { match self.state { State::Dirty => {} State::Monitoring { root_pages_sorted: ref root_pages } => match change { StorageChange::Full => self.state = State::Dirty, StorageChange::Tables { root_pages_sorted: ref changed_root_pages, } => { if has_sorted_intersection(root_pages, changed_root_pages) { self.state = State::Dirty; } } }, State::Error => self.state = State::Dirty, } self.is_dirty() }",
        "url": 131
    },
    {
        "code_input": "fn main() {\n    let v = vec![1, 2, 3, 4, 5];\n    let _ = v.drain(0..2);\n    println!(\"{:?}\", v);\n}",
        "nl_input": "Ok, dropping opt doesn't access the reference",
        "gt": "fn optional_tuple(opt: Option<(&mut i32, String)>) -> Option<&mut i32> { match opt { Some((&mut ref mut r, _)) => { Some(r) }, None => None, } }",
        "url": 132
    },
    {
        "code_input": "const SIZE: usize = 10;\n\nfn main() {\n    println!(\"The value of size is: {}\", SIZE);\n}",
        "nl_input": "Tires to get the value of Const `size` as usize.",
        "gt": "pub fn try_resolve_const_size(size: Const) -> Result<usize, &'static str> { let (scalar, ty) = match size.try_to_scalar() { Some(value) => Ok(value), None => Err(\"Can't resolve scalar array size!\"), }?; let value = scalar.to_u64().expect(\"Could not convert scalar to u64!\"); Ok(usize::try_from(value).expect(\"Const size value too big.\")) }",
        "url": 133
    },
    {
        "code_input": "fn deduplicate_arg_names(names: &mut Vec<String>) {\n    let mut seen = std::collections::HashSet::new();\n    for name in names.iter_mut() {\n        if seen.contains(&name.to_string()) {\n            let mut i = 1;\n            loop {\n                let new_name = format!(\"{}_{}\", name, i);\n                if !seen.contains(&new_name) {\n                    *name = new_name.to_string();\n                    break;\n                }\n                i += 1;\n            }\n        } else {\n            seen.insert(name.clone());\n        }\n    }\n}\n\nfn main() {\n    let mut names: Vec<String> = vec![\"foo\".into(), \"foo\".into(), \"bar\".into(), \"baz\".into(), \"bar\".into()];\n    deduplicate_arg_names(&mut names);\n    let expected: Vec<String> = vec![\"foo_1\".into(), \"foo",
        "nl_input": "Makes duplicate argument names unique by appending incrementing numbers. ``` let mut names: Vec<String> = vec![\"foo\".into(), \"foo\".into(), \"bar\".into(), \"baz\".into(), \"bar\".into()]; deduplicate_arg_names(&mut names); let expected: Vec<String> = vec![\"foo_1\".into(), \"foo_2\".into(), \"bar_1\".into(), \"baz\".into(), \"bar_2\".into()]; assert_eq!(names, expected); ```",
        "gt": "fn deduplicate_arg_names(arg_names: &mut [String]) { let mut arg_name_counts = FxHashMap::default(); for name in arg_names.iter() { *arg_name_counts.entry(name).or_insert(0) += 1; } let duplicate_arg_names: FxHashSet<String> = arg_name_counts .into_iter() .filter(|(_, count)| *count >= 2) .map(|(name, _)| name.clone()) .collect(); let mut counter_per_name = FxHashMap::default(); for arg_name in arg_names.iter_mut() { if duplicate_arg_names.contains(arg_name) { let counter = counter_per_name.entry(arg_name.clone()).or_insert(1); arg_name.push('_'); arg_name.push_str(&counter.to_string()); *counter += 1; } } }",
        "url": 134
    },
    {
        "code_input": "use vmbus::VmBusDevice;\nuse vmbus::VmBusDeviceError;\nuse vmbus::VmBusDeviceHandle;\nuse vmbus::VmBusDeviceType;\nuse vmbus::VmBusDeviceUnit;\nuse vmbus::VmBusDeviceUnitId;\nuse vmbus::VmBusDeviceUnitType;\nuse vmbus::VmBusDeviceUnitTypeId;\nuse vmbus::VmBusDeviceUnitVersion;\nuse vmbus::VmBusDeviceUnitVersionId;\nuse vmbus::VmBusDeviceUnitVersionType;\nuse vmbus::VmBusDeviceUnitVersionTypeId;\n\npub struct StateUnit {\n    // Add fields here\n}\n\npub struct VmBusDeviceUnitBuilder {\n    device: VmBusDevice,\n    unit: VmBusDeviceUnit,\n}\n\nimpl VmBusDeviceUnitBuilder {\n    pub",
        "nl_input": "Offers a simple vmbus device, creates a unit for it, and adds it to `state_units`.",
        "gt": "pub async fn offer_simple_device_unit<T: SimpleVmbusDevice>( driver_source: &VmTaskDriverSource, state_units: &StateUnits, vmbus: &VmbusServerHandle, device: T, ) -> anyhow::Result<SpawnedUnit<SimpleChannelUnit<T>>> { let offer = device.offer(); let name = format!(\"{}:{}\", offer.interface_name, offer.instance_id); let handle = offer_simple_device(driver_source, vmbus.control.as_ref(), device).await?; let unit = state_units .add(name) .depends_on(vmbus.unit.handle()) .spawn(driver_source.simple(), |recv| { run_async_unit(SimpleChannelUnit(handle), recv) })?; Ok(unit) }",
        "url": 135
    },
    {
        "code_input": "use std::collections::HashMap;\n\nstruct Scope {\n    parent: Option<Box<dyn Scope>>,\n    vars: HashMap<String, i32>,\n}\n\nimpl Scope {\n    fn new(parent: Option<Box<dyn Scope>>) -> Self {\n        Self {\n            parent,\n            vars: HashMap::new(),\n        }\n    }\n\n    fn define_var(&mut self, name: String, value: i32) {\n        self.vars.insert(name, value);\n    }\n\n    fn resolve_var(&self, name: &str) -> Option<&i32> {\n        if let Some(value) = self.vars.get(name) {\n            Some(value)\n        } else if let Some(parent) = self.parent.as_ref() {\n            parent.resolve_var(name",
        "nl_input": "Returns a suitable node for resolving paths in the current scope. If we create a scope based on a statement node, then we can't resolve local variables that were defined in the current scope (only in parent scopes). So we find another node, ideally a child of the statement where local variable resolution is permitted.",
        "gt": "fn pick_node_for_resolution(node: SyntaxNode) -> SyntaxNode { match node.kind() { SyntaxKind::EXPR_STMT => { if let Some(n) = node.first_child() { cov_mark::hit!(cursor_after_semicolon); return n; } } SyntaxKind::LET_STMT | SyntaxKind::IDENT_PAT => { if let Some(next) = node.next_sibling() { return pick_node_for_resolution(next); } } SyntaxKind::NAME => { if let Some(parent) = node.parent() { return pick_node_for_resolution(parent); } } _ => {} } node }",
        "url": 136
    },
    {
        "code_input": "pub fn park_car(self) -> bool {\n    if self.state == PARKED {\n        self.state = UNPARKED;\n        true\n    } else {\n        false\n    }\n}",
        "nl_input": "Assumes this is only called by the thread that owns the Parker, which means that `self.state != PARKED`. This implementation doesn't require `Pin`, but other implementations do.",
        "gt": "pub unsafe fn park_timeout(self: Pin<&Self>, timeout: Duration) { if self.state.fetch_sub(1, Acquire) == NOTIFIED { return; } #[cfg(target_vendor = \"win7\")] if c::WaitOnAddress::option().is_none() { return keyed_events::park_timeout(self, timeout); } c::WaitOnAddress(self.ptr(), &PARKED as *const _ as *const c_void, 1, dur2timeout(timeout)); if self.state.swap(EMPTY, Acquire) == NOTIFIED { } else { } }",
        "url": 137
    },
    {
        "code_input": "use std::iter::FromIterator;\n\n// Define the Record struct\n#[derive(Debug, Clone, Copy)]\nstruct Record {\n    id: i32,\n    name: String,\n}\n\n// Define the Table struct\n#[derive(Debug, Clone)]\nstruct Table {\n    records: Vec<Record>,\n}\n\n// Define a function to create a new record\nfn create_record(id: i32, name: String) -> Record {\n    Record { id, name }\n}\n\n// Define a function to create a new table with a new record\nfn create_table(new_record: Record) -> Table {\n    Table {\n        records: vec![new_record],\n    }\n}\n\n// Define a function to create a new table with a new record iterator\nfn create_table_with_iterator(new_record_iterator: impl",
        "nl_input": "Extend the table with a iterator of new records.",
        "gt": "pub async fn extend<T: IntoIterator<Item = R> + Send>(&self, iter: T) -> anyhow::Result<Vec<Id>> where R: AsRef<Document> + Serialize + DeserializeOwned, K: Sync, { let entries = iter.into_iter().collect::<Vec<_>>(); let documents = entries.iter().map(|v| v.as_ref()).collect::<Vec<_>>(); let embeddings = self .chunker .chunk_batch(documents, &self.embedding_model) .await?; let mut ids = Vec::new(); for (value, embeddings) in entries.into_iter().zip(embeddings) { let id = self.table.insert(embeddings, value).await?; ids.push(id); } Ok(ids) }",
        "url": 138
    },
    {
        "code_input": "use tch::nn::Module;\nuse tch::nn::Optimizer;\nuse tch::nn::Func;\nuse tch::nn::FuncConfig;\nuse tch::nn::Variable;\nuse tch::nn::nn_init;\nuse tch::nn::MSELoss;\nuse tch::nn::CrossEntropyLoss;\nuse tch::nn::Adam;\nuse tch::nn::AdamConfig;\nuse tch::nn::ReLU;\nuse tch::nn::Sigmoid;\nuse tch::nn::Tanh;\nuse tch::nn::LeakyReLU;\nuse tch::nn::SELU;\nuse tch::nn::Softplus;\nuse tch::nn::Softmax;\nuse tch::nn::LogSoftmax;\nuse tch::nn::LogSigmoid;\nuse tch::nn::Hardswish;\nuse tch::nn::Hardtanh;\nuse tch::nn::ELU;\nuse tch::nn::Threshold;\nuse tch::nn::",
        "nl_input": "Set the name of the model to use.",
        "gt": "pub fn with_model(self, model: impl ToString) -> RemoteOpenAICompatibleModelBuilder<true> { RemoteOpenAICompatibleModelBuilder { model: Some(model.to_string()), config: self.config, } }",
        "url": 139
    },
    {
        "code_input": "use diesel::prelude::*;\nuse diesel::pg::PgConnection;\n\n#[derive(Queryable, Insertable, AsChangeset, Identifiable, Debug)]\n#[table_name=\"your_table_name\"]\npub struct YourTable {\n    pub id: i32,\n    pub column1: String,\n    // Add more fields as needed\n}\n\npub fn run_query() -> Vec<YourTable> {\n    let conn = PgConnection::establish(\"your_connection_string\").unwrap();\n\n    diesel::update(&YourTable::table)\n        .set(&[\n            (\"column1\", \"new_value\"),\n            // Add more set statements as needed\n        ])\n        .get_result::<YourTable>(&conn)\n        .unwrap()\n}",
        "nl_input": "Wrap the column output name and its type within the [`ColumnField`]",
        "gt": "pub fn get_column_field(&self) -> ColumnField { ColumnField::new(self.column_ref.column_id(), *self.column_ref.column_type()) }",
        "url": 140
    },
    {
        "code_input": "fn safe_get<T>(n: usize, t: T) -> Vec<T> {\n    vec![t; n]\n}",
        "nl_input": "SAFETY: caller must ensure the attribute type `n` matches type `T`.",
        "gt": "unsafe fn attribute<T>(&self, n: u32) -> Option<&T> { if (self.header.ValidAttributes & n) != 0 { unsafe { Some( AlpcGetMessageAttribute(std::ptr::from_ref(&self.header).cast_mut(), n) .cast::<T>() .as_ref() .unwrap(), ) } } else { None } }",
        "url": 141
    },
    {
        "code_input": "use std::process::Command;\nuse std::io::Read;\n\nfn main() {\n    let mut aux_vector = Vec::new();\n    let mut proc_cpuinfo = Vec::new();\n\n    // Read from auxiliary vector\n    match aux_vector.read_to_slice() {\n        Ok(_) => println!(\"Read from auxiliary vector\"),\n        Err(e) => {\n            println!(\"Error reading from auxiliary vector: {:?}\", e);\n            // If error, read from proc cpuinfo\n            match Command::new(\"cat\")\n                .arg(\"/proc/cpuinfo\")\n                .output()\n                .expect(\"Failed to execute process\")\n                .stdout\n                .read_to_slice()\n            {\n                Ok(output) => {\n                    proc_cpuinfo.extend(output.iter().filter(|&&c| c.is_alphabetic() || c.is_digit(10)));\n                    println!(\"",
        "nl_input": "Try to read the features from the auxiliary vector, and if that fails, try to read them from ` proc cpuinfo`.",
        "gt": "fn detect_features() -> cache::Initializer { let mut value = cache::Initializer::default(); let enable_feature = |value: &mut cache::Initializer, f, enable| { if enable { value.set(f as u32); } }; if let Ok(auxv) = auxvec::auxv() { enable_feature(&mut value, Feature::msa, bit::test(auxv.hwcap, 1)); return value; } value }",
        "url": 142
    },
    {
        "code_input": "fn main() {\n    let s = String::from(\"Hello, world!\");\n    match s.as_str() {\n        \"Hello, world!\" => println!(\"Matched!\"),\n        _ => (),\n    }\n}",
        "nl_input": "Should not trigger lint since `String::as_str` returns a reference (i.e., `&str`) to the locked data (i.e., the `String`) and it is not surprising that matching such a reference needs to keep the data locked until the end of the match block.",
        "gt": "fn should_not_trigger_lint_for_string_as_str() { let mutex1 = Mutex::new(StateWithField { s: \"one\".to_owned() }); { let mutex2 = Mutex::new(StateWithField { s: \"two\".to_owned() }); let mutex3 = Mutex::new(StateWithField { s: \"three\".to_owned() }); match mutex3.lock().unwrap().s.as_str() { \"three\" => { println!(\"started\"); mutex1.lock().unwrap().s.len(); mutex2.lock().unwrap().s.len(); println!(\"done\"); }, _ => {}, }; match (true, mutex3.lock().unwrap().s.as_str()) { (_, \"three\") => { println!(\"started\"); mutex1.lock().unwrap().s.len(); mutex2.lock().unwrap().s.len(); println!(\"done\"); }, (_, _) => {}, }; } }",
        "url": 143
    },
    {
        "code_input": "fn get_first_non_empty(self) -> Option<&str> {\n    self.iter().next()\n}",
        "nl_input": "Note that `self` must be nonempty.",
        "gt": "pub fn first_kv(self) -> Handle<Self, marker::KV> { let len = self.len(); assert!(len > 0); unsafe { Handle::new_kv(self, 0) } }",
        "url": 144
    },
    {
        "code_input": "use reqwest::Error;\nuse tokio::net::TcpStream;\nuse tokio::prelude::*;\nuse std::io::Read;\n\n#[tokio::main]\nasync fn main() -> Result<(), Error> {\n    let stream = TcpStream::connect(\"localhost:8000\").await?;\n    let mut body = String::new();\n    stream.read_to_string(&mut body).await?;\n    println!(\"{}\", body);\n    Ok(())\n}",
        "nl_input": "Client send default body to server. Return the body on success.",
        "gt": "pub fn client_send_body(&mut self, stream: u64, fin: bool) -> Result<Bytes> { let mut body = Bytes::from(\"Quic Century\"); let sent = self .client .send_body(&mut self.pair.client, stream, body.clone(), fin)?; self.move_forward().ok(); body.truncate(sent); Ok(body) }",
        "url": 145
    },
    {
        "code_input": "use std::panic;\nuse std::panic::Signal;\n\nfn main() {\n    // Register a handler for SIGSEGV\n    unsafe {\n        ::signal::signal_set_handler(Signal::segmentation_fault, |_sig| {\n            // Print a stack trace\n            panic::set_hook(Box::new(|info| {\n                eprintln!(\"Segmentation fault: {}\", info.message());\n                std::process::exit(139)\n            }));\n            // Exit\n            std::process::exit(139);\n        });\n    }\n\n    // Continue with your code\n    println!(\"Continue with your code...\");\n}",
        "nl_input": "When SIGSEGV is delivered to the process, print a stack trace and then exit.",
        "gt": "pub(super) fn install() { unsafe { let alt_stack_size: usize = min_sigstack_size() + 64 * 1024; let mut alt_stack: libc::stack_t = mem::zeroed(); alt_stack.ss_sp = alloc(Layout::from_size_align(alt_stack_size, 1).unwrap()).cast(); alt_stack.ss_size = alt_stack_size; libc::sigaltstack(&alt_stack, ptr::null_mut()); let mut sa: libc::sigaction = mem::zeroed(); sa.sa_sigaction = print_stack_trace as libc::sighandler_t; sa.sa_flags = libc::SA_NODEFER | libc::SA_RESETHAND | libc::SA_ONSTACK; libc::sigemptyset(&mut sa.sa_mask); libc::sigaction(libc::SIGSEGV, &sa, ptr::null_mut()); } }",
        "url": 146
    },
    {
        "code_input": "pub fn format_and_execute<E: Executor, P: Parameters>(executor: &E, parameters: P) -> E::Output {\n    let formatted_step = format_step(parameters);\n    executor.execute(formatted_step)\n}",
        "nl_input": "Formats the step with the provided parameters and executes it using the associated executor. This function takes a reference to a `Parameters` struct, formats the step with the provided parameters, and executes it using the associated executor. The result of the execution is returned as `E::Output`.",
        "gt": "pub async fn format_and_execute( &self, parameters: &Parameters, ) -> Result<Output, FormatAndExecuteError> { let prompt = self.step.format(parameters)?; Ok(self.executor.execute(self.step.options(), &prompt).await?) }",
        "url": 147
    },
    {
        "code_input": "I'm sorry, but your request is not clear. The code you're asking for is not provided. Could you please provide more details or clarify what you're asking for?\n",
        "nl_input": "@ check-pass @ revisions: default edition2021 @[edition2021] compile-flags: --edition 2021",
        "gt": "fn main() { type T = impl Copy; let foo: T = Some((1u32, 2u32)); match foo { None => (), Some((a, b)) => (), } }",
        "url": 148
    },
    {
        "code_input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::time::Duration;\n\nstruct Node {\n    complete: bool,\n}\n\nimpl Node {\n    fn new() -> Node {\n        Node { complete: false }\n    }\n\n    fn mark_as_complete(&mut self) {\n        self.complete = true;\n    }\n\n    fn wait_until_complete(&self) {\n        let mut mutex = Mutex::new(false);\n        let mut condition = Arc::new(mut Mutex::lock(mut self.clone()).unwrap());\n\n        let thread = thread::spawn(move || {\n            while !*condition.get() {\n                thread::sleep(Duration::from_secs(1));\n            }\n            self.mark_as_complete();\n        });\n\n        while !self.complete {\n            thread::sleep(Duration::",
        "nl_input": "Wait until this node is marked as [`complete`](Node::complete)d by another thread. # Safety May only be called from the thread that created the node.",
        "gt": "unsafe fn wait(&self) { while !self.completed.load(Acquire) { unsafe { self.thread.get().unwrap().park(); } } }",
        "url": 149
    },
    {
        "code_input": "fn sum(a: i32, b: i32) -> i32 {\n    a + b\n}",
        "nl_input": "rustfmt-max_width: 160 rustfmt-fn_call_width: 96 rustfmt-fn_args_layout: Compressed rustfmt-trailing_comma: Always rustfmt-wrap_comments: true",
        "gt": "fn foo() { for elem in try!(gen_epub_book::ops::parse_descriptor_file( &mut try!(File::open(&opts.source_file.1).map_err(|_| { gen_epub_book::Error::Io { desc: \"input file\", op: \"open\", more: None, } })), \"input file\" )) { println!(\"{}\", elem); } }",
        "url": 150
    },
    {
        "code_input": "fn main() {\n    let sym = \"hello\";\n    println!(\"{}\", sym);\n}",
        "nl_input": "~^ ERROR invalid `sym` operand",
        "gt": "fn main() { unsafe { let x: u64 = 0; const C: i32 = 0; static S: i32 = 0; asm!(\"{}\", sym S); asm!(\"{}\", sym main); asm!(\"{}\", sym C); asm!(\"{}\", sym x); } }",
        "url": 151
    },
    {
        "code_input": "use std::process::Command;\n\nfn main() {\n    let mut backtrace = Vec::new();\n    let mut backtrace_stderr = Vec::new();\n\n    let mut cmd = Command::new(\"backtrace\");\n    cmd.stderr(std::io::stderr());\n    let output = cmd.output().expect(\"Failed to execute command\");\n\n    for line in output.stderr.iter_lines() {\n        backtrace_stderr.push(line.expect(\"Failed to read line\"));\n    }\n\n    let mut cmd = Command::new(\"backtrace\");\n    cmd.stdout(std::io::stdout());\n    let output = cmd.output().expect(\"Failed to execute command\");\n\n    for line in output.stdout.iter_lines() {\n        backtrace.push(line.expect(\"Failed to read line\"));\n    }\n\n    for line in backtrace_stderr.iter() {\n        println!(\"{}\", line);\n    }\n\n    for line in backtrace.iter() {\n        eprintln!(\"{}\", line);",
        "nl_input": "this goes to stdout and each line has to be occurred in the following backtrace to stderr with a correct order.",
        "gt": "fn dump_filelines(filelines: &[Pos]) { for &(file, line) in filelines.iter().rev() { let basename = file.split(&['/', '\\\\'][..]).last().unwrap(); println!(\"{}:{}\", basename, line); } }",
        "url": 152
    },
    {
        "code_input": "fn negative_of_wrapping(value: i32) -> i32 {\n    let mut result = value;\n    if value >= 0 {\n        result = result - 1;\n    }\n    result\n}",
        "nl_input": "Computes the wrapping negative of the value. This could perhaps be more efficient.",
        "gt": "fn neg(self) -> Self { let mut res = ark_ff::BigInt([0; 4]); res.sub_with_borrow(&ark_ff::BigInt(self.0)); Self(res.0) }",
        "url": 153
    },
    {
        "code_input": "use pandas::DataFrame;\n\nfn add_sheet(df: &mut DataFrame, sheet_name: &str) -> Result<(), &str> {\n    if df.has_sheet(sheet_name) {\n        return Err(\"A worksheet with that name already exists\");\n    }\n\n    if !sheet_name.is_valid() {\n        return Err(\"The name is invalid\");\n    }\n\n    df.add_sheet(sheet_name)?;\n\n    Ok(())\n}",
        "nl_input": "Adds a sheet with a specific name Fails if a worksheet with that name already exists or the name is invalid",
        "gt": "pub fn add_sheet(&mut self, sheet_name: &str) -> Result<(), String> { self.insert_sheet(sheet_name, self.workbook.worksheets.len() as u32, None) }",
        "url": 154
    },
    {
        "code_input": "pub fn get_const_generic<T>(t: &const T) -> &'static T {\n    t\n}",
        "nl_input": "~ ERROR: using raw pointers as const generic parameters",
        "gt": "fn main() { let _: Const<{ 15 as *const _ }> = Const::<{ 10 as *const _ }>; let _: Const<{ 10 as *const _ }> = Const::<{ 10 as *const _ }>; }",
        "url": 155
    },
    {
        "code_input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::time::Duration;\n\nstruct SyntheticWrite {\n    durability: Arc<Mutex<bool>>,\n}\n\nimpl SyntheticWrite {\n    pub fn new(durability: Arc<Mutex<bool>>) -> SyntheticWrite {\n        SyntheticWrite { durability }\n    }\n\n    pub fn write(&self) {\n        let mut durability = self.durability.lock().unwrap();\n        *durability = true;\n\n        // Add some delay to simulate a write operation\n        thread::sleep(Duration::from_secs(1));\n\n        *durability = false;\n    }\n}\n\nfn main() {\n    let durability = Arc::new(Mutex::new(false));\n    let write =",
        "nl_input": "A \"synthetic write\" causes the system to act *as though* some input of durability `durability` has changed. This is mostly useful for profiling scenarios. **WARNING:** Just like an ordinary write, this method triggers cancellation. If you invoke it while a snapshot exists, it will block until that snapshot is dropped -- if that snapshot is owned by the current thread, this could trigger deadlock.",
        "gt": "pub fn synthetic_write(&mut self, durability: Durability) { self.with_incremented_revision(|_next_revision| Some(durability)); }",
        "url": 156
    },
    {
        "code_input": "I'm sorry, but I can't provide the code you're looking for. The code you're asking for is not clear. It seems like you're asking for a function from a specific crate, but you didn't provide the name of the crate. Could you please provide more details?\n",
        "nl_input": "This expands to either - `$crate::panic::panic_2015!(...)` or - `$crate::panic::panic_2021!(...)` depending on the edition. This is used for both std::panic!() and core::panic!(). `$crate` will refer to either the `std` or `core` crate depending on which one we're expanding from.",
        "gt": "pub(crate) fn expand_panic<'cx>( cx: &'cx mut ExtCtxt<'_>, sp: Span, tts: TokenStream, ) -> MacroExpanderResult<'cx> { let mac = if use_panic_2021(sp) { sym::panic_2021 } else { sym::panic_2015 }; expand(mac, cx, sp, tts) }",
        "url": 157
    },
    {
        "code_input": "fn advance_ranges(ranges: &mut Vec<(usize, usize)>, len: usize) {\n    for range in ranges.iter_mut() {\n        range.0 += len;\n        range.1 += len;\n    }\n}",
        "nl_input": "Advances the range list by `len` bytes.",
        "gt": "pub fn skip(&mut self, mut len: usize) { assert!(self.len() >= len); while len > 0 { let n = self.current(len).len(); self.advance(n); len -= n; } }",
        "url": 158
    },
    {
        "code_input": "fn main() {\n    let strings = vec![\"Hello\", \"World\", \"Rust\", \"Programming\", \"Language\"];\n    let search_str = \"Rust\";\n\n    let result = strings.iter().position(|s| s == search_str);\n\n    match result {\n        Some(position) => println!(\"Found at position: {}\", position),\n        None => println!(\"Not found\"),\n    }\n}",
        "nl_input": "bindings_after_at + slice_patterns + or_patterns",
        "gt": "fn bindings_after_at_slice_patterns_or_patterns_moves(x: [Option<Test>; 4]) { match x { a @ [.., Some(Test::Foo | Test::Bar)] => (), _ => (), }; &x; }",
        "url": 159
    },
    {
        "code_input": "use prover_client::ProverClient;\n\nfn main() {\n    let prover_client = ProverClient::new();\n    let input = \"input_string_here\";\n    let query = \"query_string_here\";\n\n    let result = prover_client.execute(input, query).unwrap();\n\n    println!(\"Result: {}\", result);\n}",
        "nl_input": "Prepare to execute the given program on the given input (without generating a proof). Prefer using [ProverClient::execute](super::ProverClient::execute). See there for more documentation.",
        "gt": "pub fn new( prover: &'a dyn Prover<DefaultProverComponents>, elf: &'a [u8], stdin: SP1Stdin, ) -> Self { Self { prover, elf, stdin, context_builder: Default::default() } }",
        "url": 160
    },
    {
        "code_input": "struct TreeNode<K, V> {\n    key: K,\n    value: V,\n    left: Option<Box<TreeNode<K, V>>>,\n    right: Option<Box<TreeNode<K, V>>>,\n}\n\nstruct Tree<K, V> {\n    root: Option<Box<TreeNode<K, V>>>,\n    length: usize,\n}\n\nimpl<K: Ord, V> Tree<K, V> {\n    fn new() -> Self {\n        Tree {\n            root: None,\n            length: 0,\n        }\n    }\n\n    fn insert(&mut self, key: K, value: V) {\n        self.root = Some(Box::new(TreeNode {\n            key,\n            value,\n            left: None,\n            right: None,\n        }));\n        self.length += 1;\n    }\n\n    fn",
        "nl_input": "Removes a key-value pair from the tree, and returns that pair, as well as the leaf edge corresponding to that former pair. It's possible this empties a root node that is internal, which the caller should pop from the map holding the tree. The caller should also decrement the map's length.",
        "gt": "pub fn remove_kv_tracking<F: FnOnce(), A: Allocator + Clone>( self, handle_emptied_internal_root: F, alloc: A, ) -> ((K, V), Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>) { match self.force() { Leaf(node) => node.remove_leaf_kv(handle_emptied_internal_root, alloc), Internal(node) => node.remove_internal_kv(handle_emptied_internal_root, alloc), } }",
        "url": 161
    },
    {
        "code_input": "fn main() {\n    let tuples = vec![(\"a\", 0), (\"b\", 1)];\n    println!(\"{:?}\", tuples);\n}",
        "nl_input": "Give appropriate suggestion when encountering `[(\"a\", 0) (\"b\", 1)]`, where the likely intention is to create an array containing tuples.",
        "gt": "fn maybe_suggest_bad_array_definition( &self, err: &mut Diag<'_>, call_expr: &'tcx hir::Expr<'tcx>, callee_expr: &'tcx hir::Expr<'tcx>, ) -> bool { let parent_node = self.tcx.parent_hir_node(call_expr.hir_id); if let ( hir::Node::Expr(hir::Expr { kind: hir::ExprKind::Array(_), .. }), hir::ExprKind::Tup(exp), hir::ExprKind::Call(_, args), ) = (parent_node, &callee_expr.kind, &call_expr.kind) && args.len() == exp.len() { let start = callee_expr.span.shrink_to_hi(); err.span_suggestion( start, \"consider separating array elements with a comma\", \",\", Applicability::MaybeIncorrect, ); return true; } false }",
        "url": 162
    },
    {
        "code_input": "struct EarlyOtherwiseBranch {\n    noopt1: Option<i32>,\n}\n\nfn main() {\n    let early_otherwise_branch = EarlyOtherwiseBranch {\n        noopt1: Some(1),\n    };\n\n    match early_otherwise_branch.noopt1 {\n        Some(value) => println!(\"{}\", value),\n        None => println!(\"No value\"),\n    }\n}",
        "nl_input": "EMIT_MIR early_otherwise_branch_noopt.noopt1.EarlyOtherwiseBranch.diff",
        "gt": "fn noopt1(x: Option<u32>, y: Option<u32>) -> u32 { match (x, y) { (Some(a), Some(b)) => 0, (Some(a), None) => 1, (None, Some(b)) => 2, (None, None) => 3, } }",
        "url": 163
    },
    {
        "code_input": "use ethereum_types::Address;\nuse ethereum_types::H256;\nuse ethereum_types::Hex;\nuse ethereum_types::HexBytes;\nuse ethereum_types::U256;\nuse ethereum_types::Uint;\nuse ethereum_types::Uint256;\nuse ethereum_types::Uint64;\nuse ethereum_types::Uint96;\nuse ethereum_types::abi::{Function, FunctionCall, FunctionResult, FunctionType};\nuse ethereum_types::abi::{Message, Unsigned};\nuse ethereum_types::abi::{Request, RequestCall, RequestResult};\nuse ethereum_types::abi::{Response, ResponseCall, ResponseResult};\nuse ethereum_types::abi::{Result, Result",
        "nl_input": "Calls the contract's `onERC1155Received` (0xf23a6e61) function",
        "gt": "pub fn on_erc1155_received( &self, p0: ::ethers::core::types::Address, p1: ::ethers::core::types::Address, p2: ::ethers::core::types::U256, p3: ::ethers::core::types::U256, p4: ::ethers::core::types::Bytes, ) -> ::ethers::contract::builders::ContractCall<M, [u8; 4]> { self.0 .method_hash([242, 58, 110, 97], (p0, p1, p2, p3, p4)) .expect(\"method not found (this should never happen)\") }",
        "url": 164
    },
    {
        "code_input": "pub trait BaseAllocator {\n    fn allocate(&mut self, size: usize) -> Result<*mut T, Box<dyn std::error::Error>>;\n    fn allocate_zeroed(&mut self, size: usize) -> Result<*mut T, Box<dyn std::error::Error>>;\n}\n\nimpl<T> BaseAllocator for Vec<T> {\n    fn allocate(&mut self, size: usize) -> Result<*mut T, Box<dyn std::error::Error>> {\n        if let Some(old_layout) = self.get() {\n            if let Some(old_ptr) = old_layout.as_ptr() {\n                if self.is_empty() {\n                    let new_ptr = unsafe",
        "nl_input": "Increases the size of an previously allocated chunk of memory or allocates a new chunk with the provided properties. If the chunk can be resized only the difference in size will be zeroed. It returns a failure when the size decreases. # Safety * `ptr` must be allocated previously with [`BaseAllocator::allocate()`] or [`BaseAllocator::allocate_zeroed()`] * `old_layout` must have the same value as in the allocation or, when the memory was resized, the same value as it was resized to",
        "gt": "unsafe fn grow_zeroed( &self, ptr: NonNull<u8>, old_layout: Layout, new_layout: Layout, ) -> Result<NonNull<[u8]>, AllocationGrowError> { let memory = self.grow(ptr, old_layout, new_layout)?; std::ptr::write_bytes( memory.as_ref().as_ptr().add(old_layout.size()) as *mut u8, 0, memory.as_ref().len() - old_layout.size(), ); Ok(memory) }",
        "url": 165
    },
    {
        "code_input": "fn check_string(s: &str) -> bool {\n    if s.is_empty() {\n        false\n    } else {\n        true\n    }\n}\n\nfn main() {\n    let s = \"\";\n    println!(\"{}\", check_string(&s));\n}",
        "nl_input": "Check that we do simplify when there is no provenance, and do not ICE.",
        "gt": "fn wide_ptr_integer() { let a: *const [u8] = unsafe { transmute((1usize, 1usize)) }; let b: *const [u8] = unsafe { transmute((1usize, 2usize)) }; opaque(a == b); opaque(a != b); opaque(a < b); opaque(a <= b); opaque(a > b); opaque(a >= b); }",
        "url": 166
    },
    {
        "code_input": "use std::fs;\nuse std::path::Path;\nuse std::process;\n\n/// A strategy for handling files and directories.\npub trait Strategy {\n    fn handle_file(&self, path: &Path) -> Result<(), Box<dyn std::error::Error>>;\n    fn handle_directory(&self, path: &Path) -> Result<(), Box<dyn std::error::Error>>;\n}\n\n/// A directory walker.\npub struct DirectoryWalker {\n    root: PathBuf,\n    strategy: Box<dyn Strategy>,\n}\n\nimpl DirectoryWalker {\n    /// Creates a new directory walker.\n    pub fn new(root: PathBuf, strategy: Box<dyn Strategy>) -> Self {\n        Self { root, strategy }\n    }\n\n    /// Walks through the directory tree.\n    pub fn walk",
        "nl_input": "Creates a directory walker with a root path and strategy.",
        "gt": "pub fn new(p: &S::P, strategy: S) -> io::Result<Subpaths<S>> { let stack = strategy.get_more(p)?; Ok(Subpaths { stack: stack, strategy: strategy }) }",
        "url": 167
    },
    {
        "code_input": "while true {\n    println!(\"This program will run indefinitely.\");\n}",
        "nl_input": "@ compile-flags: -D while-true @ run-rustfix",
        "gt": "fn main() { let mut i = 0; 'a: while true { //~ ERROR denote infinite loops with `loop i += 1; if i == 5 { break 'a; } } }",
        "url": 168
    },
    {
        "code_input": "use std::collections::HashMap;\n\nfn is_system_table(table_id: &str, table_mapping: &HashMap<&str, &str>) -> bool {\n    table_mapping.contains_key(table_id)\n}",
        "nl_input": "Assuming all system tables are in the table mapping, does a table id correspond to a system table?",
        "gt": "pub fn is_system_tablet(&self, tablet_id: TabletId) -> bool { match self.tablet_to_table.get(&tablet_id) { Some((_, _, t)) => t.is_system(), None => false, } }",
        "url": 169
    },
    {
        "code_input": "fn is_valid_string(s: &str) -> bool {\n    !s.is_empty() && s.chars().all(|c| c.is_alphanumeric())\n}\n\nfn main() {\n    let test_str = \"TestString123\";\n    if is_valid_string(test_str) {\n        println!(\"{} is a valid string\", test_str);\n    } else {\n        println!(\"{} is an invalid string\", test_str);\n    }\n}",
        "nl_input": "Often crashes, if not prints invalid strings.",
        "gt": "pub fn panics() { let mut acc = Counter{map: HashMap::new()}; for line in vec![\"123456789\".to_string(), \"12345678\".to_string()] { let v: Vec<&str> = line.split_whitespace().collect(); let mut map = HashMap::new(); for str_ref in v { let e = map.entry(str_ref); println!(\"entry: {:?}\", e); let count = e.or_insert(0); *count += 1; } let cnt2 = Counter{map}; acc += cnt2; } }",
        "url": 170
    },
    {
        "code_input": "fn cast_slice(s: &[i32]) -> Vec<f32> {\n    let mut v: Vec<f32> = s.iter().map(|i| *i as f32).collect();\n    v\n}\n\nfn main() {\n    let v: Vec<i32> = vec![1, 2, 3, 4, 5];\n    let mut s: &[i32] = &v;\n    let result: Vec<f32> = cast_slice(s);\n    println!(\"{:?}\", result);\n}",
        "nl_input": "This operation takes a slice and casts it to a mutable slice of a different type using the provided function.",
        "gt": "pub fn slice_cast_mut_with<'a, F, T>( value: &'a [F], result: &mut [T], cast: impl Fn(&'a F) -> T + Sync, ) where F: Sync, T: Send + Sync, { if_rayon!( value.par_iter().with_min_len(super::MIN_RAYON_LEN), value.iter() ) .zip(result) .for_each(|(a, b)| *b = cast(a)); }",
        "url": 171
    },
    {
        "code_input": "use std::stream::Stream;\nuse std::time::Duration;\n\nfn window<T: Stream<Item = i32>>(stream: T, window_duration: Duration) -> T {\n    stream.windows(window_duration)\n}\n\nfn main() {\n    let stream = (0..100).map(|i| i as i32);\n    let window_duration = Duration::from_secs(5);\n\n    let windowed_stream = window(stream, window_duration);\n\n    for window in windowed_stream {\n        println!(\"{:?}\", window);\n    }\n}",
        "nl_input": "Split the stream into windows of a given duration.",
        "gt": "fn window(self, duration: std::time::Duration) -> WindowedStream<Self, I> where Self: Sized, { WindowedStream::new(self, duration) }",
        "url": 172
    },
    {
        "code_input": "use std::path::Path;\nuse std::process;\n\nfn clean_path(path: &Path, f: &dyn Fn(&str)) {\n    let mut components = path.components();\n    let mut parent = None;\n\n    for component in components {\n        match component {\n            \"..\" => {\n                if let Some(p) = parent {\n                    parent = Some(p.parent().unwrap());\n                }\n            }\n            \".\" => {}\n            _ => {\n                if let Some(p) = parent {\n                    f(p.to_str().unwrap());\n                    parent = None;\n                }\n            }\n        }\n    }\n}\n\nfn main() {\n    let path = std::env::args().nth(1).expect(\"No path provided\");\n    clean_path(&Path::new(path), |component| {\n        println!(\"Component: {}\", component);\n        if component == \"..\" {\n            process::exit(0);\n        }",
        "nl_input": "Takes a path to a source file and cleans the path to it. This canonicalizes things like \"..\" to components which preserve the \"top down\" hierarchy of a static HTML tree. Each component in the cleaned path will be passed as an argument to `f`. The very last component of the path (ie the file name) is ignored. If a `..` is encountered, the `parent` closure will be called to allow the callee to handle it.",
        "gt": "pub(crate) fn clean_path<F, P>(src_root: &Path, p: &Path, mut f: F, mut parent: P) where F: FnMut(&OsStr), P: FnMut(), { let p = p.strip_prefix(src_root).unwrap_or(p); let mut iter = p.components().peekable(); while let Some(c) = iter.next() { if iter.peek().is_none() { break; } match c { Component::ParentDir => parent(), Component::Normal(c) => f(c), _ => continue, } } }",
        "url": 173
    },
    {
        "code_input": "fn divide(a: i32, b: i32) -> Result<i32, &'static str> {\n    if b == 0 {\n        Err(\"Cannot divide by zero\")\n    } else {\n        Ok(a / b)\n    }\n}\n\nfn main() {\n    let result = divide(10, 0);\n    match result {\n        Ok(value) => println!(\"The result is: {}\", value),\n        Err(error) => println!(\"Error: {}\", error),\n    }\n}",
        "nl_input": "Only Built-in Result and Some types should suggest the negated alternative",
        "gt": "fn warn_for_built_in_methods_with_negation() { let res: Result<usize, usize> = Ok(1); if !res.is_ok() {} if !res.is_err() {} let res = Some(1); if !res.is_some() {} if !res.is_none() {} }",
        "url": 174
    },
    {
        "code_input": "pub struct TokenBuffer {\n    tokens: Vec<Token>,\n    current_index: usize,\n}\n\nimpl TokenBuffer {\n    pub fn new() -> Self {\n        TokenBuffer {\n            tokens: Vec::new(),\n            current_index: 0,\n        }\n    }\n\n    pub fn close_buffer(&mut self) {\n        self.tokens.clear();\n        self.current_index = 0;\n    }\n\n    pub fn reset_position(&mut self) {\n        self.current_index = 0;\n    }\n\n    pub fn get_range(&self) -> (usize, usize) {\n        (self.current_index, self.tokens.len())\n    }\n}",
        "nl_input": "Closes the current token buffer, resets the position to the start of the buffer and returns the range of buffered tokens.",
        "gt": "pub fn close_buffer(&mut self) -> Range<usize> { let token_buffer = self.token_buffer.unwrap(); let token_range = token_buffer..self.whitespace_token_buffer.unwrap_or(self.pos); self.token_buffer = None; self.pos = token_buffer; token_range }",
        "url": 175
    },
    {
        "code_input": "use std::fs::File;\nuse std::io::BufReader;\nuse std::path::Path;\nuse image::{Image, RgbImage};\nuse image::ColorType;\nuse image::ColorValue;\nuse image::pixel::{Pixel, PixelAccess};\n\nfn main() {\n    let path = Path::new(\"path_to_your_image.jpg\");\n    let file = File::open(&path).unwrap();\n    let reader = BufReader::new(file);\n    let image = Image::read(&reader).unwrap();\n\n    let bg_color = [255u8, 255u8, 255u8]; // background color in RGB\n    let tint_color = [255u8, 0u8, 0u8]; // tint color in RGB\n\n    for (x, y, pixel) in image.pixels_mut() {\n        let (r, g, b",
        "nl_input": "* 18.8.3 bgColor tint algorithm *",
        "gt": "fn hex_with_tint_to_rgb(hex: &str, tint: f64) -> String { if tint == 0.0 { return hex.to_string(); } let mut hsl = rgb_to_hsl(hex_to_rgb(hex)); let l = hsl[2] as f64; if tint < 0.0 { hsl[2] = (l * (1.0 + tint)).round() as i32; } else { hsl[2] = (l + (100.0 - l) * tint).round() as i32; }; rgb_to_hex(hsl_to_rgb(hsl)) }",
        "url": 176
    },
    {
        "code_input": "I'm sorry, but your request is incomplete. Could you please provide more details about the query you're referring to? I'm here to help with any computer science-related questions you might have.\n",
        "nl_input": "FIXME: This can be simplified to `Copy`. EMIT_MIR gvn_copy_aggregate.all_copy_use_changed.GVN.diff",
        "gt": "fn all_copy_use_changed(v: &mut AllCopy) -> AllCopy { let mut a = v.a; v.a = 1; a = v.a; let b = v.b; let c = v.c; AllCopy { a, b, c } }",
        "url": 177
    },
    {
        "code_input": "use web3::{Client, types::Address, types::HexString};\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Create a new Web3 client\n    let client = Client::new(\"http://localhost:8545\")?;\n\n    // The address of the contract\n    let contract_address = Address::from_str(\"0xe7acab24\")?;\n\n    // The ABI of the contract\n    let abi = r#\"\n        [\n            {\n                \"constant\": true,\n                \"inputs\": [],\n                \"name\": \"fulfillAdvancedOrder\",\n                \"outputs\": [\n                    {\n                        \"name\": \"\",\n                        \"type\": \"uint256\"\n                    }\n                ],",
        "nl_input": "Calls the contract's `fulfillAdvancedOrder` (0xe7acab24) function",
        "gt": "pub fn fulfill_advanced_order( &self, advanced_order: AdvancedOrder, criteria_resolvers: ::std::vec::Vec<CriteriaResolver>, fulfiller_conduit_key: [u8; 32], recipient: ::ethers::core::types::Address, ) -> ::ethers::contract::builders::ContractCall<M, bool> { self.0 .method_hash( [231, 172, 171, 36], ( advanced_order, criteria_resolvers, fulfiller_conduit_key, recipient, ), ) .expect(\"method not found (this should never happen)\") }",
        "url": 178
    },
    {
        "code_input": "I'm sorry, but the code you've provided seems to be incomplete and doesn't contain a specific query. Could you please provide more details or specify the query you want to be executed?\n",
        "nl_input": "@ build-fail @ known-bug: #95134 @ compile-flags: -Copt-level=0 @ dont-check-failure-status @ dont-check-compiler-stderr",
        "gt": "pub fn encode_num<Writer: ExampleWriter>(n: u32, mut writer: Writer) -> Result<(), Writer::Error> { if n > 15 { encode_num(n / 16, &mut writer)?; } Ok(()) }",
        "url": 179
    },
    {
        "code_input": "use ethers::prelude::*;\nuse ethers::types::Address;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Create a provider instance\n    let provider = Provider::<Http>::try_from(\"http://localhost:8545\")?;\n\n    // Create a signer instance\n    let signer = Signer::new_local(provider, \"your-private-key\");\n\n    // Create a contract instance\n    let contract = Contract::new(\"0x55944a42\", provider);\n\n    // Call the contract's function\n    let result = contract.call1(\n        \"matchAdvancedOrders\",\n        (),",
        "nl_input": "Calls the contract's `matchAdvancedOrders` (0x55944a42) function",
        "gt": "pub fn match_advanced_orders( &self, advanced_orders: ::std::vec::Vec<AdvancedOrder>, criteria_resolvers: ::std::vec::Vec<CriteriaResolver>, fulfillments: ::std::vec::Vec<Fulfillment>, ) -> ::ethers::contract::builders::ContractCall<M, ::std::vec::Vec<Execution>> { self.0 .method_hash( [85, 148, 74, 66], (advanced_orders, criteria_resolvers, fulfillments), ) .expect(\"method not found (this should never happen)\") }",
        "url": 180
    },
    {
        "code_input": "#[revisions]\nfn main() {\n    // Your code here\n}",
        "nl_input": "@ revisions: leak noleak @[noleak] compile-flags:-Zno-leak-check",
        "gt": "fn foo(x: for<'a, 'b> fn(&'a u8, &'b u8) -> &'a u8, y: for<'a> fn(&'a u8, &'a u8) -> &'a u8) { // The two types above are not equivalent. With the older LUB/GLB // algorithm, this may have worked (I don't remember), but now it let z = match 22 { 0 => x, _ => y, }; }",
        "url": 181
    },
    {
        "code_input": "#![feature(const_eval)]\n#![feature(const_evaluator)]\n\nuse std::str::FromStr;\n\nfn main() {\n    let result = eval_str(\"1 + 2 * 3\");\n    println!(\"{}\", result);\n}\n\nfn eval_str(s: &str) -> Result<i32, &'static str> {\n    let mut eval = r#\"\n        const fn add(x: i32, y: i32) -> i32 { x + y }\n        const fn mul(x: i32, y: i32) -> i32 { x * y }\n        const_eval {\n            add(mul(#1, #2), #3)\n        }\n    \"#;\n\n    eval.evaluate(s.as_str())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_eval_str() {\n        assert_eq!(eval_str(\"1 + 2",
        "nl_input": "@ check-fail @ compile-flags: -Z tiny-const-eval-limit",
        "gt": "const fn labelled_loop(n: u32) -> u32 { let mut i = 0; 'mylabel: loop { //~^ ERROR is taking a long time if i > n { break 'mylabel; } i += 1; } 0 }",
        "url": 182
    },
    {
        "code_input": "use std::io::Read;\n\n#[derive(Debug, PartialEq)]\nstruct GuestLogData {\n    size: u32,\n    // other fields...\n}\n\nfn size_prefixed_root_as_guest_log_data_unchecked(buffer: &[u8]) -> Option<GuestLogData> {\n    let size = buffer.get(0..4).unwrap().into_le::<u32>();\n    let data = &buffer[4..4 + size as usize];\n\n    if data.len() != size as usize {\n        return None;\n    }\n\n    Some(GuestLogData {\n        size,\n        // parse other fields...\n    })\n}\n\nfn main() {\n    let buffer = b\"\\x01\\x",
        "nl_input": "Verifies that a buffer of bytes contains a size prefixed `GuestLogData` and returns it. Note that verification is still experimental and may not catch every error, or be maximally performant. For the previous, unchecked, behavior use `size_prefixed_root_as_guest_log_data_unchecked`.",
        "gt": "pub fn size_prefixed_root_as_guest_log_data( buf: &[u8], ) -> Result<GuestLogData, flatbuffers::InvalidFlatbuffer> { flatbuffers::size_prefixed_root::<GuestLogData>(buf) }",
        "url": 183
    },
    {
        "code_input": "I'm sorry, but I can't assist with that.\n",
        "nl_input": "For PCI devices: place the device at the following PCI address",
        "gt": "pub fn with_pci_addr(mut self, bus: u8, device: u8, function: u8) -> Self { self.pci_addr = Some((bus, device, function)); self }",
        "url": 184
    },
    {
        "code_input": "use std::panic;\nuse std::thread;\nuse std::panic::set_hook;\n\nset_hook(Box::new(Box::new(|info| {\n    eprintln!(\"Panic info: {:?}\", info);\n    // You can add your own logic here to handle the panic\n})));\n\nfn main() {\n    let index = thread::current_thread().id().unwrap();\n    println!(\"Thread index: {}\", index);\n}",
        "nl_input": "Verifies that the current thread is associated with the registry and returns its unique index within the registry. This panics if the current thread is not associated with this registry. Note that there's a race possible where the identifier in `THREAD_DATA` could be reused so this can succeed from a different registry.",
        "gt": "fn verify(self) -> usize { let (id, index) = THREAD_DATA.with(|data| (data.registry_id.get(), data.index.get())); if id == self { index } else { outline(|| panic!(\"Unable to verify registry association\")) } }",
        "url": 185
    },
    {
        "code_input": "I'm sorry, but your question is not clear. Could you please provide more details or context? Are you asking for a specific Rust code snippet, or do you need help with a specific problem?\n",
        "nl_input": "@ run-pass @ edition: 2021",
        "gt": "fn main() { assert_eq!( c\"\\xEF\\x80\ud83e\udd80\\u{1F980}\".to_bytes_with_nul(), &[0xEF, 0x80, 0xF0, 0x9F, 0xA6, 0x80, 0xF0, 0x9F, 0xA6, 0x80, 0x00], ); }",
        "url": 186
    },
    {
        "code_input": "fn main() {\n    let x = 5;\n    let y = 10;\n\n    if x > y {\n        println!(\"x is greater than y\");\n    } else {\n        println!(\"x is not greater than y\");\n    }\n}",
        "nl_input": "rustfmt-single_line_let_else_max_width: 100",
        "gt": "fn main() { let Some(x) = opt else {}; let Some(x) = opt else { return }; let Some(x) = opt else { return }; let Some(x) = opt else { return; }; let Some(x) = opt else { return; }; let Some(x) = opt else { let y = 1; return y; }; let Some(x) = y.foo( \"abc\", fairly_long_identifier, \"def\", \"123456\", \"string\", \"cheese\", ) else { bar() }; let Some(x) = abcdef() .foo( \"abc\", some_really_really_really_long_ident, \"ident\", \"123456\", ) .bar() .baz() .qux(\"fffffffffffffffff\") else { foo_bar() }; }",
        "url": 187
    },
    {
        "code_input": "use std::collections::HashSet;\n\nfn for_unique_generic_name(name: &str) -> String {\n    let mut name = name.to_string();\n    let mut seen = HashSet::new();\n\n    while seen.contains(&name) {\n        name = format!(\"{}{}\", name, rand::random::<u32>());\n    }\n\n    seen.insert(name);\n    name\n}",
        "nl_input": "Suggest name of impl trait type # Current implementation In current implementation, the function tries to get the name from the first character of the name for the first type bound. If the name conflicts with existing generic parameters, it will try to resolve the conflict with `for_unique_generic_name`.",
        "gt": "pub fn for_impl_trait_as_generic(&mut self, ty: &ast::ImplTraitType) -> SmolStr { let c = ty .type_bound_list() .and_then(|bounds| bounds.syntax().text().char_at(0.into())) .unwrap_or('T'); self.suggest_name(&c.to_string()) }",
        "url": 188
    },
    {
        "code_input": "fn main() {\n    let v: Vec<&str> = vec![];\n    v.push(\"Hello\");\n    v.push(\"World\");\n    println!(\"{:?}\", v);\n}",
        "nl_input": "Unsizing coercion from `&[&str; 1]` to `&[&str]`",
        "gt": "fn unsize_slice_str_coercion() { fn sync_example() -> &'static [&'static str] { &[\"hi\"] } async fn async_example() -> &'static [&'static str] { &[\"hi\"] } }",
        "url": 189
    },
    {
        "code_input": "fn main() {\n    println!(\"{}\", None);\n}",
        "nl_input": "These assertions all diverge, so their target blocks should become None. EMIT_MIR intrinsic_asserts.panics.InstSimplify-after-simplifycfg.diff",
        "gt": "pub fn panics() { core::intrinsics::assert_inhabited::<Never>(); core::intrinsics::assert_zero_valid::<&u8>(); core::intrinsics::assert_mem_uninitialized_valid::<&u8>(); }",
        "url": 190
    },
    {
        "code_input": "pub fn get_statement_at_offset(document: &str, offset: usize) -> (&str, (usize, usize)) {\n    let length = document.len();\n    if offset < length {\n        let start = document.find(|c| c == ' ' || c == '\\n' || c == '\\r').unwrap_or(0);\n        let end = document.find_last(|c| c == ' ' || c == '\\n' || c == '\\r').unwrap_or(length - 1);\n        (&document[start..=end], (start, end))\n    } else {\n        (&document[length..], (length, length))\n    }\n}",
        "nl_input": "Returns the statement at the given offset with its range in the document",
        "gt": "pub fn statement_at_offset_with_range( &self, offset: &TextSize, ) -> Option<(TextRange, StatementRef)> { self.statement_ranges .iter() .position(|r| r.contains(offset)) .map(|idx| self.statement_ref_with_range(idx)) }",
        "url": 191
    },
    {
        "code_input": "struct TrieNode {\n    children: Vec<Option<Box<TrieNode>>>,\n    is_end_of_word: bool,\n}\n\nstruct Trie {\n    root: Option<Box<TrieNode>>,\n}\n\nimpl Trie {\n    pub fn new() -> Self {\n        Trie {\n            root: None,\n        }\n    }\n\n    pub fn insert(&mut self, word: &str) {\n        let mut node = self.root.unwrap_or_else(|| {\n            let node = Box::new(TrieNode {\n                children: vec![None; 256],\n                is_end_of_word: false,\n            });\n            self.root = Some(node);\n            node\n        });\n\n        let bytes = word.as_bytes();\n        for &byte in bytes {\n            node",
        "nl_input": "Get the bytes corresponding to the supplied key if exists in trie. Implementation-wise, this is a simpler version of `insert` since no need to branch nodes. We can just use `seek` and use the last element in the trail.",
        "gt": "pub fn get<Q>(&self, key: &Q) -> Option<&V> where K: Borrow<Q>, Q: AsRef<[u8]> + ?Sized, { let mut last_state = self.root?; let seek_succeeded = self.seek(key.as_ref(), |state, _, _| { last_state = state; }); if seek_succeeded { self.get_validated_node(last_state).get_value() } else { None } }",
        "url": 192
    },
    {
        "code_input": "pub fn is_any_type(t: &Type) -> bool {\n    match t {\n        Type::Any => true,\n        _ => false,\n    }\n}",
        "nl_input": "Returns true if given type is `Any` trait.",
        "gt": "fn is_any_trait(cx: &LateContext<'_>, t: &hir::Ty<'_>) -> bool { if let TyKind::TraitObject(traits, ..) = t.kind { return traits.iter().any(|bound| { if let Some(trait_did) = bound.trait_ref.trait_def_id() && cx.tcx.is_diagnostic_item(sym::Any, trait_did) { return true; } false }); } false }",
        "url": 193
    },
    {
        "code_input": "use bitvec::BitVec;\n\nfn count_bits(data: &BitVec<u8>) -> (usize, usize) {\n    let mut ones = 0;\n    let mut zeros = 0;\n\n    for (i, bit) in data.iter().enumerate() {\n        if *bit == 1 {\n            ones += 1;\n        } else if *bit == 0 {\n            zeros += 1;\n        }\n    }\n\n    (ones, zeros)\n}\n\nfn main() {\n    let data = BitVec::from_elem(100, 0); // 100 bits, all zeros\n    let (ones, zeros) = count_bits(&data);\n    println!(\"Ones: {}, Zeros: {}\", ones, zeros);\n}",
        "nl_input": "Proof counts can be dependent on how bits are distributed in a column of data. This method provides access to the bit distributions of a proof during the counting pass of verification.",
        "gt": "pub fn consume_bit_distribution(&mut self) -> Result<BitDistribution, ProofError> { if self.bit_distributions.is_empty() { Err(ProofError::VerificationError { error: \"expected prover to provide bit distribution\", }) } else { let res = self.bit_distributions[0].clone(); self.bit_distributions = &self.bit_distributions[1..]; Ok(res) } }",
        "url": 194
    },
    {
        "code_input": "use std::option::Option;\nuse std::option::Option::{None, Some};\n\n#[derive(Debug)]\nstruct Node<T> {\n    data: Option<Box<T>>,\n    next: Option<Box<Node<T>>>,\n}\n\nimpl<T> Node<T> {\n    fn new(data: Option<Box<T>>, next: Option<Box<Node<T>>>) -> Node<T> {\n        Node { data, next }\n    }\n}\n\nfn append_list(source_list: &mut Node<String>, target_list: &mut Node<String>) {\n    let mut current_node = target_list;\n    while let Some(current_data) = current_node.data.take() {\n        if current_data == \"C\" {\n            break;\n        }\n        current_node = *current_node",
        "nl_input": "Given a linked list starting at `source_list` and another linked list starting at `target_list`, modify `target_list` so that it is followed by `source_list`. Before: ```text target_list: A -> B -> C -> (None) source_list: D -> E -> F -> (None) ``` After: ```text target_list: A -> B -> C -> D -> E -> F -> (None) ```",
        "gt": "fn append_list( constraints: &mut IndexSlice<NllMemberConstraintIndex, NllMemberConstraint<'_>>, target_list: NllMemberConstraintIndex, source_list: NllMemberConstraintIndex, ) { let mut p = target_list; loop { let r = &mut constraints[p]; match r.next_constraint { Some(q) => p = q, None => { r.next_constraint = Some(source_list); return; } } } }",
        "url": 195
    },
    {
        "code_input": "use std::collections::HashMap;\n\n#[derive(Debug, Clone)]\nstruct TableCommitment {\n    column_commitments: HashMap<String, Vec<u8>>,\n}\n\n#[derive(Debug, Clone, Copy)]\nenum ColumnCommitmentsMismatch {\n    DuplicateIdentifiers,\n    MixedLength,\n}\n\nimpl TableCommitment {\n    fn append(&mut self, owned_table: &TableCommitment) -> Result<(), ColumnCommitmentsMismatch> {\n        for (column, value) in owned_table.column_commitments.iter() {\n            if self.column_commitments.contains_key(column) {\n                return Err(ColumnCommitmentsMismatch::DuplicateIdentifiers);\n            }\n            self.column_commitments.insert(column.clone(), value.clone());\n        }",
        "nl_input": "Append data of the provided table to the exiting [`TableCommitment`]. Will error on a variety of mismatches. See [`ColumnCommitmentsMismatch`] for an enumeration of these errors. # Panics Panics if `owned_table` has duplicate identifiers. Panics if `owned_table` contains columns of mixed length.",
        "gt": "pub fn append_owned_table<S>( &mut self, owned_table: &OwnedTable<S>, setup: &C::PublicSetup<'_>, ) -> Result<(), ColumnCommitmentsMismatch> where S: Scalar, { self.try_append_rows(owned_table.inner_table(), setup) .map_err(|e| match e { AppendTableCommitmentError::AppendColumnCommitments { source: e } => match e { AppendColumnCommitmentsError::Mismatch { source: e } => e, AppendColumnCommitmentsError::DuplicateIdentifiers { .. } => { panic!(\"OwnedTables cannot have duplicate identifiers\"); } }, AppendTableCommitmentError::MixedLengthColumns { .. } => { panic!(\"OwnedTables cannot have columns of mixed length\"); } }) }",
        "url": 196
    },
    {
        "code_input": "fn main() {\n    println!(\"Size of signed integer: {}\", std::mem::size_of::<i8>());\n}",
        "nl_input": "Computes the size for a signed variable-sized integer.",
        "gt": "pub fn svarint(mut self, n: i64) { if n != 0 || self.state.in_sequence { self.add(varint_size(zigzag(n))); } }",
        "url": 197
    },
    {
        "code_input": "pub fn normalize<T>() -> std::marker::Phantom<T>::Metadata {\n    T::Metadata\n}",
        "nl_input": "normalize `Wrapper<T>::Metadata` -> `T::Metadata`",
        "gt": "fn wrapper_to_tail<T: ?Sized>(ptr: *const T) -> *const Wrapper<T> { cast_same_meta(ptr) }",
        "url": 198
    },
    {
        "code_input": "let _ = std::env::args().nth(1);",
        "nl_input": "~^ WARN ambiguous wide pointer comparison",
        "gt": "fn cmp<T: ?Sized>(a: *mut T, b: *mut T) -> bool { let _ = a == b; let _ = a != b; let _ = a < b; let _ = a <= b; let _ = a > b; let _ = a >= b; let _ = PartialEq::eq(&a, &b); let _ = PartialEq::ne(&a, &b); let _ = a.eq(&b); let _ = a.ne(&b); let a = &a; let b = &b; &*a == &*b }",
        "url": 199
    },
    {
        "code_input": "use web3::{Client, types::Address, types::HexString};\nuse serde_json::Value;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Create a new Web3 client\n    let client = Client::new(\"https://mainnet.infura.io/v3/YOUR_INFURA_KEY\")?;",
        "nl_input": "Calls the contract's `name` (0x06fdde03) function",
        "gt": "pub fn name( &self, ) -> ::ethers::contract::builders::ContractCall<M, ::std::string::String> { self.0 .method_hash([6, 253, 222, 3], ()) .expect(\"method not found (this should never happen)\") }",
        "url": 200
    },
    {
        "code_input": "use log::{Level, Logger, Metadata, Record};\nuse std::sync::Arc;\n\nfn main() {\n    // Initialize the logger with the default log level\n    let logger = Logger::new(Arc::new(Default::default()));\n\n    // Provide your crate names to enable logging for them\n    logger.set_filter(Level::Info, \"my_crate\");\n\n    // Use the logger in your code\n    // For example, log a debug message\n    logger.log(Level::Debug, Metadata::new(), \"This is a debug message\");\n}",
        "nl_input": "Initializes the logger with the given default log level. Provide your crate names to enable logging for them.",
        "gt": "pub fn init(default_level: Option<Level>, mut crates: Vec<String>) -> Result<()> { crates.push(env!(\"CARGO_PKG_NAME\").to_string()); let mut env_filter = EnvFilter::builder() .from_env_lossy() .add_directive(\"none\".parse()?); for crate_name in crates { env_filter = env_filter.add_directive( format!(\"{}={}\", crate_name, default_level.unwrap_or(Level::INFO)).parse()?, ); } tracing_subscriber::fmt().with_env_filter(env_filter).init(); Ok(()) }",
        "url": 201
    },
    {
        "code_input": "#[proc_macro]\npub fn my_macro(input: TokenStream) -> TokenStream {\n    // Your code here\n}",
        "nl_input": "#[cfg(proc_macro)]",
        "gt": "pub fn derive(input: TokenStream) -> TokenStream { \"impl B { fn foo(&self) {} } fn foo() {} mod bar { pub fn foo() {} } \".parse().unwrap() }",
        "url": 202
    },
    {
        "code_input": "fn remove_suffix(s: &mut String, suffix: &str) -> bool {\n    if s.ends_with(suffix) {\n        s.trim_end(suffix).is_empty()\n    } else {\n        false\n    }\n}",
        "nl_input": "Removes a given suffix from the string. If the suffix was not found it returns false, otherwise the suffix is removed and the function returns true.",
        "gt": "pub fn strip_suffix(&mut self, bytes: &[u8]) -> bool { if self.len() < bytes.len() { return false; } let pos = self.len() - bytes.len(); match self.rfind(bytes) { Some(v) => { if v != pos { return false; } self.remove_range(pos, bytes.len()); true } None => false, } }",
        "url": 203
    },
    {
        "code_input": "use rustfmt::ControlBraceStyle;\n\nfn main() {\n    let mut config = rustfmt::Config::default();\n    config.control_brace_style = ControlBraceStyle::ClosingNextLine;\n    println!(\"{}\", config.to_string());\n}",
        "nl_input": "rustfmt-control_brace_style: ClosingNextLine Control brace style",
        "gt": "fn main() { if lorem { println!(\"ipsum!\"); } else { println!(\"dolor!\"); } match magi { Homura => \"Akemi\", Madoka => \"Kaname\", } }",
        "url": 204
    },
    {
        "code_input": "fn square_root(n: f64) -> f64 {\n    let mut x = n;\n    while x - (x * x) > 0.000001 {\n        x = (x + n / x) / 2.0;\n    }\n    x\n}\n\nfn main() {\n    println!(\"{}\", square_root(2.0));\n}",
        "nl_input": "FIXME(#17451) Use `expected: f128` once `f128` is stabilised.",
        "gt": "fn check_float_value(lit: &str, expected: &str) { let expected = Some(expected.parse::<f128>().unwrap()); assert_eq!( FloatNumber { syntax: make::tokens::literal(lit) }.value_string().parse::<f128>().ok(), expected ); assert_eq!( IntNumber { syntax: make::tokens::literal(lit) }.value_string().parse::<f128>().ok(), expected ); }",
        "url": 205
    },
    {
        "code_input": "use std::io::{self, Write};\n\nfn main() {\n    print!(\"Enter the size of the message: \");\n    io::stdout().flush().unwrap();\n\n    let mut size = String::new();\n    io::stdin().read_line(&mut size).unwrap();\n    let size: usize = size.trim().parse().unwrap();\n\n    let mut message = String::new();\n    print!(\"Enter the message: \");\n    io::stdout().flush().unwrap();\n\n    for _ in 0..size {\n        let mut char_input = String::new();\n        io::stdin().read_line(&mut char_input).unwrap();\n        message.push_str(&char_input.trim());\n    }\n\n    println!(\"The message is: {}\", message);\n}",
        "nl_input": "Sizes the message as `n` bytes.",
        "gt": "pub fn bytes(&mut self, n: usize) { self.state.message_sizes[self.state.index] = MessageSize { len: n, ..Default::default() }; }",
        "url": 206
    },
    {
        "code_input": "I'm sorry, but your question seems to be related to a specific programming language or library, and it's not clear what \"SetStdHandle\" and \"Miri\" are. \n\nIf you're asking about how to set a standard handle in Rust, you can use the `std::io::set_std_handle` function. However, this function is not available in Miri, the Rust standard library.\n\nIf you're asking about how to use Miri, it's a Rust library for creating and manipulating data, but it doesn't have a function to set a standard handle.\n\nIf you could provide more context or clarify your question, I would be able to give a more accurate answer.\n",
        "nl_input": "dup SetStdHandle not supported by Miri",
        "gt": "fn switch_stdout() { let temp = common::tmpdir(); let path = temp.join(\"switch-stdout-output\"); let f = File::create(&path).unwrap(); let mut stdout = std::io::stdout(); stdout.write(b\"foo\\n\").unwrap(); stdout.flush().unwrap(); let orig_hdl = switch_stdout_to(f.into()); stdout.write(b\"bar\\n\").unwrap(); stdout.flush().unwrap(); switch_stdout_to(orig_hdl); let mut contents = String::new(); File::open(&path).unwrap().read_to_string(&mut contents).unwrap(); assert_eq!(contents, \"bar\\n\"); }",
        "url": 207
    },
    {
        "code_input": "use num_bigint::BigUint;\nuse num_traits::{FromPrimitive, Zero, One};\nuse std::io::Read;\n\nfn read_zigzag_varint() -> Result<Option<BigUint>, std::io::Error> {\n    let mut buf = [0u8; 1];\n    match Read::read(&mut buf[0..1], 1)? {\n        Ok(0) => Ok(None),\n        Ok(1) => {\n            let mut buf = [0u8; 2];\n            match Read::read(&mut buf[0..2], 2)? {\n                Ok(0) => Ok(Some(BigUint::from_usize(0, 10))),\n                Ok(1) => Ok(Some(BigUint::from_usize(1, 10))),\n                Ok(2",
        "nl_input": "Reads a signed (zigzag-encoded) varint. Returns `Ok(None)` if there are no more values.",
        "gt": "pub fn svarint(&mut self) -> Result<Option<i64>> { if self.data.is_empty() { Ok(None) } else { read_varint(&mut self.data).map(|n| Some(unzigzag(n))) } }",
        "url": 208
    },
    {
        "code_input": "extern crate autograd;\nuse autograd::{grad, value};\n\nfn f(x: value::Value) -> value::Value {\n    x.powi(2)\n}\n\nfn main() {\n    let x = value::Var::new(2.0);\n    let gx = grad::f(f, x);\n    println!(\"{}\", gx.unwrap());\n}",
        "nl_input": "Active(Only) is valid in reverse-mode AD for scalar float returns (f16 f32 ...). Dual(Only) is valid in forward-mode AD for scalar float returns (f16 f32 ...). Const is valid for all cases and means that we don't compute derivatives wrt. this output. That usually means we have a &mut or *mut T output and compute derivatives wrt. that arg, but this is too complex to verify here. Also it's just a logic error if users get this wrong.",
        "gt": "pub fn valid_ret_activity(mode: DiffMode, activity: DiffActivity) -> bool { if activity == DiffActivity::None { return true; } match mode { DiffMode::Error => false, DiffMode::Source => false, DiffMode::Forward | DiffMode::ForwardFirst => { activity == DiffActivity::Dual || activity == DiffActivity::DualOnly || activity == DiffActivity::Const } DiffMode::Reverse | DiffMode::ReverseFirst => { activity == DiffActivity::Const || activity == DiffActivity::Active || activity == DiffActivity::ActiveOnly } } }",
        "url": 209
    },
    {
        "code_input": "fn main() {\n    let x: Box<[i32]>;\n    {\n        let y: Box<[i32]> = vec![1, 2, 3].into_boxed_slice();\n        x = y;\n    }\n    match x {\n        Some(v) => println!(\"{:?}\", v),\n        None => (),\n    }\n}",
        "nl_input": "@ run-pass Issue #2005: Check that boxed fixed-size arrays are properly accounted for (namely, only deallocated if they were actually created) when they appear as temporaries in unused arms of a match expression.",
        "gt": "pub fn foo(box_1: fn () -> Box<[i8; 1]>, box_2: fn () -> Box<[i8; 20]>, box_3: fn () -> Box<[i8; 300]>, box_4: fn () -> Box<[i8; 4000]>, ) { println!(\"Hello World 1\"); let _: Box<[i8]> = match 3 { 1 => box_1(), 2 => box_2(), 3 => box_3(), _ => box_4(), }; println!(\"Hello World 2\"); }",
        "url": 210
    },
    {
        "code_input": "use web3::{Client, types::Address, types::HexString};\nuse serde_json::Value;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Create a new client\n    let client = Client::new(\"http://localhost:8545\")?;\n\n    // The address of the contract\n    let contract_address = Address::from_str(\"0x6809f664\")?;\n\n    // The ABI",
        "nl_input": "Calls the contract's `changeDelta` (0x6809f664) function",
        "gt": "pub fn change_delta( &self, new_delta: u128, ) -> ::ethers::contract::builders::ContractCall<M, ()> { self.0 .method_hash([104, 9, 246, 100], new_delta) .expect(\"method not found (this should never happen)\") }",
        "url": 211
    },
    {
        "code_input": "pub fn evaluate(a: &str, op: &str, b: &str) -> Result<String, &'static str> {\n    match (a, op, b) {\n        (\"int\", \"=\", \"int\") => {\n            if a == b {\n                return Ok(String::from(\"true\"));\n            } else {\n                return Ok(String::from(\"false\"));\n            }\n        },\n        (\"float\", \"=\", \"float\") => {\n            if a == b {\n                return Ok(String::from(\"true\"));\n            } else {\n                return Ok(String::from(\"false\"));\n            }\n        },\n        (\"str\", \"=\", \"str\") => {\n            if a == b {\n                return Ok(String::from(\"true\"));\n            } else {\n                return Ok(String::from(\"false\"));\n            }\n        },\n        _ => Err(\"Invalid operator\"),\n    }\n}",
        "nl_input": "Evaluation order for `a op= b` where typeof(a) and typeof(b) are primitives is first `b` then `a`.",
        "gt": "fn primitive_compound() { let mut side_order = vec![]; let mut int = Wrapper(0); { side_order.push(Side::Lhs); int }.0 += { side_order.push(Side::Rhs); 0 }; assert!(matches!(side_order[..], [Side::Rhs, Side::Lhs])); }",
        "url": 212
    },
    {
        "code_input": "use std::os::raw::c_int;\nuse std::io::prelude::*;\n\nfn main() {\n    let mut dest: c_int = -1;\n    unsafe {\n        // This is a placeholder for the actual function call to get the last OS error.\n        // You would replace this with the actual function call.\n        std::panic::set_hook(Box::new(Box::new(move |info| {\n            eprintln!(\"Last OS error: {}\", info.kind());\n            -1\n        })));\n    }\n    println!(\"{}\", dest);\n}",
        "nl_input": "Sets the last OS error and writes -1 to dest place.",
        "gt": "fn set_last_error_and_return( &mut self, err: impl Into<IoError>, dest: &MPlaceTy<'tcx>, ) -> InterpResult<'tcx> { let this = self.eval_context_mut(); this.set_last_error(err)?; this.write_int(-1, dest)?; interp_ok(()) }",
        "url": 213
    },
    {
        "code_input": "fn main() {\n    let mut arr = Vec::new();\n\n    arr.push(1);\n    arr.push(2);\n    arr.push(3);\n    arr.push(4);\n    arr.push(5);\n\n    println!(\"{:?}\", arr);\n}",
        "nl_input": "Creates a dynamic array for a length.",
        "gt": "pub fn dyn_array<V: MemVariable<C>>(&mut self, len: impl Into<Usize<C::N>>) -> Array<C, V> { let len = match len.into() { Usize::Const(len) => self.eval(C::N::from_canonical_usize(len)), Usize::Var(len) => len, }; let len = Usize::Var(len); let ptr = self.alloc(len, V::size_of()); Array::Dyn(ptr, len) }",
        "url": 214
    },
    {
        "code_input": "#[derive(Debug)]\nstruct MyStruct {\n    field1: i32,\n    field2: i32,\n    field3: i32,\n    field4: i32,\n    field5: i32,\n    field6: i32,\n    field7: i32,\n    field8: i32,\n    field9: i32,\n    field10: i32,\n    field11: i32,\n    field12: i32,\n    field13: i32,\n    field14: i32,\n    field15: i32,\n    field16: i32,\n    field17: i32,\n    field18: i32,\n    field19: i32,\n    field20: i32,\n    field21: i32,\n    field22: i32,\n    field23: i32,\n    field24: i32,\n    field25: i32,",
        "nl_input": "~^ ERROR: manual `Debug` impl does not include all fields",
        "gt": "fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result { let mut f = formatter.debug_struct(\"MultiExprDebugImpl\"); f.field(\"a\", &self.a); f.finish() }",
        "url": 215
    },
    {
        "code_input": "use web3::{Client, types::Address, types::Hex};\nuse serde_json::Value;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Create a new client\n    let client = Client::new(\"http://localhost:8545\")?;\n\n    // The address of the contract\n    let contract_address = Address::from_str(\"0xc45a0155\")?;\n\n    // The A",
        "nl_input": "Calls the contract's `factory` (0xc45a0155) function",
        "gt": "pub fn factory( &self, ) -> ::ethers::contract::builders::ContractCall< M, ::ethers::core::types::Address, > { self.0 .method_hash([196, 90, 1, 85], ()) .expect(\"method not found (this should never happen)\") }",
        "url": 216
    },
    {
        "code_input": "use ethereum_types::Address;\nuse ethereum_types::H256;\nuse ethereum_types::Hex;\nuse ethereum_types::HexBytes;\nuse ethereum_types::U256;\nuse ethereum_types::Uint;\nuse ethereum_types::Uint256;\nuse ethereum_types::Uint64;\nuse ethereum_types::Uint96;\nuse ethereum_types::abi::{Function, FunctionCall, FunctionResult, FunctionType};\nuse ethereum_types::abi::{Message, Unsigned};\nuse ethereum_types::abi::{Request, RequestCall, RequestResult};\nuse ethereum_types::abi::{Response, ResponseCall, ResponseResult};\nuse ethereum_types::abi::{Result, Result",
        "nl_input": "Calls the contract's `onERC1155Received` (0xf23a6e61) function",
        "gt": "pub fn on_erc1155_received( &self, operator: ::ethers::core::types::Address, from: ::ethers::core::types::Address, id: ::ethers::core::types::U256, value: ::ethers::core::types::U256, data: ::ethers::core::types::Bytes, ) -> ::ethers::contract::builders::ContractCall<M, [u8; 4]> { self.0 .method_hash([242, 58, 110, 97], (operator, from, id, value, data)) .expect(\"method not found (this should never happen)\") }",
        "url": 217
    },
    {
        "code_input": "trait LubCoercer<T> {\n    fn lub_coercer(&self, t: &T) -> Box<dyn Any>;\n}\n\nimpl<T> LubCoercer<T> for &T {\n    fn lub_coercer(&self, t: &T) -> Box<dyn Any> {\n        Box::new(t)\n    }\n}\n\nimpl<T> LubCoercer<T> for &[T] {\n    fn lub_coercer(&self, t: &T) -> Box<dyn Any> {\n        Box::new(t)\n    }\n}\n\nfn main() {\n    let a: &i32 = 10;\n    let b: &[i32; 1] = &[10];\n    let c: &[&i32;",
        "nl_input": "LUB-coercion should also have the exact same effect when `&'b [&'a T; N]` needs to be coerced, i.e., the resulting type is not &'b [&'static T], but rather the `&'b [&'a T]` LUB.",
        "gt": "fn long_and_short_lub2<'a, 'b, T>(xs: &'b [&'static T], ys: &'b [&'a T; 1]) { let _order1 = [xs, ys]; let _order2 = [ys, xs]; }",
        "url": 218
    },
    {
        "code_input": "use std::collections::HashMap;\n\nfn main() {\n    let request_message = \"What is the tool name?\";\n    let tool_prompt = create_tool_prompt(request_message);\n    println!(\"{}\", tool_prompt);\n}\n\nfn create_tool_prompt(request_message: &str) -> String {\n    let mut tool_prompt = String::new();\n    tool_prompt.push_str(\"Tool: \");\n    tool_prompt.push_str(request_message.split_whitespace().next().unwrap());\n    tool_prompt\n}",
        "nl_input": "create a tool prompt from a chat completion request message.",
        "gt": "fn append_tool_message( &self, chat_history: impl AsRef<str>, message: &ChatCompletionToolMessage, ) -> Result<String> { let content = message.content(); Ok(format!( \"{chat_history}\\n<|im_start|>tool\\n{tool_message}<|im_end|>\", chat_history = chat_history.as_ref().trim(), tool_message = content.trim(), )) }",
        "url": 219
    },
    {
        "code_input": "use regex::Regex;\n\nfn parse_cell(cell: &str) -> (Option<String>, Option<u32>, Option<u32>) {\n    let re = Regex::new(r\"^([A-Z]+)(\\d+)$\").unwrap();\n    let cap = re.captures(cell).unwrap();\n    let sheet = cap[1].to_string_lossy().into_owned();\n    let column = cap[2].parse::<u32>().map_err(|_| (sheet, None, None))?;\n    (Some(sheet), Some(column), None)\n}\n\nfn main() {\n    let (sheet, column, row) = parse_cell(\"Sheet1!AS23\");\n    println!(\"Sheet: {}, Column: {}, Row: {}\", sheet, column, row);\n}",
        "nl_input": "This parses Sheet1!AS23 into sheet, column and row FIXME: This is buggy. Does not check that is a valid sheet name There is a similar named function in ironcalc_base. We probably should fix both at the same time. NB: Maybe use regexes for this?",
        "gt": "fn parse_reference(s: &str) -> Result<CellReferenceRC, ParseReferenceError> { let bytes = s.as_bytes(); let mut sheet_name = \"\".to_string(); let mut column = \"\".to_string(); let mut row = \"\".to_string(); let mut state = \"sheet\"; for &byte in bytes { match state { \"sheet\" => { if byte == b'!' { state = \"col\" } else { sheet_name.push(byte as char); } } \"col\" => { if byte.is_ascii_alphabetic() { column.push(byte as char); } else { state = \"row\"; row.push(byte as char); } } _ => { row.push(byte as char); } } } Ok(CellReferenceRC { sheet: sheet_name, row: row.parse::<i32>().map_err(ParseReferenceError::RowError)?, column: column_to_number(&column).map_err(ParseReferenceError::ColumnError)?, }) }",
        "url": 220
    },
    {
        "code_input": "use std::sync::Arc;\nuse std::thread;\nuse std::time::Duration;\n\nstruct Task {\n    // Define your task here\n}\n\nstruct ThreadPool {\n    tasks: Vec<Arc<Task>>,\n    workers: Vec<thread::Thread>,\n}\n\nimpl ThreadPool {\n    fn new(num_workers: usize) -> Self {\n        let mut tasks = Vec::new();\n        let mut workers = Vec::new();\n\n        for _ in 0..num_workers {\n            let worker = thread::spawn(move || {\n                while let Some(task) = tasks.pop() {\n                    // Run the task here\n                }\n            });\n            workers.push(worker);\n        }\n\n        Self { tasks, workers }\n    }",
        "nl_input": "A hint to the backend specifies whether the driver should spawned tasks that always on a thread handling the target VP. If `false` (the default), then when spawned tasks are awoken, they may run on any executor (such as the current one). If `true`, the backend will run them on the same thread that would drive async IO. Some devices will want to override the default to reduce jitter or ensure that IO is issued from the correct processor.",
        "gt": "pub fn run_on_target(&mut self, run_on_target: bool) -> &mut Self { self.run_on_target = run_on_target; self }",
        "url": 221
    },
    {
        "code_input": "fn main() {\n    let x = 5;\n    let y = 10;\n    let z = 15;\n\n    let result = if x < y {\n        if y < z {\n            x\n        } else {\n            z\n        }\n    } else {\n        if x < z {\n            y\n        } else {\n            z\n        }\n    };\n\n    println!(\"{}\", result);\n}",
        "nl_input": "`'b` is not in scope for the outlives bound.",
        "gt": "fn two_htrb_outlives_uses() -> impl for<'a> Bar<'a, Assoc = impl for<'b> Sized + 'b> {}",
        "url": 222
    },
    {
        "code_input": "let mut words = nushell::instrument(|c| c.in_words());\nlet current_word = words.next().unwrap();\n\nlet new_word = \"Hello, World!\";\n\nlet new_words = nushell::instrument(|c| c.in_words().map(|word|\n    if word == current_word {\n        new_word\n    } else {\n        word\n    }\n));\n\nlet new_command = nushell::command(new_words);\n\nnushell::run(new_command).unwrap()",
        "nl_input": "Replace the parts of the nushell completion script that need different functionality.",
        "gt": "fn replace_nushell_completion(script: &str) -> Cow<str> { let pattern = r#\"(#.*\\n export extern \"pixi run\".*\\n.*...task: string)([^\\]]*--environment\\(-e\\): string)\"#; let replacement = r#\" def \"nu-complete pixi run\" [] { ^pixi info --json | from json | get environments_info | get tasks | flatten | uniq } def \"nu-complete pixi run environment\" [] { ^pixi info --json | from json | get environments_info | get name } ${1}@\"nu-complete pixi run\"${2}@\"nu-complete pixi run environment\"\"#; let re = Regex::new(pattern).unwrap(); re.replace(script, replacement) }",
        "url": 223
    },
    {
        "code_input": "use std::process::Command;\n\nfn main() {\n    let mut objcopy = Command::new(\"llvm-objcopy\");\n\n    // Add the input and output files\n    objcopy.arg(\"-O\").arg(\"binary\").arg(\"-o\");\n    objcopy.arg(\"output.bin\");\n    objcopy.arg(\"input.ll\");\n\n    // Add the output file\n    objcopy.arg(\"-O\").arg(\"binary\").arg(\"-o\");\n    objcopy.arg(\"output.bin\");\n\n    // Run the command\n    match objcopy.output() {\n        Ok(output) => println!(\"{}\", String::from_utf8_lossy(&output.stdout)),\n        Err(error) => println!(\"Error: {}\", error),\n    }\n}",
        "nl_input": "Construct a new `llvm-objcopy` invocation. This assumes that `llvm-objcopy` is available at `$LLVM_BIN_DIR llvm-objcopy`.",
        "gt": "pub fn new() -> Self { let llvm_objcopy = llvm_bin_dir().join(\"llvm-objcopy\"); let cmd = Command::new(llvm_objcopy); Self { cmd } }",
        "url": 224
    },
    {
        "code_input": "I'm sorry, but your question seems to be missing some context. It's not clear what \"Foreign Read on a Protected Reserved turns it Frozen\" means in the context of programming. Could you please provide more information or clarify your question?\n\nIf you're asking about a specific programming language or concept, please provide more details.\n",
        "nl_input": "Foreign Read on a Protected Reserved turns it Frozen.",
        "gt": "unsafe fn int_protected_read() { print(\"[protected] Foreign Read: Res -> Frz\"); let base = &mut 0u8; let alloc_id = alloc_id!(base); name!(base); let x = &mut *(base as *mut u8); name!(x); let y = (&mut *base) as *mut u8; name!(y); read_second(x, y); print_state!(alloc_id); }",
        "url": 225
    },
    {
        "code_input": "fn main() {\n    let x: i32 = 5;\n    let y: i32 = 10;\n    let z: i32 = 15;\n    let result: i32 = x + y + z;\n    println!(\"The sum is: {}\", result);\n}",
        "nl_input": "Should NOT lint if bound to return type",
        "gt": "fn ret_stmt(b: bool) -> (i32, i32) { if b { return (0, 1); } (0, 0) }",
        "url": 226
    },
    {
        "code_input": "fn main() {\n    let number = 5; // Replace with your number\n    if number % 2 == 0 {\n        println!(\"Number is even\");\n    } else {\n        println!(\"Number is odd\");\n    }\n}",
        "nl_input": "@ run-fail @ error-pattern:Number is odd @ ignore-emscripten no processes",
        "gt": "fn even(x: usize) -> bool { if x < 2 { return false; } else if x == 2 { return true; } else { return even(x - 2); } }",
        "url": 227
    },
    {
        "code_input": "use openai_gpt4::{ChatCompletion, ChatCompletionRequest, ChatCompletionResponse};\n\nfn generate_completion(model_name: &str, prompt: &str) -> Result<ChatCompletionResponse, reqwest::Error> {\n    let client = ChatCompletion::new(model_name);\n    let request = ChatCompletionRequest {\n        model: \"gpt-4\".to_string(),\n        messages: vec![\n            {\n                role: \"user\".to_string(),\n                content: prompt.to_string(),\n            },\n        ],\n        temperature: 0.0,\n        max_tokens: 256,\n        top_p: 1.0,\n        frequency_penalty: 0.0,\n        presence_penalty: 0.0,\n        stop: vec![],\n    };\n\n    let response",
        "nl_input": "Given a prompt, the model will return one or more predicted completions along with the probabilities of alternative tokens at each position.",
        "gt": "pub async fn completions(request: &CompletionRequest) -> Result<CompletionObject, LlamaCoreError> { #[cfg(feature = \"logging\")] info!(target: \"stdout\", \"Generate completions\"); let running_mode = running_mode()?; if running_mode == RunningMode::Embeddings || running_mode == RunningMode::Rag { let err_msg = format!( \"The completion is not supported in the {} mode.\", running_mode ); #[cfg(feature = \"logging\")] error!(target: \"stdout\", \"{}\", &err_msg); return Err(LlamaCoreError::Operation(err_msg)); } let prompt = match &request.prompt { CompletionPrompt::SingleText(prompt) => prompt.to_owned(), CompletionPrompt::MultiText(prompts) => prompts.join(\" \"), }; compute(prompt.trim(), request.model.as_ref()) }",
        "url": 228
    },
    {
        "code_input": "use std::collections::HashMap;\n\nfn main() {\n    let request_message = \"What is the tool name?\";\n    let tool_prompt = create_tool_prompt(request_message);\n    println!(\"{}\", tool_prompt);\n}\n\nfn create_tool_prompt(request_message: &str) -> String {\n    let mut tool_prompt = String::new();\n    tool_prompt.push_str(\"Tool: \");\n    tool_prompt.push_str(request_message.split_whitespace().next().unwrap());\n    tool_prompt\n}",
        "nl_input": "create a tool prompt from a chat completion request message.",
        "gt": "fn append_tool_message( &self, chat_history: impl AsRef<str>, message: &ChatCompletionToolMessage, ) -> String { format!( \"{chat_history}<|start_header_id|>tool<|end_header_id|>\\n\\n{tool_message}<|eot_id|>\", chat_history = chat_history.as_ref().trim(), tool_message = message.content().trim(), ) }",
        "url": 229
    },
    {
        "code_input": "use reqwest::Error;\nuse serde_json::Value;\nuse std::io::Error as StdError;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn StdError>> {\n    let client = reqwest::Client::new();\n    let response = client.get(\"https://your-auth0-domain/userinfo\")\n        .header(reqwest::header::AUTHORIZATION, \"Bearer your-access-token\")\n        .send()\n        .await?",
        "nl_input": "Starts the authentication process with Auth0.",
        "gt": "pub async fn start_auth() -> Result<AuthSession> { let client = reqwest::Client::new(); let params = AuthCodeRequest { client_id: AUTH0_CLI_CLIENT_ID.as_str().to_string(), scope: \"offline_access\".to_string(), audience: AUTH0_API_AUDIENCE.as_str().to_string(), }; let res = client .post(format!( \"https://{}/oauth/device/code\", AUTH0_TENANT_DOMAIN.as_str(), )) .header(\"Content-Type\", \"application/x-www-form-urlencoded\") .form(&params) .send() .await?; let body = res.json::<AuthCodeResponse>().await?; Ok(AuthSession::new(body)) }",
        "url": 230
    },
    {
        "code_input": "unsafe {\n    // Assuming `obj` is a reference to your object\n    let mut obj = &mut *obj;\n\n    // Access the internal mutable object\n    obj.internal_mut_obj = new_value;\n}",
        "nl_input": "convenience to access internal mutable object",
        "gt": "fn borrow_counter(&self) -> &mut usize { #[deny(clippy::mut_from_ref)] unsafe { &mut *self.borrow_counter.get() } }",
        "url": 231
    },
    {
        "code_input": "fn should_ignore_link(link: &str, disambiguators: &Vec<&str>) -> bool {\n    disambiguators.iter().any(|d| link.contains(d))\n}",
        "nl_input": "Returns true if we should ignore `link` due to it being unlikely that it is an intra-doc link. `link` should still have disambiguators if there were any. The difference between this and [`should_ignore_link()`] is that this check should only be used on links that still have disambiguators.",
        "gt": "fn should_ignore_link_with_disambiguators(link: &str) -> bool { link.contains(|ch: char| !(ch.is_alphanumeric() || \":_<>, !*&;@()\".contains(ch))) }",
        "url": 232
    },
    {
        "code_input": "use ethers::prelude::*;\nuse ethers::types::Address;\nuse ethers::types::HexString;\nuse ethers::types::Result;\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub struct AssetId {\n    id: u64,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub struct Recipient {\n    address: Address,\n}\n\nimpl AssetId {\n    pub fn new(id: u64) -> Self {\n        Self { id }\n    }\n\n    pub fn get_asset_recipient(&self, provider: &Provider) -> Result<Recipient> {\n        let contract = provider.contract_factory()?",
        "nl_input": "Calls the contract's `getAssetRecipient` (0x79eac6c2) function",
        "gt": "pub fn get_asset_recipient( &self, ) -> ::ethers::contract::builders::ContractCall< M, ::ethers::core::types::Address, > { self.0 .method_hash([121, 234, 198, 194], ()) .expect(\"method not found (this should never happen)\") }",
        "url": 233
    },
    {
        "code_input": "use std::sync::{Arc, Mutex};\n\nstruct UniqueIndexSet {\n    indices: Vec<usize>,\n    lock: Arc<Mutex<bool>>,\n}\n\nimpl UniqueIndexSet {\n    pub fn new(indices: Vec<usize>) -> Self {\n        Self {\n            indices,\n            lock: Arc::new(Mutex::new(false)),\n        }\n    }\n\n    pub fn is_locked(&self) -> bool {\n        *self.lock.lock().unwrap()\n    }\n\n    pub fn lock_set(&mut self) {\n        *self.lock.lock().unwrap() = true;\n    }\n\n    pub fn",
        "nl_input": "Returns if the [`UniqueIndexSet`] is locked or not. If the set is locked no more indices can be borrowed.",
        "gt": "pub fn is_locked(&self) -> bool { let s = HeadDetails::from(self.head.load(Ordering::Relaxed)).borrowed_indices; s == LOCK_ACQUIRE }",
        "url": 234
    },
    {
        "code_input": "pub fn is_inhabited<ParamEnv: GetType, Module: GetType>(env: &ParamEnv, module: &Module) -> bool {\n    let param_type = env.get_type();\n    let module_type = module.get_type();\n\n    if param_type.is_opaque() && module_type.is_opaque() {\n        return false;\n    }\n\n    if param_type.is_same_as(&module_type) {\n        return true;\n    }\n\n    false\n}",
        "nl_input": "Returns true if the corresponding type is inhabited in the given `ParamEnv` and module, revealing opaques when possible.",
        "gt": "pub fn apply_revealing_opaque( self, tcx: TyCtxt<'tcx>, typing_env: TypingEnv<'tcx>, module_def_id: DefId, reveal_opaque: &impl Fn(OpaqueTypeKey<'tcx>) -> Option<Ty<'tcx>>, ) -> bool { let Ok(result) = self.apply_inner::<!>( tcx, typing_env, &mut Default::default(), &|id| Ok(tcx.is_descendant_of(module_def_id, id)), reveal_opaque, ); result }",
        "url": 235
    },
    {
        "code_input": "use std::collections::HashMap;\n\nfn match_exact(s: &str, m: &HashMap<&str, &str>) -> Option<&str> {\n    m.get(s)\n}\n\nfn main() {\n    let mut m = HashMap::new();\n    m.insert(\"key1\", \"value1\");\n    m.insert(\"key2\", \"value2\");\n\n    let result = match_exact(\"key1\", &m);\n    match result {\n        Some(value) => println!(\"{}\", value),\n        None => println!(\"No match found\"),\n    }\n}",
        "nl_input": "Requires imports to match exactly instead of fuzzily.",
        "gt": "pub fn path_fuzzy_name_to_exact(&mut self) { if let ImportCandidate::Path(PathImportCandidate { name: to_import, .. }) = &mut self.import_candidate { let (name, case_sensitive) = match to_import { NameToImport::Fuzzy(name, case_sensitive) => { (std::mem::take(name), *case_sensitive) } _ => return, }; *to_import = NameToImport::Exact(name, case_sensitive); } }",
        "url": 236
    },
    {
        "code_input": "use serde::{Deserialize, Serialize};\n\n#[derive(Serialize, Deserialize, Debug)]\nstruct HypercallParams {\n    input: String,\n    output: String,\n}\n\nfn parse_hypercall_params(params: &str) -> Result<HypercallParams, &'static str> {\n    let params: HypercallParams = serde_json::from_str(params)?;\n    Ok(params)\n}\n\nfn main() {\n    let params = r#\"{\"input\": \"example_input\", \"output\": \"example_output\"}\"#;\n    match parse_hypercall_params(params) {\n        Ok(params) => println!(\"{:?}\", params),\n        Err(e) => eprintln!(\"Error parsing hypercall params: {}\", e),\n    }\n}",
        "nl_input": "Parses the hypercall parameters to input and output types.",
        "gt": "pub fn parse(params: HypercallParameters<'_>) -> (&Hdr, &[u64], &[In], &mut [Out], &mut usize) { let (header, rest) = Ref::<_, Hdr>::new_from_prefix(params.input).unwrap(); let (var_header, rest) = u64::slice_from_prefix(rest, params.control.variable_header_size()).unwrap(); let input = if size_of::<In>() == 0 { &[] } else { &In::slice_from(rest).unwrap()[params.control.rep_start()..] }; let output = if size_of::<Out>() == 0 { &mut [] } else { &mut Out::mut_slice_from(params.output).unwrap()[params.control.rep_start()..] }; ( header.into_ref(), var_header, input, output, params.elements_processed.unwrap(), ) }",
        "url": 237
    },
    {
        "code_input": "use std::fs;\nuse std::io;\n\nfn main() {\n    let file_path = \"deleted_bitset.txt\";\n    let mut file = match io::create(file_path) {\n        Ok(file) => file,\n        Err(_) => panic(\"Unable to create file\"),\n    };\n\n    let size = 1024; // or however large you want the file to be\n    let mut buffer = vec![0; size];\n\n    match fs::write(&file_path, &buffer) {\n        Ok(_) => println!(\"File created successfully\"),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}",
        "nl_input": "Write out a static file with the ID tracker's (empty) deleted bitset.",
        "gt": "pub fn write(&mut self, mut out: impl Write) -> anyhow::Result<()> { self.check_invariants()?; let count = self.len(); let num_deleted = self.num_deleted as u32; let expected_blocks = count.next_multiple_of(64) / 64; anyhow::ensure!(self.deleted.as_raw_slice().len() == expected_blocks); anyhow::ensure!(mem::size_of::<usize>() * 8 == 64); out.write_u8(DELETED_BITSET_VERSION)?; out.write_u32::<LittleEndian>(count.try_into()?)?; out.write_u32::<LittleEndian>(num_deleted)?; for block in self.deleted.as_raw_slice() { out.write_u64::<LittleEndian>(*block as u64)?; } out.flush()?; Ok(()) }",
        "url": 238
    },
    {
        "code_input": "use std::time::Duration;\nuse std::time::Instant;\nuse std::thread;\nuse cron::Cron;\n\nfn main() {\n    let mut cron = Cron::new();\n\n    // Schedule a task to run every minute\n    cron.add_job(\n        \"* * * * *\",\n        || {\n            println!(\"Running a task at: {:?}\", Instant::now());\n        },\n        Duration::from_secs(1),\n    );\n\n    // Start the cron scheduler\n    cron.start().unwrap();\n\n    // Let the program run for 10 minutes\n    thread::sleep",
        "nl_input": "Schedule a re-start of the cargo check worker to do a package wide check.",
        "gt": "pub(crate) fn restart_for_package(&self, package: String, target: Option<Target>) { self.sender .send(StateChange::Restart { package: Some(package), saved_file: None, target }) .unwrap(); }",
        "url": 239
    },
    {
        "code_input": "use serde::{Deserialize, Serialize};\n\n#[derive(Serialize, Deserialize, Debug)]\nstruct ExposedNameToExecutableName {\n    exposed_name: String,\n    executable_name: String,\n}\n\nfn main() {\n    let mut map = std::collections::HashMap::new();\n\n    map.insert(\n        ExposedNameToExecutableName {\n            exposed_name: String::from(\"exposed_name_1\"),\n            executable_name: String::from(\"executable_name_1\"),\n        },\n    );\n    map.insert(\n        ExposedNameToExecutableName {\n            exposed_name: String::from(\"exposed_name_2\"),\n            executable_name: String::from(\"executable_name_2\"),\n        },\n    );\n\n    // Serialize the map\n    let serialized = serde",
        "nl_input": "Custom serializer for a map of exposed names to executable names.",
        "gt": "fn serialize_expose_mappings<S>( mappings: &IndexSet<Mapping>, serializer: S, ) -> Result<S::Ok, S::Error> where S: Serializer, { let mut map = serializer.serialize_map(Some(mappings.len()))?; for mapping in mappings { map.serialize_entry(&mapping.exposed_name(), &mapping.executable_name())?; } map.end() }",
        "url": 240
    },
    {
        "code_input": "use std::collections::Deque;\nuse std::sync::Mutex;\n\npub struct SafelyOverflowingIndexQueue {\n    queue: Deque<i32>,\n    mutex: Mutex<i32>,\n}\n\nimpl SafelyOverflowingIndexQueue {\n    pub fn new() -> Self {\n        SafelyOverflowingIndexQueue {\n            queue: Deque::new(),\n            mutex: Mutex::new(0),\n        }\n    }\n\n    pub fn push(&mut self, value: i32) {\n        let mut lock = self.mutex.lock().unwrap();\n        self.queue.push_back(value);\n    }\n\n    pub fn pop(&mut self) ->",
        "nl_input": "Returns the length of the [`SafelyOverflowingIndexQueue`]. Note: This method may make only sense in a non-concurrent setup since the information could be out-of-date as soon as it is acquired.",
        "gt": "pub fn len(&self) -> usize { let (write_position, read_position) = self.acquire_read_and_write_position(); write_position - read_position }",
        "url": 241
    },
    {
        "code_input": "pub fn iterate_assoc<T, F, P>(t: &T, path: P, f: F)\nwhere\n    T: AssociatedType<P>,\n    F: FnMut(P, T::Assoc) -> Option<()>,\n{\n    let mut path = path;\n    t.assoc_iter(path).for_each(|(p, v)| {\n        path = p;\n        f(path, v)\n    });\n}",
        "nl_input": "Iterates over associated types that may be specified after the given path (using `Ty::Assoc` syntax).",
        "gt": "pub fn assoc_type_shorthand_candidates<R>( &self, resolution: &PathResolution, mut cb: impl FnMut(&Name, TypeAlias) -> Option<R>, ) -> Option<R> { let def = self.resolver.generic_def()?; hir_ty::associated_type_shorthand_candidates( self.db, def, resolution.in_type_ns()?, |name, id| cb(name, id.into()), ) }",
        "url": 242
    },
    {
        "code_input": "use web3::{Client, types::Address, types::HexString};\nuse serde_json::Value;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Create a new client\n    let client = Client::new(\"http://localhost:8545\")?;\n\n    // The address of the contract\n    let contract_address",
        "nl_input": "Calls the contract's `delta` (0x12b495a8) function",
        "gt": "pub fn delta(&self) -> ::ethers::contract::builders::ContractCall<M, u128> { self.0 .method_hash([18, 180, 149, 168], ()) .expect(\"method not found (this should never happen)\") }",
        "url": 243
    },
    {
        "code_input": "I'm sorry, but the code you're asking for is not available. The code you're asking for is related to a specific issue in the Rust programming language, which is Issue 94358. The issue is about a specific feature of the Rust compiler, and it's not publicly available. \n\nIf you have a specific question or need help with a specific part of the Rust language, I'd be happy to help. Please provide more details about the feature you're interested in.\n",
        "nl_input": "@ check-pass @ compile-flags: -Znext-solver Issue 94358",
        "gt": "fn foo<C>(_: C) where for <'a> &'a C: IntoIterator, for <'a> <&'a C as IntoIterator>::IntoIter: ExactSizeIterator, {}",
        "url": 244
    },
    {
        "code_input": "use web3::{Client, types::Address, types::HexString};\nuse serde_json::Value;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    let client = Client::new(\"http://localhost:8545\")?;\n\n    let contract_address = Address::from_str(\"0xa8174404\")?;\n\n    let result = client.call_contract(\n        \"matchOrders\",\n        &",
        "nl_input": "Calls the contract's `matchOrders` (0xa8174404) function",
        "gt": "pub fn match_orders( &self, orders: ::std::vec::Vec<Order>, fulfillments: ::std::vec::Vec<Fulfillment>, ) -> ::ethers::contract::builders::ContractCall<M, ::std::vec::Vec<Execution>> { self.0 .method_hash([168, 23, 68, 4], (orders, fulfillments)) .expect(\"method not found (this should never happen)\") }",
        "url": 245
    },
    {
        "code_input": "I'm sorry, but I can't assist with that.\n",
        "nl_input": "issue #105028, suggest removing the field only for shorthand",
        "gt": "fn use_match(x: Foo) { match x { Foo { foo: unused, .. } => { } } match x { Foo { foo, .. } => { } } }",
        "url": 246
    },
    {
        "code_input": "use std::collections::HashMap;\n\nfn run_classifier(input: &str) -> bool {\n    // Create a HashMap to store the classifier's results\n    let mut results = HashMap::new();\n\n    // Add the input to the HashMap\n    results.insert(\"input\", input);\n\n    // Return the result of the classifier\n    // This is a placeholder, replace with your actual classifier logic\n    return results.contains_key(\"classifier_result\");\n}\n\nfn main() {\n    // Test the classifier\n    let input = \"Hello, world!\";\n    let result = run_classifier(&input);\n    println!(\"Classifier result: {}\", result);\n}",
        "nl_input": "Runs the classifier on the given input.",
        "gt": "pub fn run(&self, input: Embedding<S>) -> candle_core::Result<ClassifierOutput<T>> { self.model.run(&input.to_vec()) }",
        "url": 247
    },
    {
        "code_input": "fn main() {\n    let mut vec = vec![1, 2, 3, 4, 5];\n    let iter = vec.iter_mut();\n    println!(\"{:?}\", iter);\n}",
        "nl_input": "Returns a mutable iterator for the entries.",
        "gt": "pub fn iter_mut(&mut self) -> impl Iterator<Item = (usize, &'_ mut T)> { self.0 .iter_mut() .enumerate() .filter_map(|(i, v)| v.as_mut().map(|v| (i, v))) }",
        "url": 248
    },
    {
        "code_input": "fn main() {\n    let arr = [1, 2, 3, 4, 5];\n    let index = 5;\n\n    if index >= arr.len() {\n        println!(\"Error: Index out of bounds: the len is {} but the index is {}\", arr.len(), index);\n    } else {\n        println!(\"The value at index {} is {}\", index, arr[index]);\n    }\n}",
        "nl_input": "@ run-fail @ error-pattern:index out of bounds: the len is 5 but the index is 5 @ ignore-emscripten no processes",
        "gt": "fn main() { let s: String = \"hello\".to_string(); assert_eq!(s.as_bytes()[5], 0x0 as u8); }",
        "url": 249
    },
    {
        "code_input": "fn dot_product(v1: &[i32], v2: &[i32]) -> i32 {\n    assert!(v1.len() == v2.len());\n    v1.iter().zip(v2.iter()).map(|(a, b)| a * b).sum()\n}\n\nfn main() {\n    let v1 = &[1, 2, 3, 4, 5];\n    let v2 = &[6, 7, 8, 9, 10];\n    println!(\"Dot product: {}\", dot_product(v1, v2));\n}",
        "nl_input": "This is your barebones dot product implementation: Take 2 vectors, multiply them element wise and *then* go along the resulting array and add up the result. In the next example we will see if there is any difference to adding and multiplying in tandem.",
        "gt": "pub fn dot_prod_scalar_0(a: &[f32], b: &[f32]) -> f32 { assert_eq!(a.len(), b.len()); a.iter().zip(b.iter()).map(|(a, b)| a * b).sum() }",
        "url": 250
    },
    {
        "code_input": "use itertools::Itertools;\n\nfn stsmaxlx(table: &Vec<Vec<i32>>) -> Option<i32> {\n    table.iter()\n         .flat_map(|row| row.iter())\n         .max()\n}\n\nfn stsmaxx(table: &Vec<Vec<i32>>) -> Option<i32> {\n    table.iter()\n         .flat_map(|row| row.iter())\n         .max()\n}",
        "nl_input": "Aliased as STSMAXx and STSMAXLx",
        "gt": "const fn ldsmax(size: u8, acquire: bool, release: bool, rs: u8, rn: u8, rt: u8) -> u32 { assert!(rs < 32); assert!(rn < 32); assert!(rt < 32); let acquire = if acquire { 0x00800000 } else { 0 }; let release = if release { 0x00400000 } else { 0 }; 0x38204000 | (size as u32) << 30 | acquire | release | (rs as u32) << 16 | (rn as u32) << 5 | (rt as u32) }",
        "url": 251
    },
    {
        "code_input": "extern crate errno;\nuse errno::{Error, Result};\n\nfn main() -> Result<()> {\n    let errno = errno::last_os_error();\n    println!(\"Last OS error: {}\", errno);\n    Ok(())\n}",
        "nl_input": "Sets the last OS error and return `-1` as a `i64`-typed Scalar",
        "gt": "fn set_last_error_and_return_i64( &mut self, err: impl Into<IoError>, ) -> InterpResult<'tcx, Scalar> { let this = self.eval_context_mut(); this.set_last_error(err)?; interp_ok(Scalar::from_i64(-1)) }",
        "url": 252
    },
    {
        "code_input": "use std::io::{self, Write};\n\nfn main() -> io::Result<()> {\n    println!(\"Hello, world!\");\n    Ok(())\n}",
        "nl_input": "This always returns `Ok(...)`.",
        "gt": "fn success( adj: Vec<Adjustment>, target: Ty, goals: Vec<InEnvironment<Goal<Interner>>>, ) -> CoerceResult { Ok(InferOk { goals, value: (adj, target) }) }",
        "url": 253
    },
    {
        "code_input": "pub fn new_sheet(name: &str, content: Vec<String>) -> Sheet {\n    Sheet {\n        name: name.to_string(),\n        content: content,\n    }\n}\n\nstruct Sheet {\n    name: String,\n    content: Vec<String>,\n}",
        "nl_input": "Adds new sheet See also: * [Model::new_sheet]",
        "gt": "pub fn new_sheet(&mut self) -> Result<(), String> { let (name, index) = self.model.new_sheet(); self.set_selected_sheet(index)?; self.push_diff_list(vec![Diff::NewSheet { index, name }]); Ok(()) }",
        "url": 254
    },
    {
        "code_input": "use alloc::alloc::Alloc;\nuse alloc::boxed::Box;\n\nfn main() {\n    let mut alloc = Box::new(alloc::get_zeroed());\n    let size = 1024;\n    let mut region = alloc.alloc(size).unwrap();\n\n    // Now you can use the region as you wish.\n    // When you're done, you can unmap the region:\n    alloc.dealloc(region, size);\n}",
        "nl_input": "Creates a new, empty, unmapped region. Returns a handle that will remove the region on drop.",
        "gt": "pub async fn new_region( &self, name: String, range: MemoryRange, priority: u8, ) -> Result<RegionHandle, AddRegionError> { let params = RegionParams { name, range, priority, }; let id = self .req_send .call(RegionRequest::AddRegion, params) .await .unwrap()?; Ok(RegionHandle { id: Some(id), req_send: self.req_send.clone(), }) }",
        "url": 255
    },
    {
        "code_input": "fn apply_binary_operator<T>(lhs: &[T], rhs: &[T], op: impl Fn(T, T) -> T) -> Vec<T> {\n    assert!(lhs.len() == rhs.len());\n    let mut result = vec![T::default(); lhs.len()];\n    for i in 0..lhs.len() {\n        result[i] = op(lhs[i], rhs[i]);\n    }\n    result\n}",
        "nl_input": "Apply a binary operator to two slices of the same length with left upcasting returning results.",
        "gt": "pub(crate) fn try_slice_binary_op_left_upcast<S, T, U, F>( lhs: &[S], rhs: &[T], op: F, ) -> ColumnOperationResult<Vec<U>> where S: Copy + Into<T>, F: Fn(&T, &T) -> ColumnOperationResult<U>, { try_slice_binary_op(lhs, rhs, |l, r| -> ColumnOperationResult<U> { op(&Into::<T>::into(*l), r) }) }",
        "url": 256
    },
    {
        "code_input": "I'm sorry, but your question is a bit unclear. It seems like you're asking for a code snippet to set a variable in a Vertical.io (VTL) page, but the context is not clear. \n\nVTL is a language used to build dynamic content on the Vertical.io platform. It's not a programming language, but a markup language. It's used to create dynamic content that can be used in a Vertical.io page.\n\nIf you're asking for a code snippet to set a variable in a VTL page, I'd need more information about what you're trying to achieve. For example, what variable you're trying to set, what value it should have, and what page you're trying to set it on.\n\nPlease provide more details so I can assist you better.\n",
        "nl_input": "Set the reason for the vtl return into the vp assist page",
        "gt": "pub fn set_return_reason(&self, reason: HvVtlEntryReason) -> Result<(), GuestMemoryError> { let gpa = (self.vp_assist_page.gpa_page_number() * HV_PAGE_SIZE) + offset_of!(hvdef::HvVpAssistPage, vtl_control) as u64 + offset_of!(HvVpVtlControl, entry_reason) as u64; self.guest_memory.write_plain(gpa, &(reason.0)) }",
        "url": 257
    },
    {
        "code_input": "use std::process::exit;\n\nfn main() {\n    // Create a new job object\n    let job = std::thread::spawn(move || {\n        // This is where you would put your code to create a suspended, nearly empty process\n\n        // When the job object is closed, the process will terminate\n        exit(0);\n    });\n\n    // Wait for the job to finish\n    job.join().unwrap();\n}",
        "nl_input": "Creates a suspended, (nearly) empty process, hosted in a new job object. It will terminate when the job object is closed.",
        "gt": "pub fn empty_process() -> io::Result<EmptyProcess> { let job = Job::new()?; job.set_terminate_on_close()?; let mut builder = Builder::new(\"empty\"); builder .application_name(std::env::current_exe()?) .env_clear() .stdin(Stdio::Null) .stdout(Stdio::Null) .stderr(Stdio::Null) .job(job.as_handle()) .suspended(true); let process = builder.spawn()?; Ok(EmptyProcess { process, job }) }",
        "url": 258
    },
    {
        "code_input": "use near_sdk::{env, near_bindgen};\n\n#[near_bindgen]\nimpl env::contract {\n    #[init]\n    fn new(_delegate: env::delegate::Delegate) {}\n\n    #[finality(\"final\")]\n    fn asset_recipient(&self, _msg: env::msg::Msg) {\n        let contract_id = env::current_account_id();\n        let contract_account = env::account_info(contract_id).unwrap();\n        let contract_account_id = contract_account.account_id.to_string_lossy();\n\n        // Replace with your actual contract's address\n        let contract_address = \"0x3bfa67fe\".to_string_lossy();\n\n        // Call the contract's",
        "nl_input": "Calls the contract's `assetRecipient` (0x3bfa67fe) function",
        "gt": "pub fn asset_recipient( &self, ) -> ::ethers::contract::builders::ContractCall< M, ::ethers::core::types::Address, > { self.0 .method_hash([59, 250, 103, 254], ()) .expect(\"method not found (this should never happen)\") }",
        "url": 259
    },
    {
        "code_input": "use std::process::Command;\nuse std::env;\n\nfn main() {\n    let mut env_variables = env::vars();\n\n    // Run the command\n    let output = Command::new(\"your-command\")\n        .output()\n        .expect(\"failed to execute command\");\n\n    // Parse the output as a string\n    let output_str = String::from_utf8(output.stdout)\n        .expect(\"failed to decode output\");\n\n    // Split the output string into lines\n    let lines: Vec<&str> = output_str.split_whitespace().collect();\n\n    // Iterate over the lines and set the environment variables\n    for line in lines {\n        let variable: Vec<&str> = line.split('=').collect();\n        if variable.len() == 2 {\n            env_variables.set(variable[",
        "nl_input": "Runs the activation scripts of the prefix and returns the environment variables that were modified as part of this process.",
        "gt": "pub async fn run_activation(&self) -> miette::Result<HashMap<String, String>> { let activator = Activator::from_path(self.root(), ShellEnum::default(), Platform::current()) .into_diagnostic() .context(\"failed to constructor environment activator\")?; activator .run_activation(ActivationVariables::from_env().unwrap_or_default(), None) .into_diagnostic() .context(\"failed to run activation\") }",
        "url": 260
    },
    {
        "code_input": "use web3::{Client, types::Address, types::Hex};\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    let client = Client::new(\"http://localhost:8545\")?;\n\n    let contract_address = Address::from_str(\"0xf47b7740\")?;\n\n    let result = client.call_contract(\n        \"information\",\n        &contract_address,\n        &[]\n    )?;\n\n    println!(\"{}\", result);\n\n    Ok(",
        "nl_input": "Calls the contract's `information` (0xf47b7740) function",
        "gt": "pub fn information( &self, ) -> ::ethers::contract::builders::ContractCall< M, (::std::string::String, [u8; 32], ::ethers::core::types::Address), > { self.0 .method_hash([244, 123, 119, 64], ()) .expect(\"method not found (this should never happen)\") }",
        "url": 261
    },
    {
        "code_input": "use media_session::MediaSession;\n\nfn update_media_metadata(session: &mut MediaSession) {\n    let metadata = MediaMetadata::new()\n        .title(\"New Title\")\n        .album(\"New Album\")\n        .artist(\"New Artist\")\n        .duration(Duration::new(Some(123), Some(456))) // in seconds\n        .build();\n\n    session.update_metadata(metadata);\n}",
        "nl_input": "Updates media metadata properties in a `MediaSession`.",
        "gt": "fn update_media_properties( session_output: &mut MediaSession, session: &GsmtcSession, ) -> anyhow::Result<()> { let properties = session.TryGetMediaPropertiesAsync()?.get()?; let title = properties.Title()?.to_string(); let artist = properties.Artist()?.to_string(); let album_title = properties.AlbumTitle()?.to_string(); let album_artist = properties.AlbumArtist()?.to_string(); session_output.title = (!title.is_empty()).then_some(title); session_output.artist = (!artist.is_empty()).then_some(artist); session_output.album_title = (!album_title.is_empty()).then_some(album_title); session_output.album_artist = (!album_artist.is_empty()).then_some(album_artist); session_output.track_number = properties.TrackNumber()? as u32; Ok(()) }",
        "url": 262
    },
    {
        "code_input": "pub fn is_boolean_column(column: &Vec<bool>) -> Option<&Vec<bool>> {\n    if column.is_empty() {\n        return None;\n    }\n    let first_element = column.get(0);\n    match first_element {\n        Some(&value) => {\n            if value {\n                return Some(column);\n            }\n            else {\n                return None;\n            }\n        },\n        None => return None,\n    }\n}",
        "nl_input": "Returns the column as a slice of booleans if it is a boolean column. Otherwise, returns None.",
        "gt": "pub(crate) fn as_boolean(&self) -> Option<&'a [bool]> { match self { Self::Boolean(col) => Some(col), _ => None, } }",
        "url": 263
    },
    {
        "code_input": "use std::collections::{HashMap, VecDeque};\nuse std::sync::{Arc, RwLock};\n\nstruct LRUCache<K, V> {\n    capacity: usize,\n    cache: Arc<RwLock<HashMap<K, V>>>,\n    order: VecDeque<K>,\n}\n\nimpl<K: Ord + Clone, V> LRUCache<K, V> {\n    pub fn new(capacity: usize) -> Self {\n        Self {\n            capacity,\n            cache: Arc::new(RwLock::new(HashMap::new())),\n            order: VecDeque::new(),\n        }\n    }\n\n    pub fn get(&self, key: &K",
        "nl_input": "This may evict 'waiting' entries under high load. That will cause a channel error for callers who could choose to retry. If this becomes an issue, we can iterate over the entries, collect a set of keys to evict and manually pop each key from the LRU.",
        "gt": "fn trim_to_size(inner: &mut Inner<RT, Key, Value>) { while inner.current_size > inner.max_size { let (_, evicted) = inner .cache .pop_lru() .expect(\"Over max size, but no more entries\"); if let CacheResult::Ready { ref value, size, ref added, } = evicted { if size != value.size() { tracing::warn!( \"Value changed size from {} to {} while in the {} cache!\", size, value.size(), inner.label ) } async_lru_log_eviction(inner.label, added.elapsed()); } inner.current_size -= evicted.size(); } }",
        "url": 264
    },
    {
        "code_input": "use sklearn::classification::Classifier;\nuse std::fs::File;\nuse std::io::Write;\n\nfn save_classifier<T: serde::Serialize>(classifier: &T, path: &str) -> Result<(), Box<dyn std::error::Error>> {\n    let mut file = File::create(path)?;\n    let classifier_data = serde_json::to_string(classifier)?;\n    file.write_all(classifier_data.as_bytes())?;\n    Ok(())\n}\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Assume we have a trained classifier\n    let classifier = Classifier::new()?;\n\n    // Save the classifier to a file\n    save_classifier(&classifier, \"classifier.json\")?;\n\n    Ok(())\n}",
        "nl_input": "Saves the classifier to the given path.",
        "gt": "pub fn save<P: AsRef<std::path::Path>>(&self, path: P) -> candle_core::Result<()> { self.model.save(path) }",
        "url": 265
    },
    {
        "code_input": "use std::io::Write;\n\n#[derive(Debug)]\nstruct MyStruct {\n    data: Vec<u8>,\n}\n\nfn align_and_append(config_blob: &mut Vec<u8>, my_struct: &MyStruct) {\n    // Append the size of the struct to the config blob\n    config_blob.extend(&[0u8; 4]);\n\n    // Append the actual data of the struct\n    config_blob.extend(&my_struct.data);\n}\n\nfn main() {\n    let mut config_blob = vec![];\n    let my_struct = MyStruct {\n        data: vec![1, 2, 3, 4, 5],\n    };\n\n    align_and_append(&mut config_blob, &my_struct);\n\n    println!(\"{:?}\", config_blob",
        "nl_input": "Aligns and appends the raw byte data of a potentially dynamically sized structure and its appropriate header to the configuration blob.",
        "gt": "pub fn add_raw(&mut self, structure_type: BlobStructureType, data: &[u8]) -> &mut Self { self.add_raw_inner(structure_type, data, false) }",
        "url": 266
    },
    {
        "code_input": "fn determine_vector_size(vec: &Vec<u8>) -> usize {\n    match vec.len() {\n        0 => 0,\n        1 => 1,\n        _ => match vec.get(0).unwrap().len() {\n            0 => 0,\n            1 => 1,\n            _ => 4,\n        },\n    }\n}",
        "nl_input": "Tiny Vecs are dumb. Skip to: - 8 if the element size is 1, because any heap allocators is likely to round up a request of less than 8 bytes to at least 8 bytes. - 4 if elements are moderate-sized (<= 1 KiB). - 1 otherwise, to avoid wasting too much space for very short Vecs.",
        "gt": "const fn min_non_zero_cap(size: usize) -> usize { if size == 1 { 8 } else if size <= 1024 { 4 } else { 1 } }",
        "url": 267
    },
    {
        "code_input": "fn normalize<T>() -> ()\nwhere\n    T: AssociatedType,\n{\n    let metadata = T::Metadata;\n    // Do something with metadata\n}",
        "nl_input": "normalize `WrapperProject<T>::Metadata` -> `T::Assoc::Metadata` -> `()`",
        "gt": "fn wrapper_project_unit<T: ?Sized + Project>(ptr: *const ()) -> *const WrapperProject<T> where T::Assoc: Sized, { cast_same_meta(ptr) }",
        "url": 268
    },
    {
        "code_input": "use chrono::prelude::*;\nuse chrono::Duration;\n\nstruct TimeKeeper {\n    current_time: DateTime<Local>,\n}\n\nimpl TimeKeeper {\n    fn new() -> Self {\n        Self {\n            current_time: Local::now(),\n        }\n    }\n\n    fn get_current_time(&self) -> DateTime<Local> {\n        self.current_time.clone()\n    }\n\n    fn set_current_time(&mut self, new_time: DateTime<Local>) {\n        self.current_time = new_time;\n    }\n\n    fn get_current_time_as_string(&self) -> String {\n        self.current_time.format(\"%Y-%m-%d %H:%M:%S\").to_string()\n    }\n\n    fn get_current_time_as_duration(&self) -> Duration<Local> {",
        "nl_input": "Creates a new time keeper with the specified current guest time.",
        "gt": "pub fn new(driver: &impl SpawnDriver, uptime: VmTime) -> Self { let (new_send, new_recv) = mesh::mpsc_channel(); let (req_send, req_recv) = mesh::channel(); let time = TimeState::Stopped(uptime); let task = driver.spawn(\"vm-time-keeper\", async move { let mut primary = PrimaryKeeper { req_recv, new_recv, keepers: Vec::new(), next_id: 0, time, }; primary.run().await; }); Self { time, req_send, builder: VmTimeSourceBuilder { new_send }, _task: task, } }",
        "url": 269
    },
    {
        "code_input": "fn alias_with_lt4a<'a>(_foo: &'a FooAlias<'_>) -> &'a str\n{\n    \"Hello, world!\"\n}",
        "nl_input": "Warning; two input lifetimes, but the output lifetime is not elided, i.e., the following is valid: fn alias_with_lt4a<'a>(_foo: &'a FooAlias<'_>) -> &'a str ^^",
        "gt": "fn alias_with_lt4a<'a, 'b>(_foo: &'a FooAlias<'b>) -> &'a str { unimplemented!() }",
        "url": 270
    },
    {
        "code_input": "struct MyStruct {\n    data: i32,\n}\n\nimpl Drop for MyStruct {\n    fn drop(&mut self) {\n        println!(\"MyStruct dropped\");\n    }\n}\n\nfn main() {\n    let mut s = MyStruct { data: 1 };\n    s.data = 2; // This will not cause a drop\n    s = MyStruct { data: 3 }; // This will cause a drop\n}",
        "nl_input": "Mutable reference allows only mutation of !Drop place.",
        "gt": "pub const fn f() { let mut x: (Option<String>, u32) = (None, 0); let mut a = 10; *(&mut a) = 11; x.1 = a; }",
        "url": 271
    },
    {
        "code_input": "use std::process::Command;\n\nfn main() {\n    let mut system_prompt = \"system prompt\".to_string();\n    let mut command = Command::new(\"system_command\");\n    command.arg(&system_prompt);\n\n    let output = command.output().expect(\"Failed to execute command\");\n\n    let output_str = String::from_utf8(output.stdout).unwrap();\n    println!(\"{}\", output_str);\n}",
        "nl_input": "Create a session with the task's system prompt.",
        "gt": "fn create_session(&mut self, model: &mut impl SyncModel<Session = S>) -> Result<S> { let read = &self.session; match read { Some(cache) => match cache.try_clone() { Ok(cache) => Ok(cache), Err(err) => { tracing::error!(\"Failed to clone session: {}\", err); Ok(self.create_new_session(model)?) } }, None => Ok(self.create_new_session(model)?), } }",
        "url": 272
    },
    {
        "code_input": "fn main() {\n    let x: bool;\n    x = true;\n    println!(\"{}\", x);\n}",
        "nl_input": "The purpose of this text is to ensure that we get good diagnostics when a `bool` is expected but that due to an assignment expression `x = y` the type is `()`.",
        "gt": "fn main() { let _: bool = 0 = 0; let _: bool = match 0 { 0 => 0 = 0, _ => 0 = 0, }; let _: bool = match true { true => 0 = 0, _ => (), }; if 0 = 0 {} let _: bool = if { 0 = 0 } { 0 = 0 } else { 0 = 0 }; let _ = (0 = 0) && { 0 = 0 } || (0 = 0); let _: usize = 0 = 0; let foo = &String::new(); let bar = \"\"; if foo = bar {} }",
        "url": 273
    },
    {
        "code_input": "use rwf::http::Headers;\n\nfn main() {\n    let mut headers = Headers::new();\n    headers.insert(\"x-my-header\", \"134\");\n}",
        "nl_input": "Add a header to the headers storage. The name will be converted to lowercase. # Example ``` # use rwf::http::Headers; let mut headers = Headers::new(); headers.insert(\"x-my-header\", \"134\"); ``` #### Implementation note This implementation doesn't support adding multiple headers with the same name. This is only needed for the `Set-Cookie` header which is handled separately.",
        "gt": "pub fn insert(&mut self, name: impl ToString, value: impl ToString) { self.headers .insert(name.to_string().to_lowercase(), value.to_string()); }",
        "url": 274
    },
    {
        "code_input": "I'm sorry, but I can't assist with that.\n",
        "nl_input": "FIXME(81658): should be used + lint reinstated after #83171 relands.",
        "gt": "fn handle_assign(&mut self, expr: &'tcx hir::Expr<'tcx>) { if self .typeck_results() .expr_adjustments(expr) .iter() .any(|adj| matches!(adj.kind, ty::adjustment::Adjust::Deref(_))) { self.visit_expr(expr); } else if let hir::ExprKind::Field(base, ..) = expr.kind { self.handle_assign(base); } else { self.visit_expr(expr); } }",
        "url": 275
    },
    {
        "code_input": "pub fn get_queue_length<T>(queue: &mut IndexQueue<T>) -> usize {\n    queue.len()\n}",
        "nl_input": "Returns the length of the [`IndexQueue`]. Note: This method may make only sense in a non-concurrent setup since the information could be out-of-date as soon as it is acquired.",
        "gt": "pub fn len(&self) -> usize { let (write_position, read_position) = self.acquire_read_and_write_position(); write_position - read_position }",
        "url": 276
    },
    {
        "code_input": "use std::collections::HashMap;\n\n#[derive(Debug, Clone)]\nstruct DefMap {\n    name: String,\n    value: String,\n    children: Vec<DefMap>,\n}\n\nimpl DefMap {\n    fn get_module(&self) -> Option<&String> {\n        self.name.split('.').collect::<Vec<&str>>().last()\n    }\n\n    fn new(name: String, value: String) -> DefMap {\n        DefMap {\n            name,\n            value,\n            children: vec![],\n        }\n    }\n\n    fn add_child(&mut self, child: DefMap) {\n        self.children.push(child);\n    }\n}\n\nfn main() {\n    let mut root = DefMap::new(String::from(\"module.name\"), String::from(\"module.value",
        "nl_input": "If this `DefMap` is for a block expression, returns the module containing the block (which might again be a block, or a module inside a block).",
        "gt": "pub fn parent(&self) -> Option<ModuleId> { let BlockRelativeModuleId { block, local_id } = self.block?.parent; Some(ModuleId { krate: self.krate, block, local_id }) }",
        "url": 277
    },
    {
        "code_input": "extern crate raylib;\nextern crate raymarch_rs;\n\nuse raylib::{Color, DrawMode, Texture2D, vec2, vec3, vec4};\nuse raymarch_rs::{Mesh, MeshBuilder, Primitive, RenderMode, Shader, ShaderData, Vertex};\n\nfn main() {\n    // Initialize the window\n    raylib::InitWindow(800, 600, \"Raymarch Mesh\");\n\n    // Setup camera\n    let mut camera = vec3::new(0",
        "nl_input": "Creates a node within a new mesh.",
        "gt": "pub fn new(driver: impl Driver + Spawn + Clone) -> io::Result<Self> { let directory = create_object_directory(&ObjectAttributes::new(), DIRECTORY_ALL_ACCESS)?; Self::with_id(driver, NodeId::new(), directory) }",
        "url": 278
    },
    {
        "code_input": "use std::collections::HashMap;\nuse std::sync::{Arc, Mutex};\nuse tokio::sync::mpsc;\n\n#[tokio::main]\nasync fn main() {\n    let (tx, rx) = mpsc::channel();\n\n    let kv = Arc::new(Mutex::new(HashMap::new()));\n\n    let kv_store = KVStore::new(kv, tx);\n\n    let _ = kv_store.start().await;\n\n    let _ = rx.recv().await;\n}\n\nstruct KVStore {\n    kv: Arc<Mutex<HashMap<String, String>>>,",
        "nl_input": "If possible, extract some result from the preceding KV and move to the edge beyond it.",
        "gt": "fn perform_next_back_checked<F, R>(&mut self, f: F) -> Option<R> where F: Fn(&Handle<NodeRef<BorrowType, K, V, marker::LeafOrInternal>, marker::KV>) -> R, { if self.is_empty() { None } else { super::mem::replace(self.back.as_mut().unwrap(), |back| { let kv = back.next_back_kv().ok().unwrap(); let result = f(&kv); (kv.next_back_leaf_edge(), Some(result)) }) } }",
        "url": 279
    },
    {
        "code_input": "let mut list = LinkedList::new();\nlet value = Box::new(5);\nlet next = Box::new(Some(6));\n\nlist.push_back(Node { value, next });\n\n*list.0.value = Box::new(10);\n*list.0.next = Box::new(Some(11));",
        "nl_input": "Assignment to a deref field projection: the `*list.0` assignment should clear the existing borrows of `list.0.value` and `list.0.next`",
        "gt": "fn assignment_to_deref_field_projection<T>(mut list: (Box<&mut List<T>>,)) -> Vec<&mut T> { let mut result = vec![]; loop { result.push(&mut list.0.value); if let Some(n) = list.0.next.as_mut() { *list.0 = n; } else { return result; } } }",
        "url": 280
    },
    {
        "code_input": "struct Node {\n    reserved: bool,\n    active: bool,\n}\n\nfn main() {\n    let mut node = Node { reserved: false, active: true };\n    node = conflict(&mut node);\n    println!(\"{:?}\", node);\n}\n\nfn conflict(node: &mut Node) -> Node {\n    if node.reserved {\n        node.active = false;\n    }\n    node\n}\n\nfn invalidate(node: &mut Node) {\n    node.active = false;\n}",
        "nl_input": "A non-child node was read-accessed: keep `Reserved` but mark it as `conflicted` if it is protected; invalidate `Active`.",
        "gt": "fn foreign_read(state: PermissionPriv, protected: bool) -> Option<PermissionPriv> { Some(match state { non_writeable @ (Frozen | Disabled) => non_writeable, ReservedFrz { .. } if protected => ReservedFrz { conflicted: true }, res @ (ReservedFrz { .. } | ReservedIM) => { assert!(!protected); res } Active => if protected { Disabled } else { Frozen }, }) }",
        "url": 281
    },
    {
        "code_input": "use web3::{Client, types::Address, types::HexString};\nuse serde_json::Value;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Create a new client\n    let client = Client::new(\"http://localhost:8545\")?;\n\n    // The address of the contract\n    let contract_address = Address::from_str(\"0x33131570\")?;\n\n    // The ABI",
        "nl_input": "Calls the contract's `isValidOrderIncludingExtraData` (0x33131570) function",
        "gt": "pub fn is_valid_order_including_extra_data( &self, order_hash: [u8; 32], caller: ::ethers::core::types::Address, order: AdvancedOrder, prior_order_hashes: ::std::vec::Vec<[u8; 32]>, criteria_resolvers: ::std::vec::Vec<CriteriaResolver>, ) -> ::ethers::contract::builders::ContractCall<M, [u8; 4]> { self.0 .method_hash( [51, 19, 21, 112], (order_hash, caller, order, prior_order_hashes, criteria_resolvers), ) .expect(\"method not found (this should never happen)\") }",
        "url": 282
    },
    {
        "code_input": "use std::path::Path;\n\nfn get_last_segment(path: &Path) -> Result<String, Box<dyn std::error::Error>> {\n    let last_segment = path.segments().collect::<Vec<_>>().last();\n    match last_segment {\n        Some(segment) => Ok(segment.to_string()),\n        None => Err(\"No segments in the path\".into()),\n    }\n}",
        "nl_input": "Return a \"error message-able\" ident for the last segment of the `Path`",
        "gt": "fn path_name_to_string(path: &Path<'_>) -> String { path.segments.last().unwrap().ident.name.to_ident_string() }",
        "url": 283
    },
    {
        "code_input": "use std::collections::HashMap;\n\nfn prefix_imports(code: &str) -> String {\n    let mut lines = code.lines();\n    let mut result = String::new();\n    let mut prefix_map: HashMap<&str, usize> = HashMap::new();\n    let mut prefix_count = 0;\n\n    for line in lines {\n        if line.starts_with(\"requires\") {\n            let mut parts = line.split_whitespace();\n            let mut prefix = String::new();\n            for part in parts {\n                if let Some(prefix_part) = part.strip_prefix(\"requires\") {\n                    prefix.push_str(prefix_part);\n                } else {\n                    break;\n                }\n            }\n            if prefix.is_empty() {\n                prefix_count += 1;\n                prefix_map.insert(&format!(\"requires{}\", prefix_count), 0);\n                result.push_str(\"requires\");\n                result.push_str(&format!(\"{}{}\", prefix, prefix_count));",
        "nl_input": "Requires imports to by prefix instead of fuzzily.",
        "gt": "pub fn path_fuzzy_name_to_prefix(&mut self) { if let ImportCandidate::Path(PathImportCandidate { name: to_import, .. }) = &mut self.import_candidate { let (name, case_sensitive) = match to_import { NameToImport::Fuzzy(name, case_sensitive) => { (std::mem::take(name), *case_sensitive) } _ => return, }; *to_import = NameToImport::Prefix(name, case_sensitive); } }",
        "url": 284
    },
    {
        "code_input": "use web3::{Client, types::Address, types::HexString};\nuse serde_json::Value;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Create a new Web3 client\n    let client = Client::new(\"http://localhost:8545\")?;\n\n    // The address of the contract\n    let contract_address = Address::from_str(\"0",
        "nl_input": "Calls the contract's `executeArb` (0x650dc8e5) function",
        "gt": "pub fn execute_arb( &self, basic_order: BasicOrderParameters, payment_value: ::ethers::core::types::U256, sudo_pool: ::ethers::core::types::Address, ) -> ::ethers::contract::builders::ContractCall<M, ()> { self.0 .method_hash( [101, 13, 200, 229], (basic_order, payment_value, sudo_pool), ) .expect(\"method not found (this should never happen)\") }",
        "url": 285
    },
    {
        "code_input": "I'm sorry, but I can't provide the help you're looking for without the specific details of the query you're referring to. Could you please provide more information about the problem you're encountering?\n",
        "nl_input": "This caused a failure in #18906",
        "gt": "fn bar<Q>(k: &K, q: &Q) where K: Borrow<Q>, Q: Foo { q.foo(k.borrow()) }",
        "url": 286
    },
    {
        "code_input": "pub fn top_level_fns() {\n    // Define a function that takes a string and returns a string\n    fn string_to_string(input: &str) -> String {\n        // Return the input string\n        input.to_string()\n    }\n\n    // Define a function that takes a string slice and returns a string\n    fn string_slice_to_string(input: &[u8]) -> String {\n        // Convert the input slice to a string\n        String::from_utf8(input).unwrap()\n    }\n\n    // Define a function that takes a string slice and returns a string slice\n    fn string_slice_to_string_slice(input: &[u8]) -> Vec<String> {\n        // Convert the input slice to a vector of strings\n        let mut result: Vec<String> = Vec::new();\n        for chunk in input.iter_utf8() {\n            result.push(chunk.to_string());\n        }\n        result\n    }\n\n    // Define a function that takes a string slice and returns a string slice",
        "nl_input": "TOP-LEVEL FN'S",
        "gt": "fn escaping_borrow_of_fn_params_1() { fn g<'a>(x: usize, y:usize) -> Box<dyn Fn(bool) -> usize + 'a> { let f = |t: bool| if t { x } else { y }; return Box::new(f); }; }",
        "url": 287
    },
    {
        "code_input": "use std::fs::File;\nuse std::io::Write;\n\npub fn write_to_disk(buffer: &Buffer) {\n    let data = buffer.get_data();\n    let filename = \"buffer.txt\";\n\n    // Check if the buffer is dirty\n    if buffer.is_dirty() {\n        // Open the file for writing\n        let file = File::create(filename).unwrap();\n\n        // Write the data to the file\n        file.write_all(data.as_bytes()).unwrap();\n\n        println!(\"Data written to disk successfully\");\n    } else {\n        println!(\"Buffer is not dirty, not writing to disk\");\n    }\n}",
        "nl_input": "Writes the buffer to the disk if it is dirty.",
        "gt": "async fn flush(&mut self) -> io::Result<()> { if self.buffer_dirty { let guest_mem = GuestMemory::allocate(self.inner.sector_size() as usize); guest_mem.write_at(0, &self.buffer).unwrap(); let write_buffers = OwnedRequestBuffers::linear(0, self.inner.sector_size() as usize, true); let binding = write_buffers.buffer(&guest_mem); let future = self.inner.write_vectored( &binding, self.pos / self.inner.sector_size() as u64, true, ); let result = future.await; self.buffer_dirty = false; result.map_err(|e| io::Error::new(io::ErrorKind::Other, format!(\"Fetch error: {}\", e))) } else { Ok(()) } }",
        "url": 288
    },
    {
        "code_input": "use postgres::{Client, NoTls};\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Create a new client\n    let mut client = Client::connect(\n        \"postgres://username:password@localhost:5432/database_name\",\n        NoTls,\n    )?;\n\n    // Query the database\n    let rows = client.query(\n        \"SELECT * FROM table_name\",\n        &[]\n    )?;\n\n    // Iterate over the rows\n    for row in rows {\n        let column1 = row.get::<&str, String>(0)?;\n        let column2 = row.get::<&str, String>(1)?;\n        // Do something with column1 and column2\n    }\n\n    Ok(())\n}",
        "nl_input": "Begins opening a database by reading the database header.",
        "gt": "pub fn begin_open(page_io: Rc<dyn DatabaseStorage>) -> Result<Rc<RefCell<DatabaseHeader>>> { sqlite3_ondisk::begin_read_database_header(page_io) }",
        "url": 289
    },
    {
        "code_input": "fn function_without_body() -> Option<bool> {\n    None\n}\n\nfn function_with_body() -> bool {\n    let result = 10 / 0;\n    true\n}\n\nfn main() {\n    match function_without_body() {\n        None => println!(\"Function can't panic\"),\n        Some(value) => println!(\"Function can panic with value: {}\", value),\n    }\n\n    match function_with_body() {\n        true => println!(\"Function can't panic\"),\n        false => println!(\"Function can panic\"),\n    }\n}",
        "nl_input": "`None` if function without a body; some bool to guess if function can panic",
        "gt": "fn can_panic(ast_func: &ast::Fn) -> Option<bool> { let body = ast_func.body()?.to_string(); let can_panic = body.contains(\"panic!(\") || body.contains(\"assert!(\") || body.contains(\".unwrap()\") || body.contains(\".expect(\"); Some(can_panic) }",
        "url": 290
    },
    {
        "code_input": "use ethers::types::Event;\nuse ethers::prelude::*;\n\nfn get_token_deposit_events(provider: &Provider, address: &str) -> Result<Vec<Event>, Box<dyn Error>> {\n    let filter = Event::Filter {\n        from_block: None,\n        to_block: None,\n        address: Some(address),\n        topics: Some(vec![\n            \"0xddf252ad1be2c89b69c2b068fc378a1e893669256c160e61f00a604970f88efa\".parse::<HexString>()?,\n            \"0x000000000000000000000000000",
        "nl_input": "Gets the contract's `TokenDeposit` event",
        "gt": "pub fn token_deposit_filter( &self, ) -> ::ethers::contract::builders::Event< ::std::sync::Arc<M>, M, TokenDepositFilter, > { self.0.event() }",
        "url": 291
    },
    {
        "code_input": "use web3::{Client, types::Address, types::HexString};\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Create a new Web3 client\n    let client = Client::new()?;\n\n    // The address of the contract\n    let contract_address = Address::from_str(\"0x5b34b966\")?;\n\n    // The ABI of the contract\n    let abi = r#\"\n    [\n        {\n            \"constant\": true,\n            \"inputs\": [],\n            \"name\": \"counter\",\n            \"outputs\": [\n                {\n                    \"name\": \"\",\n                    \"type\": \"uint256\"\n                }\n            ],\n            \"payable\": false,\n            \"type\": \"function\"",
        "nl_input": "Calls the contract's `incrementCounter` (0x5b34b966) function",
        "gt": "pub fn increment_counter( &self, ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::U256> { self.0 .method_hash([91, 52, 185, 102], ()) .expect(\"method not found (this should never happen)\") }",
        "url": 292
    },
    {
        "code_input": "pub enum ProofStatus {\n    Fulfilled,\n    NotFulfilled,\n}\n\npub struct Proof {\n    status: ProofStatus,\n    data: String,\n}\n\nimpl Proof {\n    pub fn new(status: ProofStatus, data: String) -> Self {\n        Self { status, data }\n    }\n\n    pub fn get_status(&self) -> ProofStatus {\n        self.status\n    }\n\n    pub fn get_data(&self) -> &String {\n        &self.data\n    }\n}",
        "nl_input": "Get the status of a given proof. If the status is Fulfilled, the proof is also returned.",
        "gt": "pub async fn get_proof_request_status<P: DeserializeOwned>( &self, request_id: &[u8], ) -> Result<(GetProofRequestStatusResponse, Option<P>)> { let mut rpc = self.get_rpc().await?; let res = rpc .get_proof_request_status(GetProofRequestStatusRequest { request_id: request_id.to_vec(), }) .await? .into_inner(); let status = ProofStatus::try_from(res.status)?; let proof = match status { ProofStatus::Fulfilled => { log::info!(\"Proof request fulfilled\"); let proof_uri = res .proof_uri .as_ref() .ok_or_else(|| anyhow::anyhow!(\"No proof URL provided\"))?; let proof_bytes = self.download_artifact(proof_uri).await?; Some(bincode::deserialize(&proof_bytes).context(\"Failed to deserialize proof\")?) } _ => None, }; Ok((res, proof)) }",
        "url": 293
    },
    {
        "code_input": "use web3::{Client, types::Address, types::HexString};\nuse serde_json::Value;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Create a new client\n    let client = Client::new(\"http://localhost:8545\")?;\n\n    // The address of the contract\n    let contract_address = Address::from_str(\"0xfb0f3ee1\")?;\n\n    // The A",
        "nl_input": "Calls the contract's `fulfillBasicOrder` (0xfb0f3ee1) function",
        "gt": "pub fn fulfill_basic_order( &self, parameters: BasicOrderParameters, ) -> ::ethers::contract::builders::ContractCall<M, bool> { self.0 .method_hash([251, 15, 62, 225], (parameters,)) .expect(\"method not found (this should never happen)\") }",
        "url": 294
    },
    {
        "code_input": "use nvapi::*;\nuse nvapi::types::*;\nuse nvapi::enums::*;\nuse nvapi::structs::*;\nuse nvapi::cuda::stream::CUstream;\nuse nvapi::cuda::event::CUevent;\n\nfn main() {\n    // Create a CUstream\n    let stream: CUstream = unsafe { CUstream::new() };\n\n    // Create a CUevent\n    let event: CUevent = unsafe { CUevent::new() };\n\n    // Set the event to signaled\n    event.set_status(cuda_event_status::completed);\n\n    // Submit the stream to the event\n    unsafe {\n        stream.enqueue_wait_event(&event);\n    }\n}",
        "nl_input": "Makes all future work submitted to the given stream wait for this event. Does not block the CPU. Note: cudaStreamWaitEvent must be called on the same device as the stream.",
        "gt": "pub fn wait(&self, stream: &CudaStream) { unsafe { check_res( \"cuda_event_block_C\", cuda_event_block_C(self.cu_ev.ptr, stream.cu_str), ) }; }",
        "url": 295
    },
    {
        "code_input": "fn elementwise_and(slice1: &[bool], slice2: &[bool]) -> Vec<bool> {\n    let mut result = Vec::new();\n    for (a, b) in slice1.iter().zip(slice2.iter()) {\n        result.push(*a && *b);\n    }\n    result\n}",
        "nl_input": "Element-wise AND on two boolean slices of the same length. We do not check for length equality here.",
        "gt": "pub(super) fn slice_and(lhs: &[bool], rhs: &[bool]) -> Vec<bool> { slice_binary_op(lhs, rhs, |l, r| -> bool { *l && *r }) }",
        "url": 296
    },
    {
        "code_input": "I'm sorry, but the code you've provided seems to be incomplete and doesn't seem to be related to a specific programming problem or query. Could you please provide more details or clarify what you're trying to achieve?\n",
        "nl_input": "@ revisions: current next @ ignore-compare-mode-next-solver (explicit revisions) @[next] compile-flags: -Znext-solver",
        "gt": "fn changer<'a>(mut things: Box<dyn Iterator<Item=&'a mut u8>>) { for item in *things { *item = 0 } }",
        "url": 297
    },
    {
        "code_input": "use azure_devops_client::{pat::PAT, PullRequest, PullRequestCollection, Repository, RepositoryClient, ServiceEndpoint};\nuse std::env;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Get the PAT from the environment variables\n    let pat = env::var(\"PAT\").unwrap();\n\n    // Create a ServiceEndpoint for the Azure DevOps instance\n    let service_endpoint = ServiceEndpoint::new(\"https://dev.azure.com\".parse().unwrap(), pat.clone());\n\n    // Create a RepositoryClient\n    let repository_client = RepositoryClient::new(service_endpoint);\n\n    // Get the repository\n    let repository = Repository::new(\"myorg\", \"myproject\".parse().",
        "nl_input": "Get the value of a flowey Var as a ADO runtime variable.",
        "gt": "pub fn get_var(&mut self, var: ClaimedReadVar<String>) -> AdoRuntimeVar { let backing_var = if let ReadVarBacking::RuntimeVar(var) = &var.backing_var { var } else { todo!(\"support inline ado read vars\") }; let new_ado_var_name = (self.fresh_ado_var)(); self.rust_to_ado.push(( backing_var.clone(), new_ado_var_name.clone(), var.is_secret, )); AdoRuntimeVar::dangerous_from_global(new_ado_var_name, var.is_secret) }",
        "url": 298
    },
    {
        "code_input": "I'm sorry, but I can't provide the help you're looking for without the specific details of the query. Could you please provide more information about the query you're referring to?\n",
        "nl_input": "FIXME: This is only used in collection, we should move the relevant parts of it out of ItemScope",
        "gt": "pub(crate) fn unnamed_trait_vis(&self, tr: TraitId) -> Option<Visibility> { self.unnamed_trait_imports.get(&tr).copied().map(|(a, _)| a) }",
        "url": 299
    },
    {
        "code_input": "use std::arch::asm;\nuse std::ptr;\n\npub unsafe fn get_peb() -> *const ::std::arch::peb::Peb {\n    let mut peb: ::std::arch::peb::Peb = ::std::mem::zeroed();\n    asm::sys_call1(0x400000, asm::WITHOUT_PREFIX | asm::SYSCALL_READ, ptr::null_mut(), ptr::null_mut(), ptr::null_mut(), ptr::null_mut(), ptr::null_mut(), ptr::null_mut(), ptr::null_mut(), ptr::null_mut(), ptr::null_mut(), ptr::null_mut(), ptr::null_mut(), ptr::null_mut(),",
        "nl_input": "Retrieves the Process Environment Block (PEB) of the current process. This function uses architecture-specific intrinsics to access the Thread Environment Block (TEB) and extract the PEB pointer. # Returns A mutable pointer to the PEB structure.",
        "gt": "pub unsafe fn get_peb() -> *mut PEB { let teb_offset = ntapi::FIELD_OFFSET!(NT_TIB, _Self) as u32; #[cfg(target_arch = \"x86_64\")] unsafe { use ntapi::winapi_local::um::winnt::__readgsqword; let teb = __readgsqword(teb_offset) as *mut TEB; (*teb).ProcessEnvironmentBlock } #[cfg(target_arch = \"x86\")] unsafe { use ntapi::winapi_local::um::winnt::__readfsdword; let teb = __readfsdword(teb_offset) as *mut TEB; (*teb).ProcessEnvironmentBlock } }",
        "url": 300
    },
    {
        "code_input": "use std::os::last_os_error;\n\nfn main() {\n    let err_code = last_os_error().unwrap_or(-1);\n    println!(\"Last OS error: {}\", err_code);\n}",
        "nl_input": "Sets the last OS error and return `-1` as a `i32`-typed Scalar",
        "gt": "fn set_last_error_and_return_i32( &mut self, err: impl Into<IoError>, ) -> InterpResult<'tcx, Scalar> { let this = self.eval_context_mut(); this.set_last_error(err)?; interp_ok(Scalar::from_i32(-1)) }",
        "url": 301
    },
    {
        "code_input": "use std::error::Error;\nuse std::process;\n\nfn main() -> Result<(), Box<dyn Error>> {\n    // This is a dummy error, you can replace it with your actual error\n    let result = Err(\"This is a dummy error\");\n\n    if let Err(e) = result {\n        println!(\"Error: {}\", e);\n        process::exit(1);\n    }\n\n    Ok(())\n}",
        "nl_input": "Print error message, along with (optional) stack trace, then exit",
        "gt": "fn print_error(message: &str, sub_message: &str, error: Option<&Error>) { eprintln!( \"{}{}{}\", format!(\"{}\", message).red(), match error { Some(err) => format!(\"\\n{}\", err).red().dimmed(), None => \"\".red().dimmed(), }, format!(\"\\n{}\", sub_message).yellow(), ); std::process::exit(1); }",
        "url": 302
    },
    {
        "code_input": "use emits::LowerIntrinsics;\n\nfn main() {\n    let lower_intrinsics = LowerIntrinsics::diff;\n    println!(\"{}\", lower_intrinsics);\n}",
        "nl_input": "EMIT_MIR lower_intrinsics.transmute_ref_dst.LowerIntrinsics.diff",
        "gt": "pub unsafe fn transmute_ref_dst<T: ?Sized>(u: &T) -> *const T { unsafe { std::mem::transmute(u) } }",
        "url": 303
    },
    {
        "code_input": "fn main() {\n    let mut x = 0;\n    loop {\n        x += 1;\n    }\n}",
        "nl_input": "Spins forever, preserving some context in the registers.",
        "gt": "pub fn dead_loop(code0: u64, code1: u64, code2: u64) -> ! { unsafe { core::arch::asm!(\"1: jmp 1b\", in (\"rdi\") code0, in (\"rsi\") code1, in (\"rax\") code2, options(att_syntax)); core::hint::unreachable_unchecked() } }",
        "url": 304
    },
    {
        "code_input": "pub fn factorial(n: u64) -> u64 {\n    match n {\n        0 => 1,\n        1 => 1,\n        _ => n * factorial(n - 1),\n    }\n}",
        "nl_input": "Not re-exported outside the crate",
        "gt": "pub fn new(url: &mut Url) -> PathSegmentsMut<'_> { let after_path = url.take_after_path(); let old_after_path_position = to_u32(url.serialization.len()).unwrap(); // Special urls always have a non empty path if SchemeType::from(url.scheme()).is_special() { debug_assert!(url.byte_at(url.path_start) == b'/'); } else { debug_assert!( url.serialization.len() == url.path_start as usize || url.byte_at(url.path_start) == b'/' ); } PathSegmentsMut { after_first_slash: url.path_start as usize + \"/\".len(), url, old_after_path_position, after_path, } }",
        "url": 305
    },
    {
        "code_input": "use std::env;\n\nfn main() {\n    let guest = env::var(\"GUEST\").unwrap_or(\"rust\");\n    println!(\"{}\", guest);\n}",
        "nl_input": "returns the the path of simpleguest binary. Picks rust c version depending on environment variable GUEST (or rust by default if unset)",
        "gt": "pub(crate) fn get_c_or_rust_simpleguest_path() -> String { let guest_type = std::env::var(\"GUEST\").unwrap_or(\"rust\".to_string()); match guest_type.as_str() { \"rust\" => simple_guest_as_string().unwrap(), \"c\" => c_simple_guest_as_string().unwrap(), _ => panic!(\"Unknown guest type '{guest_type}', use either 'rust' or 'c'\"), } }",
        "url": 306
    },
    {
        "code_input": "fn num_of_digits(n: u64, base: u64) -> u64 {\n    match base {\n        2 => n.count_ones() as u64,\n        8 => n.count_ones() as u64,\n        10 => n.to_string().len() as u64,\n        16 => n.to_string().len() as u64,\n        _ => panic!(\"Unsupported base\"),\n    }\n}",
        "nl_input": "Counts how many base-10 digits are required to represent n in the given base",
        "gt": "fn count_digits(n: u16) -> usize { match n { 0..=9 => 1, 10..=99 => 2, 100..=999 => 3, 1000..=9999 => 4, 10000..=65535 => 5, } }",
        "url": 307
    },
    {
        "code_input": "use templating::Template;\nuse std::collections::HashMap;\nuse std::fmt;\n\n#[derive(Debug, Clone, Copy)]\nenum StringTemplateError {\n    TemplateError(String),\n}\n\nimpl fmt::Display for StringTemplateError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match self {\n            StringTemplateError::TemplateError(ref err) => write!(f, \"Template error: {}\", err),\n        }\n    }\n}\n\nimpl From<StringTemplateError>",
        "nl_input": "Adds a assistant message to the conversation by templating the specified template string and parameters. # Arguments * `body` - A template string representing the message body. * `parameters` - Parameters used to template the message body # Returns Result<Self, StringTemplateError> If Ok() A Result containing a modified `ChatMessageCollection` with the new assistant message added on success, or an error if the body couldn't be templated",
        "gt": "pub fn with_assistant_template( self, body: &str, parameters: &Parameters, ) -> Result<Self, StringTemplateError> { match StringTemplate::tera(body).format(parameters) { Err(e) => Err(e), Ok(templated_body) => Ok(self.with_assistant(templated_body)), } }",
        "url": 308
    },
    {
        "code_input": "fn is_palindrome(s: &str) -> bool {\n    let s = s.chars().collect::<Vec<char>>();\n    let len = s.len();\n    for i in 0..len/2 {\n        if s[i] != s[len-i-1] {\n            return false;\n        }\n    }\n    true\n}",
        "nl_input": "while static methods can *assume* this, we should still *check* that it holds at the use site.",
        "gt": "fn evil<'a, 'b>(b: &'b u32) -> &'a u32 { <()>::static_evil(b) }",
        "url": 309
    },
    {
        "code_input": "use std::collections::HashMap;\n\nstruct QueryPrefetcher {\n    queries: HashMap<String, String>,\n}\n\nimpl QueryPrefetcher {\n    fn new() -> Self {\n        Self {\n            queries: HashMap::new(),\n        }\n    }\n\n    fn prefetch(&mut self, query: &str, result: &str) {\n        self.queries.insert(query.to_string(), result.to_string());\n    }\n\n    fn prefetch_query(&mut self, query: &str) -> Option<&str> {\n        self.queries.get(query)\n    }\n}",
        "nl_input": "Used to prefetch queries which will be needed later by metadata encoding. Only a subset of the queries are actually prefetched to keep this code smaller.",
        "gt": "fn prefetch_mir(tcx: TyCtxt<'_>) { if !tcx.sess.opts.output_types.should_codegen() { // We won't emit MIR, so don't prefetch it. return; } let reachable_set = tcx.reachable_set(()); par_for_each_in(tcx.mir_keys(()), |&def_id| { let (encode_const, encode_opt) = should_encode_mir(tcx, reachable_set, def_id); if encode_const { tcx.ensure_with_value().mir_for_ctfe(def_id); } if encode_opt { tcx.ensure_with_value().optimized_mir(def_id); } if encode_opt || encode_const { tcx.ensure_with_value().promoted_mir(def_id); } }) }",
        "url": 310
    },
    {
        "code_input": "use std::collections::HashMap;\n\nfn get_tensor_map() -> HashMap<String, Vec<i32>> {\n    // Create a new HashMap to store the tensor map.\n    let mut tensor_map: HashMap<String, Vec<i32>> = HashMap::new();\n\n    // Add some data to the tensor map.\n    tensor_map.insert(\"key1\".to_string(), vec![1, 2, 3, 4, 5]);\n    tensor_map.insert(\"key2\".to_string(), vec![6, 7, 8, 9, 10]);\n\n    // Return the tensor map.\n    tensor_map\n}",
        "nl_input": "Get the tensor map for this cache. This can be used to save the cache to disk.",
        "gt": "pub fn get_tensor_map(&self, device: &Device) -> HashMap<String, Tensor> { let mut map = HashMap::with_capacity(self.blocks.len()); for (i, kv_cache) in self.blocks.iter().enumerate() { if let (Ok(Some(k)), Ok(Some(v))) = (kv_cache.cache().k(), kv_cache.cache().v()) { map.insert(format!(\"llama.cache.blocks.{}.key\", i), k); map.insert(format!(\"llama.cache.blocks.{}.value\", i), v); } } map.insert( \"llama.cache.tokens\".to_string(), Tensor::from_iter(self.tokens.iter().copied(), device).unwrap(), ); map.insert( \"llama.cache.max_seq_len\".to_string(), Tensor::new(self.max_seq_len as u32, device).unwrap(), ); map }",
        "url": 311
    },
    {
        "code_input": "let array = [1, 2, 3, 4, 5];\nlet string = \"Hello, world!\";\n\nprintln!(\"Length of array: {}\", array.len());\nprintln!(\"Length of string: {}\", string.len());",
        "nl_input": "`.len()` on arrays ends up being something like this",
        "gt": "fn array_len(x: &mut [i32; 42]) -> usize { let x: &[i32] = x; std::intrinsics::ptr_metadata(x) }",
        "url": 312
    },
    {
        "code_input": "use ethereum_types::Address;\nuse ethereum_types::H256;\nuse ethereum_types::Hex;\nuse ethereum_types::HexBytes;\nuse ethereum_types::U256;\nuse ethereum_types::Uint;\nuse ethereum_types::Uint256;\nuse ethereum_types::Uint64;\nuse ethereum_types::Uint96;\nuse ethereum_types::abi::{Function, FunctionCall, FunctionResult, FunctionType};\nuse ethereum_types::abi::{Message, Unsigned};\nuse ethereum_types::abi::{Request, RequestCall, RequestResult};\nuse ethereum_types::abi::{Response, ResponseCall, ResponseResult};\nuse ethereum_types::abi::{Result, Result",
        "nl_input": "Calls the contract's `onERC1155Received` (0xf23a6e61) function",
        "gt": "pub fn on_erc1155_received( &self, p0: ::ethers::core::types::Address, p1: ::ethers::core::types::Address, p2: ::ethers::core::types::U256, p3: ::ethers::core::types::U256, p4: ::ethers::core::types::Bytes, ) -> ::ethers::contract::builders::ContractCall<M, [u8; 4]> { self.0 .method_hash([242, 58, 110, 97], (p0, p1, p2, p3, p4)) .expect(\"method not found (this should never happen)\") }",
        "url": 313
    },
    {
        "code_input": "fn hacked_eddyb(s: &str) -> String {\n    s.chars().map(|c| if c.is_lowercase() { c.to_uppercase().collect::<String>() } else { c.to_lowercase().collect::<String>() }).collect::<Vec<_>>()\n}",
        "nl_input": "HACK(eddyb) this can't be a closure due to lifetime elision.",
        "gt": "fn loop_initial_states( func_at_loop_node: FuncAtMut<'_, ControlNode>, ) -> &mut SmallVec<[Value; 2]> { match &mut func_at_loop_node.def().kind { ControlNodeKind::Loop { initial_inputs, .. } => initial_inputs, _ => unreachable!(), } }",
        "url": 314
    },
    {
        "code_input": "use crate::db::{get_connection, Connection};\nuse crate::models::Group;\nuse diesel::prelude::*;\n\npub fn get_group_by_tracking_id(tracking_id: i32) -> Option<Group> {\n    let conn: Connection = get_connection().unwrap();\n\n    let group = queries::group\n        .filter(group::tracking_id.eq(tracking_id))\n        .load::<Group>(&conn)\n        .expect(\"Failed to load group\");\n\n    Some(group)\n}",
        "nl_input": "get_group_by_tracking_id",
        "gt": "pub async fn get_group_by_tracking_id( data: web::Path<GetGroupByTrackingIDData>, dataset_org_plan_sub: DatasetAndOrgWithSubAndPlan, _user: LoggedUser, pool: web::Data<Pool>, ) -> Result<HttpResponse, actix_web::Error> { let group = get_group_from_tracking_id_query( data.tracking_id.clone(), dataset_org_plan_sub.dataset.id, pool.clone(), ) .await?; Ok(HttpResponse::Ok().json(group)) }",
        "url": 315
    },
    {
        "code_input": "use std::env;\n\nfn main() {\n    env::remove_var(\"KEY\").unwrap();\n}",
        "nl_input": "Removes an environment variable for the command.",
        "gt": "pub fn env_remove(mut self, key: impl AsRef<str>) -> Self { self.env_changes .push(EnvChange::Remove(key.as_ref().to_owned())); self }",
        "url": 316
    },
    {
        "code_input": "fn copy_slice<T: Copy>(src: &mut [T], offset: usize, dst: &mut [T]) {\n    let len = dst.len();\n    let src_len = src.len();\n    let end = offset % src_len;\n    let _ = dst[..end].copy_from_slice(&src[..end]);\n    let _ = dst[end..len].copy_from_slice(&src[end..len]);\n}",
        "nl_input": "Copy the contents of the sandbox at the specified offset into the slice",
        "gt": "pub fn copy_from_slice(&self, slice: &[u8], offset: usize) -> Result<()> { bounds_check!(offset, slice.len(), self.mem_size()); let base = self.base_ptr().wrapping_add(offset); let guard = self .lock .try_read() .map_err(|e| new_error!(\"Error locking at {}:{}: {}\", file!(), line!(), e))?; for (i, b) in slice.iter().enumerate() { unsafe { base.wrapping_add(i).write_volatile(*b); } } drop(guard); Ok(()) }",
        "url": 317
    },
    {
        "code_input": "fn main() {\n    let x = 5;\n    let y = 10;\n    let z = &x;\n    let w = &y;\n    let result = z.as_ref() as &w;\n    println!(\"{}\", result);\n}",
        "nl_input": "Look for `self: &'a Self` - also desugared from `&'a self`",
        "gt": "fn is_self_ty(&self, ty: &Ty) -> bool { match ty.kind { TyKind::ImplicitSelf => true, TyKind::Path(None, _) => { let path_res = self.r.partial_res_map[&ty.id].full_res(); if let Some(Res::SelfTyParam { .. } | Res::SelfTyAlias { .. }) = path_res { return true; } self.impl_self.is_some() && path_res == self.impl_self } _ => false, } }",
        "url": 318
    },
    {
        "code_input": "use colored::*;\n\nfn main() {\n    let terminal = std::io::stdout();\n    if terminal.is_terminal() {\n        println!(\"{}\", \"Hello, world!\".green());\n    } else {\n        println!(\"{}\", \"Hello, world!\");\n    }\n}",
        "nl_input": "Write output in the optionally specified color. The output is written in the specified color if this OutputWriter instance contains a Terminal in its `terminal` field.",
        "gt": "pub(crate) fn writeln(&mut self, msg: &str, color: Option<term::color::Color>) { match &mut self.terminal { Some(ref mut t) => { if let Some(color) = color { t.fg(color).unwrap(); } writeln!(t, \"{msg}\").unwrap(); if color.is_some() { t.reset().unwrap(); } } None => println!(\"{msg}\"), } }",
        "url": 319
    },
    {
        "code_input": "fn main() {\n    let s = \"Hello, world!\";\n    let _ = pass(s);\n}\n\nfn pass(s: &str) -> &str {\n    s\n}",
        "nl_input": "Run the sequence of passes without validating the MIR after each pass. The MIR is still validated at the end.",
        "gt": "pub(super) fn run_passes_no_validate<'tcx>( tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>, passes: &[&dyn MirPass<'tcx>], phase_change: Option<MirPhase>, ) { run_passes_inner(tcx, body, passes, phase_change, false); }",
        "url": 320
    },
    {
        "code_input": "I'm sorry, but the information you provided is not clear. Could you please provide more context or clarify what you're asking for? Are you asking for a Rust code to find the intersection of two sets?\n",
        "nl_input": "#11067 and #9626",
        "gt": "fn assoc_tys_generics<'a, 'b, T, U>() where T: IntoIterator<Item = ()> + IntoIterator<Item = i32>, U: From<&'a str> + From<&'b [u16]>, { }",
        "url": 321
    },
    {
        "code_input": "fn main() {\n    let a: i32 = 5;\n    let b: i32 = 5;\n    let c: i32 = 10;\n\n    let result = check_values(a, b, c);\n\n    println!(\"{}\", result);\n}\n\nfn check_values(a: i32, b: i32, c: i32) -> bool {\n    if a == b {\n        if c == a {\n            return true;\n        }\n    }\n    false\n}",
        "nl_input": "This used to fail MIR validation due to the types on both sides of an assignment not being equal. The failure doesn't occur with a check-only build.",
        "gt": "fn iter_slice<'a, T>(xs: &'a [T]) -> impl Iterator<Item = &'a T> { xs.iter() }",
        "url": 322
    },
    {
        "code_input": "fn main() {\n    let mut v = vec![1, 2, 3, 4, 5];\n    let r = &mut v;\n    let w = &mut v;\n    println!(\"{:?}\", r);\n    println!(\"{:?}\", w);\n}",
        "nl_input": "Make sure that reading from an `&mut` does, like reborrowing to `&`, NOT invalidate other reborrows.",
        "gt": "fn read_does_not_invalidate1() { fn foo(x: &mut (i32, i32)) -> &i32 { let xraw = x as *mut (i32, i32); let ret = unsafe { &(*xraw).1 }; let _val = x.1; ret } assert_eq!(*foo(&mut (1, 2)), 2); }",
        "url": 323
    },
    {
        "code_input": "use tick::prelude::*;\n\nfn main() {\n    let mut labels: Vec<String> = (0..100).map(|i| format!(\"Label {}\", i)).collect();\n\n    for i in 0..100 {\n        println!(\"{}\", labels[i]);\n    }\n}",
        "nl_input": "Generate periodic labels to render on the y-axis (query count)",
        "gt": "fn generate_y_labels(max: i32, count: usize) -> Vec<Span<'static>> { let step = max / (count - 1) as i32; (0..count) .map(|x| Span::raw(format!(\"{}\", x * step as usize))) .collect::<Vec<Span<'static>>>() }",
        "url": 324
    },
    {
        "code_input": "pub fn get_type<T>(_ty: T) -> T {\n    _ty\n}",
        "nl_input": "If `ty` is a type variable with known type, returns that type; otherwise, return ty.",
        "gt": "pub(crate) fn resolve_ty_shallow(&mut self, ty: &Ty) -> Ty { self.resolve_obligations_as_possible(); self.var_unification_table.normalize_ty_shallow(Interner, ty).unwrap_or_else(|| ty.clone()) }",
        "url": 325
    },
    {
        "code_input": "fn identity(n: u32) -> u32 {\n    let mut accumulator = n;\n    let mut num = n;\n    while num > 0 {\n        accumulator += 1;\n        num -= 1;\n    }\n    accumulator\n}\n\nfn main() {\n    println!(\"{}\", identity(10));\n}",
        "nl_input": "This is an identity function (`|x| x`), but implemented using recursion. Each step we increment accumulator and decrement the number. With normal calls this fails compilation because of the recursion limit, but with tail calls `become` we don't grow the stack spend recursion limit so this should compile.",
        "gt": "const fn rec_id(n: u32) -> u32 { const fn inner(acc: u32, n: u32) -> u32 { match n { 0 => acc, #[cfg(r#become)] _ => become inner(acc + 1, n - 1), #[cfg(r#return)] _ => return inner(acc + 1, n - 1), } } inner(0, n) }",
        "url": 326
    },
    {
        "code_input": "use std::time::Duration;\nuse std::time::Instant;\n\nfn mock_function(delay: Duration) {\n    let start = Instant::now();\n    // Simulate a delay\n    std::thread::sleep(delay);\n    let duration = start.elapsed();\n    println!(\"Time passed: {}\", duration);\n}\n\nfn main() {\n    let delay = Duration::from_secs(5);\n    mock_function(delay);\n}",
        "nl_input": "Bump the amount of mock time that's passed.",
        "gt": "pub fn tick(&self, d: std::time::Duration) { let mut time = self.time.lock(); *time = *time + LocalClockDelta::from_millis(d.as_millis().try_into().unwrap()) }",
        "url": 327
    },
    {
        "code_input": "use rand::Rng;\n\nfn main() {\n    let mut rng = rand::thread_rng();\n    let number = rng.gen_range(1..101);\n    println!(\"{}\", number);\n}",
        "nl_input": "Guarantees that each returned number is unique.",
        "gt": "pub fn next(&mut self) -> u32 { self.count += 1; assert!(self.count <= 70029); let x = self.x; let t = x ^ (x << 11); self.x = self.y; self.y = self.z; self.z = self.w; let w_ = self.w; self.w = w_ ^ (w_ >> 19) ^ (t ^ (t >> 8)); self.w }",
        "url": 328
    },
    {
        "code_input": "fn sort_array(arr: &mut [i32]) -> Vec<i32> {\n    let mut v: Vec<i32> = arr.to_vec();\n    v.sort();\n    v\n}",
        "nl_input": "If you pass in an array, it will not be sorted.",
        "gt": "pub(crate) fn serialize<T: Serialize>(item: T) -> Result<Self, serde_json::Error> { Ok(Self(serde_json::to_string(&item)?)) }",
        "url": 329
    },
    {
        "code_input": "use serde_json::Value;\nuse std::fs::File;\nuse std::io::BufReader;\n\nfn load_classifier(path: &str) -> Result<Value, serde_json::Error> {\n    let file = File::open(path)?;\n    let reader = BufReader::new(file);\n    let classifier: Value = serde_json::from_reader(reader)?;\n    Ok(classifier)\n}",
        "nl_input": "Loads a classifier from the given path.",
        "gt": "pub fn load<P: AsRef<std::path::Path>>( path: P, device: &Device, config: ClassifierConfig, ) -> candle_core::Result<Self> { let model = Classifier::load(path, device, config)?; Ok(Self::new(model)) }",
        "url": 330
    },
    {
        "code_input": "use std::cmp::Ord;\nuse std::cmp::Ordering;\n\npub fn closest_n<T>(embedding: &T, n: usize) -> Vec<T>\nwhere\n    T: Ord + Copy + PartialEq + std::marker::Copy + std::cmp::PartialEq + std::fmt::Debug,\n{\n    let mut embeddings = vec![];\n    // Add your embeddings to the embeddings vector\n    // For example: embeddings.push(embedding1);\n\n    let mut closest = Vec::new();\n    for e in embeddings.iter() {\n        if closest.len() < n {\n            let distance = e.partial_cmp(embed",
        "nl_input": "Get the closest N embeddings to the given embedding.",
        "gt": "pub fn search<'a>(&'a self, embedding: &'a Embedding<S>) -> VectorDBSearchBuilder<'a, S> { VectorDBSearchBuilder { db: self, embedding, results: None, filter: None, } }",
        "url": 331
    },
    {
        "code_input": "use std::fs;\nuse std::io::Read;\n\nfn main() {\n    let file_path = \"debug_info.elf\";\n    let file_content = fs::read(file_path).expect(\"Failed to read file\");\n\n    let mut file_content_str = String::new();\n    file_content.read_to_string(&mut file_content_str).expect(\"Failed to read file content\");\n\n    println!(\"{}\", file_content_str);\n}",
        "nl_input": "DevkitA64 doesn't natively support debug info, but the build system will place debug info at the path `romfs: debug_info.elf`.",
        "gt": "pub(super) fn native_libraries() -> Vec<Library> { extern \"C\" { static __start__: u8; } let bias = core::ptr::addr_of!(__start__) as usize; let mut ret = Vec::new(); let mut segments = Vec::new(); segments.push(LibrarySegment { stated_virtual_memory_address: 0, len: usize::max_value() - bias, }); let path = \"romfs:/debug_info.elf\"; ret.push(Library { name: path.into(), segments, bias, }); ret }",
        "url": 332
    },
    {
        "code_input": "fn emit_mir(slice_iter: &dyn Iterator<Item = &str>) {\n    for (index, item) in slice_iter.enumerate() {\n        println!(\"{}: {}\", index, item);\n    }\n}",
        "nl_input": "EMIT_MIR slice_iter.enumerated_loop.PreCodegen.after.mir",
        "gt": "pub fn enumerated_loop<'a, T>(slice: &'a [T], f: impl Fn(usize, &T)) { for (i, x) in slice.iter().enumerate() { f(i, x) } }",
        "url": 333
    },
    {
        "code_input": "use std::fs;\nuse std::path::Path;\n\nfn is_not_expected(path: &Path, expected: &[&str]) -> bool {\n    let filename = path.file_name().unwrap().to_str().unwrap();\n    !expected.contains(filename)\n}\n\nfn main() {\n    let path = Path::new(\"./test.txt\");\n    let expected = vec![\"file1.txt\", \"file2.txt\", \"file3.txt\"];\n    let result = is_not_expected(&path, &expected);\n    println!(\"{}\", result);\n}",
        "nl_input": "Returns true if the filename at `path` is not in `expected`.",
        "gt": "pub fn filename_not_in_denylist<P: AsRef<Path>, V: AsRef<[String]>>(path: P, expected: V) -> bool { let expected = expected.as_ref(); path.as_ref() .file_name() .is_some_and(|name| !expected.contains(&name.to_str().unwrap().to_owned())) }",
        "url": 334
    },
    {
        "code_input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::time::Duration;\n\nstruct MemTable {\n    value: i32,\n}\n\nimpl MemTable {\n    fn new(value: i32) -> MemTable {\n        MemTable { value }\n    }\n\n    fn write(&mut self, value: i32) {\n        self.value = value;\n    }\n\n    fn flush(&self, duration: Duration) {\n        thread::sleep(duration);\n        println!(\"Flushed value: {}\", self.value);\n    }\n}\n\nfn main() {\n    let mut mem_table = Arc::new(Mutex::new(MemTable::new(0)));\n\n    let mut shared_mem_table = mem_table.clone();\n\n    let write_to_mem_task = thread::spawn(move || {\n        let mut mem_table",
        "nl_input": "Puts a value, returning as soon as the value is written to the memtable but before it is flushed to durable storage.",
        "gt": "fn put(&self, key: Bytes, value: Bytes, attrs: RowAttributes) { self.maybe_subtract_old_val_from_size(key.clone()); self.size.fetch_add( key.len() + value.len() + sizeof_attributes(&attrs), Ordering::Relaxed, ); self.map.insert( key, ValueWithAttributes { value: ValueDeletable::Value(value), attrs, }, ); }",
        "url": 335
    },
    {
        "code_input": "use std::ascii::AsciiExt;\n\nfn is_valid_utf8(s: &str) -> bool {\n    let bytes = s.encode_wide().chain(std::iter::once(0)).collect::<Vec<u16>>();\n    match bytes {\n        Ok(bytes) if bytes.len() > 1 && bytes[0] == 0xFFFD && bytes[1] == 0xFFFC => true,\n        _ => false,\n    }\n}\n\nfn check_signature_lists(signature_lists: Vec<Vec<String>>) -> Vec<Vec<String>> {\n    let mut valid_lists = Vec::new();\n    for list in signature_lists {\n        let mut is_valid = true;\n        for s in list {\n            if !is_valid_utf8(s) {\n                is_valid",
        "nl_input": "Whether the error is due to malformed data in the signature lists",
        "gt": "pub fn key_var_error(&self) -> bool { match self { FormatError::SignatureList(_) | FormatError::SignatureListX509(_) => true, FormatError::AuthVarPkcs7Der(_) | FormatError::AuthVarPkcs7DerHeader(_) => false, } }",
        "url": 336
    },
    {
        "code_input": "impl ClosureKind {\n    pub fn inverse(&self) -> ClosureKind",
        "nl_input": "Inverse of [`Ty::to_opt_closure_kind`]. See docs on that method for explanation of the relationship between `Ty` and [`ty::ClosureKind`].",
        "gt": "pub fn from_closure_kind(tcx: TyCtxt<'tcx>, kind: ty::ClosureKind) -> Ty<'tcx> { match kind { ty::ClosureKind::Fn => tcx.types.i8, ty::ClosureKind::FnMut => tcx.types.i16, ty::ClosureKind::FnOnce => tcx.types.i32, } }",
        "url": 337
    },
    {
        "code_input": "fn main() {\n    let _ = 1_0;\n}",
        "nl_input": "Diagnostic: typed-hole This diagnostic is triggered when an underscore expression is used in an invalid position.",
        "gt": "pub(crate) fn typed_hole(ctx: &DiagnosticsContext<'_>, d: &hir::TypedHole) -> Diagnostic { let display_range = ctx.sema.diagnostics_display_range(d.expr.map(|it| it.into())); let (message, fixes) = if d.expected.is_unknown() { (\"`_` expressions may only appear on the left-hand side of an assignment\".to_owned(), None) } else { ( format!( \"invalid `_` expression, expected type `{}`\", d.expected .display(ctx.sema.db, ctx.edition) .with_closure_style(ClosureStyle::ClosureWithId), ), fixes(ctx, d), ) }; Diagnostic::new(DiagnosticCode::RustcHardError(\"typed-hole\"), message, display_range) .with_fixes(fixes) }",
        "url": 338
    },
    {
        "code_input": "#[derive(Copy, Clone, Debug)]\npub struct OpaqueOrigin;\n\nimpl OpaqueOrigin {\n    pub fn new() -> Self {\n        OpaqueOrigin\n    }\n}",
        "nl_input": "Creates a new opaque origin that is only equal to itself.",
        "gt": "pub fn new_opaque() -> Origin { static COUNTER: AtomicUsize = AtomicUsize::new(0); Origin::Opaque(OpaqueOrigin(COUNTER.fetch_add(1, Ordering::SeqCst))) }",
        "url": 339
    },
    {
        "code_input": "use mio::{AsyncReadExt, AsyncWriteExt, Handle, Mio, Options, Result};\nuse tokio::prelude::*;\n\n#[tokio::main]\nasync fn main() -> Result<()> {\n    let (tx, rx) = Handle::try_pair().await?;\n\n    let tx_handle = tx.into_handle();\n    let rx_handle = rx.into_handle();\n\n    // Use the handles in your code here.\n\n    Ok(())\n}",
        "nl_input": "Offers a new channel, returning a typed handle to get back the original channel when it's revoked.",
        "gt": "pub async fn offer_simple_device<T: 'static + SimpleVmbusDevice>( driver_source: &VmTaskDriverSource, bus: &(impl ParentBus + ?Sized), device: T, ) -> anyhow::Result<SimpleDeviceHandle<T>> { let driver = driver_source.builder().target_vp(0).build(\"simple-vmbus\"); let channel = SimpleDeviceWrapper::new(driver, device); Ok(SimpleDeviceHandle( offer_channel(&driver_source.simple(), bus, channel).await?, )) }",
        "url": 340
    },
    {
        "code_input": "fn main() {\n    let value = \"Hello, world!\";\n    println!(\"{}\", value);\n}",
        "nl_input": "EMIT_MIR casts.redundant.InstSimplify-after-simplifycfg.diff",
        "gt": "pub fn redundant<'a, 'b: 'a>(x: *const &'a u8) -> *const &'a u8 { // CHECK-LABEL: fn redundant( // CHECK: inlined generic_cast // CHECK-NOT: as generic_cast::<&'a u8, &'b u8>(x) as *const &'a u8 }",
        "url": 341
    },
    {
        "code_input": "use std::collections::HashMap;\n\nstruct Transaction {\n    id: u32,\n    // other fields...\n}\n\nstruct Block {\n    transactions: Vec<Transaction>,\n    // other fields...\n}\n\nimpl Block {\n    fn replay_all_transactions(&self) -> Vec<String> {\n        let mut traces = Vec::new();\n\n        for transaction in &self.transactions {\n            // Here you would typically fetch the transaction data from a database or other source.\n            // This is just a placeholder.\n            let trace = format!(\"Transaction {}\", transaction.id);\n            traces.push(trace);\n        }\n\n        traces\n    }\n}\n\nfn main() {\n    let block = Block {\n        transactions: vec![\n            Transaction { id: 1 },\n            Transaction { id: 2 },\n            Transaction { id: 3 },\n        ],",
        "nl_input": "Replays all transactions in a block returning the requested traces for each transaction",
        "gt": "pub async fn trace_replay_block_transactions( &self, block: BlockNumber, trace_types: Vec<TraceType>, ) -> Result<Vec<BlockTrace>> { let _permit = self.permit_request().await; Self::map_err( source_provider!(self, trace_replay_block_transactions(block, trace_types)).await, ) }",
        "url": 342
    },
    {
        "code_input": "use std::path::Path;\n\nfn resolve_path(path: &str) -> Option<String> {\n    let path = Path::new(path);\n    match path.is_absolute() {\n        true => Some(path.to_str().unwrap().to_string()),\n        false => None,\n    }\n}",
        "nl_input": "Resolves the path to an absolute path.",
        "gt": "pub fn resolve(&self, project_root: &Path) -> PathBuf { let native_path = Path::new(self.path.as_str()); if native_path.is_absolute() { native_path.to_path_buf() } else { project_root.join(native_path) } }",
        "url": 343
    },
    {
        "code_input": "use std::io::{Cursor, Read};\n\nfn main() {\n    let mut buffer = Cursor::new(\"Hello, world!\");\n    println!(\"Current position: {}\", buffer.position());\n}",
        "nl_input": "return the lsn the cursor is currently pointing at",
        "gt": "pub fn lsn(&mut self) -> Option<Lsn> { self.state.as_ref().map(|(lsn, _)| *lsn) }",
        "url": 344
    },
    {
        "code_input": "struct Foo<'a> {\n    data: &'a str,\n}\n\nfn struct_with_lt4b<'a>(_foo: &Foo<'a>) -> &'a str {\n    &_foo.data\n}",
        "nl_input": "Warning; two input lifetimes, but the output lifetime is not elided, i.e., the following is valid: fn struct_with_lt4b<'b>(_foo: &Foo<'b>) -> &'b str ^^^^",
        "gt": "fn struct_with_lt4b<'a, 'b>(_foo: &'a Foo<'b>) -> &'b str { unimplemented!() }",
        "url": 345
    },
    {
        "code_input": "fn round_down_to_power_of_two(size: usize) -> usize {\n    if size == 0 {\n        0\n    } else {\n        let mut size = size;\n        size -= 1;\n        while size & (size - 1) != 0 {\n            size &= size - 1;\n        }\n        size\n    }\n}",
        "nl_input": "We have `size < min_align`. Round `size` *down* to the next power of two and use that.",
        "gt": "fn prev_power_of_two(x: u64) -> u64 { let next_pow2 = x.next_power_of_two(); if next_pow2 == x { x } else { next_pow2 / 2 } }",
        "url": 346
    },
    {
        "code_input": "fn main() {\n    let s = \"Hello, world!\";\n    let pattern = \"world\";\n\n    if s.contains(&pattern) {\n        println!(\"Pattern found in string\");\n    } else {\n        println!(\"Pattern not found in string\");\n    }\n}",
        "nl_input": "Provide the patterns that need to be matched.",
        "gt": "pub fn patterns<P: AsRef<Path>>(&mut self, path: P) -> &mut Self { self.cmd.arg(path.as_ref()); self }",
        "url": 347
    },
    {
        "code_input": "use std::panic;\n\npub fn read_result(database_key: &str, changed_revision: u64) -> Result<String, Box<dyn std::error::Error>> {\n    // Your implementation here\n}\n\npub fn check_cycle_participant() -> Result<(), &'static str> {\n    // Your implementation here\n}\n\npub fn process_query(database_key: &str, changed_revision: u64) -> Result<String, Box<dyn std::error::Error>> {\n    if let Err(e) = check_cycle_participant() {\n        return Err(e);\n    }\n\n    if let Err(e) = read_result(database_key, changed_revision) {\n        return Err(e);\n    }\n\n    Ok(",
        "nl_input": "Reports that the currently active query read the result from another query. Also checks whether the \"cycle participant\" flag is set on the current stack frame -- if so, panics with `CycleParticipant` value, which should be caught by the code executing the query. # Parameters - `database_key`: the query whose result was read - `changed_revision`: the last revision in which the result of that query had changed",
        "gt": "pub(crate) fn report_query_read_and_unwind_if_cycle_resulted( &self, input: DatabaseKeyIndex, durability: Durability, changed_at: Revision, ) { self.local_state .report_query_read_and_unwind_if_cycle_resulted(input, durability, changed_at); }",
        "url": 348
    },
    {
        "code_input": "use std::path::Path;\nuse std::str::FromStr;\nuse url::Url;\n\nfn is_requirement(req: &str) -> bool {\n    let url = Url::parse(req);\n    match url {\n        Ok(_) => true,\n        Err(_) => {\n            let path = Path::new(req);\n            match path.to_str() {\n                Ok(_) => true,\n                Err(_) => {\n                    let git_req = req.starts_with(\"git://\") || req.starts_with(\"git@\");\n                    match git_req {\n                        true => true,\n                        false => false,\n                    }\n                }\n            }\n        }\n    }\n}",
        "nl_input": "Returns true if the requirement is a direct dependency. I.e. a url, path or git requirement.",
        "gt": "pub fn is_direct_dependency(&self) -> bool { matches!( self, PyPiRequirement::Git { .. } | PyPiRequirement::Path { .. } | PyPiRequirement::Url { .. } ) }",
        "url": 349
    },
    {
        "code_input": "use std::mem::size_of_val;\n\n#[derive(Default)]\npub struct SafelyOverflowingIndexQueue {\n    capacity: usize,\n    index: usize,\n    data: Vec<u8>,\n}\n\nimpl SafelyOverflowingIndexQueue {\n    pub fn new(capacity: usize) -> Self {\n        Self {\n            capacity,\n            index: 0,\n            data: vec![0; capacity],\n        }\n    }\n\n    pub fn push(&mut self, value: u8) -> Option<usize> {\n        if self.index == self.capacity {\n            return None;\n        }\n\n        self.data[self.index] = value;\n        self.index += 1;\n        Some(self.index)\n    }\n\n    pub fn get_capacity(&self) -> usize {\n        self.capacity\n    }\n\n    pub fn get_size(&self) -> usize {\n        self.index\n    }\n}\n\nfn main() {",
        "nl_input": "Returns the amount of memory required to create a [`SafelyOverflowingIndexQueue`] with the provided capacity.",
        "gt": "pub const fn const_memory_size(capacity: usize) -> usize { unaligned_mem_size::<UnsafeCell<usize>>(capacity + 1) }",
        "url": 350
    },
    {
        "code_input": "use pre_codegen::num_to_digit;\n\nfn main() {\n    let num = 12345;\n    let str_num = num_to_digit(num);\n    println!(\"{}\", str_num);\n}",
        "nl_input": "EMIT_MIR issue_59352.num_to_digit.PreCodegen.after.mir @ compile-flags: -Z mir-opt-level=3 -Z span_free_formats",
        "gt": "pub fn num_to_digit(num: char) -> u32 { if num.is_digit(8) { num.to_digit(8).unwrap() } else { 0 } }",
        "url": 351
    },
    {
        "code_input": "let x = 5;\nmatch x {\n    0 => println!(\"x is zero\"),\n    1 => println!(\"x is one\"),\n    2 => println!(\"x is two\"),\n    _ => println!(\"x is something else\"),\n}",
        "nl_input": "EMIT_MIR matches_reduce_branches.match_u8_i8.MatchBranchSimplification.diff",
        "gt": "fn match_u8_i8(i: EnumAu8) -> i8 { match i { EnumAu8::u0_0x00 => 0, EnumAu8::u127_0x7f => 127, EnumAu8::u128_0x80 => -128, EnumAu8::u255_0xff => -1, } }",
        "url": 352
    },
    {
        "code_input": "fn reverse_vector(input: Vec<i32>) -> Vec<i32> {\n    let mut output = Vec::new();\n    for i in input.iter().rev() {\n        output.push(*i);\n    }\n    output\n}",
        "nl_input": "This function shows quite directly what is going on: We have a reborrow of contents within the box.",
        "gt": "fn return_borrow_from_dropped_box_1(x: Box<&mut u32>) -> &mut u32 { &mut **x }",
        "url": 353
    },
    {
        "code_input": "fn main() {\n    let max_stream_window = 1048576;\n    set_max_stream_window(max_stream_window);\n}\n\nfn set_max_stream_window(max_stream_window: u64) {\n    // Set the initial max stream data\n    let initial_max_stream_data_uni = max_stream_window;\n}",
        "nl_input": "Set the `initial_max_stream_data_uni` transport parameter. The value is capped by the setting `max_stream_window`. The default value is `1048576`.",
        "gt": "pub fn set_initial_max_stream_data_uni(&mut self, v: u64) { self.local_transport_params.initial_max_stream_data_uni = cmp::min(v, self.max_stream_window); }",
        "url": 354
    },
    {
        "code_input": "fn main() {\n    let byte_slice = b\"Hello, world!\";\n    println!(\"The size of the byte slice is: {}\", byte_slice.len());\n}",
        "nl_input": "Computes the size for a byte slice.",
        "gt": "pub fn bytes(mut self, len: usize) { if len != 0 || self.state.in_sequence { self.add(varint_size(len as u64) + len); } }",
        "url": 355
    },
    {
        "code_input": "pub fn evaluate_subpolynomial(coefficients: &Vec<f64>, variable: f64) -> f64 {\n    let mut result = 0.0;\n    for (index, coefficient) in coefficients.iter().enumerate() {\n        result += coefficient * (variable as f64).powf(coefficients.len() - 1 - index as f64);\n    }\n    result\n}",
        "nl_input": "Produce the evaluation of a subpolynomial used in sumcheck",
        "gt": "pub fn produce_sumcheck_subpolynomial_evaluation( &mut self, subpolynomial_type: &SumcheckSubpolynomialType, eval: S, ) { self.sumcheck_evaluation += self.subpolynomial_multipliers[self.produced_subpolynomials] * match subpolynomial_type { SumcheckSubpolynomialType::Identity => { eval * self.mle_evaluations.random_evaluation } SumcheckSubpolynomialType::ZeroSum => eval, }; self.produced_subpolynomials += 1; }",
        "url": 356
    },
    {
        "code_input": "pub struct OfferResources {\n    // Define your fields here\n    // For example, you might have a field for the offer ID, a field for the resource ID, and a field for the quantity\n    offer_id: u32,\n    resource_id: u32,\n    quantity: u32,\n}\n\nimpl OfferResources {\n    // This is a constructor for the `OfferResources` struct\n    pub fn new(offer_id: u32, resource_id: u32, quantity: u32) -> OfferResources {\n        OfferResources {\n            offer_id,\n            resource_id,\n            quantity,\n        }\n    }\n\n    // This method would be used to get the offer ID\n    pub fn get_offer_id(&self) -> u32 {\n        self.offer_id\n    }\n\n    //",
        "nl_input": "Creates a new `OfferResources`.",
        "gt": "pub fn new(untrusted_memory: GuestMemory, private_memory: Option<GuestMemory>) -> Self { OfferResources { untrusted_memory, private_memory, } }",
        "url": 357
    },
    {
        "code_input": "use std::collections::HashMap;\n\n// Assume we have a struct for X509\nstruct X509 {\n    // ...\n}\n\n// Assume we have a struct for SignatureList\nstruct SignatureList {\n    x509: X509,\n    // ...\n}\n\n// Assume we have a function to get the signature list\nfn get_signature_list() -> SignatureList {\n    // ...\n}\n\n// Function to get a single certificate per signature list\nfn get_single_cert_per_signature_list() -> HashMap<String, X509> {\n    let signature_list = get_signature_list();\n\n    // Create a HashMap to store the certificates\n    let mut certificates = HashMap::new();\n\n    // Iterate over the signature list\n    for signature in &signature_list {\n        // If",
        "nl_input": "assume there is only single cert per signature list see comment associated with `SignatureList::X509` for rationale",
        "gt": "fn next_inner(&mut self) -> Result<Option<SignatureData<X509Data<'a>>>, ParseError> { if self.buf.is_empty() { return Ok(None); } let (header, buf) = EFI_SIGNATURE_DATA::read_from_prefix_split(self.buf) .ok_or(ParseError::X509InvalidHeader)?; let val: Cow<'a, [u8]> = buf.into(); let res = SignatureData::new_x509(header.signature_owner, val); self.buf = &[]; Ok(Some(res)) }",
        "url": 358
    },
    {
        "code_input": "fn main() {\n    let x = 5;\n    let y: &'static i32 = &x;\n    println!(\"{}\", y);\n}",
        "nl_input": "lifetime pointers with 'static lifetime are ok",
        "gt": "fn static_lifime_ok<'a,T,U:Send>(_: &'a isize) { assert_send::<&'static isize>(); assert_send::<&'static str>(); assert_send::<&'static [isize]>(); // whether or not they are mutable assert_send::<&'static mut isize>(); }",
        "url": 359
    },
    {
        "code_input": "use std::collections::HashMap;\n\n#[derive(Debug, Clone)]\nstruct AddressOfPair {\n    fn0: Fn0,\n}\n\n#[derive(Debug, Clone)]\nstruct Fn0 {\n    GVN: GVN,\n}\n\n#[derive(Debug, Clone)]\nstruct GVN {\n    diff: i32,\n}\n\nfn main() {\n    let address_of_pair = AddressOfPair {\n        fn0: Fn0 {\n            GVN: GVN {\n                diff: 10,\n            },\n        },\n    };\n\n    println!(\"{}\", address_of_pair.fn0.GVN.diff);\n}",
        "nl_input": "EMIT_MIR address_of_pair.fn0.GVN.diff",
        "gt": "pub fn fn0() -> bool { let mut pair = (1, false); let ptr = core::ptr::addr_of_mut!(pair.1); pair = (1, false); unsafe { *ptr = true; } let ret = !pair.1; return ret; }",
        "url": 360
    },
    {
        "code_input": "I'm sorry, but your request is incomplete. Could you please provide more details about the query you want to write in Rust?\n",
        "nl_input": "@ edition:2018 @ aux-crate:reexported_trait=reexported-trait.rs",
        "gt": "fn main() { reexported_trait::FooStruct.trait_method(); reexported_trait::FooStruct.trait_method_b(); }",
        "url": 361
    },
    {
        "code_input": "use std::error::Error;\n\nfn main() -> Result<(), Box<dyn Error>> {\n    // This will cause a compile error because the function is declared to return a Result,\n    // but the actual return type is an opaque type.\n    //\n    // This is a common error when trying to return a Result from a function that is\n    // expected to return a value. The function is declared to return a Result, but\n    // the actual return type is an opaque type.\n    //\n    // This is a common error when trying to return a Result from a function that is\n    // expected to return a value. The function is declared to return a Result, but\n    // the actual return type is an opaque type.\n    //\n    // This is a common error when trying to return a Result from a function that is\n    // expected to return a value. The function is declared to return a Result, but\n    // the actual return type is an opaque type.\n    //\n    // This is a common error when",
        "nl_input": "~ ERROR unconstrained opaque type",
        "gt": "fn bar<'a: 'a>() where Self::Assoc<'a>:, { let _ = |x: &'a ()| { let _: Self::Assoc<'a> = x; //~^ ERROR `<() as Foo>::Assoc<'a>` captures lifetime that does not appear in bound }; }",
        "url": 362
    },
    {
        "code_input": "use cache::{Cache, SimpleCache};\n\nfn main() {\n    let cache = SimpleCache::new(100);\n\n    // Now you can use the cache in your code\n}",
        "nl_input": "Create a new cache for a model with the given configuration.",
        "gt": "pub fn new(config: &Config) -> Self { let mut blocks = Vec::with_capacity(config.n_layer); for _ in 0..config.n_layer { blocks.push(ParallelBlockCache(None)) } Self { blocks, first_token: true, } }",
        "url": 363
    },
    {
        "code_input": "fn command_handler(command: &str) -> &'static str {\n    match command {\n        \"abort\" => \"I'm sorry, that command couldn't be aborted.\",\n        _ => \"I'm sorry, but I don't understand that command.\",\n    }\n}",
        "nl_input": "Abort is a required command, but a legal implementation is to just complete it with a status that means \"I'm sorry, that command couldn't be aborted.\"",
        "gt": "fn handle_abort(&self) -> Result<Option<CommandResult>, NvmeError> { Ok(Some(CommandResult { status: spec::Status::SUCCESS, dw: [1, 0], })) }",
        "url": 364
    },
    {
        "code_input": "fn main() {\n    let points = vec![\n        (1, 1),\n        (2, 2),\n        (3, 3),\n        (4, 4),\n        (5, 5),\n    ];\n\n    let (max_x, max_y) = points.iter().fold((0, 0), |(max_x, max_y), &(x, y)| {\n        (max_x.max(x), max_y.max(y))\n    });\n\n    println!(\"Max x: {}, Max y: {}\", max_x, max_y);\n}",
        "nl_input": "Determine the uppermost bounds for the x and y axis",
        "gt": "fn find_bounds(stats: &StatsResponse) -> (f64, f64) { let mut max_length = 0; let mut max_value = f64::MIN; for dataset in &[&stats.dns_queries_chart, &stats.blocked_filtering_chart] { let length = dataset.len(); if length > max_length { max_length = length; } let max_in_dataset = dataset .iter() .map(|&(_, y)| y) .fold(f64::MIN, f64::max); if max_in_dataset > max_value { max_value = max_in_dataset; } } (max_length as f64, max_value) }",
        "url": 365
    },
    {
        "code_input": "use std::process::Command;\n\nfn main() {\n    let output = Command::new(\"ls\")\n        .arg(\"-l\")\n        .output()\n        .expect(\"Failed to execute ls command\");\n\n    if !output.status.success() {\n        println!(\"Command failed with status: {}\", output.status);\n    } else {\n        let output_str = String::from_utf8_lossy(&output.stdout);\n        println!(\"{}\", output_str);\n    }\n}",
        "nl_input": "@ run-fail @ check-run-results @ exec-env:RUST_BACKTRACE=0 ignore-tidy-linelength",
        "gt": "fn main() { assert!(1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20 + 21 + 22 + 23 + 24 + 25 == 0); }",
        "url": 366
    },
    {
        "code_input": "use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};\nuse near_sdk::{env, near_bindgen};\n\n#[near_bindgen]\n#[derive(BorshDeserialize, BorshSerialize)]\npub struct Transfer {\n    pub from: String,\n    pub to: String,\n    pub amount: u128,\n}\n\nimpl Transfer {\n    pub fn new(from: String, to: String, amount: u1",
        "nl_input": "Calls the contract's `transferFrom` (0x23b872dd) function",
        "gt": "pub fn transfer_from( &self, from: ::ethers::core::types::Address, to: ::ethers::core::types::Address, token_id: ::ethers::core::types::U256, ) -> ::ethers::contract::builders::ContractCall<M, ()> { self.0 .method_hash([35, 184, 114, 221], (from, to, token_id)) .expect(\"method not found (this should never happen)\") }",
        "url": 367
    },
    {
        "code_input": "use crate::ast::{PathType, TraitRef};\n\npub fn path_type_to_trait_ref(path_type: &PathType) -> TraitRef {\n    match path_type {\n        PathType::Name(name) => TraitRef::Name(name),\n        PathType::Key(key) => TraitRef::Key(key),\n    }\n}",
        "nl_input": "Converts an `ast::PathType` to a `hir::TraitRef`.",
        "gt": "pub(crate) fn from_ast(ctx: &mut LowerCtx<'_>, node: ast::Type) -> Option<Self> { match node { ast::Type::PathType(path) => { path.path().and_then(|it| ctx.lower_path(it)).map(|path| TraitRef { path }) } _ => None, } }",
        "url": 368
    },
    {
        "code_input": "use std::io::{self, Write};\n\nfn main() {\n    // Read a null-terminated sequence of bytes\n    let mut input = String::new();\n    io::stdin().read_line(&mut input).unwrap();\n\n    // Perform path separator conversion if needed\n    let output = if input.contains('/') {\n        // Replace '/' with '\\\\'\n        input.replace('/', \"\\\\\")\n    } else {\n        // No conversion needed\n        input\n    };\n\n    // Write the output\n    io::stdout().write_all(output.as_bytes()).unwrap();\n}",
        "nl_input": "Read a null-terminated sequence of bytes, and perform path separator conversion if needed.",
        "gt": "fn read_path_from_c_str<'a>(&'a self, ptr: Pointer) -> InterpResult<'tcx, Cow<'a, Path>> where 'tcx: 'a, { let this = self.eval_context_ref(); let os_str = this.read_os_str_from_c_str(ptr)?; interp_ok(match this.convert_path(Cow::Borrowed(os_str), PathConversion::TargetToHost) { Cow::Borrowed(x) => Cow::Borrowed(Path::new(x)), Cow::Owned(y) => Cow::Owned(PathBuf::from(y)), }) }",
        "url": 369
    },
    {
        "code_input": "use near_sdk::{env, near_bindgen};\n\n#[near_bindgen]\nimpl env::contract {\n    #[init]\n    fn new(_delegate: env::delegate::Delegate) {}\n\n    #[finality(\"final\")]\n    fn asset_recipient(&self, _msg: env::msg::Msg) {\n        let contract_id = env::current_account_id();\n        let contract_account = env::account_info(contract_id).unwrap();\n        let contract_account_id = contract_account.account_id.to_string_lossy();\n\n        // Replace with your actual contract's address\n        let contract_address = \"0x3bfa67fe\".to_string_lossy();\n\n        // Call the contract's",
        "nl_input": "Calls the contract's `assetRecipient` (0x3bfa67fe) function",
        "gt": "pub fn asset_recipient( &self, ) -> ::ethers::contract::builders::ContractCall< M, ::ethers::core::types::Address, > { self.0 .method_hash([59, 250, 103, 254], ()) .expect(\"method not found (this should never happen)\") }",
        "url": 370
    },
    {
        "code_input": "use bx::{Query, QueryBuilder, Result};\n\nfn main() {\n    let mut query = Query::new();\n    query.add_field(\"field1\", \"value1\");\n    query.add_field(\"field2\", \"value2\");\n    query.add_field(\"field3\", \"value3\");\n\n    let result: Result<Query> = query.build();\n\n    match result {\n        Ok(query) => {\n            println!(\"Query: {:?}\", query);\n        },\n        Err(error) => {\n            println!(\"Error: {:?}\", error);\n        },\n    }\n}",
        "nl_input": "Important: we *cannot* use bx.emit() here, because this is called in contexts where the emitter is already locked. Doing so may cause subtle rare bugs.",
        "gt": "pub fn def(self, bx: &builder::Builder<'_, '_>) -> Word { self.def_with_span(bx, bx.span()) }",
        "url": 371
    },
    {
        "code_input": "use std::path::Path;\nuse std::fs;\nuse std::env;\n\nfn get_url(path: &str) -> Result<Url, Box<dyn std::error::Error>> {\n    let path = Path::new(path);\n    let is_windows = env::var(\"os\").unwrap().to_lowercase().contains(\"windows\");\n\n    if is_windows {\n        let path_str = match path.to_str() {\n            Ok(s) => s,\n            Err(_) => return Err(\"Path is not a valid Windows path\".into()),\n        };\n\n        let url = Url::from_file_path(path_str).map_err(|e| e.into())?;\n        Ok(url)\n    } else {\n        let url = Url::from_file_path(path).map_err(|e| e.into())?;\n        Ok(url)\n    }\n}",
        "nl_input": "Returns a `Url` object from a given path, will lowercase drive letters if present. This will only happen when processing windows paths. When processing non-windows path, this is essentially the same as `Url::from_file_path`.",
        "gt": "pub(crate) fn url_from_abs_path(path: &AbsPath) -> lsp_types::Url { let url = lsp_types::Url::from_file_path(path).unwrap(); match path.components().next() { Some(Utf8Component::Prefix(prefix)) if matches!(prefix.kind(), Utf8Prefix::Disk(_) | Utf8Prefix::VerbatimDisk(_)) => { } _ => return url, } let driver_letter_range = { let (scheme, drive_letter, _rest) = match url.as_str().splitn(3, ':').collect_tuple() { Some(it) => it, None => return url, }; let start = scheme.len() + ':'.len_utf8(); start..(start + drive_letter.len()) }; let mut url: String = url.into(); url[driver_letter_range].make_ascii_lowercase(); lsp_types::Url::parse(&url).unwrap() }",
        "url": 372
    },
    {
        "code_input": "use mode::*;\n\nfn is_dyn_thread_safe() -> bool {\n    // Check if the mode is dyna thread safe\n    // This is a placeholder, replace with actual logic\n    true\n}",
        "nl_input": "This function only works when `mode::is_dyn_thread_safe()`.",
        "gt": "pub fn scope<'scope, OP, R>(op: OP) -> R where OP: FnOnce(&rayon::Scope<'scope>) -> R + DynSend, R: DynSend, { let op = FromDyn::from(op); rayon::scope(|s| FromDyn::from(op.into_inner()(s))).into_inner() }",
        "url": 373
    },
    {
        "code_input": "fn main() {\n    let _ = || {\n        let _ = Noisy(1);\n        let _ = Noisy(2);\n        // Control flow is broken here\n        Foo(Noisy(1), Noisy(2))\n    };\n}\n\nstruct Noisy(i32);\n\nstruct Foo(Noisy, Noisy);",
        "nl_input": "In this case, the control flow break happens *before* we construct `Foo(Noisy(1),Noisy(2))`, so there should be no record of it in the event log.",
        "gt": "fn leak_3_ret() -> Foo { let _old_foo = || Foo { n0: Noisy(1), n1: Noisy(2) }; Foo { n1: { return Foo { n0: Noisy(3), n1: Noisy(4) } }, .._old_foo() }; }",
        "url": 374
    },
    {
        "code_input": "use futures::prelude::*;\nuse std::error::Error;\nuse tokio::prelude::*;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn Error>> {\n    let mut runtime = Runtime::try_block_on_or_unwind(|| {\n        // Your code here\n    });\n\n    // Handle the result of the future\n    match runtime.wait().await {\n        Ok(output) => {\n            println!(\"{}\", output);\n            Ok(())\n        },\n        Err(error) => {\n            eprintln!(\"Error: {}\", error);\n            Err(error.into())\n        },\n    }\n}",
        "nl_input": "Helper: see [`Runtime::try_block_on_or_unwind`].",
        "gt": "fn block_on_or_unwind<MutexGuard>( &self, db: &<Q as QueryDb<'_>>::DynDb, runtime: &Runtime, other_id: RuntimeId, mutex_guard: MutexGuard, ) { runtime.block_on_or_unwind( db.ops_database(), self.database_key_index(), other_id, mutex_guard, ) }",
        "url": 375
    },
    {
        "code_input": "let x: i32 = 5;",
        "nl_input": "Create a variable, where we already know the scope and index it will be bound to",
        "gt": "pub fn new(scope: usize, index: usize) -> Self { Self { internal: VariableInternal::Static(VariableScope { scope: scope as u16, index: index as u16, }), } }",
        "url": 376
    },
    {
        "code_input": "use std::thread;\nuse std::time::Duration;\n\n// Assume these are defined elsewhere in your code\n\nstruct Vfs;\nstruct ThreadPool;\n\nimpl Vfs {\n    fn dispatch_request(&self, _request: &str) -> Result<(), Duration> {\n        // This is a placeholder for the actual request dispatching.\n        // In a real implementation, you would need to implement this.\n        Ok(())\n    }\n}\n\nimpl ThreadPool {\n    fn dispatch_request(&self, vfs: &Vfs, request: &str) -> Result<(), Duration> {\n        // This is a placeholder for the actual request dispatching.\n        // In a real implementation, you would need to implement this.\n        vfs.dispatch_request(request)\n    }\n}\n\nfn main() {\n    let vfs = Vfs;\n    let thread_pool = ThreadPool;\n\n    let request = \"some",
        "nl_input": "Dispatches a non-latency-sensitive request onto the thread pool. When the VFS is marked not ready this will return a `default` constructed [`R::Result`].",
        "gt": "pub(crate) fn on_with<R>( &mut self, f: fn(GlobalStateSnapshot, R::Params) -> anyhow::Result<R::Result>, default: impl FnOnce() -> R::Result, on_cancelled: fn() -> ResponseError, ) -> &mut Self where R: lsp_types::request::Request< Params: DeserializeOwned + panic::UnwindSafe + Send + fmt::Debug, Result: Serialize, > + 'static, { if !self.global_state.vfs_done { if let Some(lsp_server::Request { id, .. }) = self.req.take_if(|it| it.method == R::METHOD) { self.global_state.respond(lsp_server::Response::new_ok(id, default())); } return self; } self.on_with_thread_intent::<true, false, R>(ThreadIntent::Worker, f, on_cancelled) }",
        "url": 377
    },
    {
        "code_input": "use std::io::{self, Write};\n\nfn main() {\n    let mut buf: [u8; 4] = [0; 4];\n    let mut input = io::stdin().lock();\n    input.read(&mut buf).unwrap();\n    let result = u32::from_be_bytes(buf);\n    println!(\"{}\", result);\n}",
        "nl_input": "Read a pointer-sized unsigned integer from a place.",
        "gt": "pub fn read_target_usize( &self, op: &impl Projectable<'tcx, M::Provenance>, ) -> InterpResult<'tcx, u64> { self.read_scalar(op)?.to_target_usize(self) }",
        "url": 378
    },
    {
        "code_input": "use std::fs::File;\nuse std::io::BufReader;\nuse serde::Deserialize;\n\n#[derive(Debug, Deserialize)]\nstruct Config {\n    channels: Vec<Channel>,\n}\n\n#[derive(Debug, Deserialize)]\nstruct Channel {\n    name: String,\n    config: ChannelConfig,\n}\n\n#[derive(Debug, Deserialize)]\nstruct ChannelConfig {\n    default: bool,\n    // other fields...\n}\n\nfn main() {\n    let file = File::open(\"config.toml\").expect(\"Failed to open config file\");\n    let reader = BufReader::new(file);\n    let config: Config = toml::from_reader(reader).expect(\"Failed to parse config file\");\n\n    for channel in &config.channels {\n        println!(\"Channel:",
        "nl_input": "Parses the channels, getting channel config and default channels from config",
        "gt": "pub(crate) fn resolve_from_config(&self, config: &Config) -> miette::Result<IndexSet<Channel>> { self.resolve(config.global_channel_config(), config.default_channels()) }",
        "url": 379
    },
    {
        "code_input": "use ethers::types::Event;\nuse ethers::prelude::*;\n\nfn get_token_deposit_events(provider: &Provider, address: &str) -> Result<Vec<Event>, Box<dyn Error>> {\n    let filter = Event::Filter {\n        from_block: None,\n        to_block: None,\n        address: Some(address),\n        topics: Some(vec![\n            \"0xddf252ad1be2c89b69c2b068fc378a1e893669256c160e61f00a604970f88efa\".parse::<HexString>()?,\n            \"0x000000000000000000000000000",
        "nl_input": "Gets the contract's `TokenDeposit` event",
        "gt": "pub fn token_deposit_filter( &self, ) -> ::ethers::contract::builders::Event< ::std::sync::Arc<M>, M, TokenDepositFilter, > { self.0.event() }",
        "url": 380
    },
    {
        "code_input": "extern crate pnet;\nuse pnet::net::Ipv4;\nuse pnet::net::Ipv6;\nuse pnet::net::Ip;\n\nfn get_linear_ip() -> Option<Ip> {\n    let ipv4 = Ipv4::new();\n    let ipv6 = Ipv6::new();\n\n    match ipv4.get_ip() {\n        Ok(ip) => Some(ip),\n        Err(_) => match ipv6.get_ip() {\n            Ok(ip) => Some(ip),\n            Err(_) => None,\n        },\n    }\n}",
        "nl_input": "Gets the linear IP of the CPU, taking into account the code segment. Returns None if IP EIP does not fit into the code segment.",
        "gt": "pub fn linear_ip(&self, offset: u64) -> Option<u64> { let rip = self.state.rip.wrapping_add(offset); match self.state.bitness() { Bitness::Bit64 => Some(rip), Bitness::Bit32 | Bitness::Bit16 => { self.verify_segment_access( Register::CS, OperationKind::AddressComputation, offset, 1, ) .ok()?; let cs = &self.state.segs[CpuState::CS]; Some(cs.base.wrapping_add(rip)) } } }",
        "url": 381
    },
    {
        "code_input": "fn count_elements(row: &Vec<i32>) -> usize {\n    row.len()\n}",
        "nl_input": "Returns the number of elements in `row`.",
        "gt": "pub fn count(&self, row: R) -> usize { let (start, end) = self.range(row); self.words[start..end].iter().map(|e| e.count_ones() as usize).sum() }",
        "url": 382
    },
    {
        "code_input": "pub struct Position {\n    line: usize,\n    column: usize,\n}\n\nimpl Position {\n    pub fn new(line: usize, column: usize) -> Self {\n        Self { line, column }\n    }\n\n    pub fn set_line(&mut self, line: usize) {\n        self.line = line;\n    }\n\n    pub fn set_column(&mut self, column: usize) {\n        self.column = column;\n    }\n\n    pub fn get_line(&self) -> usize {\n        self.line\n    }\n\n    pub fn get_column(&self) -> usize {\n        self.column\n    }\n}\n\npub fn is_local_variable_initialized_at_current_cursor_position() -> bool {\n    // This is a placeholder. The actual implementation depends on the context.",
        "nl_input": "Returns `true` if the local variable (or some part of it) is initialized at the current cursor position. Callers should call one of the `seek` methods immediately before to point the cursor to the desired location.",
        "gt": "fn initialized_at_curr_loc(&self, mpi: MovePathIndex) -> bool { let state = self.flow_inits.get(); if state.contains(mpi) { return true; } let move_paths = &self.flow_inits.analysis().move_data().move_paths; move_paths[mpi].find_descendant(move_paths, |mpi| state.contains(mpi)).is_some() }",
        "url": 383
    },
    {
        "code_input": "#[doc(hidden)]\npub fn query_items(items: Vec<&str>) -> Vec<&str> {\n    items.into_iter().filter(|item| !item.contains(\"#[doc(hidden)]\")).collect()\n}",
        "nl_input": "Strip items marked `#[doc(hidden)]`",
        "gt": "pub(crate) fn strip_hidden(krate: clean::Crate, cx: &mut DocContext<'_>) -> clean::Crate { let mut retained = ItemIdSet::default(); let is_json_output = cx.is_json_output(); let krate = { let mut stripper = Stripper { retained: &mut retained, update_retained: true, tcx: cx.tcx, is_in_hidden_item: false, last_reexport: None, }; stripper.fold_crate(krate) }; let mut stripper = ImplStripper { tcx: cx.tcx, retained: &retained, cache: &cx.cache, is_json_output, document_private: cx.render_options.document_private, document_hidden: cx.render_options.document_hidden, }; stripper.fold_crate(krate) }",
        "url": 384
    },
    {
        "code_input": "use std::vec::Vec;\n\nfn llama_eval(logits: &Vec<f32>) -> Vec<f32> {\n    let n_tokens = logits.len();\n    let n_vocab = *logits.last().unwrap();\n\n    let mut probabilities = Vec::with_capacity(n_tokens);\n\n    for _ in 0..n_tokens {\n        probabilities.push(0.0);\n    }\n\n    probabilities\n}\n\nfn main() {\n    let logits = vec![1.0, 2.0, 3.0, 4.0, 5.0];\n    let probabilities = llama_eval(&logits);\n\n    for probability in probabilities {\n        println!(\"{}\", probability);\n    }\n}",
        "nl_input": "Token logits obtained from the last call to llama_eval() The logits for the last token are stored in the last row Can be mutated in order to change the probabilities of the next token Rows: n_tokens Cols: n_vocab",
        "gt": "pub fn llama_get_logits_as_slice(&self, n_tokens: usize, n_vocab: usize) -> Vec<f32> { let len = n_tokens * n_vocab; unsafe { std::slice::from_raw_parts_mut(llama_get_logits(self.ctx), len) }.to_vec() }",
        "url": 385
    },
    {
        "code_input": "fn is_valid_number(s: &str) -> bool {\n    match s.parse::<f64>() {\n        Ok(_) => true,\n        Err(_) => false,\n    }\n}",
        "nl_input": "The span is that of the surrounding type pattern expr whatever.",
        "gt": "fn visit_qpath(&mut self, qpath: &'v QPath<'v>, id: HirId, _span: Span) -> Self::Result { walk_qpath(self, qpath, id) }",
        "url": 386
    },
    {
        "code_input": "pub struct ValueAddedMapper {\n    map: std::collections::HashMap<String, String>,\n}\n\nimpl ValueAddedMapper {\n    pub fn new() -> ValueAddedMapper {\n        ValueAddedMapper {\n            map: std::collections::HashMap::new(),\n        }\n    }\n\n    pub fn add(&mut self, key: String, value: String) {\n        self.map.insert(key, value);\n    }\n\n    pub fn get(&self, key: &String) -> Option<&String> {\n        self.map.get(key)\n    }\n}",
        "nl_input": "Returns a VA mapper for this guest memory. This will single instance the mapper, so this is safe to call multiple times.",
        "gt": "pub async fn new_mapper(&self) -> Result<Arc<VaMapper>, VaMapperError> { MAPPER_CACHE .get_or_insert_with(&self.id, async { VaMapper::new(self.req_send.clone(), self.max_addr, None).await }) .await }",
        "url": 387
    },
    {
        "code_input": "fn main() {\n    let y = |x: i32| {\n        x * 2\n    };\n    println!(\"{}\", y(5));\n}",
        "nl_input": "The type of `y` ends up getting inferred to the type of the block.",
        "gt": "fn broken() { let mut x = 3; let mut _y = vec![&mut x]; while x < 10 { let mut z = x; _y.push(&mut z); x += 1; } }",
        "url": 388
    },
    {
        "code_input": "pub fn get_enum_variant_name<T>(enum_variant: T, idx: usize) -> Option<&str>\nwhere\n    T: std::fmt::Debug + std::fmt::Display + std::marker::Copy + std::cmp::Ord + std::cmp::PartialEq + std::cmp::PartialOrd + std::cmp::Eq + std::cmp::Ord + std::cmp::PartialEq + std::cmp::PartialOrd + std::cmp::Eq + std::cmp::Ord + std::cmp::PartialEq + std::cmp::PartialOrd + std::cmp::Eq + std::cmp::Ord + std::cmp::PartialEq + std::cmp::PartialOrd + std::cmp::Eq + std::cmp::Ord + std::cmp::PartialEq + std::cmp::PartialOrd + std::cmp::Eq",
        "nl_input": "Gets the name of a enum variant with index `idx`",
        "gt": "pub fn variant_name(ty: Ty, idx: u32) -> crate::IString { match ty.kind() { TyKind::Adt(adt_def, _subst) => { let variant_def = &adt_def.variants()[idx.into()]; variant_def.name.to_string().into() } _ => todo!(\"Can't yet get fields of typr {ty:?}\"), } }",
        "url": 389
    },
    {
        "code_input": "pub fn check_result(eax: u32, ecx: u32) -> bool {\n    // Implement your own logic here to check the result\n    // For example, you can compare the result to a specific value\n    eax == ecx\n}",
        "nl_input": "Returns true if this result is intended for the given `eax` and `ecx` input values.",
        "gt": "pub fn matches(&self, eax: u32, ecx: u32) -> bool { self.function == eax && (self.index.is_none() || self.index == Some(ecx)) }",
        "url": 390
    },
    {
        "code_input": "#[cfg(any(target_os = \"windows\", target_os = \"macos\", target_os = \"linux\"))]\npub fn enum_to_natvis(e: &'static dyn AnyEnum) -> String {\n    use std::any::Any;\n    use std::any::type_name;\n    use std::str;\n\n    let mut s = String::new();\n    s.push_str(\"enum \");\n    s.push_str(type_name(e as &dyn Any));\n    s.push_str(\" {\\n\");\n\n    for variant in e.iter().unwrap().variants() {\n        s.push_str(\"    \");\n        s.push_str(str::replace(&variant.name, \"::\", \":: \", \"::\"));\n        s.push_str(\" = \");\n        s.push_str(str::replace(&variant.value, \"::\", \":: \", \"::\"));\n        s.push_str(\",\\n\");\n    }\n\n    s.",
        "nl_input": "MSVC names enums differently than other platforms so that the debugging visualization format (natvis) is able to understand enums and render the active variant correctly in the debugger. For more information, look in rustc_codegen_llvm src debuginfo metadata enums cpp_like.rs.",
        "gt": "fn msvc_enum_fallback<'tcx>( tcx: TyCtxt<'tcx>, ty_and_layout: TyAndLayout<'tcx>, push_inner: &dyn Fn(/*output*/ &mut String, /*visited*/ &mut FxHashSet<Ty<'tcx>>), output: &mut String, visited: &mut FxHashSet<Ty<'tcx>>, ) { assert!(!wants_c_like_enum_debuginfo(tcx, ty_and_layout)); output.push_str(\"enum2$<\"); push_inner(output, visited); push_close_angle_bracket(true, output); }",
        "url": 391
    },
    {
        "code_input": "use chrono::prelude::*;\nuse futures_util::StreamExt;\nuse ndarray::Array;\nuse ndarray_rand::rand_distr::Uniform;\nuse ndarray_rand::RandomExt;\nuse ndarray_rand::Random;\nuse serde::Deserialize;\nuse tokio::net::TcpStream;\nuse tokio_util::compat::TokioAsyncWrite;\n\n#[derive(Debug, Deserialize)]\nstruct Document {\n    id: u32,\n    timestamp: DateTime<chrono::Local>,\n    data: String,\n}\n\n#[tokio::main]\nasync fn main() {\n    let (client, stream) = tokio::net::tcp_stream().into_stream().await;\n    let mut writer = stream.into_writable();\n\n    let page_size = 10;\n    let start_time",
        "nl_input": "Loads documents within the given table and the given timestamp range. page_size is how many documents to fetch with a single query. It doesn't affect load_documents results, just efficiency of the internal queries. NOTE: The filter is implemented entirely in memory. We can potentially add indexes to the documents table to allow for an efficient database version of this query, but have not yet done so.",
        "gt": "fn load_documents_from_table( &self, tablet_id: TabletId, range: TimestampRange, order: Order, page_size: u32, retention_validator: Arc<dyn RetentionValidator>, ) -> DocumentStream<'_> { self.load_documents(range, order, page_size, retention_validator) .try_filter(move |(_, doc_id, _)| future::ready(doc_id.table() == tablet_id)) .boxed() }",
        "url": 392
    },
    {
        "code_input": "#![feature(memcpy)]\n#![feature(copy_nonoverlapping)]\n\nuse std::mem;\n\nfn main() {\n    let mut a: [u8; 10] = [0; 10];\n    let mut b: [u8; 10] = [1; 10];\n    mem::copy_nonoverlapping(&mut a, &mut b);\n    println!(\"{:?}\", a);\n}",
        "nl_input": "@compile-flags: -Zmiri-permissive-provenance C's memcpy is 0 bytes is UB for some pointers that are allowed in Rust's `copy_nonoverlapping`.",
        "gt": "fn main() { let from = 42 as *const u8; let to = 23 as *mut u8; unsafe { to.copy_from(from, 0); libc::memcpy(to.cast(), from.cast(), 0); } }",
        "url": 393
    },
    {
        "code_input": "pub fn get_current_payload(payloads: &Vec<String>, offset: usize) -> Option<&str> {\n    if offset < payloads.len() {\n        Some(&payloads[offset])\n    } else {\n        None\n    }\n}",
        "nl_input": "Gets the current payload, or None if the end was reached. This function takes care of moving to the next payload buffer if the current offset matches the end.",
        "gt": "fn get_payload(&mut self) -> Option<&'payload VirtioQueuePayload> { let payload = self.current?; if self.offset == payload.length as usize { self.next_payload(); self.offset = 0; } self.current }",
        "url": 394
    },
    {
        "code_input": "fn check_error_message(args: &[&str]) -> Result<(), &str> {\n    for arg in args {\n        if !arg.contains(\"error:\") {\n            return Err(\"Error message not found in arguments\");\n        }\n    }\n    Ok(())\n}",
        "nl_input": "Check that all arguments are shown in the error message, even if they're across multiple lines.",
        "gt": "fn bar( a: i32, b: i32, c: i32, d: i32, e: i32, f: i32, ) { println!(\"{}\", a); println!(\"{}\", b); println!(\"{}\", c); println!(\"{}\", d); println!(\"{}\", e); println!(\"{}\", f); }",
        "url": 395
    },
    {
        "code_input": "use std::collections::HashMap;\nuse std::env;\nuse std::fs;\nuse std::process;\n\nuse spirv_builder::{Builder, BuilderConfig, Result};\n\nfn main() -> Result<()> {\n    let mut args = env::args().collect::<Vec<_>>();\n    args.remove(0); // remove the program name\n\n    let mut config = BuilderConfig::default();\n\n    for arg in args.iter() {\n        match arg {\n            \"--target-env\" => {\n                let target_env = env::var(\"TARGET_ENV\").unwrap();\n                config.target_env(target_env)\n            }\n            \"--target-triple\" => {\n                let target_triple = env::var(\"TARGET_TRIPLE\").unwrap();\n                config.target_triple(target_triple)\n            }\n            \"--enable-debug-info\" => config.enable_debug_info(true),\n            \"--disable-debug-info\" => config.enable_debug_info(false),",
        "nl_input": "The RUSTFLAGS passed to all SPIR-V builds. FIXME(eddyb) expose most of these from `spirv-builder`.",
        "gt": "fn rust_flags(codegen_backend_path: &Path) -> String { let target_features = [ \"Int8\", \"Int16\", \"Int64\", \"Float64\", \"ShaderClockKHR\", \"ext:SPV_KHR_shader_clock\", ]; [ &*format!(\"-Zcodegen-backend={}\", codegen_backend_path.display()), \"-Zbinary-dep-depinfo\", \"-Csymbol-mangling-version=v0\", \"-Zcrate-attr=feature(register_tool)\", \"-Zcrate-attr=register_tool(rust_gpu)\", \"-Coverflow-checks=off\", \"-Cdebug-assertions=off\", \"-Zinline-mir=off\", \"-Zmir-enable-passes=-GVN\", \"-Cdebuginfo=2\", \"-Cembed-bitcode=no\", &format!(\"-Ctarget-feature=+{}\", target_features.join(\",+\")), ] .join(\" \") }",
        "url": 396
    },
    {
        "code_input": "fn main() {\n    let x = 5;\n    let y = 10;\n    let z = x + y;\n\n    println!(\"{}\", z);\n}",
        "nl_input": "Verify that we can thread jumps when we assign from an aggregate constant.",
        "gt": "fn aggregate(x: u8) -> u8 { const FOO: (u8, u8) = (5, 13); let (a, b) = FOO; if a == 7 { b } else { a } }",
        "url": 397
    },
    {
        "code_input": "use reqwest::Error;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Serialize, Deserialize, Debug)]\nstruct HierarchyControlRequest {\n    auth_handle: String,\n    hierarchy: String,\n    state: bool,\n}\n\n#[derive(Serialize, Deserialize, Debug)]\nstruct HierarchyControlResponse {\n    status: String,\n    message: String,\n}\n\nasync fn send_hierarchy_control(auth_handle: String, hierarchy: String, state: bool) -> Result<HierarchyControlResponse, Error> {\n    let client = reqwest::Client::new();\n    let request_body = HierarchyControlRequest {\n        auth_handle,",
        "nl_input": "Helper function to send HierarchyControl command. # Arguments * `auth_handle`: The authorization handle used in the command. * `hierarchy`: The hierarchy to control. * `state`: Enable the target hierarchy or not.",
        "gt": "pub fn hierarchy_control( &mut self, auth_handle: ReservedHandle, hierarchy: ReservedHandle, state: bool, ) -> Result<(), TpmCommandError> { use tpm20proto::protocol::HierarchyControlCmd; let session_tag = SessionTagEnum::Sessions; let mut cmd = HierarchyControlCmd::new( session_tag.into(), auth_handle, CmdAuth::new(TPM20_RS_PW, 0, 0, 0), hierarchy, state, ); self.tpm_engine .execute_command(cmd.as_bytes_mut(), &mut self.reply_buffer) .map_err(TpmCommandError::TpmExecuteCommand)?; match HierarchyControlCmd::base_validate_reply(&self.reply_buffer, session_tag) { Err(error) => Err(TpmCommandError::InvalidResponse(error))?, Ok((res, false)) => Err(TpmCommandError::TpmCommandFailed { response_code: res.header.response_code.get(), })?, Ok((_res, true)) => Ok(()), } }",
        "url": 398
    },
    {
        "code_input": "struct MyStruct {\n    _unused_field: u32,\n    _unused_field_2: u32,\n}\n\nimpl MyStruct {\n    fn method_with_self(&self) -> bool {\n        // Your method logic here\n        true\n    }\n}\n\nfn main() {\n    let my_instance = MyStruct {\n        _unused_field: 0,\n        _unused_field_2: 0,\n    };\n\n    if my_instance.method_with_self() {\n        // Do something\n    }\n}",
        "nl_input": "Check that underscore and unused bindings within and outwith more complex patterns are dropped after the method with self is polled.",
        "gt": "async fn foobar_async( &'a self, ref mut x: D, (ref mut a, _, ref mut _c): (D, D, D), _: D, ref mut _y: D, ) { x.1.borrow_mut().push(DropOrder::Function); }",
        "url": 399
    },
    {
        "code_input": "pub enum MPace {\n    None,\n    Some(String),\n    Some(i32),\n}\n\npub fn mpace_to_str(pace: &MPace) -> Option<String> {\n    match *pace {\n        MPace::None => None,\n        MPace::Some(value) => Some(value.clone()),\n        MPace::Some(value) => Some(value.clone()),\n    }\n}",
        "nl_input": "Turn the wide MPlace into a string (must already be dereferenced!)",
        "gt": "pub fn read_str(&self, mplace: &MPlaceTy<'tcx, M::Provenance>) -> InterpResult<'tcx, &str> { let len = mplace.len(self)?; let bytes = self.read_bytes_ptr_strip_provenance(mplace.ptr(), Size::from_bytes(len))?; let str = std::str::from_utf8(bytes).map_err(|err| err_ub!(InvalidStr(err)))?; interp_ok(str) }",
        "url": 400
    },
    {
        "code_input": "use interrupt::{Interrupt, InterruptController};\n\nfn main() {\n    // Create a new InterruptController\n    let mut ic = InterruptController::new().unwrap();\n\n    // Create a new Interrupt\n    let mut interrupt = ic.create_interrupt(Interrupt::IRQ0).unwrap();\n\n    // Set the interrupt handler\n    interrupt.set_handler(|int| {\n        println!(\"Interrupt received!\");\n        // You can also return an error or handle the interrupt in another way\n        Ok(())\n    }).unwrap();\n\n    // Enable the interrupt\n    interrupt.enable().unwrap();\n\n    // Keep the program running\n    loop {}\n}",
        "nl_input": "Signals the interrupt if it is enabled.",
        "gt": "pub fn _signal(&self) { if self.enabled.load(Ordering::Relaxed) { if let Some(event) = &self.irqfd_event { event.signal(); } else if let Some(partition) = self.partition.upgrade() { assert!(cfg!(target_arch = \"x86_64\")); partition .kvm .irq_line(self.gsi, true) .expect(\"interrupt delivery failure\"); } } }",
        "url": 401
    },
    {
        "code_input": "use std::sync::{Arc, Mutex};\n\nstruct Request {\n    // your request data here\n}\n\nstruct WorkQueue {\n    work_queue: Vec<Arc<Request>>,\n    mutex: Mutex<Vec<Arc<Request>>>,\n}\n\nimpl WorkQueue {\n    fn new() -> Self {\n        Self {\n            work_queue: Vec::new(),\n            mutex: Mutex::new(Vec::new()),\n        }\n    }\n\n    fn push(&mut self, request: Arc<Request>) {\n        let mut work_queue = self.mutex.lock().unwrap();\n        work_queue.push(request);\n    }",
        "nl_input": "Gets the work queue for sending requests.",
        "gt": "pub fn wq(&self) -> queues::Wq { if self.is_send { queues::Wq::new_sq(self.wq_mem.clone(), self.doorbell.clone(), self.wq_id) } else { queues::Wq::new_rq(self.wq_mem.clone(), self.doorbell.clone(), self.wq_id) } }",
        "url": 402
    },
    {
        "code_input": "use std::net::TcpStream;\nuse std::io::{Read, Write};\n\n#[derive(Debug)]\nstruct Message {\n    id: MessageID,\n    data: String,\n}\n\nfn receive_message(stream: &mut TcpStream) -> Result<Message, <TcpStream as ReadWrite>::Error> {\n    let mut buffer = [0; 1024];\n    let len = stream.read(&mut buffer)?;\n    let message_id = MessageID::from_slice(&buffer[0..len]);\n\n    let mut data = [0; 1024];\n    let len = stream.read(&mut data)?;\n\n    Ok(Message {\n        id: message_id,\n        data: String::from_utf8_lossy(&data[0..len]),\n    })\n}\n\nfn main() {\n    let",
        "nl_input": "Waits for a response message from the host. The caller is responsible for validating the message ID.",
        "gt": "async fn recv_response(&mut self) -> Vec<u8> { self.response_message_recv .as_mut() .unwrap() .recv() .await .unwrap() }",
        "url": 403
    },
    {
        "code_input": "use std::path::Path;\n\nfn windows_to_unix(path: &str) -> String {\n    let path = Path::new(path);\n    match path.is_absolute() {\n        true => path.to_str().unwrap().replace(\"\\\\\", \"/\"),\n        false => path.to_str().unwrap(),\n    }\n}",
        "nl_input": "Adjust a Unix path to Windows conventions such that it un-does everything that `windows_to_unix` did, and such that if the Unix input path was absolute, then the Windows output path is absolute.",
        "gt": "fn unix_to_windows<T>(path: &mut Vec<T>) where T: From<u8> + Copy + Eq, { let sep = T::from(b'\\\\'); for c in path.iter_mut() { if *c == b'/'.into() { *c = sep; } } if path.get(2..4) == Some(&[b':'.into(), sep]) && path[0] == sep { path.remove(0); } else if path.first() == Some(&sep) && path.get(1) != Some(&sep) { path.splice(0..0, [sep, sep, b'?'.into()]); } }",
        "url": 404
    },
    {
        "code_input": "I'm sorry, but the code you've provided is not clear. It seems like there are multiple notes in the text, but the actual code is not provided. Could you please provide the code you want to write in Rust?\n",
        "nl_input": "~^ NOTE function defined here ~| NOTE function defined here ~| NOTE function defined here ~| NOTE function defined here ~| NOTE function defined here ~| NOTE function defined here ~| NOTE function defined here ~| NOTE function defined here ~| NOTE function defined here ~| NOTE function defined here ~| NOTE function defined here ~| NOTE ~| NOTE ~| NOTE ~| NOTE ~| NOTE ~| NOTE ~| NOTE ~| NOTE ~| NOTE ~| NOTE ~| NOTE",
        "gt": "fn main() { foo::<u32>(42_usize); foo::<u32>(42_u64); foo::<u32>(42_u32); foo::<u32>(42_u16); foo::<u32>(42_u8); foo::<u32>(42_isize); foo::<u32>(42_i64); foo::<u32>(42_i32); foo::<u32>(42_i16); foo::<u32>(42_i8); foo::<u32>(42.0_f64); foo::<u32>(42.0_f32); }",
        "url": 405
    },
    {
        "code_input": "fn main() {\n    let s = \"Hello, world!\";\n    let upper_s = s.to_uppercase().collect::<String>();\n    println!(\"{}\", upper_s);\n}",
        "nl_input": "rustfmt-format_strings: true",
        "gt": "fn foo() -> &'static str { let sql = \"ATTACH DATABASE ':memory:' AS my_attached; BEGIN; CREATE TABLE my_attached.foo(x INTEGER); INSERT INTO my_attached.foo VALUES(42); END;\"; sql }",
        "url": 406
    },
    {
        "code_input": "pub fn opcode_to_byte(opcode: u8) -> u8 {\n    opcode\n}",
        "nl_input": "Convert an opcode to a byte opcode.",
        "gt": "fn from(value: Opcode) -> Self { match value { Opcode::AND => Self::AND, Opcode::OR => Self::OR, Opcode::XOR => Self::XOR, Opcode::SLL => Self::SLL, _ => panic!(\"Invalid opcode for ByteChip: {value:?}\"), } }",
        "url": 407
    },
    {
        "code_input": "use reqwest::Error;\nuse serde_json::json;\n\nfn add_to_batch(key: &str, value: &str) -> Result<String, Error> {\n    let batch = json::object(\n        vec![\n            (\"key\".to_string(), json::String(key.to_string())),\n            (\"value\".to_string(), json::String(value.to_string())),\n        ]\n    )?;\n\n    Ok(batch)\n}\n\nfn main() {\n    let key = \"my_key\";\n    let value = \"my_value\";\n\n    match add_to_batch(key, value) {\n        Ok(batch) => println!(\"{}\", batch),\n        Err(e) => eprintln!(\"Error: {}\", e),\n    }\n}",
        "nl_input": "Put a key-value pair into the batch. Keys must not be empty.",
        "gt": "pub fn put_with_options(&mut self, key: &[u8], value: &[u8], options: &PutOptions) { assert!(!key.is_empty(), \"key cannot be empty\"); self.ops.push(WriteOp::Put( Bytes::copy_from_slice(key), Bytes::copy_from_slice(value), options.clone(), )); }",
        "url": 408
    },
    {
        "code_input": "use std::collections::HashMap;\nuse std::path::PathBuf;\n\npub struct DocLinkResolutions {\n    resolutions: HashMap<PathBuf, bool>,\n}\n\nimpl DocLinkResolutions {\n    pub fn new() -> Self {\n        Self {\n            resolutions: HashMap::new(),\n        }\n    }\n\n    pub fn add(&mut self, path: PathBuf, is_resolved: bool) {\n        self.resolutions.insert(path, is_resolved);\n    }\n\n    pub fn get(&self, path: &PathBuf) -> Option<bool> {\n        self.resolutions.get(path)\n    }\n\n    pub fn remove(&mut self, path: &PathBuf) {\n        self.resolutions.remove(path);\n    }\n\n    pub fn clear(&mut self) {\n        self.resolutions.clear();\n    }\n}",
        "nl_input": "Convenience wrapper around `doc_link_resolutions`. This also handles resolving `true` and `false` as booleans. NOTE: `doc_link_resolutions` knows only about paths, not about types. Associated items will never be resolved by this function.",
        "gt": "fn resolve_path( &self, path_str: &str, ns: Namespace, item_id: DefId, module_id: DefId, ) -> Option<Res> { if let res @ Some(..) = self.resolve_self_ty(path_str, ns, item_id) { return res; } let result = self .cx .tcx .doc_link_resolutions(module_id) .get(&(Symbol::intern(path_str), ns)) .copied() .unwrap_or_else(|| { span_bug!( self.cx.tcx.def_span(item_id), \"no resolution for {path_str:?} {ns:?} {module_id:?}\", ) }) .and_then(|res| res.try_into().ok()) .or_else(|| resolve_primitive(path_str, ns)); debug!(\"{path_str} resolved to {result:?} in namespace {ns:?}\"); result }",
        "url": 409
    },
    {
        "code_input": "use image::{ImageFormat, RgbImage};\nuse nalgebra::{Vector3, Matrix4, Point3, Vector2};\n\nfn detect_text_pixels(image_path: &str) -> Result<Vec<Vector3<f32>>, Box<dyn std::error::Error>> {\n    let image = RgbImage::from_file(image_path)?;\n    let (width, height) = image.dimensions();\n\n    let mut pixels: Vec<Vector3<f32>> = vec![];\n\n    for y in 0..height {\n        for x in 0..width {\n            let pixel = image.get(x, y);\n            let (r, g, b) = pixel.into_channels();\n            let intensity = (r as f32 + g as f32 + b as f32) / 3.0;",
        "nl_input": "Detect text pixels in an image. Returns an (H, W) tensor indicating the probability of each pixel in the input being part of a text word. This is a low-level API that is useful for debugging purposes. Use [detect_words](OcrEngine::detect_words) for a higher-level API that returns oriented bounding boxes of words.",
        "gt": "pub fn detect_text_pixels(&self, input: &OcrInput) -> anyhow::Result<NdTensor<f32, 2>> { if let Some(detector) = self.detector.as_ref() { detector.detect_text_pixels(input.image.view(), self.debug) } else { Err(anyhow!(\"Detection model not loaded\")) } }",
        "url": 410
    },
    {
        "code_input": "fn main() {\n    for i in 1..=10 {\n        println!(\"{}\", i);\n    }\n}",
        "nl_input": "The range of the identifier that is being completed.",
        "gt": "pub(crate) fn source_range(&self) -> TextRange { let kind = self.original_token.kind(); match kind { CHAR => { cov_mark::hit!(completes_if_lifetime_without_idents); TextRange::at(self.original_token.text_range().start(), TextSize::from(1)) } LIFETIME_IDENT | UNDERSCORE | INT_NUMBER => self.original_token.text_range(), _ if kind.is_any_identifier() => self.original_token.text_range(), _ => TextRange::empty(self.position.offset), } }",
        "url": 411
    },
    {
        "code_input": "use web3::{Client, types::Address, types::HexString};\nuse serde_json::Value;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Create a new client\n    let client = Client::new(\"http://localhost:8545\")?;\n\n    // The address of the contract\n    let contract_address = Address::from_str(\"0x70a08231",
        "nl_input": "Calls the contract's `balanceOf` (0x70a08231) function",
        "gt": "pub fn balance_of( &self, p0: ::ethers::core::types::Address, ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::U256> { self.0 .method_hash([112, 160, 130, 49], p0) .expect(\"method not found (this should never happen)\") }",
        "url": 412
    },
    {
        "code_input": "use std::collections::HashMap;\n\nfn main() {\n    let mut region_to_guest_address = HashMap::new();\n\n    region_to_guest_address.insert(\"Region1\", \"Guest1Address\");\n    region_to_guest_address.insert(\"Region2\", \"Guest2Address\");\n    region_to_guest_address.insert(\"Region3\", \"Guest3Address\");\n\n    println!(\"{:?}\", region_to_guest_address);\n}",
        "nl_input": "Maps this region to a guest address.",
        "gt": "pub async fn map(&self, params: MapParams) { self.req_send .call(RegionRequest::MapRegion, (self.id.unwrap(), params)) .await .unwrap() }",
        "url": 413
    },
    {
        "code_input": "use reqwest::Error;\nuse serde_json::Value;\n\n#[tokio::main]\nasync fn main() -> Result<(), Error> {\n    let resp = reqwest::get(\"https://api.github.com/users/github\").await?;\n    let root: Value = resp.json().await?;\n    println!(\"{:#?}\", root);\n    Ok(())\n}",
        "nl_input": "Does not need `Pin`, but other implementation do.",
        "gt": "pub unsafe fn park_timeout(self: Pin<&Self>, dur: Duration) { if self.state.fetch_sub(1, Acquire) == NOTIFIED { return; } let nanos = dur.as_nanos().try_into().unwrap_or(i64::MAX); let timeout = dispatch_time(DISPATCH_TIME_NOW, nanos); let timeout = dispatch_semaphore_wait(self.semaphore, timeout) != 0; let state = self.state.swap(EMPTY, Acquire); if state == NOTIFIED && timeout { while dispatch_semaphore_wait(self.semaphore, DISPATCH_TIME_FOREVER) != 0 {} } else { } }",
        "url": 414
    },
    {
        "code_input": "fn process_string(s: &str) -> String {\n    let mut new_s = s.to_string();\n    if new_s.contains(' ') {\n        new_s.replace(\" \", \"$1\");\n    }\n    format!(\"${}\", new_s)\n}",
        "nl_input": "Will add <$1> to the refname if it contains spaces",
        "gt": "fn completion_text_edit(&self, display: Option<&str>, refname: &str) -> CompletionTextEdit { let ext = if self.settings().include_md_extension_md_link { \".md\" } else { \"\" }; let link_ref_text = match refname.contains(' ') { true => format!(\"<{}{}>\", refname, ext), false => format!(\"{}{}\", refname, ext), }; CompletionTextEdit::Edit(TextEdit { range: Range { start: Position { line: self.line_nr as u32, character: self.full_range.start as u32, }, end: Position { line: self.line_nr as u32, character: self.full_range.end as u32, }, }, new_text: format!(\"[{}]({})\", display.unwrap_or(\"\"), link_ref_text), }) }",
        "url": 415
    },
    {
        "code_input": "use reqwest::Error;\nuse tokio::net::TcpStream;\nuse tokio::sync::mpsc;\nuse tokio::prelude::*;\n\n#[tokio::main]\nasync fn main() -> Result<(), Error> {\n    // Create a channel to communicate between the request and response handlers.\n    let (tx, rx) = mpsc::channel();\n\n    // Start a new task to handle the request.\n    let request_handler = async {\n        // Wait for a request.\n        let request = rx.recv().await?;\n\n        // Send a response.\n        let response = format!(\"Got request: {}\", request);\n        tx.send(response).await?;\n\n        Ok(())\n    };\n\n    // Start a new task to handle the response.\n    let response_handler = async {\n        // Wait for a response",
        "nl_input": "Pushes a host request handler that sends a single host request and waits for its response.",
        "gt": "fn push_basic_host_request_handler<Req, I, Resp>( &mut self, req: mesh::rpc::Rpc<I, Resp>, f: impl 'static + Send + FnOnce(I) -> Req, ) where Req: AsBytes + 'static + Send + Sync, I: 'static + Send, Resp: 'static + AsBytes + FromBytes + Send, { self.push_host_request_handler(|mut access| { req.handle_must_succeed(move |input| async move { access.send_request_fixed_size(&f(input)).await }) }); }",
        "url": 416
    },
    {
        "code_input": "fn main() {\n    let mut x = 5;\n    let y = &mut x;\n    println!(\"{}\", y);\n}",
        "nl_input": "Temporarily takes out another immutable handle on the same location.",
        "gt": "pub fn reborrow(&self) -> Handle<NodeRef<marker::Immut<'_>, K, V, NodeType>, HandleType> { // We can't use Handle::new_kv or Handle::new_edge because we don't know our type Handle { node: self.node.reborrow(), idx: self.idx, _marker: PhantomData } }",
        "url": 417
    },
    {
        "code_input": "fn main() {\n    let slice_iter = // your iterator here;\n\n    // Iterate over the range of the iterator\n    for value in slice_iter.range_loop {\n        // Emit the value\n        println!(\"{}\", value);\n    }\n}",
        "nl_input": "EMIT_MIR slice_iter.range_loop.PreCodegen.after.mir",
        "gt": "pub fn range_loop<'a, T>(slice: &'a [T], f: impl Fn(usize, &T)) { for i in 0..slice.len() { let x = &slice[i]; f(i, x) } }",
        "url": 418
    },
    {
        "code_input": "fn main() {\n    let message = \"Hello, world!\";\n    println!(\"{}\", message);\n}",
        "nl_input": "EMIT_MIR dont_ice_on_generic_rust_call.call.Inline.diff",
        "gt": "pub fn call<I: Tuple>(mut mock: Box<dyn FnMut<I, Output = ()>>, input: I) { mock.call_mut(input) }",
        "url": 419
    },
    {
        "code_input": "fn insert_suffix_into_filename(filename: &str, suffix: &str) -> String {\n    let (name, ext) = filename.split_period().collect::<Vec<&str>>().into_iter().collect::<Vec<_>>();\n    format!(\"{}.{}\", name.join(\".\"), suffix.concat(ext))\n}\n\nfn main() {\n    let filename = \"example\";\n    let suffix = \"_suffix\";\n    println!(\"{}\", insert_suffix_into_filename(filename, suffix));\n}",
        "nl_input": "Insert the provided suffix into a filename just before the extension.",
        "gt": "pub(crate) fn suffix_path(filename: &str, suffix: &str) -> PathBuf { let (base, ext) = filename.split_once('.').unwrap(); let filename = format!(\"{base}{suffix}.{ext}\"); filename.into() }",
        "url": 420
    },
    {
        "code_input": "use std::mem;\n\nfn main() {\n    let num = 42;\n    let block = mem::transmute(&num as usize as *const u8 as *const _>();\n    println!(\"{:?}\", block);\n}",
        "nl_input": "Get a `Block` of memory representing this immediate.",
        "gt": "pub fn as_block(&self) -> Block<F> { match self { Imm::F(f) => Block::from(*f), Imm::EF(ef) => ef.as_base_slice().into(), } }",
        "url": 421
    },
    {
        "code_input": "use std::collections::HashMap;\n\nstruct MediaSession {\n    id: String,\n    current: bool,\n}\n\nstruct MediaManager {\n    sessions: HashMap<String, MediaSession>,\n}\n\nimpl MediaManager {\n    fn new() -> MediaManager {\n        MediaManager {\n            sessions: HashMap::new(),\n        }\n    }\n\n    fn update_session_id(&mut self, old_id: &str, new_id: &str) {\n        if let Some(session) = self.sessions.get_mut(old_id) {\n            session",
        "nl_input": "Updates the current media session ID and marks the correct session as the current one.",
        "gt": "fn update_current_session( &mut self, manager: &GsmtcManager, ) -> anyhow::Result<()> { self.current_session_id = manager .GetCurrentSession() .ok() .and_then(|session| session.SourceAppUserModelId().ok()) .map(|session_id| session_id.to_string()); for (session_id, state) in self.session_states.iter_mut() { state.output.is_current_session = Some(session_id) == self.current_session_id.as_ref(); } Ok(()) }",
        "url": 422
    },
    {
        "code_input": "pub fn format_channel_id(channel_id: u64) -> u64 {\n    channel_id\n}",
        "nl_input": "Format a connection ID for a given channel.",
        "gt": "pub fn new(channel_id: u32, vtl: Vtl, sint: u8) -> Self { Self(channel_id | (sint as u32) << 12 | (vtl as u32) << 16) }",
        "url": 423
    },
    {
        "code_input": "pub fn remove_cycle(participants: &mut Vec<String>) -> Option<String> {\n    let mut active_query = None;\n\n    for (i, participant) in participants.iter_mut().enumerate() {\n        if *participant == \"active_query\" {\n            active_query = Some(i.clone());\n        }\n    }\n\n    active_query.map(|i| participants.remove(i))\n}",
        "nl_input": "If the active query is registered as a cycle participant, remove and return that cycle.",
        "gt": "pub(crate) fn take_cycle(&self) -> Option<Cycle> { self.local_state.with_query_stack(|stack| stack.last_mut()?.cycle.take()) }",
        "url": 424
    },
    {
        "code_input": "fn has_trailing_semicolon(func: &str) -> bool {\n    let last_char = func.chars().last();\n    match last_char {\n        Some(';') => true,\n        _ => false,\n    }\n}",
        "nl_input": "Returns whether the given nested function has a trailing semicolon.",
        "gt": "fn has_semicolon(function: &ast::Fn) -> bool { function .syntax() .next_sibling_or_token() .map(|t| t.kind() == SyntaxKind::SEMICOLON) .unwrap_or(false) }",
        "url": 425
    },
    {
        "code_input": "pub struct Node {\n    data: i32,\n    next: Option<Box<Node>>,\n}\n\nimpl Node {\n    pub fn new(data: i32) -> Node {\n        Node {\n            data: data,\n            next: None,\n        }\n    }\n\n    pub fn borrow_data(&self) -> i32 {\n        self.data\n    }\n}",
        "nl_input": "Borrows exclusive access to the data of an internal node.",
        "gt": "fn as_internal_mut(&mut self) -> &mut InternalNode<K, V> { let ptr = Self::as_internal_ptr(self); unsafe { &mut *ptr } }",
        "url": 426
    },
    {
        "code_input": "use crate::Level;\nuse annotate_snippets::Level as AnnotateLevel;\n\nfn map_levels(input: Vec<crate::Level>) -> Vec<AnnotateLevel> {\n    input.into_iter().map(|level| level.into()).collect()\n}",
        "nl_input": "Maps [`crate::Level`] to [`annotate_snippets::Level`]",
        "gt": "fn annotation_level_for_level(level: Level) -> annotate_snippets::Level { match level { Level::Bug | Level::Fatal | Level::Error | Level::DelayedBug => { annotate_snippets::Level::Error } Level::ForceWarning(_) | Level::Warning => annotate_snippets::Level::Warning, Level::Note | Level::OnceNote => annotate_snippets::Level::Note, Level::Help | Level::OnceHelp => annotate_snippets::Level::Help, Level::FailureNote => annotate_snippets::Level::Error, Level::Allow => panic!(\"Should not call with Allow\"), Level::Expect(_) => panic!(\"Should not call with Expect\"), } }",
        "url": 427
    },
    {
        "code_input": "pub trait Tr {\n    // This is a placeholder for the actual trait methods\n}\n\npub fn check_lifetimes() {\n    // Checking for 'static lifetimes\n    let x: &'static i32 = 0;\n    let y: &'static i32 = &x;\n    let z: &'static i32 = &mut x;\n    let w: &'static i32 = &mut y;\n    let v: &'static i32 = &mut z;\n    let u: &'static i32 = &mut w;\n    let t: &'static i32 = &mut v;\n    let s: &'static i32 = &mut u;\n\n    // Checking for 'static lifetimes in the impls\n    impl<A> Tr for A { }\n    impl Tr for &'static i3",
        "nl_input": "Check that `'static` lifetimes are not introduced by the specializing impl. For example forbid the following: ```ignore (illustrative) impl<A> Tr for A { } impl Tr for &'static i32 { } ```",
        "gt": "fn check_static_lifetimes<'tcx>( tcx: TyCtxt<'tcx>, parent_args: &Vec<GenericArg<'tcx>>, span: Span, ) -> Result<(), ErrorGuaranteed> { if tcx.any_free_region_meets(parent_args, |r| r.is_static()) { return Err(tcx.dcx().emit_err(errors::StaticSpecialize { span })); } Ok(()) }",
        "url": 428
    },
    {
        "code_input": "I'm sorry, but your question seems to be incomplete. Could you please provide more details or context? Are you asking for help with a specific Rust code snippet?\n",
        "nl_input": "~^^ ERROR `d1` does not live long enough",
        "gt": "fn f_mwsa() { let (_d, d1); d1 = D_HasMethodWithSelfArg(1); _d = D_HasMethodWithSelfArg(&d1); }",
        "url": 429
    },
    {
        "code_input": "use std::collections::HashMap;\n\nfn main() {\n    let mut map = HashMap::new();\n    map.insert(\"key1\", \"value1\");\n    map.insert(\"key2\", \"value2\");\n    map.insert(\"key3\", \"value3\");\n    map.insert(\"key4\", \"value4\");\n    map.insert(\"key5\", \"value5\");\n\n    let _ = map.get(\"key1\");\n    let _ = map.get(\"key2\");\n    let _ = map.get(\"key3\");\n    let _ = map.get(\"key4\");\n    let _ = map.get(\"key5\");\n\n    let _ = map.get(\"key6\");\n    let _ = map.get(\"key7\");\n    let _ = map.get(\"key8\");\n    let _ = map.get(\"key9\");\n    let _ = map.get(\"key10\");\n}",
        "nl_input": "All of these should trigger the lint.",
        "gt": "fn not_ok() { { let ptr = cstring().as_ptr(); consume(ptr); } consume({ let ptr = cstring().as_ptr(); ptr }); consume({ let s = cstring(); s.as_ptr() }); let _ptr: *const u8 = cstring().as_ptr().cast(); let _ptr: *const u8 = { cstring() }.as_ptr().cast(); let _ptr: *const u8 = { cstring().as_ptr() }.cast(); }",
        "url": 430
    },
    {
        "code_input": "use std::collections::HashMap;\n\n#[derive(Debug)]\nstruct Place {\n    discriminant: i32,\n}\n\n#[derive(Debug)]\nstruct Places {\n    places: HashMap<String, Place>,\n}\n\nimpl Places {\n    fn new() -> Self {\n        Places {\n            places: HashMap::new(),\n        }\n    }\n\n    fn assign_discriminant(&mut self, name: &str, discriminant: i32) {\n        self.places.insert(name.to_string(), Place { discriminant });\n    }\n\n    fn get_discriminant(&self, name: &str) -> Option<&i32> {\n        self.places.get",
        "nl_input": "Assign `TOP` to the discriminant of `place` and all places that may alias it.",
        "gt": "pub fn flood_discr(&mut self, place: PlaceRef<'_>, map: &Map<'_>) where V: HasTop, { self.flood_discr_with(place, map, V::TOP) }",
        "url": 431
    },
    {
        "code_input": "use std::collections::HashMap;\n\npub struct Madt {\n    entries: Vec<HashMap<String, String>>,\n}\n\nimpl Madt {\n    pub fn new() -> Madt {\n        Madt {\n            entries: Vec::new(),\n        }\n    }\n\n    pub fn add_entry(&mut self, entry: HashMap<String, String>) {\n        self.entries.push(entry);\n    }\n\n    pub fn iter(&self) -> std::collections::Iter<HashMap<String, String>> {\n        self.entries.iter()\n    }\n}",
        "nl_input": "Returns an iterator to parse the MADT entries.",
        "gt": "pub fn entries(&self) -> MadtIter<'_> { MadtIter { entries: &self.0[size_of::<Madt>()..], } }",
        "url": 432
    },
    {
        "code_input": "use std::path::Path;\nuse std::fs;\nuse std::collections::HashMap;\nuse rust_ast::{Node, SyntaxTree};\n\nfn find_location(node: &Node, module_map: &HashMap<String, Node>) -> Node {\n    match node.parent {\n        Some(parent) => find_location(parent, module_map),\n        None => {\n            match module_map.get(&node.file.to_string()) {\n                Some(module) => module,\n                None => node,\n            }\n        }\n    }\n}\n\nfn main() {\n    let file_path = \"path/to/your/file.rs\";\n    let file_content = fs::read_to_string(file_path).unwrap();\n    let syntax_tree = SyntaxTree::new(&file_content);\n    let module_map = syntax_tree.modules.",
        "nl_input": "Finds where to put the new enum definition. Tries to find the ast node at the nearest module or at top-level, otherwise just returns the input node.",
        "gt": "fn node_to_insert_before(target_node: SyntaxNode) -> SyntaxNode { target_node .ancestors() .take_while(|it| !matches!(it.kind(), SyntaxKind::MODULE | SyntaxKind::SOURCE_FILE)) .filter(|it| ast::Item::can_cast(it.kind())) .last() .unwrap_or(target_node) }",
        "url": 433
    },
    {
        "code_input": "fn process_vec(input: Vec<i32>) -> Vec<i32> {\n    let mut output = Vec::new();\n    for i in input {\n        let mut temp = i;\n        match temp {\n            x if x > 0 => temp = x + 1,\n            _ => temp = 0,\n        }\n        output.push(temp);\n    }\n    output\n}",
        "nl_input": "Should trigger lint when either side of an assign expression contains a temporary with a significant drop, because the temporary's lifetime will be extended to the end of the match. To avoid potential unnecessary copies or creating references that would trigger the significant drop problem, the lint recommends moving the entire binary operation.",
        "gt": "fn should_trigger_lint_in_assign_expr() { let mutex = Mutex::new(StateWithIntField { i: 10 }); let mut i = 100; match mutex.lock().unwrap().i = i { _ => { println!(\"{}\", mutex.lock().unwrap().i); }, }; match i = mutex.lock().unwrap().i { _ => { println!(\"{}\", mutex.lock().unwrap().i); }, }; match mutex.lock().unwrap().i += 1 { _ => { println!(\"{}\", mutex.lock().unwrap().i); }, }; match i += mutex.lock().unwrap().i { _ => { println!(\"{}\", mutex.lock().unwrap().i); }, }; }",
        "url": 434
    },
    {
        "code_input": "pub struct Message {\n    content: String,\n    data: Vec<String>,\n}\n\npub struct MessageQueue {\n    messages: Vec<Message>,\n}\n\nimpl MessageQueue {\n    pub fn new() -> MessageQueue {\n        MessageQueue {\n            messages: Vec::new(),\n        }\n    }\n\n    pub fn enqueue(&mut self, message: Message) {\n        self.messages.push(message);\n    }\n\n    pub fn dequeue(&mut self) -> Option<Message> {\n        self.messages.remove(0)\n    }\n\n    pub fn peek(&self) -> Option<&Message> {\n        self.messages.",
        "nl_input": "Consumes and returns the first message from the incoming message queue if there are any messages available.",
        "gt": "pub fn try_recv(&mut self) -> Result<U, TryRecvError> { self.generic .try_recv()? .try_parse() .or_else(|m| lazy_parse(m, &mut self.deserialize)) .map_err(|err| TryRecvError::Error(err.into())) }",
        "url": 435
    },
    {
        "code_input": "use std::io::prelude::*;\n\nfn main() {\n    let mut stdout = std::io::stdout().lock().unwrap();\n    let mut buffer = vec![0; 1024];\n    let len = stdout.read(&mut buffer).unwrap();\n    let output_str = String::from_utf8_lossy(&buffer[..len]);\n    println!(\"{}\", output_str);\n}",
        "nl_input": "Retrieves the IO memory. Panics if the IO has started and has not yet completed.",
        "gt": "pub fn into_mem(mut self) -> T { match std::mem::replace(&mut self.state, IoState::Invalid) { IoState::Started(_) => { panic!(\"io is not complete\"); } IoState::NotStarted(_, io_mem) | IoState::Completed(_, io_mem) => io_mem, IoState::Invalid => unreachable!(), } }",
        "url": 436
    },
    {
        "code_input": "use std::collections::HashMap;\n\nfn main() {\n    let mut match_map: HashMap<String, String> = HashMap::new();\n    match_map.insert(\"key1\".to_string(), \"value1\".to_string());\n    match_map.insert(\"key2\".to_string(), \"value2\".to_string());\n    match_map.insert(\"key3\".to_string(), \"value3\".to_string());\n\n    let mut result_map: HashMap<String, String> = HashMap::new();\n\n    for (key, value) in &match_map {\n        if key == \"key2\" {\n            result_map.insert(key.clone(), value.clone());\n        }\n    }\n\n    println!(\"{:?}\", result_map);\n}",
        "nl_input": "Matching errors are added to the `Match`.",
        "gt": "pub(super) fn match_(pattern: &MetaTemplate, input: &tt::Subtree<Span>, edition: Edition) -> Match { let mut res = match_loop(pattern, input, edition); res.bound_count = count(res.bindings.bindings()); return res; fn count<'a>(bindings: impl Iterator<Item = &'a Binding>) -> usize { bindings .map(|it| match it { Binding::Fragment(_) => 1, Binding::Empty => 1, Binding::Missing(_) => 1, Binding::Nested(it) => count(it.iter()), }) .sum() } }",
        "url": 437
    },
    {
        "code_input": "use reqwest::Error;\nuse serde_json::Value;\n\n#[tokio::main]\nasync fn main() -> Result<(), Error> {\n    // Define the URL and the raw parts\n    let url = \"http://example.com\";\n    let raw_parts: Value = /* your raw parts here */;\n\n    // Convert the raw parts to a JSON string\n    let json_str = serde_json::to_string(&raw_parts)?;\n\n    // Make a POST request to the URL with the JSON string as the body\n    let response = reqwest::post(url)\n        .body(json_str)\n        .send()\n        .await?\n        .text()\n        .await?;\n\n    // Print the response\n    println!(\"{}\", response);\n\n    // Return a success result\n    Ok(())\n}",
        "nl_input": "Create a new document from the raw parts.",
        "gt": "pub fn from_parts(title: impl Into<String>, body: impl Into<String>) -> Self { Self { title: title.into(), body: body.into(), summary: None, created_at: None, updated_at: None, } }",
        "url": 438
    },
    {
        "code_input": "use web3::{Client, types::Address, types::Hex};\nuse serde_json::Value;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Create a new client\n    let client = Client::new(\"http://localhost:8545\")?;\n\n    // The address of the contract\n    let contract_address = Address::from_str(\"0xddca3f43\")?;\n\n    // The ABI",
        "nl_input": "Calls the contract's `fee` (0xddca3f43) function",
        "gt": "pub fn fee(&self) -> ::ethers::contract::builders::ContractCall<M, u128> { self.0 .method_hash([221, 202, 63, 67], ()) .expect(\"method not found (this should never happen)\") }",
        "url": 439
    },
    {
        "code_input": "use std::process::Command;\n\nfn is_app_installed(app_name: &str) -> bool {\n    let output = Command::new(app_name)\n        .output()\n        .expect(\"Failed to execute command\");\n\n    if output.status.success() {\n        true\n    } else {\n        false\n    }\n}",
        "nl_input": "Checks if an application is installed and available in the system PATH. Returns `true` if the application is found in PATH, `false` otherwise.",
        "gt": "fn is_app_installed(app_name: &str) -> bool { #[cfg(target_os = \"windows\")] { std::process::Command::new(\"where\") .arg(app_name) .output() .map(|output| output.status.success()) .unwrap_or(false) } #[cfg(any(target_os = \"macos\", target_os = \"linux\"))] { std::process::Command::new(\"which\") .arg(app_name) .output() .map(|output| output.status.success()) .unwrap_or(false) } }",
        "url": 440
    },
    {
        "code_input": "pub fn set_gid_lines(worksheet: &mut Worksheet, visible: bool) {\n    worksheet.gid_lines = vec![visible; worksheet.gid_lines.len()];\n}",
        "nl_input": "Set the gid lines in the worksheet to visible (`true`) or hidden (`false`)",
        "gt": "pub fn set_show_grid_lines(&mut self, sheet: u32, show_grid_lines: bool) -> Result<(), String> { let old_value = self.model.workbook.worksheet(sheet)?.show_grid_lines; self.model.set_show_grid_lines(sheet, show_grid_lines)?; self.push_diff_list(vec![Diff::SetShowGridLines { sheet, new_value: show_grid_lines, old_value, }]); Ok(()) }",
        "url": 441
    },
    {
        "code_input": "pub fn is_type<T, n>(value: T) -> bool {\n    value == n\n}",
        "nl_input": "# Safety Caller must ensure the attribute type `n` matches type `T`.",
        "gt": "unsafe fn set_attribute<T>(&mut self, n: u32, val: T) { let ptr = unsafe { AlpcGetMessageAttribute(&mut self.header, n).cast::<T>() }; let ptr = NonNull::new(ptr).unwrap().as_ptr(); unsafe { ptr.write(val) }; self.header.ValidAttributes |= n; }",
        "url": 442
    },
    {
        "code_input": "pub fn reserve_exact<T, E>(vec: &mut Vec<T>, count: u32) -> Result<Vec<T>, E> {\n    if vec.len() < count {\n        return Err(E::NotEnoughSpace);\n    }\n\n    let mut new_vec = vec![];\n    for _ in 0..count {\n        new_vec.push(vec.remove(0));\n    }\n\n    Ok(new_vec)\n}",
        "nl_input": "The same as `reserve_exact`, but returns on errors instead of panicking or aborting.",
        "gt": "pub fn try_reserve_exact( &mut self, len: usize, additional: usize, ) -> Result<(), TryReserveError> { self.inner.try_reserve_exact(len, additional, T::LAYOUT) }",
        "url": 443
    },
    {
        "code_input": "use web3::{Client, types::Address, types::HexString};\nuse serde_json::Value;\n\n#[derive(Debug, serde::Deserialize)]\nstruct Result {\n    result: String,\n}\n\nfn main() {\n    let client = Client::new(\"http://localhost:8545\");\n\n    let contract_address = Address::from_str(\"0x46423aa7\").unwrap();",
        "nl_input": "Calls the contract's `getOrderStatus` (0x46423aa7) function",
        "gt": "pub fn get_order_status( &self, order_hash: [u8; 32], ) -> ::ethers::contract::builders::ContractCall< M, (bool, bool, ::ethers::core::types::U256, ::ethers::core::types::U256), > { self.0 .method_hash([70, 66, 58, 167], order_hash) .expect(\"method not found (this should never happen)\") }",
        "url": 444
    },
    {
        "code_input": "use std::ascii::AsciiExt;\n\n#[derive(Debug, Clone)]\nstruct FunctionCall {\n    name: String,\n}\n\nfn find_function_call(buffer: &[u8]) -> Option<FunctionCall> {\n    let function_call_start = buffer.find(b\"function_call(\")?;\n    let function_call_end = buffer.find(b\")\")?;\n\n    let function_name_start = buffer.find(b\"\\\"\")?;\n    let function_name_end = buffer.rfind(b\"\\\"\")?;\n\n    let function_name = &buffer[function_name_start + 1..function_name_end];\n\n    Some(FunctionCall {\n        name: function_name.to_string(),\n    })\n}\n\nfn main() {\n    let buffer = b\"Hello, function_call(\\\"world\\\")\";\n    match",
        "nl_input": "Verifies that a buffer of bytes contains a `FunctionCall` and returns it. Note that verification is still experimental and may not catch every error, or be maximally performant. For the previous, unchecked, behavior use `root_as_function_call_unchecked`.",
        "gt": "pub fn root_as_function_call(buf: &[u8]) -> Result<FunctionCall, flatbuffers::InvalidFlatbuffer> { flatbuffers::root::<FunctionCall>(buf) }",
        "url": 445
    },
    {
        "code_input": "fn main() {\n    let s = \"Hello, world!\";\n    let t = s.chars().collect::<Vec<char>>();\n    t.reverse();\n    let result = t.iter().zip(s.chars().cycle()).collect::<Vec<(char, char)>>();\n    println!(\"{:?}\", result);\n}",
        "nl_input": "rustfmt-indent_style: Visual",
        "gt": "fn main() { something.aaaaaaaaaaaa() .aaaaaaaaaaaa() .aaaaaaaaaaaa() .aaaaaaaaaaaa() .aaaaaaaaaaaa() .aaaaaaaaaaaa() .aaaaaaaaaaaa() .bench_function(|| { let x = hello(); }); something.aaaaaaaaaaaa() .aaaaaaaaaaaa() .aaaaaaaaaaaa() .aaaaaaaaaaaa() .aaaaaaaaaaaa() .aaaaaaaaaaaa() .aaaaaaaaaaaa() .bench_function(arg, || { let x = hello(); }); something.aaaaaaaaaaaa() .aaaaaaaaaaaa() .aaaaaaaaaaaa() .aaaaaaaaaaaa() .aaaaaaaaaaaa() .aaaaaaaaaaaa() .aaaaaaaaaaaa() .bench_function(arg, || { let x = hello(); }, arg); AAAAAAAAAAA.function(|| { let _ = (); }); AAAAAAAAAAA.chain().function(|| { let _ = (); }) }",
        "url": 446
    },
    {
        "code_input": "use std::process::exit;\nuse std::thread;\n\nfn main() {\n    // This will re-launch all currently open widgets.\n    // This is a very basic example and may not work for your specific use case.\n    thread::spawn(move || {\n        loop {\n            // Pause for a while\n            thread::sleep(std::time::Duration::from_secs(1));\n        }\n    });\n\n    // Exit the program\n    exit(0);\n}",
        "nl_input": "Relaunches all currently open widgets.",
        "gt": "pub async fn relaunch_all(&self) -> anyhow::Result<()> { let widget_ids = { self.widget_states.lock().await.keys().cloned().collect() }; self.relaunch_by_ids(&widget_ids).await }",
        "url": 447
    },
    {
        "code_input": "pub mod parent {\n    pub fn def() {\n        if let Some(_) = std::env::var(\"name\") {\n            println!(\"Error: name is already defined\");\n        } else {\n            std::env::set_var(\"name\", \"def\");\n        }\n    }\n}",
        "nl_input": "Defines `name` in namespace `ns` of module `parent` to be `def` if it is not yet defined; otherwise, reports an error.",
        "gt": "pub(crate) fn define<T>(&mut self, parent: Module<'ra>, ident: Ident, ns: Namespace, def: T) where T: ToNameBinding<'ra>, { let binding = def.to_name_binding(self.arenas); let key = self.new_disambiguated_key(ident, ns); if let Err(old_binding) = self.try_define(parent, key, binding, false) { self.report_conflict(parent, ident, ns, old_binding, binding); } }",
        "url": 448
    },
    {
        "code_input": "use web3::{Client, types::Address, types::HexString};\nuse serde_json::Value;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Create a new client\n    let client = Client::new(\"http://localhost:8545\")?;\n\n    // The address of the contract\n    let contract_address = Address::from_str(\"0x6809f664\")?;\n\n    // The ABI",
        "nl_input": "Calls the contract's `changeDelta` (0x6809f664) function",
        "gt": "pub fn change_delta( &self, new_delta: u128, ) -> ::ethers::contract::builders::ContractCall<M, ()> { self.0 .method_hash([104, 9, 246, 100], new_delta) .expect(\"method not found (this should never happen)\") }",
        "url": 449
    },
    {
        "code_input": "pub fn check_slices(s1: &[i32], s2: &[i32], eq_fn: fn(&[i32] -> bool) -> bool) -> bool {\n    if s1.len() != s2.len() {\n        return false;\n    }\n\n    for (a, b) in s1.iter().zip(s2.iter()) {\n        if !eq_fn(a, b) {\n            return false;\n        }\n    }\n\n    true\n}",
        "nl_input": "Checks if two slices are equal as per `eq_fn`.",
        "gt": "pub fn over<X>(left: &[X], right: &[X], mut eq_fn: impl FnMut(&X, &X) -> bool) -> bool { left.len() == right.len() && left.iter().zip(right).all(|(x, y)| eq_fn(x, y)) }",
        "url": 450
    },
    {
        "code_input": "fn returning<'a, 'b>(_arg: &'a i32) -> &'b i32 {\n    &5\n}",
        "nl_input": "returning `y` requires that `'b: 'a`, but it's not known to be true",
        "gt": "fn missing_subset<'a, 'b>(x: &'a u32, y: &'b u32) -> &'a u32 { y }",
        "url": 451
    },
    {
        "code_input": "use ethers::prelude::*;\nuse ethers::types::Address;\nuse ethers::types::HexString;\nuse ethers::types::Result;\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub struct AssetId {\n    id: u64,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub struct Recipient {\n    address: Address,\n}\n\nimpl AssetId {\n    pub fn new(id: u64) -> Self {\n        Self { id }\n    }\n\n    pub fn get_asset_recipient(&self, provider: &Provider) -> Result<Recipient> {\n        let contract = provider.contract_factory()?",
        "nl_input": "Calls the contract's `getAssetRecipient` (0x79eac6c2) function",
        "gt": "pub fn get_asset_recipient( &self, ) -> ::ethers::contract::builders::ContractCall< M, ::ethers::core::types::Address, > { self.0 .method_hash([121, 234, 198, 194], ()) .expect(\"method not found (this should never happen)\") }",
        "url": 452
    },
    {
        "code_input": "use rwf::http::Response;\n\nlet response = Response::new()\n    .text(\"don't cache me\")\n    .header(\"Cache-Control\", \"no-cache\");",
        "nl_input": "Add a header to the response. Header name is lowercased automatically. The value is set as-is. # Example ``` use rwf::http::Response; let response = Response::new() .text(\"don't cache me\") .header(\"Cache-Control\", \"no-cache\"); ```",
        "gt": "pub fn header(mut self, name: impl ToString, value: impl ToString) -> Self { self.headers.insert(name.to_string(), value.to_string()); self }",
        "url": 453
    },
    {
        "code_input": "pub fn ensure_static_type<T: 'static>(_x: T, _y: T) {}",
        "nl_input": "Callee knows that: 'x: 'a 'y: 'b so the only way we can ensure that `'x: 'y` is to show that `'a: 'static`.",
        "gt": "fn establish_relationships<'a, 'b, F>(_cell_a: &Cell<&'a u32>, _cell_b: &Cell<&'b u32>, _closure: F) where F: for<'x, 'y> FnMut( &Cell<&'a &'x u32>, &Cell<&'b &'y u32>, &Cell<&'x u32>, &Cell<&'y u32>, ), { }",
        "url": 454
    },
    {
        "code_input": "use web3::{Client, types::Address, types::Hex};\nuse serde_json::Value;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Create a new client\n    let client = Client::new(\"http://localhost:8545\")?;\n\n    // The address of the contract\n    let contract_address = Address::from_str(\"0xc45a0155\")?;\n\n    // The A",
        "nl_input": "Calls the contract's `factory` (0xc45a0155) function",
        "gt": "pub fn factory( &self, ) -> ::ethers::contract::builders::ContractCall< M, ::ethers::core::types::Address, > { self.0 .method_hash([196, 90, 1, 85], ()) .expect(\"method not found (this should never happen)\") }",
        "url": 455
    },
    {
        "code_input": "use std::collections::HashMap;\n\nfn main() {\n    let request_message = \"What is the tool name?\";\n    let tool_prompt = create_tool_prompt(request_message);\n    println!(\"{}\", tool_prompt);\n}\n\nfn create_tool_prompt(request_message: &str) -> String {\n    let mut tool_prompt = String::new();\n    tool_prompt.push_str(\"Tool: \");\n    tool_prompt.push_str(request_message.split_whitespace().next().unwrap());\n    tool_prompt\n}",
        "nl_input": "create a tool prompt from a chat completion request message.",
        "gt": "fn append_tool_message( &self, chat_history: impl AsRef<str>, message: &ChatCompletionToolMessage, ) -> String { format!( \"{chat_history}<|start_header_id|>ipython<|end_header_id|>\\n\\n{tool_message}<|eot_id|>\", chat_history = chat_history.as_ref().trim(), tool_message = message.content().trim(), ) }",
        "url": 456
    },
    {
        "code_input": "use std::any::Any;\nuse std::rc::Rc;\nuse std::boxed::Box;\nuse std::convert::From;\n\nfn type_of_expression(expression: &str) -> Option<Box<dyn Any>> {\n    let mut stack = Vec::new();\n    let mut last_type: Option<Box<dyn Any>> = None;\n\n    for token in expression.split_whitespace() {\n        match token {\n            \"(\" => {\n                let inner_type = type_of_expression(token.1);\n                if inner_type.is_none() {\n                    return None;\n                }\n                let inner_type = inner_type.unwrap();\n                if last_type.is_some() && *last_type == inner_type {\n                    return None;\n                }\n                last_type = inner_type;\n            },\n            \")\" => {\n                if stack.is_empty() || stack.last().unwrap() !",
        "nl_input": "Visits the expression and returns its data type.",
        "gt": "fn visit_expr(&mut self, expr: &Expression) -> ConversionResult<ColumnType> { match expr { Expression::Wildcard => Ok(ColumnType::BigInt), Expression::Literal(literal) => self.visit_literal(literal), Expression::Column(_) => self.visit_column_expr(expr), Expression::Unary { op, expr } => self.visit_unary_expr((*op).into(), expr), Expression::Binary { op, left, right } => { self.visit_binary_expr(&(*op).into(), left, right) } Expression::Aggregation { op, expr } => self.visit_agg_expr(*op, expr), } }",
        "url": 457
    },
    {
        "code_input": "struct MyStruct {\n    data: Vec<String>,\n}\n\nimpl MyStruct {\n    fn new() -> Self {\n        MyStruct {\n            data: vec![],\n        }\n    }\n\n    fn add(&mut self, s: String) {\n        self.data.push(s);\n    }\n\n    fn poll(&mut self) -> Option<String> {\n        if let Some(s) = self.data.pop() {\n            Some(s)\n        } else {\n            None\n        }\n    }\n}",
        "nl_input": "Check that underscore patterns are dropped after the method with self is polled.",
        "gt": "async fn bar_async(&'a self, x: D, _: D) { x.1.borrow_mut().push(DropOrder::Function); NeverReady.await; }",
        "url": 458
    },
    {
        "code_input": "{\n    \"name\": \"rustfmt-control_brace_style\",\n    \"value\": \"ClosingNextLine\"\n}",
        "nl_input": "rustfmt-control_brace_style: ClosingNextLine",
        "gt": "fn main() { if false { (); (); } if false { (); (); } let a = if 0 > 1 { unreachable!() } else { 0x0 }; if true { (); } else if false { (); (); } else { (); (); (); } if true { (); } else if false { (); (); } else { (); (); (); } }",
        "url": 459
    },
    {
        "code_input": "use web3::{Http, types::Address, Client};\nuse std::error::Error;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn Error>> {\n    let http = Http::new().chain_err()?;\n    let client = Client::new_with_http(http, \"https://mainnet.infura.io/v3/YOUR_INFURA_KEY\");\n\n    let contract_address = Address::from_str(\"0xb1dd61b6\")?;\n\n    let result = client.call(\n        \"function_name\",\n        (),\n        contract_address,\n    )\n    .await?;\n\n    print",
        "nl_input": "Calls the contract's `poolType` (0xb1dd61b6) function",
        "gt": "pub fn pool_type(&self) -> ::ethers::contract::builders::ContractCall<M, u8> { self.0 .method_hash([177, 221, 97, 182], ()) .expect(\"method not found (this should never happen)\") }",
        "url": 460
    },
    {
        "code_input": "use tokio::net::TcpStream;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    let (client, _) = tokio::net::connect(\"localhost:8080\").await?;\n\n    let stream = client.into_stream();\n\n    // Set the window size to 1000000 (1 MB)\n    stream.set_window_size(1000000).await?;\n\n    Ok(())\n}",
        "nl_input": "Set the maximum size of the stream flow control window. The value should not be greater than the setting `max_connection_window`. The default value is MAX_STREAM_WINDOW (6 MB).",
        "gt": "pub fn set_max_stream_window(&mut self, v: u64) { self.max_stream_window = cmp::min(v, VINT_MAX); }",
        "url": 461
    },
    {
        "code_input": "struct NonZST;\n\nimpl NonZST {\n    const UNINHABITED: () = ();\n}\n\nfn main() {\n    println!(\"{}\", NonZST::UNINHABITED);\n}",
        "nl_input": "Non-ZST uninhabited types are, nonetheless, uninhabited.",
        "gt": "fn yawning_void_struct() { enum Void {} struct YawningVoid(Void, u128); const _: () = { assert!(std::mem::size_of::<YawningVoid>() == std::mem::size_of::<u128>()); assert!(false); }; assert::is_maybe_transmutable::<YawningVoid, u128>(); assert::is_maybe_transmutable::<(), Void>(); }",
        "url": 462
    },
    {
        "code_input": "use std::thread;\nuse std::pin::Pin;\nuse std::sync::{Arc, RwLock};\nuse std::sync::{Arc, RwLock};\n\nfn main() {\n    let shared_data = Arc::new(RwLock::new(0));\n\n    let mut handle = thread::spawn(move || {\n        let mut data = shared_data.clone();\n        loop {\n            data.write().unwrap();\n        }\n    });\n\n    handle.join().unwrap();\n}",
        "nl_input": "Tries to set the thread handle for the current thread. Fails if a handle was already set or if the thread ID of `thread` would change an already-set ID.",
        "gt": "pub(crate) fn set_current(thread: Thread) -> Result<(), Thread> { if CURRENT.get() != NONE { return Err(thread); } match id::get() { Some(id) if id == thread.id() => {} None => id::set(thread.id()), _ => return Err(thread), } crate::sys::thread_local::guard::enable(); CURRENT.set(thread.into_raw().cast_mut()); Ok(()) }",
        "url": 463
    },
    {
        "code_input": "fn main() {\n    let mut x: i32 = 5;\n    let y: &mut i32 = &mut x;\n    *y = 10;\n    println!(\"{}\", x); // Output: 10\n}",
        "nl_input": "If we have only exposed read-only pointers, doing a write through a wildcard ptr should fail.",
        "gt": "fn main() { let mut x = 0; let _fool = &mut x as *mut i32; let addr = (&x as *const i32).expose_provenance(); let ptr = std::ptr::with_exposed_provenance_mut::<i32>(addr); unsafe { *ptr = 0 }; }",
        "url": 464
    },
    {
        "code_input": "fn sum_of_elements<T: Iterator>(iter: T) -> i32 {\n    iter.sum()\n}",
        "nl_input": "same as cci_iter_lib, more-or-less, but not marked inline",
        "gt": "pub fn iter<F>(v: Vec<usize> , mut f: F) where F: FnMut(usize) { let mut i = 0; let n = v.len(); while i < n { f(v[i]); i += 1; } }",
        "url": 465
    },
    {
        "code_input": "fn main() {\n    println!(\"~^ WARN unnecessary lifetime parameter `'a` ~| WARN lifetime parameter `'b` never used\");\n}",
        "nl_input": "~^ WARN unnecessary lifetime parameter `'a` ~| WARN lifetime parameter `'b` never used",
        "gt": "fn static_id_indirect<'a,'b>(t: &'a ()) -> &'static () where 'a: 'b, 'b: 'static { t }",
        "url": 466
    },
    {
        "code_input": "fn get_even_numbers(numbers: Vec<i32>) -> Vec<i32> {\n    let mut even_numbers: Vec<i32> = Vec::new();\n    for number in numbers {\n        if number % 2 == 0 {\n            even_numbers.push(number);\n        }\n    }\n    even_numbers\n}",
        "nl_input": "~^ NOTE `x` dropped here while still borrowed",
        "gt": "fn is_moved() { let x = vec![1]; let a = display_len(&x); fn mv(_: impl Sized) {} mv(x); }",
        "url": 467
    },
    {
        "code_input": "fn grant_permission(permission: &str) -> bool {\n    // Check if the permission string contains \"Unique\" and \"SharedReadOnly\"\n    if permission.contains(\"Unique\") && permission.contains(\"SharedReadOnly\") {\n        // If it does, return true\n        return true;\n    }\n    // If it doesn't, return false\n    return false;\n}\n\nfn main() {\n    // Test the function with a permission string\n    let permission = \"UniqueSharedReadOnly\";\n    if grant_permission(&permission) {\n        println!(\"Permission granted\");\n    } else {\n        println!(\"Permission denied\");\n    }\n}",
        "nl_input": "@error-in-other-file: retag .* for Unique permission .* only grants SharedReadOnly permission",
        "gt": "fn main() { unsafe { let x = 0u8; let x = core::ptr::addr_of!(x); core::ptr::drop_in_place(x.cast_mut()); } }",
        "url": 468
    },
    {
        "code_input": "use cpuid::{Feature, Features, Info, InfoType, System, SystemExt};\n\nfn main() {\n    let system = System::new().unwrap();\n    let features = system.features().unwrap();\n    let info = system.info().unwrap();\n\n    let smt_enabled = features.contains(Feature::SMT);\n    let socket_size = match info.get(InfoType::SocketSize) {\n        Some(size) => size.value(),\n        None => panic!(\"SMT is not supported on this system\"),\n    };\n\n    let host_info = HostInfo {",
        "nl_input": "Returns a builder initialized from host information (via CPUID). Note that this only queries SMT state and the socket size, it does not otherwise affect APIC configuration.",
        "gt": "pub fn from_host_topology() -> Result<Self, HostTopologyError> { fn cpuid(leaf: u32, sub_leaf: u32) -> [u32; 4] { #[cfg(not(target_arch = \"x86_64\"))] { let (_, _) = (leaf, sub_leaf); unimplemented!(\"cannot invoke from_host_topology: host arch is not x86_64\"); } #[cfg(target_arch = \"x86_64\")] { let result = safe_intrinsics::cpuid(leaf, sub_leaf); [result.eax, result.ebx, result.ecx, result.edx] } } Self::from_cpuid(&mut cpuid) }",
        "url": 469
    },
    {
        "code_input": "use near_sdk::{env, near_bindgen};\n\n#[near_bindgen]\nimpl env::contract {\n    #[init]\n    fn new(_delegate: env::delegate::Delegate) {}\n\n    #[finality(\"final\")]\n    fn asset_recipient(&self, _msg: env::msg::Msg) {\n        let contract_id = env::current_account_id();\n        let contract_account = env::account_info(contract_id).unwrap();\n        let contract_account_id = contract_account.account_id.to_string_lossy();\n\n        // Replace with your actual contract's address\n        let contract_address = \"0x3bfa67fe\".to_string_lossy();\n\n        // Call the contract's",
        "nl_input": "Calls the contract's `assetRecipient` (0x3bfa67fe) function",
        "gt": "pub fn asset_recipient( &self, ) -> ::ethers::contract::builders::ContractCall< M, ::ethers::core::types::Address, > { self.0 .method_hash([59, 250, 103, 254], ()) .expect(\"method not found (this should never happen)\") }",
        "url": 470
    },
    {
        "code_input": "I'm sorry, but the information you provided is incomplete. Could you please provide more details about the query you want to write in Rust?\n",
        "nl_input": "FIXME(eddyb) maybe cache this?",
        "gt": "fn qualif_local<Q: qualifs::Qualif>(&mut self, local: Local) -> bool { let TempState::Defined { location: loc, .. } = self.temps[local] else { return false; }; let stmt_or_term = self.body.stmt_at(loc); match stmt_or_term { Left(statement) => { let Some((_, rhs)) = statement.kind.as_assign() else { span_bug!(statement.source_info.span, \"{:?} is not an assignment\", statement) }; qualifs::in_rvalue::<Q, _>(self.ccx, &mut |l| self.qualif_local::<Q>(l), rhs) } Right(terminator) => { assert_matches!(terminator.kind, TerminatorKind::Call { .. }); let return_ty = self.body.local_decls[local].ty; Q::in_any_value_of_ty(self.ccx, return_ty) } } }",
        "url": 471
    },
    {
        "code_input": "use web3::{Client, types::Address, types::Hex};\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    let client = Client::new()?;\n\n    let contract_address = Address::from_str(\"0x6e1a8597\")?;\n\n    let function_name = \"getSellQuote\".parse::<Hex>()?;\n\n    let args = vec![];\n\n    let result = client.call_contract(contract_address, function_name, args)\n        .await?\n        .into_result()?;\n\n    println!(\"{:#?}",
        "nl_input": "Calls the contract's `getSellQuote` (0x6e1a8597) function",
        "gt": "pub fn get_sell_quote( &self, pool_address: ::ethers::core::types::Address, ) -> ::ethers::contract::builders::ContractCall<M, SellQuote> { self.0 .method_hash([110, 26, 133, 151], pool_address) .expect(\"method not found (this should never happen)\") }",
        "url": 472
    },
    {
        "code_input": "use std::fs::File;\nuse std::io::{self, BufRead};\nuse std::path::Path;\nuse std::collections::HashMap;\n\nfn parse_file(path: &Path) -> io::Result<HashMap<String, String>> {\n    let file = File::open(path)?;\n    let mut map = HashMap::new();\n    for line in io::BufReader::new(file).lines() {\n        let line = line?;\n        let (key, value) = line.split_once(':').unwrap();\n        map.insert(key.to_string(), value.to_string());\n    }\n    Ok(map)\n}\n\nfn main() -> io::Result<()> {\n    let path = Path::new(\"path_to_your_file\");\n    let map = parse_file(&path)?;\n    print",
        "nl_input": "Parse a file with `Key: value` entries such as WHEEL and METADATA",
        "gt": "fn parse_key_value_file( file: impl Read, debug_filename: &str, ) -> miette::Result<HashMap<String, Vec<String>>> { let mut data: HashMap<String, Vec<String>> = HashMap::default(); let file = BufReader::new(file); for (line_no, line) in file.lines().enumerate() { let line = line.into_diagnostic()?.trim().to_string(); if line.is_empty() { continue; } let (key, value) = line.split_once(':').ok_or_else(|| { miette::miette!( \"Line {} of the {debug_filename} file is invalid\", line_no + 1 ) })?; data.entry(key.trim().to_string()) .or_default() .push(value.trim().to_string()); } Ok(data) }",
        "url": 473
    },
    {
        "code_input": "use intrinsics::non_const::LowerIntrinsics;\n\nfn main() {\n    let result = LowerIntrinsics::diff(10, 5);\n    println!(\"{}\", result);\n}",
        "nl_input": "EMIT_MIR lower_intrinsics.non_const.LowerIntrinsics.diff",
        "gt": "pub fn non_const<T>() -> usize { let size_of_t = core::intrinsics::size_of::<T>; size_of_t() }",
        "url": 474
    },
    {
        "code_input": "use vf_rs::*;\n\nfn main() {\n    // Create a new VF\n    let mut vf = VF::new().unwrap();\n\n    // Add two VF ports\n    let (vtl2_vf, vtl0_vf) = vf.add_ports(2).unwrap();\n\n    // Get the first VF port\n    let mut vtl2_port = vf.get_port(0).unwrap();\n\n    // Get the second VF port\n    let mut vtl0_port = vf.get_port(1).unwrap();\n\n    // Move the filter from the first VF port to the second VF port\n    vtl2_port.move_filter(&vtl0_port).unwrap();\n}",
        "nl_input": "Move filter between VTL2 VF vport and VTL0 VF vport",
        "gt": "pub async fn move_filter(&self, direction_to_vtl0: u8) -> anyhow::Result<()> { if let Some(to_vtl0) = self.vport_state.get_direction_to_vtl0() { if to_vtl0 == (direction_to_vtl0 == 1) { return Ok(()); } } let mut gdma = self.inner.gdma.lock().await; let hwc_activity_id = BnicDriver::new(&mut *gdma, self.inner.dev_id) .move_vport_filter(self.config.vport, direction_to_vtl0) .await?; self.vport_state .set_direction_to_vtl0(direction_to_vtl0 == 1); tracing::info!( mac_address = %self.mac_address(), direction_to_vtl0, hwc_activity_id, \"switch data path for mac\", ); Ok(()) }",
        "url": 475
    },
    {
        "code_input": "I'm sorry, but your request is incomplete. It seems like you're asking for help with a specific code snippet, but you didn't provide enough information. Could you please provide more details about the problem you're trying to solve? For example, what is the context of the code you're trying to write? What is the expected output? What is the current state of the code?\n\nOnce I have more information, I'll be able to assist you better.\n",
        "nl_input": "FIXME: This can be simplified to `Copy`. EMIT_MIR gvn_copy_aggregate.all_copy_use_changed_2.GVN.diff",
        "gt": "fn all_copy_use_changed_2(v: &mut AllCopy) -> AllCopy { let mut a = v.a; let b = v.b; let c = v.c; v.a = 1; a = v.a; AllCopy { a, b, c } }",
        "url": 476
    },
    {
        "code_input": "use std::collections::HashMap;\n\n#[derive(Debug, Clone)]\nstruct State {\n    data: HashMap<String, String>,\n}\n\nimpl State {\n    fn new() -> Self {\n        State {\n            data: HashMap::new(),\n        }\n    }\n}",
        "nl_input": "Constructs a new instance of [`State`].",
        "gt": "pub fn new(analyzer: Analyzer<'a>, accent_color: Option<Color>) -> Result<Self> { let mut state = Self { running: true, tab: Tab::default(), info_index: 0, block_index: 2, list: SelectableList::default(), analyzer, show_heh: false, show_details: false, input: Input::default(), input_mode: false, strings_loaded: false, system_calls_loaded: false, dynamic_scroll_index: 0, general_scroll_index: 0, notes_scroll_index: 0, headers_scroll_index: 0, accent_color: accent_color.unwrap_or(Color::White), logo: Logo::default(), }; state.handle_tab()?; Ok(state) }",
        "url": 477
    },
    {
        "code_input": "pub fn assert_leaf<T>(handle: &mut Handle<T>) {\n    // The `unsafe` keyword is used to perform unsafe operations.\n    // In this case, we are using it to call a function that requires the handle to be a leaf.\n    unsafe {\n        // The `assert_node` function is assumed to be defined somewhere.\n        // It checks if the node is a leaf.\n        assert_node(handle.node());\n    }\n}\n\n// This is a placeholder for the `assert_node` function.\n// It should be defined somewhere.\nfn assert_node(node: &Node) {\n    // The `assert_leaf` function is assumed to be defined somewhere.\n    // It checks if the node is a leaf.\n    assert_leaf(node);\n}\n\n// This is a placeholder for the `assert_leaf` function.\n// It should be defined somewhere.\nfn assert_leaf",
        "nl_input": "Unsafely asserts to the compiler the static information that the handle's node is a `Leaf`.",
        "gt": "pub unsafe fn cast_to_leaf_unchecked( self, ) -> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, Type> { let node = unsafe { self.node.cast_to_leaf_unchecked() }; Handle { node, idx: self.idx, _marker: PhantomData } }",
        "url": 478
    },
    {
        "code_input": "use tokio::runtime::Runtime;\nuse tokio::sync::mpsc;\nuse reqwest::Error;\n\n#[tokio::main]\nasync fn main() -> Result<(), Error> {\n    let (tx, rx) = mpsc::channel(10);\n\n    let runtime = Runtime::new().expect(\"Failed to create runtime\");\n\n    let client = reqwest::Client::new();\n\n    let url = \"http://example.com/api/v1/repo/data\";\n    let env = \"production\";\n\n    let future = runtime.spawn(async move {\n        let resp = client.get(url).await.expect(\"Failed to get response\");\n        let resp_body = resp.text().await.expect(\"Failed to read response body\");\n\n        if let Some(body) = resp_body.as_str() {\n            if body.contains",
        "nl_input": "Returns a future that will resolve to the solved repodata records for the given environment or `None` if no task was spawned to instantiate the prefix.",
        "gt": "pub(crate) fn get_conda_prefix( &self, environment: &GroupedEnvironment<'p>, ) -> Option<impl Future<Output = (Prefix, PythonStatus)>> { let cell = self.instantiated_conda_prefixes.get(environment)?.clone(); Some(async move { cell.wait().await.clone() }) }",
        "url": 479
    },
    {
        "code_input": "fn main() {\n    let mut n: i32 = -128;\n\n    for (i, bit) in n.abs().to_string(2).chars().enumerate() {\n        if bit == '1' {\n            println!(\"The sign bit varies at bit position {}\", i);\n        }\n    }\n}",
        "nl_input": "Iterate over each varying bit for the absolute values and the sign bit if it varies",
        "gt": "pub fn for_each_varying_bit<F>(&self, mut f: F) where F: FnMut(usize, usize), { for i in 0..4 { let bitset = self.vary_mask[i]; for pos in BitIter::from(bitset) { f(i, pos); } } }",
        "url": 480
    },
    {
        "code_input": "pub trait ParamEnv {\n    fn implements_trait(&self, callee_id: bool) -> bool;\n}\n\nimpl ParamEnv for i32 {\n    fn implements_trait(&self, callee_id: bool) -> bool {\n        if callee_id {\n            *self == 42\n        } else {\n            *self == 43\n        }\n    }\n}\n\nimpl ParamEnv for &str {\n    fn implements_trait(&self, callee_id: bool) -> bool {\n        if callee_id {\n            **self == \"hello\"\n        } else {\n            **self == \"world\"\n        }\n    }\n}",
        "nl_input": "Same as `implements_trait` but allows using a `ParamEnv` different from the lint context. The `callee_id` argument is used to determine whether this is a function call in a `const fn` environment, used for checking const traits.",
        "gt": "pub fn implements_trait_with_env<'tcx>( tcx: TyCtxt<'tcx>, typing_env: ty::TypingEnv<'tcx>, ty: Ty<'tcx>, trait_id: DefId, callee_id: Option<DefId>, args: &[GenericArg<'tcx>], ) -> bool { implements_trait_with_env_from_iter(tcx, typing_env, ty, trait_id, callee_id, args.iter().map(|&x| Some(x))) }",
        "url": 481
    },
    {
        "code_input": "use std::collections::HashMap;\n\nstruct Entry {\n    key: i32,\n    value: String,\n}\n\nfn main() {\n    let mut entries = HashMap::new();\n\n    // Get an existing entry\n    let existing_entry = entries.get(&1).unwrap_or(&Entry { key: 0, value: String::from(\"default\") });\n    println!(\"Existing entry: {:?}\", existing_entry);\n\n    // Create a new entry\n    let new_entry = Entry { key: 2, value: String::from(\"new value\") };\n    entries.insert(2, new_entry);\n\n    // Get the new entry\n    let new_entry = entries.get(&2).unwrap();\n    println!(\"New entry: {:?}\", new_entry);\n}",
        "nl_input": "Either get a previously existing entry, or create a new one if it is not yet present.",
        "gt": "pub fn get_or_insert(&mut self, key: K) -> UniIndex { self.get(&key).unwrap_or_else(|| self.insert(key)) }",
        "url": 482
    },
    {
        "code_input": "use quote::{quote, Quote};\nuse rustc_mir::parser::ast::Module;\n\nfn main() {\n    let code = r#\"\n        fn foo() {\n            let x = 5;\n            let y = 10;\n            let z = |x, y| x + y;\n            println!(\"{}\", z(x, y));\n        }\"#;\n\n    let module: Module = quote().parse(code).unwrap();\n\n    for stmt in module.body.statements {\n        match stmt {\n            Some(stmt) if stmt.is_let() {\n                let let_stmt",
        "nl_input": "Number of implicit inputs -- notably the \"environment\" parameter for closures -- that appear in MIR but not in the user's code.",
        "gt": "pub(crate) fn implicit_inputs(self) -> usize { match self { DefiningTy::Closure(..) | DefiningTy::CoroutineClosure(..) | DefiningTy::Coroutine(..) => 1, DefiningTy::FnDef(..) | DefiningTy::Const(..) | DefiningTy::InlineConst(..) => 0, } }",
        "url": 483
    },
    {
        "code_input": "pub fn manipulate_left_right(left: &mut Vec<f32>, right: &mut Vec<f32>, p: f32) {\n    for i in 0..left.len() {\n        right[i] = left[i] * p;\n        left[i] = left[i] * (1.0 - p);\n    }\n}",
        "nl_input": "This method manipulates left and right such that right[i] = left[i] * p and left[i] = left[i] * (1 - p)",
        "gt": "fn compute_evaluation_vector_impl<F>(left: &mut [F], right: &mut [F], p: F) where F: One + Sub<Output = F> + MulAssign + SubAssign + Mul<Output = F> + Send + Sync + Copy, { let k = cmp::min(left.len(), right.len()); let one_minus_p = F::one() - p; if_rayon!( left.par_iter_mut().with_min_len(MIN_PARALLEL_LEN), left.iter_mut() ) .zip(right) .for_each(|(li, ri)| { *ri = *li * p; *li -= *ri; }); if_rayon!( left[k..].par_iter_mut().with_min_len(MIN_PARALLEL_LEN), left[k..].iter_mut() ) .for_each(|li| { *li *= one_minus_p; }); }",
        "url": 484
    },
    {
        "code_input": "// Define a function to get the current module name\nfn get_current_module_name() -> &'static str {\n    // Get the current module name\n    let current_module_name = std::env::module_name().unwrap();\n\n    // Return the current module name\n    current_module_name\n}\n\nfn main() {\n    // Get the current module name\n    let current_module_name = get_current_module_name();\n\n    // Print the current module name\n    println!(\"Current module name: {}\", current_module_name);\n}",
        "nl_input": "Get a name from current module scope, legacy macros are not included",
        "gt": "pub(crate) fn get(&self, name: &Name) -> PerNs { PerNs { types: self.types.get(name).copied(), values: self.values.get(name).copied(), macros: self.macros.get(name).copied(), } }",
        "url": 485
    },
    {
        "code_input": "pub struct Reserved {\n    value: i32,\n}\n\nimpl Reserved {\n    pub fn new(value: i32) -> Reserved {\n        Reserved { value }\n    }\n\n    pub fn borrow(&self) -> &Reserved {\n        &self.value\n    }\n}\n\npub struct Tree {\n    reserved: Option<Box<Reserved>>,\n}\n\nimpl Tree {\n    pub fn new() -> Tree {\n        Tree { reserved: None }\n    }\n\n    pub fn borrow_reserved(&mut self) -> Option<&Reserved> {\n        self.reserved.take()\n    }\n}",
        "nl_input": "Tree Borrows has no issue with several mutable references existing at the same time, as long as they are used only immutably. I.e. multiple Reserved can coexist.",
        "gt": "pub fn aliasing_read_only_mutable_refs() { unsafe { let base = &mut 42u64; let r1 = &mut *(base as *mut u64); let r2 = &mut *(base as *mut u64); let _l = *r1; let _l = *r2; } }",
        "url": 486
    },
    {
        "code_input": "pub fn get_validator(validator: &RetentionValidator) -> Result<(), &'static str> {\n    // Check if the validator is not null\n    if validator == &Default::default() {\n        return Err(\"Validator is null\");\n    }\n\n    // Call the validator\n    validator.validate()\n}",
        "nl_input": "Allows a retention validator to be explicitly passed in",
        "gt": "pub async fn previous_revisions_with_validator( &self, ids: BTreeSet<(InternalDocumentId, Timestamp)>, retention_validator: Arc<dyn RetentionValidator>, ) -> anyhow::Result< BTreeMap<(InternalDocumentId, Timestamp), (Timestamp, Option<ResolvedDocument>)>, > { for (_, ts) in &ids { anyhow::ensure!(*ts <= self.upper_bound.succ()?); } self.reader .previous_revisions(ids, retention_validator.clone()) .await }",
        "url": 487
    },
    {
        "code_input": "use std::collections::HashMap;\n\nfn main() {\n    let request_message = \"What is the tool name?\";\n    let tool_prompt = create_tool_prompt(request_message);\n    println!(\"{}\", tool_prompt);\n}\n\nfn create_tool_prompt(request_message: &str) -> String {\n    let mut tool_prompt = String::new();\n    tool_prompt.push_str(\"Tool: \");\n    tool_prompt.push_str(request_message.split_whitespace().next().unwrap());\n    tool_prompt\n}",
        "nl_input": "create a tool prompt from a chat completion request message.",
        "gt": "fn append_tool_message( &self, chat_history: impl AsRef<str>, message: &ChatCompletionToolMessage, ) -> String { format!( \"{chat_history}\\n<|im_start|>environment name=<|plugin|>\\n{tool_message}<|im_end|>\", chat_history = chat_history.as_ref().trim(), tool_message = message.content().trim(), ) }",
        "url": 488
    },
    {
        "code_input": "use std::thread;\nuse std::time::Duration;\n\n// Assume these are defined elsewhere in your code\n\nstruct Vfs;\nstruct ThreadPool;\n\nimpl Vfs {\n    fn request(&self, _: &str) -> Result<(), R::Error> {\n        // Simulate a latency-sensitive request\n        thread::sleep(Duration::from_secs(2));\n\n        // Return a default constructed result\n        Ok(())\n    }\n}\n\nimpl ThreadPool {\n    fn dispatch(&self, vfs: &Vfs, _: &str) -> Result<(), R::Error> {\n        // Dispatch the request onto the VFS\n        vfs.request(_)\n    }\n}\n\nfn main() {\n    // Create a VFS and a ThreadPool\n    let vfs = Vfs {};\n    let thread_pool = ThreadPool {};\n\n    // Dispatch a request onto the ThreadPool\n    thread",
        "nl_input": "Dispatches a latency-sensitive request onto the thread pool. When the VFS is marked not ready this will return a default constructed [`R::Result`].",
        "gt": "pub(crate) fn on_latency_sensitive<const ALLOW_RETRYING: bool, R>( &mut self, f: fn(GlobalStateSnapshot, R::Params) -> anyhow::Result<R::Result>, ) -> &mut Self where R: lsp_types::request::Request< Params: DeserializeOwned + panic::UnwindSafe + Send + fmt::Debug, Result: Serialize + Default, > + 'static, { if !self.global_state.vfs_done { if let Some(lsp_server::Request { id, .. }) = self.req.take_if(|it| it.method == R::METHOD) { self.global_state.respond(lsp_server::Response::new_ok(id, R::Result::default())); } return self; } self.on_with_thread_intent::<true, ALLOW_RETRYING, R>( ThreadIntent::LatencySensitive, f, Self::content_modified_error, ) }",
        "url": 489
    },
    {
        "code_input": "use web3::{Client, types::Address, types::HexString};\nuse serde_json::Value;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Create a new Web3 client\n    let client = Client::new(\"http://localhost:8545\")?;\n\n    // The address of the contract\n    let contract_address = Address::from_str(\"0xf07ec373\")?;\n\n    // The ABI of the contract",
        "nl_input": "Calls the contract's `getCounter` (0xf07ec373) function",
        "gt": "pub fn get_counter( &self, offerer: ::ethers::core::types::Address, ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::U256> { self.0 .method_hash([240, 126, 195, 115], offerer) .expect(\"method not found (this should never happen)\") }",
        "url": 490
    },
    {
        "code_input": "use std::net::{SocketAddr, UdpSocket};\n\nfn send_datagrams(bufs: Vec<(SocketAddr, &[u8])>) {\n    let mut socket = UdpSocket::bind(None).unwrap();\n\n    for (addr, data) in &bufs {\n        socket.send_to(data.to_vec(), addr).unwrap();\n    }\n}",
        "nl_input": "Sends the datagram in `bufs`.",
        "gt": "fn send_vectored<'a>(&'a mut self, bufs: &'a [IoSlice<'a>]) -> SendVectored<'a, Self> { SendVectored { send: self, bufs } }",
        "url": 491
    },
    {
        "code_input": "enum Countries {\n    Ghana,\n    Lesotho,\n}\n\nfn main() {\n    let country = Countries::Lesotho;\n    println!(\"{:?}\", country);\n}",
        "nl_input": "Assist: generate_enum_variant Adds a variant to an enum. ``` enum Countries { Ghana, } fn main() { let country = Countries::Lesotho$0; } ``` -> ``` enum Countries { Ghana, Lesotho, } fn main() { let country = Countries::Lesotho; } ```",
        "gt": "pub(crate) fn generate_enum_variant(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> { let path: ast::Path = ctx.find_node_at_offset()?; let parent = path_parent(&path)?; if ctx.sema.resolve_path(&path).is_some() { // No need to generate anything if the path resolves return None; } let name_ref = path.segment()?.name_ref()?; if name_ref.text().starts_with(char::is_lowercase) { // Don't suggest generating variant if the name starts with a lowercase letter return None; } if let Some(hir::PathResolution::Def(hir::ModuleDef::Adt(hir::Adt::Enum(e)))) = ctx.sema.resolve_path(&path.qualifier()?) { let target = path.syntax().text_range(); return add_variant_to_accumulator(acc, ctx, target, e, &name_ref, parent); } None }",
        "url": 492
    },
    {
        "code_input": "use std::error::Error;\nuse std::fmt;\n\n#[derive(Debug)]\nstruct RedactedJsError {\n    message: String,\n    request_id: Option<String>,\n}\n\nimpl fmt::Display for RedactedJsError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"{}\", self.message)\n    }\n}\n\nimpl Error for RedactedJsError {}\n\nfn handle_error(e: Result<String, RedactedJsError>) {\n    match e {\n        Ok(value) => println!(\"{}\", value),\n        Err(error) => {\n            if let Some(request_id) = error.request_id {\n                if !error.message.contains(\"Server Error\") && !error.message.contains(request_id) {",
        "nl_input": "Format the exception when it is or will be nested inside of another RedactedJsError In particular we don't want to print 'Server Error' or the request id multiple times in the same stack trace.",
        "gt": "pub fn nested_to_string(&self) -> String { if self.block_logging { \"Server Error\".to_string() } else { format!(\"{}\", self.error) } }",
        "url": 493
    },
    {
        "code_input": "pub struct JumpThread<T> {\n    current_thread: T,\n    jump_table: Vec<Option<T>>,\n}\n\nimpl<T> JumpThread<T> {\n    pub fn new(current_thread: T) -> JumpThread<T> {\n        JumpThread {\n            current_thread,\n            jump_table: vec![None; 2],\n        }\n    }\n\n    pub fn switch_thread(&mut self, new_thread: T) {\n        let old_thread = self.current_thread;\n        self.current_thread = new_thread;\n        self.jump_table[old_thread as usize] = None;\n    }\n\n    pub fn copy_aggregate(&mut self, old_thread: T, new_thread: T) {\n        self.jump_table[",
        "nl_input": "Verify that jump threading succeeds seeing through copies of aggregates.",
        "gt": "fn aggregate_copy() -> u32 { const Foo: (u32, u32) = (5, 3); let a = Foo; let b = a; let c = b.1; if c == 2 { b.0 } else { 13 } }",
        "url": 494
    },
    {
        "code_input": "I'm sorry, but your request is not clear. It seems like you're asking for a Rust code snippet, but you didn't provide any specific query or context. Could you please provide more details or clarify what you're looking for?\n",
        "nl_input": "@ revisions: edition2021 edition2024 @ [edition2024] compile-flags: -Zunstable-options @ [edition2024] edition: 2024 @ [edition2021] check-pass",
        "gt": "fn why_would_you_do_this() -> bool { let mut x = None; x.replace(std::cell::RefCell::new(123).borrow()).is_some() }",
        "url": 495
    },
    {
        "code_input": "extern crate pandas;\n\nuse pandas::DataFrame;\n\nfn convert_to_dataframe() -> DataFrame {\n    // Create a DataFrame\n    let df = DataFrame::new(vec![\n        vec![1, 2, 3],\n        vec![4, 5, 6],\n        vec![7, 8, 9],\n    ]);\n\n    // Set the column names\n    df.set_axis(vec![\"a\", \"b\", \"c\"], true);\n\n    // Return the DataFrame\n    df\n}\n\nfn main() {\n    let",
        "nl_input": "convert block-derived data to dataframe",
        "gt": "async fn transform_channel( mut receiver: mpsc::Receiver<R<Self::Response>>, query: &Arc<Query>, ) -> R<Self> { let mut columns = Self::default(); while let Some(message) = receiver.recv().await { match message { Ok(message) => Self::transform(message, &mut columns, query)?, Err(e) => return Err(e), } } Ok(columns) }",
        "url": 496
    },
    {
        "code_input": "pub struct ColumnCommitmentMetadata {\n    column_type: ColumnType,\n    bounds: Bounds,\n}\n\nimpl ColumnCommitmentMetadata {\n    pub fn new(column_type: ColumnType, bounds: Bounds) -> Result<Self, &'static str> {\n        if column_type != bounds.column_type {\n            return Err(\"The Bounds variant and column type do not match\");\n        }\n\n        Ok(Self { column_type, bounds })\n    }\n}",
        "nl_input": "Construct a new [`ColumnCommitmentMetadata`]. Will error if the supplied metadata are invalid. i.e., if The Bounds variant and column type do not match.",
        "gt": "pub fn try_new( column_type: ColumnType, bounds: ColumnBounds, ) -> Result<ColumnCommitmentMetadata, InvalidColumnCommitmentMetadata> { match (column_type, bounds) { (ColumnType::TinyInt, ColumnBounds::TinyInt(_)) | (ColumnType::SmallInt, ColumnBounds::SmallInt(_)) | (ColumnType::Int, ColumnBounds::Int(_)) | (ColumnType::BigInt, ColumnBounds::BigInt(_)) | (ColumnType::Int128, ColumnBounds::Int128(_)) | (ColumnType::TimestampTZ(_, _), ColumnBounds::TimestampTZ(_)) | ( ColumnType::Boolean | ColumnType::VarChar | ColumnType::Scalar | ColumnType::Decimal75(..), ColumnBounds::NoOrder, ) => Ok(ColumnCommitmentMetadata { column_type, bounds, }), _ => Err(InvalidColumnCommitmentMetadata::TypeBoundsMismatch { column_type, column_bounds: bounds, }), } }",
        "url": 497
    },
    {
        "code_input": "fn main() {\n    println!(\"EMIT_MIR gvn_copy_aggregate.all_copy.GVN.diff\");\n}",
        "nl_input": "EMIT_MIR gvn_copy_aggregate.all_copy.GVN.diff",
        "gt": "fn all_copy(v: &AllCopy) -> AllCopy { let a = v.a; let b = v.b; let c = v.c; AllCopy { a, b, c } }",
        "url": 498
    },
    {
        "code_input": "fn main() {\n    let _ = 123;\n}",
        "nl_input": "Shouldn't lint `binding to `_` prefixed variable with no side-effect`",
        "gt": "async fn foo(_i: u64) { let _a = 0; let _b = num(); let _ = async { let _c = 0; let _d = num(); } .await; }",
        "url": 499
    },
    {
        "code_input": "fn get_gateway() -> &'static str {\n    \"https://api.github.com\"\n}\n\nfn main() {\n    println!(\"{}\", get_gateway());\n}",
        "nl_input": "Returns the [`Gateway`] used by this project.",
        "gt": "fn repodata_gateway(&self) -> &Gateway { self.repodata_gateway.get_or_init(|| { Self::repodata_gateway_init( self.authenticated_client().clone(), self.config().clone().into(), ) }) }",
        "url": 500
    },
    {
        "code_input": "use std::rc::Rc;\n\nfn main() {\n    // Define a struct\n    struct MyStruct {\n        field1: i32,\n        field2: Rc<i32>,\n    }\n\n    // Create an instance of the struct\n    let my_instance = MyStruct {\n        field1: 10,\n        field2: Rc::new(10),\n    };\n\n    // Print the fields and their types\n    println!(\"{:?}\", std::any::type_name(&my_instance));\n    println!(\"field1: {}\", my_instance.field1);\n    println!(\"field2: {}\", *my_instance.field2.borrow());\n}",
        "nl_input": "This lists the fields of a variant along with their types.",
        "gt": "fn list_variant_fields<'a>( &'a self, ty: &'a Ty, variant: VariantId, ) -> impl Iterator<Item = (LocalFieldId, Ty)> + Captures<'a> + Captures<'db> { let (_, substs) = ty.as_adt().unwrap(); let field_tys = self.db.field_types(variant); let fields_len = variant.variant_data(self.db.upcast()).fields().len() as u32; (0..fields_len).map(|idx| LocalFieldId::from_raw(idx.into())).map(move |fid| { let ty = field_tys[fid].clone().substitute(Interner, substs); let ty = normalize(self.db, self.db.trait_environment_for_body(self.body), ty); (fid, ty) }) }",
        "url": 501
    },
    {
        "code_input": "fn main() {\n    let x = 5;\n\n    match x {\n        0 => println!(\"x is zero\"),\n        1 => println!(\"x is one\"),\n        2 => println!(\"x is two\"),\n        _ => println!(\"x is something else\"),\n    }\n}",
        "nl_input": "rustfmt-match_arm_blocks: false rustfmt-match_block_trailing_comma: true Match expressions, no unwrapping of block arms or wrapping of multiline expressions.",
        "gt": "fn foo() { match x { a => { \"line1\"; \"line2\" }, b => ( aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa, bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb, ), } }",
        "url": 502
    },
    {
        "code_input": "fn factorial(n: u64) -> u64 {\n    match n {\n        0 => 1,\n        1 => 1,\n        _ => n * factorial(n - 1),\n    }\n}\n\nfn main() {\n    let num = 5;\n    println!(\"{}\", factorial(num));\n}",
        "nl_input": "rustfmt-max_width: 80",
        "gt": "fn foo() { polyfill::slice::fill( &mut self.pending[padding_pos..(self.algorithm.block_len - 8)], 0, ); }",
        "url": 503
    },
    {
        "code_input": "use std::collections::VecDeque;\n\nfn pop_queue(queue: &mut VecDeque<i32>) -> Option<i32> {\n    if queue.is_empty() {\n        None\n    } else {\n        let popped_value = queue.pop_back().unwrap();\n        Some(popped_value)\n    }\n}",
        "nl_input": "Tries to pop a value out of the queue. If the queue was empty it returns [`None`] otherwise the value packed inside the Option.",
        "gt": "pub fn try_pop(&self) -> Option<T> { match self.used_slots.try_wait().unwrap() { true => self.pop(), false => None, } }",
        "url": 504
    },
    {
        "code_input": "use web3::{Client, types::Address, types::HexString};\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Create a new client\n    let client = Client::new(\"http://localhost:8545\")?;\n\n    // The address of the contract\n    let contract_address = Address::from_str(\"0x18160ddd\")?;\n\n    // Call the totalSupply function\n    let total_supply =",
        "nl_input": "Calls the contract's `totalSupply` (0x18160ddd) function",
        "gt": "pub fn total_supply( &self, ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::U256> { self.0 .method_hash([24, 22, 13, 221], ()) .expect(\"method not found (this should never happen)\") }",
        "url": 505
    },
    {
        "code_input": "fn get_doc_hint(doc: &Vec<String>) -> Option<String> {\n    match doc.get(0) {\n        Some(hint) => Some(hint),\n        None => None\n    }\n}",
        "nl_input": "Returns the value of the first `doc_hint` attribute in the given slice or `None` if `doc_hint` attribute is not available.",
        "gt": "pub fn find_doc_hint(attrs: &[syn::Attribute]) -> Option<String> { attrs.iter().filter_map(doc_hint).next() }",
        "url": 506
    },
    {
        "code_input": "use std::sync::{RwLock, Arc};\nuse std::cell::RefCell;\nuse std::thread;\n\nstruct LazySingleton {\n    value: Option<RwLock<RefCell<i32>>>,\n}\n\nimpl LazySingleton {\n    fn new() -> LazySingleton {\n        LazySingleton {\n            value: None,\n        }\n    }\n\n    fn get_value(&self) -> i32 {\n        let mut value = self.value.take().unwrap();\n        if value.get() == None {\n            let mut local_value = value.get_mut().unwrap();\n            *local_value = Arc::new(RefCell::new(0));\n            *local_value\n        } else {\n            *value.get().unwrap()\n        }\n    }\n\n    fn set_value(&self, new_value: i32) {\n        let",
        "nl_input": "Creates a new [`LazySingleton`] where the underlying value is not yet initialized.",
        "gt": "pub const fn new() -> Self { Self { data: UnsafeCell::new(None), is_initialized: IoxAtomicBool::new(false), is_finalized: IoxAtomicBool::new(false), } }",
        "url": 507
    },
    {
        "code_input": "#[derive(Debug, Clone, Copy)]\nenum Direction {\n    North,\n    East,\n    South,\n    West,\n}\n\n#[derive(Debug, Clone, Copy)]\nstruct Coordinate {\n    x: i32,\n    y: i32,\n}\n\nimpl Coordinate {\n    fn new(x: i32, y: i32) -> Self {\n        Self { x, y }\n    }\n\n    fn move_in_direction(&self, direction: Direction) -> Self {\n        match direction {\n            Direction::North => Self::new(self.x, self.y + 1),\n            Direction::East => Self::new(self.x + 1, self.y),\n            Direction::South => Self::new(self.x, self.y - 1),\n            Direction::West => Self::new(self.x - 1, self.y),\n        }\n    }\n}\n\nfn main() {\n    let start = Coordinate::new(0, 0);",
        "nl_input": "Warns against some misuses of `#[must_use]`",
        "gt": "fn check_must_use(&self, hir_id: HirId, attr: &Attribute, target: Target) { if !matches!( target, Target::Fn | Target::Enum | Target::Struct | Target::Union | Target::Method(_) | Target::ForeignFn | Target::Trait ) { let article = match target { Target::ExternCrate | Target::Enum | Target::Impl | Target::Expression | Target::Arm | Target::AssocConst | Target::AssocTy => \"an\", _ => \"a\", }; self.tcx.emit_node_span_lint( UNUSED_ATTRIBUTES, hir_id, attr.span, errors::MustUseNoEffect { article, target }, ); } }",
        "url": 508
    },
    {
        "code_input": "fn get_block_expressions(body: &Vec<Vec<Expression>>) -> impl Iterator<Item = &Expression> {\n    body.iter().flat_map(|block| block.iter())\n}",
        "nl_input": "Returns an iterator over all block expressions in this body that define inner items.",
        "gt": "pub fn blocks<'a>( &'a self, db: &'a dyn DefDatabase, ) -> impl Iterator<Item = (BlockId, Arc<DefMap>)> + 'a { self.block_scopes.iter().map(move |&block| (block, db.block_def_map(block))) }",
        "url": 509
    },
    {
        "code_input": "use std::collections::HashMap;\nuse std::sync::Arc;\n\n// Define a TaskGraphNode\n#[derive(Debug)]\npub struct TaskGraphNode {\n    name: String,\n    dependencies: Vec<String>,\n    executor: Arc<dyn Executor>,\n}\n\n// Define an Executor trait\npub trait Executor {\n    fn execute(&self, task_graph: &HashMap<String, TaskGraphNode>) -> Result<(), Box<dyn std::error::Error>>;\n}\n\n// Define a TaskExecutor\npub struct TaskExecutor {}\n\n// Implement the Executor trait for TaskExecutor\nimpl Executor for TaskExecutor {\n    fn execute(&self, task_graph: &HashMap<String, TaskGraphNode>) -> Result<(), Box<dyn std::error::Error>> {\n        // TODO: Implement the",
        "nl_input": "Constructs a new executable task from a task graph node.",
        "gt": "pub fn from_task_graph(task_graph: &TaskGraph<'p>, task_id: TaskId) -> Self { let node = &task_graph[task_id]; Self { project: task_graph.project(), name: node.name.clone(), task: node.task.clone(), run_environment: node.run_environment.clone(), additional_args: node.additional_args.clone(), } }",
        "url": 510
    },
    {
        "code_input": "use std::num::NonZeroUsize;\n\nfn main() {\n    let n = 10;\n    let result = NonZeroUsize::new(n).unwrap();\n    println!(\"{}\", result.get());\n}",
        "nl_input": "replace with `NonZeroUsize::new(n).unwrap()` once `unwrap()` is const stabilized",
        "gt": "pub(crate) const fn create_dim(n: usize) -> NonZeroUsize { match NonZeroUsize::new(n) { None => panic!(\"dim must not be 0\"), Some(n) => n, } }",
        "url": 511
    },
    {
        "code_input": "use std::collections::HashMap;\nuse std::fs;\nuse std::path::Path;\nuse std::process;\n\nuse build_dependencies::{BuildDependencies, BuildDependenciesError};\nuse serde::{Deserialize, Serialize};\n\n#[derive(Serialize, Deserialize, Debug)]\nstruct Package {\n    name: String,\n    version: String,\n    features: Vec<String>,\n}\n\nfn main() {\n    let mut packages = HashMap::new();\n\n    let file = std::env::args().nth(1).expect(\"No file provided\");\n    let file_path = Path::new(&file);\n\n    if !file_path.exists() {\n        println!(\"File {} not found\", file);",
        "nl_input": "Returns the combined dependencies to install for this collection. The `build` dependencies overwrite the `host` dependencies which overwrite the `run` dependencies. The dependencies of all features are combined. This means that if two features define a requirement for the same package that both requirements are returned. The different requirements per package are sorted in the same order as the features they came from. If the `platform` is `None` no platform specific dependencies are taken into consideration.",
        "gt": "fn combined_dependencies(&self, platform: Option<Platform>) -> CondaDependencies { self.features() .filter_map(|f| f.combined_dependencies(platform)) .into() }",
        "url": 512
    },
    {
        "code_input": "struct Tree {\n    value: i32,\n    left: Option<Box<Tree>>,\n    right: Option<Box<Tree>>,\n}\n\nimpl Tree {\n    fn split(&mut self) -> (&mut Tree, &mut Tree) {\n        let mut left = self.left.take();\n        let mut right = self.right.take();\n\n        if let Some(left) = left {\n            left.right = None;\n        }\n\n        if let Some(right) = right {\n            right.left = None;\n        }\n\n        (left, right)\n    }\n}",
        "nl_input": "Splits a unique reference into a pair of leaf edges delimiting the full range of the tree. The results are non-unique references allowing massively destructive mutation, so must be used with the utmost care.",
        "gt": "pub fn full_range(self) -> LazyLeafRange<marker::Dying, K, V> { let self2 = unsafe { ptr::read(&self) }; full_range(self, self2) }",
        "url": 513
    },
    {
        "code_input": "pub fn is_some_or_none(option: Option<T>) -> bool {\n    match option {\n        Some(_) => true,\n        None => true,\n        _ => false,\n    }\n}",
        "nl_input": "Methods that are unstable const should not be suggested within a const context, see issue #5697. However, in Rust 1.48.0 the methods `is_some` and `is_none` of `Option` were stabilized as const, so the following should be linted.",
        "gt": "const fn issue6067() { if let Some(_) = Some(42) {} if let None = None::<()> {} while let Some(_) = Some(42) {} while let None = None::<()> {} match Some(42) { Some(_) => true, None => false, }; match None::<()> { Some(_) => false, None => true, }; }",
        "url": 514
    },
    {
        "code_input": "use std::str::FromStr;\n\n#[derive(Debug, PartialEq)]\nenum SearchScope {\n    Code(String),\n    SearchScope(String),\n}\n\nimpl FromStr for SearchScope {\n    type Err = ();\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        if s.contains(\"code\") {\n            Ok(Self::Code(s.into()))\n        } else if s.contains(\"search_scope\") {\n            Ok(Self::SearchScope(s.into()))\n        } else {\n            Err(())\n        }\n    }\n}\n\nfn check_code(code: &str) -> Result<SearchScope, ()> {\n    let search_scope = SearchScope::from_str(code)?;\n    Ok(search_scope)\n}\n\nfn main() {\n    let code = \"This is a code\";\n    match check",
        "nl_input": "Checks if `code` matches the search pattern found in `search_scope`, returning information about the match, if it does. Since we only do matching in this module and searching is done by the parent module, we don't populate nested matches.",
        "gt": "pub(crate) fn get_match( debug_active: bool, rule: &ResolvedRule, code: &SyntaxNode, restrict_range: &Option<FileRange>, sema: &Semantics<'_, ide_db::RootDatabase>, ) -> Result<Match, MatchFailed> { record_match_fails_reasons_scope(debug_active, || { Matcher::try_match(rule, code, restrict_range, sema) }) }",
        "url": 515
    },
    {
        "code_input": "use std::collections::HashMap;\nuse std::sync::Arc;\n\nuse ndarray::Array;\nuse ndarray_rand::rand_distr::Uniform;\nuse ndarray_rand::RandomExt;\nuse ndarray_rand::Random;\n\nuse serde::Deserialize;\nuse serde_json::Value;\n\nuse crate::{\n    query::Query,\n    table::{OwnedTable, Table},\n};\n\n#[derive(Debug, Clone, Deserialize)]\npub struct Transformation {\n    pub select: HashMap<String, Value>,\n}\n\nimpl Transformation {\n    pub fn apply(&self, table: &Arc<OwnedTable>, query: &Query) -> Result<Array<f64>, Box<dyn std::error::Error>> {\n        let mut result = Array::new(table",
        "nl_input": "Apply the select transformation to the given `OwnedTable`.",
        "gt": "fn apply(&self, owned_table: OwnedTable<S>) -> PostprocessingResult<OwnedTable<S>> { let cols: IndexMap<Identifier, OwnedColumn<S>> = self .aliased_result_exprs .iter() .map( |aliased_result_expr| -> PostprocessingResult<(Identifier, OwnedColumn<S>)> { let result_column = owned_table.evaluate(&aliased_result_expr.expr)?; Ok((aliased_result_expr.alias, result_column)) }, ) .collect::<PostprocessingResult<_>>()?; Ok(OwnedTable::try_new(cols)?) }",
        "url": 516
    },
    {
        "code_input": "fn main() {\n    let mut universe: f32 = 42.0; // Initialize the variable\n    let ui: f32 = 10.0; // Define the new value\n\n    // Check if the updated universe is the root\n    if universe == ui {\n        println!(\"The updated universe is the root.\");\n    } else {\n        universe = ui; // Replace the universe\n        println!(\"The updated universe is not the root.\");\n    }\n}",
        "nl_input": "Replaces the universe of this canonical variable with `ui`. In case this is a float or int variable, this causes an ICE if the updated universe is not the root.",
        "gt": "pub fn with_updated_universe(self, ui: UniverseIndex) -> CanonicalVarKind<I> { match self { CanonicalVarKind::Ty(CanonicalTyVarKind::General(_)) => { CanonicalVarKind::Ty(CanonicalTyVarKind::General(ui)) } CanonicalVarKind::Region(_) => CanonicalVarKind::Region(ui), CanonicalVarKind::Const(_) => CanonicalVarKind::Const(ui), CanonicalVarKind::PlaceholderTy(placeholder) => { CanonicalVarKind::PlaceholderTy(placeholder.with_updated_universe(ui)) } CanonicalVarKind::PlaceholderRegion(placeholder) => { CanonicalVarKind::PlaceholderRegion(placeholder.with_updated_universe(ui)) } CanonicalVarKind::PlaceholderConst(placeholder) => { CanonicalVarKind::PlaceholderConst(placeholder.with_updated_universe(ui)) } CanonicalVarKind::Ty(CanonicalTyVarKind::Int | CanonicalTyVarKind::Float) => { assert_eq!(ui, UniverseIndex::ROOT); self } } }",
        "url": 517
    },
    {
        "code_input": "pub fn is_crate_attribute(attr: &str) -> bool {\n    match attr {\n        \"crate::\" => true,\n        _ => false,\n    }\n}",
        "nl_input": "Checks that an attribute is used at the crate level. Returns `true` if valid.",
        "gt": "fn check_attr_crate_level( &self, attr: &Attribute, meta: &MetaItemInner, hir_id: HirId, ) -> bool { if hir_id != CRATE_HIR_ID { let bang_span = attr.span.lo() + BytePos(1); let sugg = (attr.style == AttrStyle::Outer && self.tcx.hir().get_parent_item(hir_id) == CRATE_OWNER_ID) .then_some(errors::AttrCrateLevelOnlySugg { attr: attr.span.with_lo(bang_span).with_hi(bang_span), }); self.tcx.emit_node_span_lint( INVALID_DOC_ATTRIBUTES, hir_id, meta.span(), errors::AttrCrateLevelOnly { sugg }, ); return false; } true }",
        "url": 518
    },
    {
        "code_input": "use reqwest::Error;\nuse tokio::net::TcpStream;\nuse tokio_util::compat::TokioAsyncWriteCompatExt;\n\n#[tokio::main]\nasync fn main() -> Result<(), Error> {\n    let stream = TcpStream::connect(\"example.com:80\").await?;\n    let mut headers = reqwest::Headers::new();\n    headers.insert(reqwest::header::USER_AGENT, \"my-app/0.1.0\");\n\n    let response = reqwest::Client::new()\n        .post(\"http://example.com/\")\n        .headers(headers)\n        .send()\n        .await?;\n\n    let stream_id = response.headers().get(reqwest::header::X_STREAM_ID)?.to_string();\n\n    println!(\"Stream ID: {}\", stream",
        "nl_input": "Client send a new request with default headers. Return stream_id and the headers list on success.",
        "gt": "pub fn send_request(&mut self, fin: bool) -> Result<(u64, Vec<Header>)> { let req_headers = Session::default_request_headers(); let stream_id = self.client.stream_new(&mut self.pair.client)?; self.client .send_headers(&mut self.pair.client, stream_id, &req_headers, fin)?; self.move_forward().ok(); Ok((stream_id, req_headers)) }",
        "url": 519
    },
    {
        "code_input": "use serde::{Deserialize, Serialize};\n\n#[derive(Serialize, Deserialize, Debug)]\nstruct Value {\n    // Define your fields here\n    field1: String,\n    field2: i32,\n    field3: f64,\n    // ...\n}\n\nfn parse_value(sort_key: &str) -> Result<Value, serde_json::Error> {\n    let value: Value = serde_json::from_str(sort_key)?;\n    Ok(value)\n}\n\nfn main() {\n    let sort_key = r#\"{\"field1\": \"value1\", \"field2\": 2, \"field3\": 3.0}\"#;\n    match parse_value(sort_key) {\n        Ok(value) => println!(\"{:?}\", value),\n        Err(e",
        "nl_input": "Parse a `Value` from a sort key.",
        "gt": "pub fn read_sort_key<R: Read>(reader: &mut R) -> anyhow::Result<Self> { Self::_read_sort_key(&mut BytePeeker::new(reader)) }",
        "url": 520
    },
    {
        "code_input": "use std::sync::{Arc, Mutex};\nuse std::ptr::null_mut;\n\nfn main() {\n    let shared = Arc::new(Mutex::new(5));\n    let raw_ptr = Arc::borrow_mut(&shared);\n\n    // Use raw pointer\n    *raw_ptr = 6;\n\n    println!(\"{}\", *Arc::borrow(&shared));\n}",
        "nl_input": "Make sure that creating a raw ptr next to a shared ref works but the shared ref still gets invalidated when the raw ptr is used for writing.",
        "gt": "fn main() { unsafe { use std::mem; let x = &mut 0; let y1: &i32 = mem::transmute(&*x); let y2 = x as *mut _; let _val = *y2; let _val = *y1; *y2 += 1; let _fail = *y1; } }",
        "url": 521
    },
    {
        "code_input": "println!(\"EMIT_MIR {}\", \"mem_replace.manual_replace.PreCodegen.after.mir\");",
        "nl_input": "EMIT_MIR mem_replace.manual_replace.PreCodegen.after.mir",
        "gt": "pub fn manual_replace(r: &mut u32, v: u32) -> u32 { let temp = *r; *r = v; temp }",
        "url": 522
    },
    {
        "code_input": "use std::fs::File;\nuse std::io::Error;\nuse std::path::Path;\n\nstruct FileManager {\n    open_files: Vec<String>,\n}\n\nimpl FileManager {\n    fn new() -> Self {\n        Self {\n            open_files: Vec::new(),\n        }\n    }\n\n    fn open_file(&mut self, path: &str) -> Result<File, Error> {\n        if self.is_file_open(path) {\n            return Err(Error::new(\n                std::io::ErrorKind::AlreadyExists,\n                \"File is already open\",\n            ));\n        }\n\n        let path = Path::new(path);\n        let file = File::open(path)?;\n\n        self.open_files.push(path.to_string());\n\n        Ok(file)",
        "nl_input": "Return an error if the file is already open.",
        "gt": "fn check_not_open(&self) -> lx::Result<()> { if self.file.is_some() { return Err(lx::Error::EINVAL); } Ok(()) }",
        "url": 523
    },
    {
        "code_input": "fn main() {\n    let mut arr = [1, 2, 3, 4, 5];\n    let index = 2;\n\n    if index < arr.len() {\n        let value = arr.get(index).unwrap();\n        println!(\"Value at index {} is: {}\", index, value);\n    } else {\n        println!(\"Index out of bounds\");\n    }\n}",
        "nl_input": "Get the value at this index mutably, if it exists.",
        "gt": "pub fn get_mut(&mut self, idx: UniIndex) -> Option<&mut V> { self.data.get_mut(idx.idx as usize).and_then(Option::as_mut) }",
        "url": 524
    },
    {
        "code_input": "use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};\nuse near_sdk::{env, near_bindgen};\n\n#[near_bindgen]\n#[derive(BorshDeserialize, BorshSerialize)]\npub struct SpotPriceUpdate {\n    pub price: f64,\n}\n\nimpl env::log::Log for SpotPriceUpdate {\n    fn title(&self) -> String {\n        String::from(\"SpotPriceUpdate\")\n    }\n}\n\n#[near_bindgen]\nimpl env::event::Event for SpotPriceUpdate {\n    fn new(price: f64) -> Self {\n        Self { price }\n    }\n\n    fn title(&self) -> String {\n        String::from(\"SpotPriceUpdate\")\n    }\n\n    fn deserialize(input:",
        "nl_input": "Gets the contract's `SpotPriceUpdate` event",
        "gt": "pub fn spot_price_update_filter( &self, ) -> ::ethers::contract::builders::Event< ::std::sync::Arc<M>, M, SpotPriceUpdateFilter, > { self.0.event() }",
        "url": 525
    },
    {
        "code_input": "use lower_intrinsics::unchecked::LowerIntrinsics;\n\nfn main() {\n    let result = LowerIntrinsics::diff(10, 5);\n    println!(\"{}\", result);\n}",
        "nl_input": "EMIT_MIR lower_intrinsics.unchecked.LowerIntrinsics.diff",
        "gt": "pub unsafe fn unchecked(a: i32, b: i32, c: u32) { let _a = core::intrinsics::unchecked_add(a, b); let _b = core::intrinsics::unchecked_sub(a, b); let _c = core::intrinsics::unchecked_mul(a, b); let _x = core::intrinsics::unchecked_div(a, b); let _y = core::intrinsics::unchecked_rem(a, b); let _i = core::intrinsics::unchecked_shl(a, b); let _j = core::intrinsics::unchecked_shr(a, b); let _k = core::intrinsics::unchecked_shl(a, c); let _l = core::intrinsics::unchecked_shr(a, c); }",
        "url": 526
    },
    {
        "code_input": "#![feature(box_syntax)]\n\nuse std::boxed::Box;\n\n#[derive(Debug, PartialEq)]\nstruct HiddenType<T> {\n    value: T,\n}\n\nimpl<T> HiddenType<T> {\n    fn new(value: T) -> Self {\n        Self { value }\n    }\n\n    fn get_value(&self) -> &T {\n        &self.value\n    }\n}\n\n#[derive(Debug, PartialEq)]\nstruct OuterImplTrait {\n    hidden_type: HiddenType<[&'?15 u8; 1]>,\n}\n\n#[derive(Debug, PartialEq)]\nstruct InnerImplTrait {\n    hidden_type: HiddenType<[&'?15 u8; 1]>,\n}\n\nfn main() {\n    let outer_impl_trait = OuterImplTrait {\n        hidden_type: HiddenType::new",
        "nl_input": "Assuming the hidden type is `[&'?15 u8; 1]`, we have two distinct member constraints: - '?15 member ['static, 'a, 'b] from outer impl-trait - '?15 member ['static, 'a, 'b] from inner impl-trait To satisfy both we can choose 'a or 'b, so it's a failure due to ambiguity.",
        "gt": "fn fail_early_bound<'s, 'a, 'b>(a: &'s u8) -> impl IntoIterator<Item = impl Cap<'a> + Cap<'b>> where 's: 'a, 's: 'b, { [a] }",
        "url": 527
    },
    {
        "code_input": "use reqwest::Error;\nuse serde::Deserialize;\n\n#[derive(Debug, Deserialize)]\nstruct InspectResponse {\n    data: String,\n}\n\npub fn inspect(url: &str) -> Result<InspectResponse, Error> {\n    let response = reqwest::get(url).await?;\n    let inspect_response: InspectResponse = response.json().await?;\n    Ok(inspect_response)\n}",
        "nl_input": "Used for on-demand inspect calls.",
        "gt": "pub fn inspect_proc(req: Request<'_>) { req.respond() .sensitivity_child(\"meminfo\", SensitivityLevel::Safe, inspect_meminfo) .sensitivity_child(\"interrupts\", SensitivityLevel::Safe, inspect_interrupts) .sensitivity_child(\"processes\", SensitivityLevel::Safe, inspect_userspace_procs); }",
        "url": 528
    },
    {
        "code_input": "I'm sorry, but the code you're asking for is not provided. Could you please provide more details or clarify what the query is?\n",
        "nl_input": "~^ NOTE: in Rust 2018, `tup` is dropped here, but in Rust 2021, only `tup.0` will be dropped here as part of the closure",
        "gt": "fn main() { test1_all_need_migration(); test2_only_precise_paths_need_migration(); test3_only_by_value_need_migration(); test4_type_contains_drop_need_migration(); test5_drop_non_drop_aggregate_need_migration(); test6_significant_insignificant_drop_aggregate_need_migration(); test7_move_closures_non_copy_types_might_need_migration(); test8_drop_order_and_blocks(); test9_drop_order_and_nested_closures(); test10_vec_of_significant_drop_type(); }",
        "url": 529
    },
    {
        "code_input": "use std::collections::HashMap;\n\nfn main() {\n    let request_message = \"What is the tool name?\";\n    let tool_prompt = create_tool_prompt(request_message);\n    println!(\"{}\", tool_prompt);\n}\n\nfn create_tool_prompt(request_message: &str) -> String {\n    let mut tool_prompt = String::new();\n    tool_prompt.push_str(\"Tool: \");\n    tool_prompt.push_str(request_message.split_whitespace().next().unwrap());\n    tool_prompt\n}",
        "nl_input": "create a tool prompt from a chat completion request message.",
        "gt": "fn append_tool_message( &self, chat_history: impl AsRef<str>, message: &ChatCompletionToolMessage, ) -> String { format!( \"{chat_history}\\n<|im_start|>tool\\n<tool_response>\\n{tool_message}\\n</tool_response>\\n<|im_end|>\", chat_history = chat_history.as_ref().trim(), tool_message = message.content().trim(), ) }",
        "url": 530
    },
    {
        "code_input": "#[rustc_clean]\nfn main() {\n    // This is a sanity check. If this function returns false, the system is not dirty-clean.\n    if !check_sanity() {\n        panic!(\"System is not dirty-clean\");\n    }\n}\n\n#[rustc_clean]\nfn check_sanity() -> bool {\n    // This is a placeholder for the actual sanity check.\n    // In a real system, this would be a function that checks if all dependencies are up-to-date,\n    // and if the code is free from hard-to-find bugs.\n    true\n}",
        "nl_input": "Sanity check for the dirty-clean system. We add #[rustc_clean] attributes in places that are not checked and make sure that this causes an error.",
        "gt": "fn main() { #[rustc_clean(except=\"hir_owner\", cfg=\"cfail2\")] { } #[rustc_clean(cfg=\"cfail2\")] { } }",
        "url": 531
    },
    {
        "code_input": "use std::fs::File;\nuse std::io::Write;\nuse std::path::Path;\nuse log::{Record, Level, Metadata, Log, Config};\nuse std::io::BufWriter;\n\npub struct FramebufferLogger<F: AsRef<str>> {\n    path: Path,\n    framebuffer: F,\n}\n\nimpl<F: AsRef<str>> FramebufferLogger<F> {\n    pub fn new(path: Path, framebuffer: F) -> Self {\n        Self {\n            path,\n            framebuffer,\n        }\n    }\n}\n\nimpl Log for FramebufferLogger<&str> {\n    fn enabled(&self, metadata: &Metadata) -> bool {\n        metadata.level() <= Level::Info\n    }\n\n    fn log(&self, record: &Record) {\n        let mut file = match File::create",
        "nl_input": "Creates a new logger that uses the given framebuffer.",
        "gt": "pub fn new(framebuffer: &'static mut [u8], info: FrameBufferInfo) -> Self { let mut logger = Self { framebuffer, info, x_pos: 0, y_pos: 0, level: 0, }; logger.clear(); logger }",
        "url": 532
    },
    {
        "code_input": "use std::process::Command;\n\nfn main() {\n    let linker = Command::new(\"ld\")\n        .arg(\"-r\") // Relocations in the produced ELF files are read-only\n        .arg(\"-B\") // Suppress lazy binding\n        .arg(\"-o\")\n        .arg(\"output.o\");\n\n    let elf_file = Command::new(\"gcc\")\n        .arg(\"-c\")\n        .arg(\"input.c\");\n\n    let output = elf_file.output()\n        .expect(\"Failed to execute gcc\");\n\n    if output.status.success() {\n        let link_output = linker.output()\n            .expect(\"Failed to execute linker\");\n\n        if link_output",
        "nl_input": "Add options making relocation sections in the produced ELF files read-only and suppressing lazy binding.",
        "gt": "fn add_relro_args(cmd: &mut dyn Linker, sess: &Session) { match sess.opts.cg.relro_level.unwrap_or(sess.target.relro_level) { RelroLevel::Full => cmd.full_relro(), RelroLevel::Partial => cmd.partial_relro(), RelroLevel::Off => cmd.no_relro(), RelroLevel::None => {} } }",
        "url": 533
    },
    {
        "code_input": "use std::collections::HashMap;\n\nfn replace_all(script: &mut String) {\n    let all_commands = HashMap::new();\n    all_commands.insert(\":all\", \"all_commands\");\n\n    for (old, new) in all_commands {\n        script.replacen(old, new, &mut String::new());\n    }\n}\n\nfn main() {\n    let mut script = String::from(\"_all:all_commands\");\n    replace_all(&mut script);\n    println!(\"{}\", script);\n}",
        "nl_input": "Replace the parts of the zsh completion script that need different functionality.",
        "gt": "fn replace_zsh_completion(script: &str) -> Cow<str> { let pattern = r\"(?ms)(\\(run\\))(?:.*?)(_arguments.*?)(\\*::task)\"; let replacement = r#\"$1 local tasks tasks=(\"$${(@s/ /)$$(pixi task list --machine-readable 2> /dev/null)}\") if [[ -n \"$$tasks\" ]]; then _values 'task' \"$${tasks[@]}\" else return 1 fi $2::task\"#; let re = Regex::new(pattern).unwrap(); re.replace(script, replacement) }",
        "url": 534
    },
    {
        "code_input": "fn main() {\n    println!(\"{}\", foo());\n}\n\nfn foo() -> Option<()> {\n    None\n}",
        "nl_input": "lint not just `return None`, but also `return None;` (note the semicolon)",
        "gt": "fn issue11993(y: Option<i32>) -> Option<i32> { let Some(x) = y else { return None; }; let Some(x) = y else { todo!(); return None; }; let Some(x) = y else { return None; }; None }",
        "url": 535
    },
    {
        "code_input": "use rust_embed::RustEmbed;\n\n#[derive(RustEmbed)]\n#[folder = \"target/rnacos-web\"]\nstruct Asset;\n\nfn main() {\n    let asset = Asset::load().unwrap();\n    println!(\"{}\", String::from_utf8_lossy(&asset.data()));\n}",
        "nl_input": "* use rust_embed::RustEmbed; #[derive(RustEmbed)] #[folder = \"target rnacos-web\"] struct Asset; *",
        "gt": "fn handle_embedded_file(path: &str) -> HttpResponse { match get_embedded_file(path) { Some(content) => HttpResponse::Ok() .content_type(from_path(path).first_or_octet_stream().as_ref()) .body(content.data.into_owned()), None => HttpResponse::NotFound().body(\"404 Not Found\"), } }",
        "url": 536
    },
    {
        "code_input": "fn main() {\n    let _ = 1;\n}",
        "nl_input": "@ compile-flags: --force-warn while_true @ compile-flags: --force-warn unused_variables @ compile-flags: --force-warn unused_mut @ check-pass",
        "gt": "fn expect_early_pass_lint(terminate: bool) { #[expect(while_true)] while !terminate { println!(\"Do you know what a spin lock is?\") } }",
        "url": 537
    },
    {
        "code_input": "use pathspec::Pathspec;\n\nfn is_path_spec(s: &str) -> bool {\n    let pathspec = Pathspec::parse(s).unwrap();\n    pathspec.is_pathspec()\n}\n\nfn main() {\n    let path = \"/path/to/file\";\n    let path_spec = \"path=/path/to/file\";\n\n    println!(\"{}\", is_path_spec(&path)); // true\n    println!(\"{}\", is_path_spec(&path_spec)); // true\n}",
        "nl_input": "Returns the path spec if this instance is a path spec.",
        "gt": "pub fn into_path(self) -> Option<PinnedPathSpec> { match self { MutablePinnedSourceSpec::Path(spec) => Some(spec), } }",
        "url": 538
    },
    {
        "code_input": "use std::collections::HashMap;\n\nstruct OrderBook {\n    bids: HashMap<f64, Vec<(f64, u32)>>,\n    asks: HashMap<f64, Vec<(f64, u32)>>,\n}\n\nimpl OrderBook {\n    fn new() -> Self {\n        OrderBook {\n            bids: HashMap::new(),\n            asks: HashMap::new(),\n        }\n    }\n\n    fn process_event(&mut self, event: &str) {\n        match event {\n            \"new_bid\" => {\n                // Process a new bid event\n            },\n            \"new_ask\" => {\n                // Process a new ask event\n            },\n            _ => {\n                // Ignore other events\n            }\n        }\n    }\n\n    fn can_arbitrate(&self) -> bool {\n        // Check",
        "nl_input": "Process incoming events, seeing if we can arb new orders, and updating the internal state on new blocks.",
        "gt": "async fn process_event(&mut self, event: Event) -> Vec<Action> { match event { Event::OpenseaOrder(order) => self .process_order_event(*order) .await .map_or(vec![], |a| vec![a]), Event::NewBlock(block) => match self.process_new_block_event(block).await { Ok(_) => vec![], Err(e) => { panic!(\"Strategy is out of sync {}\", e); } }, } }",
        "url": 539
    },
    {
        "code_input": "use std::thread;\nuse std::time::Duration;\n\n// Assume these are defined elsewhere\npub struct ThreadPool;\npub struct Vfs;\n\nimpl ThreadPool {\n    pub fn new() -> ThreadPool {\n        ThreadPool\n    }\n\n    pub fn dispatch(&self, task: impl FnOnce() -> R::Result + 'static) -> R::Result {\n        let _ = thread::spawn(task);\n        Ok(())\n    }\n}\n\nimpl Vfs {\n    pub fn is_ready(&self) -> bool {\n        // Implementation depends on your Vfs\n        false\n    }\n}\n\npub fn perform_request(thread_pool: &ThreadPool, vfs: &Vfs) -> R::Result {\n    if !vfs.is_ready() {\n        return Err(R::Result::default());\n    }\n\n    thread_pool.dispatch(move || {\n        //",
        "nl_input": "Dispatches a non-latency-sensitive request onto the thread pool. When the VFS is marked not ready this will return a default constructed [`R::Result`].",
        "gt": "pub(crate) fn on<const ALLOW_RETRYING: bool, R>( &mut self, f: fn(GlobalStateSnapshot, R::Params) -> anyhow::Result<R::Result>, ) -> &mut Self where R: lsp_types::request::Request< Params: DeserializeOwned + panic::UnwindSafe + Send + fmt::Debug, Result: Serialize + Default, > + 'static, { if !self.global_state.vfs_done { if let Some(lsp_server::Request { id, .. }) = self.req.take_if(|it| it.method == R::METHOD) { self.global_state.respond(lsp_server::Response::new_ok(id, R::Result::default())); } return self; } self.on_with_thread_intent::<true, ALLOW_RETRYING, R>( ThreadIntent::Worker, f, Self::content_modified_error, ) }",
        "url": 540
    },
    {
        "code_input": "use std::thread;\nuse std::time::Duration;\nuse std::future::Future;\n\nfn main() {\n    let (tx, rx) = thread::spawn((|| {\n        let value = \"Hello, world!\";\n        // Send the value to the other thread\n        tx.send(value).unwrap();\n        // This line will never be reached\n    })).join().unwrap();\n\n    // Receive the value from the other thread\n    let received_value = rx.recv().unwrap();\n\n    println!(\"Received: {}\", received_value);\n}",
        "nl_input": "~^ ERROR: future cannot be sent between threads safely",
        "gt": "fn main() { let rc = Rc::new([1, 2, 3]); private_future(rc.clone(), &Cell::new(42)); public_future(rc.clone()); let arc = Arc::new([4, 5, 6]); public_send(arc); generic_future(42); generic_future_send(42); let dummy = Dummy { rc }; dummy.public_future(); dummy.public_send(); }",
        "url": 541
    },
    {
        "code_input": "{\n    \"code\": \"fn main() { println!(\\\"Hello, world!\\\"); }\",\n    \"control_brace_style\": \"always_next_line\"\n}",
        "nl_input": "rustfmt-control_brace_style: AlwaysNextLine",
        "gt": "fn main() { if false { (); (); } if false { (); (); } let a = if 0 > 1 { unreachable!() } else { 0x0 }; if true { (); } else if false { (); (); } else { (); (); (); } if true { (); } else if false { (); (); } else { (); (); (); } }",
        "url": 542
    },
    {
        "code_input": "use std::cmp::Ordering;\n\n#[derive(Debug, Clone, Copy)]\nstruct Partition {\n    id: u32,\n    value: f32,\n    weight: f32,\n}\n\nfn compute_stats(partitions: Vec<Partition>) -> (f32, f32, f32) {\n    let mut sum_value = 0.0;\n    let mut sum_weight = 0.0;\n    let mut min_value = f32::INFINITY;\n    let mut max_value = f32::NEG_INFINITY;\n    let mut min_weight = f32::INFINITY;\n    let mut max_weight = f32::NEG_INFINITY;\n\n    for partition in partitions.iter() {\n        sum_value",
        "nl_input": "compute stats for Vec of Partition's",
        "gt": "pub fn meta_chunks_stats(chunks: &[Partition]) -> PartitionStats { chunks .iter() .map(|chunk| chunk.stats()) .fold(PartitionStats { ..Default::default() }, |acc, stats| acc.fold(stats)) }",
        "url": 543
    },
    {
        "code_input": "use std::sync::{Arc, atomic::{AtomicUsize, Ordering}};\nuse std::thread;\nuse std::time::Duration;\n\nstruct MyThread {\n    id: usize,\n    counter: Arc<AtomicUsize>,\n}\n\nimpl MyThread {\n    fn new(id: usize) -> MyThread {\n        MyThread {\n            id,\n            counter: Arc::new(AtomicUsize::new(0)),\n        }\n    }\n\n    fn increment(&self) {\n        let old = self.counter.fetch(Ordering::SeqCst);\n        let new = old.map_loaded(|c| c + 1).unwrap_or(1);\n        while !self.counter.compare_and_swap(old, new, Ordering::SeqC",
        "nl_input": "Check that the destructor can be blocked joining another thread.",
        "gt": "fn check_blocking() { struct JoinCell { value: RefCell<Option<thread::JoinHandle<u8>>>, } impl Drop for JoinCell { fn drop(&mut self) { for _ in 0..10 { thread::yield_now(); } let join_handle = self.value.borrow_mut().take().unwrap(); println!( \"Joining: {} (should be before 'Continue main 2').\", join_handle.join().unwrap() ); } } thread_local! { static B: JoinCell = JoinCell { value: RefCell::new(None) }; } thread::spawn(|| { B.with(|f| { assert!(f.value.borrow().is_none()); let handle = thread::spawn(|| 7); *f.value.borrow_mut() = Some(handle); }); }) .join() .unwrap(); println!(\"Continue main 2.\"); }",
        "url": 544
    },
    {
        "code_input": "use web3::{Client, types::Address, types::HexString};\nuse serde_json::Value;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Create a new Web3 client\n    let client = Client::new(\"https://mainnet.infura.io/v3/YOUR_INFURA_KEY\")?;",
        "nl_input": "Calls the contract's `name` (0x06fdde03) function",
        "gt": "pub fn name( &self, ) -> ::ethers::contract::builders::ContractCall<M, ::std::string::String> { self.0 .method_hash([6, 253, 222, 3], ()) .expect(\"method not found (this should never happen)\") }",
        "url": 545
    },
    {
        "code_input": "use std::fs::remove_file;\nuse std::path::Path;\n\nfn remove_files(work_product: String) {\n    let path = Path::new(&work_product);\n    if path.exists() {\n        if path.is_dir() {\n            remove_file(path).unwrap();\n        } else {\n            println!(\"{} is not a directory\", work_product);\n        }\n    } else {\n        println!(\"{} does not exist\", work_product);\n    }\n}",
        "nl_input": "Removes files for a given work product.",
        "gt": "pub(crate) fn delete_workproduct_files(sess: &Session, work_product: &WorkProduct) { for (_, path) in work_product.saved_files.items().into_sorted_stable_ord() { let path = in_incr_comp_dir_sess(sess, path); if let Err(err) = std_fs::remove_file(&path) { sess.dcx().emit_warn(errors::DeleteWorkProduct { path: &path, err }); } } }",
        "url": 546
    },
    {
        "code_input": "fn main() {\n    let bytes: [u8; 5] = [1, 2, 3, 4, 5];\n    println!(\"{:?}\", bytes);\n}",
        "nl_input": "Creates an allocation initialized by the given bytes",
        "gt": "pub fn from_bytes<'a>( slice: impl Into<Cow<'a, [u8]>>, align: Align, mutability: Mutability, ) -> Self { let bytes = Bytes::from_bytes(slice, align); let size = Size::from_bytes(bytes.len()); Self { bytes, provenance: ProvenanceMap::new(), init_mask: InitMask::new(size, true), align, mutability, extra: (), } }",
        "url": 547
    },
    {
        "code_input": "pub struct Node {\n    key: i32,\n    value: i32,\n    next: Option<Box<Node>>,\n}\n\nimpl Node {\n    pub fn insert_key_value(&mut self, key: i32, value: i32) -> &mut i32 {\n        let mut new_node = Box::new(Node {\n            key: key,\n            value: value,\n            next: None,\n        });\n\n        if self.next.is_none() {\n            self.next = Some(new_node);\n        } else {\n            let mut current_node = self.next.unwrap();\n            while current_node.next.is_some() {\n                current_node = *current_node.next.unwrap();\n            }\n            current_node.",
        "nl_input": "Adds a key-value pair to the end of the node, and returns the mutable reference of the inserted value.",
        "gt": "pub fn push(&mut self, key: K, val: V) -> *mut V { unsafe { self.push_with_handle(key, val).into_val_mut() } }",
        "url": 548
    },
    {
        "code_input": "use web3::{Client, types::Address, types::HexString};\nuse serde_json::Value;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Create a new client\n    let client = Client::new(\"http://localhost:8545\")?;\n\n    // The address of the contract\n    let contract_address = Address::from_str(\"0xd8a1890c\")?;\n\n    // The",
        "nl_input": "Calls the contract's `changeSpotPrice` (0xd8a1890c) function",
        "gt": "pub fn change_spot_price( &self, new_spot_price: u128, ) -> ::ethers::contract::builders::ContractCall<M, ()> { self.0 .method_hash([216, 161, 137, 12], new_spot_price) .expect(\"method not found (this should never happen)\") }",
        "url": 549
    },
    {
        "code_input": "use std::fs::File;\nuse std::io::BufReader;\nuse toml::value::Value;\nuse toml::toml_array;\nuse toml::toml_map;\nuse toml::toml_str;\n\nfn read_config() -> Result<Value, toml::de::Error> {\n    let file = File::open(\"config.toml\")?;\n    let reader = BufReader::new(file);\n    let value = toml::parse_document(reader)?;\n    Ok(value)\n}\n\nfn main() {\n    match read_config() {\n        Ok(value) => println",
        "nl_input": "Read existing configuration of trampoline from the root path.",
        "gt": "pub async fn from_root_path( root_path: PathBuf, exposed_name: &ExposedName, ) -> miette::Result<Self> { let manifest_path = root_path .join(TRAMPOLINE_CONFIGURATION) .join(exposed_name.to_string() + \".json\"); let manifest_str = tokio_fs::read_to_string(manifest_path) .await .into_diagnostic()?; serde_json::from_str(&manifest_str).into_diagnostic() }",
        "url": 550
    },
    {
        "code_input": "fn main() {\n    let x = 5;\n    match x {\n        0 => println!(\"x is zero\"),\n        1 => println!(\"x is one\"),\n        2 => println!(\"x is two\"),\n        3 => println!(\"x is three\"),\n        4 => println!(\"x is four\"),\n        5 => println!(\"x is five\"),\n        _ => println!(\"x is not 0-5\"),\n    }\n}",
        "nl_input": "rustfmt-max_width: 120 rustfmt-match_arm_blocks: false rustfmt-match_block_trailing_comma: true",
        "gt": "fn a_very_very_very_very_very_very_very_very_very_very_very_long_function_name() -> i32 { 42 }",
        "url": 551
    },
    {
        "code_input": "use std::io::prelude::*;\nuse std::io::Result;\nuse std::os::unix::io::AsRawFd;\nuse std::os::unix::io::AsRawTextMode;\nuse std::os::unix::io::RawFd;\nuse std::os::unix::io::RawTextMode;\nuse std::os::unix::io::{AsRawTextMode, AsRawFd, RawFd, RawTextMode};\nuse std::os::unix::net::TcpStream;\nuse std::os::unix::net::TcpStreamExt;\nuse std::os::unix::net::TcpListener;\nuse std::os::unix::net::TcpListenerExt;\nuse std::os::unix",
        "nl_input": "@ignore-target: windows # no libc socketpair on Windows This is temporarily here because blocking on fd is not supported yet. When blocking is eventually supported, this will be moved to pass-dep libc libc-socketpair",
        "gt": "fn main() { let mut fds = [-1, -1]; let _ = unsafe { libc::socketpair(libc::AF_UNIX, libc::SOCK_STREAM, 0, fds.as_mut_ptr()) }; let arr1: [u8; 212992] = [1; 212992]; let _ = unsafe { libc::write(fds[0], arr1.as_ptr() as *const libc::c_void, 212992) }; let data = \"abc\".as_bytes().as_ptr(); let _ = unsafe { libc::write(fds[0], data as *const libc::c_void, 3) }; let mut buf: [u8; 3] = [0; 3]; let _res = unsafe { libc::read(fds[1], buf.as_mut_ptr().cast(), buf.len() as libc::size_t) }; }",
        "url": 552
    },
    {
        "code_input": "use std::iter::FromIterator;\n\nuse rust_ast::{StmtList, Stmt};\n\nfn remove_methods(list: &mut StmtList) {\n    list.stmts.clear();\n    list.stmts.extend(FromIterator::from_iter(list.stmts.iter().filter(|stmt| stmt.is_method_call() == false)));\n}",
        "nl_input": "FIXME: remove all these methods, they belong to ast::StmtList",
        "gt": "pub fn statements(&self) -> impl Iterator<Item = ast::Stmt> { self.stmt_list().into_iter().flat_map(|it| it.statements()) }",
        "url": 553
    },
    {
        "code_input": "use std::fs;\nuse std::path::Path;\n\nfn get_folder_segments(path: &Path) -> Vec<String> {\n    let mut folder_segments = Vec::new();\n    for component in path.components() {\n        folder_segments.push(component.to_string_lossy().into_owned());\n    }\n    folder_segments\n}\n\nfn get_mod_folders(path: &Path) -> Vec<String> {\n    let mut mod_folders = Vec::new();\n    for folder in path.ancestors() {\n        let folder_segments = get_folder_segments(&folder);\n        if folder_segments.last() == Some(\"mod.rs\") {\n            mod_folders.push(folder_segments.iter().take(folder_",
        "nl_input": "For each `path` we add each folder component to `folder_segments` and if the file name is `mod.rs` we add it's parent folder to `mod_folders`.",
        "gt": "fn process_paths_for_mod_files<'a>( path: &'a Path, folder_segments: &mut FxIndexSet<&'a OsStr>, mod_folders: &mut FxHashSet<&'a OsStr>, ) { let mut comp = path.components().rev().peekable(); let _: Option<_> = comp.next(); if path.ends_with(\"mod.rs\") { mod_folders.insert(comp.peek().map(|c| c.as_os_str()).unwrap_or_default()); } let folders = comp.filter_map(|c| if let Component::Normal(s) = c { Some(s) } else { None }); folder_segments.extend(folders); }",
        "url": 554
    },
    {
        "code_input": "fn string_to_chars(s: &str) -> Vec<char> {\n    s.chars().collect()\n}",
        "nl_input": "C says that passing \"invalid\" pointers is UB for all string functions. It is unclear whether `(int*)42` is \"invalid\", but there is no actually a `char` living at that address, so arguably it cannot be a valid pointer. Hence this is UB.",
        "gt": "fn main() { let ptr = 42 as *const u8; unsafe { libc::memcmp(ptr.cast(), ptr.cast(), 0); } }",
        "url": 555
    },
    {
        "code_input": "pub struct Event {\n    pub from: String,\n    pub to: String,\n    pub value: u64,\n}",
        "nl_input": "Gets the contract's `Transfer` event",
        "gt": "pub fn transfer_filter( &self, ) -> ::ethers::contract::builders::Event< ::std::sync::Arc<M>, M, TransferFilter, > { self.0.event() }",
        "url": 556
    },
    {
        "code_input": "struct Data {\n    id: u32,\n    name: String,\n}\n\nfn construct_rom(data: Vec<Data>) -> Vec<u8> {\n    let mut rom = Vec::new();\n    for item in data {\n        rom.push(item.id as u8);\n        rom.push(item.name.len() as u8);\n        for c in item.name.chars() {\n            rom.push(c as u8);\n        }\n    }\n    rom\n}\n\nfn main() {\n    let data = vec![\n        Data {\n            id: 1,\n            name: String::from(\"Hello\"),\n        },\n        Data {\n            id: 2,\n            name: String::from(\"World\"),",
        "nl_input": "Constructs a ROM from the specified data.",
        "gt": "fn build_from_slice(self, data: &[u8]) -> std::io::Result<Rom> { let backing = sparse_mmap::alloc_shared_memory(data.len())?; let mapping = sparse_mmap::SparseMapping::new(data.len())?; mapping.map_file(0, data.len(), &backing, 0, true)?; mapping.write_at(0, data).unwrap(); Ok(Rom { name: self.name, mapper: self.mapper, len: data.len() as u64, backing, }) }",
        "url": 557
    },
    {
        "code_input": "use std::ascii::AsciiExt;\n\n#[derive(Debug, PartialEq)]\nstruct GuestLogData {\n    // Add fields here\n}\n\nfn verify_guest_log_data(buffer: &[u8]) -> Option<GuestLogData> {\n    let mut data = GuestLogData::deserialize_from_slice(buffer)?;\n\n    if data.is_some() {\n        Some(data.unwrap())\n    } else {\n        None\n    }\n}\n\nfn main() {\n    let buffer = b\"\\x01\\x02\\x03\\x04\"; // This is a placeholder, replace with actual data\n    match verify_guest_log_data(buffer) {\n        Some(data) => println!(\"GuestLogData: {:?}\", data),\n        None => print",
        "nl_input": "Verifies that a buffer of bytes contains a `GuestLogData` and returns it. Note that verification is still experimental and may not catch every error, or be maximally performant. For the previous, unchecked, behavior use `root_as_guest_log_data_unchecked`.",
        "gt": "pub fn root_as_guest_log_data(buf: &[u8]) -> Result<GuestLogData, flatbuffers::InvalidFlatbuffer> { flatbuffers::root::<GuestLogData>(buf) }",
        "url": 558
    },
    {
        "code_input": "pub fn query(node: Option<&mut Node>) -> bool {\n    let mut result = true;\n    while let Some(ref mut node) = node {\n        if node.is_key_in_range(0, 16) {\n            result = false;\n        }\n    }\n    result\n}",
        "nl_input": "Don't break from the loop, to allow for loop unrolling. Should only be used for small Nodes (KEYS <= 16). Ideally, we could express this with feature(generic_const_exprs)",
        "gt": "fn linear_search_child(&self, byte: u8) -> Option<usize> { let mut idx = None; for i in 0..KEYS { if self.keys[i] == Some(byte) { idx = Some(i); } } idx }",
        "url": 559
    },
    {
        "code_input": "I'm sorry, but your request is incomplete. It seems like you're asking for a Rust code snippet, but you didn't provide any specific query or context. Could you please provide more details or clarify what you're trying to achieve?\n",
        "nl_input": "~^ NOTE required by a bound in `assert_send` ~| NOTE required by this bound in `assert_send` ~| NOTE required by a bound in `assert_send` ~| NOTE required by this bound in `assert_send`",
        "gt": "fn main() { let x: &*mut () = &std::ptr::null_mut(); let y: &mut *mut () = &mut std::ptr::null_mut(); assert_send(#[coroutine] move || { yield; let _x = x; }); assert_send(#[coroutine] move || { yield; let _y = y; }); }",
        "url": 560
    },
    {
        "code_input": "use tesseract::*;\nuse std::error::Error;\nuse std::fs::File;\nuse std::io::Read;\n\nfn main() -> Result<(), Box<dyn Error>> {\n    let mut tesseract = Tesseract::new()?;\n    tesseract.set_language(\"eng\")?;\n\n    let file = File::open(\"path_to_your_image_file\")?;\n    let mut contents = String::new();\n    file.read_to_string(&mut contents)?;\n\n    let result = tesseract.process_string(&contents)?;",
        "nl_input": "Detect text words in an image. Returns an unordered list of the oriented bounding rectangles of each word found.",
        "gt": "pub fn detect_words(&self, input: &OcrInput) -> anyhow::Result<Vec<RotatedRect>> { if let Some(detector) = self.detector.as_ref() { detector.detect_words(input.image.view(), self.debug) } else { Err(anyhow!(\"Detection model not loaded\")) } }",
        "url": 561
    },
    {
        "code_input": "I'm sorry, but I can't assist with that.\n",
        "nl_input": "Issue #118164: recovery path leaving unemitted error behind",
        "gt": "fn bar() -> String { #[cfg(feature = )] [1, 2, 3].iter().map().collect::<String>() #[attr] }",
        "url": 562
    },
    {
        "code_input": "pub fn get_last_ip_layer(packet: &[u8]) -> Option<&[u8]> {\n    let ip_header_length = 20; // Assuming the IP header length is 20 bytes\n    let ip_header_end = packet.len() - ip_header_length;\n    packet[ip_header_end - 8..ip_header_end].into_iter().last()\n}",
        "nl_input": "XXX-FIXME(vvv): Some packets (e.g. GRE) may have several \"ip\" layers. We should take the last one, not the first one.",
        "gt": "pub(crate) fn new(pkt: &Packet) -> Result<Self> { let ttl = if let Some(ip) = pkt.find_proto(\"ip\") { ip.first(\"ip.ttl\")?.parse::<u8>()? } else if let Some(ipv6) = pkt.find_proto(\"ipv6\") { ipv6.first(\"ipv6.hlim\")?.parse::<u8>()? } else { panic!(\"BUG\"); }; Ok(Self(ttl)) }",
        "url": 563
    },
    {
        "code_input": "I'm sorry, but your question is a bit unclear. Could you please provide more context or clarify what you're asking for? Are you asking for a code snippet for a specific function or method in Rust? If so, please provide more details.\n",
        "nl_input": "Emit an intermediate note on the given `Diag` if the involved regions are suggestable.",
        "gt": "pub(crate) fn intermediate_suggestion( &mut self, mbcx: &MirBorrowckCtxt<'_, '_, '_>, errci: &ErrorConstraintInfo<'_>, diag: &mut Diag<'_>, ) { let fr_name = self.region_vid_to_name(mbcx, errci.fr); let outlived_fr_name = self.region_vid_to_name(mbcx, errci.outlived_fr); if let (Some(fr_name), Some(outlived_fr_name)) = (fr_name, outlived_fr_name) && !matches!(outlived_fr_name.source, RegionNameSource::Static) { diag.help(format!( \"consider adding the following bound: `{fr_name}: {outlived_fr_name}`\", )); } }",
        "url": 564
    },
    {
        "code_input": "use std::env;\n\nfn main() {\n    // Get the environment variable named 'key'\n    let key_value = env::var(\"key\");\n\n    // Check if the environment variable was found\n    if key_value.is_err() {\n        println!(\"Environment variable 'key' not found\");\n    } else {\n        // If the environment variable was found, remove it\n        env::set(\"key\", \"\");\n        println!(\"Environment variable 'key' removed\");\n    }\n}",
        "nl_input": "Removes the environment variable `key`.",
        "gt": "pub fn env_remove<K: AsRef<OsStr>>(&mut self, key: K) -> &mut Self { self.env.insert(key.as_ref().to_owned(), None); self }",
        "url": 565
    },
    {
        "code_input": "use std::collections::HashMap;\n\nstruct Solution;\n\nimpl Solution {\n    pub fn count_elements(arr: &[i32]) -> i32 {\n        let mut count_map = HashMap::new();\n        for &i in arr {\n            *count_map.entry(i).or_insert(0) += 1;\n        }\n        count_map.len()\n    }\n}\n\nfn main() {\n    let arr = &[1, 2, 2, 1, 1, 3];\n    println!(\"{}\", Solution::count_elements(arr));\n}",
        "nl_input": "We can't see use the `T::Assoc::This: Copy` bound to prove `T::Assoc: Copy`",
        "gt": "fn foo<T: Trait>(x: T::Assoc) -> (T::Assoc, T::Assoc) where T::Assoc: Id<This = T::Assoc>, { (x, x) }",
        "url": 566
    },
    {
        "code_input": "use std::net::TcpStream;\nuse std::io::Write;\n\npub enum MessageType {\n    TL_CONNECT_REQUEST,\n    // other message types...\n}\n\npub struct HvSocket {\n    stream: TcpStream,\n}\n\nimpl HvSocket {\n    pub fn new(stream: TcpStream) -> Self {\n        Self { stream }\n    }\n\n    pub fn connect_request(&self) {\n        let message = MessageType::TL_CONNECT_REQUEST;\n        let message_bytes = message.to_string().as_bytes();\n\n        match self.stream.write(message_bytes) {\n            Ok(_) => println!(\"Connect request sent successfully.\"),\n            Err(e) => println!(\"Failed to send connect request: {}\", e),\n        }\n    }\n}",
        "nl_input": "Handles MessageType::TL_CONNECT_REQUEST, which requests for an hvsocket connection.",
        "gt": "fn handle_tl_connect_request(&mut self, request: protocol::TlConnectRequest2) { self.notifier.notify_hvsock(&request.into()); }",
        "url": 567
    },
    {
        "code_input": "use std::collections::HashMap;\nuse std::collections::VecDeque;\n\ntype Task = u32;\ntype Edge = (Task, Task);\n\nfn topological_sort(edges: &Vec<Edge>) -> Vec<Task> {\n    let mut graph = HashMap::new();\n    let mut indegree = HashMap::new();\n    let mut result = VecDeque::new();\n\n    for &(u, v) in edges {\n        graph.entry(u).or_insert_with(VecDeque::new);\n        graph[u].push(v);\n        *indegree.entry(v).or_insert(0) += 1;\n    }\n\n    for task in 0..graph.len() {\n        if indegree.get(&task).unwrap_or(&0) == 0 {\n            result.push_back(",
        "nl_input": "Returns the topological order of the tasks in the graph. The topological order is the order in which the tasks should be executed to ensure that all dependencies of a task are executed before the task itself.",
        "gt": "pub fn topological_order(&self) -> Vec<TaskId> { let mut visited = HashSet::new(); let mut order = Vec::new(); for i in 0..self.nodes.len() { visit(TaskId(i), &self.nodes, &mut visited, &mut order); } return order; fn visit( id: TaskId, nodes: &[TaskNode<'_>], visited: &mut HashSet<TaskId>, order: &mut Vec<TaskId>, ) { if !visited.insert(id) { return; } for dependency in nodes[id.0].dependencies.iter() { visit(*dependency, nodes, visited, order); } order.push(id); } }",
        "url": 568
    },
    {
        "code_input": "fn iterate_matrix(matrix: &Vec<Vec<bool>>) {\n    for row in matrix {\n        for &item in row.iter() {\n            if item {\n                // Perform your operation here\n                println!(\"Item is true\");\n            }\n        }\n    }\n}\n\nfn main() {\n    let matrix = vec![\n        vec![true, false, true],\n        vec![false, true, true],\n        vec![true, true, true],\n    ];\n\n    iterate_matrix(&matrix);\n}",
        "nl_input": "Iterates through all the columns set to true in a given row of the matrix.",
        "gt": "pub fn iter(&self, row: R) -> impl Iterator<Item = C> + '_ { self.row(row).into_iter().flat_map(|r| r.iter()) }",
        "url": 569
    },
    {
        "code_input": "#[derive(Debug)]\nstruct AbortError {\n    code: i32,\n    message: String,\n}\n\nimpl std::fmt::Display for AbortError {\n    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n        write!(f, \"Aborting program with error code {} and message: {}\", self.code, self.message)\n    }\n}\n\nimpl std::error::Error for AbortError {}\n\nunsafe fn abort_program(code: i32, message: &str) -> ! {\n    // Create a new AbortError instance\n    let err = AbortError {\n        code,\n        message: message.to_string(),\n    };\n\n    // Abort the program with the error\n    abort!(err);\n}",
        "nl_input": "Aborts the program with a code and a message. # Safety This function is unsafe because it dereferences a raw pointer.",
        "gt": "pub unsafe fn abort_with_code_and_message(code: i32, message_ptr: *const c_char) -> ! { let peb_ptr = P_PEB.unwrap(); copy_nonoverlapping( message_ptr, (*peb_ptr).guestPanicContextData.guestPanicContextDataBuffer as *mut c_char, CStr::from_ptr(message_ptr).count_bytes() + 1, ); outb(OutBAction::Abort as u16, code as u8); unreachable!() }",
        "url": 570
    },
    {
        "code_input": "use std::collections::HashMap;\nuse std::fs::Metadata;\nuse std::path::Path;\n\nstruct FileRegistry {\n    files: HashMap<Path, Metadata>,\n    owners: HashMap<Path, String>,\n}\n\nimpl FileRegistry {\n    fn new() -> Self {\n        Self {\n            files: HashMap::new(),\n            owners: HashMap::new(),\n        }\n    }\n\n    fn insert_file(&mut self, path: Path, metadata: Metadata) {\n        self.files.insert(path, metadata);\n    }\n\n    fn get_file_owner(&mut self, path: &Path) -> Option<&String> {\n        self.owners.get(path)\n    }\n\n    fn set_file_owner(&mut self, path: &Path, owner: String) {\n        self.owners.insert(path, owner);\n    }\n}",
        "nl_input": "If only the paths are available, create a FileRegistry with empty owners This is *unsafe* if you do not later insert the appropriate owners before get_file_owner is called",
        "gt": "pub fn new_from_paths(file_paths: Vec<&'a PathBuf>) -> Self { Self { version_count: file_paths.iter().map(|_| 0).collect(), owners: file_paths.iter().map(|_| Vec::new()).collect(), file_paths, } }",
        "url": 571
    },
    {
        "code_input": "fn main() {\n    let num1 = 5;\n    let num2 = 10;\n    let sum = num1 + num2;\n    println!(\"The sum of {} and {} is {}\", num1, num2, sum);\n}",
        "nl_input": "Multiple arguments should each get their own line.",
        "gt": "fn do_bar( a: u8, mut b: u8, c: &u8, d: &mut u8, closure: &Fn(i32) -> i32, ) -> i32 { let bar = |x: i32, y: i32| -> i32 { x + y }; bar(a, b) }",
        "url": 572
    },
    {
        "code_input": "use std::sync::{Arc, Rc};\n\nfn main() {\n    let shared_data = Arc::new(Rc::new(5));\n\n    let reader1 = Arc::clone(&shared_data);\n    let reader2 = Arc::clone(&shared_data);\n\n    println!(\"{}\", reader1.read());\n    println!(\"{}\", reader2.read());\n}\n\nstruct MyReader<'a> {\n    data: &'a i32,\n}\n\nimpl<'a> MyReader<'a> {\n    fn new(data: &'a i32) -> MyReader<'a> {\n        MyReader { data }\n    }\n\n    fn read(&self) -> i32 {\n        *self.data\n    }\n}",
        "nl_input": "Here we need something outlived by `'a` *and* outlived by `'b`, but we can only name `'a` and `'b` (and neither suits). So we get an error. Somewhat unfortunate, though, since the caller would have to consider the loans for both `'a` and `'b` alive.",
        "gt": "fn upper_bounds<'a, 'b>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'a, 'b> { if condition() { a } else { b } }",
        "url": 573
    },
    {
        "code_input": "fn main() {\n    let x: Box<dyn Any> = Box::new(5);\n    println!(\"{}\", x);\n}",
        "nl_input": "~^ ERROR unconstrained opaque type",
        "gt": "fn execute_transaction_fut<'f, F, O>( //~^ ERROR: item does not constrain f: F, ) -> impl FnOnce(&mut dyn Transaction) -> TransactionFuture<'_, O> where F: FnOnce(&mut dyn Transaction) -> TransactionFuture<'_, O> + 'f { f }",
        "url": 574
    },
    {
        "code_input": "use std::error::Error;\nuse std::fs::File;\nuse std::io::Read;\nuse xlsx::{open_workbook, Workbook};\n\nfn main() -> Result<(), Box<dyn Error>> {\n    let file = File::open(\"path_to_your_file\")?;\n    let mut buffer = String::new();\n    file.read_to_string(&mut buffer)?;\n\n    let workbook: Workbook = open_workbook(&buffer)?;\n\n    // Now you can work with the workbook\n\n    Ok(())\n}",
        "nl_input": "Loads a [Workbook] from the bytes of an xlsx file. This is useful, for instance, when bytes are transferred over the network",
        "gt": "pub fn load_from_xlsx_bytes( bytes: &[u8], name: &str, locale: &str, tz: &str, ) -> Result<Workbook, XlsxError> { let cursor = Cursor::new(bytes); let reader = BufReader::new(cursor); load_xlsx_from_reader(name.to_string(), reader, locale, tz) }",
        "url": 575
    },
    {
        "code_input": "extern crate poseidon2;\n\nuse poseidon2::{Poseidon2, Poseidon2_128};\n\nfn main() {\n    let mut hasher = Poseidon2_128::new();\n    let array: Vec<u8> = vec![0x01, 0x02, 0x03, 0x04, 0x05];\n    let compressed = hasher.compress(&array);\n    println!(\"{:x}\", compressed);\n}",
        "nl_input": "Applies the Poseidon2 compression to the given array. Reference: [p3_symmetric::TruncatedPermutation]",
        "gt": "pub fn poseidon2_compress_x( &mut self, result: &mut Array<C, Felt<C::F>>, left: &Array<C, Felt<C::F>>, right: &Array<C, Felt<C::F>>, ) { self.push_op(DslIr::Poseidon2CompressBabyBear(Box::new(( result.clone(), left.clone(), right.clone(), )))); }",
        "url": 576
    },
    {
        "code_input": "fn get_lifetime<'a, 'b>(vec: &'a Vec<&'b Box<dyn Trait>>) -> Vec<&'b Box<dyn Trait>> {\n    vec.iter().map(|x| *x).collect()\n}",
        "nl_input": "same as above but there is a late-bound lifetime named `'b`.",
        "gt": "async fn bar2<'b>(_dummy: &'a u8, arg: A, lt: Inv<'_>) { check_bound(arg, lt); }",
        "url": 577
    },
    {
        "code_input": "use std::fs::File;\nuse std::io::Read;\n\n#[derive(Debug, PartialEq)]\nstruct MyStruct {\n    a: i32,\n    b: f64,\n}\n\nfn main() {\n    let file_path = \"path_to_your_file.bin\";\n    let mut file = File::open(file_path).expect(\"Failed to open file\");\n    let mut buffer = vec![0u8; 100];\n    let _ = file.read(&mut buffer).expect(\"Failed to read from file\");\n\n    let struct_data: MyStruct =\n        ::std::mem::from_slice(&buffer[..MyStruct::estimated_size()]).expect(\"Failed to convert slice to struct\");\n\n    println!(\"{:?}\", struct_data);\n}",
        "nl_input": "Some helpers for reading from binary files.",
        "gt": "pub fn read_usize(file: &mut File) -> usize { let mut buf = [0u8; 4]; file.read_exact(&mut buf).unwrap(); i32::from_le_bytes(buf) as usize }",
        "url": 578
    },
    {
        "code_input": "use std::panic;\nuse std::panic::PanicInfo;\n\nfn main() {\n    let _ = std::panic::set_hook(Box::new(Box::new(|info: &PanicInfo| {\n        println!(\"Panic occurred: {}\", info);\n        // Print the stack trace\n        panic::set_current_panic_info(info);\n        // This will cause the program to terminate\n        std::process::exit(1);\n    })));\n\n    let zombie_value: *mut u8 = &mut 0;\n    *zombie_value = 42;\n}",
        "nl_input": "If an entry point references a zombie'd value, then the entry point would normally get removed. That's an absolutely horrible experience to debug, though, so instead, create a nice error message containing the stack trace of how the entry point got to the zombie value.",
        "gt": "fn report_all(mut self) -> super::Result<()> { let mut result = Ok(()); for root_id in super::dce::collect_roots(self.module) { if let Some(zombie) = self.zombies.get_zombie_by_id(root_id) { for (_, err) in self.build_errors_keyed_by_leaf_id(zombie) { result = Err(err.emit()); } } } result }",
        "url": 579
    },
    {
        "code_input": "use web3::types::Address;\nuse web3::types::HexValue;\nuse web3::types::Log;\nuse web3::types::Transaction;\nuse web3::types::BlockNumber;\n\npub fn get_token_withdrawal_events(web3: &web3::Web3, contract_address: &Address) -> Vec<Event> {\n    let contract_address = HexValue::new(contract_address.to_string());\n    let event_filter = web3.eth().logs({\n        \"address\": contract_address,\n        \"topic\": Some(\"0x7ff36ab5b14047068d87663eb0145189742715202c99",
        "nl_input": "Gets the contract's `TokenWithdrawal` event",
        "gt": "pub fn token_withdrawal_filter( &self, ) -> ::ethers::contract::builders::Event< ::std::sync::Arc<M>, M, TokenWithdrawalFilter, > { self.0.event() }",
        "url": 580
    },
    {
        "code_input": "use std::ffi::CString;\nuse std::ffi::CStr;\nuse std::ffi::CStrPointer;\nuse std::ffi::CStrSlice;\nuse std::ffi::CStrSliceMut;\n\n#[derive(Debug)]\npub struct FunctionCall {\n    name: String,\n    args: Vec<String>,\n}\n\n#[derive(Debug)]\npub struct FfiFunctionCall {\n    name: CString,\n    args: Vec<CString>,\n}\n\nimpl FfiFunctionCall {\n    pub fn new(function_call: &FunctionCall) -> Self {\n        let name = CString::new(function_call.name.clone());\n        let args = function_call.args.into_",
        "nl_input": "Create a new `FfiFunctionCall` by consuming a FunctionCall.",
        "gt": "pub fn from_function_call(value: FunctionCall) -> Result<Self> { let leaked_function_name = CString::new(value.function_name.as_str()) .expect(\"Failed to convert function name to CString\") .into_raw(); let (parameters, parameter_len) = match value.parameters { Some(p) => { let parameters: Vec<FfiParameter> = p .into_iter() .map(|param| FfiParameter::from_parameter_value(param).unwrap()) .collect(); let boxed = parameters.into_boxed_slice(); let parameters_len = boxed.len(); let leaked_param_vec = Box::into_raw(boxed); (leaked_param_vec as *const FfiParameter, parameters_len) } None => (core::ptr::null(), 0), }; Ok(Self { function_name: leaked_function_name, parameters, parameters_len: parameter_len, return_type: value.expected_return_type, }) }",
        "url": 581
    },
    {
        "code_input": "fn find_last_occurrence(s: &str, b: &[u8]) -> Option<usize> {\n    let s_len = s.len();\n    let b_len = b.len();\n\n    if b_len > s_len {\n        return None;\n    }\n\n    let mut last_occurrence: Option<usize> = None;\n\n    for i in (0..s_len).rev() {\n        if s[i..i+b_len].as_bytes().eq(b) {\n            last_occurrence = Some(i);\n        }\n    }\n\n    last_occurrence\n}",
        "nl_input": "Finds the last occurrence of a byte string in the given string. If the byte string was found the start position of the byte string is returned, otherwise [`None`].",
        "gt": "pub fn rfind(&self, bytes: &[u8]) -> Option<usize> { if self.len() < bytes.len() { return None; } for i in (0..self.len() - bytes.len() + 1).rev() { let mut has_found = true; for (n, byte) in bytes.iter().enumerate() { if unsafe { *self.data[i + n].as_ptr() } != *byte { has_found = false; break; } } if has_found { return Some(i); } } None }",
        "url": 582
    },
    {
        "code_input": "pub fn check(t1: &Option<TokenTree>, t2: &Option<TokenTree>) -> bool {\n    match (t1, t2) {\n        (Some(ref t1), Some(ref t2)) => *t1 == *t2 && check(&t1.children, &t2.children),\n        (Some(_), _) | (_, Some(_)) => false,\n        (None, None) => true,\n    }\n}",
        "nl_input": "The following three functions are only meant to check partial structural equivalence of `TokenTree`s, see the last assertion in `check()`.",
        "gt": "fn check_leaf_eq(a: &tt::Leaf, b: &tt::Leaf) -> bool { match (a, b) { (tt::Leaf::Literal(a), tt::Leaf::Literal(b)) => a.symbol == b.symbol, (tt::Leaf::Punct(a), tt::Leaf::Punct(b)) => a.char == b.char, (tt::Leaf::Ident(a), tt::Leaf::Ident(b)) => a.sym == b.sym, _ => false, } }",
        "url": 583
    },
    {
        "code_input": "pub struct Node {\n    pub dests: Vec<usize>,\n}\n\npub struct Graph {\n    pub nodes: Vec<Node>,\n}\n\nimpl Graph {\n    pub fn remove_node(&mut self, node_index: usize) {\n        self.nodes.remove(node_index);\n    }\n}",
        "nl_input": "Remove node if it only has n dests",
        "gt": "pub fn safe_remove_node(&mut self, node: NodeIndex, dests: usize) { if self .graph .edges_directed(node, Direction::Outgoing) .filter(|e| !e.weight().is_schedule()) .count() <= dests { self.graph.remove_node(node); } }",
        "url": 584
    },
    {
        "code_input": "pub fn command_not_found_handler(command: &str) -> Result<(), &'static str> {\n    eprintln!(\"Command not found: {}\", command);\n    Err(\"Command not found\")\n}",
        "nl_input": "Called when a command was not found.",
        "gt": "fn command_not_found<'p>(project: &'p Project, explicit_environment: Option<Environment<'p>>) { let available_tasks: HashSet<TaskName> = if let Some(explicit_environment) = explicit_environment { explicit_environment.get_filtered_tasks() } else { project .environments() .into_iter() .filter(|env| verify_current_platform_has_required_virtual_packages(env).is_ok()) .flat_map(|env| env.get_filtered_tasks()) .collect() }; if !available_tasks.is_empty() { eprintln!( \"\\nAvailable tasks:\\n{}\", available_tasks .into_iter() .sorted() .format_with(\"\\n\", |name, f| { f(&format_args!(\"\\t{}\", name.fancy_display().bold())) }) ); } }",
        "url": 585
    },
    {
        "code_input": "struct Metric {\n    value: f32,\n}\n\nfn get_metric_type() -> &'static str {\n    std::mem::size_of::<f32>() as u8 as &'static str\n}\n\nfn main() {\n    let metric = Metric { value: 0.0 };\n    println!(\"The size of the float is: {}\", get_metric_type());\n}",
        "nl_input": "Gets the type of the metric for its field in metric struct.",
        "gt": "fn metric_field(foundations: &Path, fn_: &ItemFn) -> proc_macro2::TokenStream { let ItemFn { attrs: FnAttrs { cfg, ctor, .. }, args, ty: metric_ty, ident: metric_name, .. } = fn_; let field_ty = if args.is_empty() { metric_ty.to_token_stream() } else if let Some(ExprStruct { path: ctor_path, .. }) = ctor { quote! { #foundations::reexports_for_macros::prometools::serde::Family< #metric_name, #metric_ty, #ctor_path, > } } else { quote! { #foundations::reexports_for_macros::prometools::serde::Family< #metric_name, #metric_ty, > } }; quote! { #(#cfg)* #metric_name: #field_ty } }",
        "url": 586
    },
    {
        "code_input": "use reqwest::Error;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Serialize, Deserialize, Debug)]\nstruct SearchResult {\n    title: String,\n    link: String,\n    snippet: String,\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), Error> {\n    let client = reqwest::Client::new();\n    let query = \"rust\";\n    let url = format!(\"https://www.googleapis.com/customsearch/v6?key=YOUR_API_KEY&cx=YOUR_SEARCH_ENGINE_ID&q={}\", query);\n\n    let resp = client.get(url).await?;\n    let results: Vec<SearchResult> = resp.json().await?;\n\n    for result in results {",
        "nl_input": "Perform a search and summarize the corresponding search results",
        "gt": "pub async fn summarize_search<T: Serialize>( &self, search_input: &T, ) -> Result<String, LlamaCoreError> { let search_output = self.perform_search(&search_input).await?; let summarization_prompts = self.summarization_prompts.clone().unwrap_or(( \"The following are search results I found on the internet:\\n\\n\".to_string(), \"\\n\\nTo sum up them up: \".to_string(), )); let summarize_ctx_size = self .summarize_ctx_size .unwrap_or((self.size_limit_per_result * self.max_search_results as u16) as usize); summarize( search_output, summarize_ctx_size, summarization_prompts.0, summarization_prompts.1, ) }",
        "url": 587
    },
    {
        "code_input": "#[cfg(test)]\nmod test {\n    #[test]\n    fn internal_function() {\n        // This function is declared internal in cfail1, and it is not inlined by ThinLTO.\n        // It is not inlined into foo() when it is declared `internal` in cfail1.\n        // This function is not inlined by ThinLTO.\n        // It is not inlined into foo() when it is declared `internal` in cfail1.\n        // This function is not inlined by ThinLTO.\n        // It is not inlined into foo() when it is declared `internal` in cfail1.\n        // This function is not inlined by ThinLTO.\n        // It is not inlined into foo() when it is declared `internal` in cfail1.\n        // This function is not inlined by ThinLTO.\n        // It is not inlined into foo",
        "nl_input": "This function needs to be big so that it does not get inlined by ThinLTO but *does* get inlined into foo() when it is declared `internal` in cfail1 (alone).",
        "gt": "pub fn bar(){ println!(\"quux1\"); println!(\"quux2\"); println!(\"quux3\"); println!(\"quux4\"); println!(\"quux5\"); println!(\"quux6\"); println!(\"quux7\"); println!(\"quux8\"); println!(\"quux9\"); }",
        "url": 588
    },
    {
        "code_input": "pub struct Node {\n    pub tag: String,\n    pub namespace: String,\n    pub attributes: Vec<(String, String)>,\n}\n\npub fn compare_nodes(node1: &Node, node2: &Node) -> bool {\n    node1.tag == node2.tag &&\n    node1.namespace == node2.namespace &&\n    node1.attributes == node2.attributes\n}",
        "nl_input": "This will only compare against the tag, namespace and data same except element data. for element data compare against the tag, namespace and attributes without order. Both nodes could still have other parents and children.",
        "gt": "fn matches_tag_and_attrs_without_order(&self, other_data: &ElementData<C>) -> bool { if self.name != other_data.name || self.namespace != other_data.namespace { return false; } if self.name != other_data.name { return false; } if self.namespace != other_data.namespace { return false; } self.attributes.eq(&other_data.attributes) }",
        "url": 589
    },
    {
        "code_input": "use std::io::Read;\n\nfn read_bytes(ptr: &mut [u8], len: usize) -> i32 {\n    let mut dest = [0u8; len];\n    match ptr.as_mut().read(&mut dest) {\n        Ok(_) => len as i32,\n        Err(_) => -1,\n    }\n}",
        "nl_input": "Reads as much as possible into the given buffer `ptr`. `len` indicates how many bytes we should try to read. `dest` is where the return value should be stored: number of bytes read, or `-1` in case of error.",
        "gt": "fn read<'tcx>( &self, _self_ref: &FileDescriptionRef, _communicate_allowed: bool, _ptr: Pointer, _len: usize, _dest: &MPlaceTy<'tcx>, _ecx: &mut MiriInterpCx<'tcx>, ) -> InterpResult<'tcx> { throw_unsup_format!(\"cannot read from {}\", self.name()); }",
        "url": 590
    },
    {
        "code_input": "use std::collections::HashMap;\n\nfn macro_query(input: &str) -> Vec<String> {\n    let mut result = Vec::new();\n    let mut tokens = Vec::new();\n    let mut current_token = String::new();\n    let mut in_string = false;\n    let mut in_comment = false;\n    let mut in_quote = false;\n\n    for c in input.chars() {\n        if c == '\"' || c == '\\'' {\n            if in_string {\n                in_string = false;\n                if current_token.len() > 0 {\n                    tokens.push(current_token.clone());\n                    current_token.clear();\n                }\n            } else {\n                in_string = true;\n                current_token.push(c);\n            }\n        } else if c == '/' && !in_string {\n            if input.chars().nth(input.len() - 1) == Some('*') {\n                in_comment = true;\n            } else {\n                result.push(",
        "nl_input": "Tokens to be returned when the macro cannot proceed.",
        "gt": "fn failed(crate_name: &Ident) -> proc_macro::TokenStream { finish(quote! { pub mod #crate_name {} }, quote! { \"\" }) }",
        "url": 591
    },
    {
        "code_input": "use crate::{sql::proof::CountBuilder, types::UInt64};\n\npub fn get_challenges(cnt: UInt64) -> Vec<CountBuilder> {\n    let mut challenges = Vec::new();\n\n    for _ in 0..cnt {\n        challenges.push(CountBuilder::new().build());\n    }\n\n    challenges\n}",
        "nl_input": "Request `cnt` more post result challenges. Specifically, these are the challenges that the verifier sends to the prover after the prover sends the result, but before the prover send commitments to the intermediate witness columns. Note: this must be matched with the same count in the [`CountBuilder`](crate::sql::proof::CountBuilder).",
        "gt": "pub fn request_post_result_challenges(&mut self, cnt: usize) { self.num_post_result_challenges += cnt; }",
        "url": 592
    },
    {
        "code_input": "use std::env;\n\nfn main() {\n    match env::underlying_os() {\n        Some(os) => println!(\"Underlying OS: {:?}\", os),\n        None => println!(\"No underlying OS\"),\n    }\n}",
        "nl_input": "Gets the underlying OS event, if there is one.",
        "gt": "pub fn event(&self) -> Option<&Event> { match &self.0 { Inner::Event(e) => Some(e), Inner::SlimEvent(_) => None, } }",
        "url": 593
    },
    {
        "code_input": "use web3::{Http, types::Address, Client};\nuse std::error::Error;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn Error>> {\n    let http = Http::new().chain_err()?;\n    let client = Client::new_with_http(http, \"https://mainnet.infura.io/v3/YOUR_INFURA_KEY\");\n\n    let contract_address = Address::from_str(\"0xb1dd61b6\")?;\n\n    let result = client.call(\n        \"function_name\",\n        (),\n        contract_address,\n    )\n    .await?;\n\n    print",
        "nl_input": "Calls the contract's `poolType` (0xb1dd61b6) function",
        "gt": "pub fn pool_type(&self) -> ::ethers::contract::builders::ContractCall<M, u8> { self.0 .method_hash([177, 221, 97, 182], ()) .expect(\"method not found (this should never happen)\") }",
        "url": 594
    },
    {
        "code_input": "struct TreeNode {\n    key: i32,\n    left: Option<Box<TreeNode>>,\n    right: Option<Box<TreeNode>>,\n}",
        "nl_input": "Splits a unique reference into a pair of leaf edges delimiting a specified range. The result are non-unique references allowing (some) mutation, which must be used carefully. The result is meaningful only if the tree is ordered by key, like the tree in a `BTreeMap` is. # Safety Do not use the duplicate handles to visit the same KV twice.",
        "gt": "pub fn range_search<Q, R>(self, range: R) -> LeafRange<marker::ValMut<'a>, K, V> where Q: ?Sized + Ord, K: Borrow<Q>, R: RangeBounds<Q>, { unsafe { self.find_leaf_edges_spanning_range(range) } }",
        "url": 595
    },
    {
        "code_input": "I'm sorry, but your question seems to be incomplete. Could you please provide more details or context about the query you're referring to?\n",
        "nl_input": "object safety was renamed to dyn-compatibility but still remains here in chalk. This will be removed since we are going to migrate to next-gen trait solver.",
        "gt": "fn is_object_safe(&self, trait_id: chalk_ir::TraitId<Interner>) -> bool { let trait_ = from_chalk_trait_id(trait_id); crate::dyn_compatibility::dyn_compatibility(self.db, trait_).is_none() }",
        "url": 596
    },
    {
        "code_input": "pub struct Transition {\n    // ...\n}\n\nimpl Transition {\n    pub fn readable_explanation(&self) -> String {\n        format!(\"This transition corresponds to {}\", self.summary())\n    }\n}",
        "nl_input": "Readable explanation of the consequences of an event. Fits in the sentence \"This transition corresponds to {trans.summary()}\".",
        "gt": "pub fn summary(&self) -> &'static str { assert!(self.is_possible()); assert!(!self.is_noop()); match (self.from, self.to) { (_, Active) => \"the first write to a 2-phase borrowed mutable reference\", (_, Frozen) => \"a loss of write permissions\", (ReservedFrz { conflicted: false }, ReservedFrz { conflicted: true }) => \"a temporary loss of write permissions until function exit\", (Frozen, Disabled) => \"a loss of read permissions\", (_, Disabled) => \"a loss of read and write permissions\", (old, new) => unreachable!(\"Transition from {old:?} to {new:?} should never be possible\"), } }",
        "url": 597
    },
    {
        "code_input": "#[path = \"path_to_your_file\"]\n#[path = \"another_path_to_your_file\"]\nfn main() {\n    // Your code here\n}",
        "nl_input": "N.B., even when there are multiple `#[path = ...]` attributes, we just need to examine the first one, since rustc ignores the second and the subsequent ones as unused attributes.",
        "gt": "fn find_path_value(attrs: &[ast::Attribute]) -> Option<Symbol> { attrs.iter().flat_map(path_value).next() }",
        "url": 598
    },
    {
        "code_input": "use web3::{Client, types::Address, types::HexString};\nuse serde_json::Value;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Create a new client\n    let client = Client::new(\"http://localhost:8545\")?;\n\n    // The address of the contract\n    let contract_address",
        "nl_input": "Calls the contract's `delta` (0x12b495a8) function",
        "gt": "pub fn delta(&self) -> ::ethers::contract::builders::ContractCall<M, u128> { self.0 .method_hash([18, 180, 149, 168], ()) .expect(\"method not found (this should never happen)\") }",
        "url": 599
    },
    {
        "code_input": "fn missing(input: &str) -> String {\n    let reversed: String = input.chars().rev().collect();\n    reversed\n}\n\nfn main() {\n    let input = \"Hello, World!\";\n    let reversed = missing(input);\n    println!(\"{}\", reversed);\n}",
        "nl_input": "Reverses specialization by the `Missing` constructor by pushing a whole new pattern.",
        "gt": "fn push_pattern(&mut self, pat: WitnessPat<Cx>) { for witness in self.0.iter_mut() { witness.push_pattern(pat.clone()) } }",
        "url": 600
    },
    {
        "code_input": "const EPS: f64 = 1.0e-10;",
        "nl_input": "const EPS: f64 = f64::EPSILON;",
        "gt": "fn numbers_are_close(x: f64, y: f64, eps: f64) -> bool { let norm = (x * x + y * y).sqrt(); if norm == 0.0 { return true; } let d = f64::abs(x - y); if d < eps { return true; } d / norm < eps }",
        "url": 601
    },
    {
        "code_input": "I'm sorry, but the code you're asking for is not available in the context of the current state of the Rust programming language. The `EMIT_MIR` instruction is a part of the Rust compiler's internal code, and it's not publicly documented. \n\nThe `match_u8_i8_2_failed.MatchBranchSimplification.diff` is a part of the `match_simplify` function in the `match_simplify` module, which is a part of the `match_simplify_impl` trait in the `match` crate.\n\nIf you're looking to implement this functionality yourself, you would need to understand the Rust compiler's internal workings, which is beyond the scope of a simple code snippet.\n\nIf you need help with a different part of the Rust language, feel free to ask!\n",
        "nl_input": "EMIT_MIR matches_reduce_branches.match_u8_i8_2_failed.MatchBranchSimplification.diff",
        "gt": "fn match_u8_i8_2_failed(i: EnumAu8) -> (i8, i8) { let a: i8; let b: i8; match i { EnumAu8::u0_0x00 => { a = 0; b = 0; () } EnumAu8::u127_0x7f => { a = 127; b = 127; () } EnumAu8::u128_0x80 => { a = -128; b = -128; () } EnumAu8::u255_0xff => { a = -1; b = 1; () } }; (a, b) }",
        "url": 602
    },
    {
        "code_input": "use std::process::{Command, Stdio};\nuse std::io::Error;\n\nfn execute_program(args: Vec<&str>) -> Result<(), Error> {\n    let output = Command::new(\"echo\")\n        .arg(\"Hello, world!\")\n        .stdout(Stdio::piped())\n        .stderr(Stdio::piped())\n        .spawn()?\n        .wait()?;\n\n    if output.status.success() {\n        Ok(())\n    } else {\n        Err(output.stderr.expect(\"Failed to read stderr\"))\n    }\n}",
        "nl_input": "Executes the program without tracing and without emitting events. # Errors This function will return an error if the program execution fails.",
        "gt": "pub fn run_fast(&mut self) -> Result<(), ExecutionError> { self.executor_mode = ExecutorMode::Simple; self.print_report = true; while !self.execute()? {} Ok(()) }",
        "url": 603
    },
    {
        "code_input": "I'm sorry, but the information you provided is not clear. It seems like you're referring to a specific issue with Rust, but the context is not clear. Could you please provide more details or clarify what you're referring to?\n\nIf you're referring to a specific issue with Rust, I'd be happy to help. Please provide more information about the issue you're facing.\n",
        "nl_input": "We used to not lower the extra `b @ ..` into `b @ _` which meant that no type was registered for the binding `b` although it passed through resolve. This resulted in an ICE (#69103).",
        "gt": "fn main() { let [a @ .., b @ ..] = &mut [1, 2]; b; let [.., c @ ..] = [1, 2]; c; let (.., d @ ..) = (1, 2); d; }",
        "url": 604
    },
    {
        "code_input": "use std::env;\nuse std::process;\n\nfn main() {\n    // Parse args.\n    let args: Vec<String> = env::args().collect();\n\n    // Check if the `RUST_LOG` environment variable is set.\n    if let Some(rust_log) = env::var(\"RUST_LOG\") {\n        // Check if the `sqlite3Parser=debug` is in the `RUST_LOG` environment variable.\n        if rust_log.to_lowercase().contains(\"sqlite3Parser=debug\") {\n            println!(\"The `RUST_LOG` environment variable is set to `{}`, and the `sqlite3Parser=debug` is in it.\", rust_log);\n        } else {\n            println!(\"The `RUST_LOG` environment variable is set to `{}`, but the `sqlite3Parser=debug` is not in it.\", rust_log);",
        "nl_input": "Parse args. RUST_LOG=sqlite3Parser=debug",
        "gt": "fn main() { env_logger::init(); let args = env::args(); for arg in args.skip(1) { let mut parser = Parser::new(arg.as_bytes()); loop { match parser.next() { Ok(None) => break, Err(err) => { eprintln!(\"Err: {err} in {arg}\"); break; } Ok(Some(cmd)) => { println!(\"{cmd}\"); } } } } }",
        "url": 605
    },
    {
        "code_input": "pub fn create_new_instance(initiator: &str) -> Result<String, &'static str> {\n    if initiator.is_empty() {\n        return Err(\"Initiator cannot be empty\");\n    }\n\n    let instance_id = format!(\"{}_{}\", initiator, chrono::Local::now().format(\"%Y%m%d%H%M%S\"));\n    Ok(instance_id)\n}",
        "nl_input": "Creates a new instance for the given initiator.",
        "gt": "pub fn new(initiator: T) -> Self { Timer { initiator, target_deadline: Instant::from_nanos(0), state: None, } }",
        "url": 606
    },
    {
        "code_input": "use std::fs::File;\nuse std::io::{self, BufRead};\nuse std::path::Path;\n\nfn read_file(file_path: &Path) -> io::Result<String> {\n    let file = File::open(file_path)?;\n    let reader = io::BufReader::new(file);\n    let mut text = String::new();\n\n    for result in reader.lines() {\n        let line = result?;\n        text.push_str(&line);\n    }\n\n    Ok(text)\n}\n\nfn main() -> io::Result<()> {\n    let file_path = Path::new(\"path_to_your_file\");\n    let text = read_file(&file_path)?;\n    println!(\"{}\", text);\n    Ok(())\n}",
        "nl_input": "Reads a file from the guest into a string.",
        "gt": "pub async fn read_file(&self, path: impl AsRef<Utf8Path<T>>) -> anyhow::Result<String> { let path = self.path(path); let v = self.client.read_file(path.as_str()).await?; String::from_utf8(v).with_context(|| format!(\"file '{}' is not valid utf-8\", path.as_str())) }",
        "url": 607
    },
    {
        "code_input": "fn main() {\n    let a: u8 = 10;\n    let b: u8 = 20;\n    let c: u8 = a + b;\n    println!(\"{}\", c);\n}",
        "nl_input": "Only 'a should be linted here",
        "gt": "fn split_once<'a>(base: &'a str, other: &'_ str) -> (&'a str, Option<&'a str>) { base.split_once(other) .map(|(left, right)| (left, Some(right))) .unwrap_or((base, None)) }",
        "url": 608
    },
    {
        "code_input": "use image::{Image, Rgb};\n\nfn set_grad(img: &mut Image<Rgb<u8>, Array<u8, 3>>, grad: &Image<Rgb<u8>, Array<u8, 3>>) -> Image<Rgb<u8>, Array<u8, 3>> {\n    let (w, h) = img.dimensions();\n    let mut new_img = img.clone();\n    for (x, y) in 0..w {\n        for 0..h {\n            let (r, g, b) = new_img.get(x, y).unwrap();\n            let (r_grad, g_grad, b_grad) = grad.get(x, y).unwrap();\n            new_img.put(x, y, (r as f64 * r_grad",
        "nl_input": "Sets the 'Grad' image operand",
        "gt": "pub fn grad<T>(grad_x: T, grad_y: T) -> SampleParams<NoneTy, NoneTy, SomeTy<(T, T)>, NoneTy> { SampleParams { bias: NoneTy, lod: NoneTy, grad: SomeTy((grad_x, grad_y)), sample_index: NoneTy, } }",
        "url": 609
    },
    {
        "code_input": "fn contains_non_printable(s: &str) -> bool {\n    for c in s.chars() {\n        if c.is_control() {\n            return true;\n        }\n    }\n    false\n}",
        "nl_input": "Are `\\x80`..`\\xff` allowed?",
        "gt": "fn allow_high_bytes(self) -> bool { match self { Char | Str => false, Byte | ByteStr | CStr => true, RawStr | RawByteStr | RawCStr => unreachable!(), } }",
        "url": 610
    },
    {
        "code_input": "use cardano_address_builder::{Address, Network};\n\nfn main() {\n    let network = Network::Testnet;\n    let address = Address::new(&network, \"<Your Payment Key>\");\n    println!(\"{}\", address.to_string());\n}",
        "nl_input": "Create a new Stacks address with a pay-2-script-hash",
        "gt": "pub fn p2sh<'a>( version: AddressVersion, keys: impl IntoIterator<Item = &'a PublicKey>, signature_threshold: usize, ) -> Self { Self::new(version, hash_p2sh(keys, signature_threshold)) }",
        "url": 611
    },
    {
        "code_input": "I'm sorry, but your request is not clear. The text you provided seems to be a query for a specific edition of a software, but it's not clear what the query is asking for. Could you please provide more context or clarify what you're asking for?\n",
        "nl_input": "@ revisions: edition2021 edition2024 @ [edition2021] edition: 2021 @ [edition2024] edition: 2024 @ [edition2024] compile-flags: -Zunstable-options @ [edition2024] check-pass",
        "gt": "fn main() { let cell = std::cell::RefCell::new(0u8); if let Ok(mut byte) = cell.try_borrow_mut() { *byte = 1; } }",
        "url": 612
    },
    {
        "code_input": "pub fn call_on_mir(get_mir_data: fn() -> &'static str) {\n    let mir_data = get_mir_data();\n    println!(\"MIR data: {}\", mir_data);\n}",
        "nl_input": "Call this on things you got out of the MIR (so it is as generic as the current stack frame), to bring it into the proper environment for this interpreter.",
        "gt": "pub(super) fn instantiate_from_current_frame_and_normalize_erasing_regions< T: TypeFoldable<TyCtxt<'tcx>>, >( &self, value: T, ) -> Result<T, ErrorHandled> { self.instantiate_from_frame_and_normalize_erasing_regions(self.frame(), value) }",
        "url": 613
    },
    {
        "code_input": "use std::process::Command;\nuse std::io::Write;\n\n#[tokio::main]\nasync fn main() {\n    let output = Command::new(\"echo\")\n        .arg(\"Hello, world!\")\n        .output()\n        .await\n        .expect(\"failed to execute command\");\n\n    println!(\"{}\", String::from_utf8_lossy(&output.stdout));\n    println!(\"{}\", String::from_utf8_lossy(&output.stderr));\n}",
        "nl_input": "Returns a [`InstallBuilder`]. To execute the command and await the result call `.await` on the return value.",
        "gt": "pub fn install(&self) -> InstallBuilder { InstallBuilder { args: Args { environment: None, project_config: ProjectConfig { manifest_path: Some(self.manifest_path()), }, lock_file_usage: LockFileUsageArgs { frozen: false, locked: false, }, config: Default::default(), all: false, }, } }",
        "url": 614
    },
    {
        "code_input": "use std::fs;\nuse std::path::Path;\n\nfn get_files_with_suffix(dir: &str, suffix: &str) -> Vec<String> {\n    let mut result = Vec::new();\n    let dir = Path::new(dir);\n\n    for entry in fs::read_dir(dir).unwrap() {\n        let entry = entry.unwrap();\n        let entry_path = entry.path();\n\n        if let Some(basename) = entry_path.file_name().and_then(Path::file_name) {\n            let filename = basename.to_str().unwrap();\n\n            if filename.ends_with(suffix) {\n                result.push(entry_path.to_str().unwrap().to_string());\n            }\n        }\n    }\n\n    result\n}",
        "nl_input": "Returns paths in the given `dir` (non-recursively), optionally with the given `suffix`. The `suffix` should contain the leading dot.",
        "gt": "pub fn get_files_from_dir( dir: &Utf8Path, suffix: Option<&str>, ) -> anyhow::Result<Vec<Utf8PathBuf>> { let path = format!(\"{dir}/*{}\", suffix.unwrap_or(\"\")); Ok(glob::glob(&path)? .map(|p| p.map(|p| Utf8PathBuf::from_path_buf(p).unwrap())) .collect::<Result<Vec<_>, _>>()?) }",
        "url": 615
    },
    {
        "code_input": "fn main() {\n    let message = \"Hello, world!\";\n    println!(\"{}\", message);\n}",
        "nl_input": "@ known-bug: #105275 @ compile-flags: -Copt-level=0",
        "gt": "pub fn encode_num<Writer: ExampleWriter>(n: u32, mut writer: Writer) -> Result<(), Writer::Error> { if n > 15 { encode_num(n / 16, &mut writer)?; } Ok(()) }",
        "url": 616
    },
    {
        "code_input": "fn convert_scalar_to_u32(scalar: &str) -> Result<u32, &'static str> {\n    match scalar.parse::<u32>() {\n        Ok(value) => Ok(value),\n        Err(_) => Err(\"The scalar is not a pointer.\"),\n    }\n}\n\nfn main() {\n    let scalar = \"1234\";\n    match convert_scalar_to_u32(scalar) {\n        Ok(value) => println!(\"The machine-pointer-sized unsigned integer is: {}\", value),\n        Err(message) => eprintln!(\"Error: {}\", message),\n    }\n}",
        "nl_input": "Converts the scalar to produce a machine-pointer-sized unsigned integer. Fails if the scalar is a pointer.",
        "gt": "pub fn to_target_usize(self, cx: &impl HasDataLayout) -> InterpResult<'tcx, u64> { let b = self.to_uint(cx.data_layout().pointer_size)?; interp_ok(u64::try_from(b).unwrap()) }",
        "url": 617
    },
    {
        "code_input": "use std::fs::File;\nuse std::io::{self, Write};\n\nfn set_file_attributes(file: &mut File) -> io::Result<()> {\n    // Set the file's write mode to append.\n    file.set_write_hint(true)?;\n\n    // Set the file's position to the end of the file.\n    file.position(io::SeekFrom::End(0))?;\n\n    // Set the file's permissions to read and write.\n    file.set_permissions(io::Permissions::from_mode(0o666))?;\n\n    Ok(())\n}\n\nfn main() -> io::Result<()> {\n    let file = open_file(\"path/to/file\")?;\n\n    set_file_attributes(&mut file)\n}",
        "nl_input": "Sets the attributes of the open file.",
        "gt": "pub fn set_attr(&self, arg: &fuse_setattr_in, request_uid: lx::uid_t) -> lx::Result<()> { let attr = util::fuse_set_attr_to_lxutil(arg, request_uid); self.file.read().set_attr(attr) }",
        "url": 618
    },
    {
        "code_input": "pub struct ZST;\n\nimpl ZST {\n    pub fn transmute(zst: ZST) -> u32 {\n        // This is a placeholder, you would need to implement the actual transmute logic\n        // for the ZST struct.\n        0\n    }\n}",
        "nl_input": "Verify non-generic ZST -> generic ZST transmute",
        "gt": "unsafe fn cast_zst0<T>(from: ()) -> [T; 0] { ::std::mem::transmute::<(), [T; 0]>(from) }",
        "url": 619
    },
    {
        "code_input": "use nist_primitive::Curve25519Scalar;\n\nfn validate_byte_array(array: &[u8]) -> Result<Curve25519Scalar, &'static str> {\n    if array.len() != 32 {\n        return Err(\"The byte array is not of the expected length (32 bytes)\");\n    }\n\n    let scalar = Curve25519Scalar::from_slice(array).map_err(|_| \"The byte array cannot be converted to a valid canonical scalar\")?;\n\n    Ok(scalar)\n}",
        "nl_input": "# Panics This method will panic if the byte array is not of the expected length (32 bytes) or if it cannot be converted to a valid canonical scalar. However, under normal conditions, valid `Curve25519Scalar` values should always satisfy these requirements.",
        "gt": "fn from(value: &Curve25519Scalar) -> Self { let bytes = ark_ff::BigInteger::to_bytes_le(&value.0.into_bigint()); curve25519_dalek::scalar::Scalar::from_canonical_bytes(bytes.try_into().unwrap()).unwrap() }",
        "url": 620
    },
    {
        "code_input": "use std::fs::File;\nuse std::io::Read;\nuse std::path::Path;\nuse serde::{Deserialize};\n\n#[derive(Debug, Deserialize)]\nstruct Module {\n    name: String,\n    file: String,\n}\n\nfn main() -> std::io::Result<()> {\n    let file_path = Path::new(\"path_to_your_file\");\n    let file = File::open(&file_path)?;\n    let mut buffer = String::new();\n    file.read_to_string(&mut buffer)?;\n\n    let module: Module = serde_json::from_str(&buffer)?;\n\n    println!(\"{:?}\", module);\n\n    Ok(())\n}",
        "nl_input": "Returns the `SyntaxNode` of the module. If this is a file module, returns the `SyntaxNode` of the *definition* file, not of the *declaration*.",
        "gt": "pub fn module_definition_node(&self, module: Module) -> InFile<SyntaxNode> { let def_map = module.id.def_map(self.db.upcast()); let definition = def_map[module.id.local_id].origin.definition_source(self.db.upcast()); let definition = definition.map(|it| it.node()); let root_node = find_root(&definition.value); self.cache(root_node, definition.file_id); definition }",
        "url": 621
    },
    {
        "code_input": "I'm sorry, but your question seems to be incomplete. Could you please provide more details or clarify what you're trying to achieve? The error message you're referring to is related to Rust's type system, and it's not clear what the error is about.\n",
        "nl_input": "[old]~^ ERROR: unconstrained opaque type",
        "gt": "fn weird_bound<X>(x: &<X as Trait<'static>>::Out<Foo>) -> X //[old]~^ ERROR: item does not constrain //[next]~^^ ERROR: cannot satisfy `Foo == _` where for<'a> X: Trait<'a>, for<'a> <X as Trait<'a>>::Out<()>: Copy, { let x = *x; todo!(); }",
        "url": 622
    },
    {
        "code_input": "fn main() {\n    let range = 1..10;\n    for i in range {\n        println!(\"{}\", i);\n    }\n}",
        "nl_input": "EMIT_MIR range_iter.inclusive_loop.PreCodegen.after.mir",
        "gt": "pub fn inclusive_loop(start: u32, end: u32, f: impl Fn(u32)) { for x in start..=end { f(x) } }",
        "url": 623
    },
    {
        "code_input": "use std::thread;\nuse std::sync::{Arc, Mutex};\n\nthread_local_storage! {\n    static MY_THREAD_LOCAL_STATIC: Arc<Mutex<i32>> = Arc::new(Mutex::new(0));\n}\n\nfn main() {\n    let value = MY_THREAD_LOCAL_STATIC.lock().unwrap();\n    *value = 1;\n\n    let t1 = thread::spawn(move || {\n        let value = MY_THREAD_LOCAL_STATIC.lock().unwrap();\n        *value = 2;\n    });\n\n    let t2 = thread::spawn(move || {\n        let value = MY_THREAD_LOCAL_STATIC.lock().unwrap();\n        *value = 3;\n    });\n\n    t1.join().unwrap();\n    t2.join().unwrap();",
        "nl_input": "Ensure that leaks through `thread_local` statics *not in the main thread* are detected.",
        "gt": "pub fn main() { #[thread_local] static TLS: Cell<Option<&'static i32>> = Cell::new(None); std::thread::spawn(|| { TLS.set(Some(Box::leak(Box::new(123)))); }) .join() .unwrap(); }",
        "url": 624
    },
    {
        "code_input": "use ethers::prelude::*;\nuse ethers::types::Address;\nuse ethers::types::HexString;\nuse ethers::types::Result;\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub struct AssetId {\n    id: u64,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub struct Recipient {\n    address: Address,\n}\n\nimpl AssetId {\n    pub fn new(id: u64) -> Self {\n        Self { id }\n    }\n\n    pub fn get_asset_recipient(&self, provider: &Provider) -> Result<Recipient> {\n        let contract = provider.contract_factory()?",
        "nl_input": "Calls the contract's `getAssetRecipient` (0x79eac6c2) function",
        "gt": "pub fn get_asset_recipient( &self, ) -> ::ethers::contract::builders::ContractCall< M, ::ethers::core::types::Address, > { self.0 .method_hash([121, 234, 198, 194], ()) .expect(\"method not found (this should never happen)\") }",
        "url": 625
    },
    {
        "code_input": "use ethers::types::Event;\nuse ethers::prelude::*;\n\nfn get_token_deposit_events(provider: &Provider, address: &str) -> Result<Vec<Event>, Box<dyn Error>> {\n    let filter = Event::Filter {\n        from_block: None,\n        to_block: None,\n        address: Some(address),\n        topics: Some(vec![\n            \"0xddf252ad1be2c89b69c2b068fc378a1e893669256c160e61f00a604970f88efa\".parse::<HexString>()?,\n            \"0x000000000000000000000000000",
        "nl_input": "Gets the contract's `TokenDeposit` event",
        "gt": "pub fn token_deposit_filter( &self, ) -> ::ethers::contract::builders::Event< ::std::sync::Arc<M>, M, TokenDepositFilter, > { self.0.event() }",
        "url": 626
    },
    {
        "code_input": "#[derive(Debug, PartialEq)]\nenum BinaryError {\n    InvalidBitCount,\n    InvalidBitValue,\n}\n\n#[derive(Debug, PartialEq)]\nstruct BinaryNumber {\n    value: i16,\n}\n\nimpl BinaryNumber {\n    fn new(value: i16) -> Result<Self, BinaryError> {\n        if value >= 0 && value < 1024 {\n            Ok(Self { value })\n        } else {\n            Err(BinaryError::InvalidBitCount)\n        }\n    }\n\n    fn get_bit(&self, position: usize) -> Result<i16, BinaryError> {\n        if position < 10 {\n            let mask = 1 << position;\n            let bit = self.value & mask;\n            if bit != 0 {\n                Ok(1)",
        "nl_input": "Binary numbers are 10 bits and the most significant bit is the sign",
        "gt": "fn from_binary_to_decimal(value: f64) -> Result<i64, String> { let value = format!(\"{value}\"); let result = match i64::from_str_radix(&value, 2) { Ok(b) => b, Err(_) => { return Err(\"cannot parse into binary\".to_string()); } }; if !(0..=1023).contains(&result) { return Err(\"too large\".to_string()); } else if result > 511 { return Ok(result - 1024); }; Ok(result) }",
        "url": 627
    },
    {
        "code_input": "pub fn get_variant_name(variant_id: u32) -> String {\n    match variant_id {\n        1 => String::from(\"Variant 1\"),\n        2 => String::from(\"Variant 2\"),\n        3 => String::from(\"Variant 3\"),\n        _ => String::from(\"\"),\n    }\n}",
        "nl_input": "Returns the variant's name or \"\" if unknown.",
        "gt": "pub fn variant_name(self) -> Option<&'static str> { match self { Self::none => Some(\"none\"), Self::guest => Some(\"guest\"), Self::host => Some(\"host\"), _ => None, } }",
        "url": 628
    },
    {
        "code_input": "use f64::consts::EPSILON;\n\nfn are_close(a: f64, b: f64) -> bool {\n    (a - b).abs() < EPSILON\n}",
        "nl_input": "Assert that two float values are close together.",
        "gt": "pub fn assert_approx_equal(left: f64, right: f64) { let diff = (left - right).abs(); let add = left.abs() + right.abs(); if diff > 0.0005 * add { panic!(\"assertion failed: `(left ~= right) left: {left} right: {right}\"); } }",
        "url": 629
    },
    {
        "code_input": "use web3::{Client, types::Address, types::HexString};\nuse serde_json::Value;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Create a new client\n    let client = Client::new(\"http://localhost:8545\")?;\n\n    // The address of the contract\n    let contract_address = Address::from",
        "nl_input": "Calls the contract's `withdraw` (0x3ccfd60b) function",
        "gt": "pub fn withdraw(&self) -> ::ethers::contract::builders::ContractCall<M, ()> { self.0 .method_hash([60, 207, 214, 11], ()) .expect(\"method not found (this should never happen)\") }",
        "url": 630
    },
    {
        "code_input": "I'm sorry, but the `pgml.embed()` function is not a built-in function in Rust. It seems like you might be referring to a library or a function that is specific to the `pgml` library, which is not available in Rust.\n\nIf you're referring to a function or method in a library that is specific to the `pgml` library, you would need to find that library and use it in your Rust code.\n\nIf you're referring to a different function or method, please provide more context or the name of the function or method you're referring to.\n\nIf you're referring to a different library or function, please provide more information.\n\nIf you're referring to a function or method in a different library, I'd need more information about that library to provide a more accurate answer.\n",
        "nl_input": "Run the built-in `pgml.embed()` function. # Arguments * `model` - The model to use. * `text` - The text to embed.",
        "gt": "pub async fn embed(&self, model: &str, text: &str) -> anyhow::Result<Json> { let pool = get_or_initialize_pool(&self.database_url).await?; let query = sqlx::query(\"SELECT embed FROM pgml.embed($1, $2)\"); let result = query.bind(model).bind(text).fetch_one(&pool).await?; let result = result.get::<Vec<f32>, _>(0); let result = serde_json::to_value(result)?; Ok(Json(result)) }",
        "url": 631
    },
    {
        "code_input": "use std::collections::VecDeque;\n\nfn main() {\n    let mut queue = VecDeque::new();\n\n    // Add elements to the queue\n    queue.push_back(1);\n    queue.push_back(2);\n    queue.push_back(3);\n\n    // Print the number of elements in the queue\n    println!(\"Number of elements in the queue: {}\", queue.len());\n}",
        "nl_input": "Returns the number of elements stored in the queue",
        "gt": "pub fn len(&self) -> usize { let (write_position, read_position) = self.acquire_read_and_write_position(); write_position - read_position }",
        "url": 632
    },
    {
        "code_input": "use text_classification::TextClassification;\nuse std::fs::File;\nuse std::io::BufReader;\n\nfn main() {\n    let model_path = \"path_to_your_model\";\n    let mut file = File::open(model_path).expect(\"Failed to open file\");\n    let reader = BufReader::new(file);\n\n    let mut class",
        "nl_input": "Initialize a text recognizer from a trained RTen model. Fails if the model does not have the expected inputs or outputs.",
        "gt": "pub fn from_model(model: Model) -> anyhow::Result<TextRecognizer> { let input_id = model .input_ids() .first() .copied() .ok_or(anyhow!(\"recognition model has no inputs\"))?; let input_shape = model .node_info(input_id) .and_then(|info| info.shape()) .ok_or(anyhow!(\"recognition model does not specify input shape\"))?; let output_id = model .output_ids() .first() .copied() .ok_or(anyhow!(\"recognition model has no outputs\"))?; Ok(TextRecognizer { model, input_id, input_shape: input_shape.into_iter().collect(), output_id, }) }",
        "url": 633
    },
    {
        "code_input": "use rust_tokenizers::Tokenizer;\n\nfn get_prompt() -> String {\n    // Your function to get the prompt\n    // For example, you might use a file or a database query\n    \"Your prompt here\".to_string()\n}\n\nfn main() {\n    let mut tokenizer = Tokenizer::new();\n    let prompt = get_prompt();\n\n    // Tokenize the prompt\n    let tokens = tokenizer.tokenize(&prompt).expect(\"Failed to tokenize prompt\");\n\n    // Print the first token\n    println!(\"{}\", tokens.iter().next().unwrap().as",
        "nl_input": "Load the tokenizer and return the first tokens from the prompt in context.",
        "gt": "fn load_tokenizer(ctx: &Context) -> Result<(Tokenizer, Option<u32>)> { let tokenizer_filename = ctx.data_path.join(\"tokenizer.json\"); log::info!(\"loading tokenizer from {}\", tokenizer_filename.display()); let tokenizer = Tokenizer::from_file(tokenizer_filename).map_err(anyhow::Error::msg)?; let eos_token_id = ctx .config .as_ref() .expect(\"No config specified\") .eos_token_id .or_else(|| tokenizer.token_to_id(DEFAULT_EOS_TOKEN)); Ok((tokenizer, eos_token_id)) }",
        "url": 634
    },
    {
        "code_input": "use std::hash::{Hash, FnvHash};\n\nfn compute_hash(key: &str) -> String {\n    let mut hasher = FnvHash::new();\n    hasher.update(key.as_bytes());\n    let result = hasher.finish();\n    format!(\"{:x}\", result)\n}\n\nfn main() {\n    let key = \"my_key\";\n    let hash = compute_hash(key);\n    println!(\"{}\", hash);\n}",
        "nl_input": "Computes a unique semi-human-readable hash for this key. Some parts of the input are hashes and others are included directly in the name this is to make it easier to identify the cache files.",
        "gt": "pub fn hash_key(&self) -> String { let BuildInput { channel_urls, target_platform, name, version, build, host_platform, host_virtual_packages, build_virtual_packages, } = self; let mut hasher = Xxh3::new(); build.hash(&mut hasher); channel_urls.hash(&mut hasher); host_platform.hash(&mut hasher); host_virtual_packages.hash(&mut hasher); build_virtual_packages.hash(&mut hasher); let hash = URL_SAFE_NO_PAD.encode(hasher.finish().to_ne_bytes()); format!(\"{name}-{version}-{target_platform}-{hash}\",) }",
        "url": 635
    },
    {
        "code_input": "use std::error::Error;\n\nfn main() {\n    let result = some_function();\n\n    if let Err(e) = result {\n        println!(\"Error: {}\", e);\n    }\n}\n\nfn some_function() -> Result<(), Box<dyn Error>> {\n    // Some code here...\n\n    Ok(())\n}",
        "nl_input": "rust-lang rust#78174: ICE: \"cannot convert ReErased to a region vid\"",
        "gt": "fn issue_78174() { match \"foo\" { const { concat!(\"fo\", \"o\") } => (), _ => unreachable!(), } }",
        "url": 636
    },
    {
        "code_input": "use web3::{Client, types::Address, types::HexString};\nuse serde_json::Value;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Create a new client\n    let client = Client::new(\"http://localhost:8545\")?;\n\n    // The address of the contract\n    let contract_address = Address::from_str(\"0x6809f664\")?;\n\n    // The ABI",
        "nl_input": "Calls the contract's `changeDelta` (0x6809f664) function",
        "gt": "pub fn change_delta( &self, new_delta: u128, ) -> ::ethers::contract::builders::ContractCall<M, ()> { self.0 .method_hash([104, 9, 246, 100], new_delta) .expect(\"method not found (this should never happen)\") }",
        "url": 637
    },
    {
        "code_input": "I'm sorry, but it seems there's a misunderstanding. The code you've provided is not clear enough to provide a specific solution. Could you please provide more context or clarify what you're trying to achieve? Are you looking for a Rust code snippet for a specific function or operation?\n",
        "nl_input": "def and def_cx are separated, because Builder has a span associated with what it's currently emitting.",
        "gt": "pub fn def_cx(self, cx: &CodegenCx<'_>) -> Word { self.def_with_span(cx, DUMMY_SP) }",
        "url": 638
    },
    {
        "code_input": "use std::str::FromStr;\n\n#[derive(Debug, PartialEq)]\nenum LengthUnit {\n    Pixel,\n    Percentage,\n}\n\n#[derive(Debug, PartialEq)]\nstruct LengthValue {\n    amount: f32,\n    unit: LengthUnit,\n}\n\nimpl FromStr for LengthValue {\n    type Err = ();\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        let mut parts = s.split_whitespace();\n        let amount = parts.next().unwrap().parse::<f32>().unwrap();\n        let unit = match parts.next().unwrap() {\n            \"px\" => LengthUnit::Pixel,\n            \"%\" => LengthUnit::Per",
        "nl_input": "Parses a string containing a number followed by a unit (`px`, `%`). Allows for negative numbers. Example: ``` LengthValue::from_str(\"100px\") { amount: 100.0, unit: LengthUnit::Pixel } ```",
        "gt": "fn from_str(unparsed: &str) -> anyhow::Result<Self> { let units_regex = Regex::new(r\"([+-]?\\d+)(%|px)?\")?; let err_msg = format!( \"Not a valid length value '{}'. Must be of format '10px' or '10%'.\", unparsed ); let captures = units_regex .captures(unparsed) .context(err_msg.to_string())?; let unit_str = captures.get(2).map_or(\"\", |m| m.as_str()); let unit = match unit_str { \"px\" | \"\" => LengthUnit::Pixel, \"%\" => LengthUnit::Percentage, _ => bail!(err_msg), }; let amount = captures .get(1) .and_then(|amount_str| f32::from_str(amount_str.into()).ok()) .context(err_msg.to_string())?; Ok(LengthValue { amount, unit }) }",
        "url": 639
    },
    {
        "code_input": "use std::sync::mpsc;\n\nstruct ReceivePage {\n    bits: u8,\n}\n\nenum ReceivePage::Bit {\n    Set,\n    Clear,\n}\n\nfn handle_interrupt(page: &mut ReceivePage) {\n    for bit in ReceivePage::Bit::values().filter(|&bit| page.bits & bit as u8 != 0) {\n        match bit {\n            ReceivePage::Bit::Set => {\n                // Handle interrupt for this bit set\n            },\n            ReceivePage::Bit::Clear => {\n                // Handle interrupt for this bit cleared\n            },\n        }\n    }\n\n    // Clear all bits in the receive page\n    page.bits = 0;\n}\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n    let",
        "nl_input": "Handles the shared interrupt by signaling all channels whose bit is set in the receive page. All bits in the receive page are cleared during this operation.",
        "gt": "pub fn handle_shared_interrupt(&self) { let bitmap = AtomicBitmap::new(self.get_recv_page()); let channel_table = self.channel_table.read(); bitmap.scan_and_clear(|event_flag| { let event = channel_table.get(event_flag); if let Some(Some(event)) = event { event.deliver(); } else { tracelimit::warn_ratelimited!(event_flag, \"Guest signaled unknown channel\"); } }); }",
        "url": 640
    },
    {
        "code_input": "use std::collections::HashMap;\n\n#[derive(Debug, Clone)]\nstruct StateChanges {\n    environment: String,\n    changes: Vec<String>,\n}\n\nimpl StateChanges {\n    fn new(environment: String) -> Self {\n        StateChanges {\n            environment,\n            changes: Vec::new(),\n        }\n    }\n}",
        "nl_input": "Creates a new `StateChanges` instance with a single environment name and an empty vector as its value.",
        "gt": "pub(crate) fn new_with_env(env_name: EnvironmentName) -> Self { Self { changes: HashMap::from([(env_name, Vec::new())]), } }",
        "url": 641
    },
    {
        "code_input": "use serde::{Deserialize, Serialize};\n\n#[derive(Serialize, Deserialize, Debug)]\npub struct Field {\n    // No attributes\n}",
        "nl_input": "Generates the code for a field with no attributes.",
        "gt": "fn generate_field_arg(&mut self, binding_info: &BindingInfo<'_>) -> TokenStream { let diag = &self.parent.diag; let field = binding_info.ast(); let mut field_binding = binding_info.binding.clone(); field_binding.set_span(field.ty.span()); let ident = field.ident.as_ref().unwrap(); let ident = format_ident!(\"{}\", ident); quote! { #diag.arg( stringify!(#ident), #field_binding ); } }",
        "url": 642
    },
    {
        "code_input": "I'm sorry, but it seems like there's a misunderstanding. The query you've provided seems to be a request for a code snippet, but it's not clear what the exact task is. \n\nThe query you've provided is a request to emit a specific enum variant in Rust, but it's not clear what the specific enum and variant are. \n\nIf you could provide more context or clarify what you're asking for, I would be able to help you better. For example, are you asking for a way to emit an enum variant, or is this a different kind of request?\n",
        "nl_input": "EMIT_MIR gvn_copy_aggregate.enum_identical_variant.GVN.diff",
        "gt": "fn enum_identical_variant(v: &Enum1) -> Enum1 { match v { Enum1::A(v) => { let a = v.a; let b = v.b; let c = v.c; let all_copy = AllCopy { a, b, c }; Enum1::A(all_copy) } Enum1::B(v) => { let a = v.a; let b = v.b; let c = v.c; let all_copy = AllCopy { a, b, c }; Enum1::B(all_copy) } } }",
        "url": 643
    },
    {
        "code_input": "pub fn convert_back<T: 'static + 'dyn Any>(obj: Box<dyn Any>) -> T {\n    match obj {\n        Box::<T>(ref mut inner) => inner.clone(),\n        _ => panic!(\"The type is not the same as that of the object passed to `new`.\"),\n    }\n}",
        "nl_input": "Converts the memory back to an unerased type. Panics if the type is not the same as that of the object passed to `new`.",
        "gt": "pub fn downcast<T: Any>(self) -> T { let inner: SmallBox<dyn Any, S4> = unsafe { std::mem::transmute(self.0) }; let inner: SmallBox<T, _> = inner.downcast().unwrap(); inner.into_inner() }",
        "url": 644
    },
    {
        "code_input": "use std::any::Any;\nuse std::collections::HashMap;\n\nstruct MyStruct {\n    field1: i32,\n    field2: f64,\n}\n\nfn get_type_by_name(name: &str, s: &MyStruct) -> Option<&Any> {\n    static mut HASH_MAP: HashMap<&str, Box<dyn Any>> = HashMap::new();\n\n    if HASH_MAP.is_empty() {\n        HASH_MAP.insert(\n            \"field1\", Box::new(s.field1 as Any),\n        );\n        HASH_MAP.insert(\n            \"field2\", Box::new(s.field2 as Any),\n        );\n    }\n\n    HASH_MAP.get(name)\n}\n\nfn main() {\n    let s = MyStruct { field1: 1, field",
        "nl_input": "Get's the type of a field by name.",
        "gt": "pub fn get_field_by_name<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, name: Symbol) -> Option<Ty<'tcx>> { match *ty.kind() { ty::Adt(def, args) if def.is_union() || def.is_struct() => def .non_enum_variant() .fields .iter() .find(|f| f.name == name) .map(|f| f.ty(tcx, args)), ty::Tuple(args) => name.as_str().parse::<usize>().ok().and_then(|i| args.get(i).copied()), _ => None, } }",
        "url": 645
    },
    {
        "code_input": "fn get_element<T>(slice: &[T], index: usize) -> T {\n    slice[index]\n}",
        "nl_input": "@ run-fail @ compile-flags: -Copt-level=3 -Cdebug-assertions=no -Zub-checks=yes @ error-pattern: unsafe precondition(s) violated: slice::get_unchecked_mut requires @ revisions: usize range range_to range_from backwards_range",
        "gt": "fn main() { unsafe { let mut s = &mut [0]; #[cfg(usize)] s.get_unchecked_mut(1); #[cfg(range)] s.get_unchecked_mut(1..2); #[cfg(range_to)] s.get_unchecked_mut(..2); #[cfg(range_from)] s.get_unchecked_mut(2..); #[cfg(backwards_range)] s.get_unchecked_mut(1..0); } }",
        "url": 646
    },
    {
        "code_input": "use std::sync::{Arc, Mutex};\n\nstruct Guard<T> {\n    inner: Arc<Mutex<T>>,\n}\n\nimpl<T> Guard<T> {\n    pub fn new(inner: T) -> Guard<T> {\n        let inner = Arc::new(Mutex::new(inner));\n        Guard { inner }\n    }\n\n    pub fn get(&self) -> T {\n        let mutex = self.inner.clone();\n        *mutex.get()\n    }\n}",
        "nl_input": "Constructs a new guard for the given prefix but does not perform any locking operations yet.",
        "gt": "pub fn new(prefix: &Path) -> io::Result<Self> { let guard_path = prefix.join(GUARD_PATH); std::fs::create_dir_all(guard_path.parent().unwrap())?; Ok(Self { guard: fd_lock::RwLock::new( std::fs::File::options() .write(true) .read(true) .create(true) .truncate(false) .open(guard_path)?, ), }) }",
        "url": 647
    },
    {
        "code_input": "use std::io::{self, Read, Result};\nuse tokio::net::TcpStream;\nuse tokio_util::compat::StreamExt;\n\n#[derive(Debug)]\nenum Error {\n    WouldBlock(io::Error),\n}\n\ntype Result<T> = std::result::Result<T, Error>;\n\nstruct Receiver<T: Read + Send + Sync + 'static> {\n    inner: T,\n}\n\nimpl<T: Read + Send + Sync + 'static> Receiver<T> {\n    fn new(inner: T) -> Self {\n        Self { inner }\n    }\n\n    async fn is_ready(&self) -> Result<bool> {\n        let ready = self.inner.is_readable().await;\n        match ready {\n            Ok(ready) => Ok(ready),\n            Err(",
        "nl_input": "Checks if there are incoming packets ready to be processed. Fails with `ErrorKind::WouldBlock` if there are no packets ready.",
        "gt": "fn process_in(&mut self) -> io::Result<()> { if self.state.in_next_full.0 != self.state.in_next_pending { Ok(()) } else { match self.state.in_overlapped[self.state.in_next_pending].io_status() { Some((ntstatus::STATUS_SUCCESS, _)) => { self.state.in_next_pending = (self.state.in_next_pending + 1) % IN_OP_COUNT; Ok(()) } None => Err(ErrorKind::WouldBlock.into()), Some((status, _)) => Err(status_to_error(status)), } } }",
        "url": 648
    },
    {
        "code_input": "fn a_op_b(a: i32, b: i32, op: impl Fn(i32, i32) -> i32) -> i32 {\n    op(a, b)\n}\n\nfn main() {\n    let add = |a, b| a + b;\n    let result = a_op_b(5, 3, add);\n    println!(\"{}\", result);\n}",
        "nl_input": "Evaluation order for `a op=b` otherwise is first `a` then `b`.",
        "gt": "fn generic_compound<T: AddAssign<T> + Default>() { let mut side_order = vec![]; let mut add_assignable: Wrapper<T> = Wrapper(Default::default()); { side_order.push(Side::Lhs); add_assignable }.0 += { side_order.push(Side::Rhs); Default::default() }; assert!(matches!(side_order[..], [Side::Lhs, Side::Rhs])); }",
        "url": 649
    },
    {
        "code_input": "fn main() {\n    println!(\"{}\", 42);\n}",
        "nl_input": "Whether to package these target-specific docs for another similar target.",
        "gt": "pub(crate) fn use_docs_fallback(&self) -> bool { match self { PkgType::JsonDocs | PkgType::HtmlDocs => true, _ => false, } }",
        "url": 650
    },
    {
        "code_input": "fn coerce<T>(arg: &T) -> String\nwhere\n    T: ToString,\n{\n    arg.to_string()\n}\n\nfn main() {\n    let num = 5;\n    let str = \"Hello\";\n    let result = coerce(&num);\n    println!(\"{}\", result); // Outputs: 5\n\n    let result = coerce(&str);\n    println!(\"{}\", result); // Outputs: Hello\n}",
        "nl_input": "The argument coerces to a subtype of the return type.",
        "gt": "fn long_to_short<'a, 'b, T>(xs: &'b [&'static T; 1]) -> &'b [&'a T] { xs }",
        "url": 651
    },
    {
        "code_input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    let shared_value = Arc::new(Mutex::new(0));\n\n    let mut handles = vec![];\n\n    for _ in 0..10 {\n        let handle = thread::spawn(move || {\n            let mut value = shared_value.lock().unwrap();\n\n            while *value < 100 {\n                *value += 1;\n                println!(\"{}\", *value);\n                thread::sleep(Duration::from_secs(1));\n            }\n        });\n\n        handles.push(handle);\n    }\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n}",
        "nl_input": "Waits for a new value to be set.",
        "gt": "pub async fn wait_next(&mut self) { poll_fn(|cx| { let mut old_waker = None; let inner = &mut *self.0; inner.port.with_handler(|state| { if inner.last_id == state.id { old_waker = state.waker.replace(cx.waker().clone()); return Poll::Pending; } inner.last_id = state.id; Poll::Ready(()) }) }) .await }",
        "url": 652
    },
    {
        "code_input": "struct Event {\n    // Your event data here\n}\n\nstruct EventList {\n    events: Vec<Event>,\n}\n\nimpl EventList {\n    fn new() -> EventList {\n        EventList {\n            events: Vec::new(),\n        }\n    }\n\n    fn push(&mut self, event: Event) {\n        self.events.push(event);\n    }\n}",
        "nl_input": "Pushes an event to the event list.",
        "gt": "fn push(&mut self, port: PortRef, seq: Seq, event: PortEvent) { match port { PortRef::LocalPort(port) => self.push_local(port, seq, event), PortRef::RemotePort(remote_node, port_id) => { self.remote_events.push((remote_node, port_id, seq, event)); } } }",
        "url": 653
    },
    {
        "code_input": "fn main() {\n    let add = |x, y| x + y;\n    println!(\"{}\", add(5, 3));\n}",
        "nl_input": "For closures, we first visit the parameters and then the content, as we prefer those.",
        "gt": "fn visit_body(&mut self, body: &Body<'tcx>) { for param in body.params { debug!( \"param: span {:?}, ty_span {:?}, pat.span {:?}\", param.span, param.ty_span, param.pat.span ); if param.ty_span != param.pat.span { debug!(\"skipping param: has explicit type\"); continue; } let Some(param_ty) = self.opt_node_type(param.hir_id) else { continue }; if self.generic_arg_contains_target(param_ty.into()) { self.update_infer_source(InferSource { span: param.pat.span, kind: InferSourceKind::ClosureArg { insert_span: param.pat.span.shrink_to_hi(), ty: param_ty, }, }) } } intravisit::walk_body(self, body); }",
        "url": 654
    },
    {
        "code_input": "fn main() {\n    let y: i32 = 5; // Replace this with your value\n    let result = match y {\n        0 => EarlyOtherwiseBranch::opt1,\n        1 => EarlyOtherwiseBranch::opt2,\n        _ => EarlyOtherwiseBranch::other,\n    };\n\n    match result {\n        EarlyOtherwiseBranch::opt1 => println!(\"opt1\"),\n        EarlyOtherwiseBranch::opt2 => println!(\"opt2\"),\n        EarlyOtherwiseBranch::other => println!(\"other\"),\n    }\n}\n\n#[derive(Debug)]\nenum EarlyOtherwiseBranch {\n    opt1,\n    opt2,\n    other,\n}",
        "nl_input": "We can't optimize it because y may be an invalid value. EMIT_MIR early_otherwise_branch.opt1.EarlyOtherwiseBranch.diff",
        "gt": "fn opt1(x: Option<u32>, y: Option<u32>) -> u32 { match (x, y) { (Some(a), Some(b)) => 0, _ => 1, } }",
        "url": 655
    },
    {
        "code_input": "use std::fs::File;\nuse std::io::BufReader;\nuse toml::value::Table;\nuse toml::toml_array;\nuse toml::toml_value;\n\nfn is_crate_present(crate_name: &str) -> bool {\n    let file_path = std::env::current_dir().unwrap();\n    let file_path = file_path.join(\"Cargo.toml\");\n\n    let file = File::open(&file_path).unwrap();\n    let reader = BufReader::new(file);\n    let mut content = String::new();\n    reader.read_to_string(&mut content).unwrap();\n\n    let table: Table = toml_value::from_str(&content).unwrap();\n    let dependencies = table.get(\"dependencies\").unwrap_or(&Table::new());\n\n    let crates",
        "nl_input": "@ check-pass @ aux-crate:bar=bar.rs @ compile-flags:--crate-type lib -Wunused-crate-dependencies",
        "gt": "pub fn fib(n: u32) -> Vec<u32> { let mut prev = 0; let mut cur = 1; let mut v = vec![]; for _ in 0..n { v.push(prev); let n = prev + cur; prev = cur; cur = n; } v }",
        "url": 656
    },
    {
        "code_input": "fn main() {\n    let x: f64 = 5.0;\n    let y: f64 = 3.0;\n    let sum: f64 = x + y;\n    println!(\"{}\", sum);\n}",
        "nl_input": "~^ ERROR cannot find type `double` in this scope ~| HELP perhaps you intended to use this type",
        "gt": "fn main() { let x: Real = 3.5; let y: long = 74802374902374923; let v1: Boolean = true; let v2: Bool = true; }",
        "url": 657
    },
    {
        "code_input": "fn main() {\n    let result = Ok(\"Hello, world!\".to_string());\n    match result {\n        Ok(value) => println!(\"{}\", value),\n        Err(error) => println!(\"Error: {}\", error),\n    }\n}",
        "nl_input": "even without panics, this helps for Miri backtraces",
        "gt": "pub unsafe fn gather_select_ptr( source: Simd<*const T, N>, enable: Mask<isize, N>, or: Self, ) -> Self { unsafe { core::intrinsics::simd::simd_gather(or, source, enable.to_int()) } }",
        "url": 658
    },
    {
        "code_input": "fn sort_and_deduplicate(provenance: Vec<&str>) -> Vec<&str> {\n    let mut result: Vec<&str> = provenance.into_iter().collect();\n    result.sort();\n    result.dedup();\n    result\n}",
        "nl_input": "The caller must guarantee that the given provenance list is already sorted by address and contain no duplicates.",
        "gt": "pub fn from_presorted_ptrs(r: Vec<(Size, Prov)>) -> Self { ProvenanceMap { ptrs: SortedMap::from_presorted_elements(r), bytes: None } }",
        "url": 659
    },
    {
        "code_input": "use chrono::prelude::*;\nuse chrono::week::Weekday;\nuse chrono::week::Week;\n\nfn group_by_week(dates: &Vec<LocalDate>) -> Vec<(Week, Vec<LocalDate>)> {\n    let mut result = Vec::new();\n    let mut current_week: Option<Week> = None;\n\n    for &date in dates {\n        let week = date.week_number();\n        if let Some(current) = current_week {\n            if current == week {\n                result.last_mut().unwrap().1.push(date);\n            } else {\n                result.push((week, vec![date]));\n                current_week = Some(week);\n            }\n        } else {\n            result.push((week, vec![date]));\n            current_week = Some(week);\n        }\n    }",
        "nl_input": "Groups an iterator of dates by week.",
        "gt": "fn by_week(it: impl DateIterator) -> impl Iterator<Item=(u32, impl DateIterator)> + Clone { it.group_by(|d| d.succ().isoweekdate().1) }",
        "url": 660
    },
    {
        "code_input": "fn list_iterator(binding: &str) -> Option<&str> {\n    match binding {\n        \"list\" => Some(\"item1\"),\n        \"other_list\" => Some(\"item2\"),\n        _ => None,\n    }\n}\n\nfn main() {\n    println!(\"{:?}\", list_iterator(\"list\"));\n    println!(\"{:?}\", list_iterator(\"other_list\"));\n    println!(\"{:?}\", list_iterator(\"not_a_list\"));\n}",
        "nl_input": "Returns an iterator over the items in a list. Returns `None` if the binding is not bound to a list.",
        "gt": "fn list_items(&self) -> Option<impl Iterator<Item = NodeWithSource<'a>> + Clone> { match self { Self::List(parent_node, field_id) => { Some(parent_node.named_children_by_field_id(*field_id)) } Self::Empty(..) | Self::Node(..) | Self::String(..) | Self::ConstantRef(..) | Self::FileName(..) => None, } }",
        "url": 661
    },
    {
        "code_input": "fn find_ancestor_in_body(original_span: &Span, body_span: &Span) -> Option<&str> {\n    let mut current_span = original_span;\n    while let Some(ancestor_span) = current_span.ancestor_span(0) {\n        if ancestor_span.intersects(body_span) {\n            if let Some(macro_name) = find_macro_name_in_span(ancestor_span) {\n                return Some(macro_name);\n            }\n        }\n        current_span = ancestor_span;\n    }\n    None\n}\n\nfn find_macro_name_in_span(span: &Span) -> Option<&str> {\n    if let Some(syntax_context) = span.syntax_context() {\n        if let Some(macro_name",
        "nl_input": "Walks through the expansion ancestors of `original_span` to find a span that is contained in `body_span` and has the same [syntax context] as `body_span`. If the returned span represents a bang-macro invocation (e.g. `foo!(..)`), the returned symbol will be the name of that macro (e.g. `foo`).",
        "gt": "pub(crate) fn unexpand_into_body_span_with_expn_kind( original_span: Span, body_span: Span, ) -> Option<(Span, Option<ExpnKind>)> { let (span, prev) = unexpand_into_body_span_with_prev(original_span, body_span)?; let expn_kind = prev.map(|prev| prev.ctxt().outer_expn_data().kind); Some((span, expn_kind)) }",
        "url": 662
    },
    {
        "code_input": "extern crate chrono;\nextern crate rusqlite;\n\nuse rusqlite::{params, Connection, Result};\nuse chrono::prelude::*;\n\nfn date(conn: &Connection, date: &str) -> Result<Local<DateTime<>>> {\n    let now = Local::now();\n    let date_time = match date {\n        \"today\" => now,\n        \"yesterday\" => now.previous_local(),\n        _ => return Err(\"Invalid date\".into()),\n    };\n\n    Ok(date_time)\n}\n\nfn main() -> Result<()> {\n    let mut conn = Connection::open(\":memory:\")?;\n    conn.execute(\n        \"CREATE TABLE test(date DATE)\",\n        ())?;\n    conn.execute(\n        \"INSERT INTO test(date) VALUES (?)\",\n        (params![date],))?;\n\n    let date_time",
        "nl_input": "Implementation of the date() SQL function.",
        "gt": "pub fn exec_date(values: &[OwnedValue]) -> OwnedValue { let maybe_dt = match values.first() { None => parse_naive_date_time(&OwnedValue::Text(Rc::new(\"now\".to_string()))), Some(value) => parse_naive_date_time(value), }; if maybe_dt.is_none() { return OwnedValue::Text(Rc::new(String::new())); } let mut dt = maybe_dt.unwrap(); for modifier in values.iter().skip(1) { if let OwnedValue::Text(modifier_str) = modifier { if apply_modifier(&mut dt, modifier_str).is_err() { return OwnedValue::Text(Rc::new(String::new())); } } else { return OwnedValue::Text(Rc::new(String::new())); } } OwnedValue::Text(Rc::new(get_date_from_naive_datetime(dt))) }",
        "url": 663
    },
    {
        "code_input": "use rand::Rng;\nuse std::convert::TryInto;\n\nfn base62_encode(input: u64) -> String {\n    static ALPHABET: [char; 62] =\n        \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\".chars().collect();\n\n    let mut output = String::new();\n    let mut num = input;\n\n    loop {\n        let remainder = num % 62;\n        num /= 62;\n        output.push(ALPHABET[remainder as usize]);\n\n        if num == 0 {\n            break;\n        }\n    }\n\n    output.chars().rev().collect::<String>()\n}\n\nfn main",
        "nl_input": "The hash is encoded based on `base-62` and the final terminator `_` is removed because it does not help prevent hash collisions",
        "gt": "fn push_hash64(hash: u64, output: &mut String) { let hash = v0::encode_integer_62(hash); let hash_len = hash.len(); let _ = write!(output, \"{hash_len}H{}\", &hash[..hash_len - 1]); }",
        "url": 664
    },
    {
        "code_input": "I'm sorry, but I can't provide the help you're looking for without more specific details. The information you've provided is incomplete. Could you please provide more details about the `IntoDocuments`, the table you're referring to, and the query you're trying to implement?\n",
        "nl_input": "Extend the table from [`IntoDocuments`]",
        "gt": "pub async fn add_context(&self, context: impl IntoDocuments) -> anyhow::Result<Vec<Id>> where R: From<Document> + AsRef<Document> + Serialize + DeserializeOwned, K: Sync, { let documents = context.into_documents().await?; let iter = documents.into_iter().map(|v| v.into()); self.extend(iter).await }",
        "url": 665
    },
    {
        "code_input": "fn check_binary_operation(a: i32, b: i32, op: &str) -> bool {\n    match op {\n        \"+\" => a + b,\n        \"-\" => a - b,\n        \"*\" => a * b,\n        \"/\" => a / b,\n        _ => false,\n    }\n}",
        "nl_input": "Should trigger lint when both sides of a binary operation creates a temporary with a significant drop. To avoid potential unnecessary copies or creating references that would trigger the significant drop problem, the lint recommends moving the entire binary operation.",
        "gt": "fn should_trigger_lint_for_accessing_fields_in_mutex_in_both_sides_of_binary_op() { let mutex1 = Mutex::new(StateWithField { s: \"state\".to_owned() }); let mutex2 = Mutex::new(StateWithField { s: \"statewithfield\".to_owned(), }); match mutex1.lock().unwrap().s.len() < mutex2.lock().unwrap().s.len() { true => { println!( \"{} < {}\", mutex1.lock().unwrap().s.len(), mutex2.lock().unwrap().s.len() ); }, false => {}, }; match mutex1.lock().unwrap().s.len() >= mutex2.lock().unwrap().s.len() { true => { println!( \"{} >= {}\", mutex1.lock().unwrap().s.len(), mutex2.lock().unwrap().s.len() ); }, false => {}, }; }",
        "url": 666
    },
    {
        "code_input": "use std::collections::HashMap;\n\nfn count_occurrences(nums: &[i32]) -> String {\n    let mut map = HashMap::new();\n    for &num in nums {\n        let count = map.entry(num).or_insert(0);\n        *count += 1;\n    }\n\n    let mut result = String::new();\n    for (num, count) in map {\n        if count > 1 {\n            result.push_str(&format!(\"{} (x{}) \", num, count));\n        } else {\n            result.push_str(&format!(\"{} \", num));\n        }\n    }\n    result.trim_end().to_string()\n}\n\nfn main() {\n    let nums = vec![4, 4, 4, 3, 2, 1, 1, 1, 1, 1];\n    println!",
        "nl_input": "Converts a slice to a string, capturing repetitions to save space. E.g. `[4, 4, 4, 3, 2, 1, 1, 1, 1, 1]` -> \"[4 (x3), 3, 2, 1 (x5)]\".",
        "gt": "fn list(ns: &[usize]) -> String { let mut v = Vec::new(); if ns.is_empty() { return \"[]\".to_string(); } let mut elem = |curr, curr_count| { if curr_count == 1 { v.push(format!(\"{curr}\")); } else { v.push(format!(\"{curr} (x{curr_count})\")); } }; let mut curr = ns[0]; let mut curr_count = 1; for &n in &ns[1..] { if n != curr { elem(curr, curr_count); curr = n; curr_count = 1; } else { curr_count += 1; } } elem(curr, curr_count); format!(\"[{}]\", v.join(\", \")) }",
        "url": 667
    },
    {
        "code_input": "use std::str::FromStr;\n\nenum Expr {\n    Let(String, Box<Expr>),\n    Bool(bool),\n}\n\nimpl FromStr for Expr {\n    type Err = ();\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        if s.starts_with(\"let \") {\n            let name = s[5..s.find_first(|c| !c.is_alphanumeric()).unwrap()];\n            let expr = s[s.find_first(|c| !c.is_alphanumeric()).unwrap()..].parse()?;\n            Ok(Self::Let(name.into(), expr))\n        } else if s.starts_with(\"true\")",
        "nl_input": "Visit the right-hand-side of a `&&`. Used for if-let chains. Returns `Some` if the expression was ultimately a `let ... = ...`, and `None` if it was a normal boolean expression. This must call `visit_expr` on the subexpressions we are not handling ourselves.",
        "gt": "fn visit_land_rhs( &mut self, ex: &'p Expr<'tcx>, ) -> Result<Option<(Span, RefutableFlag)>, ErrorGuaranteed> { match ex.kind { ExprKind::Scope { value, lint_level, .. } => { self.with_lint_level(lint_level, |this| this.visit_land_rhs(&this.thir[value])) } ExprKind::Let { box ref pat, expr } => { let expr = &self.thir()[expr]; self.with_let_source(LetSource::None, |this| { this.visit_expr(expr); }); Ok(Some((ex.span, self.is_let_irrefutable(pat, Some(expr))?))) } _ => { self.with_let_source(LetSource::None, |this| { this.visit_expr(ex); }); Ok(None) } } }",
        "url": 668
    },
    {
        "code_input": "pub fn union_row_set(row: &mut Vec<u32>, set: &mut dyn Set) -> bool {\n    match set {\n        BitSet { bits } => {\n            for bit in bits {\n                if !row.contains(&bit) {\n                    row.push(bit);\n                }\n            }\n            true\n        }\n        HybridBitSet { bits } => {\n            for bit in bits {\n                if !row.contains(&bit) {\n                    row.push(bit);\n                }\n            }\n            true\n        }\n    }\n}",
        "nl_input": "Unions `row` with `set`. `set` can be either `BitSet` or `HybridBitSet`. Returns true if the row was changed.",
        "gt": "pub fn union_row<Set>(&mut self, row: R, set: &Set) -> bool where HybridBitSet<C>: BitRelations<Set>, { self.ensure_row(row).union(set) }",
        "url": 669
    },
    {
        "code_input": "use std::io::Read;\n\n#[derive(Debug, PartialEq)]\nstruct GuestLogData {\n    // Add fields here\n}\n\nfn parse_guest_log_data(bytes: &[u8]) -> Result<GuestLogData, Box<dyn std::error::Error>> {\n    let mut reader = bytes.into_reader();\n\n    // Assumes the first 4 bytes are the length of the rest of the data\n    let mut length = [0u8; 4];\n    reader.read(&mut length)?;\n    let data_length = u32::from_le_bytes([length[0], length[1], length[2], length[3]]);\n\n    // Assumes the next 4 bytes are the offset to the actual data\n    let mut offset = [0u8; 4];\n    reader.read(&mut offset)?;\n    let",
        "nl_input": "Assumes, without verification, that a buffer of bytes contains a GuestLogData and returns it. # Safety Callers must trust the given bytes do indeed contain a valid `GuestLogData`.",
        "gt": "pub unsafe fn root_as_guest_log_data_unchecked(buf: &[u8]) -> GuestLogData { flatbuffers::root_unchecked::<GuestLogData>(buf) }",
        "url": 670
    },
    {
        "code_input": "#[rustc_diagnostic_item = \"ptr_drop_in_place\"]\nfn main() {\n    let v: Vec<i32> = vec![1, 2, 3, 4, 5];\n    let w: Vec<i32> = v.clone();\n    println!(\"{:?}\", w);\n}",
        "nl_input": "FIXME: Consider if `#[rustc_diagnostic_item = \"ptr_drop_in_place\"]` is needed?",
        "gt": "unsafe fn async_drop_in_place_raw<T: ?Sized>( to_drop: *mut T, ) -> <T as AsyncDestruct>::AsyncDestructor { unsafe { async_drop_in_place_raw(to_drop) } }",
        "url": 671
    },
    {
        "code_input": "fn main() {\n    let mut vec: Vec<i32> = vec![1, 2, 3, 4, 5];\n\n    let mut closure = || {\n        let mut i = 0;\n        while i < vec.len() {\n            vec.push(i + 1);\n            i += 1;\n        }\n    };\n\n    closure();\n\n    println!(\"{:?}\", vec);\n}",
        "nl_input": "Fill the remaining space of the vector by calling the provided closure repeatedly",
        "gt": "pub fn fill_with<F: FnMut() -> T>(&mut self, f: F) { unsafe { self.fill_with_impl(f) } }",
        "url": 672
    },
    {
        "code_input": "fn main() {\n    let a = 5;\n    let b = 3;\n    let result = a - b;\n    println!(\"{}\", result);\n}",
        "nl_input": "EMIT_MIR lower_intrinsics.transmute_to_box_uninhabited.LowerIntrinsics.diff",
        "gt": "pub unsafe fn transmute_to_box_uninhabited() -> ! { let x: Box<Never> = std::mem::transmute(1usize); match *x {} }",
        "url": 673
    },
    {
        "code_input": "pub struct BasicBlock {\n    // Define your BasicBlock fields here\n}\n\npub struct SwitchInt {\n    value: i32,\n    cases: Vec<(i32, BasicBlock)>,\n    otherwise: BasicBlock,\n}\n\nimpl SwitchInt {\n    pub fn new(value: i32) -> Self {\n        Self {\n            value,\n            cases: Vec::new(),\n            otherwise: BasicBlock::default(),\n        }\n    }\n\n    pub fn add_case(&mut self, value: i32, block: BasicBlock) {\n        self.cases.push((value, block));\n    }\n\n    pub fn get_block(&self) -> &BasicBlock {\n        for &(v, block) in self.cases.iter() {\n            if v == self.value {\n                return &block;\n            }\n        }\n        &self.otherwise\n    }",
        "nl_input": "Finds the `BasicBlock` to which this `SwitchInt` will branch given the specific value. This cannot fail, as it'll return the `otherwise` branch if there's not a specific match for the value.",
        "gt": "pub fn target_for_value(&self, value: u128) -> BasicBlockId { self.iter().find_map(|(v, t)| (v == value).then_some(t)).unwrap_or_else(|| self.otherwise()) }",
        "url": 674
    },
    {
        "code_input": "fn into(self) -> () {}\n\nfn into2(self) -> () {}\n\nfn into3(self) -> () {}\n\nfn find_position(s: &str) -> Option<usize> {\n    s.chars().rposition('`')\n}",
        "nl_input": "Returns the position just before rarrow ```rust,ignore fn into(self) -> () {} ^ in case of unformatted code fn into2(self)-> () {} ^ fn into3(self) -> () {} ^ ```",
        "gt": "pub fn position_before_rarrow(s: &str) -> Option<usize> { s.rfind(\"->\").map(|rpos| { let mut rpos = rpos; let chars: Vec<char> = s.chars().collect(); while rpos > 1 { if let Some(c) = chars.get(rpos - 1) { if c.is_whitespace() { rpos -= 1; continue; } } break; } rpos }) }",
        "url": 675
    },
    {
        "code_input": "pub fn define_opaque_type(name: &str) -> Result<(), &'static str> {\n    // Define the opaque type\n    use std::any::Any;\n    use std::sync::Arc;\n\n    // Create a new Arc to ensure the opaque type is shared across threads\n    let shared_type = Arc::new(Any::new(name));\n\n    // Return the shared opaque type\n    Ok(shared_type)\n}",
        "nl_input": "While typechecking a body, we need to be able to define the opaque types defined by that body.",
        "gt": "pub fn analysis_in_body(cx: I, body_def_id: I::LocalDefId) -> TypingMode<I> { TypingMode::Analysis { defining_opaque_types: cx.opaque_types_defined_by(body_def_id) } }",
        "url": 676
    },
    {
        "code_input": "use std::collections::HashMap;\n\nstruct Pool {\n    id: u32,\n    touched: bool,\n}\n\nstruct Block {\n    start: u32,\n    end: u32,\n}\n\nimpl Pool {\n    fn new(id: u32) -> Pool {\n        Pool { id, touched: false }\n    }\n\n    fn touch(&mut self) {\n        self.touched = true;\n    }\n}\n\nfn find_touched_pools(blocks: &[Block]) -> HashMap<u32, Pool> {\n    let mut pools = vec![];\n    let mut touched_pools = HashMap::new();\n\n    for block in blocks {\n        for pool in &mut pools {\n            if block.start <= pool.id && pool.id <= block.end {\n                pool.touch();\n                touched_pools.entry(pool",
        "nl_input": "Find all pools that were touched in a given block range.",
        "gt": "async fn get_touched_pools(&self, from_block: u64, to_block: u64) -> Result<Vec<H160>> { let address_list = self.pool_bids.keys().cloned().collect::<Vec<_>>(); let filter = Filter::new() .from_block(from_block) .to_block(to_block) .address(address_list) .events(&*POOL_EVENT_SIGNATURES); let events = self.client.get_logs(&filter).await?; let touched_pools = events.iter().map(|event| event.address).collect::<Vec<_>>(); Ok(touched_pools) }",
        "url": 677
    },
    {
        "code_input": "I'm sorry, but the code you've provided seems to be a specific issue with the Rust compiler, and it's not clear what the problem is. The `@ known-bug:` and `@ compile-flags:` lines are not valid Rust syntax. \n\nIf you're asking for a Rust code, I'd need more information about the problem you're trying to solve. For example, are you trying to optimize a specific function, or are you trying to use a specific feature in Rust? Please provide more details so I can assist you better.\n",
        "nl_input": "@ known-bug: rust-lang rust#129095 @ compile-flags: -Zmir-opt-level=5 -Zvalidate-mir",
        "gt": "pub fn function_with_bytes<const BYTES: &'static [u8; 4]>() -> &'static [u8] { BYTES }",
        "url": 678
    },
    {
        "code_input": "pub fn sum_from_index(vec: &Vec<u64>, ix: u64) -> u64 {\n    let mut sum: u64 = 0;\n    for i in ix..vec.len() {\n        sum += vec[i];\n    }\n    sum\n}",
        "nl_input": "* Note: This function is only called for ix>=0x40000000 (see above) *",
        "gt": "fn pone(x: f64) -> f64 { let ix = high_word(x) & 0x7fffffff; let (p, q) = if ix >= 0x40200000 { (PR8, PS8) } else if ix >= 0x40122E8B { (PR5, PS5) } else if ix >= 0x4006DB6D { (PR3, PS3) } else { (PR2, PS2) }; let z = 1.0 / (x * x); let r = p[0] + z * (p[1] + z * (p[2] + z * (p[3] + z * (p[4] + z * p[5])))); let s = 1.0 + z * (q[0] + z * (q[1] + z * (q[2] + z * (q[3] + z * q[4])))); 1.0 + r / s }",
        "url": 679
    },
    {
        "code_input": "struct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nimpl Rectangle {\n    fn new(width: u32, height: u32) -> Rectangle {\n        Rectangle { width, height }\n    }\n}",
        "nl_input": "It's common to define a constructor sort of function to create struct instances. If there is a canonical constructor it is typically named the same as the type. Other constructor sort of functions are typically named from_foo, from_bar, etc.",
        "gt": "fn AsciiArt(width: usize, height: usize, fill: char) -> AsciiArt { let lines = vec![vec!['.'; width]; height]; AsciiArt {width: width, height: height, fill: fill, lines: lines} }",
        "url": 680
    },
    {
        "code_input": "use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};\nuse near_sdk::{env, near_bindgen};\n\n#[near_bindgen]\n#[derive(BorshDeserialize, BorshSerialize)]\npub struct SpotPriceUpdate {\n    pub price: f64,\n}\n\nimpl env::log::Log for SpotPriceUpdate {\n    fn title(&self) -> String {\n        String::from(\"SpotPriceUpdate\")\n    }\n}\n\n#[near_bindgen]\nimpl env::event::Event for SpotPriceUpdate {\n    fn new(price: f64) -> Self {\n        Self { price }\n    }\n\n    fn title(&self) -> String {\n        String::from(\"SpotPriceUpdate\")\n    }\n\n    fn deserialize(input:",
        "nl_input": "Gets the contract's `SpotPriceUpdate` event",
        "gt": "pub fn spot_price_update_filter( &self, ) -> ::ethers::contract::builders::Event< ::std::sync::Arc<M>, M, SpotPriceUpdateFilter, > { self.0.event() }",
        "url": 681
    },
    {
        "code_input": "use std::io::{self, Read};\nuse std::pin::Pin;\nuse std::sync::mpsc;\n\nconst MAXIMUM_WAIT_READ_SIZE: usize = 1024;\n\nfn read_from_fd(fd: &mut Pin<Box<dyn Read>>, read_size: usize) -> Vec<u8> {\n    let mut buffer = vec![0; read_size];\n    let mut bytes_read = 0;\n\n    loop {\n        let read_result = fd.read(&mut buffer).unwrap();\n        bytes_read += read_result;\n\n        if bytes_read == read_size {\n            break;\n        }\n\n        if read_result == 0 {\n            panic!(\"File descriptor is not ready\");\n        }\n\n        if",
        "nl_input": "Returns a new instance that waits for `fd` to be ready via `fd_ready`, then reads `read_size` bytes from it. Panics if `read_size` is greater than [`MAXIMUM_WAIT_READ_SIZE`].",
        "gt": "pub fn new(fd: RawFd, fd_ready: T, read_size: usize) -> Self { assert!(read_size <= MAXIMUM_WAIT_READ_SIZE); Self { fd_ready, fd, read_size, } }",
        "url": 682
    },
    {
        "code_input": "let x = 5;\nlet y = 10;\nlet z = 15;\n\nlet result;\n\nif x < y {\n    result = x;\n} else {\n    if y < z {\n        result = y;\n    } else {\n        result = z;\n    }\n}\n\nprintln!(\"The smallest value is: {}\", result);",
        "nl_input": "Wether this expression would be valid somewhere that expects a value, for example, an `if` condition.",
        "gt": "pub fn returns(&self) -> bool { if let ExprKind::Block(ref block) = self.node { match block.stmts.last().map(|last_stmt| &last_stmt.node) { Some(&StmtKind::Expr(_)) => true, Some(&StmtKind::Semi(ref expr)) => { if let ExprKind::Ret(_) = expr.node { true } else { false } } _ => false, } } else { true } }",
        "url": 683
    },
    {
        "code_input": "fn is_subtype<T: std::cmp::PartialEq + std::hash::Hash + Send + Sync + 'static>(expected: T, actual: &T) -> bool {\n    expected == actual\n}\n\nfn main() {\n    let expected = 5;\n    let actual = &expected;\n    let result = is_subtype(expected, actual);\n    println!(\"{}\", result);\n}",
        "nl_input": "Makes `expected <: actual`.",
        "gt": "pub fn sub<T>( self, define_opaque_types: DefineOpaqueTypes, expected: T, actual: T, ) -> InferResult<'tcx, ()> where T: ToTrace<'tcx>, { if self.infcx.next_trait_solver { NextSolverRelate::relate(self.infcx, self.param_env, expected, ty::Covariant, actual) .map(|goals| self.goals_to_obligations(goals)) } else { let mut op = TypeRelating::new( self.infcx, ToTrace::to_trace(self.cause, expected, actual), self.param_env, define_opaque_types, ty::Covariant, ); op.relate(expected, actual)?; Ok(InferOk { value: (), obligations: op.into_obligations() }) } }",
        "url": 684
    },
    {
        "code_input": "struct TreeNode {\n    value: i32,\n    left: Option<Box<TreeNode>>,\n    right: Option<Box<TreeNode>>,\n}\n\nfn compile_tree(tree: &TreeNode) -> &'static str {\n    match tree {\n        &TreeNode { left: Some(ref left), right: Some(ref right), .. } => {\n            if left.value < right.value {\n                \"left is smaller than right\"\n            } else if left.value > right.value {\n                \"left is larger than right\"\n            } else {\n                \"left and right are equal\"\n            }\n        }\n        _ => \"tree is empty\",\n    }\n}\n\nfn main() {\n    let tree = TreeNode {\n        value: 5,\n        left: Some(Box::new(TreeNode {\n            value: 3,\n            left: None,\n            right: None,",
        "nl_input": "@revisions: stack tree @[tree]compile-flags: -Zmiri-tree-borrows @error-in-other-file: expected a pointer to 4 bytes of memory",
        "gt": "fn main() { unsafe { let ptr = Box::into_raw(Box::new(0u16)); drop(Box::from_raw(ptr as *mut u32)); } }",
        "url": 685
    },
    {
        "code_input": "use std::slice::Iter;\n\npub fn get_arg_type(args: &[&dyn Any], offset: usize) -> Option<&'static str> {\n    if offset < args.len() {\n        match &args[offset] {\n            Box<dyn Any>::into_inner() => Some(\"Box<dyn Any>\"),\n            _ => Some(\"<unknown>\"),\n        }\n    } else {\n        None\n    }\n}",
        "nl_input": "Gets the argument type at the given offset. For closures this will also get the type as written. This will return `None` when the index is out of bounds only for variadic functions, otherwise this will panic.",
        "gt": "pub fn input_with_hir(self, i: usize) -> Option<(Option<&'tcx hir::Ty<'tcx>>, Binder<'tcx, Ty<'tcx>>)> { match self { Self::Sig(sig, _) => { if sig.c_variadic() { sig.inputs() .map_bound(|inputs| inputs.get(i).copied()) .transpose() .map(|arg| (None, arg)) } else { Some((None, sig.input(i))) } }, Self::Closure(decl, sig) => Some(( decl.and_then(|decl| decl.inputs.get(i)), sig.input(0).map_bound(|ty| ty.tuple_fields()[i]), )), Self::Trait(inputs, _, _) => Some((None, inputs.map_bound(|ty| ty.tuple_fields()[i]))), } }",
        "url": 686
    },
    {
        "code_input": "pub fn get_item<T>(index: usize, data: &Vec<T>) -> Option<&T> {\n    data.get(index)\n}",
        "nl_input": "~ MONO_ITEM fn <Indexable as std::ops::Index<usize>>::index",
        "gt": "fn index(&self, index: usize) -> &Self::Output { if index >= 3 { &self.data[0] } else { &self.data[index] } }",
        "url": 687
    },
    {
        "code_input": "use std::io::{self, Write, Read};\n\nfn main() {\n    let (mut reader1, mut writer1) = io::pipe();\n    let (mut reader2, mut writer2) = io::pipe();\n\n    let _ = std::thread::spawn(move || {\n        let mut s = String::new();\n        reader1.read_line(&mut s).unwrap();\n        println!(\"{}\", s);\n\n        let mut s = String::new();\n        reader2.read_line(&mut s).unwrap();\n        println!(\"{}\", s);\n    });\n\n    let _ = std::thread::spawn(move || {\n        let s = \"Hello, world!\";\n        writer1.write_all(s.as_bytes()).unwrap();\n\n        writer2.write_all(s.as_bytes()).unwrap();\n    });\n}",
        "nl_input": "Returns a pipe (reader, writer combo)",
        "gt": "fn pipe() -> (i32, i32) { let mut fds = [0; 2]; assert_eq!(unsafe { libc::pipe(fds.as_mut_ptr()) }, 0); (fds[0], fds[1]) }",
        "url": 688
    },
    {
        "code_input": "use serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\n\n#[derive(Serialize, Deserialize, Debug)]\nstruct EmbeddingRequest {\n    // Define your fields here\n}\n\nimpl EmbeddingRequest {\n    pub fn to_embeddings(&self) -> HashMap<String, Vec<f32>> {\n        // Implement your conversion logic here\n        unimplemented!()\n    }\n}",
        "nl_input": "Convert a query to embeddings. # Arguments * `embedding_request` - A reference to an `EmbeddingRequest` object.",
        "gt": "pub async fn rag_query_to_embeddings( embedding_request: &EmbeddingRequest, ) -> Result<EmbeddingsResponse, LlamaCoreError> { #[cfg(feature = \"logging\")] info!(target: \"stdout\", \"Compute embeddings for the user query.\"); let running_mode = running_mode()?; if running_mode != RunningMode::Rag { let err_msg = format!(\"The RAG query is not supported in the {running_mode} mode.\",); #[cfg(feature = \"logging\")] error!(target: \"stdout\", \"{}\", &err_msg); return Err(LlamaCoreError::Operation(err_msg)); } embeddings(embedding_request).await }",
        "url": 689
    },
    {
        "code_input": "use std::sync::{Arc, Mutex};\nuse std::thread;\n\nfn main() {\n    let counter = Arc::new(Mutex::new(0));\n\n    let mut handles = vec![];\n\n    for _ in 0..2 {\n        let counter = counter.clone();\n        let handle = thread::spawn(move || {\n            let mut num = counter.lock().unwrap();\n            for _ in 0..10 {\n                *num += 1;\n            }\n        });\n        handles.push(handle);\n    }\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n\n    println!(\"Final counter value: {}\", *counter.lock().unwrap());\n}",
        "nl_input": "Might lose data if multiple thread calls it simultaneously",
        "gt": "pub fn update<F>(&self, func: F) where F: FnOnce(&mut T), { let mut v = self.0.load(); func(&mut v); self.0.store(v) }",
        "url": 690
    },
    {
        "code_input": "use ethers::prelude::*;\nuse ethers::types::Address;\n\n#[derive(Debug, Clone)]\npub struct Contract {\n    client: Client,\n    address: Address,\n}\n\nimpl Contract {\n    pub async fn new(client: Client, address: Address) -> Self {\n        Self {\n            client,\n            address,\n        }\n    }\n\n    pub async fn transfer_ownership(&self, new_owner: &str) -> Result<(), Box<dyn std::error::Error>> {\n        let contract = self.client.contract::<&str>::new(self.address.clone(), \"transferOwnership\");\n        let tx = contract.transfer_ownership(new_owner).await?;\n        let receipt = self.",
        "nl_input": "Calls the contract's `transferOwnership` (0x6d435421) function",
        "gt": "pub fn transfer_ownership( &self, conduit: ::ethers::core::types::Address, new_potential_owner: ::ethers::core::types::Address, ) -> ::ethers::contract::builders::ContractCall<M, ()> { self.0 .method_hash([109, 67, 84, 33], (conduit, new_potential_owner)) .expect(\"method not found (this should never happen)\") }",
        "url": 691
    },
    {
        "code_input": "I'm sorry, but your request is not clear. It seems like you're asking for help with a specific code snippet, but you didn't provide enough context. Could you please provide more details? For example, what is the purpose of the code, what is the input and output, and what is the expected output? This will help me provide a more accurate and helpful response.\n",
        "nl_input": "EMIT_MIR combine_array_len.norm2.InstSimplify-after-simplifycfg.diff",
        "gt": "fn norm2(x: [f32; 2]) -> f32 { let a = x[0]; let b = x[1]; a * a + b * b }",
        "url": 692
    },
    {
        "code_input": "use web3::{Client, types::Address, types::HexString};\nuse serde_json::Value;\n\n#[derive(Debug, serde::Deserialize)]\nstruct Result {\n    result: String,\n}\n\nfn main() {\n    let client = Client::new(\"http://localhost:8545\");\n\n    let contract_address = Address::from_str(\"0x46423aa7\").unwrap();",
        "nl_input": "Calls the contract's `getOrderStatus` (0x46423aa7) function",
        "gt": "pub fn get_order_status( &self, order_hash: [u8; 32], ) -> ::ethers::contract::builders::ContractCall< M, (bool, bool, ::ethers::core::types::U256, ::ethers::core::types::U256), > { self.0 .method_hash([70, 66, 58, 167], order_hash) .expect(\"method not found (this should never happen)\") }",
        "url": 693
    },
    {
        "code_input": "pub enum Datatype {\n    Int,\n    Float,\n    String,\n    // Add more datatypes as needed\n}\n\npub struct Cluster {\n    datatypes: Vec<Datatype>,\n}\n\nimpl Cluster {\n    pub fn new() -> Self {\n        Cluster {\n            datatypes: Vec::new(),\n        }\n    }\n\n    pub fn add_datatype(&mut self, datatype: Datatype) {\n        self.datatypes.push(datatype);\n    }\n\n    pub fn get_datatypes(&self) -> &Vec<Datatype> {\n        &self.datatypes\n    }\n}\n\npub enum ScalarDatatype {\n    Int(Cluster),\n    Float(Cluster),\n    String(Cluster),\n    // Add more datatypes as needed\n}\n\nimpl ScalarDat",
        "nl_input": "cluster datatypes into MultiDatatype ScalarDatatype groups",
        "gt": "pub fn cluster_datatypes(dts: Vec<Datatype>) -> Vec<MetaDatatype> { let mdts: Vec<MultiDatatype> = MultiDatatype::variants() .iter() .filter(|mdt| mdt.datatypes().iter().filter(|x| dts.contains(x)).count() >= 2) .cloned() .collect(); let mdt_dts: Vec<Datatype> = mdts.iter().flat_map(|mdt| mdt.datatypes()).filter(|dt| dts.contains(dt)).collect(); let other_dts: Vec<Datatype> = dts.iter().filter(|dt| !mdt_dts.contains(dt)).copied().collect(); [ mdts.iter().map(|mdt| MetaDatatype::Multi(*mdt)).collect::<Vec<MetaDatatype>>(), other_dts.into_iter().map(MetaDatatype::Scalar).collect(), ] .concat() }",
        "url": 694
    },
    {
        "code_input": "struct MyStruct {\n    data: Vec<i32>,\n}\n\nimpl MyStruct {\n    fn get(&self, index: usize) -> Option<&i32> {\n        self.data.get(index)\n    }\n}",
        "nl_input": "Issue 46095 Built-in indexing should be used even when the index is not trivially an integer Overloaded indexing would cause wrapped to be borrowed mutably",
        "gt": "fn main() { let mut a1 = A; let mut a2 = A; let wrapped = [&mut a1, &mut a2]; { wrapped[0 + 1 - 1].take_mutably(); } { wrapped[identity(0)].take_mutably(); } }",
        "url": 695
    },
    {
        "code_input": "use reqwest::Error;\nuse std::net::SocketAddr;\n\nfn check_connection(addr: SocketAddr) -> Result<bool, Error> {\n    let client = reqwest::Client::new();\n    let url = format!(\"http://{}\", addr.to_string_lossy());\n    let res = client.get(url.as_str()).await?;\n    match res.status() {\n        Ok(_) => Ok(true),\n        Err(_) => Ok(false),\n    }\n}",
        "nl_input": "Returns whether the remote node connection has failed.",
        "gt": "fn node_status(&self) -> Result<(), NodeError> { if !self.failed.load(Ordering::SeqCst) { return Ok(()); } self.node_error.lock().clone() }",
        "url": 696
    },
    {
        "code_input": "pub struct CongestionControl {\n    pub window_size: usize,\n    pub packet_count: usize,\n    pub packet_sequence: Vec<usize>,\n}\n\nimpl CongestionControl {\n    pub fn new(window_size: usize) -> Self {\n        Self {\n            window_size,\n            packet_count: 0,\n            packet_sequence: Vec::new(),\n        }\n    }\n\n    pub fn add_packet(&mut self) {\n        self.packet_count += 1;\n        self.packet_sequence.push(self.packet_count);\n\n        if self.packet_sequence.len() > self.window_size {\n            self.packet_sequence.remove(0);\n        }\n    }\n\n    pub fn congestion_window(&self) -> usize {\n        let mut congestion_window = 0;\n\n        for",
        "nl_input": "Adjust the congestion window See draft-cardwell-iccrg-bbr-congestion-control-00 Section 4.2.3.6",
        "gt": "fn set_cwnd(&mut self) { let bytes_in_flight = self.stats.bytes_in_flight; self.update_target_cwnd(); self.modulate_cwnd_for_recovery(bytes_in_flight); if !self.packet_conservation { if self.is_filled_pipe() { self.cwnd = self .target_cwnd .min(self.cwnd + self.ack_state.newly_acked_bytes); } else if self.cwnd < self.target_cwnd || self.delivery_rate_estimator.delivered() < self.config.initial_cwnd { self.cwnd += self.ack_state.newly_acked_bytes; } self.cwnd = self.cwnd.max(self.config.min_cwnd); } self.modulate_cwnd_for_probe_rtt(); }",
        "url": 697
    },
    {
        "code_input": "use num_bigint::BigUint;\n\nfn biguint_to_vec(n: &BigUint, len: usize) -> Vec<u8> {\n    let mut vec: Vec<u8> = Vec::with_capacity(len);\n    for _ in 0..len {\n        vec.push(0);\n    }\n    let mut i = n.iter();\n    let mut j = 0;\n    while let Some(digit) = i.next() {\n        vec[j] = *digit as u8;\n        j += 1;\n    }\n    vec\n}",
        "nl_input": "Convert a BigUint to a Vec of F limbs (with len NB_LIMBS).",
        "gt": "fn to_limbs_field_vec<E: From<F>, F: Field>(x: &BigUint) -> Vec<E> { Self::to_limbs(x).into_iter().map(|x| F::from_canonical_u8(x).into()).collect::<Vec<_>>() }",
        "url": 698
    },
    {
        "code_input": "fn set_row_to_true(row: &mut Vec<bool>) {\n    for i in 0..row.len() {\n        row[i] = true;\n    }\n}",
        "nl_input": "Sets every cell in `row` to true.",
        "gt": "pub fn insert_all_into_row(&mut self, row: R) { assert!(row.index() < self.num_rows); let (start, end) = self.range(row); let words = &mut self.words[..]; for index in start..end { words[index] = !0; } clear_excess_bits_in_final_word(self.num_columns, &mut self.words[..end]); }",
        "url": 699
    },
    {
        "code_input": "fn apply_binary_operator<T>(lhs: &[T], rhs: &[T], op: impl Fn(&T, &T) -> T) -> Vec<T> {\n    assert!(lhs.len() == rhs.len());\n    let mut result = vec![T::default(); lhs.len()];\n    for i in 0..lhs.len() {\n        result[i] = op(lhs[i], rhs[i]);\n    }\n    result\n}",
        "nl_input": "Apply a binary operator to two slices of the same length with right upcasting returning results.",
        "gt": "pub(crate) fn try_slice_binary_op_right_upcast<S, T, U, F>( lhs: &[S], rhs: &[T], op: F, ) -> ColumnOperationResult<Vec<U>> where T: Copy + Into<S>, F: Fn(&S, &S) -> ColumnOperationResult<U>, { try_slice_binary_op(lhs, rhs, |l, r| -> ColumnOperationResult<U> { op(l, &Into::<S>::into(*r)) }) }",
        "url": 700
    },
    {
        "code_input": "fn add_two_numbers(a: i32, b: i32) -> i32 {\n    let local_variable = a + b;\n    local_variable\n}",
        "nl_input": "Some locals are part of the function's interface and can not be removed. Note that these locals *can* still be merged with non-required locals by removing that other local.",
        "gt": "fn is_local_required(local: Local, body: &Body<'_>) -> bool { match body.local_kind(local) { LocalKind::Arg | LocalKind::ReturnPointer => true, LocalKind::Temp => false, } }",
        "url": 701
    },
    {
        "code_input": "use web3::types::Address;\nuse web3::types::HexValue;\nuse web3::types::Log;\nuse web3::types::Transaction;\nuse web3::types::BlockNumber;\n\npub fn get_token_withdrawal_events(web3: &web3::Web3, contract_address: &Address) -> Vec<Event> {\n    let contract_address = HexValue::new(contract_address.to_string());\n    let event_filter = web3.eth().logs({\n        \"address\": contract_address,\n        \"topic\": Some(\"0x7ff36ab5b14047068d87663eb0145189742715202c99",
        "nl_input": "Gets the contract's `TokenWithdrawal` event",
        "gt": "pub fn token_withdrawal_filter( &self, ) -> ::ethers::contract::builders::Event< ::std::sync::Arc<M>, M, TokenWithdrawalFilter, > { self.0.event() }",
        "url": 702
    },
    {
        "code_input": "extern crate regex;\n\nuse regex::Regex;\n\nfn main() {\n    let s = \"This_is_a_test_string_with_underscore_patterns_in_it\";\n    let re = Regex::new(r\"_+\").unwrap();\n    let s = re.replace_all(s, \"_\");\n    println!(\"{}\", s);\n}",
        "nl_input": "Check that underscore patterns within more complex patterns are dropped after the method is polled.",
        "gt": "async fn baz_async((x, _): (D, D)) { x.1.borrow_mut().push(DropOrder::Function); NeverReady.await; }",
        "url": 703
    },
    {
        "code_input": "use web3::{Client, types::Address, types::HexString};\n\nfn main() {\n    let client = Client::new(\"http://localhost:8545\");\n\n    let contract_address = Address::from_str(\"0x081812fc\").unwrap();\n\n    let result = client.call(\n        \"getApproved\",\n        &[contract_address],\n        &[],\n        &[],\n    )\n    .unwrap();\n\n    println!(\"{:?}\", result);\n}",
        "nl_input": "Calls the contract's `getApproved` (0x081812fc) function",
        "gt": "pub fn get_approved( &self, token_id: ::ethers::core::types::U256, ) -> ::ethers::contract::builders::ContractCall< M, ::ethers::core::types::Address, > { self.0 .method_hash([8, 24, 18, 252], token_id) .expect(\"method not found (this should never happen)\") }",
        "url": 704
    },
    {
        "code_input": "use std::io::Write;\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    let mut my_slice = vec![1, 2, 3, 4, 5];\n    let illegal_content = vec![6, 7, 8, 9, 10];\n\n    // Append illegal content to my_slice\n    if !my_slice.append(&mut illegal_content) {\n        return Err(\"Failed to append illegal content to my_slice\".into());\n    }\n\n    println!(\"{:?}\", my_slice);\n    Ok(())\n}",
        "nl_input": "Adds a byte slice at the end. When the capacity is exceeded, the byte slice contains illegal characters or the content would result in an illegal content it fails.",
        "gt": "fn push_bytes(&mut self, bytes: &[u8]) -> Result<(), SemanticStringError> { self.insert_bytes(self.len(), bytes) }",
        "url": 705
    },
    {
        "code_input": "use std::fs;\nuse std::path::Path;\n\nfn get_lock_file_data(path: &Path) -> Result<(Vec<u8>, Vec<u8>), std::io::Error> {\n    let mut data = Vec::new();\n    let mut derived_data = Vec::new();\n\n    if let Ok(content) = fs::read(path) {\n        data.extend(content);\n    } else {\n        return Err(std::io::Error::new(std::io::ErrorKind::InvalidInput, \"Failed to read lock file\"));\n    }\n\n    derived_data = get_derived_data(&data);\n\n    Ok((data, derived_data))\n}\n\nfn get_derived_data(data: &[u8]) ->",
        "nl_input": "Ensures that the lock-file is up-to-date with the project information. Returns the lock-file and any potential derived data that was computed as part of this operation.",
        "gt": "pub async fn update_lock_file( &self, options: UpdateLockFileOptions, ) -> miette::Result<LockFileDerivedData<'_>> { self::update_lock_file(self, options).await }",
        "url": 706
    },
    {
        "code_input": "I'm sorry, but your request is not clear. The code you're asking for is a warning for a non-local `macro_rules!` definition, but it's not clear what the `macro_rules!` is supposed to do. Could you please provide more context or clarify what you're trying to achieve?\n",
        "nl_input": "~^ WARN non-local `macro_rules!` definition",
        "gt": "fn main() { #[macro_export] macro_rules! m { () => { } }; struct InsideMain; impl InsideMain { fn bar() { #[macro_export] macro_rules! m2 { () => { } }; } } }",
        "url": 707
    },
    {
        "code_input": "use std::collections::HashMap;\n\n// Define a struct to hold the actions callbacks\n#[derive(Default)]\nstruct Actions {\n    callbacks: HashMap<String, Box<dyn Fn()>>,\n}\n\n// Define a global instance of the Actions struct\nstatic ACTIONS: Actions = Actions::default();\n\n// Define a function to add a new action callback\nfn add_action<F>(name: &str, callback: F)\nwhere\n    F: 'static + Fn() + 'static,\n{\n    ACTIONS.callbacks.insert(name.to_string(), Box::new(callback));\n}\n\n// Define a function to run a specific action\nfn run_function(name: &str) {\n    if let Some(callback) = ACTIONS.callbacks.get(name) {\n        callback();",
        "nl_input": "This fn should be called on startup. All `run_function` calls will fail if actions callbacks are not set.",
        "gt": "fn set_action_callbacks(&self, action_callbacks: Arc<dyn ActionCallbacks>) { *self.action_callbacks.write() = Some(Arc::downgrade(&action_callbacks)); }",
        "url": 708
    },
    {
        "code_input": "trait MyTrait {\n    // This is the trait\n}\n\n#[derive(MyTrait)]\nstruct MyDerive {\n    // This is the derive\n}\n\nfn main() {\n    let _my_derive = MyDerive {};\n}",
        "nl_input": "Check for resolve collisions between a trait and its derive. These are common and we should just resolve to the trait in that case.",
        "gt": "fn is_derive_trait_collision<T>(ns: &PerNS<Result<Vec<(Res, T)>, ResolutionFailure<'_>>>) -> bool { if let (Ok(type_ns), Ok(macro_ns)) = (&ns.type_ns, &ns.macro_ns) { type_ns.iter().any(|(res, _)| matches!(res, Res::Def(DefKind::Trait, _))) && macro_ns .iter() .any(|(res, _)| matches!(res, Res::Def(DefKind::Macro(MacroKind::Derive), _))) } else { false } }",
        "url": 709
    },
    {
        "code_input": "use webidl::{types::Utf8String, WebIDLException, WebIDLResult};\nuse std::collections::HashMap;\n\n#[tokio::main]\nasync fn main() -> WebIDLResult<()> {\n    // Create a new context.\n    let context = webidl::Context::new().expect(\"Failed to create context\");\n\n    // Define the interface.\n    let interface = context\n        .bindings()\n        .expect(\"Failed to bindings\")\n        .expect(\"Failed to get bindings\")\n        .expect(\"Failed to get interface\");\n\n    // Define the input element.\n    let",
        "nl_input": "Function to wait for an input element to be focused and then using AX to fill it",
        "gt": "pub fn autofill(value: &str, password: bool, prev: &str) -> Option<String> { unsafe { swift!( fn autofill(value: SRString, password: Bool, prev: SRString) -> Option<SRString>); autofill( SRString::from(value), Bool::from(password), SRString::from(prev), ) } .map(|s| s.to_string()) }",
        "url": 710
    },
    {
        "code_input": "fn is_marked_as_red(node: &str) -> bool {\n    marked_as_red\n}",
        "nl_input": "Returns true if the given node has been marked as red during the current compilation session. Used in various assertions",
        "gt": "pub fn is_red(&self, dep_node: &DepNode) -> bool { matches!(self.node_color(dep_node), Some(DepNodeColor::Red)) }",
        "url": 711
    },
    {
        "code_input": "I'm sorry, but your request is not clear. The code you're asking for is not provided. Could you please provide more details or context?\n",
        "nl_input": "line!(): expands to the current line number",
        "gt": "pub(crate) fn expand_line( cx: &mut ExtCtxt<'_>, sp: Span, tts: TokenStream, ) -> MacroExpanderResult<'static> { let sp = cx.with_def_site_ctxt(sp); check_zero_tts(cx, sp, tts, \"line!\"); let topmost = cx.expansion_cause().unwrap_or(sp); let loc = cx.source_map().lookup_char_pos(topmost.lo()); ExpandResult::Ready(MacEager::expr(cx.expr_u32(topmost, loc.line as u32))) }",
        "url": 712
    },
    {
        "code_input": "use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};\nuse near_sdk::{env, near_bindgen};\nuse near_sdk::types::{AccountId, Uint256};\n\n#[near_bindgen]\n#[derive(BorshDeserialize, BorshSerialize)]\npub struct CallTargetStatusUpdate {\n    pub target_id: AccountId,\n    pub call_id: Uint256,\n    pub status: Uint256,\n}\n\nimpl CallTargetStatusUpdate {\n    pub fn new(target_id: AccountId, call_id: Uint256, status: Uint256) -> Self {\n        Self {\n            target_id,\n            call_id",
        "nl_input": "Gets the contract's `CallTargetStatusUpdate` event",
        "gt": "pub fn call_target_status_update_filter( &self, ) -> ::ethers::contract::builders::Event< ::std::sync::Arc<M>, M, CallTargetStatusUpdateFilter, > { self.0.event() }",
        "url": 713
    },
    {
        "code_input": "pub fn get_statistics(partition: &Vec<Partition>) -> (f64, f64, f64) {\n    let mut sum = 0.0;\n    let mut min = f64::INFINITY;\n    let mut max = f64::NEG_INFINITY;\n\n    for &partition in partition {\n        sum += partition.value;\n        min = min.min(partition.value);\n        max = max.max(partition.value);\n    }\n\n    let avg = sum / (partition.len() as f64);\n\n    (avg, min, max)\n}",
        "nl_input": "get statistics for partition NOTE: this function is not exhaustive",
        "gt": "pub fn stats(&self) -> PartitionStats { let chunk = self.clone(); PartitionStats { block_numbers: chunk.block_numbers.map(|c| c.stats()), transactions: chunk.transactions.map(|c| c.stats()), call_datas: chunk.call_datas.map(|c| c.stats()), addresses: chunk.addresses.map(|c| c.stats()), contracts: chunk.contracts.map(|c| c.stats()), from_addresses: chunk.from_addresses.map(|c| c.stats()), to_addresses: chunk.to_addresses.map(|c| c.stats()), slots: chunk.slots.map(|c| c.stats()), topic0s: chunk.topic0s.map(|c| c.stats()), topic1s: chunk.topic1s.map(|c| c.stats()), topic2s: chunk.topic2s.map(|c| c.stats()), topic3s: chunk.topic3s.map(|c| c.stats()), } }",
        "url": 714
    },
    {
        "code_input": "use postgres::{Client, NoTls};\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    let client = Client::connect(\n        \"host=localhost user=postgres dbname=test sslmode=disable password=secret\",\n        NoTls,\n    )\n    .await?;\n\n    let rows = client\n        .query(\n            \"SELECT * FROM gvn_copy_aggregate.all_copy_move.GVN.diff\",\n            &[]\n        )\n        .await?;\n\n    for row in rows {\n        let (id, name",
        "nl_input": "EMIT_MIR gvn_copy_aggregate.all_copy_move.GVN.diff",
        "gt": "fn all_copy_move(v: AllCopy) -> AllCopy { let a = v.a; let b = v.b; let c = v.c; AllCopy { a, b, c } }",
        "url": 715
    },
    {
        "code_input": "fn matrix_vector_multiplication(matrix: &[[f32; 3]; 3], vector: &[f32; 3]) -> [f32; 3] {\n    let mut result = [0.0; 3];\n    for i in 0..3 {\n        for j in 0..3 {\n            result[i] += matrix[i][j] * vector[j];\n        }\n    }\n    result\n}\n\nfn main() {\n    let matrix = [[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]];\n    let vector = [10.0, 20.0, 30.0];\n    let result = matrix_vector_multiplication(&matrix, &vector);\n    println!(\"{:?}\",",
        "nl_input": "Code for standard non-quantized matrix vector models.",
        "gt": "const fn int_div_up(x: usize, y: usize) -> usize { x / y + if x % y == 0 { 0 } else { 1 } }",
        "url": 716
    },
    {
        "code_input": "use web3::{Client, types::Address, types::HexString};\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Create a new Web3 client\n    let client = Client::new(\"http://localhost:8545\")?;\n\n    // The address of the contract\n    let contract_address = Address::from_str(\"0xe7acab24\")?;\n\n    // The ABI of the contract\n    let abi = r#\"\n        [\n            {\n                \"constant\": true,\n                \"inputs\": [],\n                \"name\": \"fulfillAdvancedOrder\",\n                \"outputs\": [\n                    {\n                        \"name\": \"\",\n                        \"type\": \"uint256\"\n                    }\n                ],",
        "nl_input": "Calls the contract's `fulfillAdvancedOrder` (0xe7acab24) function",
        "gt": "pub fn fulfill_advanced_order( &self, advanced_order: AdvancedOrder, criteria_resolvers: ::std::vec::Vec<CriteriaResolver>, fulfiller_conduit_key: [u8; 32], recipient: ::ethers::core::types::Address, ) -> ::ethers::contract::builders::ContractCall<M, bool> { self.0 .method_hash( [231, 172, 171, 36], ( advanced_order, criteria_resolvers, fulfiller_conduit_key, recipient, ), ) .expect(\"method not found (this should never happen)\") }",
        "url": 717
    },
    {
        "code_input": "use chrono::prelude::*;\nuse uuid::Uuid;\n\n#[derive(Debug, Clone)]\npub struct UniqueSystemId {\n    id: Uuid,\n    created_at: DateTime<Local>,\n}\n\nimpl UniqueSystemId {\n    pub fn new() -> Self {\n        Self {\n            id: Uuid::new_v4(),\n            created_at: Local::now(),\n        }\n    }\n\n    pub fn id(&self) -> &Uuid {\n        &self.id\n    }\n\n    pub fn created_at(&self) -> &DateTime<Local> {\n        &self.created_at\n    }\n}",
        "nl_input": "Returns the [`Time`] when the [`UniqueSystemId`] was created",
        "gt": "pub fn creation_time(&self) -> Time { Time { clock_type: ClockType::default(), seconds: self.seconds as u64, nanoseconds: self.nanoseconds, } }",
        "url": 718
    },
    {
        "code_input": "use ethers::types::Event;\nuse ethers::prelude::*;\n\nfn get_token_deposit_events(provider: &Provider, address: &str) -> Result<Vec<Event>, Box<dyn Error>> {\n    let filter = Event::Filter {\n        from_block: None,\n        to_block: None,\n        address: Some(address),\n        topics: Some(vec![\n            \"0xddf252ad1be2c89b69c2b068fc378a1e893669256c160e61f00a604970f88efa\".parse::<HexString>()?,\n            \"0x000000000000000000000000000",
        "nl_input": "Gets the contract's `TokenDeposit` event",
        "gt": "pub fn token_deposit_filter( &self, ) -> ::ethers::contract::builders::Event< ::std::sync::Arc<M>, M, TokenDepositFilter, > { self.0.event() }",
        "url": 719
    },
    {
        "code_input": "use reqwest::Error;\nuse tokio::time::{sleep, Duration};\nuse tokio::prelude::*;\n\n#[tokio::main]\nasync fn main() -> Result<(), Error> {\n    let url = \"http://example.com\";\n    let timeout = false;\n\n    let response = make_request(url).await;\n\n    match response {\n        Ok(_) => println!(\"Request was successful!\"),\n        Err(e) => {\n            if timeout {\n                println!(\"Request timed out: {}\", e);\n            } else {\n                println!(\"Request failed: {}\", e);\n            }\n        }\n    }\n\n    Ok(())\n}\n\nasync fn make_request(url: &str) -> Result<(), Error> {",
        "nl_input": "Set the boolean flag indicating if the HTTP request should hang until the bundle is either included, or the timeout is reached (default: false)",
        "gt": "pub fn set_await_receipt(&mut self, await_receipt: bool) { self.echo_features .get_or_insert_with(Default::default) .await_receipt = await_receipt; }",
        "url": 720
    },
    {
        "code_input": "#[derive(Debug, Clone, Copy)]\nenum Message {\n    Quit,\n    ChangeColor(i32, i32, i32),\n    ChangeAlpha(f32),\n}\n\nimpl Message {\n    fn parse(s: &str) -> Option<Message> {\n        match s {\n            \"quit\" => Some(Message::Quit),\n            \"change_color\" => Some(Message::ChangeColor(0, 0, 0)),\n            \"change_alpha\" => Some(Message::ChangeAlpha(1.0)),\n            _ => None,\n        }\n    }\n}\n\nfn process_message(message: Message) {\n    match message {\n        Message::Quit => {\n            println!(\"Exiting...\");\n        },\n        Message::ChangeColor(r, g, b) => {\n            println!(\"Changing color to RGB({}, {}, {})\", r, g, b);\n        },\n        Message::ChangeAlpha(a) => {\n            println!(\"Changing alpha to {}\", a);",
        "nl_input": "FIXME(blyxyas): In a future revision, we should also graph #![allow]s, but that is handled with more care",
        "gt": "fn visit_attribute(&mut self, attribute: &'tcx ast::Attribute) { if matches!( Level::from_attr(attribute), Some( Level::Warn | Level::Deny | Level::Forbid | Level::Expect(..) | Level::ForceWarn(..), ) ) { let store = unerased_lint_store(self.tcx.sess); let Some(meta) = attribute.meta() else { return }; let Some(meta_item_list) = meta.meta_item_list() else { return }; for meta_list in meta_item_list { let Some(meta_item) = meta_list.meta_item() else { return }; let ident: &str = &meta_item .path .segments .iter() .map(|segment| segment.ident.as_str()) .collect::<Vec<&str>>() .join(\"::\"); let Ok(lints) = store.find_lints( ident, ) else { return; }; for lint in lints { self.dont_need_to_run.swap_remove(&lint); } } } }",
        "url": 721
    },
    {
        "code_input": "use std::str::FromStr;\n\n#[derive(Debug, PartialEq)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nimpl TryFrom<&str> for Point {\n    type Error = ();\n\n    fn try_from(s: &str) -> Result<Self, Self::Error> {\n        let (x, y) = s\n            .chars()\n            .filter(|c| c == '(' || c == ')')\n            .collect::<Vec<char>>()\n            .split_at(2);\n\n        let x: i32 = x.iter().filter(|c| c.is_digit(10)).collect::<String>().parse().unwrap();\n        let y: i32 = y.iter().",
        "nl_input": "~^ ERROR: consider implementing `TryFrom` instead",
        "gt": "fn from(s: Option<String>) -> Invalid { let s = s.unwrap(); if !s.is_empty() { panic!(\"42\"); } else if s.parse::<u32>().unwrap() != 42 { panic!(\"{:?}\", s); } Invalid }",
        "url": 722
    },
    {
        "code_input": "pub fn should_assert_interrupt(error: u8) -> bool {\n    match error {\n        0...15 => true, // ATA defined IDE errors\n        _ => false, // All other errors\n    }\n}",
        "nl_input": "Returns true if an interrupt should be asserted. Interrupts should be asserted for all ATA defined IDE errors. All other errors are traced with ERROR level and no interrupt is asserted.",
        "gt": "fn log_and_update_error(&mut self, error: IdeError, register: Option<DriveRegister>) { let ide_error = match error { IdeError::IdeBadLocation { .. } | IdeError::ZeroSector | IdeError::LbaBitNotSet => { ErrorReg::ERR_BAD_LOCATION } IdeError::IdeBadSector { .. } => ErrorReg::ERR_BAD_SECTOR, IdeError::Flush { .. } => ErrorReg::ERR_UNKNOWN_COMMAND, }; tracelimit::warn_ratelimited!( path = %self.disk_path, error = error.as_error(), ?register, \"io port failure\" ); self.state.regs.error = ide_error; self.state.error_pending = true; self.state.command = None; self.state.buffer = None; self.state.pending_interrupt = true; }",
        "url": 723
    },
    {
        "code_input": "use web3::{Client, types::Address, types::HexString};\nuse serde_json::Value;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Create a new Web3 client\n    let client = Client::new(\"https://mainnet.infura.io/v3/YOUR_INFURA_KEY\")?;",
        "nl_input": "Calls the contract's `name` (0x06fdde03) function",
        "gt": "pub fn name( &self, ) -> ::ethers::contract::builders::ContractCall<M, ::std::string::String> { self.0 .method_hash([6, 253, 222, 3], ()) .expect(\"method not found (this should never happen)\") }",
        "url": 724
    },
    {
        "code_input": "use std::sync::mpsc;\n\nstruct SubmissionQueue {\n    queue: mpsc::UnboundedReceiver<Submission>,\n}\n\nstruct Submission {\n    // Add fields for your submission here\n}\n\nimpl SubmissionQueue {\n    pub fn new() -> SubmissionQueue {\n        let (tx, rx) = mpsc::unbounded_channel();\n        SubmissionQueue { queue: rx }\n    }\n\n    pub fn submit(&self, submission: Submission) {\n        self.queue.send(submission).unwrap();\n    }\n\n    pub fn drain(&self) {\n        while let Some(submission) = self.queue.recv() {\n            // Handle the submission here\n        }\n    }\n\n    pub fn stop(&self) {\n        self.queue.close();\n    }\n}",
        "nl_input": "Stops all submission queues and drains them of any pending IO. This future may be dropped and reissued.",
        "gt": "pub async fn drain(&mut self) { for sq in &mut self.io_sqs { sq.task.stop().await; if let Some(state) = sq.task.state_mut() { state.drain().await; sq.task.remove(); } } }",
        "url": 725
    },
    {
        "code_input": "pub fn can_begin_literal_maybe_minus(token: &Token) -> bool {\n    match token {\n        Token::Digit(..) | Token::Alphabetic(..) | Token::Special(..) => true,\n        Token::Minus => true,\n        _ => false,\n    }\n}",
        "nl_input": "Keep this in sync with `Token::can_begin_literal_maybe_minus` excluding unary negation.",
        "gt": "pub fn from_token(token: &Token) -> Option<Lit> { match token.uninterpolate().kind { Ident(name, IdentIsRaw::No) if name.is_bool_lit() => Some(Lit::new(Bool, name, None)), Literal(token_lit) => Some(token_lit), Interpolated(ref nt) if let NtExpr(expr) | NtLiteral(expr) = &**nt && let ast::ExprKind::Lit(token_lit) = expr.kind => { Some(token_lit) } _ => None, } }",
        "url": 726
    },
    {
        "code_input": "use std::io::{self, Write};\n\nfn main() {\n    let mut input = String::new();\n    io::stdin().read_line(&mut input).unwrap();\n    let input: Vec<&str> = input.trim().split('\\0').collect();\n    println!(\"{}\", input[0]);\n}",
        "nl_input": "Read an escaped, null-terminated byte string from the input stream.",
        "gt": "pub fn read_escaped_bytes<R: Read>(reader: &mut BytePeeker<R>) -> io::Result<Vec<u8>> { let mut out = vec![]; loop { let byte = reader.read_u8()?; if byte == TERMINATOR_BYTE { if let Some(ESCAPE_BYTE) = reader.peek()? { reader.read_u8()?; out.push(TERMINATOR_BYTE); } else { break; } } else { out.push(byte); } } Ok(out) }",
        "url": 727
    },
    {
        "code_input": "fn get_value<'a>(val: &'a i32) -> &'a i32 {\n    val\n}\n\nfn main() {\n    let x = 5;\n    let y = get_value(&x);\n    println!(\"{}\", y);\n}",
        "nl_input": "... and this version does not work (the lifetime of `one` is supposed to match the lifetime `'a`) ...",
        "gt": "fn foo<'a>(map: RefCell<HashMap<&'static str, &'a [u8]>>) { let one = [1]; assert_eq!(map.borrow().get(\"one\"), Some(&&one[..])); }",
        "url": 728
    },
    {
        "code_input": "use std::collections::HashMap;\n\nfn maps_equal(m1: &HashMap<Option<u32>, Option<u32>>, m2: &HashMap<Option<u32>, Option<u32>>) -> bool {\n    if m1.keys().len() != m2.keys().len() {\n        return false;\n    }\n\n    for (k1, v1) in m1.iter() {\n        let v2 = m2.get(&k1);\n        if v2.is_none() || *v2.unwrap_or(&None) != *v1 {\n            return false;\n        }\n    }\n\n    true\n}",
        "nl_input": "Equality up to trailing `None`s of two maps, i.e. do they represent the same mapping ?",
        "gt": "pub fn equivalent(&self, other: &Self) -> bool { let min_len = self.data.len().min(other.data.len()); self.data[min_len..].iter().all(Option::is_none) && other.data[min_len..].iter().all(Option::is_none) && (self.data[..min_len] == other.data[..min_len]) }",
        "url": 729
    },
    {
        "code_input": "extern crate pandas;\n\nuse pandas::DataFrame;\n\n// Assume we have a struct for a transaction\n#[derive(Debug, Clone, Copy)]\nstruct Transaction {\n    id: u32,\n    amount: f64,\n    // other fields...\n}\n\n// Assume we have a function to convert a transaction to a DataFrame\nfn transaction_to_dataframe(transaction: &Transaction) -> DataFrame {\n    let mut df = DataFrame::new(vec![\n        (\"id\", vec![transaction.id]),\n        (\"",
        "nl_input": "convert transaction-derived data to dataframe",
        "gt": "async fn transform_channel( mut receiver: mpsc::Receiver<R<Self::Response>>, query: &Arc<Query>, ) -> R<Self> { let mut columns = Self::default(); while let Some(message) = receiver.recv().await { match message { Ok(message) => Self::transform(message, &mut columns, query)?, Err(e) => return Err(e), } } Ok(columns) }",
        "url": 730
    },
    {
        "code_input": "fn set_bits(i: usize, j: usize, vec: &mut Vec<u8>) {\n    let mut num = vec[0];\n    for k in i..=j {\n        num = num | (1 << k);\n    }\n    vec[0] = num;\n}",
        "nl_input": "Sets the `i`th to `j`th bits.",
        "gt": "pub fn set_range(&mut self, range: Range<u32>) { let bits = T::FILLED .checked_shl(range.end - range.start) .unwrap_or(T::ZERO) .not() .checked_shl(range.start) .unwrap_or(T::ZERO); self.0 |= bits; }",
        "url": 731
    },
    {
        "code_input": "use web3::{Client, types::Address, types::HexString};\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Create a new client\n    let client = Client::new(\"http://localhost:8545\")?;\n\n    // The address of the contract\n    let contract_address = Address::from_str(\"0x095ea7b3\")?;\n\n    // The ABI of the contract\n    let abi = r#\"\n        [\n            {\n                \"constant\": true,",
        "nl_input": "Calls the contract's `approve` (0x095ea7b3) function",
        "gt": "pub fn approve( &self, to: ::ethers::core::types::Address, token_id: ::ethers::core::types::U256, ) -> ::ethers::contract::builders::ContractCall<M, ()> { self.0 .method_hash([9, 94, 167, 179], (to, token_id)) .expect(\"method not found (this should never happen)\") }",
        "url": 732
    },
    {
        "code_input": "fn main() {\n    println!(\"{}\", add(5, 3));\n}\n\nfn add(a: i32, b: i32) -> i32 {\n    a + b\n}",
        "nl_input": "~ ERROR `#[start]` function is not allowed to be `#[track_caller]`",
        "gt": "fn start(_argc: isize, _argv: *const *const u8) -> isize { panic!(\"{}: oh no\", std::panic::Location::caller()); }",
        "url": 733
    },
    {
        "code_input": "use deno_core::bindings::module_origin;\n\nfn main() {\n    let module_origin = module_origin::get_module_origin();\n    println!(\"{}\", module_origin);\n}",
        "nl_input": "Taken from `deno_core::bindings::module_origin`.",
        "gt": "pub fn module_origin<'a>( s: &mut v8::HandleScope<'a>, resource_name: v8::Local<'a, v8::String>, ) -> v8::ScriptOrigin<'a> { let source_map_url = strings::empty.create(s).unwrap(); v8::ScriptOrigin::new( s, resource_name.into(), 0, 0, false, 0, source_map_url.into(), true, false, true, ) }",
        "url": 734
    },
    {
        "code_input": "fn main() {\n    let mut x = 5;\n    let y = &mut x;\n    *y = 10;\n    println!(\"{}\", x);\n}",
        "nl_input": "~^ ERROR cannot borrow value as mutable more than once at a time",
        "gt": "fn f3( ref mut a @ [ [ref b @ .., _], [_, ref mut mid @ ..], .., [..], ] : [[U; 4]; 5] ) {}",
        "url": 735
    },
    {
        "code_input": "extern crate ndarray;\n\nuse ndarray::Array;\nuse ndarray::prelude::*;\n\nfn main() {\n    // Create a 2D tensor with 3 rows and 4 columns\n    let mut tensor: Array<f32, Dense<'static, RowMajor>> = Array::zeros((3, 4));\n\n    // Fill the tensor with some values\n    for i in 0..3 {\n        for j in 0..4 {\n            tensor.set(i, j, (i + j) as f32);\n        }\n    }\n\n    // Reduce the tensor by taking the mean along the 0th axis\n    let mean = tensor.mean(0);\n\n    println!(\"{:?}\", mean);\n}",
        "nl_input": "Reduce a dimension of the tensor by taking the mean of all elements along that axis.",
        "gt": "pub fn mean_reduce(self, axes: impl ToAxes) -> GraphTensor { let reduced_elements = axes .to_axes() .into_iter() .map(|i| self.dims()[i]) .product::<Expression>(); (self / reduced_elements).sum_reduce(axes) }",
        "url": 736
    },
    {
        "code_input": "I'm sorry, but your request is not clear. Could you please provide more details or context? Are you asking for a Rust code snippet that uses generic parameters from an outer item? If so, I'll need more information to provide a useful response.\n",
        "nl_input": "@ error-pattern:can't use generic parameters from outer item",
        "gt": "fn hd<U>(v: Vec<U> ) -> U { fn hd1(w: [U]) -> U { return w[0]; } return hd1(v); }",
        "url": 737
    },
    {
        "code_input": "use std::thread;\nuse std::time::Duration;\n\nfn main() {\n    let mut id = 0;\n    let mut thread_id = 0;\n\n    loop {\n        let mut new_thread = thread::spawn(move || {\n            id += 1;\n            thread_id = id;\n            println!(\"Thread {} started\", thread_id);\n\n            // Simulate work\n            thread::sleep(Duration::from_secs(1));\n\n            println!(\"Thread {} finished\", thread_id);\n        });\n\n        new_thread.join().unwrap();\n\n        // If there's a thread with a lower ID, we've found our target\n        if id % 2 == 0 {\n            break;\n        }\n    }\n}",
        "nl_input": "When a thread yields, Miri's scheduler used to pick the thread with the lowest ID that can run. IDs are assigned in thread creation order. This means we could make 2 threads infinitely ping-pong with each other while really there is a 3rd thread that we should schedule to make progress.",
        "gt": "fn two_player_ping_pong() { static FLAG: AtomicUsize = AtomicUsize::new(0); let waiter1 = thread::spawn(|| { while FLAG.load(Ordering::Acquire) == 0 { thread::yield_now(); } }); let waiter2 = thread::spawn(|| { while FLAG.load(Ordering::Acquire) == 0 { thread::yield_now(); } }); let progress = thread::spawn(|| { FLAG.store(1, Ordering::Release); }); waiter1.join().unwrap(); waiter2.join().unwrap(); progress.join().unwrap(); }",
        "url": 738
    },
    {
        "code_input": "use std::process;\nuse std::str;\n\npub fn kill_docker_container(name: &str, signal: DockerSignal) {\n    let mut args = vec![\n        \"docker\", \"kill\", name,\n    ];\n\n    match signal {\n        DockerSignal::SIGTERM => args.push(\"-sigterm\"),\n        DockerSignal::SIGKILL => args.push(\"-sigkill\"),\n    }\n\n    let output = process::Command::new(&args)\n        .output()\n        .expect(\"Failed to execute Docker command\");\n\n    if !output.status.success() {\n        eprintln!(\"Failed to kill Docker container: {}\", str::from_utf",
        "nl_input": "Kill the docker container. # Arguments * `name` - A container name. * `signal` - A enum value representing the signal type.",
        "gt": "pub fn kill_container(name: &str, signal: KillportSignal) -> Result<(), Error> { let rt = Runtime::new()?; rt.block_on(async { let docker = Docker::connect_with_socket_defaults() .map_err(|e| Error::new(std::io::ErrorKind::Other, e.to_string()))?; let options = KillContainerOptions { signal: signal.to_string(), }; docker .kill_container(name, Some(options)) .await .map_err(|e| Error::new(std::io::ErrorKind::Other, e.to_string())) }) }",
        "url": 739
    },
    {
        "code_input": "fn const_generic_param<T>(_t: T) {\n    // Your code here\n}\n\nfn main() {\n    const_generic_param(5);\n}",
        "nl_input": "[min]~^ ERROR `&'static ()` is forbidden as the type of a const generic parameter [adt_const_params]~^^ ERROR `&'static ()` can't be used as a const parameter type",
        "gt": "fn main() { const A: &'static () = unsafe { std::mem::transmute(10 as *const ()) }; let _ = Const::<{ A }>; }",
        "url": 740
    },
    {
        "code_input": "use std::num::ParseIntError;\n\nfn canonicalize_and_run_query(query: &str) -> Result<i32, ParseIntError> {\n    // This is a placeholder for your actual query.\n    // We're just returning a hardcoded result for the sake of this example.\n    Ok(query.len())\n}\n\nfn main() {\n    match canonicalize_and_run_query(\"Hello, world!\") {\n        Ok(result) => println!(\"Query result: {}\", result),\n        Err(error) => println!(\"Error running query: {}\", error),\n    }\n}",
        "nl_input": "Helper function that canonicalizes and runs the query. If an overflow results, we re-run it in the local context so we can report a nice error.",
        "gt": "fn evaluate_obligation_no_overflow( &self, obligation: &PredicateObligation<'tcx>, ) -> EvaluationResult { match self.evaluate_obligation(obligation) { Ok(result) => result, Err(OverflowError::Canonical) => { let mut selcx = SelectionContext::new(self); selcx.evaluate_root_obligation(obligation).unwrap_or_else(|r| match r { OverflowError::Canonical => { span_bug!( obligation.cause.span, \"Overflow should be caught earlier in standard query mode: {:?}, {:?}\", obligation, r, ) } OverflowError::Error(_) => EvaluationResult::EvaluatedToErr, }) } Err(OverflowError::Error(_)) => EvaluationResult::EvaluatedToErr, } }",
        "url": 741
    },
    {
        "code_input": "fn bitwise_and(eax: u32, ecx: u32) -> u32 {\n    eax & ecx\n}",
        "nl_input": "Returns the result value to return for inputs `eax` and `ecx`. `default` provides the base value which is used for a missing leaf or for any bits of the result whose mask bits are clear.",
        "gt": "pub fn result(&self, eax: u32, ecx: u32, default: &[u32; 4]) -> [u32; 4] { let mut result = *default; if let Some(x) = self.leaves.iter().find(|x| x.matches(eax, ecx)) { x.apply(&mut result); } result }",
        "url": 742
    },
    {
        "code_input": "pub fn create_assistant_prompt(request_message: &str) -> String {\n    format!(\"Assistant: {}\", request_message)\n}",
        "nl_input": "Create an assistant prompt from a chat completion request message.",
        "gt": "fn append_assistant_message( &self, chat_history: impl AsRef<str>, message: &ChatCompletionAssistantMessage, ) -> Result<String> { let content = match message.content() { Some(content) => content.to_string(), None => match message.tool_calls().is_some() { true => String::new(), false => return Err(PromptError::NoAssistantMessage), }, }; Ok(format!( \"{chat_history} <|start_header_id|>assistant<|end_header_id|>\\n\\n{assistant_message}<|eot_id|>\", chat_history = chat_history.as_ref().trim(), assistant_message = content.trim(), )) }",
        "url": 743
    },
    {
        "code_input": "pub fn map_syntax_elements<F>(elements: &Vec<SyntaxElement>, map_func: F) -> Vec<SyntaxElement>\nwhere\n    F: Fn(SyntaxElement) -> SyntaxElement,\n{\n    elements.iter().map(map_func).collect()\n}",
        "nl_input": "Like [`SyntaxMapping::upmap_child`] but for syntax elements.",
        "gt": "pub fn upmap_child_element( &self, child: &SyntaxElement, input_ancestor: &SyntaxNode, output_ancestor: &SyntaxNode, ) -> Result<SyntaxElement, MissingMapping> { match child { SyntaxElement::Node(node) => { self.upmap_child(node, input_ancestor, output_ancestor).map(SyntaxElement::Node) } SyntaxElement::Token(token) => { let upmap_parent = self.upmap_child(&token.parent().unwrap(), input_ancestor, output_ancestor)?; let element = upmap_parent.children_with_tokens().nth(token.index()).unwrap(); debug_assert!( element.as_token().is_some_and(|it| it.kind() == token.kind()), \"token upmapping mapped to the wrong node ({token:?} -> {element:?})\" ); Ok(element) } } }",
        "url": 744
    },
    {
        "code_input": "fn process_string(s: &str) -> Result<Vec<char>, &'static str> {\n    if s.chars().next().map_err(|_| \"Empty string\")? == '\\r' {\n        Err(\"Raw string does not support explicit character escapes\")\n    } else {\n        Ok(s.chars().collect())\n    }\n}",
        "nl_input": "Takes a contents of a string literal (without quotes) and produces a sequence of characters or errors. NOTE: Raw strings do not perform any explicit character escaping, here we only produce errors on bare CR.",
        "gt": "fn check_raw_common<F>(src: &str, mode: Mode, callback: &mut F) where F: FnMut(Range<usize>, Result<char, EscapeError>), { let mut chars = src.chars(); let allow_unicode_chars = mode.allow_unicode_chars(); while let Some(c) = chars.next() { let start = src.len() - chars.as_str().len() - c.len_utf8(); let res = match c { '\\r' => Err(EscapeError::BareCarriageReturnInRawString), _ => ascii_check(c, allow_unicode_chars), }; let end = src.len() - chars.as_str().len(); callback(start..end, res); } }",
        "url": 745
    },
    {
        "code_input": "use rusoto_core::Region;\nuse rusoto_dynamodb::{DynamoDb, DynamoDbClient, CreateTableInput, CreateTableOutput, AttributeDefinition, KeySchemaElement, ProvisionedThroughput};\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Create a DynamoDB client\n    let client = DynamoDbClient::new(Region::UsEast1);\n\n    // Define the table properties\n    let table_name = \"my_table\";",
        "nl_input": "Creates a new [`OwnedTable`].",
        "gt": "pub fn try_from_iter<T: IntoIterator<Item = (Identifier, OwnedColumn<S>)>>( iter: T, ) -> Result<Self, OwnedTableError> { Self::try_new(IndexMap::from_iter(iter)) }",
        "url": 746
    },
    {
        "code_input": "fn main() {\n    let x: i32; // This is a declaration, but no initialization\n    x = 5; // This is an assignment, but `x` hasn't been initialized, so it's undefined behavior\n}",
        "nl_input": "~^ ERROR assigning to `&T` is undefined behavior",
        "gt": "unsafe fn generic_assign_to_ref<T>(this: &T, a: T) { *(this as *const _ as *mut _) = a; }",
        "url": 747
    },
    {
        "code_input": "use termion::{Color, OutputColor, OutputStream, Style, Terminal, Writer};\n\nfn main() {\n    let mut terminal = Terminal::new().unwrap();\n\n    // Set the color of the output\n    terminal.set_color(OutputColor::Color(Color::Rgb(255, 0, 0)));\n\n    // Set the style of the output\n    terminal.set_style(Style::Bold);\n\n    // Create a new writer\n    let writer = Writer::new(&terminal.output().unwrap());\n\n    // Write a line of output\n    writer.println(\"Hello, world!\").unwrap();\n}",
        "nl_input": "Create a new OutputWriter instance based on the caller's preference for colorized output and the capabilities of the terminal.",
        "gt": "pub(crate) fn new(color: Color) -> Self { if let Some(t) = term::stdout() { if color.use_colored_tty() && t.supports_color() { return OutputWriter { terminal: Some(t) }; } } OutputWriter { terminal: None } }",
        "url": 748
    },
    {
        "code_input": "use std::env;\nuse std::process;\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n\n    if args.len() < 2 {\n        println!(\"Usage: {} <attribute>\", args[0]);\n        process::exit(1);\n    }\n\n    let attribute_name = args[1].clone();\n\n    if attribute_name == \"#[inline]\" || attribute_name == \"#[rustfmt::skip]\" {\n        println!(\"{}\", attribute_name);\n    } else {\n        println!(\"Attribute not found\");\n    }\n}",
        "nl_input": "Return attributes with the given attribute name. Single segmented name like `#[inline]` is specified as `&[\"inline\".to_string()]`. Multi-segmented name like `#[rustfmt::skip]` is specified as `&[\"rustfmt\".to_string(), \"skip\".to_string()]`.",
        "gt": "fn attrs_by_path(&self, attr: &[Symbol]) -> Vec<Attribute> { let def_id = self.def_id(); with(|cx| cx.get_attrs_by_path(def_id, attr)) }",
        "url": 749
    },
    {
        "code_input": "fn drop_returned_value() {\n    let _ = drop(fn_with_side_effect_and_returning_some_value());\n}",
        "nl_input": "dropping returned value of a function like in the following snippet is considered idiomatic, see #9482 for examples match <var> { <pat> => drop(fn_with_side_effect_and_returning_some_value()), .. }",
        "gt": "fn is_single_call_in_arm<'tcx>(cx: &LateContext<'tcx>, arg: &'tcx Expr<'_>, drop_expr: &'tcx Expr<'_>) -> bool { if matches!(arg.kind, ExprKind::Call(..) | ExprKind::MethodCall(..)) { if let Node::Arm(Arm { body, .. }) = cx.tcx.parent_hir_node(drop_expr.hir_id) { return body.hir_id == drop_expr.hir_id; } } false }",
        "url": 750
    },
    {
        "code_input": "use std::fmt::Write;\n\nfn format_string(format_string: &str, data: &(i32, f32, &str)) -> String {\n    let mut output = String::new();\n    Write::write(&format_string, data).unwrap();\n    output\n}\n\nfn main() {\n    let format_string = \"The number is {} and the float is {}\";\n    let data = (10, 3.14, \"test\");\n    let result = format_string(format_string, data);\n    println!(\"{}\", result);\n}",
        "nl_input": "Formats the given string based on the formatting arguments and data provided",
        "gt": "pub fn format(&self, args: &[&dyn fmt::Display]) -> String { let mut s = String::new(); for arg in args { s.push_str(&format!(\"{arg} \")); } s.trim_end().to_owned() }",
        "url": 751
    },
    {
        "code_input": "use std::io::{self, Write};\n\nfn main() {\n    // Fetch the destination register\n    let mut dest_reg = String::new();\n    print!(\"Enter the destination register: \");\n    io::stdout().flush().unwrap();\n    io::stdin().read_line(&mut dest_reg).unwrap();\n\n    // Fetch the input operand\n    let mut input_operand = String::new();\n    print!(\"Enter the input operand: \");\n    io::stdout().flush().unwrap();\n    io::stdin().read_line(&mut input_operand).unwrap();\n\n    // Print the results\n    println!(\"Destination register: {}\", dest_reg);\n    println!(\"Input operand: {}\", input_operand);\n}",
        "nl_input": "Fetch the destination register and input operand values for an ALU instruction.",
        "gt": "fn alu_rr(&mut self, instruction: &Instruction) -> (Register, u32, u32) { if !instruction.imm_c { let (rd, rs1, rs2) = instruction.r_type(); let c = self.rr(rs2, MemoryAccessPosition::C); let b = self.rr(rs1, MemoryAccessPosition::B); (rd, b, c) } else if !instruction.imm_b && instruction.imm_c { let (rd, rs1, imm) = instruction.i_type(); let (rd, b, c) = (rd, self.rr(rs1, MemoryAccessPosition::B), imm); (rd, b, c) } else { assert!(instruction.imm_b && instruction.imm_c); let (rd, b, c) = (Register::from_u32(instruction.op_a), instruction.op_b, instruction.op_c); (rd, b, c) } }",
        "url": 752
    },
    {
        "code_input": "pub fn park_car(self) -> bool {\n    if self.state == PARKED {\n        self.state = UNPARKED;\n        true\n    } else {\n        false\n    }\n}",
        "nl_input": "Assumes this is only called by the thread that owns the Parker, which means that `self.state != PARKED`. This implementation doesn't require `Pin`, but other implementations do.",
        "gt": "pub unsafe fn park_timeout(self: Pin<&Self>, timeout: Duration) { if self.state.fetch_sub(1, Acquire) == NOTIFIED { return; } futex_wait(&self.state, PARKED, Some(timeout)); if self.state.swap(EMPTY, Acquire) == NOTIFIED { } else { } }",
        "url": 753
    },
    {
        "code_input": "pub fn get_type<T>(x: &T) -> T {\n    *x\n}",
        "nl_input": "For the overloaded place expressions (`*x`, `x[3]`), the trait returns a type of `&T`, but the actual type we assign to the *expression* is `T`. So this function just peels off the return type by one layer to yield `T`.",
        "gt": "pub(crate) fn make_overloaded_place_return_type(&self, method: MethodCallee<'tcx>) -> Ty<'tcx> { let ret_ty = method.sig.output(); ret_ty.builtin_deref(true).unwrap() }",
        "url": 754
    },
    {
        "code_input": "use reqwest::Error;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Serialize, Deserialize, Debug)]\nstruct User {\n    id: i32,\n    name: String,\n    email: String,\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), Error> {\n    let response = reqwest::get(\"https://jsonplaceholder.typicode.com/users/1\")\n        .await?\n        .json()\n        .await?;\n\n    let user: User = response.into();\n\n    println!(\"{:?}\", user);\n\n    Ok(())\n}",
        "nl_input": "@ no-prefer-dynamic @ compile-flags:-g",
        "gt": "pub fn generic_function<T: Clone>(val: T) -> (T, T) { let result = (val.clone(), val.clone()); let a_variable: u32 = 123456789; let another_variable: f64 = 123456789.5; zzz(); result }",
        "url": 755
    },
    {
        "code_input": "use std::slice::Iter;\n\nfn size_prefixed_root_as_function_call_unchecked(buf: &[u8]) -> Option<usize> {\n    let mut iter = buf.iter();\n    let mut size_started = false;\n    let mut size_index = 0;\n    let mut function_call_index: Option<usize> = None;\n\n    for (i, byte) in buf.iter().enumerate() {\n        if *byte == 0x66 && !size_started {\n            size_index = i;\n            size_started = true;\n        } else if *byte == 0x00 && size_started {\n            function_call_index = Some(size_index);\n            break;\n        }",
        "nl_input": "Verifies that a buffer of bytes contains a size prefixed `FunctionCall` and returns it. Note that verification is still experimental and may not catch every error, or be maximally performant. For the previous, unchecked, behavior use `size_prefixed_root_as_function_call_unchecked`.",
        "gt": "pub fn size_prefixed_root_as_function_call( buf: &[u8], ) -> Result<FunctionCall, flatbuffers::InvalidFlatbuffer> { flatbuffers::size_prefixed_root::<FunctionCall>(buf) }",
        "url": 756
    },
    {
        "code_input": "use web3::{Client, types::Address, types::Hex};\nuse serde_json::Value;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Create a new client\n    let client = Client::new(\"http://localhost:8545\")?;\n\n    // The address of the contract\n    let contract_address = Address::from_str(\"0xfc0c",
        "nl_input": "Calls the contract's `token` (0xfc0c546a) function",
        "gt": "pub fn token( &self, ) -> ::ethers::contract::builders::ContractCall< M, ::ethers::core::types::Address, > { self.0 .method_hash([252, 12, 84, 106], ()) .expect(\"method not found (this should never happen)\") }",
        "url": 757
    },
    {
        "code_input": "pub fn check(foo10: u32, type1: u32, type2: u32, type3: u32, type4: u32) -> Result<(), &'static str> {\n    if foo10 > 5 {\n        return Err(\"Foo10 is greater than 5\");\n    }\n    if type1 > 10 {\n        return Err(\"Type1 is greater than 10\");\n    }\n    if type2 > 10 {\n        return Err(\"Type2 is greater than 10\");\n    }\n    if type3 > 10 {\n        return Err(\"Type3 is greater than 10\");\n    }\n    if type4 > 10 {\n        return Err(\"Type4 is greater than 10\");\n    }\n    Ok(())\n}",
        "nl_input": "CHECK: define{{.*}}5foo10{{.*}}!type ![[TYPE10:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}",
        "gt": "pub fn foo11(_: &dyn FnOnce(i32) -> i32, _: &dyn FnOnce(i32) -> i32) {}",
        "url": 758
    },
    {
        "code_input": "use std::fs;\n\nfn main() {\n    let file_path = \"child.txt\";\n\n    if !fs::exists(file_path) {\n        fs::create_file(file_path).unwrap();\n    }\n}",
        "nl_input": "Walk to a child, and make sure it exists.",
        "gt": "fn walk(&self, name: &lx::LxStr) -> lx::Result<Qid> { let mut state = self.state.write(); state.path.push_lx(name)?; state.validate_exists()?; Ok(state.qid) }",
        "url": 759
    },
    {
        "code_input": "fn flatten<T>(option: Option<T>) -> impl Iterator<Item = T> {\n    match option {\n        Some(value) => vec![value].into_iter(),\n        None => vec![].into_iter(),\n    }\n}",
        "nl_input": "Turns option of iterator into an iterator (this is just flatten)",
        "gt": "fn maybe_iter<I: Iterator>(i: Option<I>) -> impl Iterator<Item = I::Item> { i.into_iter().flatten() }",
        "url": 760
    },
    {
        "code_input": "use asm::int::{outb, INTERRUPT_OFFSET, INTERRUPT_ENABLE_MASK};\n\nfn send_nmi() {\n    // Send the NMI to the other processor\n    outb(0x64, INTERRUPT_OFFSET);\n\n    // Enable the NMI interrupt\n    outb(INTERRUPT_ENABLE_MASK, INTERRUPT_OFFSET);\n}",
        "nl_input": "Not used just yet, but allows triggering an NMI to another processor.",
        "gt": "pub fn ipi_nmi(&self, apic_id: u32) { let shift = { 56 }; self.set_icr((u64::from(apic_id) << shift) | (1 << 14) | (0b100 << 8)); }",
        "url": 761
    },
    {
        "code_input": "pub struct Place {\n    tracked: bool,\n    flooded: bool,\n}\n\nimpl Place {\n    pub fn new() -> Place {\n        Place { tracked: false, flooded: false }\n    }\n\n    pub fn track(&mut self) {\n        if !self.flooded {\n            self.tracked = true;\n        }\n    }\n\n    pub fn is_tracked(&self) -> bool {\n        self.tracked\n    }\n\n    pub fn is_flooded(&self) -> bool {\n        self.flooded\n    }\n\n    pub fn set_flooded(&mut self) {\n        self.flooded = true;\n    }\n}",
        "nl_input": "Low-level method that assigns to a place. This does nothing if the place is not tracked. The target place must have been flooded before calling this method.",
        "gt": "fn insert_idx(&mut self, target: PlaceIndex, result: ValueOrPlace<V>, map: &Map<'_>) { match result { ValueOrPlace::Value(value) => self.insert_value_idx(target, value, map), ValueOrPlace::Place(source) => self.insert_place_idx(target, source, map), } }",
        "url": 762
    },
    {
        "code_input": "Sure, I can help you with that. However, I'll need more specific details about the NatVis debugger and the crates you're interested in. \n\nFor example, I need to know:\n\n1. What is the NatVis debugger?\n2. What are the crates you're interested in?\n3. What is the structure of the output you want?\n\nOnce I have these details, I can provide a more accurate code snippet.\n",
        "nl_input": "Write the NatVis debugger visualizer files for each crate to the temp directory and gather the file paths.",
        "gt": "fn collect_natvis_visualizers( tmpdir: &Path, sess: &Session, crate_name: &Symbol, natvis_debugger_visualizers: &BTreeSet<DebuggerVisualizerFile>, ) -> Vec<PathBuf> { let mut visualizer_paths = Vec::with_capacity(natvis_debugger_visualizers.len()); for (index, visualizer) in natvis_debugger_visualizers.iter().enumerate() { let visualizer_out_file = tmpdir.join(format!(\"{}-{}.natvis\", crate_name.as_str(), index)); match fs::write(&visualizer_out_file, &visualizer.src) { Ok(()) => { visualizer_paths.push(visualizer_out_file); } Err(error) => { sess.dcx().emit_warn(errors::UnableToWriteDebuggerVisualizer { path: visualizer_out_file, error, }); } }; } visualizer_paths }",
        "url": 763
    },
    {
        "code_input": "use web3::{Client, types::Address};\nuse std::error::Error;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn Error>> {\n    let client = Client::new()?;\n\n    let contract_address = Address::new(\"0x6e9bfd9f\");\n\n    let result = client.contract::<&str>()?\n        .method(\"getConduit\")\n        .call_once()\n        .await?;\n\n    println!(\"{:#?}\", result);\n\n    Ok(())\n}",
        "nl_input": "Calls the contract's `getConduit` (0x6e9bfd9f) function",
        "gt": "pub fn get_conduit( &self, conduit_key: [u8; 32], ) -> ::ethers::contract::builders::ContractCall< M, (::ethers::core::types::Address, bool), > { self.0 .method_hash([110, 155, 253, 159], conduit_key) .expect(\"method not found (this should never happen)\") }",
        "url": 764
    },
    {
        "code_input": "fn foo<'a, T>(s: &'a T) -> &'a T: 'static {\n    s\n}",
        "nl_input": "S<&'a T> is in the return type, so we get an implied bound &'a T: 'static",
        "gt": "fn foo<'a, T>(x: &'a T) -> (S<&'a T>, Box<dyn Any + 'static>) { let y = S(x); let z = Box::new(y.clone()) as Box<dyn Any + 'static>; (y, z) }",
        "url": 765
    },
    {
        "code_input": "I'm sorry, but your request is not clear. Could you please provide more details or context about the query you're referring to? It would be helpful if you could specify the programming language you're using and the specific task you're trying to accomplish.\n",
        "nl_input": "Call this on things you got out of the MIR (so it is as generic as the provided stack frame), to bring it into the proper environment for this interpreter.",
        "gt": "pub(super) fn instantiate_from_frame_and_normalize_erasing_regions< T: TypeFoldable<TyCtxt<'tcx>>, >( &self, frame: &Frame<'tcx, M::Provenance, M::FrameExtra>, value: T, ) -> Result<T, ErrorHandled> { frame .instance .try_instantiate_mir_and_normalize_erasing_regions( *self.tcx, self.typing_env, ty::EarlyBinder::bind(value), ) .map_err(|_| ErrorHandled::TooGeneric(self.cur_span())) }",
        "url": 766
    },
    {
        "code_input": "fn interpret_target_result(target_result: &str) -> (String, String) {\n    let mut target = String::new();\n    let mut result = String::new();\n\n    for c in target_result.chars() {\n        if c == '=' {\n            continue;\n        }\n        if c.is_numeric() {\n            result.push(c);\n        } else {\n            target.push(c);\n        }\n    }\n\n    (target, result)\n}",
        "nl_input": "Helper method to interpret `target = result`.",
        "gt": "pub fn assign(&mut self, target: PlaceRef<'_>, result: ValueOrPlace<V>, map: &Map<'_>) where V: HasTop, { self.flood(target, map); if let Some(target) = map.find(target) { self.insert_idx(target, result, map); } }",
        "url": 767
    },
    {
        "code_input": "pub fn find_bin(layout: &str) -> &'static str {\n    match layout {\n        \"low\" => \"low bin\",\n        \"medium\" => \"medium bin\",\n        \"high\" => \"high bin\",\n        _ => \"unknown bin\",\n    }\n}",
        "nl_input": "Pretends to be expensive finding a suitable bin for the layout.",
        "gt": "fn find_bin(&self, layout: Layout) -> Option<&MyBin> { if layout == Layout::new::<usize>() { Some(&self.bins[0]) } else { None } }",
        "url": 768
    },
    {
        "code_input": "use std::fs;\nuse std::path::Path;\n\nfn is_dylib(path: &Path) -> bool {\n    let metadata = fs::metadata(path).unwrap();\n    let filename = metadata.file_name().unwrap();\n    filename.to_str().unwrap().ends_with(\".dylib\")\n}\n\nfn main() {\n    let path = Path::new(\"path_to_your_file\");\n    println!(\"{}\", is_dylib(&path));\n}",
        "nl_input": "FIXME: Find a better way to know if it is a dylib.",
        "gt": "fn is_dylib(path: &Utf8Path) -> bool { match path.extension().map(|e| e.to_owned().to_lowercase()) { None => false, Some(ext) => matches!(ext.as_str(), \"dll\" | \"dylib\" | \"so\"), } }",
        "url": 769
    },
    {
        "code_input": "fn main() {\n    let vec = vec![1, 2, 3, 4, 5];\n    let index = 2;\n    let len = vec.len();\n\n    if index >= len {\n        println!(\"Index out of bounds: the len is {} but the index is {}\", len, index);\n    } else {\n        println!(\"The value at index {} is {}\", index, vec[index]);\n    }\n}",
        "nl_input": "@ run-fail @ error-pattern:index out of bounds: the len is 1 but the index is 2 @ ignore-emscripten no processes",
        "gt": "fn main() { let v: Vec<isize> = vec![10]; let x: usize = 0; assert_eq!(v[x], 10); assert_eq!(v[x + 2], 20); }",
        "url": 770
    },
    {
        "code_input": "#[miri_run]\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    let newtype = m::newtype(\n        \"Newtype\",\n        m::field(\"field\", m::Scalar(m::Int)),\n    )?;\n\n    let newtype_with_no_retag = newtype.clone_with_retag_fields(|fields| {\n        fields.clone_with_retag_fields(|field| {\n            if field.name == \"field\" {\n                Some(field.clone_with_retag_fields(|field| {\n                    if field.name == \"field\" {\n                        Some(field.clone_with_retag_fields(|field| {\n                            if field.name == \"field\" {\n                                Some(field.clone_with_retag_fields(|field| {\n                                    if field.name == \"field\" {\n                                        Some(field.clone_with_retag_fields(|field| {\n                                            if field.",
        "nl_input": "Make sure that with -Zmiri-retag-fields=scalar, we do *not* retag the fields of `Newtype`.",
        "gt": "fn main() { let ptr = Box::into_raw(Box::new(0i32)); #[rustfmt::skip] unsafe { dealloc_while_running( Newtype(&mut *ptr, 0, 0), || drop(Box::from_raw(ptr)), ) }; }",
        "url": 771
    },
    {
        "code_input": "use std::collections::VecDeque;\n\n#[derive(Default)]\nstruct FixedSizeIndexQueue<T> {\n    queue: VecDeque<T>,\n    max_size: usize,\n}\n\nimpl<T> FixedSizeIndexQueue<T> {\n    pub fn new(max_size: usize) -> Self {\n        Self { max_size, queue: VecDeque::new() }\n    }\n\n    pub fn push(&mut self, item: T) {\n        if self.queue.len() == self.max_size {\n            self.queue.pop_front();\n        }\n        self.queue.push_back(item);\n    }\n\n    pub fn pop(&mut self) -> Option<T> {\n        self.queue.pop_front()\n    }\n\n    pub fn peek(&self) -> Option<&T> {\n        self.queue.front()\n    }\n\n    pub fn is_full(&self) -> bool {\n        self.queue.len() == self.max",
        "nl_input": "Creates a new empty [`FixedSizeIndexQueue`].",
        "gt": "pub fn new() -> Self { let mut new_self = Self { state: unsafe { RelocatableIndexQueue::new_uninit(CAPACITY) }, data: core::array::from_fn(|_| UnsafeCell::new(0)), }; let allocator = BumpAllocator::new(core::ptr::addr_of!(new_self.data) as usize); unsafe { new_self .state .init(&allocator) .expect(\"All required memory is preallocated.\") }; new_self }",
        "url": 772
    },
    {
        "code_input": "pub fn get_column_name(self, alias: &str) -> Result<String, &'static str> {\n    if let Some(column_name) = self.column_mapping.get(alias) {\n        Ok(column_name.clone())\n    } else {\n        Err(\"Alias not found in column mapping\")\n    }\n}",
        "nl_input": "# Panics Will panic if: - `self.column_mapping.get(alias)` returns `None`, which can occur if the alias is not found in the column mapping.",
        "gt": "pub fn add_result_columns(mut self, columns: &[EnrichedExpr]) -> Self { let mut has_nonprovable_column = false; for enriched_expr in columns { if let Some(plan) = &enriched_expr.dyn_proof_expr { self.filter_result_expr_list.push(AliasedDynProofExpr { expr: plan.clone(), alias: enriched_expr.residue_expression.alias, }); } else { has_nonprovable_column = true; } } if has_nonprovable_column { for alias in self.column_mapping.keys().sorted() { let column_ref = self.column_mapping.get(alias).unwrap(); self.filter_result_expr_list.push(AliasedDynProofExpr { expr: DynProofExpr::new_column(*column_ref), alias: *alias, }); } } self }",
        "url": 773
    },
    {
        "code_input": "use std::thread;\n\nfn main() {\n    let handle = thread::current_thread();\n    println!(\"{}\", handle);\n}",
        "nl_input": "Gets a handle to the thread that invokes it, if the handle has been initialized.",
        "gt": "pub(crate) fn try_current() -> Option<Thread> { let current = CURRENT.get(); if current > DESTROYED { unsafe { let current = ManuallyDrop::new(Thread::from_raw(current)); Some((*current).clone()) } } else { None } }",
        "url": 774
    },
    {
        "code_input": "use cid::Cid;\n\nfn set_length(cid: &mut Cid, length: usize) {\n    let mut bytes = cid.to_vec();\n    bytes.truncate(length);\n    cid.set_bytes(bytes);\n}\n\nfn main() {\n    let mut cid = Cid::new_v1(0);\n    set_length(&mut cid, 10);\n}",
        "nl_input": "Set the length of source cid. Applicable to Endpoint only.",
        "gt": "pub fn set_cid_len(&mut self, v: usize) { self.cid_len = cmp::min(v, MAX_CID_LEN); }",
        "url": 775
    },
    {
        "code_input": "fn get_def_id(res: &Res) -> Option<DefId> {\n    match res.id {\n        Some(id) => Some(id),\n        None => None,\n    }\n}",
        "nl_input": "Return `Some(..)` with the `DefId` of this `Res` if it has a ID, else `None`.",
        "gt": "pub fn opt_def_id(&self) -> Option<DefId> { match *self { Res::Def(_, id) => Some(id), Res::Local(..) | Res::PrimTy(..) | Res::SelfTyParam { .. } | Res::SelfTyAlias { .. } | Res::SelfCtor(..) | Res::ToolMod | Res::NonMacroAttr(..) | Res::Err => None, } }",
        "url": 776
    },
    {
        "code_input": "fn main() {\n    let a = 5;\n    let result = a;\n    println!(\"{}\", result);\n}",
        "nl_input": "~^ ERROR: 8 bindings with single-character names in scope",
        "gt": "fn bindings2() { let (a, b, c, d, e, f, g, h): (bool, bool, bool, bool, bool, bool, bool, bool) = unimplemented!(); }",
        "url": 777
    },
    {
        "code_input": "use rayon::prelude::*;\n\nfn par_iter_mut(d: &mut Vec<i32>, n: usize) {\n    for i in 0..n {\n        *d.get_mut(i) = i as i32;\n    }\n}\n\nfn main() {\n    let mut x = vec![0; 10];\n    let mut xout = vec![0; 10];\n\n    // Run the function in parallel\n    x.par_iter_mut(|d, n| {\n        par_iter_mut(d, n)\n    });\n\n    // Print the result\n    println!(\"{:?}\", xout);\n}",
        "nl_input": "W (d,n) @ x (n,) -> xout (d,) by far the most amount of time is spent inside this little function Rust note: par_iter_mut is from the RAYON library. It run in parallel. Rust note: x is passed by reference, xout as mutiple reference.",
        "gt": "pub fn matvec<const B: usize>(self: &Self, xout: &mut [[f32; OUT]; B], x: &[[f32; IN]; B]) { for (xout, x) in xout.iter_mut().zip(x) { xout.par_iter_mut().enumerate().for_each(|(i, v)| { *v = self.w[i] .iter() .zip(x.iter()) .fold(0.0, |acc, (&_w, &_x)| acc + _w * _x); }); } }",
        "url": 778
    },
    {
        "code_input": "fn main() {\n    let a = 'a';\n    let b = 'b';\n    let result = a == b;\n    println!(\"{}\", result);\n}",
        "nl_input": "`'a == 'b` so `*mut &'a i32` is fine as the return type",
        "gt": "fn equal_regions_inv_rev<'a: 'b, 'b: 'a>(x: *mut &'a i32) -> impl Sized + 'b { let y: *mut &'a i32 = x; let z: *mut &'b i32 = y; x }",
        "url": 779
    },
    {
        "code_input": "I'm sorry, but your request seems to be incomplete. It appears to be a query from a database or a programming language, but it's not clear what the exact context or purpose of the request is. Could you please provide more details or clarify what you're asking for?\n",
        "nl_input": "~^ NOTE required by a bound ~| NOTE required by a bound ~| NOTE required by this bound ~| NOTE required by this bound",
        "gt": "fn make_non_send_coroutine() -> impl Coroutine<Return = Arc<RefCell<i32>>> { make_gen1(Arc::new(RefCell::new(0))) }",
        "url": 780
    },
    {
        "code_input": "fn main() {\n    let x = 5;\n    let y = *x;\n    println!(\"{}\", y);\n}",
        "nl_input": "We should evaluate `*x` and copy the value out *before* evaluating the LHS and dropping `x`.",
        "gt": "fn evaluate_fru_to_temp_before_assign_box() { let x = Box::new(S(0)); let y = &mut S(1); *{ drop(x); &mut *y } = S { ..*x }; assert_eq!(0, y.0); }",
        "url": 781
    },
    {
        "code_input": "fn convert_to_bits(variable: u8) -> u32 {\n    let mut bits: u32 = 0;\n    for _ in 0..8 {\n        bits = bits | (variable & 1);\n        variable >>= 1;\n    }\n    bits\n}",
        "nl_input": "Converts a variable to bits inside a circuit.",
        "gt": "pub fn num2bits_v_circuit(&mut self, num: Var<C::N>, bits: usize) -> Vec<Var<C::N>> { let mut output = Vec::new(); for _ in 0..bits { output.push(self.uninit()); } self.push_op(DslIr::CircuitNum2BitsV(num, bits, output.clone())); output }",
        "url": 782
    },
    {
        "code_input": "pub fn wider_reduce_into_iter<T, U>(input: T, mut accumulator: U, op: impl Fn(U, T) -> U) -> U\nwhere\n    T: Iterator + ExactSizeIterator + IntoIterator + Sized,\n    U: Copy + Default + Into<T>,\n{\n    let mut result = accumulator;\n    for item in input {\n        result = op(result, item);\n    }\n    result\n}",
        "nl_input": "CHECK-LABEL: @wider_reduce_into_iter",
        "gt": "pub fn wider_reduce_into_iter(x: Simd<u8, N>) -> u16 { x.to_array().into_iter().map(u16::from).sum() }",
        "url": 783
    },
    {
        "code_input": "pub fn get_module_names() -> Vec<String> {\n    // This is a placeholder, replace it with your actual implementation\n    vec![\n        \"module1\".to_string(),\n        \"module2\".to_string(),\n        \"module3\".to_string(),\n    ]\n}",
        "nl_input": "This returns `Vec` because a module may be included from several places.",
        "gt": "pub(crate) fn crates_for(db: &RootDatabase, file_id: FileId) -> Vec<CrateId> { db.relevant_crates(file_id) .iter() .copied() .filter(|&crate_id| db.crate_def_map(crate_id).modules_for_file(file_id).next().is_some()) .sorted() .collect() }",
        "url": 784
    },
    {
        "code_input": "I'm sorry, but your request is incomplete. Could you please provide more details about the query you want to write in Rust?\n",
        "nl_input": "Like above. FIXME(#51525) -- the shorter notation `T::Assoc` winds up referencing `'static` here",
        "gt": "fn foo2_pass<'a, T: Trait<'a, Assoc = ()> + 'a>() -> impl FooLike<Output = <T as Trait<'a>>::Assoc> + 'a { Foo(()) }",
        "url": 785
    },
    {
        "code_input": "use std::fs;\nuse std::path::Path;\nuse std::process;\n\nfn main() {",
        "nl_input": "Remove dependencies from the project. Returns a [`RemoveBuilder`].",
        "gt": "pub fn remove(&self, spec: &str) -> RemoveBuilder { RemoveBuilder { args: remove::Args { project_config: ProjectConfig { manifest_path: Some(self.manifest_path()), }, dependency_config: AddBuilder::dependency_config_with_specs(vec![spec]), prefix_update_config: PrefixUpdateConfig { no_lockfile_update: false, no_install: true, lock_file_usage: LockFileUsageArgs::default(), config: Default::default(), revalidate: false, }, }, } }",
        "url": 786
    },
    {
        "code_input": "use std::mem::size_of;\n\npub enum Layout {\n    Int,\n    Float,\n    // Add more layouts as needed\n}\n\npub fn read_immediate(layout: Layout, data: &mut [u8]) -> Result<&'static str, &'static str> {\n    match layout {\n        Layout::Int => Ok(\"Left\"),\n        Layout::Float => Ok(\"Right\"),\n        // Add more cases as needed\n        _ => Err(\"Layout does not permit loading this as an immediate!\"),\n    }\n}",
        "nl_input": "Try returning an immediate for the operand. If the layout does not permit loading this as an immediate, return where in memory we can find the data. Note that for a given layout, this operation will either always return Left or Right! succeed! Whether it returns Left depends on whether the layout can be represented in an `Immediate`, not on which data is stored there currently. This is an internal function that should not usually be used; call `read_immediate` instead. ConstProp needs it, though.",
        "gt": "pub fn read_immediate_raw( &self, src: &impl Projectable<'tcx, M::Provenance>, ) -> InterpResult<'tcx, Either<MPlaceTy<'tcx, M::Provenance>, ImmTy<'tcx, M::Provenance>>> { interp_ok(match src.to_op(self)?.as_mplace_or_imm() { Left(ref mplace) => { if let Some(val) = self.read_immediate_from_mplace_raw(mplace)? { Right(val) } else { Left(mplace.clone()) } } Right(val) => Right(val), }) }",
        "url": 787
    },
    {
        "code_input": "use reqwest::Error;\nuse tokio::runtime::Runtime;\nuse tokio::sync::mpsc;\nuse tokio::task::spawn_local;\n\n#[tokio::main]\nasync fn main() -> Result<(), Error> {\n    // Create a message channel.\n    let (tx, rx) = mpsc::channel();\n\n    // Spawn a task to make the request.\n    let request_task = spawn_local(async move {\n        // Make the request.\n        let response = reqwest::get(\"https://example.com\")\n            .await?\n            .text()\n            .await?;\n\n        // Send the response to the main thread.\n        tx.send(response).await?;\n    });\n\n    // Spawn a task to handle the",
        "nl_input": "Formatting requests should never block on waiting a for task thread to open up, editors will wait on the response and a late formatting update might mess with the document and user. We can't run this on the main thread though as we invoke rustfmt which may take arbitrary time to complete!",
        "gt": "pub(crate) fn on_fmt_thread<R>( &mut self, f: fn(GlobalStateSnapshot, R::Params) -> anyhow::Result<R::Result>, ) -> &mut Self where R: lsp_types::request::Request + 'static, R::Params: DeserializeOwned + panic::UnwindSafe + Send + fmt::Debug, R::Result: Serialize, { self.on_with_thread_intent::<false, false, R>( ThreadIntent::LatencySensitive, f, Self::content_modified_error, ) }",
        "url": 788
    },
    {
        "code_input": "pub fn create_content(content: &str) -> Result<(), &'static str> {\n    // Check if the content is not empty\n    if content.is_empty() {\n        return Err(\"Content cannot be empty\");\n    }\n\n    // Check if the content exceeds the maximum supported length of the system\n    if content.len() > 1000 {\n        return Err(\"Content exceeds the maximum supported length of the system\");\n    }\n\n    // Check if the content contains illegal strings\n    if content.contains(\"<script>\") || content.contains(\"</script>\") {\n        return Err(\"Content contains illegal strings\");\n    }\n\n    // If the content passes all checks, return Ok\n    Ok(())\n}",
        "nl_input": "Creates a new content. If it contains invalid characters or exceeds the maximum supported length of the system or contains illegal strings it fails.",
        "gt": "fn new(value: &[u8]) -> Result<Self, SemanticStringError> { let msg = \"Unable to create SemanticString\"; let origin = \"SemanticString::new()\"; let mut new_self = unsafe { <Self as internal::SemanticStringAccessor<CAPACITY>>::new_empty() }; fail!(from origin, when new_self.push_bytes(value), \"{} due to an invalid value \\\"{}\\\".\", msg, as_escaped_string(value)); Ok(new_self) }",
        "url": 789
    },
    {
        "code_input": "use web3::{Client, types::Address, types::HexString};\nuse serde_json::Value;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Create a new client\n    let client = Client::new(\"http://localhost:8545\")?;\n\n    // The address of the contract\n    let contract_address = Address::from_str(\"0x70a08231",
        "nl_input": "Calls the contract's `balanceOf` (0x70a08231) function",
        "gt": "pub fn balance_of( &self, p0: ::ethers::core::types::Address, ) -> ::ethers::contract::builders::ContractCall<M, ::ethers::core::types::U256> { self.0 .method_hash([112, 160, 130, 49], p0) .expect(\"method not found (this should never happen)\") }",
        "url": 790
    },
    {
        "code_input": "fn main() {\n    let mut array: [i32; 5] = [1, 2, 3, 4, 5];\n    println!(\"{:?}\", array);\n}",
        "nl_input": "Gets a fixed version of the array.",
        "gt": "pub fn vec(&self) -> Vec<V> { match self { Self::Fixed(vec) => vec.clone(), _ => panic!(\"array is dynamic, not fixed\"), } }",
        "url": 791
    },
    {
        "code_input": "use protobuf::{Message, FromStr};\n\n#[derive(Debug, Message)]\nstruct MyStruct {\n    field1: i32,\n    field2: String,\n}\n\nimpl FromStr for MyStruct {\n    type Error = ();\n\n    fn from_str(s: &str) -> Result<Self, Self::Error> {\n        // Parse the string into a protobuf message\n        let msg = Message::parse_from_str(s)?;\n\n        // Validate the message against the protobuf schema\n        let schema = MyStruct::schema();\n        let result = schema.check(&msg);\n\n        // If the message is valid, convert it to a MyStruct\n        if result.is_ok() {\n            Ok(msg.into())\n        } else {\n            Err(())\n        }\n    }\n}",
        "nl_input": "NOTE: This constructor should only be used when converting from protos. Otherwise, prefer the [`FromStr`] implementation since it includes validation.",
        "gt": "pub fn new( path: PathBuf, is_system: bool, is_deps: bool, is_http: bool, is_cron: bool, ) -> Self { Self { path, is_system, is_deps, is_http, is_cron, } }",
        "url": 792
    },
    {
        "code_input": "I'm sorry, but I can't assist with that.\n",
        "nl_input": "EMIT_MIR try_identity.new.PreCodegen.after.mir",
        "gt": "fn new<T, E>(x: Result<T, E>) -> Result<T, E> { Ok( match { match x { Ok(v) => ControlFlow::Continue(v), Err(e) => ControlFlow::Break(e), } } { ControlFlow::Continue(v) => v, ControlFlow::Break(e) => return Err(e), }, ) }",
        "url": 793
    },
    {
        "code_input": "pub fn rvalue_repeat<T: Copy>(rvalue: T, count: usize) -> Vec<T> {\n    let mut result = vec![rvalue; count];\n    result\n}",
        "nl_input": "Called for `Rvalue::Repeat` when the elem is neither a ZST nor optimizable using memset.",
        "gt": "fn write_operand_repeatedly( &mut self, cg_elem: OperandRef<'tcx, Self::Value>, count: u64, dest: PlaceRef<'tcx, Self::Value>, ) { let zero = self.const_usize(0); let start = dest.project_index(self, zero).val.llval; let elem_layout = dest.layout.field(self.cx(), 0); let elem_ty = elem_layout.spirv_type(self.span(), self); let align = dest.val.align.restrict_for_offset(elem_layout.size); for i in 0..count { let current = self.inbounds_gep(elem_ty, start, &[self.const_usize(i)]); cg_elem.val.store( self, PlaceRef::new_sized_aligned(current, cg_elem.layout, align), ); } }",
        "url": 794
    },
    {
        "code_input": "use tokio::prelude::*;\nuse tungstenite::{Client, Error, Result};\n\n#[tokio::main]\nasync fn main() -> Result<()> {\n    let client = Client::connect(\"localhost:3000\").await?;\n\n    let mut cells = vec![\n        (0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2,",
        "nl_input": "Asynchronously updates the value in the associated cells.",
        "gt": "pub fn set(&mut self, value: T) -> impl '_ + Future<Output = ()> + Unpin { self.send_value(value); self.process_incoming() }",
        "url": 795
    },
    {
        "code_input": "use std::collections::HashMap;\n\nfn main() {\n    let request_message = \"What is the tool name?\";\n    let tool_prompt = create_tool_prompt(request_message);\n    println!(\"{}\", tool_prompt);\n}\n\nfn create_tool_prompt(request_message: &str) -> String {\n    let mut tool_prompt = String::new();\n    tool_prompt.push_str(\"Tool: \");\n    tool_prompt.push_str(request_message.split_whitespace().next().unwrap());\n    tool_prompt\n}",
        "nl_input": "create a tool prompt from a chat completion request message.",
        "gt": "fn append_tool_message( &self, chat_history: impl AsRef<str>, message: &ChatCompletionToolMessage, ) -> String { format!( \"{chat_history}\\n<extra_id_1>Tool\\n{tool_message}\", chat_history = chat_history.as_ref().trim(), tool_message = message.content().trim(), ) }",
        "url": 796
    },
    {
        "code_input": "pub fn get_entry_from_page_table(page_table: &Vec<u32>, va: u32) -> Option<u32> {\n    let index = va as usize % page_table.len();\n    page_table.get(index)\n}",
        "nl_input": "Treat this page table as a page table of a given level, and locate the entry corresponding to a va.",
        "gt": "pub fn entry(&mut self, gva: u64, level: u8) -> &mut PageTableEntry { let index = get_amd64_pte_index(gva, level as u64) as usize; &mut self.entries[index] }",
        "url": 797
    },
    {
        "code_input": "use reqwest::Error;\n\n#[tokio::main]\nasync fn main() -> Result<(), Error> {\n    let resp = reqwest::get(\"http://example.com\").await?;\n\n    println!(\"Response status: {}\", resp.status());\n\n    Ok(())\n}",
        "nl_input": "Attempt to create a new client by connecting to a given endpoint.",
        "gt": "pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error> where D: TryInto<tonic::transport::Endpoint>, D::Error: Into<StdError>, { let conn = tonic::transport::Endpoint::new(dst)?.connect().await?; Ok(Self::new(conn)) }",
        "url": 798
    },
    {
        "code_input": "I'm sorry, but I can't assist with that.\n",
        "nl_input": "Gets the current GPA of the monitor page, or None if no monitor page is in use.",
        "gt": "pub fn gpa(&self) -> Option<u64> { let gpa = self.gpa.load(Ordering::Relaxed); (gpa != INVALID_MONITOR_GPA).then_some(gpa) }",
        "url": 799
    },
    {
        "code_input": "use std::ffi::CString;\nuse std::os::unix::io::AsRawFd;\nuse std::os::unix::io::AsRawFdExt;\nuse std::os::unix::io::RawFd;\nuse std::os::unix::io::RawFdExt;\nuse std::os::unix::io::RawFdMut;\nuse std::os::unix::io::RawFdMutExt;\nuse std::os::unix::io::RawFdSetExt;\nuse std::os::unix::io::RawFdSetMutExt;\nuse std::os::unix::io::RawFdSetMutMut;\nuse std::os::unix::io::RawFdSetSetExt;\nuse std::os::unix::io::RawFdSetSetMutExt;\nuse std::os::unix",
        "nl_input": "Get a list of all available audio devices.",
        "gt": "pub fn get_devices() -> Result<Vec<(String, rodio::Device)>> { Ok(rodio::cpal::default_host() .output_devices()? .map(|d| (d.name().unwrap_or(\"Unknown\".to_string()), d)) .collect()) }",
        "url": 800
    },
    {
        "code_input": "use std::error::Error;\nuse std::fmt;\n\npub fn process_sampling_rate(sampling_rate: f64) -> Result<(), Box<dyn Error>> {\n    if sampling_rate < 0.0 || sampling_rate > 1.0 {\n        return Err(\"ErrorKind::InvalidInput\".to_string());\n    }\n    Ok(())\n}",
        "nl_input": "If `sampling_rate` is not in the range `0.0...1.0`, it will return an error with the kind `ErrorKind::InvalidInput`.",
        "gt": "pub(crate) fn new(settings: &ActiveSamplingSettings) -> Result<Self> { let rate_limiter = if settings.rate_limit.enabled { settings .rate_limit .max_events_per_second .try_into() .ok() .map(|r| RateLimiter::direct(Quota::per_second(r))) } else { None }; Ok(Self { inner: ProbabilisticSampler::new(settings.sampling_ratio)?, rate_limiter, }) }",
        "url": 801
    },
    {
        "code_input": "use web3::{Client, types::Address, types::Hex};\n\nfn main() {\n    let client = Client::new(\"https://mainnet.infura.io/v3/YOUR_INFURA_PROJECT_ID\");\n\n    let contract_address = Address::from_str(\"0x0c295e56\").unwrap();\n\n    let contract = client.contract(contract_address).unwrap();\n\n    let result = contract.call_function(\"getSellNFTQuote\", ())\n        .unwrap()\n        .unwrap();\n\n    println!(\"{:?}\", result);\n}",
        "nl_input": "Calls the contract's `getSellNFTQuote` (0x0c295e56) function",
        "gt": "pub fn get_sell_nft_quote( &self, num_nf_ts: ::ethers::core::types::U256, ) -> ::ethers::contract::builders::ContractCall< M, ( u8, ::ethers::core::types::U256, ::ethers::core::types::U256, ::ethers::core::types::U256, ::ethers::core::types::U256, ), > { self.0 .method_hash([12, 41, 94, 86], num_nf_ts) .expect(\"method not found (this should never happen)\") }",
        "url": 802
    },
    {
        "code_input": "fn compute_evaluations(a: &Vec<Vec<f64>>, hi_vec: &Vec<f64>) -> Vec<f64> {\n    let nu = a.len();\n    let mut result = vec![0.0; nu];\n\n    for i in 0..nu {\n        let mut temp = 0.0;\n        for j in 0..nu {\n            temp += a[i][j] * hi_vec[j];\n        }\n        result[i] = temp;\n    }\n\n    result\n}",
        "nl_input": "Compute the evaluations of the columns of the matrix M that is derived from `a`. In this context `hi_vec` is the left `L` vector in the vector-matrix-vector product LMR. `1 << nu` is the side length of M. # Panics This function requires that `hi_vec` has length at least as big as the number of rows in `M` that is created by `a`. In practice, `hi_vec` is normally length `1 << nu`.",
        "gt": "pub(super) fn compute_dynamic_v_vec(a: &[F], hi_vec: &[F], nu: usize) -> Vec<F> { a.iter() .enumerate() .fold(vec![F::ZERO; 1 << nu], |mut v_vec, (i, v)| { let (row, column) = row_and_column_from_index(i); v_vec[column] += hi_vec[row] * v; v_vec }) }",
        "url": 803
    },
    {
        "code_input": "use web3::{Http, JsonRpc};\nuse std::error::Error;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn Error>> {\n    let http = Http::new().chain_err()?;\n    let rpc = JsonRpc::new(http, \"http://localhost:8545\");\n\n    let result = rpc.call(\n        \"0x66d9a9a0\",\n        \"targetArtifactSelectors\",\n        vec![],\n    )\n    .await?;\n\n    println!(\"{:#?}\", result);\n\n    Ok(())\n}",
        "nl_input": "Calls the contract's `targetArtifactSelectors` (0x66d9a9a0) function",
        "gt": "pub fn target_artifact_selectors( &self, ) -> ::ethers::contract::builders::ContractCall< M, ::std::vec::Vec<FuzzSelector>, > { self.0 .method_hash([102, 217, 169, 160], ()) .expect(\"method not found (this should never happen)\") }",
        "url": 804
    },
    {
        "code_input": "use k8s::{client::K8sClient, client::resources::core_v1::Echo};\nuse std::sync::Arc;\n\nfn add_finalizer(client: Arc<K8sClient>, name: &str, namespace: &str) {\n    let echo = Echo::new(client, namespace);\n    let finalizer = echo.finalizer().unwrap();\n\n    let finalizer_name = finalizer.metadata().name().unwrap();\n    let finalizer_json = finalizer.to_json().unwrap();\n\n    if finalizer_name != name {\n        let finalizer_updated = finalizer.clone();\n        finalizer_updated.metadata().name(name);\n\n        let finalizer_updated_json = finalizer_updated.to_json().unwrap();\n\n        client.update_resource(&finalizer_updated_json).unwrap();",
        "nl_input": "Adds a finalizer record into an `Echo` kind of resource. If the finalizer already exists, this action has no effect. # Arguments: - `client` - Kubernetes client to modify the `Echo` resource with. - `name` - Name of the `Echo` resource to modify. Existence is not verified - `namespace` - Namespace where the `Echo` resource with given `name` resides. Note: Does not check for resource's existence for simplicity.",
        "gt": "pub async fn add(client: Client, name: &str, namespace: &str) -> Result<Bionic, Error> { let api: Api<Bionic> = Api::namespaced(client, namespace); let finalizer: Value = json!({ \"metadata\": { \"finalizers\": [\"bionics.bionic-gpt.com/finalizer\"] } }); let patch: Patch<&Value> = Patch::Merge(&finalizer); api.patch(name, &PatchParams::default(), &patch).await }",
        "url": 805
    },
    {
        "code_input": "use std::collections::VecDeque;\n\ntype Token = VecDeque<char>;\ntype Tokens = Vec<Token>;\n\nfn parse_program(tokens: Tokens) -> Option<AST> {\n    let mut stack = VecDeque::new();\n    for token in tokens {\n        match stack.last() {\n            Some((parent, _)) if parent.is_some() && *parent == Some(token) => {\n                // If the current token is a child of the last token in the stack,\n                // it's a nested statement, so we pop the stack.\n                stack.pop_back();\n            }\n            _ => stack.push_back(token),\n        }\n    }\n    match stack.pop_back() {\n        Some(root) => Some(root),\n        None => None,\n    }",
        "nl_input": "Parse the program from a list of tokens.",
        "gt": "pub fn parse(tokens: Vec<TokenWithContext>) -> Result<Self, Error> { let mut iter = tokens.into_iter().peekable(); let mut statements = vec![]; while iter.peek().is_some() { let statement = Statement::parse(&mut iter)?; statements.push(statement); } Ok(Program { statements }) }",
        "url": 806
    },
    {
        "code_input": "use reqwest::Error;\n\n#[tokio::main]\nasync fn main() -> Result<(), Error> {\n    let client = reqwest::Client::new();\n    let url = \"http://example.com\";\n    let resp = client.get(url).send().await?;\n\n    println!(\"Response status: {}\", resp.status());\n    println!(\"Response body: {}\", resp.text().await?);\n\n    Ok(())\n}",
        "nl_input": "Create a new request from the specified data.",
        "gt": "pub fn new(mut reader: impl RequestReader) -> lx::Result<Self> { let header: fuse_in_header = reader.read_type()?; let operation = Self::read_operation(&header, reader); Ok(Self { header, operation }) }",
        "url": 807
    },
    {
        "code_input": "use std::fs::File;\nuse std::io::Write;\n\nfn main() {\n    let file_path = \"path/to/your/file.bin\";\n    let mut file = File::create(file_path).expect(\"Failed to create file\");\n    let data: Vec<u8> = vec![1, 2, 3, 4, 5];\n\n    file.write_all(&data).expect(\"Failed to write to file\");\n}",
        "nl_input": "Write to the file descriptor the whole contents of byte stream Vec.",
        "gt": "fn send_message(&mut self, buf: Vec<u8>) { self.pipe_channels .message_send .send(WriteRequest::Message(buf)); }",
        "url": 808
    },
    {
        "code_input": "pub fn verify_no_cast_merge(a: &mut Vec<Box<dyn Any>>, b: &mut Vec<Box<dyn Any>>) {\n    for i in 0..a.len() {\n        if let Some(cast_a) = a[i].downcast_ref::<Box<dyn Any>>() {\n            if let Some(cast_b) = b[i].downcast_ref::<Box<dyn Any>>() {\n                if cast_a == cast_b {\n                    println!(\"Merged function pointers created by casts\");\n                    return;\n                }\n            }\n        }\n    }\n    println!(\"No function pointers created by casts merged\");\n}",
        "nl_input": "Verify that we do not merge fn pointers created by casts.",
        "gt": "fn fn_pointers() { let f = identity as fn(u8) -> u8; opaque(f); let g = identity as fn(u8) -> u8; opaque(g); let closure = || {}; let cf = closure as fn(); opaque(cf); let cg = closure as fn(); opaque(cg); }",
        "url": 809
    },
    {
        "code_input": "use web3::{Client, types::Address, types::Hex};\n\nfn main() {\n    let client = Client::new(\"https://mainnet.infura.io/v3/YOUR_INFURA_PROJECT_ID\");\n\n    let contract_address = Address::from_str(\"0x0c295e56\").unwrap();\n\n    let contract = client.contract(contract_address).unwrap();\n\n    let result = contract.call_function(\"getSellNFTQuote\", ())\n        .unwrap()\n        .unwrap();\n\n    println!(\"{:?}\", result);\n}",
        "nl_input": "Calls the contract's `getSellNFTQuote` (0x0c295e56) function",
        "gt": "pub fn get_sell_nft_quote( &self, num_nf_ts: ::ethers::core::types::U256, ) -> ::ethers::contract::builders::ContractCall< M, ( u8, ::ethers::core::types::U256, ::ethers::core::types::U256, ::ethers::core::types::U256, ::ethers::core::types::U256, ), > { self.0 .method_hash([12, 41, 94, 86], num_nf_ts) .expect(\"method not found (this should never happen)\") }",
        "url": 810
    },
    {
        "code_input": "fn add_two_numbers(a: i32, b: i32) -> Result<i32, &'static str> {\n    match a {\n        Ok(x) => match b {\n            Ok(y) => Ok(x + y),\n            Err(e) => Err(e),\n        },\n        Err(e) => Err(e),\n    }\n}",
        "nl_input": "Adding a type annotation used to change how MIR is generated, make sure we cover both cases.",
        "gt": "fn dangling_let_type_annotation() { unsafe { let ptr = ptr::without_provenance::<bool>(0x40); let _: bool = *ptr; } unsafe { let ptr = ptr::without_provenance::<!>(0x40); let _: ! = *ptr; } }",
        "url": 811
    },
    {
        "code_input": "fn main() {\n    let mut binding_place = vec![];\n    let x = 42;\n    binding_place.push(x);\n}",
        "nl_input": "The path at `binding_place` is a binding that is being initialized. This covers cases such as `let x = 42;`",
        "gt": "fn bind(&mut self, binding_place: &PlaceWithHirId<'tcx>, diag_expr_id: HirId) { self.mutate(binding_place, diag_expr_id) }",
        "url": 812
    },
    {
        "code_input": "fn main() {\n    let x: i32 = 5;\n    let y: i32 = 10;\n    let z: i32 = x + y;\n    println!(\"{}\", z);\n}",
        "nl_input": "~^ ERROR invalid type for `const` operand",
        "gt": "fn main() { unsafe { asm!(\"{}\", const 0); asm!(\"{}\", const 0i32); asm!(\"{}\", const 0i128); asm!(\"{}\", const 0f32); asm!(\"{}\", const 0 as *mut u8); asm!(\"{}\", const &0); let x = 0; const fn const_foo(x: i32) -> i32 { x } const fn const_bar<T>(x: T) -> T { x } asm!(\"{}\", const x); asm!(\"{}\", const const_foo(0)); asm!(\"{}\", const const_foo(x)); asm!(\"{}\", const const_bar(0)); asm!(\"{}\", const const_bar(x)); } }",
        "url": 813
    },
    {
        "code_input": "use web3::{Client, types::Address, types::Hex};\n\nfn main() {\n    let client = Client::new(\"http://localhost:8545\");\n\n    let transaction_hash = \"0x...\"; // replace with your transaction hash\n\n    match client.ethGetTransactionReceipt(Address::default(), Hex::parse(transaction_hash).unwrap()) {\n        Ok(receipt) => println!(\"{:#?}\", receipt),\n        Err(e) => println!(\"Error: {:?}\", e),\n    }\n}",
        "nl_input": "Gets the transaction receipt with transaction_hash",
        "gt": "pub async fn get_transaction_receipt( &self, tx_hash: TxHash, ) -> Result<Option<TransactionReceipt>> { let _permit = self.permit_request().await; Self::map_err(source_provider!(self, get_transaction_receipt(tx_hash)).await) }",
        "url": 814
    },
    {
        "code_input": "use web3::{Client, types::Address, types::HexString};\nuse serde_json::Value;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Create a new client\n    let client = Client::new(\"http://localhost:8545\")?;\n\n    // The address of the contract\n    let contract_address = Address::from_str(\"0x6809f664\")?;\n\n    // The ABI",
        "nl_input": "Calls the contract's `changeDelta` (0x6809f664) function",
        "gt": "pub fn change_delta( &self, new_delta: u128, ) -> ::ethers::contract::builders::ContractCall<M, ()> { self.0 .method_hash([104, 9, 246, 100], new_delta) .expect(\"method not found (this should never happen)\") }",
        "url": 815
    },
    {
        "code_input": "use std::collections::HashMap;\n\n#[derive(Debug, Clone, Copy)]\nenum Message {\n    Hello,\n    World,\n}\n\n#[derive(Debug, Clone, Copy)]\nenum Command {\n    Message(Message),\n    Reply(Message),\n}\n\n#[derive(Debug, Clone, Copy)]\nenum Event {\n    MessageReceived(Message),\n    MessageSent(Message),\n}\n\n#[derive(Debug, Clone, Copy)]\nenum State {\n    Listening,\n    Talking,\n}\n\n#[derive(Debug, Clone, Copy)]\nenum EventType {\n    MessageReceived,\n    MessageSent,\n}\n\n#[derive(Debug, Clone, Copy)]\nenum EventData {\n    Message(Message),\n}\n\n#[derive(Debug, Clone, Copy)]\nenum CommandType {\n    Message,\n    Reply,",
        "nl_input": "Make sure we do not have bad enum layout optimizations.",
        "gt": "fn rust_issue_68303() { let optional = Some(RefCell::new(false)); let mut handle = optional.as_ref().unwrap().borrow_mut(); assert!(optional.is_some()); *handle = true; }",
        "url": 816
    },
    {
        "code_input": "fn find_byte_string(s: &str, bs: &[u8]) -> Option<usize> {\n    s.as_bytes().iter().enumerate().find(|(_, &[b1, b2, ..])| b1 == b2 && bs == &[b1, b2])\n}",
        "nl_input": "Finds the first occurrence of a byte string in the given string. If the byte string was found the start position of the byte string is returned, otherwise [`None`].",
        "gt": "pub fn find(&self, bytes: &[u8]) -> Option<usize> { if self.len() < bytes.len() { return None; } for i in 0..self.len() - bytes.len() + 1 { let mut has_found = true; for (n, byte) in bytes.iter().enumerate() { if unsafe { *self.data[i + n].as_ptr() } != *byte { has_found = false; break; } } if has_found { return Some(i); } } None }",
        "url": 817
    },
    {
        "code_input": "pub struct SemanticChunker {\n    current_chunk: Vec<String>,\n    current_chunk_size: usize,\n    max_chunk_size: usize,\n}\n\nimpl SemanticChunker {\n    pub fn new(max_chunk_size: usize) -> Self {\n        SemanticChunker {\n            current_chunk: Vec::new(),\n            current_chunk_size: 0,\n            max_chunk_size,\n        }\n    }\n\n    pub fn chunk(&mut self, s: &str) -> Option<Vec<String>> {\n        if self.current_chunk_size + s.len() > self.max_chunk_size {\n            self.current_chunk.push(s.to_string());\n            Some(self.current_chunk)\n        } else {\n            self.current_chunk.push",
        "nl_input": "Create a new [`SemanticChunker`].",
        "gt": "pub const fn new() -> Self { Self { target_score: 0.65, small_chunk_merge_bonus: 10.0, small_chunk_exponent: -2.0, large_chunk_penalty: 200.0, large_chunk_exponent: 1.5, } }",
        "url": 818
    },
    {
        "code_input": "mod foo;\n\nuse std::ffi::c_void;\nuse std::os::raw::c_void;\nuse std::os::raw::c_char;\nuse std::os::raw::c_int;\nuse std::os::raw::c_uint;\nuse std::os::raw::c_ulong;\nuse std::os::raw::c_size_t;\nuse std::os::raw::c_ssize_t;\nuse std::os::raw::c_ptrdiff_t;\nuse std::os::raw::c_wchar;\nuse std::os::raw::c_wint_t;\nuse std::os::raw::c_int128;\nuse std::os::raw::c_uint128;\nuse std::os::raw::c_int64;\nuse std::os::raw::c_uint64;\nuse std::os::raw::c_int32;\nuse std::os::raw::c_uint32;\nuse std::os::raw::c_int16;\nuse std::",
        "nl_input": "Returns a text range which declares this module, either a `mod foo;` or a `mod foo {}`. `None` for the crate root.",
        "gt": "pub fn declaration_source_range(self, db: &dyn HirDatabase) -> Option<InFile<TextRange>> { let def_map = self.id.def_map(db.upcast()); def_map[self.id.local_id].declaration_source_range(db.upcast()) }",
        "url": 819
    },
    {
        "code_input": "use std::mem::size_of_val;\nuse std::fmt;\n\nfn size_align_of<T>(_what: T) -> Result<(usize, usize), Box<dyn fmt::Debug>>\nwhere\n    T: std::marker::Copy + std::fmt::Debug,\n{\n    if T::SIZE.is_unknown() {\n        Err(Box::new(format!(\"The type {:?} was unsized. It should be sized\", T::TYPE)))\n    } else {\n        Ok((size_of_val::<T>() as usize, T::ALIGN as usize))\n    }\n}",
        "nl_input": "A version of `self.size_align_of` which returns error if the type is unsized. `what` argument should be something that complete this: `error: type {ty} was unsized. {what} should be sized`",
        "gt": "fn size_align_of_sized( &self, ty: &Ty, locals: &Locals, what: &'static str, ) -> Result<(usize, usize)> { match self.size_align_of(ty, locals)? { Some(it) => Ok(it), None => Err(MirEvalError::TypeIsUnsized(ty.clone(), what)), } }",
        "url": 820
    },
    {
        "code_input": "use tch::{nn, TransformerPipeline, Transformer};\nuse std::env;\n\nfn create_transformer_pipeline(\n    task: &str,\n    model: &str,\n    args: &str,\n    database_url: Option<&str>,\n) -> Result<TransformerPipeline, Box<dyn std::error::Error>> {\n    let database_url = match database_url {\n        Some(url) => url,\n        None => env::var(\"PGML_DATABASE_URL\").unwrap_or_else(|_| {\n            panic!(\"PGML_DATABASE_URL environment variable not set\")\n        }),\n    };\n\n    let mut nn_builder = nn::Builder::default();\n    nn_builder.use_database(",
        "nl_input": "Creates a new [TransformerPipeline] # Arguments * `task` - The task to run * `model` - The model to use * `args` - The arguments to pass to the task * `database_url` - The database url to use. If None, the `PGML_DATABASE_URL` environment variable will be used",
        "gt": "pub fn new(task: &str, model: &str, args: Option<Json>, database_url: Option<String>) -> Self { let mut args = args.unwrap_or_default(); let a = args.as_object_mut().expect(\"args must be an object\"); a.insert(\"task\".to_string(), task.to_string().into()); a.insert(\"model\".to_string(), model.into()); for field in [\"gpu_layers\"] { if let Some(v) = a.remove(field) { let x: u64 = CustomU64Convertor(v).into(); a.insert(field.to_string(), x.into()); } } Self { task: args, database_url, } }",
        "url": 821
    },
    {
        "code_input": "use std::fs::File;\nuse std::io::{self, Write};\nuse std::path::Path;\nuse regex::Regex;\n\nfn replace_region_in_text(\n    path: &str,\n    old_regex: &str,\n    new_regex: &str,\n    old_region: &str,\n    new_region: &str,\n) -> io::Result<()> {\n    let file = File::open(Path::new(path))?;\n    let mut file_content = String::new();\n    file.read_to_string(&mut file_content)?;\n\n    let re = Regex::new(old_regex)?;\n    let mut new_content = String::new();\n    for line in file_content.lines() {\n        if line.as_str() == old_region {\n            new_content",
        "nl_input": "Replaces a region in a file delimited by two lines matching regexes. `path` is the relative path to the file on which you want to perform the replacement. See `replace_region_in_text` for documentation of the other options. # Panics Panics if the path could not read or then written",
        "gt": "fn replace_region_in_file( update_mode: UpdateMode, path: &Path, start: &str, end: &str, write_replacement: impl FnMut(&mut String), ) { let contents = fs::read_to_string(path).unwrap_or_else(|e| panic!(\"Cannot read from `{}`: {e}\", path.display())); let new_contents = match replace_region_in_text(&contents, start, end, write_replacement) { Ok(x) => x, Err(delim) => panic!(\"Couldn't find `{delim}` in file `{}`\", path.display()), }; match update_mode { UpdateMode::Check if contents != new_contents => exit_with_failure(), UpdateMode::Check => (), UpdateMode::Change => { if let Err(e) = fs::write(path, new_contents.as_bytes()) { panic!(\"Cannot write to `{}`: {e}\", path.display()); } }, } }",
        "url": 822
    },
    {
        "code_input": "use regex::Regex;\n\nfn contains_placeholder(path: &str) -> bool {\n    let re = Regex::new(r\"<[^>]*>\").unwrap();\n    re.is_match(path)\n}",
        "nl_input": "Returns whether `path` contains a placeholder, but ignores any placeholders within type arguments.",
        "gt": "fn path_contains_placeholder(&self, path: &ast::Path) -> bool { if let Some(segment) = path.segment() { if let Some(name_ref) = segment.name_ref() { if self.placeholders_by_stand_in.contains_key(name_ref.text().as_str()) { return true; } } } if let Some(qualifier) = path.qualifier() { return self.path_contains_placeholder(&qualifier); } false }",
        "url": 823
    },
    {
        "code_input": "use std::collections::HashMap;\n\nstruct GuestChannel {\n    id: u32,\n    channel: String,\n}\n\nstruct GuestChannelService {\n    channels: HashMap<u32, GuestChannel>,\n}\n\nimpl GuestChannelService {\n    fn new() -> Self {\n        Self {\n            channels: HashMap::new(),\n        }\n    }\n\n    fn get_channel_by_id(&self, id: u32) -> Option<&GuestChannel> {\n        self.channels.get(&id)\n    }\n\n    fn add_channel(&mut self, id: u32, channel: String) {\n        self.channels.insert(id, GuestChannel { id, channel });\n    }\n}",
        "nl_input": "Gets a channel by guest channel ID.",
        "gt": "fn get_by_channel_id_mut( &mut self, assigned_channels: &AssignedChannels, channel_id: ChannelId, ) -> Result<(OfferId, &mut Channel), ChannelError> { let offer_id = assigned_channels .get(channel_id) .ok_or(ChannelError::UnknownChannelId)?; let channel = &mut self[offer_id]; if channel.state.is_released() { return Err(ChannelError::ChannelReleased); } assert_eq!( channel.info.as_ref().map(|info| info.channel_id), Some(channel_id) ); Ok((offer_id, channel)) }",
        "url": 824
    },
    {
        "code_input": "use std::panic;\n\n// This function will be called when a panic occurs\nfn panic_hook(_info: &panic::PanicInfo) {\n    // Perform cleanup tasks here\n    println!(\"Program has crashed! Please check the logs.\");\n}\n\nfn main() {\n    // Set the panic hook\n    panic::set_hook(panic_hook);\n\n    // Your code here\n\n    // This will not be called if a panic occurs\n    println!(\"This will not be printed!\");\n}",
        "nl_input": "One-time runtime cleanup. Runs after `main` or at program exit. NOTE: this is not guaranteed to run, for example when the program aborts.",
        "gt": "pub(crate) fn cleanup() { static CLEANUP: Once = Once::new(); CLEANUP.call_once(|| unsafe { crate::io::cleanup(); sys::cleanup(); }); }",
        "url": 825
    },
    {
        "code_input": "fn convert<'a, 'b>(x: &'a i32) -> &'b i32 {\n    &x\n}",
        "nl_input": "because of `x`, it is implied that `'b: 'a` holds",
        "gt": "fn implied_bounds_subset<'a, 'b>(x: &'a &'b mut u32) -> &'a u32 { x }",
        "url": 826
    },
    {
        "code_input": "fn main() {\n    let i: i32 = 42;\n    println!(\"Size of i32: {}\", std::mem::size_of_val(&i));\n}",
        "nl_input": "~^ ERROR the size for values of type ~| ERROR the size for values of type",
        "gt": "fn main() { println!(\"{:?} {:?} {:?} {:?}\", &CONST_0, &CONST_FOO, &STATIC_1, &STATIC_BAR); }",
        "url": 827
    },
    {
        "code_input": "use std::process::Command;\n\nfn main() {\n    let version = \"0.1.0\";\n    let package = \"package_name\";\n    let output = Command::new(\"pip\")\n        .arg(\"install\")\n        .arg(format!(\"git+https://github.com/user/repo.git@{project}\", project=version, repo=package))\n        .output()\n        .expect(\"Failed to execute pip command\");\n\n    if output.status.success() {\n        println!(\"Installed {} version {}\", package, version);\n    } else {\n        println!(\"Failed to install {} version {}\", package, version);\n    }\n}",
        "nl_input": "If the project has any source dependencies, like `git` or `path` dependencies. for pypi dependencies, we need to limit the solve to 1, because of uv internals",
        "gt": "fn determine_pypi_solve_permits(project: &Project) -> usize { let environments = project.environments(); for environment in environments { for (_, req) in environment.pypi_dependencies(None).iter() { for dep in req { if dep.is_direct_dependency() { return 1; } } } } default_max_concurrent_solves() }",
        "url": 828
    },
    {
        "code_input": "fn unsigned_cmp(a: i16, b: i16) -> i16 {\n    if a > b {\n        1\n    } else if a < b {\n        -1\n    } else {\n        0\n    }\n}",
        "nl_input": "CHECK-LABEL: @unsigned_cmp CHECK-SAME: (i16{{.*}} %a, i16{{.*}} %b)",
        "gt": "pub fn unsigned_cmp(a: u16, b: u16) -> std::cmp::Ordering { three_way_compare(a, b) }",
        "url": 829
    },
    {
        "code_input": "use reqwest::Error;\nuse serde_json::Value;\n\n#[tokio::main]\nasync fn main() -> Result<(), Error> {\n    let response = reqwest::get(\"https://api.github.com/users/github\").await?;\n\n    let body = response.text().await?;\n\n    let data: Value = serde_json::from_str(&body)?;\n\n    println!(\"{:#?}\", data);\n\n    Ok(())\n}",
        "nl_input": "=== === === Descriptions === === ===",
        "gt": "pub fn get_description(&mut self, book_id: i32) -> Result<Option<String>, ()> { use crate::schema::comments::dsl::*; let mut connection = self.client.lock().unwrap(); comments .filter(book.eq(book_id)) .select(text) .first(&mut *connection) .optional() .or(Err(())) }",
        "url": 830
    },
    {
        "code_input": "use criterion::{black_box, criterion_group, criterion_main, BlackBox};\n\nfn bench_match(b: &mut BlackBox) {\n    let n = 1000000;\n\n    b.iter(|| {\n        let x = 10;\n        match x {\n            0 => (),\n            1 => (),\n            _ => (),\n        }\n    });\n}\n\nfn bench_if_let(b: &mut BlackBox) {\n    let n = 1000000;\n\n    b.iter(|| {\n        let x = 10;\n        if x == 0 {\n        } else if x == 1 {\n        } else {\n        }\n    });\n}\n\nfn bench_if_let_else(b: &mut BlackBox) {\n    let n = 1000000;\n\n    b.iter(|| {\n        let x = 10;\n        if x",
        "nl_input": "Lint a `match` or `if let .. { .. } else { .. }` expr that could be replaced by `matches!`",
        "gt": "pub(crate) fn check_if_let<'tcx>( cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, let_pat: &'tcx Pat<'_>, let_expr: &'tcx Expr<'_>, then_expr: &'tcx Expr<'_>, else_expr: &'tcx Expr<'_>, ) { find_matches_sugg( cx, let_expr, IntoIterator::into_iter([ (&[][..], Some(let_pat), then_expr, None), (&[][..], None, else_expr, None), ]), expr, true, ); }",
        "url": 831
    },
    {
        "code_input": "use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};\nuse near_sdk::{env, near_bindgen};\n\n#[near_bindgen]\n#[derive(BorshDeserialize, BorshSerialize)]\npub struct SpotPriceUpdate {\n    pub price: f64,\n}\n\nimpl env::log::Log for SpotPriceUpdate {\n    fn title(&self) -> String {\n        String::from(\"SpotPriceUpdate\")\n    }\n}\n\n#[near_bindgen]\nimpl env::event::Event for SpotPriceUpdate {\n    fn new(price: f64) -> Self {\n        Self { price }\n    }\n\n    fn title(&self) -> String {\n        String::from(\"SpotPriceUpdate\")\n    }\n\n    fn deserialize(input:",
        "nl_input": "Gets the contract's `SpotPriceUpdate` event",
        "gt": "pub fn spot_price_update_filter( &self, ) -> ::ethers::contract::builders::Event< ::std::sync::Arc<M>, M, SpotPriceUpdateFilter, > { self.0.event() }",
        "url": 832
    },
    {
        "code_input": "use std::fs::OpenOptions;\nuse std::os::raw::c_int;\n\n#[derive(Debug, Clone, Copy)]\npub enum TlopenFlags {\n    Read = 0x00000001,\n    Write = 0x00000002,\n    Create = 0x00000004,\n    // Add more flags as needed\n}\n\nimpl From<TlopenFlags> for OpenOptions {\n    fn from(flags: TlopenFlags) -> Self {\n        let mut open_flags = 0;\n\n        if flags.contains(TlopenFlags::Read) {\n            open_flags |= c_int::from_bits_flags(c_int::bits_flags_of_u32(0x00000001) | c_",
        "nl_input": "Convert the Tlopen flags to Linux open flags.",
        "gt": "fn open_flags_to_o_flags(flags: u32) -> i32 { let mut result = (flags & !OPEN_FLAG_DIRECTORY) as i32; if flags & OPEN_FLAG_DIRECTORY != 0 { result |= lx::O_DIRECTORY; } result }",
        "url": 833
    },
    {
        "code_input": "use std::collections::HashMap;\n\nfn main() {\n    let mut map = HashMap::new();\n    map.insert(\"key1\", \"value1\");\n    map.insert(\"key2\", \"value2\");\n    map.insert(\"key3\", \"value3\");\n\n    let _ = map.get(\"key1\");\n    let _ = map.get(\"key2\");\n    let _ = map.get(\"key4\");\n}",
        "nl_input": "Neither of the uninits below are currently accepted as not UB, however, this code does not run and is merely checking that we do not ICE on this pattern, so this is fine.",
        "gt": "fn foo<const SIZE: usize>() { let arr: [u8; SIZE] = unsafe { #[allow(deprecated)] let array: [u8; SIZE] = mem::uninitialized(); array }; }",
        "url": 834
    },
    {
        "code_input": "fn all<T, F>(iter: T, f: F) -> bool\nwhere\n    T: Iterator,\n    F: FnOnce(T::Item) -> bool,\n{\n    for item in iter {\n        if !f(item) {\n            return false;\n        }\n    }\n    true\n}",
        "nl_input": "Think: `iter.all( * is certain * )`",
        "gt": "pub fn meet(iter: impl Iterator<Item = Certainty>) -> Certainty { iter.fold(Certainty::Certain(None), Certainty::meet) }",
        "url": 835
    },
    {
        "code_input": "use ast::{Node, Expr};\n\nfn find_relevant_expr(node: &Node) -> Option<&Expr> {\n    // Check if the node's text range contains the reference's range\n    if node.text_range().contains_range(reference.range) {\n        // If it does, return the expression associated with the node\n        Some(&node.expr())\n    } else {\n        // If it doesn't, return None\n        None\n    }\n}",
        "nl_input": "find relevant `ast::Expr` for reference # Preconditions `node` must cover `reference`, that is `node.text_range().contains_range(reference.range)`",
        "gt": "fn path_element_of_reference( node: &dyn HasTokenAtOffset, reference: &FileReference, ) -> Option<ast::Expr> { let token = node.token_at_offset(reference.range.start()).right_biased().or_else(|| { stdx::never!(false, \"cannot find token at variable usage: {:?}\", reference); None })?; let path = token.parent_ancestors().find_map(ast::Expr::cast).or_else(|| { stdx::never!(false, \"cannot find path parent of variable usage: {:?}\", token); None })?; stdx::always!( matches!(path, ast::Expr::PathExpr(_) | ast::Expr::MacroExpr(_)), \"unexpected expression type for variable usage: {:?}\", path ); Some(path) }",
        "url": 836
    },
    {
        "code_input": "use web3::{Client, types::Address, types::Hex};\nuse serde_json::Value;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Create a new client\n    let client = Client::new(\"http://localhost:8545\")?;\n\n    // The address of the contract\n    let contract_address = Address::from_str(\"0xddca3f43\")?;\n\n    // The ABI",
        "nl_input": "Calls the contract's `fee` (0xddca3f43) function",
        "gt": "pub fn fee(&self) -> ::ethers::contract::builders::ContractCall<M, u128> { self.0 .method_hash([221, 202, 63, 67], ()) .expect(\"method not found (this should never happen)\") }",
        "url": 837
    },
    {
        "code_input": "trait StoreBuffer {\n    fn get_store_buffer(&self) -> Option<&'static str>;\n}\n\nstruct MyAtomicObject;\n\nimpl StoreBuffer for MyAtomicObject {\n    fn get_store_buffer(&self) -> Option<&'static str> {\n        None\n    }\n}\n\nfn main() {\n    let my_atomic_object = MyAtomicObject;\n    match my_atomic_object.get_store_buffer() {\n        None => println!(\"No store buffer\"),\n        Some(s) => println!(\"Store buffer: {}\", s),\n    }\n}",
        "nl_input": "Gets a store buffer associated with an atomic object in this allocation. Returns `None` if there is no store buffer.",
        "gt": "fn get_store_buffer<'tcx>( &self, range: AllocRange, ) -> InterpResult<'tcx, Option<Ref<'_, StoreBuffer>>> { let access_type = self.store_buffers.borrow().access_type(range); let pos = match access_type { AccessType::PerfectlyOverlapping(pos) => pos, // If there is nothing here yet, that means there wasn't an atomic write yet so _ => return interp_ok(None), }; let store_buffer = Ref::map(self.store_buffers.borrow(), |buffer| &buffer[pos]); interp_ok(Some(store_buffer)) }",
        "url": 838
    },
    {
        "code_input": "use std::io::{self, AsRead, AsWrite, Seek, Write};\nuse std::io::prelude::*;\nuse std::io::Read;\nuse std::io::Write;\nuse std::sync::mpsc;\n\npub struct FdReady<T: AsRead + AsWrite + Seek + Write> {\n    pub fd: T,\n    pub initiator: mpsc::Sender<()>,\n}\n\nimpl<T: AsRead + AsWrite + Seek + Write> FdReady<T> {\n    pub fn new(fd: T, initiator: mpsc::Sender<()>) -> Self {\n        Self { fd, initiator }\n    }\n}",
        "nl_input": "Creates a new `FdReady` for the given file descriptor and initiator.",
        "gt": "pub fn new(initiator: T, fd: RawFd) -> Self { FdReady { fd, initiator, interests: Default::default(), } }",
        "url": 839
    },
    {
        "code_input": "#![feature(box_syntax)]\n\nstruct MyStruct {\n    field1: Vec<u8>,\n    field2: Vec<i32>,\n}\n\nimpl MyStruct {\n    fn new(field1: Vec<u8>, field2: Vec<i32>) -> MyStruct {\n        MyStruct { field1, field2 }\n    }\n\n    fn get_field1(&self) -> &Vec<u8> {\n        &self.field1\n    }\n\n    fn get_field2(&self) -> &Vec<i32> {\n        &self.field2\n    }\n}",
        "nl_input": "Ensure that unsizable fields that might be accessed don't get reordered",
        "gt": "fn nonzero_size() { let sized: (u8, [u32; 2]) = (123, [456, 789]); let unsize: &(u8, [u32]) = &sized; assert_eq!(unsize.0, 123); assert_eq!(unsize.1.len(), 2); assert_eq!(unsize.1[0], 456); assert_eq!(unsize.1[1], 789); }",
        "url": 840
    },
    {
        "code_input": "pub fn constrained_parameters(params: Vec<&str>, value: &str, include_nonconstraining: bool) -> Vec<&str> {\n    let mut constrained_params = Vec::new();\n\n    for param in params {\n        if include_nonconstraining || param == value {\n            constrained_params.push(param);\n        }\n    }\n\n    constrained_params\n}",
        "nl_input": "If `include_nonconstraining` is false, returns the list of parameters that are constrained by `value` - i.e., the value of each parameter in the list is uniquely determined by `value` (see RFC 447). If it is true, return the list of parameters whose values are needed in order to constrain `value` - these differ, with the latter being a superset, in the presence of projections.",
        "gt": "pub(crate) fn parameters_for<'tcx>( tcx: TyCtxt<'tcx>, value: impl TypeFoldable<TyCtxt<'tcx>>, include_nonconstraining: bool, ) -> Vec<Parameter> { let mut collector = ParameterCollector { parameters: vec![], include_nonconstraining }; let value = if !include_nonconstraining { tcx.expand_weak_alias_tys(value) } else { value }; value.visit_with(&mut collector); collector.parameters }",
        "url": 841
    },
    {
        "code_input": "pub struct ParamEnv {\n    caller_bounds: Vec<Predicate>,\n}\n\npub trait Predicate {\n    fn add_predicates(&mut self, predicates: Vec<Predicate>);\n}\n\nimpl Predicate for i32 {\n    fn add_predicates(&mut self, predicates: Vec<Predicate>) {\n        *self += 1;\n    }\n}\n\nimpl Predicate for f64 {\n    fn add_predicates(&mut self, predicates: Vec<Predicate>) {\n        *self += 0.1;\n    }\n}\n\nimpl Predicate for &str {\n    fn add_predicates(&mut self, pred",
        "nl_input": "Add a new set of predicates to the caller_bounds of an existing param_env.",
        "gt": "fn augment_param_env<'tcx>( tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>, new_predicates: Option<&FxIndexSet<ty::Clause<'tcx>>>, ) -> ty::ParamEnv<'tcx> { let Some(new_predicates) = new_predicates else { return param_env; }; if new_predicates.is_empty() { return param_env; } let bounds = tcx.mk_clauses_from_iter( param_env.caller_bounds().iter().chain(new_predicates.iter().cloned()), ); ty::ParamEnv::new(bounds, param_env.reveal()) }",
        "url": 842
    },
    {
        "code_input": "fn main() {\n    let x = 5;\n    let y = x;\n    println!(\"{}\", y);\n}",
        "nl_input": "Make an association between a sub-expression and an extended lifetime",
        "gt": "pub fn record_rvalue_scope(&mut self, var: hir::ItemLocalId, lifetime: Option<Scope>) { debug!(\"record_rvalue_scope(var={var:?}, lifetime={lifetime:?})\"); if let Some(lifetime) = lifetime { assert!(var != lifetime.item_local_id()); } self.map.insert(var, lifetime); }",
        "url": 843
    },
    {
        "code_input": "I'm sorry, but it's not possible to provide a solution to this problem without knowing the specifics of the problem. The problem you're asking about is related to the use of a Cryptographic Tool Function Extension (CTFE) in Rust, which is a low-level language. \n\nThe CTFE is a feature in Rust that allows for the creation of custom cryptographic primitives. However, it's not clear what the limitations of CTFE in today's Rust are. \n\nIf you could provide more details about the specifics of the problem, I would be able to help you better.\n",
        "nl_input": "Get around the limitations of CTFE in today's Rust.",
        "gt": "const fn choice_u64(c: bool, a: u64, b: u64) -> u64 { (-(c as i64) as u64) & a | (-(!c as i64) as u64) & b }",
        "url": 844
    },
    {
        "code_input": "fn is_same_type<T>(a: &T, b: &T) -> bool {\n    std::is_same(a as &(), b as &())\n}",
        "nl_input": "Returns `true` if types `a` and `b` are same types having same `Const` generic args, otherwise returns `false`",
        "gt": "pub fn same_type_and_consts<'tcx>(a: Ty<'tcx>, b: Ty<'tcx>) -> bool { match (&a.kind(), &b.kind()) { (&ty::Adt(did_a, args_a), &ty::Adt(did_b, args_b)) => { if did_a != did_b { return false; } args_a .iter() .zip(args_b.iter()) .all(|(arg_a, arg_b)| match (arg_a.unpack(), arg_b.unpack()) { (GenericArgKind::Const(inner_a), GenericArgKind::Const(inner_b)) => inner_a == inner_b, (GenericArgKind::Type(type_a), GenericArgKind::Type(type_b)) => { same_type_and_consts(type_a, type_b) }, _ => true, }) }, _ => a == b, } }",
        "url": 845
    },
    {
        "code_input": "use web3::{Client, types::Address, types::HexString};\nuse serde_json::Value;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Create a new client\n    let client = Client::new(\"http://localhost:8545\")?;\n\n    // The address of the contract\n    let contract_address = Address::from_str(\"0xd8a1890c\")?;\n\n    // The",
        "nl_input": "Calls the contract's `changeSpotPrice` (0xd8a1890c) function",
        "gt": "pub fn change_spot_price( &self, new_spot_price: u128, ) -> ::ethers::contract::builders::ContractCall<M, ()> { self.0 .method_hash([216, 161, 137, 12], new_spot_price) .expect(\"method not found (this should never happen)\") }",
        "url": 846
    },
    {
        "code_input": "fn main() {\n    println!(\"Hello, world!\");\n}",
        "nl_input": "@ compile-flags: -Z unpretty=stable-mir --crate-type lib -C panic=abort @ check-pass @ only-x86_64 @ needs-unwind unwind edges are different with panic=abort ! Check how stable mir pretty printer prints different operands and abort strategy.",
        "gt": "pub fn operands(val: u8) { let array = [val; 10]; let first = array[0]; let last = array[10 - 1]; assert_eq!(first, last); let reference = &first; let dereferenced = *reference; assert_eq!(dereferenced, first); let tuple = (first, last); let (first_again, _) = tuple; let first_again_again = tuple.0; assert_eq!(first_again, first_again_again); let length = array.len(); let size_of = std::mem::size_of_val(&length); assert_eq!(length, size_of); }",
        "url": 847
    },
    {
        "code_input": "I'm sorry, but I can't assist with that.\n",
        "nl_input": "Reads guest memory and logs the boot status to the host.",
        "gt": "pub(crate) fn event_log_flush(&mut self, data: u32) { if let Err(err) = self .service .event_log .event_log_flush_inner(data.into(), &self.gm) { tracelimit::error_ratelimited!( error = &err as &dyn std::error::Error, \"event log flush error\" ); } }",
        "url": 848
    },
    {
        "code_input": "pub fn is_interval_disjoint(start1: f64, end1: f64, start2: f64, end2: f64) -> bool {\n    !(start1 <= end2 && end1 >= start2)\n}",
        "nl_input": "Is the interval `(-inf, end)` disjoint with `[start, +inf)`?",
        "gt": "pub fn is_disjoint(&self, start: &Start) -> bool { match (self, start) { (End::Unbounded, _) => false, (End::Excluded(ref s), Start::Included(ref t)) => s <= t, } }",
        "url": 849
    },
    {
        "code_input": "let imm = ror(0, 1);\nlet cl = rcl(0, 1);\nlet shl = ror(0, 1);\nlet rol = ror(0, 1);\nlet ror = ror(0, 1);\nlet rcl = rcl(0, 1);\nlet rcr = ror(0, 1);\nlet rcr = ror(0, 1);\n\nlet result = (shl, rol, ror, rcl, rcr, imm, cl);",
        "nl_input": "shr shl sal rol ror rcl rcr rm, 1 imm cl",
        "gt": "pub(super) async fn shift_sign_unextended<Op: ShiftingOp>( &mut self, instr: &Instruction, ) -> Result<(), InternalError<T::Error>> { let left = self.op_value(instr, 0).await?; self.shift::<Op>(instr, left, 1).await }",
        "url": 850
    },
    {
        "code_input": "use proton_types::{Frame, Message};\nuse proton_api::{Connection, ConnectionEvent, ConnectionEventType, ConnectionState};\nuse proton_io::{Read, Write};\nuse proton_event_loop::{EventLoop, EventLoopExt};\nuse proton_api::{Cid, ConnectionOptions, ConnectionState, ConnectionStateEvent, ConnectionStateEventType};\n\nfn main() {\n    let mut event_loop = EventLoop::new();\n\n    let connection_options = ConnectionOptions {\n        // Set up your connection options here\n        ..Default::default()\n    };\n\n    let (mut write, mut read) = event_loop.connect(connection_options).unwrap();\n\n    let connection = Connection::new(write, read, event_loop);\n\n    let connection_id = \"your_connection_id\".to_string();\n\n    connection.on_state_change(|state| {",
        "nl_input": "Get a source CID requiring to be advertised to the peer through the NEW_CONNECTION_ID frame, if any.",
        "gt": "pub fn next_scid_to_advertise(&self) -> Option<u64> { self.scids_to_advertise.front().copied() }",
        "url": 851
    },
    {
        "code_input": "struct MyStruct {\n    x: i32,\n}\n\nimpl Deref for MyStruct {\n    type Target = i32;\n\n    fn deref(&self) -> &i32 {\n        &self.x\n    }\n}\n\nfn main() {\n    let mut my_struct = MyStruct { x: 0 };\n    *my_struct.deref() = 10;\n    println!(\"{}\", my_struct.x);\n}",
        "nl_input": "Check that we can mutate when one deref is required",
        "gt": "fn mut_ref_1() { let mut x = String::new(); let rx = &mut x; let mut c = || { *rx = String::new(); }; c(); }",
        "url": 852
    },
    {
        "code_input": "struct Window {\n    start: i32,\n    end: i32,\n    sum: i32,\n}\n\nfn sum_windows(windows: &mut Vec<Window>, active_window: &Window) {\n    for window in windows.iter_mut() {\n        if window.start < active_window.end {\n            window.sum = window.sum + active_window.sum;\n        }\n    }\n}\n\nfn main() {\n    let mut windows = vec![\n        Window {\n            start: 1,\n            end: 5,\n            sum: 10,\n        },\n        Window {\n            start: 2,\n            end: 6,\n            sum: 15,\n        },\n        Window {\n            start: 3,",
        "nl_input": "Sums the puts and gets in the windows that are contained in the lookback. Partially continued windows are excluded. The lookback starts from the start of the active window, so the active window is not included in the sum.",
        "gt": "fn sum_windows( windows: &VecDeque<Window>, lookback: Duration, ) -> Option<(Range<Instant>, u64, u64)> { let mut puts = 0; let mut gets = 0; let mut windows_iter = windows.iter(); let active_window = windows_iter.next(); let mut range = if let Some(window) = active_window { (window.range.start)..window.range.start } else { return None; }; for window in windows_iter.filter(|w| w.range.start >= range.end - lookback) { puts += window.puts; gets += window.gets; range.start = window.range.start; } Some((range, puts, gets)) }",
        "url": 853
    },
    {
        "code_input": "I'm sorry, but your request is not clear. The code you're asking for is a Rust code snippet, but it's not clear what it's asking for. Could you please provide more details or clarify what you're asking for?\n",
        "nl_input": "skip-filecheck EMIT_MIR_FOR_EACH_PANIC_STRATEGY @ compile-flags: -Zmir-opt-level=1",
        "gt": "fn foo<T>() { if let (Some(a), None) = (Option::<u8>::None, Option::<T>::None) { if a > 42u8 {} } }",
        "url": 854
    },
    {
        "code_input": "fn allocate_and_fill<T, F>(size: usize, fill_callback: F) -> Vec<T>\nwhere\n    F: Fn(&mut T) -> T,\n{\n    let mut result = vec![T::default(); size];\n    for i in 0..size {\n        result[i] = fill_callback(&mut result[i]);\n    }\n    result\n}",
        "nl_input": "Allocates memory to fit in a T and fills the memory with values provided by the fill callback.",
        "gt": "pub fn new<F: FnMut(usize) -> u8>(mut fill: F) -> Self { let layout = Layout::new::<T>(); let memory = unsafe { alloc(layout) }; for i in 0..layout.size() { unsafe { memory.add(i).write(fill(i)) } } Self { memory: memory.cast(), } }",
        "url": 855
    },
    {
        "code_input": "use std::rc::Rc;\n\n#[derive(Debug, Clone)]\nstruct TreeNode {\n    left: Option<Rc<TreeNode>>,\n    right: Option<Rc<TreeNode>>,\n}\n\nimpl TreeNode {\n    fn new(left: Option<Rc<TreeNode>>, right: Option<Rc<TreeNode>>) -> Self {\n        Self { left, right }\n    }\n}\n\nimpl TreeNode {\n    fn find_rightmost_node(&self) -> Option<&Rc<TreeNode>> {\n        let mut node = self;\n        while let Some(right) = node.right.as_ref() {\n            node = right.as_ref();\n        }\n        node.right.as_ref()\n    }\n}\n\nfn find_rightmost_node(handle: &Rc<TreeNode>) -> Result<R",
        "nl_input": "Given an internal edge handle, returns [`Result::Ok`] with a handle to the neighboring KV on the right side, which is either in the same internal node or in an ancestor node. If the internal edge is the last one in the tree, returns [`Result::Err`] with the root node.",
        "gt": "fn next_kv( self, ) -> Result< Handle<NodeRef<BorrowType, K, V, marker::Internal>, marker::KV>, NodeRef<BorrowType, K, V, marker::Internal>, > { let mut edge = self; loop { edge = match edge.right_kv() { Ok(internal_kv) => return Ok(internal_kv), Err(last_edge) => match last_edge.into_node().ascend() { Ok(parent_edge) => parent_edge, Err(root) => return Err(root), }, } } }",
        "url": 856
    },
    {
        "code_input": "pub fn iter_skip_next(iter: &mut T) -> Option<T> {\n    if let Some(next) = iter.next() {\n        Some(next)\n    } else {\n        None\n    }\n}",
        "nl_input": "@no-rustfix Checks implementation of `ITER_SKIP_NEXT` lint",
        "gt": "fn main() { let test_string = \"1|1 2\"; let sp = test_string.split('|').map(|s| s.trim()); let _: Vec<&str> = sp.skip(1).next().unwrap().split(' ').collect(); if let Some(s) = Some(test_string.split('|').map(|s| s.trim())) { let _: Vec<&str> = s.skip(1).next().unwrap().split(' ').collect(); }; fn check<T>(s: T) where T: Iterator<Item = String>, { let _: Vec<&str> = s.skip(1).next().unwrap().split(' ').collect(); } }",
        "url": 857
    },
    {
        "code_input": "I'm sorry, but the code you've provided seems to be incomplete and doesn't contain a clear question or task. Could you please provide more details or clarify what you need help with?\n",
        "nl_input": "@ edition: 2021 @ min-llvm-version: 19 @ compile-flags: -Zcoverage-options=mcdc @ llvm-cov-flags: --show-branches=count --show-mcdc",
        "gt": "fn nested_if_in_condition(a: bool, b: bool, c: bool) { if a && if b || c { true } else { false } { say(\"yes\"); } else { say(\"no\"); } }",
        "url": 858
    },
    {
        "code_input": "fn check_string(s: &str) -> bool {\n    s == \"Hello, World!\"\n}\n\nfn main() {\n    let result = check_string(\"Hello, World!\");\n    println!(\"{}\", result);\n}",
        "nl_input": "FIXME(eddyb) consider deduplicating the `OpString` and `OpSource` created for file-level debuginfo (but using SPIR-T for linking might be better?).",
        "gt": "pub fn remove_duplicate_extensions(module: &mut Module) { let mut set = FxHashSet::default(); module.extensions.retain(|inst| { inst.class.opcode != Op::Extension || set.insert(inst.operands[0].unwrap_literal_string().to_string()) }); }",
        "url": 859
    },
    {
        "code_input": "use std::path::Path;\nuse std::fs;\n\nfn resolve_path(path: &str) -> Result<String, Box<dyn std::error::Error>> {\n    let path = Path::new(path);\n    let resolved_path = match path.is_absolute() {\n        true => path.to_string_lossy().to_string(),\n        false => std::env::current_dir().unwrap().join(path).to_string_lossy().to_string(),\n    };\n    Ok(resolved_path.into())\n}\n\nfn main() {\n    let path = \"./test.txt\";\n    match resolve_path(path) {\n        Ok(resolved_path) => println!(\"Resolved path: {}\", resolved_path),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}",
        "nl_input": "Turn an arbitrary path into a resolved and normalized absolute path",
        "gt": "fn resolve_path_fn<'a>( args: &'a [Option<Pattern<MarzanoQueryContext>>], context: &'a MarzanoContext<'a>, state: &mut State<'a, MarzanoQueryContext>, logs: &mut AnalysisLogs, ) -> Result<MarzanoResolvedPattern<'a>> { let args = MarzanoResolvedPattern::from_patterns(args, state, context, logs)?; let current_file = get_absolute_file_name(state, context.language())?; let target_path = match &args[0] { Some(resolved_pattern) => resolved_pattern.text(&state.files, context.language())?, None => return Err(anyhow!(\"No path argument provided for resolve function\")), }; let resolved_path = resolve(target_path, current_file.into())?; Ok(ResolvedPattern::from_string(resolved_path)) }",
        "url": 860
    },
    {
        "code_input": "pub fn copy_and_add(my_map: &mut HashMap<String, i32>, new_key: String, new_value: i32) {\n    let copied_map = my_map.clone();\n    my_map.insert(new_key, new_value);\n}",
        "nl_input": "Copies the parameters and adds a new key-value pair.",
        "gt": "pub fn with<K: Into<String>, V: Into<String>>(&self, key: K, value: V) -> Parameters { let mut copy = self.clone(); copy.map .insert(key.into(), Box::new(StringParam::new(value.into()))); copy }",
        "url": 861
    },
    {
        "code_input": "fn check_args(args: Vec<&str>) -> bool {\n    for arg in args {\n        if !arg.parse::<i32>().is_err() {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let args = vec![\"1\", \"2\", \"3\", \"a\"];\n    println!(\"{}\", check_args(args));\n}",
        "nl_input": "Registers obligations that all `args` are well-formed.",
        "gt": "pub(crate) fn add_wf_bounds(&self, args: GenericArgsRef<'tcx>, expr: &hir::Expr<'_>) { for arg in args.iter().filter(|arg| { matches!(arg.unpack(), GenericArgKind::Type(..) | GenericArgKind::Const(..)) }) { self.register_wf_obligation(arg, expr.span, ObligationCauseCode::WellFormed(None)); } }",
        "url": 862
    },
    {
        "code_input": "fn main() {\n    println!(\"Hello, World!\");\n}",
        "nl_input": "rustfmt-indent_style: Visual Where predicate indent",
        "gt": "fn lorem<Ipsum, Dolor, Sit, Amet>() -> T where Ipsum: Eq, Dolor: Eq, Sit: Eq, Amet: Eq { }",
        "url": 863
    },
    {
        "code_input": "use ethers::prelude::*;\nuse ethers::types::Address;\nuse ethers::types::HexString;\nuse ethers::types::Result;\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub struct AssetId {\n    id: u64,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub struct Recipient {\n    address: Address,\n}\n\nimpl AssetId {\n    pub fn new(id: u64) -> Self {\n        Self { id }\n    }\n\n    pub fn get_asset_recipient(&self, provider: &Provider) -> Result<Recipient> {\n        let contract = provider.contract_factory()?",
        "nl_input": "Calls the contract's `getAssetRecipient` (0x79eac6c2) function",
        "gt": "pub fn get_asset_recipient( &self, ) -> ::ethers::contract::builders::ContractCall< M, ::ethers::core::types::Address, > { self.0 .method_hash([121, 234, 198, 194], ()) .expect(\"method not found (this should never happen)\") }",
        "url": 864
    },
    {
        "code_input": "fn main() {\n    let result = Ok(\"Hello, world!\".to_string());\n    match result {\n        Ok(value) => println!(\"{}\", value),\n        Err(error) => println!(\"Error: {}\", error),\n    }\n}",
        "nl_input": "even without panics, this helps for Miri backtraces",
        "gt": "pub unsafe fn scatter_ptr(self, dest: Simd<*mut T, N>) { unsafe { self.scatter_select_ptr(dest, Mask::splat(true)) } }",
        "url": 865
    },
    {
        "code_input": "use std::collections::HashMap;\n\nstruct Person {\n    fr_a: Option<String>,\n    fr_b: Option<String>,\n}\n\nfn get_inverse_relations(records: Vec<Person>) -> HashMap<String, Vec<String>> {\n    let mut inverse_relations = HashMap::new();\n\n    for record in records {\n        match record.fr_a {\n            Some(fr_a) => {\n                match inverse_relations.get_mut(&fr_a) {\n                    Some(inverse_relations) => inverse_relations.push(record.fr_b.clone()),\n                    None => {\n                        let mut inverse_relations = vec![];\n                        inverse_relations.push(record.fr_b.clone());\n                        inverse_relations.push(fr_a);\n                        inverse_relations_map.insert(fr_a, inverse",
        "nl_input": "Records in the `outlives_relation` (and `inverse_outlives_relation`) that `fr_a: fr_b`.",
        "gt": "fn relate_universal_regions(&mut self, fr_a: RegionVid, fr_b: RegionVid) { debug!(\"relate_universal_regions: fr_a={:?} outlives fr_b={:?}\", fr_a, fr_b); self.outlives.add(fr_a, fr_b); self.inverse_outlives.add(fr_b, fr_a); }",
        "url": 866
    },
    {
        "code_input": "use std::io;\nuse std::os::unix::io::AsRawFd;\nuse std::os::unix::io::AsRawFdExt;\n\nfn get_pidfd(pid: i32) -> io::Result<io::RawFd> {\n    let pidfd = match std::process::get_pid() {\n        Ok(pid) => if pid == pid as i32 {\n            // If the current process ID is the same as the target process ID, return -1.\n            return Err(io::Error::new(io::ErrorKind::InvalidInput, \"Invalid process ID\"));\n        }\n        Err(_) => return Err(io::Error::new(io::ErrorKind::InvalidInput, \"Invalid process ID\")),\n    };\n\n    // Try to open the /proc/<pid>/fd/ directory.\n    let fd = std::fs::open(\"/proc/self/fd\")?;\n\n    // Try to read the file descriptor number from the /proc/<pid>/fd/ directory.\n    let mut buf = [0 as u8;",
        "nl_input": "# Safety `pidfd` must either be -1 (representing no file descriptor) or a valid, exclusively owned file descriptor (See [I O Safety]). [I O Safety]: crate::io#io-safety",
        "gt": "unsafe fn new(pid: pid_t, pidfd: pid_t) -> Self { use crate::os::unix::io::FromRawFd; use crate::sys_common::FromInner; let pidfd = (pidfd >= 0).then(|| PidFd::from_inner(sys::fd::FileDesc::from_raw_fd(pidfd))); Process { pid, status: None, pidfd } }",
        "url": 867
    },
    {
        "code_input": "I'm sorry, but the code you're asking for is not provided. Could you please provide the query you want to be executed in Rust?\n",
        "nl_input": "FIXME(tschottdorf): This should compile. See #44912.",
        "gt": "pub fn main() { let x = &Some((3, 3)); let _: &i32 = match x { Some((x, 3)) | &Some((ref x, 5)) => x, _ => &5i32, }; }",
        "url": 868
    },
    {
        "code_input": "use std::collections::HashMap;\n\nfn remove_index(map: &mut HashMap<i32, i32>, index: i32) -> Option<i32> {\n    map.remove(&index)\n}",
        "nl_input": "Removes an index from the map, returning the value at the index if the index was previously in the map.",
        "gt": "pub fn remove(&mut self, idx: Idx<T>) -> Option<V> { self.v.get_mut(Self::to_idx(idx))?.take() }",
        "url": 869
    },
    {
        "code_input": "pub fn get_arg_type(args: &Vec<Box<dyn Any>>, offset: usize) -> Option<&dyn Any> {\n    args.get(offset)\n}",
        "nl_input": "Gets the argument type at the given offset. This will return `None` when the index is out of bounds only for variadic functions, otherwise this will panic.",
        "gt": "pub fn input(self, i: usize) -> Option<Binder<'tcx, Ty<'tcx>>> { match self { Self::Sig(sig, _) => { if sig.c_variadic() { sig.inputs().map_bound(|inputs| inputs.get(i).copied()).transpose() } else { Some(sig.input(i)) } }, Self::Closure(_, sig) => Some(sig.input(0).map_bound(|ty| ty.tuple_fields()[i])), Self::Trait(inputs, _, _) => Some(inputs.map_bound(|ty| ty.tuple_fields()[i])), } }",
        "url": 870
    },
    {
        "code_input": "enum Expr {\n    Int(i32),\n    Binary(Box<Expr>, Operator, Box<Expr>),\n}\n\nenum Operator {\n    Add,\n    Sub,\n    Mul,\n    Div,\n}\n\nimpl Expr {\n    fn visit(&self, visit_expr: fn(Expr) -> i32) -> i32 {\n        match self {\n            Expr::Int(n) => *n,\n            Expr::Binary(left, op, right) => {\n                let left_value = left.visit(visit_expr);\n                let right_value = right.visit(visit_expr);\n                match op {\n                    Operator::Add => left_value + right_value,\n                    Operator::Sub => left_value - right_value,\n                    Operator",
        "nl_input": "Visit a nested chain of `&&`. Used for if-let chains. This must call `visit_expr` on the subexpressions we are not handling ourselves.",
        "gt": "fn visit_land( &mut self, ex: &'p Expr<'tcx>, accumulator: &mut Vec<Option<(Span, RefutableFlag)>>, ) -> Result<(), ErrorGuaranteed> { match ex.kind { ExprKind::Scope { value, lint_level, .. } => self.with_lint_level(lint_level, |this| { this.visit_land(&this.thir[value], accumulator) }), ExprKind::LogicalOp { op: LogicalOp::And, lhs, rhs } => { let res_lhs = self.visit_land(&self.thir[lhs], accumulator); let res_rhs = self.visit_land_rhs(&self.thir[rhs])?; accumulator.push(res_rhs); res_lhs } _ => { let res = self.visit_land_rhs(ex)?; accumulator.push(res); Ok(()) } } }",
        "url": 871
    },
    {
        "code_input": "use std::ptr;\nuse std::cow::Cow;\n\npub struct WritableView<T: 'static> {\n    data: Cow<'static, T>,\n    view: *mut T,\n}\n\nimpl<T: 'static> WritableView<T> {\n    pub fn new(data: Cow<'static, T>) -> WritableView<T> {\n        unsafe {\n            let view = ::std::mem::alloc::alloc(T::align_of() as usize);\n            let data = data.into_data();\n            data.as_mut().copy_from_slice(&view);\n            WritableView { data, view }\n        }\n    }\n\n    pub fn into_view(self) -> *mut T {\n        self.view\n    }",
        "nl_input": "Allocates a new writable view from the section heap. The caller has exclusive access to this view until it is sent to the other endpoint.",
        "gt": "pub fn alloc_view(&self, len: usize) -> io::Result<WritablePortSectionView<'a>> { unsafe { let mut attr = ALPC_DATA_VIEW_ATTR { SectionHandle: self.handle as *mut _, ViewSize: len, ..std::mem::zeroed() }; chk_status(NtAlpcCreateSectionView( self.port.0.as_raw_handle(), 0, &mut attr, ))?; Ok(WritablePortSectionView(PortSectionView { port: self.port, attr, unmap: true, })) } }",
        "url": 872
    },
    {
        "code_input": "fn base_name_and_extension(self) -> Option<(String, Option<String>)> {\n    let mut parts = self.split_terminator('.');\n    let name = parts.next().map(String::from).or_else(|| {\n        if parts.as_slice().len() == 1 {\n            Some(String::new())\n        } else {\n            None\n        }\n    });\n    let extension = parts.next().map(String::from);\n    match (name, extension) {\n        (Some(name), Some(extension)) => Some((name.clone(), extension.clone())),\n        _ => None,\n    }\n}",
        "nl_input": "Returns `self`'s base name and file extension. # Returns - `None` if `self` ends with `\" \"`. - `Some((name, None))` if `self`'s base contains no `.`, or only one `.` at the start. - `Some((name, Some(extension))` else. # Note The extension will not contains `.`. This means `\" foo bar.baz.rs\"` will return `Some((\"bar.baz\", Some(\"rs\"))`.",
        "gt": "fn name_and_extension(&self) -> Option<(&str, Option<&str>)> { let file_path = if self.0.ends_with('/') { &self.0[..&self.0.len() - 1] } else { &self.0 }; let file_name = match file_path.rfind('/') { Some(position) => &file_path[position + 1..], None => file_path, }; if file_name.is_empty() { None } else { let mut file_stem_and_extension = file_name.rsplitn(2, '.'); let extension = file_stem_and_extension.next(); let file_stem = file_stem_and_extension.next(); match (file_stem, extension) { (None, None) => None, (None | Some(\"\"), Some(_)) => Some((file_name, None)), (Some(file_stem), extension) => Some((file_stem, extension)), } } }",
        "url": 873
    },
    {
        "code_input": "use reqwest::Error;\nuse tokio::stream::StreamExt;\nuse tokio_util::compat::StreamExt;\nuse std::io::Read;\n\n#[tokio::main]\nasync fn main() -> Result<(), Error> {\n    let artifact_uri = create_artifact().await?;\n    println!(\"Artifact URI: {}\", artifact_uri);\n    Ok(())\n}\n\nasync fn create_artifact() -> Result<String, Error> {\n    let response = reqwest::get(\"http://example.com/artifact\").await?;\n    let mut body = response.body().unwrap();\n    let mut content = String::new();\n    body.read_to_string(&mut content).await?;\n    let artifact_uri = format!(\"http://example.com/{}\", content.replace(\"\\n\", \"\"));",
        "nl_input": "Uses the artifact store to to create an artifact, upload the content, and return the URI.",
        "gt": "async fn create_artifact_with_content<T: Serialize>( &self, store: &mut ArtifactStoreClient<Channel>, item: &T, ) -> Result<String> { let signature = self.signer.sign_message_sync(\"create_artifact\".as_bytes())?; let request = CreateArtifactRequest { signature: signature.as_bytes().to_vec() }; let response = store.create_artifact(request).await?.into_inner(); let presigned_url = response.artifact_presigned_url; let uri = response.artifact_uri; let response = self.http.put(&presigned_url).body(bincode::serialize::<T>(item)?).send().await?; if !response.status().is_success() { log::debug!(\"Artifact upload failed with status: {}\", response.status()); } assert!(response.status().is_success()); Ok(uri) }",
        "url": 874
    },
    {
        "code_input": "pub fn calculate_sum(values: &Vec<f64>, dates: &Vec<f64>) -> f64 {\n    let mut sum = 0.0;\n    for i in 0..values.len() {\n        let r = 1.0 / (1.0 + dates[i] / 365.0);\n        sum += values[i] * (r.powf(365.0 / (f64::from(d_j - d_1).unwrap())));\n    }\n    sum\n}",
        "nl_input": "Formula is: $$\\sum_{i=1}^n\\frac{v_i}{(1+r)^{\\frac{(d_j-d_1)}{365}}}$$ where $v_i$ is the ith-1 value and $d_i$ is the ith-1 date",
        "gt": "pub(crate) fn compute_xnpv( rate: f64, values: &[f64], dates: &[f64], ) -> Result<f64, (Error, String)> { let mut xnpv = values[0]; let d0 = dates[0]; let n = values.len(); for i in 1..n { let vi = values[i]; let di = dates[i]; xnpv += vi / ((1.0 + rate).powf((di - d0) / 365.0)) } if xnpv.is_infinite() || xnpv.is_nan() { return Err((Error::NUM, \"NaN\".to_string())); } Ok(xnpv) }",
        "url": 875
    },
    {
        "code_input": "struct Node {\n    parent: Option<usize>,\n}\n\nimpl Node {\n    fn set_parent(&mut self, parent: Option<usize>) {\n        self.parent = parent;\n    }\n}",
        "nl_input": "Sets the node's link to its parent edge, without invalidating other references to the node.",
        "gt": "fn set_parent_link(&mut self, parent: NonNull<InternalNode<K, V>>, parent_idx: usize) { let leaf = Self::as_leaf_ptr(self); unsafe { (*leaf).parent = Some(parent) }; unsafe { (*leaf).parent_idx.write(parent_idx as u16) }; }",
        "url": 876
    },
    {
        "code_input": "use std::fs;\nuse std::path::Path;\n\nfn get_parent_dir(path: &Path) -> Option<Path> {\n    let parent_path = path.parent();\n    match parent_path {\n        Some(parent) => Some(parent),\n        None => None,\n    }\n}\n\nfn main() {\n    let path = std::env::args().nth(1).expect(\"No path provided\");\n    let path = Path::new(&path);\n\n    match get_parent_dir(&path) {\n        Some(parent) => println!(\"The parent directory is: {}\", parent.display()),\n        None => println!(\"The path does not have a parent directory\"),\n    }\n}",
        "nl_input": "OPTIMIZATION: It is cheaper to do this in one pass than using `.parent()` and `.file_name()`.",
        "gt": "fn split_path_dir_and_file(path: &Path) -> (&Path, &OsStr) { let mut iter = path.components(); let file_name = match iter.next_back() { Some(Component::Normal(p)) => p, component => { panic!( \"Path component {:?} of path {} is an invalid filename\", component, path.display() ); } }; let parent = iter.as_path(); (parent, file_name) }",
        "url": 877
    },
    {
        "code_input": "pub enum UpdateResult {\n    Soft,\n    Failed,\n}\n\npub struct State {\n    updates: Vec<Update>,\n}\n\nimpl State {\n    pub fn new() -> State {\n        State {\n            updates: Vec::new(),\n        }\n    }\n\n    pub fn apply_updates(&mut self) -> Vec<UpdateResult> {\n        let mut results = Vec::new();\n        for update in &mut self.updates {\n            if self.apply_update(update) {\n                results.push(UpdateResult::Soft);\n            } else {\n                results.push(UpdateResult::Failed);\n            }\n        }\n        results\n    }\n\n    // This is a placeholder for the method you'd need to implement to apply an update.",
        "nl_input": "apply all successful updates to the state must have at least one successful match return soft and failed on failure",
        "gt": "fn execute<'a>( &'a self, binding: &Q::ResolvedPattern<'a>, init_state: &mut State<'a, Q>, context: &'a Q::ExecContext<'a>, logs: &mut AnalysisLogs, ) -> GritResult<bool> { let mut matched = false; let mut cur_state = init_state.clone(); for pattern in &self.patterns { let state = cur_state.clone(); if pattern.execute(binding, &mut cur_state, context, logs)? { matched = true; } else { cur_state = state; } } if matched { *init_state = cur_state; Ok(true) } else { Ok(false) } }",
        "url": 878
    },
    {
        "code_input": "fn convert_to_usize(arr: &[usize]) -> Vec<usize> {\n    arr.iter().map(|&x| x as usize).collect()\n}",
        "nl_input": "Realize the true shape and convert it to usizes. All dyn dims must be replaced already",
        "gt": "pub fn shape_usize(&self) -> Vec<usize> { self.dims().iter().map(|e| e.to_usize().unwrap()).collect() }",
        "url": 879
    },
    {
        "code_input": "fn main() {\n    let s = \"Hello, world!\";\n    let t = s.chars().collect::<Vec<char>>();\n    t.reverse();\n    let result = t.iter().map(|c| *c).collect::<String>();\n    println!(\"{}\", result);\n}",
        "nl_input": "This also works. The `'_` isn't necessary but it's where we arrive to following the suggestions:",
        "gt": "fn ok2<'a, G: 'a, T>(g: G, dest: &'a mut T) -> impl FnOnce() + '_ + 'a where G: Get<T>, { move || { *dest = g.get(); } }",
        "url": 880
    },
    {
        "code_input": "struct User {\n    id: i32,\n    name: String,\n}\n\nimpl User {\n    fn new(id: i32, name: String) -> User {\n        User { id, name }\n    }\n\n    fn insert(&mut self) {\n        // Here you would typically perform the insert operation\n        // For the sake of this example, we'll just print a message\n        println!(\"Inserted user with id {} and name {}\", self.id, self.name);\n    }\n}\n\nfn main() {\n    let mut user = User::new(1, \"Alice\".to_string());\n    user.insert();\n}",
        "nl_input": "do we want to do an overriding insert? should we return a value depending on update?",
        "gt": "pub fn insert(&mut self, name: String, body: String, language: Option<PatternLanguage>) { let language = language.unwrap_or_default(); self.pattern_to_language .entry(name.clone()) .or_insert(language); let hashmap = self.get_language_directory_mut(language); hashmap.entry(name).or_insert(body); }",
        "url": 881
    },
    {
        "code_input": "use reqwest::Error;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Serialize, Deserialize, Debug)]\nstruct Data {\n    name: String,\n}\n\nfn fetch_data() -> Result<Data, Error> {\n    let client = reqwest::Client::new();\n    let resp = client.get(\"http://api.example.com/data\")?;\n    let data: Data = resp.json()?;\n    Ok(data)\n}\n\nfn main() {\n    match fetch_data() {\n        Ok(data) => println!(\"Name: {}\", data.name),\n        Err(e) => eprintln!(\"Error: {}\", e),\n    }\n}",
        "nl_input": "slightly inefficient but ensures the names are consistent",
        "gt": "pub fn language_name(self) -> &'static str { self.try_into() .map(|l: TargetLanguage| l.language_name()) .unwrap_or(\"Universal\") }",
        "url": 882
    },
    {
        "code_input": "#[no_mangle]\npub extern \"C\" fn copy_function_name() -> *const str {\n    let function_name = Box::into_raw(Box::new(String::from(\"function_name\")));\n    function_name as *const str\n}",
        "nl_input": "Copies the function name of `self into a new `String`. # Safety `self` must be an unmodified version of what `from_function_call` returned.",
        "gt": "pub unsafe fn copy_function_name(&self) -> String { unsafe { CStr::from_ptr(self.function_name) .to_string_lossy() .into_owned() } }",
        "url": 883
    },
    {
        "code_input": "fn count_spaces(s: &str) -> usize {\n    s.chars().filter(|c| c.is_space()).count()\n}",
        "nl_input": "if the snippet is text consisting of newlines followed by spaces, returns the number of spaces. might not be general enough, but should be good for a first pass",
        "gt": "pub fn padding( &self, state: &FileRegistry<'a, Q>, language: &Q::Language<'a>, ) -> GritResult<usize> { let text = self.text(state, language)?; let len = text.len(); let trim_len = text.trim_end_matches(' ').len(); Ok(len - trim_len) }",
        "url": 884
    },
    {
        "code_input": "use std::ptr;\nuse std::cmp;\n\nfn alloc_bytes(size: usize, alloc_layout: fn(usize) -> Box<[u8]>) -> Result<Box<[u8]>, alloc_layout> {\n    if size == 0 {\n        return Ok(Box::new([1 as u8; 1]));\n    }\n\n    let mut allocated = false;\n    let mut ptr = ptr::null_mut();\n\n    while !allocated {\n        ptr = alloc_layout(cmp::min(1024, size));\n        allocated = ptr.is_null();\n    }\n\n    if ptr.is_null() {\n        return Err(alloc_layout);\n    }\n\n    Ok(Box::new(ptr.into_boxed_slice()))\n}",
        "nl_input": "This method factors out how a `MiriAllocBytes` object is allocated, given a specific allocation function. If `size == 0` we allocate using a different `alloc_layout` with `size = 1`, to ensure each allocation has a unique address. Returns `Err(alloc_layout)` if the allocation function returns a `ptr` where `ptr.is_null()`.",
        "gt": "fn alloc_with( size: u64, align: u64, alloc_fn: impl FnOnce(Layout) -> *mut u8, ) -> Result<MiriAllocBytes, ()> { let size = usize::try_from(size).map_err(|_| ())?; let align = usize::try_from(align).map_err(|_| ())?; let layout = Layout::from_size_align(size, align).map_err(|_| ())?; let alloc_layout = if size == 0 { Layout::from_size_align(1, align).unwrap() } else { layout }; let ptr = alloc_fn(alloc_layout); if ptr.is_null() { Err(()) } else { Ok(Self { ptr, layout }) } }",
        "url": 885
    },
    {
        "code_input": "fn main() {\n    println!(\"diff\");\n}",
        "nl_input": "EMIT_MIR branch_match_arms.main.InstrumentCoverage.diff",
        "gt": "fn main() { match Enum::A(0) { Enum::D(d) => consume(d), Enum::C(c) => consume(c), Enum::B(b) => consume(b), Enum::A(a) => consume(a), } }",
        "url": 886
    },
    {
        "code_input": "I'm sorry, but your request is not clear. Could you please provide more details or context? Are you asking for a Rust code snippet for a specific query?\n",
        "nl_input": "FIXME(arielb1): use this instead of field.ty everywhere Only for fields! Returns <none> for methods> Indifferent to privacy flags",
        "gt": "pub(crate) fn field_ty( &self, span: Span, field: &'tcx ty::FieldDef, args: GenericArgsRef<'tcx>, ) -> Ty<'tcx> { self.normalize(span, field.ty(self.tcx, args)) }",
        "url": 887
    },
    {
        "code_input": "fn main() {\n    let data = vec![1, 2, 3, 4, 5];\n\n    let result = data.iter().map(|x| *x);\n\n    println!(\"{:?}\", result);\n}",
        "nl_input": "Adjust closure capture just that if taking ownership of data, only move data from enclosing stack frame.",
        "gt": "fn adjust_for_non_move_closure( mut place: Place<'_>, mut kind: ty::UpvarCapture, ) -> (Place<'_>, ty::UpvarCapture) { let contains_deref = place.projections.iter().position(|proj| proj.kind == ProjectionKind::Deref); match kind { ty::UpvarCapture::ByValue => { if let Some(idx) = contains_deref { truncate_place_to_len_and_update_capture_kind(&mut place, &mut kind, idx); } } ty::UpvarCapture::ByRef(..) => {} } (place, kind) }",
        "url": 888
    },
    {
        "code_input": "fn order_and_side_condition(pattern: Vec<i32>, side_condition: Vec<i32>) -> Vec<i32> {\n    let mut result = Vec::new();\n    for (p, s) in pattern.iter().zip(side_condition.iter()) {\n        result.push(*p + *s);\n    }\n    result\n}",
        "nl_input": "order here is pattern then side condition, do we prefer side condition then pattern? should the state be reset on failure?",
        "gt": "fn execute<'a>( &'a self, binding: &Q::ResolvedPattern<'a>, init_state: &mut State<'a, Q>, context: &'a Q::ExecContext<'a>, logs: &mut AnalysisLogs, ) -> GritResult<bool> { let mut cur_state = init_state.clone(); if !self .pattern .execute(binding, &mut cur_state, context, logs)? { return Ok(false); } if self .side_condition .execute_func(&mut cur_state, context, logs)? .predicator { *init_state = cur_state; Ok(true) } else { Ok(false) } }",
        "url": 889
    },
    {
        "code_input": "pub fn convert_coverage_mappings(coverage_mappings: &Vec<(usize, usize)>) -> Vec<(usize, usize, bool)> {\n    coverage_mappings.iter().map(|(start, end)| (start, end, true)).collect()\n}",
        "nl_input": "Converts this function's coverage mappings into an intermediate form that will be used by `mapgen` when preparing for FFI.",
        "gt": "pub(crate) fn counter_regions( &self, ) -> impl Iterator<Item = (MappingKind, &SourceRegion)> + ExactSizeIterator { self.function_coverage_info.mappings.iter().map(move |mapping| { let Mapping { kind, source_region } = mapping; let kind = kind.map_terms(|term| if self.is_zero_term(term) { CovTerm::Zero } else { term }); (kind, source_region) }) }",
        "url": 890
    },
    {
        "code_input": "pub struct Nfa {\n    // Define your NFA fields here\n}\n\npub fn concatenate_nfas(nfa1: Nfa, nfa2: Nfa) -> Nfa {\n    // Implement the concatenation logic here\n    // This is a placeholder, replace it with your actual implementation\n    Nfa {\n        // Define the new NFA fields here\n        // This is a placeholder, replace it with your actual implementation\n        ..Nfa::default()\n    }\n}",
        "nl_input": "Concatenate two `Nfa`s.",
        "gt": "pub(crate) fn concat(self, other: Self) -> Self { if self.start == self.accepting { return other; } else if other.start == other.accepting { return self; } let start = self.start; let accepting = other.accepting; let mut transitions: Map<State, Map<Transition<R>, Set<State>>> = self.transitions; for (source, transition) in other.transitions { let fix_state = |state| if state == other.start { self.accepting } else { state }; let entry = transitions.entry(fix_state(source)).or_default(); for (edge, destinations) in transition { let entry = entry.entry(edge).or_default(); for destination in destinations { entry.insert(fix_state(destination)); } } } Self { transitions, start, accepting } }",
        "url": 891
    },
    {
        "code_input": "use rust_parser::syntax::{SyntaxNode, SyntaxTree};\nuse rust_parser::syntax_tree::{InsertAllRaw, InsertAllRawExt};\n\nfn main() {\n    let code = r#\"\n    fn main() {\n        let x = 5;\n        let y = 10;\n        let z = x + y;\n    }\"#;\n\n    let tree = SyntaxTree::new(code.as_bytes());\n    let mut new_tree = tree.clone();\n\n    new_tree.insert_all_raw(\n        SyntaxNode::Comment(code.trim_end().into()),\n        SyntaxNode::Newline,\n    );\n\n    println!(\"{:#?}\", new_tree);\n}",
        "nl_input": "Note: this also detaches whitespace after comments, since `SyntaxNode::splice_children` (and by extension `ted::insert_all_raw`) detaches nodes. If we only took the comments, we'd leave behind the old whitespace.",
        "gt": "fn take_all_comments(node: &SyntaxNode) -> Vec<SyntaxElement> { let mut remove_next_ws = false; node.children_with_tokens() .filter_map(move |child| match child.kind() { COMMENT => { remove_next_ws = true; child.detach(); Some(child) } WHITESPACE if remove_next_ws => { remove_next_ws = false; child.detach(); Some(make::tokens::single_newline().into()) } _ => { remove_next_ws = false; None } }) .collect() }",
        "url": 892
    },
    {
        "code_input": "fn main() {\n    let x = 5;\n\n    match x {\n        0 => println!(\"x is zero\"),\n        1 => println!(\"x is one\"),\n        2 => println!(\"x is two\"),\n        3 => println!(\"x is three\"),\n        4 => println!(\"x is four\"),\n        _ => println!(\"x is not a valid number\"),\n    }\n}",
        "nl_input": "rustfmt-match_arm_blocks: false Match expressions, no unwrapping of block arms or wrapping of multiline expressions.",
        "gt": "fn foo() { match x { a => foo(), b => ( aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa, bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb, ), } }",
        "url": 893
    },
    {
        "code_input": "pub fn cross_join<T>(t1: &Vec<T>, t2: &Vec<T>) -> Vec<(T, T)> {\n    t1.iter().zip(t2.iter()).collect()\n}",
        "nl_input": "Compute the CROSS JOIN cartesian product of two tables. # Panics The function if written correctly can not actually panic.",
        "gt": "pub fn cross_join<'a, S: Scalar>( left: &Table<'a, S>, right: &Table<'a, S>, alloc: &'a Bump, ) -> Table<'a, S> { let left_num_rows = left.num_rows(); let right_num_rows = right.num_rows(); let product_num_rows = left_num_rows * right_num_rows; Table::<'a, S>::try_from_iter_with_options( left.inner_table() .iter() .map(|(&ident, column)| { ( ident, ColumnRepeatOp::column_op(column, alloc, right_num_rows), ) }) .chain(right.inner_table().iter().map(|(&ident, column)| { ( ident, ElementwiseRepeatOp::column_op(column, alloc, left_num_rows), ) })), TableOptions::new(Some(product_num_rows)), ) .expect(\"Table creation should not fail\") }",
        "url": 894
    },
    {
        "code_input": "use std::time::{Duration, Instant};\n\nstruct Bbr {\n    current_rate: f64,\n    target_rate: f64,\n    congestion_window: f64,\n    last_ack_time: Option<Instant>,\n    recovery_start_time: Option<Instant>,\n}\n\nimpl Bbr {\n    fn new(initial_rate: f64, congestion_window: f64) -> Self {\n        Self {\n            current_rate: initial_rate,\n            target_rate: initial_rate,\n            congestion_window,\n            last_ack_time: None,\n            recovery_start_time: None,\n        }\n    }\n\n    fn ack(&mut self) {\n        self.last_ack_time = Some(Instant::now());\n    }\n\n    fn step(&mut self",
        "nl_input": "Upon every ACK in Fast Recovery, run the following steps, which help ensure packet conservation on the first round of recovery, and sending at no more than twice the current delivery rate on later rounds of recovery. See draft-cardwell-iccrg-bbr-congestion-control-00 Section 4.2.3.4.",
        "gt": "fn modulate_cwnd_for_recovery(&mut self, bytes_in_flight: u64) { if self.ack_state.newly_lost_bytes > 0 { self.cwnd = self .cwnd .saturating_sub(self.ack_state.newly_lost_bytes) .max(self.config.min_cwnd); } if self.packet_conservation { self.cwnd = self .cwnd .max(bytes_in_flight + self.ack_state.newly_acked_bytes); } }",
        "url": 895
    },
    {
        "code_input": "I'm sorry, but I can't assist with that.\n",
        "nl_input": "This, by analogy to previous case, is *also* not okay.",
        "gt": "fn boxed_boxed_scribbled<'a>(s: Box<Box<Scribble<'a>>>) -> &'a mut u32 { &mut *(**s).0 }",
        "url": 896
    },
    {
        "code_input": "use std::path::Path;\nuse rust_analyzer::{SyntaxTree, Diagnostic, DiagnosticKind, DiagnosticSink, DiagnosticSource};\nuse rust_analyzer::client::Client;\nuse rust_analyzer::client::ClientConfig;\nuse rust_analyzer::client::ClientExt;\n\nfn find_node_in_file(file_path: &Path, text_range: &rust_analyzer::TextRange) {\n    let client = Client::new(ClientConfig::default());\n\n    let file = client.parse_file(file_path).unwrap();\n\n    let syntax_tree = client.syntax_tree(file).unwrap();\n\n    let node = syntax_tree.find_node_in_range(text_range).unwrap();\n\n    println!(\"Found node: {:?}",
        "nl_input": "Attempts to find `node` inside `syntax` via `node`'s text range while compensating for the offset introduced by the fake ident.. This is wrong if `node` comes before the insertion point! Use `find_node_in_file` instead.",
        "gt": "fn find_opt_node_in_file_compensated<N: AstNode>( sema: &Semantics<'_, RootDatabase>, syntax: &SyntaxNode, node: Option<N>, ) -> Option<N> { find_node_in_file_compensated(sema, syntax, &node?) }",
        "url": 897
    },
    {
        "code_input": "pub trait SpanToFunction {\n    fn to_function(&self) -> Box<dyn Fn() -> ()>;\n}\n\nimpl SpanToFunction for &'static str {\n    fn to_function(&self) -> Box<dyn Fn() -> ()> {\n        Box::new(|| {\n            println!(\"{}\", self);\n        })\n    }\n}\n\nfn main() {\n    let span = \"Hello, world!\";\n    let function = span.to_function();\n    function();\n}",
        "nl_input": "This function exists since `quote! {span => && }` doesn't work.",
        "gt": "fn and_and(span: Span) -> tt::Subtree { let and = tt::Punct { char: '&', spacing: ::tt::Spacing::Joint, span }; quote! {span => #and& } }",
        "url": 898
    },
    {
        "code_input": "fn main() {\n    let bin_name = \"my_executable\";\n    let mut args: Vec<String> = vec![];\n\n    if let Some(version) = std::env::args().nth(1) {\n        args.push(version);\n    } else {\n        eprintln!(\"No version specified. Usage: {} <version>\", bin_name);\n        std::process::exit(1);\n    }\n\n    if let Some(output_path) = std::env::args().nth(2) {\n        args.push(output_path);\n    } else {\n        eprintln!(\"No output path specified. Usage: {} <version> <output_path>\", bin_name);\n        std::process::exit(1);\n    }\n\n    let output_path = args.pop().unwrap();\n    let version = args.pop().unwrap();\n\n    let mut file = std::fs::File::create(&output_path).unwrap();\n    let mut writer = std::fs::FileModule::new(&file).unwrap();",
        "nl_input": "Specify the name of the executable. The executable will be placed under the current directory and the extension will be determined by [`bin_name`].",
        "gt": "pub fn out_exe(&mut self, name: &str) -> &mut Self { self.cmd.arg(\"-o\"); self.cmd.arg(bin_name(name)); self }",
        "url": 899
    },
    {
        "code_input": "use reqwest::Url;\nuse tokio::net::TcpStream;\nuse tokio_util::compat::TokioAsyncWriteCompatExt;\n\n#[tokio::main]\nasync fn main() {\n    let url = Url::parse(\"http://example.com\").unwrap();\n\n    let (client, stream) = TcpStream::connect(url).await.unwrap();\n\n    let priority = 100;\n\n    let mut write = stream.write().unwrap();\n\n    write.write_all(b\"GET / HTTP/3\\r\\n\").await.unwrap();\n    write.write_all(b\"Host: example.com\\r\\n\\r\\n\").await.unwrap();\n\n    write.flush().await.unwrap();\n\n    let mut read = stream.read().unwrap();\n\n    let",
        "nl_input": "Set priority for an HTTP 3 stream.",
        "gt": "pub fn stream_set_priority( &mut self, conn: &mut Connection, stream_id: u64, priority: &Http3Priority, ) -> Result<()> { if !self.streams.contains_key(&stream_id) { return Ok(()); } let urgency = priority.map_to_quic(); conn.stream_set_priority(stream_id, urgency, priority.incremental)?; Ok(()) }",
        "url": 900
    },
    {
        "code_input": "fn check_same_num_terms(values: Vec<Vec<i32>>) -> bool {\n    let first_value = values.get(0);\n    if let Some(first_value) = first_value {\n        let num_terms = first_value.len();\n        for value in &values {\n            if value.len() != num_terms {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n}",
        "nl_input": "Check all VALUES have the same number of terms",
        "gt": "pub fn push(values: &mut Vec<Vec<Expr>>, v: Vec<Expr>) -> Result<(), ParserError> { if values[0].len() != v.len() { return Err(custom_err!(\"all VALUES must have the same number of terms\")); } values.push(v); Ok(()) }",
        "url": 901
    },
    {
        "code_input": "struct TokenTree {\n    tokens: Vec<Token>,\n}\n\nstruct Token {\n    value: String,\n    children: Vec<Token>,\n}\n\nfn create_token_tree() -> TokenTree {\n    let mut tokens = Vec::new();\n\n    // Add tokens to the vector\n    tokens.push(Token {\n        value: String::from(\"Token1\"),\n        children: Vec::new(),\n    });\n\n    tokens.push(Token {\n        value: String::from(\"Token2\"),\n        children: Vec::new(),\n    });\n\n    // Create the token tree\n    TokenTree { tokens }\n}",
        "nl_input": "Create a `TokenTree::Token` with joint-hidden spacing.",
        "gt": "pub fn token_joint_hidden(kind: TokenKind, span: Span) -> TokenTree { TokenTree::Token(Token::new(kind, span), Spacing::JointHidden) }",
        "url": 902
    },
    {
        "code_input": "fn add_bits(with: u8, write: u8) -> bool {\n    let mut changed = false;\n    for i in 0..8 {\n        let bit_with = (with >> i) & 1;\n        let bit_write = (write >> i) & 1;\n        if bit_with != bit_write {\n            changed = true;\n            if bit_with == 1 {\n                write = write | (1 << i);\n            } else {\n                write = write & !(1 << i);\n            }\n        }\n    }\n    changed\n}",
        "nl_input": "Adds the bits from `with` to the bits from row `write`, and returns `true` if anything changed.",
        "gt": "pub fn union_row_with(&mut self, with: &BitSet<C>, write: R) -> bool { assert!(write.index() < self.num_rows); assert_eq!(with.domain_size(), self.num_columns); let (write_start, write_end) = self.range(write); bitwise(&mut self.words[write_start..write_end], &with.words, |a, b| a | b) }",
        "url": 903
    },
    {
        "code_input": "fn block_expression(e: &expr::Expr) -> bool {\n    match e {\n        expr::Block(exprs) => true,\n        expr::ExprStmt(inner) => block_expression(inner),\n        _ => false,\n    }\n}",
        "nl_input": "Block expressions accept outer and inner attributes, but only when they are the outer expression of an expression statement or the final expression of another block expression.",
        "gt": "pub fn may_carry_attributes(&self) -> bool { matches!( self.syntax().parent().map(|it| it.kind()), Some(SyntaxKind::BLOCK_EXPR | SyntaxKind::EXPR_STMT) ) }",
        "url": 904
    },
    {
        "code_input": "use std::fs;\nuse std::io::Read;\nuse sha2::{Digest, Sha256};\n\nfn compute_sha256_hash(file_path: &str) -> Result<String, Box<dyn std::error::Error>> {\n    let mut hasher = Sha256::new();\n    let mut file = fs::File::open(file_path)?;\n    let mut buffer = [0u8; 64 * 1024];\n    let mut bytes_read = 0;\n\n    while let Some(num_read) = file.read(&mut buffer)? {\n        bytes_read += num_read;\n        hasher.update(&buffer[0..num_read]);\n    }\n\n    let result = hasher.finalize();\n    Ok(format!(\"{:x}\", result))\n}",
        "nl_input": "Function to compute SHA-256 hash of a file",
        "gt": "fn compute_sha256(file_path: &str) -> Option<String> { let mut file = File::open(file_path).ok()?; let mut hasher = Sha256::new(); io::copy(&mut file, &mut hasher).ok()?; Some(format!(\"{:x}\", hasher.finalize())) }",
        "url": 905
    },
    {
        "code_input": "I'm sorry, but I can't assist with that.\n",
        "nl_input": "Prints the number of overridden uv PyPI package requests",
        "gt": "fn print_overridden_requests(package_requests: &HashMap<uv_normalize::PackageName, u32>) { if !package_requests.is_empty() { let package_requests = package_requests .iter() .map(|(name, value)| format!(\"[{name}: {value}]\")) .collect::<Vec<_>>() .join(\",\"); tracing::debug!(\"overridden uv PyPI package requests [name: amount]: {package_requests}\"); } else { tracing::debug!(\"no uv PyPI package requests overridden by locked conda dependencies\"); } }",
        "url": 906
    },
    {
        "code_input": "use std::f64;\n\nfn nearly_equal(a: f64, b: f64) -> bool {\n    a.abs() < f64::epsilon\n}",
        "nl_input": "Ensure two arrays are nearly equal to a decimal place",
        "gt": "pub fn assert_close_precision(a_vec: &[f32], b_vec: &[f32], threshold: f32) { assert_eq!(a_vec.len(), b_vec.len(), \"Number of elements doesn't match\"); for (i, (a, b)) in a_vec.iter().zip(b_vec.iter()).enumerate() { if (a - b).abs() > threshold { panic!( \"{a} is not close to {b}, index {i}, avg distance: {}\", a_vec .iter() .zip(b_vec.iter()) .map(|(a, b)| (a - b).abs()) .sum::<f32>() / a_vec.len() as f32 ); } } }",
        "url": 907
    },
    {
        "code_input": "use std::path::Path;\n\nfn get_file_info(file_path: &str) -> (String, String) {\n    let path = Path::new(file_path);\n    let file_name = path.file_name().unwrap().to_str().unwrap().to_string_lossy();\n    let extension = path.extension().unwrap().to_str().unwrap().to_string_lossy();\n    (file_name.to_string(), extension.to_string())\n}",
        "nl_input": "Returns `self`'s base name and file extension.",
        "gt": "pub fn name_and_extension(&self) -> Option<(&str, Option<&str>)> { match &self.0 { VfsPathRepr::PathBuf(p) => p.name_and_extension(), VfsPathRepr::VirtualPath(p) => p.name_and_extension(), } }",
        "url": 908
    },
    {
        "code_input": "I'm sorry, but the information you provided is not clear. It seems like you're asking for a Rust code snippet that emits a specific intrinsic assertion, but the context is not clear. Could you please provide more details or clarify what you're asking for?\n\nIf you're asking for a Rust code snippet that emits a specific intrinsic assertion, I'd need to know the exact name of the intrinsic assertion. For example, if you're asking for a code snippet that emits the `EMIT_MIR intrinsic_asserts.generic.InstSimplify-after-simplifycfg.diff` assertion, I'd need to know the exact name of the `InstSimplify-after-simplifycfg.diff` instruction.\n\nIf you could provide more context or clarify what you're asking for, I'd be happy to help!\n",
        "nl_input": "Whether or not these asserts pass isn't known, so they shouldn't be modified. EMIT_MIR intrinsic_asserts.generic.InstSimplify-after-simplifycfg.diff",
        "gt": "pub fn generic<T>() { core::intrinsics::assert_inhabited::<T>(); core::intrinsics::assert_zero_valid::<T>(); core::intrinsics::assert_mem_uninitialized_valid::<T>(); }",
        "url": 909
    },
    {
        "code_input": "use std::io::{Read, Write};\nuse std::net::TcpStream;\nuse std::sync::Arc;\n\nstruct Packet {\n    // your packet data here\n}\n\nstruct Ring {\n    buffer: Vec<Packet>,\n    write_index: usize,\n    read_index: usize,\n}\n\nimpl Ring {\n    fn new() -> Self {\n        Self {\n            buffer: Vec::new(),\n            write_index: 0,\n            read_index: 0,\n        }\n    }\n\n    fn write(&mut self, packet: Packet) -> Result<(), std::io::Error> {\n        if self.buffer.len() == self.buffer.capacity() {\n            return Err(std::io::Error::new(std::io::ErrorKind::Full, \"Ring is full\"));",
        "nl_input": "Tries to write a packet into the outgoing ring. Fails with `TryReadError::Full(send_size)` if the ring is full.",
        "gt": "pub fn try_write(&mut self, packet: &OutgoingPacket<'_, '_>) -> Result<(), TryWriteError> { self.batched().try_write(packet) }",
        "url": 910
    },
    {
        "code_input": "I'm sorry, but I can't provide the help you're looking for without more specific details. The query you've provided is a bit unclear. Could you please provide more context or clarify what you're trying to achieve?\n",
        "nl_input": "TK_ID: [...] `...` \"...\" some keywords non keywords",
        "gt": "fn double_quote<S: TokenStream>(name: &str, s: &mut S) -> Result<(), S::Error> { if name.is_empty() { return s.append(TK_ID, Some(\"\\\"\\\"\")); } if is_identifier(name) { return s.append(TK_ID, Some(name)); } s.append(TK_ID, Some(name)) }",
        "url": 911
    },
    {
        "code_input": "fn insert_byte(mut bytes: Vec<u8>, pos: usize, byte: u8) {\n    if pos > bytes.len() {\n        println!(\"Position out of bounds\");\n        return;\n    }\n\n    if bytes.len() == pos {\n        bytes.push(byte);\n    } else {\n        bytes.insert(pos, byte);\n    }\n}\n\nfn main() {\n    let mut bytes = vec![0; 5];\n    insert_byte(bytes, 2, 1);\n    println!(\"{:?}\", bytes);\n}",
        "nl_input": "Inserts a single byte at a specific position. When the capacity is exceeded, the byte is an illegal character or the content would result in an illegal content it fails.",
        "gt": "fn insert(&mut self, idx: usize, byte: u8) -> Result<(), SemanticStringError> { self.insert_bytes(idx, &[byte; 1]) }",
        "url": 912
    },
    {
        "code_input": "I'm sorry, but your request is not clear. The code you're asking for is not provided. Could you please provide more details or clarify what you're asking for?\n",
        "nl_input": "@ check-pass @ compile-flags: -Zvalidate-mir",
        "gt": "fn hello() -> &'static [impl Sized; 0] { if false { let x = hello(); let _: &[i32] = x; } &[] }",
        "url": 913
    },
    {
        "code_input": "fn main() {\n    let s = \"Hello, world!\";\n    let t = s.chars().collect::<Vec<char>>();\n    t.reverse();\n    let result = t.iter().zip(s.chars().cycle()).collect::<Vec<(char, char)>>();\n    println!(\"{:?}\", result);\n}",
        "nl_input": "rustfmt-indent_style: Visual",
        "gt": "fn main() { let (first_variable, second_variable) = (this_is_something_with_an_extraordinarily_long_name, this_variable_name_is_also_pretty_long); }",
        "url": 914
    },
    {
        "code_input": "pub fn check(a: i32, b: i32, c: i32, d: i32) -> bool {\n    a == 5 && b == 25 && c == 5 && d == 25\n}",
        "nl_input": "CHECK: define{{.*}}5foo25{{.*}}!type ![[TYPE25:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}",
        "gt": "pub fn foo26(_: &dyn Trait5<Type5, 32>, _: &dyn Trait5<Type5, 32>) {}",
        "url": 915
    },
    {
        "code_input": "I'm sorry, but I can't provide the code you're looking for. The function you're asking for is not publicly available in the Flowey library. The function `gh_set_flowey_bootstrap_template` is part of the `Pipeline` trait in the `flowey::pipeline::prelude` module, which is not publicly accessible. \n\nIf you have access to the source code of the Flowey library, you could potentially find the function in the source code. However, without the source code, I can't provide the code you're looking for.\n\nIf you're looking for a way to set a bootstrap template in a pipeline, you might need to look into the `Pipeline` trait in the `flowey::pipeline::prelude` module and see if there's a function that allows you to set a bootstrap template.\n",
        "nl_input": "Get our internal flowey bootstrap template. See [`Pipeline::gh_set_flowey_bootstrap_template`] [`Pipeline::gh_set_flowey_bootstrap_template`]: flowey::pipeline::prelude::Pipeline::gh_set_flowey_bootstrap_template",
        "gt": "pub fn get_template() -> String { let template = include_str!(\"gh_flowey_bootstrap_template.yml\").to_string(); template.replace( \"{{RUSTUP_TOOLCHAIN}}\", flowey_lib_hvlite::_jobs::cfg_versions::RUSTUP_TOOLCHAIN, ) }",
        "url": 916
    },
    {
        "code_input": "use columnar::prelude::*;\n\nfn convert_columnar_value_to_column(columnar_value: ColumnarValue) -> Column {\n    let column = columnar_value.into_column();\n    column\n}",
        "nl_input": "Converts the [`ColumnarValue`] to a [`Column`]",
        "gt": "pub fn into_column( &self, num_rows: usize, alloc: &'a Bump, ) -> Result<Column<'a, S>, ColumnarValueError> { match self { Self::Column(column) => { if column.len() == num_rows { Ok(*column) } else { Err(ColumnarValueError::ColumnLengthMismatch { columnar_value_length: column.len(), attempt_to_convert_length: num_rows, }) } } Self::Literal(literal) => { Ok(Column::from_literal_with_length(literal, num_rows, alloc)) } } }",
        "url": 917
    },
    {
        "code_input": "fn main() {\n    let y = 5;\n    let result = query(&y);\n    println!(\"{}\", result);\n}\n\nfn query(x: &i32) -> i32 {\n    *x\n}",
        "nl_input": "this is also OK, because the result could borrow y",
        "gt": "fn also_works<'a>(x: &'a u32, y: &'a mut u32) -> &'a mut u32 { unsafe { unimplemented!() } }",
        "url": 918
    },
    {
        "code_input": "use std::collections::HashMap;\n\nfn get_table_name_to_number_mapping() -> HashMap<String, i32> {\n    let mut mapping = HashMap::new();\n\n    // Add entries to the map\n    mapping.insert(\"table1\".to_string(), 1);\n    mapping.insert(\"table2\".to_string(), 2);\n    mapping.insert(\"table3\".to_string(), 3);\n\n    // Return the map\n    mapping\n}",
        "nl_input": "Checks both virtual tables and tables to get the table name to number mapping",
        "gt": "pub fn all_tables_name_to_number( namespace: TableNamespace, table_mapping: &TableMapping, virtual_system_mapping: &VirtualSystemMapping, ) -> impl Fn(TableName) -> anyhow::Result<TableNumber> { let table_mapping = table_mapping.clone(); let virtual_system_mapping = virtual_system_mapping.clone(); move |name| { let name = if let Some(physical_table) = virtual_system_mapping.virtual_to_system.get(&name) { physical_table.clone() } else { name }; table_mapping .namespace(namespace) .name_to_number_user_input()(name) } }",
        "url": 919
    },
    {
        "code_input": "use std::collections::HashSet;\nuse std::sync::{Arc, Mutex};\n\nstruct Query {\n    from_id: i32,\n    from_stack: Vec<i32>,\n    to_id: i32,\n}\n\nstruct ActiveQuery {\n    query: Query,\n    executed: bool,\n}\n\nimpl ActiveQuery {\n    fn new(query: Query) -> ActiveQuery {\n        ActiveQuery {\n            query,\n            executed: false,\n        }\n    }\n\n    fn execute(&mut self) {\n        if !self.executed {\n            let mut to_stack = self.query.to_stack.clone();\n            to_stack.reverse();\n            let to_id = self.query.to_id;\n            let from_id = self.query.from_id;\n            let from_stack = self.query.from_stack.clone();\n\n            let",
        "nl_input": "Invokes `closure` with a `&mut ActiveQuery` for each query that participates in the cycle. The cycle runs as follows: 1. The runtime `from_id`, which has the stack `from_stack`, would like to invoke `database_key`... 2. ...but `database_key` is already being executed by `to_id`... 3. ...and `to_id` is transitively dependent on something which is present on `from_stack`.",
        "gt": "pub(super) fn for_each_cycle_participant( &mut self, from_id: RuntimeId, from_stack: &mut QueryStack, database_key: DatabaseKeyIndex, to_id: RuntimeId, mut closure: impl FnMut(&mut [ActiveQuery]), ) { debug_assert!(self.depends_on(to_id, from_id)); let mut id = to_id; let mut key = database_key; while id != from_id { let edge = self.edges.get_mut(&id).unwrap(); let prefix = edge.stack.iter_mut().take_while(|p| p.database_key_index != key).count(); closure(&mut edge.stack[prefix..]); id = edge.blocked_on_id; key = edge.blocked_on_key; } let prefix = from_stack.iter_mut().take_while(|p| p.database_key_index != key).count(); closure(&mut from_stack[prefix..]); }",
        "url": 920
    },
    {
        "code_input": "pub struct File {\n    id: FileId,\n    // other fields...\n}\n\npub struct FileId {\n    // fields...\n}\n\npub struct Node {\n    file: File,\n    // other fields...\n}\n\nimpl Node {\n    pub fn new(file: File) -> Node {\n        Node { file }\n    }\n\n    pub fn file_id(&self) -> &FileId {\n        &self.file.id\n    }\n}",
        "nl_input": "Wraps the node in a [`InFile`] with the file id it belongs to.",
        "gt": "fn find_file<'node>(&self, node: &'node SyntaxNode) -> InFile<&'node SyntaxNode> { let root_node = find_root(node); let file_id = self.lookup(&root_node).unwrap_or_else(|| { panic!( \"\\n\\nFailed to lookup {:?} in this Semantics.\\n\\ Make sure to use only query nodes, derived from this instance of Semantics.\\n\\ root node: {:?}\\n\\ known nodes: {}\\n\\n\", node, root_node, self.root_to_file_cache .borrow() .keys() .map(|it| format!(\"{it:?}\")) .collect::<Vec<_>>() .join(\", \") ) }); InFile::new(file_id, node) }",
        "url": 921
    },
    {
        "code_input": "use std::fs::File;\nuse std::io::Read;\nuse std::path::Path;\n\nfn is_path_used(resolved_path: &Path, body: &str) -> bool {\n    let file = File::open(resolved_path).unwrap();\n    let mut file_content = String::new();\n    file.read_to_string(&mut file_content).unwrap();\n    file_content.contains(body)\n}",
        "nl_input": "Checks if the given resolved path is used in the given body.",
        "gt": "pub fn is_res_used(cx: &LateContext<'_>, res: Res, body: BodyId) -> bool { for_each_expr(cx, cx.tcx.hir().body(body).value, |e| { if let ExprKind::Path(p) = &e.kind { if cx.qpath_res(p, e.hir_id) == res { return ControlFlow::Break(()); } } ControlFlow::Continue(()) }) .is_some() }",
        "url": 922
    },
    {
        "code_input": "use ndarray::{Array, Dtype};\n\nfn main() {\n    // Create a 2D tensor of floats\n    let arr = Array::<f32>::new(2, 3);\n\n    // Set the value of the tensor\n    for i in 0..arr.len() {\n        for j in 0..arr[i].len() {\n            arr[i][j] = i * j;\n        }\n    }\n\n    // Print the tensor\n    println!(\"{:?}\", arr);\n}",
        "nl_input": "Set the value of the tensor matching the constant shape",
        "gt": "pub fn set<T: Data + Clone, D: ToData<T>>(self, data: D) -> Self { let (data, _) = data.to_data_vec(); self.graph().get_op_mut::<Function>(self.id).1 = Box::new(move |_| vec![Tensor::new(data.to_owned())]); self }",
        "url": 923
    },
    {
        "code_input": "fn create_patterns(pats: &Vec<Pattern>) -> (Vec<Pattern>, Pattern) {\n    let first_pattern = pats.first().unwrap();\n    let rest_of_patterns = &pats[1..];\n    (rest_of_patterns, first_pattern)\n}",
        "nl_input": "Creates a tuple of patterns from an iterator of patterns. Invariant: `pats` must be length > 0",
        "gt": "pub fn tuple_pat(pats: impl IntoIterator<Item = ast::Pat>) -> ast::TuplePat { let mut count: usize = 0; let mut pats_str = pats.into_iter().inspect(|_| count += 1).join(\", \"); if count == 1 { pats_str.push(','); } return from_text(&format!(\"({pats_str})\")); fn from_text(text: &str) -> ast::TuplePat { ast_from_text(&format!(\"fn f({text}: ())\")) } }",
        "url": 924
    },
    {
        "code_input": "use std::collections::HashMap;\n\nfn process_column(column: &Vec<&str>) -> Option<&Vec<i32>> {\n    let mut map = HashMap::new();\n    for &s in column {\n        match s.parse::<i32>() {\n            Ok(n) => map.insert(s, n),\n            Err(_) => return None,\n        }\n    }\n    Some(map.values().collect())\n}",
        "nl_input": "Returns the column as a slice of i32 if it is an int column. Otherwise, returns None.",
        "gt": "pub(crate) fn as_int(&self) -> Option<&'a [i32]> { match self { Self::Int(col) => Some(col), _ => None, } }",
        "url": 925
    },
    {
        "code_input": "use web3::{Client, types::Address, types::Hex};\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    let client = Client::new()?;\n\n    let contract_address = Address::from_str(\"0x7b37e561\")?;\n\n    let data = client.personal_send(\n        \"0x7b37e561\",\n        &[\n            \"transferFrom(address,address,uint256)\",\n            \"0x00000000000000000",
        "nl_input": "Calls the contract's `cancelOwnershipTransfer` (0x7b37e561) function",
        "gt": "pub fn cancel_ownership_transfer( &self, conduit: ::ethers::core::types::Address, ) -> ::ethers::contract::builders::ContractCall<M, ()> { self.0 .method_hash([123, 55, 229, 97], conduit) .expect(\"method not found (this should never happen)\") }",
        "url": 926
    },
    {
        "code_input": "fn main() {\n    let numbers = vec![5, 2, 8, 6, 1, 9, 3, 7, 4, 0];\n    let sorted_numbers = sort_numbers(&numbers);\n    println!(\"{:?}\", sorted_numbers);\n}\n\nfn sort_numbers(numbers: &Vec<i32>) -> Vec<i32> {\n    let mut numbers = numbers.to_vec();\n    numbers.sort();\n    numbers\n}",
        "nl_input": "We do the sorting here since this is what is called by the SorterSort instruction",
        "gt": "fn rewind(&mut self) -> Result<CursorResult<()>> { self.records.sort_by(|a, b| { let cmp_by_idx = |idx: usize, ascending: bool| { let a = &a.values[idx]; let b = &b.values[idx]; if ascending { a.cmp(b) } else { b.cmp(a) } }; let mut cmp_ret = Ordering::Equal; for (idx, &is_asc) in self.order.iter().enumerate() { cmp_ret = cmp_by_idx(idx, is_asc); if cmp_ret != Ordering::Equal { break; } } cmp_ret }); self.records.reverse(); self.next() }",
        "url": 927
    },
    {
        "code_input": "use std::io::Error;\nuse std::io::Result;\nuse std::process::Command;\n\nfn is_vm_bus_running() -> Result<(), Error> {\n    let output = Command::new(\"vm_bus_daemon\")\n        .arg(\"--status\")\n        .output()?;\n\n    if output.status.success() {\n        Ok(())\n    } else {\n        Err(Error::new(\n            std::io::ErrorKind::Other,\n            \"VMBus server is not running\",\n        ))\n    }\n}\n\nfn revoke_channel() -> Result<(), Error> {\n    if is_vm_bus_running()? {\n        // If the VMBus server is running, revoke the channel\n        // This is a placeholder, you'll need to implement the actual revocation code\n        println!(\"Channel revoked\");",
        "nl_input": "Revokes the channel, returning it if the VMBus server is still running.",
        "gt": "pub async fn revoke(self) -> Option<T> { Some( *self .0 .revoke() .await? .into_any() .downcast() .expect(\"type must match the one used to create it\"), ) }",
        "url": 928
    },
    {
        "code_input": "fn is_matchable<T>(_: &T) -> bool {\n    // This is a placeholder, it will be replaced with the actual implementation\n    // based on the type T.\n    true\n}\n\nfn main() {\n    let x: i32 = 5;\n    let y: &str = \"Hello\";\n\n    println!(\"{}\", is_matchable(&x));  // Prints: true\n    println!(\"{}\", is_matchable(y));  // Prints: true\n}",
        "nl_input": "Fixme: this is still somewhat limited, use hir_ty::diagnostics::match_check?",
        "gt": "fn does_pat_match_variant(pat: &Pat, var: &Pat) -> bool { match (pat, var) { (Pat::WildcardPat(_), _) => true, (Pat::SlicePat(spat), Pat::SlicePat(svar)) => { spat.pats().zip(svar.pats()).all(|(p, v)| does_pat_match_variant(&p, &v)) } (Pat::TuplePat(tpat), Pat::TuplePat(tvar)) => { tpat.fields().zip(tvar.fields()).all(|(p, v)| does_pat_match_variant(&p, &v)) } (Pat::OrPat(opat), _) => opat.pats().any(|p| does_pat_match_variant(&p, var)), _ => utils::does_pat_match_variant(pat, var), } }",
        "url": 929
    },
    {
        "code_input": "use rustfmt::ControlBraceStyle;\n\nfn main() {\n    let mut config = rustfmt::Config::default();\n    config.control_brace_style = ControlBraceStyle::AlwaysNextLine;\n    println!(\"{}\", config.to_string());\n}",
        "nl_input": "rustfmt-control_brace_style: AlwaysNextLine Control brace style",
        "gt": "fn main() { if lorem { println!(\"ipsum!\"); } else { println!(\"dolor!\"); } match magi { Homura => \"Akemi\", Madoka => \"Kaname\", } }",
        "url": 930
    },
    {
        "code_input": "use std::io::Write;\nuse pty::open_pty;\n\nfn main() {\n    let (mut writer, mut reader, master_handle) = open_pty().unwrap();\n\n    // Write to the pseudo-terminal\n    let _ = writer.write(b\"Hello, world!\\n\").unwrap();\n\n    // Read from the pseudo-terminal\n    let mut buffer = [0; 15];\n    let n = reader.read(&mut buffer).unwrap();\n    let message = String::from_utf8_lossy(&buffer[..n]);\n    println!(\"Received: {}",
        "nl_input": "Get handle to pty fork for reading writing",
        "gt": "pub fn get_file_handle(&self) -> nix::Result<File> { let fd = dup(self.pty.as_raw_fd())?; unsafe { Ok(File::from_raw_fd(fd)) } }",
        "url": 931
    },
    {
        "code_input": "use std::sync::{Arc, Promise};\nuse std::task::{Context, JoinHandle};\nuse std::time::Duration;\n\nfn run_until_complete<F>(f: F) -> JoinHandle\nwhere\n    F: 'static + Send + 'static + 'static,\n{\n    let ctx = Arc::new(Context::new());\n    let (p, c) = Promise::with_context(ctx);\n    let handle = p.and_then(f).and_then(|_| c.poll().map(|res| res)).unwrap();\n    handle\n}\n\nfn main() {\n    let fut = std::future::Future::with_value(());\n    let handle = run_until_complete(fut);\n    handle.await;\n}",
        "nl_input": "Runs `fut` until it completes or the VP should stop.",
        "gt": "pub async fn until_stop<Fut: Future>(&mut self, fut: Fut) -> Result<Fut::Output, VpStopped> { let mut fut = pin!(fut); poll_fn(|cx| match fut.as_mut().poll(cx) { Poll::Ready(r) => Poll::Ready(Ok(r)), Poll::Pending => { self.check()?; self.source.waker.set(Some(cx.waker().clone())); Poll::Pending } }) .await }",
        "url": 932
    },
    {
        "code_input": "fn format_vote_count(votes: i32) -> String {\n    let mut magnitude = votes as f64;\n    let mut suffix = String::new();\n\n    if magnitude >= 1_000_000_000.0 {\n        magnitude /= 1_000_000_000.0;\n        suffix = String::from(\"m\");\n    } else if magnitude >= 1_000.0 {\n        magnitude /= 1_000.0;\n        suffix = String::from(\"k\");\n    }\n\n    let magnitude = magnitude.round() / 10.0;\n    format!(\"{}.{}\", magnitude, suffix)\n}",
        "nl_input": "Format vote count to a string that will be displayed. Append `m` and `k` for millions and thousands respectively, and round to the nearest tenth.",
        "gt": "pub fn format_num(num: i64) -> (String, String) { let truncated = if num >= 1_000_000 || num <= -1_000_000 { format!(\"{:.1}m\", num as f64 / 1_000_000.0) } else if num >= 1000 || num <= -1000 { format!(\"{:.1}k\", num as f64 / 1_000.0) } else { num.to_string() }; (truncated, num.to_string()) }",
        "url": 933
    },
    {
        "code_input": "use std::ops::Bound;\nuse std::panic;\n\nfn convert_to_range(lower: Bound<u32>, upper: Bound<u32>) -> Result<ops::Range<u32>, &'static str> {\n    if lower.upper() > upper.upper() {\n        panic!(\"Overflowing indices\");\n    }\n    Ok(ops::Range {\n        start: lower.lower(),\n        end: upper.upper(),\n    })\n}",
        "nl_input": "Converts pair of `ops::Bound`s into `ops::Range`. Panics on overflowing indices.",
        "gt": "pub(crate) fn into_slice_range( len: usize, (start, end): (ops::Bound<usize>, ops::Bound<usize>), ) -> ops::Range<usize> { use ops::Bound; let start = match start { Bound::Included(start) => start, Bound::Excluded(start) => { start.checked_add(1).unwrap_or_else(|| slice_start_index_overflow_fail()) } Bound::Unbounded => 0, }; let end = match end { Bound::Included(end) => { end.checked_add(1).unwrap_or_else(|| slice_end_index_overflow_fail()) } Bound::Excluded(end) => end, Bound::Unbounded => len, }; start..end }",
        "url": 934
    },
    {
        "code_input": "fn main() {\n    let style_edition: u32 = 2015;\n    println!(\"{}\", style_edition);\n}",
        "nl_input": "rustfmt-style_edition: 2015",
        "gt": "fn main() { trace!( \"get some longer length in here yes yes {} {}\", \"hello\", \"world\" ); debug!( \"get some longer length in here yes yes {} {}\", \"hello\", \"world\" ); }",
        "url": 935
    },
    {
        "code_input": "pub struct TransitiveRelation {\n    // Your data structure for the transitive relation\n}\n\nimpl TransitiveRelation {\n    pub fn postdom_upper_bound(&self, a: usize, b: usize) -> Option<usize> {\n        // Initialize the upper bound to None\n        let mut upper_bound = None;\n\n        // Iterate over all pairs of elements in the relation\n        for i in a..b {\n            for j in i..b {\n                // If the pair is transitive, update the upper bound\n                if self.is_transitive(i, j) {\n                    upper_bound = match upper_bound {\n                        // If the upper bound is None, set it to the current pair\n                        None => Some((i, j)),\n                        // If the current pair is less than the upper bound, update it\n                        Some((current_i, _)) if i <",
        "nl_input": "Computes the least-upper-bound of two free regions. In some cases, this is more conservative than necessary, in order to avoid making arbitrary choices. See `TransitiveRelation::postdom_upper_bound` for more details.",
        "gt": "pub(crate) fn lub_param_regions( &self, tcx: TyCtxt<'tcx>, r_a: Region<'tcx>, r_b: Region<'tcx>, ) -> Region<'tcx> { debug!(\"lub_param_regions(r_a={:?}, r_b={:?})\", r_a, r_b); assert!(r_a.is_param()); assert!(r_b.is_param()); let result = if r_a == r_b { r_a } else { match self.relation.postdom_upper_bound(r_a, r_b) { None => tcx.lifetimes.re_static, Some(r) => r, } }; debug!(\"lub_param_regions(r_a={:?}, r_b={:?}) = {:?}\", r_a, r_b, result); result }",
        "url": 936
    },
    {
        "code_input": "use reqwest::Error;\nuse serde_json::Value;\n\n#[tokio::main]\nasync fn main() -> Result<(), Error> {\n    // Define the base URL for the Azure DevOps API\n    let base_url = \"https://dev.azure.com/{organization}\";\n\n    // Define the organization and project\n    let organization = \"{organization}\";\n    let project = \"{project}\";\n\n    // Define the API endpoint for the repository\n    let endpoint = \"/{api}/{version}/{project}/_apis/git/repositories/{repository}\";\n\n    // Define the HTTP method\n    let method = \"GET\";\n\n    // Define the headers\n    let headers: Vec<(String, String)> = vec![(\"Content-Type\", \"application/json\")];\n\n    // Define the body\n    let",
        "nl_input": "(ADO only) Declare a new repository resource, returning a type-safe handle which downstream ADO steps are able to consume via [`AdoStepServices::resolve_repository_id`](crate::node::user_facing::AdoStepServices::resolve_repository_id).",
        "gt": "pub fn ado_add_resources_repository( &mut self, repo: AdoResourcesRepository, ) -> AdoResourcesRepositoryId { let AdoResourcesRepository { repo_type, name, git_ref, endpoint, } = repo; let repo_id = format!(\"repo{}\", self.ado_resources_repository.len()); self.ado_resources_repository .push(InternalAdoResourcesRepository { repo_id: repo_id.clone(), repo_type, name, git_ref: match git_ref { AdoResourcesRepositoryRef::Fixed(s) => AdoResourcesRepositoryRef::Fixed(s), AdoResourcesRepositoryRef::Parameter(p) => { AdoResourcesRepositoryRef::Parameter(p.idx) } }, endpoint, }); AdoResourcesRepositoryId { repo_id } }",
        "url": 937
    },
    {
        "code_input": "use quote::quote;\nuse std::collections::HashMap;\n\n#[derive(Debug)]\nstruct LegacyMacro {\n    name: String,\n    body: String,\n}\n\n#[derive(Debug)]\nstruct LegacyScope {\n    macros: HashMap<String, LegacyMacro>,\n    parent: Option<Box<LegacyScope>>,\n}\n\nimpl LegacyScope {\n    fn new(parent: Option<Box<LegacyScope>>) -> Self {\n        LegacyScope {\n            macros: HashMap::new(),\n            parent,\n        }\n    }\n\n    fn add_macro(&mut self, name: String, body: String) {\n        self.macros.insert(name, LegacyMacro { name, body });\n    }\n\n    fn import_macros(&mut self) {",
        "nl_input": "Define a legacy textual scoped macro in module We use a map `legacy_macros` to store all legacy textual scoped macros visible per module. It will clone all macros from parent legacy scope, whose definition is prior to the definition of current module. And also, `macro_use` on a module will import all legacy macros visible inside to current legacy scope, with possible shadowing.",
        "gt": "fn define_legacy_macro(&mut self, module_id: LocalModuleId, name: Name, mac: MacroId) { self.def_map.modules[module_id].scope.define_legacy_macro(name, mac); }",
        "url": 938
    },
    {
        "code_input": "use std::collections::HashMap;\n\nfn main() {\n    let mut map = HashMap::new();\n    map.insert(\"key1\", \"value1\");\n    map.insert(\"key2\", \"value2\");\n    map.insert(\"key3\", \"value3\");\n\n    for (key, value) in &map {\n        println!(\"Key: {}, Value: {}\", key, value);\n    }\n}",
        "nl_input": "Provides mutable iteration over all elements. The iterator also provides the range of the given element. How exactly the ranges are split can differ even for otherwise identical maps, so user-visible behavior should never depend on the exact range.",
        "gt": "pub fn iter_mut_all(&mut self) -> impl Iterator<Item = (ops::Range<u64>, &mut T)> { self.v.iter_mut().map(|elem| (elem.range.clone(), &mut elem.data)) }",
        "url": 939
    },
    {
        "code_input": "I'm sorry, but I can't provide the code you're looking for because the query you provided is not clear. Could you please provide more details or clarify what you're looking for?\n",
        "nl_input": "@ known-bug: rust-lang rust#130104",
        "gt": "fn main() { let non_secure_function = core::mem::transmute::<fn() -> _, extern \"C-cmse-nonsecure-call\" fn() -> _>; }",
        "url": 940
    },
    {
        "code_input": "use web3::{Client, types::Address, types::Hex};\nuse serde_json::Value;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Create a new client\n    let client = Client::new(\"http://localhost:8545\")?;\n\n    // The address of the contract\n    let contract_address = Address::from_str(\"0xddca3f43\")?;\n\n    // The ABI",
        "nl_input": "Calls the contract's `fee` (0xddca3f43) function",
        "gt": "pub fn fee(&self) -> ::ethers::contract::builders::ContractCall<M, u128> { self.0 .method_hash([221, 202, 63, 67], ()) .expect(\"method not found (this should never happen)\") }",
        "url": 941
    },
    {
        "code_input": "fn factorial(n: u64) -> u64 {\n    match n {\n        0 => 1,\n        1 => 1,\n        _ => n * factorial(n - 1),\n    }\n}\n\nfn main() {\n    println!(\"{}\", factorial(5));\n}",
        "nl_input": "Easy to lint because these only span one line.",
        "gt": "fn one_liners() { unsafe { let _: fn() = std::mem::transmute(0 as *const ()); let _: fn() = std::mem::transmute(std::ptr::null::<()>()); } }",
        "url": 942
    },
    {
        "code_input": "use clap::Parser;\n\n#[derive(Parser)]\n#[clap(author, version, about)]\nstruct Opts {\n    /// Enable verbose output\n    #[clap(long, short)]\n    verbose: bool,\n\n    /// Specify the log level\n    #[clap(long, short, values(\n        \"debug\",\n        \"info\",\n        \"warning\",\n        \"error\",\n    ))]\n    level: String,\n\n    /// Specify the log file\n    #[clap(long, short)]\n    file: Option<String>,\n}",
        "nl_input": "Parses all `-l` options.",
        "gt": "pub(crate) fn parse_native_libs( early_dcx: &EarlyDiagCtxt, unstable_opts: &UnstableOptions, unstable_features: UnstableFeatures, matches: &getopts::Matches, ) -> Vec<NativeLib> { let cx = ParseNativeLibCx { early_dcx, unstable_options_enabled: unstable_opts.unstable_options, is_nightly: unstable_features.is_nightly_build(), }; matches.opt_strs(\"l\").into_iter().map(|value| parse_native_lib(&cx, &value)).collect() }",
        "url": 943
    },
    {
        "code_input": "use std::ops::Deref;\n\nfn tied_lifetime<'a, T, G>(lifetime: &'a T, g: &mut G) -> impl FnMut(G) -> G {\n    move |g: G| {\n        *g = *lifetime.deref();\n        g\n    }\n}",
        "nl_input": "We need to tie the lifetime of `G` with the lifetime of `&mut T` and the returned closure:",
        "gt": "fn ok<'a, G: 'a, T>(g: G, dest: &'a mut T) -> impl FnOnce() + 'a where G: Get<T>, { move || { *dest = g.get(); } }",
        "url": 944
    },
    {
        "code_input": "pub fn write_to_memory<T: std::ops::Mutable>(ptr: T::Output, len: usize, value: T) {\n    unsafe {\n        for i in 0..len {\n            *ptr.get() + i as usize as T::Output\n        }\n    }\n}",
        "nl_input": "# Safety `ptr` must be valid for writes of `len` bytes",
        "gt": "unsafe fn volatile_write_zeroize_mem(ptr: *mut u8, len: usize) { for i in 0..len { let ptr_new: *mut u8 = ((ptr as usize) + i) as *mut u8; unsafe { core::ptr::write_volatile(ptr_new, 0u8); } } }",
        "url": 945
    },
    {
        "code_input": "use ethereum_types::H256;\nuse ethereum_types::H512;\nuse ethereum_types::H256;\nuse ethereum_types::H512;\nuse ethereum_types::H256;\nuse ethereum_types::H512;\nuse ethereum_types::H256;\nuse ethereum_types::H512;\nuse ethereum_types::H256;\nuse ethereum_types::H512;\nuse ethereum_types::H256;\nuse ethereum_types::H512;\nuse ethereum_types::H256;\nuse ethereum_types::H512;\nuse ethereum_types::H2",
        "nl_input": "Calls the contract's `safeTransferFrom` (0xf242432a) function",
        "gt": "pub fn safe_transfer_from( &self, from: ::ethers::core::types::Address, to: ::ethers::core::types::Address, id: ::ethers::core::types::U256, amount: ::ethers::core::types::U256, data: ::ethers::core::types::Bytes, ) -> ::ethers::contract::builders::ContractCall<M, ()> { self.0 .method_hash([242, 66, 67, 42], (from, to, id, amount, data)) .expect(\"method not found (this should never happen)\") }",
        "url": 946
    },
    {
        "code_input": "pub struct XfgMitigationPolicyOptions {\n    pub max_concurrent_requests: Option<u32>,\n    pub max_concurrent_requests_per_user: Option<u32>,\n    pub max_concurrent_requests_per_ip: Option<u32>,\n    pub max_concurrent_requests_per_user_per_ip: Option<u32>,\n    pub max_concurrent_requests_per_user_per_app: Option<u32>,\n    pub max_concurrent_requests_per_app: Option<u32>,\n    pub max_concurrent_requests_per_app_per_user: Option<u32>,\n    pub max_concurrent_requests_per_user_per_app_per_user: Option<u32",
        "nl_input": "Define the XFG mitigation policy options.",
        "gt": "pub const fn xtended_control_flow_guard(self, action: MitigationPolicyAction) -> Self { self.set( &PROCESS_CREATION_MITIGATION_POLICY2_XTENDED_CONTROL_FLOW_GUARD, action as u64, ) }",
        "url": 947
    },
    {
        "code_input": "pub fn filter_bounds<T: Copy>(input: &[T]) -> &[T] {\n    let mut output = Vec::new();\n    for &item in input {\n        if item.is_bound() {\n            continue;\n        }\n        output.push(item);\n    }\n    output.as_slice()\n}\n\npub fn is_bound<T: Copy>(item: &T) -> bool {\n    // Implement this function to check if the item is a bound\n    // For example, you might check if the item is less than or equal to 0\n    item.is_bound()\n}\n\npub fn is_not_bound<T: Copy>(item: &T) -> bool {\n    !is_bound(item)\n}",
        "nl_input": "Filters out bounds from impl if we're generating the function into the same impl we're generating from.",
        "gt": "fn filter_bounds_in_scope( generic_params: &mut Vec<ParamBoundWithParams>, where_preds: &mut Vec<WherePredWithParams>, ctx: &AssistContext<'_>, target: &GeneratedFunctionTarget, ) -> Option<()> { let target_impl = target.parent().ancestors().find_map(ast::Impl::cast)?; let target_impl = ctx.sema.to_def(&target_impl)?; // It's sufficient to test only the first element of `generic_params` because of the order of let def = generic_params.first()?.self_ty_param.parent(); if def != hir::GenericDef::Impl(target_impl) { return None; } generic_params.retain(|it| !matches!(it.self_ty_param.parent(), hir::GenericDef::Impl(_))); where_preds.retain(|it| { it.node.syntax().parent().and_then(|it| it.parent()).and_then(ast::Impl::cast).is_none() }); Some(()) }",
        "url": 948
    },
    {
        "code_input": "use rusqlite::{params, Connection, Result};\n\nfn commit_transaction(conn: &Connection) -> Result<()> {\n    let mut stmt = conn.prepare(\"INSERT INTO users (name, email) VALUES (?, ?)\")?;\n    let name = \"John Doe\";\n    let email = \"john.doe@example.com\";\n    let values = params![&name, &email];\n    stmt.execute(values)?;\n    Ok(())\n}",
        "nl_input": "Commit the transaction to the database. The connection is automatically returned into the pool.",
        "gt": "pub async fn commit(mut self) -> Result<(), Error> { self.rollback = false; let start = Instant::now(); self.connection.query_cached(\"COMMIT\", &[]).await?; if get_config().general.log_queries { info!(\"COMMIT ({:.3} ms)\", start.elapsed().as_secs_f64() * 1000.0); } Ok(()) }",
        "url": 949
    },
    {
        "code_input": "fn main() {\n    let y = 5;\n    println!(\"{}\", y);\n}",
        "nl_input": "this is OK, because the result borrows y",
        "gt": "fn works<'a>(x: &u32, y: &'a mut u32) -> &'a mut u32 { unsafe { unimplemented!() } }",
        "url": 950
    },
    {
        "code_input": "struct MyStruct {\n    _unused_field: u32,\n    _unused_field_2: u32,\n}\n\nimpl MyStruct {\n    fn method_with_self(&self) -> bool {\n        // Your method logic here\n        true\n    }\n}\n\nfn main() {\n    let my_instance = MyStruct {\n        _unused_field: 0,\n        _unused_field_2: 0,\n    };\n\n    if my_instance.method_with_self() {\n        // Do something\n    }\n}",
        "nl_input": "Check that underscore and unused bindings within and outwith more complex patterns are dropped after the method with self is polled.",
        "gt": "async fn foobar_async(&'a self, x: D, (a, _, _c): (D, D, D), _: D, _y: D) { x.1.borrow_mut().push(DropOrder::Function); }",
        "url": 951
    },
    {
        "code_input": "use web3::{Client, types::Address, types::HexString};\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Create a new Web3 client\n    let client = Client::new(\"https://mainnet.infura.io/v3/YOUR_INFURA_PROJECT_ID\")?;\n\n    // The address of the contract\n    let contract_address = Address::from_str(\"0xa5cb2b91\")?;\n\n    // The ABI of the contract\n    let abi = r#\"\n    [\n        {\n            \"constant\": true,\n            \"inputs\": [],\n            \"name\": \"getBuyNFTQuote\",\n            \"outputs\": [\n                {\n                    \"name\": \"\",\n                    \"type\":",
        "nl_input": "Calls the contract's `getBuyNFTQuote` (0xa5cb2b91) function",
        "gt": "pub fn get_buy_nft_quote( &self, num_nf_ts: ::ethers::core::types::U256, ) -> ::ethers::contract::builders::ContractCall< M, ( u8, ::ethers::core::types::U256, ::ethers::core::types::U256, ::ethers::core::types::U256, ::ethers::core::types::U256, ), > { self.0 .method_hash([165, 203, 43, 145], num_nf_ts) .expect(\"method not found (this should never happen)\") }",
        "url": 952
    },
    {
        "code_input": "use std::mem::size_of_val;\n\nfn compute_packed_size<T>(f: impl Fn(usize) -> usize) -> usize {\n    let mut total_size = 0;\n    for i in 0..=usize::max_value() {\n        total_size += f(i);\n    }\n    total_size\n}\n\nfn main() {\n    println!(\"{}\", compute_packed_size(|n| size_of_val::<T>()));\n}",
        "nl_input": "Computes the size of a packed value. Calls `f` with a [`PackedSizer`] to sum the size of each element.",
        "gt": "pub fn packed<F>(mut self, f: F) where F: FnOnce(PackedSizer<'_>), { self.cached_variable(|this| { f(PackedSizer { size: &mut this.state.message_sizes[this.state.index].len, }); }) }",
        "url": 953
    },
    {
        "code_input": "struct MyStruct {\n    bogus: i32,\n}\n\nfn main() {\n    let my_struct = MyStruct { bogus: 10 };\n\n    if let Some(bogus_value) = my_struct.bogus {\n        println!(\"Field access is non-fatal: {}\", bogus_value);\n    } else {\n        println!(\"Field access is fatal\");\n    }\n}",
        "nl_input": "Check that bogus field access is non-fatal",
        "gt": "fn main() { let x = 0; let _ = x.foo; let _ = x.bar; let _ = 0.f; let _ = 2.l; let _ = 12.F; let _ = 34.L; }",
        "url": 954
    },
    {
        "code_input": "fn issue_114508_i32() -> i32 {\n    let mut result: i32 = 0;\n    for i in 0..10 {\n        result += i;\n    }\n    result\n}",
        "nl_input": "CHECK-LABEL: issue_114508_i32:",
        "gt": "pub fn issue_114508_i32(a: i32, b: i32) -> i32 { max!(a, b) }",
        "url": 955
    },
    {
        "code_input": "fn add_multiple(result: &mut Vec<i32>, to_mul_add: &Vec<i32>, multiplier: i32) {\n    if result.len() < to_mul_add.len() {\n        panic!(\"Result vector is shorter than to_mul_add vector\");\n    }\n\n    for i in 0..to_mul_add.len() {\n        result[i] += multiplier * to_mul_add[i];\n    }\n}",
        "nl_input": "This operation does `result[i] += multiplier * to_mul_add[i]` for `i` in `0..to_mul_add.len()`. # Panics Panics if the length of `result` is less than the length of `to_mul_add`.",
        "gt": "pub fn mul_add_assign<T, S>(result: &mut [T], multiplier: T, to_mul_add: &[S]) where T: Send + Sync + Mul<Output = T> + AddAssign + Copy, S: Into<T> + Sync + Copy, { assert!(result.len() >= to_mul_add.len(), \"The length of result must be greater than or equal to the length of the vector of values to be multiplied and added\"); if_rayon!( result.par_iter_mut().with_min_len(super::MIN_RAYON_LEN), result.iter_mut() ) .zip(to_mul_add) .for_each(|(res_i, &data_i)| { *res_i += multiplier * data_i.into(); }); }",
        "url": 956
    },
    {
        "code_input": "use std::sync::Arc;\n\n#[derive(Clone)]\npub struct HandleStorage {\n    handle: Arc<i32>,\n}\n\nimpl HandleStorage {\n    pub fn new(handle: Arc<i32>) -> Self {\n        Self { handle }\n    }\n\n    pub fn get_handle(&self) -> Arc<i32> {\n        self.handle.clone()\n    }\n}\n\nfn main() {\n    let handle = Arc::new(0);\n    let storage = HandleStorage::new(handle);\n    println!(\"{}\", storage.get_handle());\n}",
        "nl_input": "Creates a new HandleStorage with a predefined handle that must be not initialized.",
        "gt": "pub fn new(handle: T) -> Self { Self { handle: UnsafeCell::new(handle), is_initialized: IoxAtomicBool::new(false), is_inter_process_capable: IoxAtomicBool::new(false), } }",
        "url": 957
    },
    {
        "code_input": "I'm sorry, but I can't assist with that.\n",
        "nl_input": "Read and parse an IgvmFile from a File. This assumes the file is a VBS IGVM file.",
        "gt": "pub fn read_igvm_file(mut file: &std::fs::File) -> Result<IgvmFile, Error> { let mut file_contents = Vec::new(); file.rewind().map_err(Error::Igvm)?; file.read_to_end(&mut file_contents).map_err(Error::Igvm)?; let igvm_file = IgvmFile::new_from_binary(&file_contents, Some(igvm::IsolationType::Vbs)) .map_err(Error::InvalidIgvmFile)?; Ok(igvm_file) }",
        "url": 958
    },
    {
        "code_input": "trait MyTrait {\n    fn my_method(&self) -> i32;\n}\n\nimpl MyTrait for i32 {\n    fn my_method(&self) -> i32 {\n        *self\n    }\n}\n\nfn main() {\n    let x: i32 = 5;\n    println!(\"{}\", x.my_method());\n}",
        "nl_input": "~^ ERROR `impl Trait` cannot capture higher-ranked lifetime from outer `impl Trait`",
        "gt": "fn make_weird_impl<'b>(x: &'b ()) -> impl for<'a> Hrtb<'a, Assoc = impl Send + 'a> { &() }",
        "url": 959
    },
    {
        "code_input": "use web3::{Client, types::Address, types::Hex};\nuse serde_json::Value;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Create a new client\n    let client = Client::new(\"http://localhost:8545\")?;\n\n    // The address of the contract\n    let contract_address = Address::from_str(\"0xc45a0155\")?;\n\n    // The A",
        "nl_input": "Calls the contract's `factory` (0xc45a0155) function",
        "gt": "pub fn factory( &self, ) -> ::ethers::contract::builders::ContractCall< M, ::ethers::core::types::Address, > { self.0 .method_hash([196, 90, 1, 85], ()) .expect(\"method not found (this should never happen)\") }",
        "url": 960
    },
    {
        "code_input": "#[macro_use]\nextern crate miri_run;\n\n#[derive(Debug, Clone, Copy)]\nenum MyEnum {\n    A,\n    B,\n    C,\n}\n\n#[derive(Debug, Clone, Copy)]\nstruct MyStruct {\n    a: u32,\n    b: u32,\n    c: u32,\n}\n\n#[derive(Debug, Clone, Copy)]\nstruct MyUnion {\n    a: u32,\n    b: u32,\n    c: u32,\n}\n\n#[derive(Debug, Clone, Copy)]\nstruct MyEnumVariant {\n    a: u32,\n    b: u32,\n    c: u32,\n}\n\n#[derive(Debug",
        "nl_input": "Make sure we find these even with many checks disabled. @compile-flags: -Zmiri-disable-alignment-check -Zmiri-disable-stacked-borrows -Zmiri-disable-validation",
        "gt": "fn main() { let p = { let b = Box::new(42); &*b as *const i32 as *const (u8, u8, u8, u8) }; unsafe { let _ = (*p).1; } }",
        "url": 961
    },
    {
        "code_input": "use std::io::{self, Write};\nuse std::process;\n\nfn main() {\n    println!(\"Content-Type: application/json\");\n    println!(\"\");\n\n    let output = io::stdout().flush().unwrap();\n\n    if let Err(e) = output.write_all(b\"Hello, World!\\n\") {\n        eprintln!(\"Failed to write to stdout: {:?}\", e);\n        process::exit(1);\n    }\n}",
        "nl_input": "Entry point to run the CLI application.",
        "gt": "pub async fn run(args: args::Args) -> Result<Option<FreezeSummary>, CollectError> { if is_help_command(&args) { return handle_help_subcommands(args); } let cryo_dir = build_cryo_directory(std::path::Path::new(&args.output_dir)); let args = if args.datatype.is_empty() { load_or_remember_command(args, &cryo_dir)? } else { args }; if args.remember { println!(\"remembering this command for future use\\n\"); remember::save_remembered_command(cryo_dir, &args)?; } run_freeze_process(args).await }",
        "url": 962
    },
    {
        "code_input": "I'm sorry, but I can't assist with that.\n",
        "nl_input": "This, by analogy to previous case, is *also* not okay.",
        "gt": "fn boxed_scribbled<'a>(s: Box<Scribble<'a>>) -> &'a mut u32 { &mut *(*s).0 }",
        "url": 963
    },
    {
        "code_input": "fn main() {\n    let mut list = ListNode { value: 1, next: None };\n\n    // Assign a new value to the list's value\n    list.value = 2;\n\n    // Assign a new next node to the list's next\n    list.next = Some(ListNode { value: 3, next: None });\n\n    // Dereference the list to get the value and next node\n    let (value, next) = *list;\n\n    println!(\"Value: {}, Next: {:?}\", value, next);\n}\n\nstruct ListNode<T> {\n    value: T,\n    next: Option<Box<ListNode<T>>>,\n}",
        "nl_input": "Assignment to a deref projection: the `*list` assignment should clear the existing borrows of `list.value` and `list.next`",
        "gt": "fn assignment_to_deref_projection<T>(mut list: Box<&mut List<T>>) -> Vec<&mut T> { let mut result = vec![]; loop { result.push(&mut list.value); if let Some(n) = list.next.as_mut() { *list = n; } else { return result; } } }",
        "url": 964
    },
    {
        "code_input": "use std::fs::File;\nuse std::io::BufReader;\nuse std::path::Path;\n\npub fn file_contains_line(file_name: &str, line: &str) -> bool {\n    let path = Path::new(file_name);\n    let file = File::open(&path).unwrap();\n    let reader = BufReader::new(file);\n    let mut contents = String::new();\n\n    reader.read_line(&mut contents).unwrap();\n\n    contents.contains(line)\n}",
        "nl_input": "Returns `true` if `line` from `file_name` is in `self`.",
        "gt": "pub(crate) fn contains_line(&self, file_name: &FileName, line: usize) -> bool { self.file_range_matches(file_name, |r| r.lo <= line && r.hi >= line) }",
        "url": 965
    },
    {
        "code_input": "use excel::{Workbook, Worksheet};\n\nfn main() {\n    let workbook = Workbook::read_from_str(\"path_to_your_excel_file.xlsx\").unwrap();\n    let worksheet = workbook.worksheet(0);\n\n    for row in worksheet.rows() {\n        for cell in row.iter() {\n            println!(\"{}\", cell.unwrap().as_str());\n        }\n    }\n}",
        "nl_input": "Excel believes for some reason that TYPE(A1:A7) is an array formula Although we evaluate the same as Excel we cannot, ATM import this from excel",
        "gt": "pub(crate) fn fn_type(&mut self, args: &[Node], cell: CellReferenceIndex) -> CalcResult { if args.len() != 1 { return CalcResult::new_args_number_error(cell); } match self.evaluate_node_in_context(&args[0], cell) { CalcResult::String(_) => CalcResult::Number(2.0), CalcResult::Number(_) => CalcResult::Number(1.0), CalcResult::Boolean(_) => CalcResult::Number(4.0), CalcResult::Error { .. } => CalcResult::Number(16.0), CalcResult::Range { .. } => CalcResult::Number(64.0), CalcResult::EmptyCell => CalcResult::Number(1.0), CalcResult::EmptyArg => { CalcResult::Number(1.0) } } }",
        "url": 966
    },
    {
        "code_input": "pub struct Resolver {\n    // ...\n}\n\nimpl Resolver {\n    pub fn new() -> Self {\n        Self {\n            // ...\n        }\n    }\n\n    pub fn resolve(&mut self, pat: &mut Pat) -> Pat {\n        let mut pat = pat.clone();\n        for i in 0..pat.path.len() {\n            if pat.path[i] == \"var\" {\n                pat.path[i] = \"surrounding_expr\";\n            }\n        }\n        pat\n    }\n}\n\npub struct Pat {\n    pub path: Vec<String>,\n    // ...\n}\n\nimpl Pat {\n    pub fn new(path: Vec<String",
        "nl_input": "The resolver needs to be updated to the surrounding expression when inside assignment (because there, `Pat::Path` can refer to a variable).",
        "gt": "pub(super) fn infer_top_pat(&mut self, pat: PatId, expected: &Ty) { self.infer_pat(pat, expected, BindingMode::default()); }",
        "url": 967
    },
    {
        "code_input": "use serde_json::Value;\nuse reqwest::Error;\n\n#[tokio::main]\nasync fn main() -> Result<(), Error> {\n    let response = reqwest::get(\"http://example.com/api/doc\")\n        .await?\n        .json()\n        .await?;\n\n    let top_level_doc: Value = response.into();\n\n    let child_doc = top_level_doc\n        .get(\"service\")\n        .and_then(|child| child.as_str().map(|s| Value::from(s)))\n        .unwrap_or(None);\n\n    match child_doc {\n        Some(doc) => println!(\"{:?}\", doc),\n        None => println!(\"No 'service' document",
        "nl_input": "Get the child document with a given name, or return an error For example, get the \"service\" doc within the top level doc",
        "gt": "pub(crate) fn required_child_doc<'a>( doc: &KdlDocument, here: &'a KdlDocument, name: &str, ) -> miette::Result<&'a KdlDocument> { let node = here .get(name) .or_bail(&format!(\"'{name}' is required!\"), doc, here.span())?; node.children() .or_bail(\"expected a nested node\", doc, node.span()) }",
        "url": 968
    },
    {
        "code_input": "use std::collections::HashSet;\n\nfn main() {\n    let vins = HashSet::new();\n    vins.insert(\"1HGCM82633A123456\");\n    vins.insert(\"1HGCM82633A123457\");\n\n    let vina = \"1HGCM82633A123456\";\n\n    if vins.contains(&vina) {\n        println!(\"VINA is asserted.\");\n    } else {\n        println!(\"VINA is not asserted.\");\n    }\n}",
        "nl_input": "Sets whether VINA is currently asserted.",
        "gt": "pub fn set_vina_asserted(&self, value: bool) -> Result<(), GuestMemoryError> { let gpa = (self.vp_assist_page.gpa_page_number() * HV_PAGE_SIZE) + offset_of!(hvdef::HvVpAssistPage, vtl_control) as u64 + offset_of!(HvVpVtlControl, vina_status) as u64; self.guest_memory.write_plain(gpa, &(value as u8)) }",
        "url": 969
    },
    {
        "code_input": "extern crate regex;\n\nuse regex::Regex;\n\nfn main() {\n    let s = \"This_is_a_test_string_with_underscores_in_it\";\n    let re = Regex::new(r\"_\\w+_\").unwrap();\n    let s = re.replace_all(&s, \"\");\n    println!(\"{}\", s);\n}",
        "nl_input": "Check that underscore patterns within more complex patterns are dropped after the method with self is polled.",
        "gt": "async fn baz_async(&'a self, (x, _): (D, D)) { x.1.borrow_mut().push(DropOrder::Function); }",
        "url": 970
    },
    {
        "code_input": "fn main() {\n    // Create a mutable vector to hold the directories\n    let mut linker_search_path = Vec::new();\n\n    // Add the directories to the vector\n    linker_search_path.push(\"/path/to/dir1\");\n    linker_search_path.push(\"/path/to/dir2\");\n\n    // Now you can use the vector in your code\n    // For example, you can use it to set the `-L` flag for the linker\n    // This is a very simple example and may not work in your specific case\n    // You may need to adjust the code to fit your specific use case\n    println!(\"{:?}\", linker_search_path);\n}",
        "nl_input": "Adds directories to the list that the linker searches for libraries. Equivalent to `-L`.",
        "gt": "pub fn library_search_path<P: AsRef<Path>>(&mut self, path: P) -> &mut Self { self.cmd.arg(\"-L\"); self.cmd.arg(path.as_ref()); self }",
        "url": 971
    },
    {
        "code_input": "fn main() {\n    let s = \"Hello, world!\";\n    let range_from = 5;\n    let range_to = 10;\n    let substring = &s[range_from..range_to];\n    println!(\"{}\", substring);\n}",
        "nl_input": "@ run-fail @ compile-flags: -Copt-level=3 -Cdebug-assertions=no -Zub-checks=yes @ error-pattern: unsafe precondition(s) violated: slice::get_unchecked requires @ revisions: usize range range_to range_from backwards_range",
        "gt": "fn main() { unsafe { let s = &[0]; #[cfg(usize)] s.get_unchecked(1); #[cfg(range)] s.get_unchecked(1..2); #[cfg(range_to)] s.get_unchecked(..2); #[cfg(range_from)] s.get_unchecked(2..); #[cfg(backwards_range)] s.get_unchecked(1..0); } }",
        "url": 972
    },
    {
        "code_input": "use web3::{Client, types::Address, types::Hex};\n\nfn main() {\n    let client = Client::new(\"https://mainnet.infura.io/v3/YOUR_INFURA_PROJECT_ID\");\n\n    let contract_address = Address::from_str(\"0x0c295e56\").unwrap();\n\n    let contract = client.contract(contract_address).unwrap();\n\n    let result = contract.call_function(\"getSellNFTQuote\", ())\n        .unwrap()\n        .unwrap();\n\n    println!(\"{:?}\", result);\n}",
        "nl_input": "Calls the contract's `getSellNFTQuote` (0x0c295e56) function",
        "gt": "pub fn get_sell_nft_quote( &self, num_nf_ts: ::ethers::core::types::U256, ) -> ::ethers::contract::builders::ContractCall< M, ( u8, ::ethers::core::types::U256, ::ethers::core::types::U256, ::ethers::core::types::U256, ::ethers::core::types::U256, ), > { self.0 .method_hash([12, 41, 94, 86], num_nf_ts) .expect(\"method not found (this should never happen)\") }",
        "url": 973
    },
    {
        "code_input": "use aes256_gcm::Aes256Gcm;\nuse rand::Rng;\n\nfn main() {\n    let mut rng = rand::thread_rng();\n    let key = [0u8; 32]\n        .into_iter()\n        .map(|_| rng.gen_range(0..256))\n        .collect::<Vec<u8>>();\n\n    println!(\"{:?}\", key);\n}",
        "nl_input": "Generate an AES-256 key",
        "gt": "fn generate_aes_256() -> [u8; 32] { let mut buf = [0u8; 32]; let result = openssl::rand::rand_bytes(&mut buf[..]); assert!(result.is_ok()); buf }",
        "url": 974
    },
    {
        "code_input": "fn main() {\n    let value = -1;\n    match value {\n        -1 => {\n            let result = 255;\n            println!(\"{}\", result);\n        }\n        _ => println!(\"Value does not match the pattern\"),\n    }\n}",
        "nl_input": "EMIT_MIR matches_reduce_branches.match_sext_i8_i16_failed.MatchBranchSimplification.diff Converting `-1i8` to `255i16` is zext.",
        "gt": "fn match_sext_i8_i16_failed(i: EnumAi8) -> i16 { match i { EnumAi8::_128_0x80 => -128, EnumAi8::_1_0xff => 255, EnumAi8::o0_0x00 => 0, EnumAi8::o1_0x01 => 1, EnumAi8::o127_0x7f => 127, } }",
        "url": 975
    },
    {
        "code_input": "pub fn generate_loan_invalidated_at_fact(loan_id: &str, borrower_id: &str) {\n    let loan_status = get_loan_status(loan_id);\n\n    if loan_status {\n        println!(\"loan_invalidated_at(L{}, B{})\", loan_id, borrower_id);\n    }\n}",
        "nl_input": "Generates a new `loan_invalidated_at(L, B)` fact.",
        "gt": "fn emit_loan_invalidated_at(&mut self, b: BorrowIndex, l: Location) { let lidx = self.location_table.start_index(l); self.all_facts.loan_invalidated_at.push((lidx, b)); }",
        "url": 976
    },
    {
        "code_input": "use std::ptr;\nuse std::mem;\n\nfn create_snapshot() -> Vec<u8> {\n    let size = mem::memory_size();\n    let mut snapshot = Vec::with_capacity(size as usize);\n    unsafe {\n        snapshot.append(&mut *ptr::null_mut()..(size as usize));\n    }\n    snapshot\n}",
        "nl_input": "this function will create a memory snapshot and push it onto the stack of snapshots It should be used when you want to save the state of the memory, for example, when evolving a sandbox to a new state",
        "gt": "pub(crate) fn push_state(&mut self) -> Result<()> { let snapshot = SharedMemorySnapshot::new(&mut self.shared_mem)?; self.snapshots .try_lock() .map_err(|e| new_error!(\"Error locking at {}:{}: {}\", file!(), line!(), e))? .push(snapshot); Ok(()) }",
        "url": 977
    },
    {
        "code_input": "use ethers::prelude::*;\nuse ethers::types::Address;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Create a provider instance\n    let provider = Provider::<Http>::try_from(\"http://localhost:8545\")?;\n\n    // Create a signer instance\n    let signer = Signer::new_local(provider, \"your_private_key\");\n\n    // Create a contract instance\n    let contract = Contract::try_from(Address::new_unchecked(\"0xb88d4fde\"))?;\n\n    // Call the contract's safeTransferFrom function\n    let result = contract.call1(\n        \"safeTransferFrom\",\n        (),\n        (),\n        signer,\n    )?",
        "nl_input": "Calls the contract's `safeTransferFrom` (0xb88d4fde) function",
        "gt": "pub fn safe_transfer_from_with_from_and_to_and_data( &self, from: ::ethers::core::types::Address, to: ::ethers::core::types::Address, token_id: ::ethers::core::types::U256, data: ::ethers::core::types::Bytes, ) -> ::ethers::contract::builders::ContractCall<M, ()> { self.0 .method_hash([184, 141, 79, 222], (from, to, token_id, data)) .expect(\"method not found (this should never happen)\") }",
        "url": 978
    },
    {
        "code_input": "use std::net::SocketAddr;\nuse std::io::prelude::*;\nuse std::io::Write;\nuse netlink::{Message, Socket, Error};\nuse socket2::{SocketKind, SocketExt, ConnectError, ConnectResult, SocketExt, ConnectedSocketExt, ConnectedSocket, SocketExt, BindError, BindResult, InetSocketAddr};\n\nfn main() -> Result<(), Error> {\n    // Create a new socket\n    let socket = Socket::",
        "nl_input": "Connects the NIC to a port on the given switch.",
        "gt": "pub fn connect(&mut self, id: &SwitchPortId) -> io::Result<()> { let (switch16, port16) = id.c_ids(); unsafe { vmsif::chk(vmsif::VmsIfNicConnect( self.nic.as_raw_handle(), switch16.as_ptr(), port16.as_ptr(), c16(&self.nic_name)?.as_ptr(), Duration::from_secs(10).as_millis() as u32, ))?; Ok(()) } }",
        "url": 979
    },
    {
        "code_input": "fn find_index(values: &Vec<i32>, target: i32) -> Option<usize> {\n    let mut lower_bound = 0;\n    let mut upper_bound = values.len();\n\n    while lower_bound < upper_bound {\n        let mid_index = lower_bound + (upper_bound - lower_bound) / 2;\n        match values[mid_index].cmp(&target) {\n            std::cmp::Ordering::Equal => return Some(mid_index),\n            std::cmp::Ordering::Greater => lower_bound = mid_index + 1,\n            std::cmp::Ordering::Less => upper_bound = mid_index,\n        }\n    }\n\n    None\n}",
        "nl_input": "Assumes values are in ascending order, returns matching index or the smaller value larger than target. Returns None if target is smaller than the smaller value.",
        "gt": "pub(crate) fn binary_search_or_greater<T: Ord>(target: &T, array: &[T]) -> Option<i32> { let mut l = 0; let mut r = array.len(); while l < r { let mut m = (l + r) / 2; match &array[m].cmp(target) { Ordering::Less => { l = m + 1; } Ordering::Greater => { r = m; } Ordering::Equal => { while m > 1 { if &array[m - 1] == target { m -= 1; } else { break; } } return Some(m as i32); } } } if r == array.len() { return None; } Some(r as i32) }",
        "url": 980
    },
    {
        "code_input": "use std::collections::HashMap;\n\nfn get_dependencies() -> Vec<String> {\n    // This is a placeholder for the function that returns the dependencies of a package.\n    // Replace this with your actual function.\n    vec![\"dep1\", \"dep2\", \"dep3\"]\n}\n\nfn main() {\n    let mut dependencies: HashMap<String, Vec<String>> = HashMap::new();\n\n    for package in get_dependencies() {\n        let package_dependencies = get_dependencies();\n        dependencies.insert(package.to_string(), package_dependencies);\n    }\n\n    println!(\"{:?}\", dependencies);\n}",
        "nl_input": "Generate a map of dependencies from a list of locked packages",
        "gt": "fn generate_dependency_map( locked_deps: &[rattler_lock::LockedPackageRef<'_>], ) -> HashMap<String, Package> { let mut package_dependencies_map = HashMap::new(); for &package in locked_deps { if let Some(package_info) = extract_package_info(package) { package_dependencies_map.insert( package_info.name.clone(), Package { name: package_info.name, version: match package { LockedPackageRef::Conda(conda_data) => { conda_data.record().version.to_string() } LockedPackageRef::Pypi(pypi_data, _) => pypi_data.version.to_string(), }, dependencies: package_info.dependencies.into_iter().unique().collect(), needed_by: Vec::new(), source: package_info.source, }, ); } } package_dependencies_map }",
        "url": 981
    },
    {
        "code_input": "use std::collections::HashMap;\nuse std::sync::{Arc, RwLock};\n\nstatic FONTS: RwLock<HashMap<String, Arc<Font>>> = RwLock::default();",
        "nl_input": "lazy_static! { pub(crate) static ref FONTS: RwLock<HashMap<String, Arc<Font>>> = Default::default(); }",
        "gt": "pub fn get_font(font_name: &str) -> Option<Arc<Font>> { if let Ok(Some(font)) = load_font(font_name) { let font = Arc::new(font); Some(font) } else { None } }",
        "url": 982
    },
    {
        "code_input": "use rusqlite::{params, Connection, Result};\n\nfn main() -> Result<()> {\n    let mut conn = Connection::open(\"my_database.db\")?;\n\n    let sql = \"SELECT * FROM my_table WHERE foo = ? AND bar = ? AND baz = ?\";\n    let params = params![1, 2, 3];\n\n    let rows = conn.query_map(sql, params, |row| {\n        (row.get(0)?, row.get(1)?, row.get(2)?)\n    })?;\n\n    for row in rows {\n        println!(\"{:",
        "nl_input": "CHECK: define{{.*}}5foo11{{.*}}!type ![[TYPE11:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}",
        "gt": "pub fn foo12( _: &(dyn Trait1 + Send + Sync), _: &(dyn Trait1 + Sync + Send), _: &(dyn Trait1 + Sync + Send), ) { }",
        "url": 983
    },
    {
        "code_input": "pub fn is_item_visible(item: &Item) -> bool {\n    if let Some(visible) = item.visible.get() {\n        !visible\n    } else {\n        false\n    }\n}",
        "nl_input": "Checks if an item is visible and not `doc(hidden)` at the completion site.",
        "gt": "pub(crate) fn is_visible<I>(&self, item: &I) -> Visible where I: hir::HasVisibility + hir::HasAttrs + hir::HasCrate + Copy, { let vis = item.visibility(self.db); let attrs = item.attrs(self.db); self.is_visible_impl(&vis, &attrs, item.krate(self.db)) }",
        "url": 984
    },
    {
        "code_input": "I'm sorry, but the information you provided is not clear. Could you please provide more details or clarify what you're asking for?\n",
        "nl_input": "Demo in #48012",
        "gt": "fn foo3r(n: u64) -> u64 { let mut count = 0; (0..n).for_each(|_| { (0..=n).rev().for_each(|j| { count += j; }) }); count }",
        "url": 985
    },
    {
        "code_input": "use serde::{Deserialize, Serialize};\nuse sqlx::{FromRow, SqlitePool};\nuse std::error::Error;\n\n#[derive(Serialize, Deserialize, Debug, Clone)]\nstruct User {\n    name: String,\n    age: i32,\n}\n\nfn main() -> Result<(), Box<dyn Error>> {\n    let pool = SqlitePool::connect(\":memory:\")?;\n\n    let user = User {\n        name: String::from(\"John\"),\n        age: 30,\n    };\n\n    let query = \"INSERT INTO users (name, age) VALUES (:name, :age)\";\n\n    sqlx::query_as(\n        &pool,\n        \"INSERT INTO users (name, age) VALUES (?, ?)\",\n        &[&user.name, &user.age],\n    )?;",
        "nl_input": "Ensure that diagnostics for mutability error (because the root variable isn't mutable) work with `capture_disjoint_fields` enabled.",
        "gt": "fn mut_error_struct() { let x = (10, 10); let y = (x, 10); let z = (y, 10); let mut c = || { z.0.0.0 = 20; }; c(); }",
        "url": 986
    },
    {
        "code_input": "use std::fs::File;\nuse std::io::{self, Write};\nuse std::path::Path;\n\nfn main() -> io::Result<()> {\n    let file_path = Path::new(\"dev/fuse\");\n    let file = File::open(&file_path)?;\n    let mut writer = io::BufWriter::new(file);\n\n    let message = \"An error is assumed to mean that the file system was unmounted.\";\n    writer.write_all(message.as_bytes())?;\n\n    Ok(())\n}",
        "nl_input": "Read a message from ` dev fuse`. An error is assumed to mean that the file system was unmounted.",
        "gt": "fn read(&mut self, buffer: &mut [u8]) -> usize { match self.fuse_dev.read(buffer) { Ok(size) => size, Err(e) => { tracing::warn!( len = buffer.len(), error = &e as &dyn std::error::Error, \"/dev/fuse read failed\", ); 0 } } }",
        "url": 987
    },
    {
        "code_input": "fn main() {\n    let mut data: Vec<u8> = sp1_zkvm::io::read_vec();\n    println!(\"{:?}\", data);\n}",
        "nl_input": "Read a buffer from the input stream. ### Examples ```ignore let data: Vec<u8> = sp1_zkvm::io::read_vec(); ```",
        "gt": "pub fn read_vec() -> Vec<u8> { let len = unsafe { syscall_hint_len() }; let capacity = (len + 3) / 4 * 4; let layout = Layout::from_size_align(capacity, 4).expect(\"vec is too large\"); let ptr = unsafe { std::alloc::alloc(layout) }; let mut vec = unsafe { Vec::from_raw_parts(ptr, 0, capacity) }; unsafe { syscall_hint_read(ptr, len); vec.set_len(len); } vec }",
        "url": 988
    },
    {
        "code_input": "use web3::types::Address;\nuse web3::types::HexValue;\nuse web3::types::Log;\nuse web3::types::Transaction;\nuse web3::types::BlockNumber;\n\npub fn get_token_withdrawal_events(web3: &web3::Web3, contract_address: &Address) -> Vec<Event> {\n    let contract_address = HexValue::new(contract_address.to_string());\n    let event_filter = web3.eth().logs({\n        \"address\": contract_address,\n        \"topic\": Some(\"0x7ff36ab5b14047068d87663eb0145189742715202c99",
        "nl_input": "Gets the contract's `TokenWithdrawal` event",
        "gt": "pub fn token_withdrawal_filter( &self, ) -> ::ethers::contract::builders::Event< ::std::sync::Arc<M>, M, TokenWithdrawalFilter, > { self.0.event() }",
        "url": 989
    },
    {
        "code_input": "use my_crate::*;",
        "nl_input": "if-ext - if macro from different crate (related to callsite code) | cmd \\ attr | no | (unspecified) | external | yes | | no | no | no | no | no | | (unspecified) | no | if-ext | if-ext | yes | | external | no | if-ext | if-ext | yes | | yes | yes | yes | yes | yes |",
        "gt": "fn get_collapse_debuginfo(sess: &Session, attrs: &[ast::Attribute], ext: bool) -> bool { let flag = sess.opts.cg.collapse_macro_debuginfo; let attr = attr::find_by_name(attrs, sym::collapse_debuginfo) .and_then(|attr| { Self::collapse_debuginfo_by_name(attr) .map_err(|span| { sess.dcx().emit_err(errors::CollapseMacroDebuginfoIllegal { span }) }) .ok() }) .unwrap_or_else(|| { if attr::contains_name(attrs, sym::rustc_builtin_macro) { CollapseMacroDebuginfo::Yes } else { CollapseMacroDebuginfo::Unspecified } }); #[rustfmt::skip] let collapse_table = [ [false, false, false, false], [false, ext, ext, true], [false, ext, ext, true], [true, true, true, true], ]; collapse_table[flag as usize][attr as usize] }",
        "url": 990
    },
    {
        "code_input": "fn main() {\n    let mut x = vec![1, 2, 3, 4, 5];\n    let y = x[2];\n    x[2] = 0;\n    println!(\"{}\", y);\n}",
        "nl_input": "We should evaluate `x[2]` and copy the value out *before* evaluating the LHS and changing its value.",
        "gt": "fn evaluate_fru_to_temp_before_assign_slice() { let mut x = &[S(0), S(1), S(2)][..]; let y = &mut S(7); *{ x = &[S(3), S(4), S(5)]; &mut *y } = S { ..x[2] }; assert_eq!(2, y.0); assert_eq!(5, x[2].0); }",
        "url": 991
    },
    {
        "code_input": "fn log(base: u32, value: f64) -> f64 {\n    match base {\n        2 => value.log2(),\n        10 => value.log10(),\n        _ => panic!(\"Base must be 2, 10, or e\"),\n    }\n}",
        "nl_input": "Returns the specialized log method for a given base if base is constant and is one of 2, 10 and e",
        "gt": "fn get_specialized_log_method(cx: &LateContext<'_>, base: &Expr<'_>) -> Option<&'static str> { if let Some(value) = ConstEvalCtxt::new(cx).eval(base) { if F32(2.0) == value || F64(2.0) == value { return Some(\"log2\"); } else if F32(10.0) == value || F64(10.0) == value { return Some(\"log10\"); } else if F32(f32_consts::E) == value || F64(f64_consts::E) == value { return Some(\"ln\"); } } None }",
        "url": 992
    },
    {
        "code_input": "use uuid::Uuid;\nuse chrono::prelude::*;\nuse rand::seq::SliceRandom;\nuse rand::Rng;\n\nfn generate_reset_token(rng: &mut Rng) -> String {\n    let now = Local::now();\n    let expiry = now + Duration::hours(24);\n    let uuid = Uuid::new_v4();\n\n    format!(\n        \"{}.{}.{}.{}.{}\",\n        uuid.0, uuid.1, uuid.2, uuid.3, now.format(\"%Y%m%d%H%M%S\").to_string()\n    )\n}\n\nfn main() {\n    let mut rng = rand::thread_rng();\n    println!(\"{}\", generate_reset_token(&mut rng));\n}",
        "nl_input": "Set the key for reset token generation. Applicable to Server only.",
        "gt": "pub fn set_reset_token_key(&mut self, v: [u8; 64]) { self.reset_token_key = hmac::Key::new(hmac::HMAC_SHA256, &v); }",
        "url": 993
    },
    {
        "code_input": "I'm sorry, but it seems there's a misunderstanding. The query you've provided is not clear. Could you please provide more details or clarify what you're trying to achieve? I'm here to help with any computer science-related questions you might have.\n",
        "nl_input": "Insert a new in-progress query. The query won't have a subscription or token, so you'll need to subsequently call `SyncState::complete_fetch` and `SyncState::fill_subscriptions` to fill out these fields.",
        "gt": "pub fn insert(&mut self, query: Query) -> anyhow::Result<()> { let query_id = query.query_id; if self.in_progress_queries.insert(query_id, query).is_some() { anyhow::bail!(\"Duplicate query ID: {}\", query_id); } self.refill_needed = true; Ok(()) }",
        "url": 994
    },
    {
        "code_input": "pub struct InternId(u32);\n\nimpl InternId {\n    pub fn new(value: u32) -> Option<Self> {\n        if value < MAX {\n            Some(Self(value))\n        } else {\n            None\n        }\n    }\n\n    pub fn value(&self) -> u32 {\n        self.0\n    }\n}",
        "nl_input": "Creates a new InternId. # Safety `value` must be less than `MAX`",
        "gt": "pub const unsafe fn new_unchecked(value: u32) -> Self { debug_assert!(value < InternId::MAX); let value = unsafe { NonZeroU32::new_unchecked(value + 1) }; InternId { value } }",
        "url": 995
    },
    {
        "code_input": "use crate::{\n    schema::{User, Query},\n    types::{Result, UserId},\n};\n\npub fn handle_query(query: &Query) -> Result<User> {\n    match query {\n        Query::GetUser(user_id) => {\n            // Fetch the user from the database using the user_id\n            // Replace this with your actual implementation\n            Ok(User::new(user_id))\n        }\n        Query::Unknown(inner) => {\n            // Handle the unknown query type\n            Err(inner)\n        }\n    }\n}",
        "nl_input": "Do we need a `QueryFunction` impl for this type of query?",
        "gt": "fn needs_query_function(&self) -> bool { match self { QueryStorage::Input | QueryStorage::Interned | QueryStorage::InternedLookup { .. } | QueryStorage::Transparent => false, QueryStorage::Memoized | QueryStorage::LruMemoized | QueryStorage::LruDependencies => { true } } }",
        "url": 996
    },
    {
        "code_input": "fn apply<T, F>(self, f: F) -> Option<T>\nwhere\n    T: FnMut(F::Input) -> F::Output,\n    F: FnMut(F::Input) -> F::Output,\n{\n    match self {\n        Some(module) if module.is_module() => None,\n        _ => Some(f(module)),\n    }\n}",
        "nl_input": "Same as `apply`, but returns `None` if self contains a module predicate",
        "gt": "pub fn apply_any_module(self, tcx: TyCtxt<'tcx>, typing_env: TypingEnv<'tcx>) -> Option<bool> { self.apply_inner(tcx, typing_env, &mut Default::default(), &|_| Err(()), &|_| None).ok() }",
        "url": 997
    },
    {
        "code_input": "fn main() {\n    let x = 5;\n    let y = 10;\n    let z = &x;\n    let w = &y;\n    let result = z;\n    println!(\"{}\", result);\n}",
        "nl_input": "~^ ERROR: mutable references are not allowed in the final value of constants",
        "gt": "const fn trigger() -> [(); unsafe { let s = transmute::<(*const u8, usize), &ManuallyDrop<str>>((S.as_ptr(), 3)); 0 }] { [(); 0] }",
        "url": 998
    },
    {
        "code_input": "use std::fs::File;\nuse std::io::prelude::*;\nuse std::io::SeekFrom;\nuse std::os::unix::io::AsRawFd;\n\nfn insert_file_descriptor(min_fd_num: u32) {\n    // Create a new file descriptor\n    let mut fd = File::create(&mut std::fs::File::stdout()).unwrap();\n\n    // Get the current file descriptor number\n    let current_fd = fd.as_raw_fd().get() as u32;\n\n    // If the current file descriptor number is less than the minimum number,\n    // increment the file descriptor number until it is greater than or equal to the minimum number\n    while current_fd < min_fd_num {\n        fd = File::create(&mut std::fs::File::stdout()).unwrap();\n        current_fd = fd.as_raw_fd().get() as",
        "nl_input": "Insert a file description, giving it a file descriptor that is at least `min_fd_num`.",
        "gt": "fn insert_with_min_num(&mut self, file_handle: FileDescriptionRef, min_fd_num: i32) -> i32 { let candidate_new_fd = self.fds.range(min_fd_num..).zip(min_fd_num..).find_map(|((fd_num, _fd), counter)| { if *fd_num != counter { Some(counter) } else { None } }); let new_fd_num = candidate_new_fd.unwrap_or_else(|| { self.fds.last_key_value().map(|(fd_num, _)| fd_num.strict_add(1)).unwrap_or(min_fd_num) }); self.fds.try_insert(new_fd_num, file_handle).unwrap(); new_fd_num }",
        "url": 999
    }
]