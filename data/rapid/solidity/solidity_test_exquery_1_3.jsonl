[
    {
        "nl_input": "The query requires a function to replace the current owner with a new owner in a smart contract. The function must ensure only authorized entities can execute the change, update the ownership status, and emit appropriate events to reflect the old and new owner addresses after the replacement.",
        "url": 0
    },
    {
        "nl_input": "The query requires a function that computes a real cap using a given cap and key. The function should take two parameters, `_cap` and `_key`, and return the computed value as a `bytes32` hash. This functionality is implemented using the `keccak256` hash function.",
        "url": 1
    },
    {
        "nl_input": "The query requires identifying a constructor function in Solidity where the function name must match the contract name. Among the provided codes, none explicitly show a constructor function that matches the contract name.",
        "url": 2
    },
    {
        "nl_input": "To qualify for a holder reward, a specific amount of Kitten Coins must be held. The exact threshold or calculation for the required amount is not explicitly defined in the provided code snippets. However, it typically depends on predefined conditions such as token tiers or balance caps, which determine eligibility for bonus rewards.",
        "url": 3
    },
    {
        "nl_input": "The query requires a function that retrieves the balance of a specific user account, taking an address as input and returning the corresponding balance. The function should be publicly accessible and view-only, ensuring no state modifications occur during the query.",
        "url": 4
    },
    {
        "nl_input": "The query requires a function to burn tokens from a user's account, with checks for sufficient balance and approval. It should emit a burn event and reduce the total supply accordingly.",
        "url": 5
    },
    {
        "nl_input": "The query requires a method that updates the current state of tranches and the current round based on specific conditions, such as checking if funding is complete or expired and transitioning between rounds accordingly.",
        "url": 6
    },
    {
        "nl_input": "The query suggests a scenario where a castle ceases to exist or becomes irrelevant. The relevant requirement from the provided code is the self-destruction of a contract when specific conditions are met, such as surrendering control and transferring balance. This reflects the end or collapse of an entity, analogous to a castle being \"no more.\"",
        "url": 7
    },
    {
        "nl_input": "The query requires a function that logs or retrieves data associated with a specific request ID, indicating an intent to access or track stored request information.",
        "url": 8
    },
    {
        "nl_input": "The query seeks a function that allows a controller to step down or relinquish control. The relevant code provides a method `detachController()` accessible only by the controller, which sets the controller address to zero and emits an event upon successful execution.",
        "url": 9
    },
    {
        "nl_input": "The query describes a function that allows for the withdrawal of tokens from a contract. It involves ensuring that unbought tokens are returned to the seller, handling token transfers under specific conditions, and allowing withdrawals of mistakenly sent tokens by the owner. The function must support multiple withdrawal scenarios, including post-purchase withdrawals, game-related token transfers, and manual owner-initiated withdrawals.",
        "url": 10
    },
    {
        "nl_input": "The query requires a public interface to access and retrieve information about games in a directory. This includes functions to get the total number of games, retrieve detailed information about a specific game (such as contract address, description, URL, submitter, and time), and check if a game is active.",
        "url": 11
    },
    {
        "nl_input": "The query requires a function that allows any user to retrieve their assigned prize, calculating the sum of payouts for all tokens owned by the caller. The function should revert if no prize is available, ensuring no gas cost to the caller in such cases.",
        "url": 12
    },
    {
        "nl_input": "The query requires a function to add a new casino with attributes such as star rating, price, name, and description. The function should create a new casino entry, assign a unique ID, and store it in a list and mapping for tracking.",
        "url": 13
    },
    {
        "nl_input": "The query focuses on the functionality of transferring tokens from one account to another within a blockchain contract. It emphasizes the need for a function that enables token transfers, ensuring proper deduction from the sender's balance and updating the recipient's balance accordingly. The function should support internal transfers, maintain accurate token balances, and emit appropriate events to log the transaction.",
        "url": 14
    },
    {
        "nl_input": "The query requires a function to toggle a locked flag in a smart contract, accessible only by the owner. It involves flipping the `locked` state between true and false and emitting an event upon toggling.",
        "url": 15
    },
    {
        "nl_input": "The query requires a function that allows the `pendingOwner` to finalize an ownership transfer within a specific block number range (start and end). The function should validate the time condition using `block.number`, update the owner, reset the pending owner, and potentially adjust time-related variables.",
        "url": 16
    },
    {
        "nl_input": "The query seeks a description of requirements related to overriding the `transfer` function in a token contract. The desired functionality includes adding conditions that must be satisfied for a transfer to proceed, such as checking permissions or token availability, and returning false or reverting if they are not met.",
        "url": 17
    },
    {
        "nl_input": "The query requires a function to allocate tokens to specified addresses, potentially with parameters such as receiver address, investment amount, and optional tracking ID. It implies the need for internal handling, validation, and emission of token transfer events.",
        "url": 18
    },
    {
        "nl_input": "The query requires a description of an `allowance` function in a smart contract that takes two addresses (`_owner` and `_spender`) and returns the remaining allowed amount. The function should be external or public, and ideally constant or pure. Three reference implementations are provided, each with slight variations in visibility, mutability, and return value.",
        "url": 19
    },
    {
        "nl_input": "The query describes a mechanism where execution is delegated to another contract, typically involving a low-level call that transfers control and returns results back to the external caller. It may involve setting or changing the delegate contract address and handling return data accordingly.",
        "url": 20
    },
    {
        "nl_input": "The query seeks to determine whether a project has been canceled. It refers to a function `isProjectCanceled(uint64 projectId)` that recursively checks if a project or its parent project has been canceled, based on the admin type and cancellation status.",
        "url": 21
    },
    {
        "nl_input": "The query requires a function that checks whether the length of a string is within specified minimum and maximum bounds. The function should accept the string and the min/max values as parameters and return a boolean indicating if the condition is met.",
        "url": 22
    },
    {
        "nl_input": "The query requires setting a cooldown period, typically for a breeding or childbirth process, involving functions that update cooldown timestamps or indexes based on specific conditions.",
        "url": 23
    },
    {
        "nl_input": "The query requires setting a contract address that is permitted to call the `vacate` function on the current contract. This functionality likely involves restricting access to the `vacate` method, ensuring only a designated contract can invoke it. The code should include a method to update this designated address, with appropriate access control such as ownership verification.",
        "url": 24
    },
    {
        "nl_input": "The query requires a function to buy tokens using Ether. The function should handle Ether payments, calculate token amounts based on a price, update user balances, and include validations such as minimum investment, supply limits, and time constraints. It should also emit relevant events for tracking purchases.",
        "url": 25
    },
    {
        "nl_input": "The query seeks to determine the number of token base units required per grain by extracting relevant information from the provided code snippets.",
        "url": 26
    },
    {
        "nl_input": "The query requires a function to update the multi-signature address in a smart contract, ensuring only authorized entities can make the change. The function should validate the new address is not zero and emit an event upon successful update.",
        "url": 27
    },
    {
        "nl_input": "The query requires checking whether the `burnToken` function can only be executed after a condition indicating the end of a token sale is met. The function should include validation to ensure it runs only once and modifies relevant supply variables upon successful execution.",
        "url": 28
    },
    {
        "nl_input": "When the token generation minimum is not met, TGE participants can request a refund by calling the appropriate function. The process involves checking conditions such as contribution amount, sale status, and token supply. Participants can then receive a refund in ETH or tokens while updating contract balances and logs accordingly.",
        "url": 29
    },
    {
        "nl_input": "The query requires a function that can only be called by the contract itself, ensuring execution exclusively through a script initiated by the contract. It enforces a quorum mechanism, restricting external entities from invoking it directly. This guarantees that specific internal logic, such as adding signers or executing critical operations, is triggered solely via predefined contractual processes.",
        "url": 30
    },
    {
        "nl_input": "The query seeks to determine the balance of tokens in a wallet address provided as input. The required functionality is implemented by a `balanceOf` function that accepts an address and returns the token balance stored in a mapping called `balances`. All three code snippets provide this functionality with slight variations in naming and syntax, but they serve the same purpose.",
        "url": 31
    },
    {
        "nl_input": "The query seeks to determine the number of wei required to purchase 0.01 Mozo token. It refers to a function that retrieves a rate, used for calculating token purchases based on ether amounts, with specific focus on small token quantities.",
        "url": 32
    },
    {
        "nl_input": "The query requires a function that allows the owner to rescue or transfer all Ether held by the contract to a specified address. The function should be accessible only to the owner and must ensure secure and efficient Ether transfer.",
        "url": 33
    },
    {
        "nl_input": "The query seeks to identify and extract information related to owner configuration in smart contract code. This includes functions or mechanisms for changing ownership, setting or enabling owner addresses, and modifiers restricting function execution to the owner. The focus is on understanding how ownership is managed and controlled within the contracts.",
        "url": 34
    },
    {
        "nl_input": "The query requires a function that calculates and returns both the token amount and the USD value based on a given input. It involves checking for zero values, computing USD value with an ether price, and delegating to internal functions to determine the final token and USD amounts.",
        "url": 35
    },
    {
        "nl_input": "The query seeks methods for managing user authorization in smart contracts. The provided code includes functions to authorize addresses, restrict access via modifiers, and enforce authorization checks, ensuring only designated users can perform specific actions.",
        "url": 36
    },
    {
        "nl_input": "The query describes a scenario where a customer buys a box through a function named `buyBox1()`. The function enforces several conditions, including preventing contract callers, ensuring the sale is active, and validating the payment. It also includes logic for determining the grade of an item (e.g., star rating) based on randomness and limits, and it handles excess funds by refunding them.",
        "url": 37
    },
    {
        "nl_input": "The query seeks to retrieve the sale prices of any property in ETH and PXL tokens. The relevant code should include a function that, given a property ID, returns the sale prices in both ETH and PXL, checking if the property is for sale by verifying ownership and then fetching the respective prices.",
        "url": 38
    },
    {
        "nl_input": "The query seeks to determine the total remaining free trial drops of a token. The relevant code provides a function that checks if a token has a free trial, then calculates and returns the remaining drops based on the difference between the maximum allowed and those already used.",
        "url": 39
    },
    {
        "nl_input": "The query describes a scenario where transferring ownership of a contract results in the destruction of the contract. The relevant code would need to include a function that both transfers ownership and triggers self-destruction. However, none of the provided contracts combine these two actions in a single function. Contract `c29626` allows transferring ownership of another contract, `c16046` changes ownership of the current contract, and `c14558` contains a kill function for self-destruction, but no ownership transfer is involved. Therefore, no single piece of code satisfies the query's requirement of transferring ownership and destroying the contract as a result.",
        "url": 40
    },
    {
        "nl_input": "The query describes a function that transfers tokens from the sender's account to a specified address, ensuring the transfer amount is valid and updating the balances accordingly.",
        "url": 41
    },
    {
        "nl_input": "The query requires a function that allows the owner to change the token exchange rate, with a default value of 0.005 Ether. The function should ensure that only the owner can update the rate, reflecting dynamic adjustments based on predefined conditions.",
        "url": 42
    },
    {
        "nl_input": "The query requires a function that can be called by a provider to immediately return a subscription deposit to a customer when the subscription is in a CANCELED state. The function must validate that the caller is authorized (either the customer or the owner), ensure the subscription is canceled, and trigger the deposit return process.",
        "url": 43
    },
    {
        "nl_input": "The query requires a function that sets an approval expiry window in seconds before the contract is locked. It should be callable only by the owner and executed prior to locking the contract.",
        "url": 44
    },
    {
        "nl_input": "The query requires retrieving the BOP balance for a specified address by calling a `balanceOf` function in a smart contract. The function should accept an address parameter and return the corresponding balance, as demonstrated by existing implementations that access a `balances` mapping or delegate to another contract's method.",
        "url": 45
    },
    {
        "nl_input": "The query highlights the importance of marking functions that do not interact with the blockchain state as `pure` rather than `constant`. It suggests optimizing function declarations for clarity and efficiency in smart contract development.",
        "url": 46
    },
    {
        "nl_input": "The query seeks a mechanism to reallocate or handle unsold and leftover tokens, potentially by transferring them back to the seller or reallocating them within the system.",
        "url": 47
    },
    {
        "nl_input": "The query focuses on a scenario where a user requests a withdrawal but later decides to cancel that request. The relevant functionality allows the user to continue participating (e.g., playing) by resetting or clearing the pending withdrawal.",
        "url": 48
    },
    {
        "nl_input": "The query requires a function to mint tokens and assign them to a specified address. The function should handle the token creation, assign ownership, and emit a transfer event from a zero address to the recipient. Additionally, it should ensure the recipient address is valid and may include internal logic for adding the token to their balance.",
        "url": 49
    },
    {
        "nl_input": "The query requires an internal function that determines the current bonus during an ICO, where the bonus decreases weekly (35%, 25%, 15%, 5%) and is set to zero after the fourth week. The function should operate only during the main public ICO stage based on time conditions.",
        "url": 50
    },
    {
        "nl_input": "The query requires calling a token allocation function across all token bankrolls. The relevant code (url 51) demonstrates this by invoking `_tokenAllocate()` multiple times with different values, indicating bulk token distribution across specified bankrolls.",
        "url": 51
    },
    {
        "nl_input": "The query requires a token transfer function that allows the owner to send tokens from their account to another, ensuring sufficient balance and supporting zero-value transfers, with a developer override option.",
        "url": 52
    },
    {
        "nl_input": "The query requires a function to send a token to a specified user address. The function should take the recipient address as a parameter, ensure the sender has sufficient balance, deduct the token amount from the sender, add it to the recipient, and emit a transfer event to reflect the change in ownership.",
        "url": 53
    },
    {
        "nl_input": "The query requires extracting 256-bit (32 bytes) worth of data from a byte stream at a specified offset. The function should return the extracted data as a `bytes32` type, shifting and combining individual bytes appropriately to form the final 256-bit value.",
        "url": 54
    },
    {
        "nl_input": "The query requires retrieving all relevant information about a specific element, including its token ID, name, selling price, owner, and associated scientist ID. The data should be returned in a structured format for a given token identifier.",
        "url": 55
    },
    {
        "nl_input": "The query requires identifying code segments that check for operational status or revert under certain conditions. The first contract uses a modifier `isOperational` to enforce operational status, the third contract reverts with descriptive messages based on funding and configuration states, while the second handles finalization logic without direct reverts.",
        "url": 56
    },
    {
        "nl_input": "The query requires a function that calculates the total payout amount, commission, and donation amounts based on a given total bet amount. It involves applying commission and donation rates, computing the respective portions, and transferring the calculated values to designated addresses.",
        "url": 57
    },
    {
        "nl_input": "The query requires identifying code that handles transaction deletion or removal within a blockchain contract. The relevant code should involve operations like removing entries from mappings, updating data structures, or emitting events related to deletion. Among the provided contracts, only the third one (`c9143`) fully meets these requirements by implementing a `deleteTx` function that removes transaction data and updates associated structures.",
        "url": 58
    },
    {
        "nl_input": "The query requires an external function to add a new dungeon floor by ID, accessible only to contract owners for altering the dungeon state.",
        "url": 59
    },
    {
        "nl_input": "The query requires a function that calculates the number of tokens to be transferred to an investor based on the amount of ether they have invested. The calculation should consider a predefined token rate or exchange rate between ether and tokens.",
        "url": 60
    },
    {
        "nl_input": "The query describes a scenario where the owner of a contract can authorize a crowdsale contract to distribute tokens. This functionality is implemented using a modifier and a function that allows the owner to set distributor addresses with permission to transfer or distribute tokens.",
        "url": 61
    },
    {
        "nl_input": "The query requires a function to create a request and assign it the next available ID. The function should increment the current ID, store request details including type, target, value, message, and creation date, and emit a `RequestCreated` event. It must be accessible only to an admin user.",
        "url": 62
    },
    {
        "nl_input": "The query requires a function that allows the `msg.sender` to assign an allowance of `_value` tokens to a specified `_spender` address, enabling the spender to use funds on behalf of the sender. The function should take `_spender` and `_value` as parameters, update the allowance mapping, and return a boolean indicating success.",
        "url": 63
    },
    {
        "nl_input": "The query requires a function that allows depositing funds into a contract, ensuring only whitelisted users can deposit, and updating their token balance accordingly. It involves handling ETH or token transfers, maintaining deposit records, and emitting appropriate events.",
        "url": 64
    },
    {
        "nl_input": "The query describes a functionality that allows users to withdraw deposited funds from a contract. The most relevant code implements a `withdraw()` function that ensures system safety checks, handles deposit retrieval, and emits a withdrawal event. Other variations involve additional parameters, bonus calculations, or admin controls, but the core need revolves around securely withdrawing user deposits.",
        "url": 65
    },
    {
        "nl_input": "The query requires a contract mechanism that restricts function execution to only those users who are recognized as payers, based on a condition within the contract code.",
        "url": 66
    },
    {
        "nl_input": "The query describes a function that allows the owner to transfer tokens from one address to another. The function includes restrictions such as being callable only by the owner, requiring a non-zero amount, ensuring the current time is before a specific limit, and verifying that neither the sender nor receiver is part of a restricted group (e.g., congress).",
        "url": 67
    },
    {
        "nl_input": "The query requires a function that allows a sender to make a payment on behalf of another user, involving a central database identifier (UUID v4) and utilizing the `msg.sender` for transaction handling.",
        "url": 68
    },
    {
        "nl_input": "The query seeks to identify code that allows adding a \"burning man\" or addresses authorized to burn tokens. The relevant functionality includes adding an address to a list of authorized burners, often with checks to prevent duplicates and utilizing ownership or multi-signature controls.",
        "url": 69
    },
    {
        "nl_input": "The query requires a function to add addresses to a whitelist, with support for adding multiple addresses at once. The function should include access control (e.g., only admin or owner), input validation (non-zero address), and proper storage updates. Event emission and efficient iteration over the input list are also important.",
        "url": 70
    },
    {
        "nl_input": "The query requires a function to freeze an account at a specified address, preventing it from sending or receiving funds. The function should be owner-restricted, update the frozen status of the account, and trigger an event to log the action.",
        "url": 71
    },
    {
        "nl_input": "The query requires setting an address with the authority to approve users via KYC. The relevant code defines a function `setKycProvider(address who)` that assigns the KYC provider's address, ensuring only the owner can make this change.",
        "url": 72
    },
    {
        "nl_input": "The query requires a function that returns the price of a registered asset in the format `(bool areRecent, uint[] prices, uint[] decimals)`, where `areRecent` indicates if the prices are fresh, `prices` is an array of asset prices, and `decimals` is an array of corresponding decimal places.",
        "url": 73
    },
    {
        "nl_input": "The query requires a function to remove or cancel an auction by deleting the auction data associated with a specific identifier (e.g., `_deedId` or `_partId`). The function may involve additional steps such as transferring ownership back to the seller and emitting an event.",
        "url": 74
    },
    {
        "nl_input": "The query requires retrieving the dividends of the owner, which involves calculating and returning the dividends, potentially including a bonus. The relevant function `getDividendsOf_` is used for this purpose, operating internally and viewing the dividend data without modifying the contract state.",
        "url": 75
    },
    {
        "nl_input": "The query requires creating a new product contract that allows marking a product with details such as item hash, enforces permissions, and handles fee transfers. It involves defining functions for product ownership transfer, brand and app validations, and emitting relevant events upon successful execution.",
        "url": 76
    },
    {
        "nl_input": "The query seeks to identify functions related to unpausing a smart contract. The relevant code includes functions named `unpause` that set the contract's `paused` state to `false`, often restricted to specific roles like `onlyManager` or `onlyOwner`, and may emit an `Unpause` event.",
        "url": 77
    },
    {
        "nl_input": "The query requires a description of a system that allows anyone to contribute funds to a \"buy executor's reward.\" Based on the provided code, this functionality is represented by a contract with a payable function that accepts contributions and adds them to a reward pool. The most relevant code defines a simple `add_reward` function that increases the reward value with incoming payments. Other functions involve withdrawing rewards or buying shares but do not directly address allowing open contributions to a reward. \n\n**Description:**  \nA function should allow any user to send funds to increase a shared buy executor's reward pool.",
        "url": 78
    },
    {
        "nl_input": "The query requires a function that allows users to donate for an event. The function should accept the event address and donation amount as parameters, ensure the event is active, transfer the donation, and emit a contribution event.",
        "url": 79
    },
    {
        "nl_input": "The query requires a function that adds an owner to a contract, ensuring the new owner is not the zero address and is successfully added to the list of owners. The function should include access control to restrict adding owners to authorized accounts only.",
        "url": 80
    },
    {
        "nl_input": "The query requires a description of a function that checks whether a sufficient fee is provided. The function should compare the sent value against a stored or calculated fee amount and potentially handle insufficient fees by throwing an error or taking corrective action.",
        "url": 81
    },
    {
        "nl_input": "The query seeks a function that returns the current state of a game, including details such as game ID, direction, bet amount, roll values, and winnings for a given player.",
        "url": 82
    },
    {
        "nl_input": "The query requires a function that calculates the amount of tokens (e.g., WPX) received based on a given wei value and predefined exchange rates per 1 ETH. The calculation should apply different rates depending on the wei tier, multiply the wei by the selected rate, and return the resulting token amount, potentially using safe math operations.",
        "url": 83
    },
    {
        "nl_input": "The query requires a function to pause and unpause an ICO, where only the sender (owner) is allowed to trigger these actions. The function must ensure that pausing or unpausing can only be done by the owner of the contract.",
        "url": 84
    },
    {
        "nl_input": "The query requires a function that allows the contract owner to close a sale, emitting a burn event for unsold tokens and setting a closing flag. The function should be restricted to the owner and executed before the sale is considered closed.",
        "url": 85
    },
    {
        "nl_input": "The query requires a function to add KYC-approved addresses to a whitelist, enabling only authorized entities to approve users for compliance with regulatory requirements.",
        "url": 86
    },
    {
        "nl_input": "The query seeks a modifier in a smart contract that allows actions to be performed by anyone. From the given code options, the relevant modifier is `whenEveryone()`, which ensures that an action can be executed as long as `everyoneDisabled` is false, effectively allowing unrestricted access when enabled.",
        "url": 87
    },
    {
        "nl_input": "The query seeks a safeguard mechanism for investors who might lose access to their funds. The relevant code should include features that protect investor assets, potentially through time-based release schedules or additional security checks before fund transfers occur.",
        "url": 88
    },
    {
        "nl_input": "The query requires a function that returns the owner of a soul. The relevant code provides functions to retrieve an owner's address, either by index or through a view function. The most suitable implementation directly returns the owner without requiring parameters, aligning with the concept of retrieving the current owner of a soul.",
        "url": 89
    },
    {
        "nl_input": "The query requires functionality to put a \"LinglongCat\" up for auction. The relevant code allows the owner of a LinglongCat to initiate a sale auction with specified parameters such as starting price, ending price, and duration. It checks ownership and ensures the cat is not pregnant before approving and creating the auction.",
        "url": 90
    },
    {
        "nl_input": "The query requires a function that allocates tokens to specified addresses. The function should accept an address or list of addresses and distribute tokens accordingly. It may include additional parameters like investment amount or UUID for tracking. Access control (e.g., owner-only or proxy use) and internal handling are also relevant considerations.",
        "url": 91
    },
    {
        "nl_input": "The query describes a scenario where a function can only be executed either before or after tokens have been released. This implies a conditional logic based on the token release state, as seen in the provided code examples involving modifiers and functions tied to a `released` state.",
        "url": 92
    },
    {
        "nl_input": "The query seeks information on how bonuses are distributed based on token investment tiers. The relevant code describes a tiered bonus system where investors receive additional tokens depending on the amount invested, with specific percentages for different ranges of token purchases.",
        "url": 93
    },
    {
        "nl_input": "The query seeks functionality to lock or disable ERC721 token behavior, preventing transfers and enabling controlled trading on third-party platforms. It requires mechanisms like pausing transfers, disabling ERC721 functionality, or restricting operations using modifiers or access controls.",
        "url": 94
    },
    {
        "nl_input": "The query requires a function that returns the address of the smart contract in which it is called. The function should be internal, view-only, and return the contract's own address using `this`.",
        "url": 95
    },
    {
        "nl_input": "The query requires a function that allows the `msg.sender` to set an alias for their address, storing the alias and associating it with the sender's address. It involves mapping the sender\u2019s address to the provided alias and vice versa.",
        "url": 96
    },
    {
        "nl_input": "The query describes a voting system where an account can cast votes for a participant or candidate. The system enforces constraints such as preventing self-voting, limiting the total votes an account can use, and ensuring votes are cast within a defined period or ballot.",
        "url": 97
    },
    {
        "nl_input": "The query requires a function to lock a specific address until a specified time, preventing its access or transactions until that time is reached. The function should allow setting the lock time for an address, ensure only authorized access, and emit an event upon successful lockup.",
        "url": 98
    },
    {
        "nl_input": "The query specifies that only the KittyGym and Arena contracts should be authorized to make changes to KittyData. This requirement is reflected in the first code snippet, which defines a modifier `onlyVerified()` that restricts function access to those two contracts. The resulting description of the query\u2019s needs is:\n\nOnly the KittyGym and Arena contracts should have permission to modify KittyData, ensuring that no other entities can alter the data without authorization.",
        "url": 99
    },
    {
        "nl_input": "The query requires a function to set the enabled status of an account in a smart contract. The function should allow only authorized access, and update the status based on provided parameters.",
        "url": 100
    },
    {
        "nl_input": "The query describes a function that sends a given value to the next investor(s) in a list. It involves transferring funds, updating balances, and recursively handling cases where the current investor's balance is insufficient. The process includes error handling for failed transfers and iterating through the investor list.",
        "url": 101
    },
    {
        "nl_input": "The query requires functionality to change the treasury address and forward payments to a specified address. The code should include a method to set the treasury address and handle payment forwarding logic, ensuring the amount is transferred correctly after deducting fees or other conditions.",
        "url": 102
    },
    {
        "nl_input": "The query requires identifying a function that can be executed only once, as indicated by the \"onlyOnce\" modifier in the code from URL 961. This modifier restricts function execution based on a condition involving \"functAttempts\".",
        "url": 103
    },
    {
        "nl_input": "The query requires a function to migrate token holders to a new contract. The migration can only be initiated by the owner and must transfer tokens using a migration agent. It processes a batch of holders, updates balances, and emits a migration event. The migration count is tracked, ensuring it does not exceed the total number of holders.",
        "url": 104
    },
    {
        "nl_input": "The query requires storing a gas price as a storage variable and updating it using the appropriate Oraclize function. It also implies the need for a function to modify this stored gas price, ensuring it is properly referenced and adjusted within the contract.",
        "url": 105
    },
    {
        "nl_input": "The query describes a function to send tokens to a partner, calculating the amount based on a percentage of the supply limit and subtracting already sold tokens. It involves checks to ensure the action is performed only once and emits relevant events.",
        "url": 106
    },
    {
        "nl_input": "The query requires a function to self-register a new DIN and set its resolver address, returning the registered DIN. The implementation should allow the caller to specify the resolver and return the DIN upon successful registration.",
        "url": 107
    },
    {
        "nl_input": "The query requires an internal function that transfers ownership of a team. The function should handle ownership transfer by updating owner records, adjusting token counts for the old and new owners, and emitting a transfer event. It should take parameters for the original owner address, new owner address, and the team ID.",
        "url": 108
    },
    {
        "nl_input": "The query describes a function that updates or sets a parameter identified by a given name to a specified value. It involves storing or modifying data using a key-value mechanism, where the key is derived from the provided name and the value is updated accordingly.",
        "url": 109
    },
    {
        "nl_input": "The query requires a function to set or update the token address in a smart contract, with access restricted to specific roles (e.g., founder or owner), and may include checks such as ensuring the token is not already deployed.",
        "url": 110
    },
    {
        "nl_input": "The query requires a function to manually perform a health check, which should be executable by the owner and trigger a security or system check process. It may involve setting a maintenance mode and verifying system status through an external call or internal logic.",
        "url": 111
    },
    {
        "nl_input": "The query requires a function to set or change the token wallet address in a smart contract, with access restricted to the owner. The function should validate the new address (non-zero and possibly not already set), and emit an event or return a boolean indicating success. Additionally, it may include checks to prevent setting invalid addresses such as the contract itself or the token address.",
        "url": 112
    },
    {
        "nl_input": "The query requires a function that checks whether a given address is registered. The desired functionality includes accepting an address as input and returning a boolean value indicating registration status.",
        "url": 113
    },
    {
        "nl_input": "The query requires a function that returns the total supply of tokens in a smart contract. The function should be publicly accessible, constant (view), and return a `uint256` value representing the total token supply.",
        "url": 114
    },
    {
        "nl_input": "The query requires adding a minter to the TAU token contract after deployment. The relevant function `addMinter` from contract `c24644` should be called, which allows the owner to add a new minter address to the list of authorized minters.",
        "url": 115
    },
    {
        "nl_input": "The query requires a function to transfer shares to another Ethereum address, including checks for valid input, sufficient balance, and updating sender and receiver balances. It also involves maintaining shareholder records and triggering an event upon successful transfer.",
        "url": 116
    },
    {
        "nl_input": "The query requires a function to close a fund, which should check if the balance is below a minimum threshold, update the state to closed, transfer remaining funds to a team wallet, and emit a closure event. The function must be accessible only to the owner and callable only in a withdraw state.",
        "url": 117
    },
    {
        "nl_input": "The query requires a function to distribute tokens, emphasizing conditions such as sender authorization, supply limits, and token transfer. It implies controlling distribution amount, recipient address, and ensuring no oversupply. The function should also trigger an event upon successful distribution.",
        "url": 118
    },
    {
        "nl_input": "The query seeks to collect all fees paid up to the current point in time. The relevant functionality is found in a function that calculates and collects a fee based on provided parameters, transferring it to a specified address while ensuring sufficient balance and handling remaining ether appropriately.",
        "url": 119
    },
    {
        "nl_input": "The query requires a function that updates the token fee for approving a transfer. The function should take a new fee value as input, update the `transferFee`, and emit an event indicating the fee change. It should be accessible only to a validator role.",
        "url": 120
    },
    {
        "nl_input": "The query requires a function to burn tokens from a sender's balance. The function should verify sufficient balance, deduct the specified amount from the sender's balance, reduce total supply, and emit a burn event. It may require authorization or owner restriction.",
        "url": 121
    },
    {
        "nl_input": "The query requires identifying code patterns where the `require()` function is used with a generic condition, specifically without direct parameter substitution. The relevant pattern involves simple state variable checks in modifiers, such as `require(operational)`, `require(!locked)`, and `require(now >= releaseDate)`. These examples demonstrate basic conditional validations within contract modifiers, aligning with the requirement for generic usage of `require()`.",
        "url": 122
    },
    {
        "nl_input": "The query seeks a public getter function for an action mapping in Solidity that is compatible with web3.js. The ideal function should return structured data about an action, such as confirmations, expiration, triggered status, target address, and value, aligning with web3.js expectations for readable contract methods.",
        "url": 123
    },
    {
        "nl_input": "The query requires a function that allows the contract owner to remove a specified address from a blacklist. The function should be external, restricted to the owner, and update the blacklist status of the target address to `false`.",
        "url": 124
    },
    {
        "nl_input": "The query requires a helper method that retrieves token details including name, symbol, and total supply in a single call. The preferred implementation returns all three values together, as seen in the first code snippet.",
        "url": 125
    },
    {
        "nl_input": "The query requires a function that determines the amount of Token that can be withdrawn from a contract by checking deposit details and stake types, considering time-based conditions and stake status.",
        "url": 126
    },
    {
        "nl_input": "The query requires a function that retrieves the actual staked amounts for active personal stakes of a given address, returning an array of these amounts.",
        "url": 127
    },
    {
        "nl_input": "The query describes a function that allows a whitelisted internal application to set the ICO end date exactly once. The function must ensure that the ICO end date can only be set one time (i.e., it cannot be changed after being set once). Additionally, the function should be restricted to whitelisted addresses and can only be executed when the contract is not paused.",
        "url": 128
    },
    {
        "nl_input": "The query seeks a function that allows setting or changing the controller address in a smart contract. It involves identifying functions that enable controller updates, typically through an external call with access control restrictions like `onlymanyowners` or `isAdmin`. The function may emit an event after updating the controller and often includes validation such as ensuring the new address is not zero.",
        "url": 129
    },
    {
        "nl_input": "The query requires a function that sets a share cut percentage for the contract owner, which is applied to the seller during a successful sale. The function should allow adjustment of the owner's share cut, enforce a maximum limit (e.g., less than 100), and emit an event when changed.",
        "url": 130
    },
    {
        "nl_input": "The query requires a function to update the access manager address in a smart contract. The function should allow only authorized entities to set a new address, ensuring it is not a zero address, and should store or update this address in the contract's state.",
        "url": 131
    },
    {
        "nl_input": "The query requires generating a giant cat image using on-chain data. The provided code defines a function `getCatImage` that returns pixel data for a cat image as a `bytes32` array, indicating an on-chain image generation approach. No external image resources are used, and the image is hardcoded directly into the contract.",
        "url": 132
    },
    {
        "nl_input": "The query requires a function that retrieves the commitment associated with a specified address in a smart contract. The function should accept an address parameter and return the corresponding commitment value, which is stored and accessible through a mapping or similar structure in the contract.",
        "url": 133
    },
    {
        "nl_input": "The query requires a function that allows changing the wallet address for reserved vesting, enabling the setting of a smart contract address at a later stage. It should be accessible only by the owner and include an event or confirmation upon successful update.",
        "url": 134
    },
    {
        "nl_input": "The query requires functionality to create or update a claim about oneself, involving setting key-value claims for the sender's address. The relevant code should allow a user to register or modify personal claim data on the blockchain.",
        "url": 135
    },
    {
        "nl_input": "The query seeks to determine whether a given user address belongs to a specific group or meets a certain condition, such as being a registered user, investor, or entity. It involves checking membership or status using functions like `isUserInGroup`, `isUser`, or `isInvestor` in smart contracts.",
        "url": 136
    },
    {
        "nl_input": "The query requires a function to transfer any accidentally sent ERC20 tokens from a contract to the owner. The function should be accessible only to the owner and ensure safe transfer.",
        "url": 137
    },
    {
        "nl_input": "The query requires a function that retrieves the amount of tokens remaining that can be spent or transferred, based on an owner-spender relationship. The function should take two addresses as parameters \u2014 the token owner and the spender \u2014 and return a non-negative integer representing the remaining token allowance.",
        "url": 138
    },
    {
        "nl_input": "The query requires a function that forwards a payment from the sender to a specified address 'to', ensuring validation checks and proper transfer of funds.",
        "url": 139
    },
    {
        "nl_input": "The query requires a function to add an address to an accredited list, including parameters for investor details and restrictions. The function must be accessible only to the owner and include validations for input data. An event should trigger upon successful addition.",
        "url": 140
    },
    {
        "nl_input": "The query seeks a function to unpause a token contract, allowing transfers to resume. The function should be accessible only to the owner and invoke the token's `unpause()` method. It is necessary for the ICO contract owner to trigger this function, ensuring the token contract, initially paused, can proceed with transfers after deployment.",
        "url": 141
    },
    {
        "nl_input": "The query requires a function to freeze multiple Ethereum addresses, preventing them from sending or receiving tokens. The function should allow the owner to specify an array of addresses and a freeze status. Additional variations may include requiring timestamps for freezing or performing checks on input data.",
        "url": 142
    },
    {
        "nl_input": "The query requires a function to create a Tuber with parameters including name, owner, and price. The function should handle unique Tuber ID generation, store the Tuber data, track its price, and emit events upon creation. It also involves internal transfers and validation of the Tuber ID type.",
        "url": 143
    },
    {
        "nl_input": "The query seeks to determine the number of decimals a token uses. It refers to a function in a smart contract that returns the decimal value of the token, which is typically used to specify the divisibility or precision level of the token in transactions.",
        "url": 144
    },
    {
        "nl_input": "The query refers to a function that allows users to redeem MTU tokens. The function checks if the user has applied units, and depending on the redeem flag, either transfers ETH based on a redemption rate or returns MTU tokens. It also updates redeemed amounts and emits an event upon successful redemption.",
        "url": 145
    },
    {
        "nl_input": "The query requires a function that calculates the number of tokens received based on the amount of wei provided. The function should take wei as input and return the corresponding token amount, potentially involving exchange rates or tiered pricing models.",
        "url": 146
    },
    {
        "nl_input": "The query requires handling contribution amounts and cap logic in a smart contract. This includes setting contribution caps based on KYC levels, enforcing minimum contribution limits, and managing soft and hard caps with appropriate validations and event emissions during token contributions.",
        "url": 147
    },
    {
        "nl_input": "The query requires a function to update or set the symbol of a token contract, with ownership restriction. The ideal implementation includes a method that allows only the owner to update the symbol, and optionally emits an event upon change.",
        "url": 148
    },
    {
        "nl_input": "The query requires enabling the listing of all deeds as an alternative to `ERC721Enumerable`, avoiding the use of arrays. The solution should provide a mechanism to retrieve all deed IDs in a way that simplifies enumeration without relying on array-based storage or iteration.",
        "url": 149
    },
    {
        "nl_input": "The query requires a function that changes the owner of a contract, emitting an event upon successful transfer. The function should restrict access to only the current owner and update the ownership variable. Multiple provided code examples fulfill these requirements using varying syntax and naming conventions.",
        "url": 150
    },
    {
        "nl_input": "The query requires a function that allows the contract owner to mint new tokens. The suitable code should include a minting function with ownership restriction, enabling token creation and assigning them to a specified address.",
        "url": 151
    },
    {
        "nl_input": "The query requires a function to set or update the token address in a smart contract, with access restricted to an owner or founder, ensuring the token address is valid and properly assigned.",
        "url": 152
    },
    {
        "nl_input": "The query requires an internal method that creates a new EtherDog with specified attributes such as matronId, sireId, generation, genes, and owner. This method should handle validations, set properties like birthTime and cooldownIndex, store the new EtherDog in a collection, and trigger events upon creation and transfer.",
        "url": 153
    },
    {
        "nl_input": "The query requires a function that transfers all raised funds to a designated wallet (e.g., founder's or beneficiary's) after a crowdfunding event ends, typically executed by the contract owner.",
        "url": 154
    },
    {
        "nl_input": "The query requires functionality to close a betting session for a champion with a specific champion ID, indicating that betting is no longer open and finalizing the result. The relevant action includes setting the winning team, closing the bet, calculating rewards, and emitting an event for the win outcome.",
        "url": 155
    },
    {
        "nl_input": "The query seeks to identify code that handles an urgency situation in a smart contract. The relevant code should involve logic for addressing urgent actions, such as fund transfer or contract termination, under specific conditions.",
        "url": 156
    },
    {
        "nl_input": "The query requires an admin function to add claimants, specifying an address and an amount. The function should be accessible only to the admin, store new claimant data, and ensure claimants are tracked properly.",
        "url": 157
    },
    {
        "nl_input": "The query describes a function `betOnDozen` that allows a user to place a bet on one of three dozen groups (0, 1, or 2). It includes input validation to ensure the selected dozen is within range and calls a `placeBet` function with the chosen value.",
        "url": 158
    },
    {
        "nl_input": "The query requires ensuring that a transaction is executed only if the following conditions are met: the sender is a certified and basic account, the gas price is sufficiently low, the transaction value is sufficiently high, and the associated signature is valid. Additionally, there should be checks to ensure compliance with anti-money laundering (AML) and know-your-customer (KYC) requirements.",
        "url": 159
    },
    {
        "nl_input": "The query requires an internal function that handles loan repayment, assuming the repayment amount has already been transferred. It validates the loan state, checks repayment amount equality, and performs token transfers and burns based on interest calculation.",
        "url": 160
    },
    {
        "nl_input": "The query seeks a function that can be used to assert equality between two unsigned integer values (uint256), serving as a testing utility to validate expected and actual outcomes in a smart contract context.",
        "url": 161
    },
    {
        "nl_input": "The query requires retrieving an enemy combination, specifically a set of four class IDs, associated with a given address. If no personalized combination exists, it should return a default initial combination.",
        "url": 162
    },
    {
        "nl_input": "The query requires a function to read player metadata during a migration process as the contract owner. It involves retrieving player data such as ID, name, address, and related stats or status. The function should be owner-restricted and return key player details from storage.",
        "url": 163
    },
    {
        "nl_input": "The query seeks to determine the current halving number in a blockchain contract. The relevant code retrieves this information by calculating the halving based on the current block number, returning the corresponding halving index.",
        "url": 164
    },
    {
        "nl_input": "The query describes a requirement where the crowdsale owner should be able to withdraw any specified amount of ether from the contract at any time. The function must allow withdrawal of a given `_amount`, ensure the contract has sufficient balance, and transfer the ether to the owner. Based on this, the most suitable code is the one that includes a `withdrawEther(uint256 _amount)` function with proper checks and transfer logic.",
        "url": 165
    },
    {
        "nl_input": "The query seeks a function that converts a `uint256` value into a structured `Warship` object, extracting various bit-shifted and masked components to populate its fields. The structure includes multiple unsigned integer fields of varying bit sizes, derived from the input number using bitwise operations.",
        "url": 166
    },
    {
        "nl_input": "The query requires a function accessible only to the owner for delivering tokens to ICO investors, ensuring secure and authorized token distribution.",
        "url": 167
    },
    {
        "nl_input": "The query requires a method that allows a user to cast a vote for a specified candidate. The function should take the candidate identifier as input and record the vote, ensuring valid candidate selection and proper voter handling.",
        "url": 168
    },
    {
        "nl_input": "The query requires retrieving the total amount of pending bets in a smart contract system. The relevant code indicates that pending bets are tracked by iterating through a `bets` array, checking for entries in specific states such as `BET_STATE_WAITPAIR` or `BET_STATE_WAITORACLIZE`, and summing up their values accordingly.",
        "url": 169
    },
    {
        "nl_input": "The query requires a function to set the address of a smart contract for delegating execution of methods. The function should allow the owner to update the delegate address and emit an event when changed. Delegate address can be set to zero to disable delegation.",
        "url": 170
    },
    {
        "nl_input": "The query requires adding a Digix price feed functionality to a contract, allowing authorized updates of ask and bid prices using a signed message. The function must validate block number, nonce, and signature before updating the price feed.",
        "url": 171
    },
    {
        "nl_input": "The query requires a function to transfer ownership of an estate from a previous owner to a new owner, involving checks for token existence, ownership, and address validity, along with updating relevant data structures and emitting a transfer event.",
        "url": 172
    },
    {
        "nl_input": "The query describes an internal utility function to finalize a PVE battle, assuming all conditions for battle completion have been verified. The function should handle post-battle updates such as setting the warrior\u2019s action to idle, calculating cooldown end block, updating dungeon index, and triggering rewards or next steps upon completion.",
        "url": 173
    },
    {
        "nl_input": "The query requires a function that retrieves a user's token balance at a specific block number. The function should take the user's address and the target block number as parameters and return the corresponding balance.",
        "url": 174
    },
    {
        "nl_input": "The query requires a function to mint tokens for pre-crowdsale purchases before the crowdsale starts. The function should take the investor's address and the number of tokens purchased as parameters, perform checks such as the current time being before the start time and valid token supply cap, and then mint the tokens for the investor.",
        "url": 175
    },
    {
        "nl_input": "The query requires an ERC20 transfer function that only allows transfers once a sale has been finalized. The implementation should include a modifier (e.g., `activated`) that checks whether the sale is completed before permitting token transfers, ensuring tokens cannot be transferred until the finalization condition is met.",
        "url": 176
    },
    {
        "nl_input": "The query requires a function that calculates a rate based on a base rate and an added bonus percentage, following the formula: rate = baseRate * (100 + bonus) / 100. The bonus is modified based on certain conditions, and the final result is computed using basic arithmetic operations.",
        "url": 177
    },
    {
        "nl_input": "The query refers to a token sale with a time-based bonus structure, where different bonus percentages are applied based on the time of investment. The contract `c39075` describes this structure with varying bonuses for the first 1,500,000, next 1,000,000, and final 1,000,000 tokens sold.",
        "url": 178
    },
    {
        "nl_input": "The query describes an internal utility function designed to initiate a player-versus-player (PVP) battle. It assumes that all prerequisite conditions for the battle have already been validated externally, such as player readiness, proper match setup, and any required permissions or state checks. The function likely sets up the battle environment, initializes relevant data structures, and possibly triggers events or interactions with other smart contract functions to commence the PVP engagement. The focus is on initiating the battle logic without repeating requirement checks.\n\n(Word count: 79)",
        "url": 179
    },
    {
        "nl_input": "The query requires a contract mechanism that restricts a function to be called only once. The relevant code provides an `onlyOnce` modifier, ensuring that the associated function can be executed just once by checking a counter variable `functAttempts`.",
        "url": 180
    },
    {
        "nl_input": "The query requires functionality to manage user contributions based on KYC status. Specifically, it needs a mechanism to set contribution limits according to KYC levels (e.g., level 1, 2, 3) and the ability to approve or disapprove users based on KYC verification. Additionally, it should allow setting a trusted KYC provider address.",
        "url": 181
    },
    {
        "nl_input": "The query requires a function that allows the owner or management to update the minimum amount required for a specific purpose, such as placing a bet or making a contribution. The function must validate that the new value is greater than zero and should ideally include access control (e.g., `onlyOwner` or `onlyManagement`). Additionally, it should update a state variable with the new value and optionally emit an event for transparency.",
        "url": 182
    },
    {
        "nl_input": "The query requires a function that allows retrieving a specific amount of tokens, involving parameters such as the token holder's address and the amount to be retrieved, including logic for balance updates and event emissions.",
        "url": 183
    },
    {
        "nl_input": "The query requires a function to retrieve gifts based on a template ID. The relevant code provides a function `getGiftsByTemplateId` that takes a `templateId` and returns an array of gift IDs associated with that template. This function allows for efficient lookup of gifts linked to a specific template.",
        "url": 184
    },
    {
        "nl_input": "The query requires a function that is called after the crowdsale ends to perform finalization tasks such as forwarding funds or enabling refunds. It should include checks to ensure it is executed only after the crowdsale has ended, and may involve actions like transferring unsold tokens or triggering refund mechanisms if certain conditions are not met.",
        "url": 185
    },
    {
        "nl_input": "The query requires a function that calculates the number of tokens to be sent to a buyer based on a predefined exchange rate set during contract deployment. The calculation should take the amount of ETH sent by the buyer as input and return the corresponding token amount using simple multiplication with the set rate.",
        "url": 186
    },
    {
        "nl_input": "The query requires a function that runs a distillation process, involving token transfers and burns based on provided parameters and predefined arrays A, N, and B. It includes validation of allowances, user input, and proportional distribution of tokens.",
        "url": 187
    },
    {
        "nl_input": "The query describes a function that allows a user to fortify multiple previously claimed tiles in a single transaction. The function takes parameters for tile IDs, fortification amount, and a flag for using battle value, and it performs verification and fortification through a service contract.",
        "url": 188
    },
    {
        "nl_input": "The query requires a function to process purchases in a private sale, handling the calculation of tokens based on wei amount, checking current sale stage and token pool availability, distributing tokens accordingly, and managing excess funds if necessary.",
        "url": 189
    },
    {
        "nl_input": "The query requires a mechanism to transfer tokens only through an escrow system, restricting direct transfers between users and ensuring that only the owner can send tokens in specific scenarios such as private sales. It involves conditions like ownership verification, possible time restrictions, and exclusion of certain accounts from token transfers.",
        "url": 190
    },
    {
        "nl_input": "The query requires functionality to create a new poll with configurable parameters such as quorum, duration for commit and reveal phases. The poll should record necessary details like end dates, handle poll creation securely, emit relevant events, and ensure valid input parameters during initiation.",
        "url": 191
    },
    {
        "nl_input": "The query checks whether the state variable `dstWalletLMNO` is set in any function. Among the provided code snippets, none directly assign or set the value of `dstWalletLMNO`. However, one contract includes a check to ensure `dstWalletLMNO` is not a zero address before proceeding with operations. This implies that `dstWalletLMNO` must be previously set elsewhere in the contract logic outside the given scope.",
        "url": 192
    },
    {
        "nl_input": "The query requires implementing a restriction that allows accessing or updating the bankroll only after 60 days. None of the provided code snippets directly implement a time-based restriction like a 60-day lock. However, they illustrate common patterns involving bankroll management, access control via modifiers, and sending funds to a designated bankroll address.\n\n**Description of Query Requirements (within 80 words):**  \nImplement a mechanism to restrict access to the bankroll functionality for 60 days before allowing any withdrawal or update. This can be achieved by incorporating a time-locked function modifier that checks whether 60 days have elapsed since a specified event, such as contract deployment or the last update.",
        "url": 193
    },
    {
        "nl_input": "The query describes a process where ERC-20 tokens approved by a user are taken, and in return, the user is given RMC tokens. This implies a token swap or conversion mechanism, where approved ERC-20 tokens are transferred from the user\u2019s account to a contract or service, and RMC tokens are issued to the user in equivalent or predetermined value. The provided code snippets illustrate mechanisms for transferring ERC-20 tokens under owner control but do not directly implement the RMC token issuance or user-centric token swapping logic.",
        "url": 194
    },
    {
        "nl_input": "The query seeks to determine under what conditions and to which participants a jackpot is distributed. The relevant information includes logic for releasing the jackpot based on time intervals and sending funds to specific tickets, as well as functions related to seeding the jackpot and retrieving its total value.",
        "url": 195
    },
    {
        "nl_input": "The query requires a function that calculates and returns the profit from selling a specified number of outcome tokens, considering market funding, fees, and ensuring profitability. The function should handle token transfers, emit relevant events, and update the net tokens sold after the sale.",
        "url": 196
    },
    {
        "nl_input": "The query requires a function that assigns asset share tokens to the authors of winning bids. The function should ensure this assignment occurs under appropriate conditions, such as project success status, and may involve calculations for share allocation, fundraise updates, and token transfers to investors. It should also track assigned shares and update bid statuses accordingly.",
        "url": 197
    },
    {
        "nl_input": "The query seeks a function that retrieves the amount of available tokens for a user. The function may involve checking token allocations, applying percentages, and considering time-based releases or phases. It typically accepts an address as input and returns the available token amount as a `uint`.",
        "url": 198
    },
    {
        "nl_input": "The query is asking for the available inventory of a product, which refers to the quantity of a product that is currently in stock and ready for sale. The provided code snippet with function `availableInventoryOf(uint256 _productId)` returning the available inventory from the product data structure best matches this requirement.\n\n**Description of the query's needs (within 80 words):**  \nThe query seeks to determine how much of a specific product is currently available in inventory. It requires a function that, given a product ID, returns the available quantity for sale.",
        "url": 199
    },
    {
        "nl_input": "The query requires a function to mint tokens, specifying the recipient address and the token ID or amount. The function should handle ownership transfer, update balances or supply, and emit relevant events. It may include access control (e.g., only owner) and validation checks like non-zero addresses.",
        "url": 200
    },
    {
        "nl_input": "The query requires a contract function that allows the reservation owner to manually close a reservation early or extend its duration. The function must be owner-restricted, update the reservation\u2019s end time, and emit an event upon change.",
        "url": 201
    },
    {
        "nl_input": "The query requires a function to change the lock period, accessible only by the owner, allowing adjustments within a specified range.",
        "url": 202
    },
    {
        "nl_input": "The query describes a scenario where the owner can refund collected ETH if the soft cap is not reached or if KYC requirements are not met. It involves functionalities for setting KYC levels, handling refunds, and enabling owner-driven Ether transfers.",
        "url": 203
    },
    {
        "nl_input": "The query requires a function to cancel an auction, involving steps like removing the auction, transferring ownership back to the seller, and emitting a cancellation event. The ideal implementation includes access control (e.g., only the owner can cancel), updating auction status, and handling associated data cleanup.",
        "url": 204
    },
    {
        "nl_input": "The query describes a contract owner's ability to seed the jackpot with funds and reclaim it when the jackpot is paid out. The relevant code should support functionality for the contract owner to contribute to the jackpot and retrieve funds upon payout.",
        "url": 205
    },
    {
        "nl_input": "The query requires a function that retrieves the sender's information in a contract. The suitable functions include `getMyInfo()` returning multiple values, `whoAmI()` returning the sender\u2019s address, or `getShareBalance()` returning the share balance of the sender. Each function involves accessing sender-specific data using `msg.sender`.",
        "url": 206
    },
    {
        "nl_input": "The query seeks a function that sets the token address in a contract, with access control restrictions such as `onlyOwner` or `onlyfounder`, and optionally includes additional checks like `nonZeroAddress` or `tokenDeployed`. The function should take a token address as input and assign it to a token variable.",
        "url": 207
    },
    {
        "nl_input": "The query requires a backup withdrawal mechanism to handle accidental ETH deposits. It needs a function that allows ETH withdrawal, includes safety checks (e.g., valid address, sufficient balance), and ensures funds are sent to an authorized recipient. The function should prevent future accidental deposits and emit relevant events if applicable.",
        "url": 208
    },
    {
        "nl_input": "The query describes a function called `setAdmin` that allows the owner to change the admin address. The function should be public, include an access control modifier like `onlyOwner`, and perform a check to ensure the new admin address is valid (not zero). Additionally, it may emit an event upon successful update.",
        "url": 209
    },
    {
        "nl_input": "The query requires a function that zeros out specific data entries (`sellerListMapping` and `sellerToPrice`) for a given seller within a contract. The function should be internal, accept a seller address, and perform direct deletions or resets of the associated values in storage structures.",
        "url": 210
    },
    {
        "nl_input": "The query requires a function to transfer ownership of a land asset, identified by coordinates (x, y), to a specified address. The function should be publicly accessible and utilize a token transfer mechanism, encoding the land asset into a token ID for the transfer process.",
        "url": 211
    },
    {
        "nl_input": "The query requires a function that allows the owner to start the presale phase and finalize the loyalty phase. The function should be accessible only by the owner and update relevant state variables to transition from the loyalty phase to the presale phase.",
        "url": 212
    },
    {
        "nl_input": "The query describes a \"housekeeping\" function used when a contract is no longer needed, such as after an upgrade. It implies the need for a function that removes the contract from the blockchain and is callable only by a specific authorized address.",
        "url": 213
    },
    {
        "nl_input": "The query requires a function to add a new manager in a smart contract. The function should allow the owner to set or update the manager's address, validate the input, and emit an event upon successful change. It should ensure only authorized addresses can perform this operation.",
        "url": 214
    },
    {
        "nl_input": "The query describes a function that allows the caller to stake tokens for a specific user and reward that user with credits. The function should revert if fewer than one token is staked and must update the user's credit balance based on the staked amount.",
        "url": 215
    },
    {
        "nl_input": "The query requires a modifier that checks whether a given value can be stored in a 64-bit unsigned integer (uint64). The matching code provides this functionality by using a require statement to ensure the uint256 input equals its conversion to uint64, ensuring no data loss.",
        "url": 216
    },
    {
        "nl_input": "The query requires a function to initialize bet data, including setting the ticket price and bet title within a contract. The function should be restricted to an admin and update internal variables with the provided parameters.",
        "url": 217
    },
    {
        "nl_input": "The query requires a function to submit a validation and settlement ring, involving multiple addresses, arguments, and signatures, while ensuring data integrity, token registration, and proper handling of fees and signatures.",
        "url": 218
    },
    {
        "nl_input": "The query requires a function that allows a user to approve another address to spend tokens on their behalf, specifying the spender and the amount. The function should emit an approval event and return a boolean indicating success.",
        "url": 219
    },
    {
        "nl_input": "When the funding goal (MIN_CAP) is not met, backers can initiate a refund process by first approving the Devvote token contract, then calling the refund function on the DevvotePrefund contract, and finally withdrawing their refund in ETH through the withdrawPayments function.",
        "url": 220
    },
    {
        "nl_input": "The query seeks a function that retrieves the X and Y coordinates of a curve point representing a SECP256k1 public key associated with an ENS node. The function should be view-only, accept a node identifier, and return two 32-byte values (x, y).",
        "url": 221
    },
    {
        "nl_input": "The query requires a function that returns the current cap. Among the provided codes, only one contract contains a function named `getIcoCap` which returns a `uint256` value representing the current cap. The other functions are unrelated as they compute a hash or return a round address. \n\n**Description:** The query seeks a function that retrieves the current cap value, and the relevant code provides a function `getIcoCap()` returning the `IcoCap` as an unsigned integer.",
        "url": 222
    },
    {
        "nl_input": "The query seeks functionality related to managing and updating the status of an ICO (Initial Coin Offering) within a smart contract. It involves setting or changing the ICO status (e.g., Active, Waiting, Closed), checking if the current time is within the ICO period, and possibly updating stages based on token availability.",
        "url": 223
    },
    {
        "nl_input": "The query requires retrieving the contract constant `_symbol`. The relevant code defines a function `symbol()` that returns the value of `_symbol`, indicating that this function is used to access the constant's value.",
        "url": 224
    },
    {
        "nl_input": "The query requires a function that sets or updates a token address in a contract. This function should be called only once and restricted to a specific role, such as founder or owner. The function takes the token address as a parameter and assigns it to a variable, ensuring the token address cannot be changed afterward.",
        "url": 225
    },
    {
        "nl_input": "The query requires a function that returns the registered EOS public key for a given Ethereum address. The function should look up a mapping of addresses to EOS keys and return the associated key if it exists, or potentially query an external source if no key is found.",
        "url": 226
    },
    {
        "nl_input": "The query requires a function to transfer tokens from one address to another on behalf of a third party. The function should take parameters for the sender, recipient, and token amount, ensure proper authorization, reduce the allowance accordingly, and execute the transfer securely.",
        "url": 227
    },
    {
        "nl_input": "The query requires a function that enables batch approval for multiple spenders, checking for invalid addresses and ensuring all provided spenders are approved or unapproved in a single transaction.",
        "url": 228
    },
    {
        "nl_input": "The query requires a function that allows the contract owner to burn all remaining tokens in their account and set the license cost. The function should be callable only once by the owner, include parameters to define the license cost percentage using a numerator and denominator, update the total supply, and emit an event upon successful execution.",
        "url": 229
    },
    {
        "nl_input": "The query requires a function to create a new proposal, allowing the submission of a beneficiary address and token amount. It includes validation checks, voting logic, and emission handling. The suitable code defines a `proposal` function with parameters `_wallet` and `_amount`, ensuring only authorized users can call it, validating inputs, managing votes, and executing token minting upon reaching a quorum.",
        "url": 230
    },
    {
        "nl_input": "The query requires a function that returns the number of matches stored in a contract. The function should be public, view-only, and return a `uint` value representing the count of matches. This is achieved by returning the length of a matches array, as seen in the first code snippet provided.",
        "url": 231
    },
    {
        "nl_input": "The query requires a function that allows core team account FT tokens to be released. The relevant code provides a function `releaseCoreTeamAccount()` which enables the release of tokens for the core team account when called, ensuring proper access control and execution.",
        "url": 232
    },
    {
        "nl_input": "The query requires a function that calculates the offset of a given block by returning the remainder when the block number is divided by a subsidy halving interval. The function should be constant and include a check to ensure it is not called before the genesis block.",
        "url": 233
    },
    {
        "nl_input": "The query requires a function that allows the owner to set an expiry time, measured in milliseconds since 1970, within a smart contract. This functionality is used to define a specific point in time after which certain contract features or approvals become invalid.",
        "url": 234
    },
    {
        "nl_input": "The query requires a function to remove a specified contract address from a list of active contracts, ensuring the operation is performed securely and efficiently by the owner.",
        "url": 235
    },
    {
        "nl_input": "The query requires a function to transfer ownership of a product or contract. The ideal implementation includes secure handling, such as ensuring the caller is authorized, validating the new owner address, and updating ownership state. Additional features like two-phase hand-over or event emission for transparency are also relevant.",
        "url": 236
    },
    {
        "nl_input": "The query requires a function to set or change a wallet address in a smart contract. The function should be accessible only to the owner, validate the new address (non-zero, possibly check against other addresses), and emit an event or return a confirmation upon successful update.",
        "url": 237
    },
    {
        "nl_input": "The query requires a failsafe mechanism to remove a game, including transferring tokens to a specified address, updating game status, and cleaning up related data structures.",
        "url": 238
    },
    {
        "nl_input": "The query requires a function that retrieves the owner of a token. The relevant code provides a function `viewOwner()` which returns the address of the token owner.",
        "url": 239
    },
    {
        "nl_input": "The query seeks to determine whether an entity was created using `createUser()` (returning `true`) or `createVirtualEntity()` (returning `false`). The relevant code provides a function `isUser(address _entity)` that checks if the given entity's address corresponds to a user-created entity by comparing it with the `entityOfUser` mapping. It ensures the entity is active and properly resolves its address before making the determination.",
        "url": 240
    },
    {
        "nl_input": "The query seeks a function used to buy tokens. Among the provided codes, the relevant function is `buyTokens()` in the second contract, which allows users to purchase tokens with Ether under conditions such as a minimum value, sale status, and cap limit.",
        "url": 241
    },
    {
        "nl_input": "The query describes a scenario where the owner can set a standard function signature to redirect to one of several pre-signed functions, aligning with future ERC865 standards. It requires mapping standardized function signatures to internal implementations and enforcing ownership control.",
        "url": 242
    },
    {
        "nl_input": "The query requests the retrieval of the \"toc price\" from a smart contract. Based on the provided code, the relevant function is `GetTocPrice()` in contract `c14894`, which returns the `TocPrice` value from the `market` mapping. This function is publicly accessible and viewable.",
        "url": 243
    },
    {
        "nl_input": "The query requires a function to cancel an order on the blackmarket for selling a specific quantity of coke at a certain price. The function should allow the seller to cancel the order, remove it from the list of offers, and emit an appropriate event upon cancellation.",
        "url": 244
    },
    {
        "nl_input": "The query requires retrieving the total lottery amount. The relevant code provides a function `getLotteryBalance()` that returns the current balance of the lottery contract, representing the total lottery amount available.",
        "url": 245
    },
    {
        "nl_input": "The query requires functions related to game information retrieval, such as fetching game details (contract address, description, URL, submitter, and time) by index, checking if a game is active, and retrieving the total number of games. The functions should support querying game records and validating game state.",
        "url": 246
    },
    {
        "nl_input": "The query checks whether the contract relationship is \"sane\" by verifying if a finalizer agent meets certain internal conditions. The relevant function `isFinalizerSane()` returns true if the relationship appears valid, indicating that the contract relies on an external agent's sanity check for its own integrity.",
        "url": 247
    },
    {
        "nl_input": "The query requires a function to display the amount of ETH already contributed by a user in a contract. The function should take an address as input and return the contribution value.",
        "url": 248
    },
    {
        "nl_input": "The query requires a function that extracts an address encoded as the first argument in transaction data from a byte array. It involves low-level parsing, handling input data structure, and returning the decoded Ethereum address.",
        "url": 249
    },
    {
        "nl_input": "The query seeks to determine whether a given Day-Index corresponds to a holiday. The code at URL 250 is most relevant, as it defines a function `getHolidayByIndex_` that checks if a day index falls within predefined holiday lists. It uses conditional statements to categorize the day index into different ranges and returns the corresponding holiday status.",
        "url": 250
    },
    {
        "nl_input": "The query requires a function that checks whether an address has already invested. The function should take an address as input and return a boolean value indicating whether the address is an existing investor. This can be achieved by iterating through an investor list or checking against a mapping of allowed investors.",
        "url": 251
    },
    {
        "nl_input": "The query seeks to determine the current stage in a smart contract based on time or conditions. It involves functions that calculate or transition stages, requiring logic related to timestamps, block numbers, or specific conditions like contribution caps being met.",
        "url": 252
    },
    {
        "nl_input": "The query requires a function to disallow authorized wallets from withdrawing funds from the bonkroll to a specific address. The function should take an address as a parameter, be accessible only to the owner, and update a mapping to set the receiver's status to false.",
        "url": 253
    },
    {
        "nl_input": "The query requires retrieving the timelock periods and corresponding locked values for a given address. It involves fetching an array of time values after performing calculations using `lockTime`, `lockNum`, `earlier`, and `later` variables, indicating a function that returns time-based lock details for a specified address in a contract.",
        "url": 254
    },
    {
        "nl_input": "The query describes a function that allows the registry owner to withdraw surplus value owned by the registry. The function should be accessible only to the owner, involve a check for sufficient balance, and transfer the specified amount from the contract to the owner. It implies a need for ownership control, balance verification, and secure fund transfer in a smart contract.",
        "url": 255
    },
    {
        "nl_input": "The query requires functionality to manage a whitelist in a smart contract, including setting up the whitelist with an authenticator address, adding addresses to the whitelist, and disabling the whitelist feature. It also emphasizes ownership restrictions and event emissions for state changes.",
        "url": 256
    },
    {
        "nl_input": "The query requires a function that transfers ownership of a contract to a new Ethereum address. The function should be callable only by the current owner and must accept the new owner's address as a parameter. Additionally, it may involve emitting an event or updating the owner state variable to reflect the change in ownership.",
        "url": 257
    },
    {
        "nl_input": "The query requirement is to allow the current collector to transfer control of the contract to a newCollector, ensuring only the owner can initiate this change and that the new collector's address is valid.",
        "url": 258
    },
    {
        "nl_input": "The query describes a system that caps the reward amount to the minimum of three values: the requested reward, the contract balance, and the remaining daily limit. It ensures that the reward cannot exceed the available balance or the daily limit remaining.",
        "url": 259
    },
    {
        "nl_input": "The query describes a scenario where the `superOwner`'s authority can be transferred, and only the `hiddenOwner` has the right to perform this transfer. The new `superOwner` must be a valid Ethereum address.",
        "url": 260
    },
    {
        "nl_input": "The query describes a function that allows users to purchase Dragon Ball Z heroes, where the price doubles after each purchase. It supports multiple purchases and handles payment distribution between the developer and the commission owner.",
        "url": 261
    },
    {
        "nl_input": "The query seeks to determine the total number of bronze caps produced so far. The relevant code snippet defines a function `producedBronzeCaps()` that returns the amount of bronze caps produced as a `uint64` value, extracted from the variable `packedProducedCaps`. This function provides the required information about the current production count of bronze caps.",
        "url": 262
    },
    {
        "nl_input": "The query seeks a function that updates the balances map and the totalSupplyHistory. None of the provided code snippets fulfill this requirement, as they only return the total supply without modifying any state variables or updating balances.",
        "url": 263
    },
    {
        "nl_input": "The query requires a function that returns a boolean indicating whether a process or state has successfully completed or ended. It focuses on detecting completion or finalization, typically used to confirm if an operation, such as setting a score or completing funding rounds, was successful.",
        "url": 264
    },
    {
        "nl_input": "The query requires a setter function to update the `timePerPeriod` variable, which represents the minimum time each period lasts in seconds. The function should accept a parameter `_timePerPeriod` of type `uint[5]` and be accessible only to the governor.",
        "url": 265
    },
    {
        "nl_input": "The owner should be able to authorize specific addresses, such as a crowdsale contract, to transfer tokens even during a lock-up period. This functionality allows certain entities to bypass standard transfer restrictions under controlled conditions set by the owner.",
        "url": 266
    },
    {
        "nl_input": "When player 1 forfeits, the game ends and rewards are distributed. Player 2 receives the transferred value after fees. The system records win/loss statistics and updates balances accordingly.",
        "url": 267
    },
    {
        "nl_input": "The query requires a function that cleans up a game by setting it to inactive, refunds any balances exclusively through a housekeeping process, and ensures no funds are left unhandled. It emphasizes refunding balances only when called by a housekeep function, and should handle failures gracefully with fallback mechanisms like fee holdover or logging.",
        "url": 268
    },
    {
        "nl_input": "The query requirement is to allow the owner to modify the bonus percentage for the current phase, either Pre ICO or Main ICO, ensuring the new bonus value differs from the existing one. This includes emitting an event upon successful update and restricting access to the owner only.",
        "url": 269
    },
    {
        "nl_input": "The query describes a function that adds a new animal type to the game, with a maximum limit of 100 animal types. It also specifies that the cost of adding a new type must not be lower than the first element in the `costs` array.",
        "url": 270
    },
    {
        "nl_input": "The query requires a modifier that allows actions only when the contract is not paused. The relevant code defines a `whenNotPaused` modifier using a condition on `now >= endDate` to control execution timing, indicating a mechanism to restrict function calls until a specified time.",
        "url": 271
    },
    {
        "nl_input": "The query requires a function to directly mint tokens and send them to a specified address, ideally with minimal restrictions and emitting relevant events like `Transfer` or `Mint`. The implementation should handle internal balance updates and supply tracking.",
        "url": 272
    },
    {
        "nl_input": "The query requires a function to change or update a wallet address in a smart contract. The function should allow the owner to set a new wallet address, with possible validations such as ensuring the new address is not zero, not the contract itself, and not already an owner. Event logging and return value may also be included.",
        "url": 273
    },
    {
        "nl_input": "The query requires a function that retrieves the namespace associated with a provided address in the service locator. The function must accept an address as input and return the corresponding namespace as a string, ensuring it checks for any time-to-live (TTL) expiration before returning the result.",
        "url": 274
    },
    {
        "nl_input": "The query requires a function that creates a free token and transfers it to a specified recipient. The function should include parameters for the token name and recipient address, enforce restrictions on the recipient address, and increment a counter after each creation.",
        "url": 275
    },
    {
        "nl_input": "The query seeks functions that implement an `onlyOwner` modifier in Solidity contracts, where access is restricted to the owner by requiring `msg.sender == owner`. The desired behavior ensures only the designated owner can execute specific functions.",
        "url": 276
    },
    {
        "nl_input": "The query indicates that the contract should not lock ETH. Among the provided codes, none directly address locking or preventing ETH from being locked. However, the third code snippet defines a `notLocked` modifier that could be used to ensure functions do not execute when ETH is locked, implying an awareness of a locking mechanism elsewhere in the contract. This suggests the presence of logic that might prevent ETH from being locked when this modifier is applied.",
        "url": 277
    },
    {
        "nl_input": "The query requires a function that allows the sender to efficiently claim all tokens by calling `claimAllForInvestor(msg.sender)`, indicating a need for a token claiming mechanism tied to investor addresses.",
        "url": 278
    },
    {
        "nl_input": "The query requires a function that returns the price of a specific team. The relevant code defines a function `getTeamPrice(uint _teamId)` which retrieves and returns the current price of a team based on its ID from a data structure called `teams`.",
        "url": 279
    },
    {
        "nl_input": "The query seeks functionality to modify or control time-related parameters in a smart contract, specifically referring to changing the \"next steal time.\" The relevant code provides an internal function to update the next steal timestamp by adding a given number of seconds to the current time.",
        "url": 280
    },
    {
        "nl_input": "The query requires a function that returns the registration date of a holder in a smart contract. The function should take an address as input and return the associated registration time as a uint value.",
        "url": 281
    },
    {
        "nl_input": "The query requires a function to update or set the reward rate or divisor in a smart contract. The relevant functions include `updateRewardRate` for setting a new reward rate based on a token address, and `setRewardDivisor` for updating the reward divisor. These functions are typically restricted to the contract owner.",
        "url": 282
    },
    {
        "nl_input": "The query pertains to functionalities related to owner creation or activation in a smart contract. It involves operations such as adding an owner, activating an owner address, checking owner status, and maintaining owner records like counts and mappings. The functions may include requirements for valid addresses, checks for existing owners, and updating ownership data structures.",
        "url": 283
    },
    {
        "nl_input": "The query requires a function that creates a new round and initializes it with a hashed salt and a hashed proof of N as parameters. The function should be payable, accept owner-only access, and emit an event upon successful creation. It should also transfer ownership of the newly created round to the owner.",
        "url": 284
    },
    {
        "nl_input": "The query involves setting a soft cap value in a smart contract, where the input number (3333000000) is converted into a larger unit by multiplying it with 10^12. The relevant code defines a function that sets this soft cap value.",
        "url": 285
    },
    {
        "nl_input": "The query requires a function that allows the owner to withdraw tokens other than DGZ to a beneficiary address. The function should ensure that DGZ tokens are excluded, and it must include access control (e.g., `onlyOwner`), a transfer mechanism, and an event emission upon successful withdrawal.",
        "url": 286
    },
    {
        "nl_input": "The query requires a function that sets a block not for sale. The relevant code provides a function `cancelSellBlock` which unsets the sale status of a block by setting `\"forSale\"` to 0, and emits an event `UnsetBlockForSale`. It ensures only the block owner can perform this action.",
        "url": 287
    },
    {
        "nl_input": "The query requires a function that allows the `msg.sender` to claim tokens owed, specifically by invoking a method that transfers tokens to the sender's address. The function should handle token allocation and ensure proper distribution based on the sender's contribution or reward eligibility.",
        "url": 288
    },
    {
        "nl_input": "The query requires retrieving detailed information about a specific `GameItem`, including its ID, name, selling price, owner, and associated game ID. The relevant function `getGameItem` from contract `c23137` fulfills this requirement by returning these attributes for a given `_tokenId`.",
        "url": 289
    },
    {
        "nl_input": "The query requires a feature that allows users to claim segments every 1000 blocks, where segment claims yield half the reward compared to cluster claims. It emphasizes a time-based claiming mechanism tied to block intervals and includes user validation and reward calculation logic based on contribution.",
        "url": 290
    },
    {
        "nl_input": "The query requires a function that allows for the transfer or exchange of tokens, potentially involving multiple allocation sources and stages. It implies a mechanism for calculating token distribution based on sender-specific values and clearing those allocations upon transfer.",
        "url": 291
    },
    {
        "nl_input": "The query describes a token sale mechanism that facilitates the presale of tokens with dynamic pricing. It includes functionality to buy tokens within a defined time frame, limits on token purchases, and tiered pricing based on how many tokens have already been sold. The contract also handles fund transfers, updates balances and total raised, and applies different price steps in intervals of tokens sold (0\u20131000, 1000\u20133000, and above 3000).",
        "url": 292
    },
    {
        "nl_input": "The query requires a mechanism to prevent specific addresses from sending or receiving tokens. This can be achieved by implementing a function that locks or freezes these addresses for a certain period or indefinitely. The function should allow the owner to specify target addresses and set Unix times for unlocking or apply a freeze status.",
        "url": 293
    },
    {
        "nl_input": "The query requires a function to remove an address from a list of pools. The function should ensure the address is valid, check if it exists in the list, and then efficiently remove it, likely by replacing it with the last element and reducing the list length.",
        "url": 294
    },
    {
        "nl_input": "The query requires determining the end date of a customer's term deposit. The relevant code provides a function `get_term_deposit_end_date` which returns the end block timestamp for a given address, indicating when the term deposit period ends.",
        "url": 295
    },
    {
        "nl_input": "The query requires a function to add a CZR lock for a given address with specified lock parameters such as start time, amount, and lock duration in months. The function should be owner-restricted, update the lock record, and emit an event upon successful locking.",
        "url": 296
    },
    {
        "nl_input": "The query seeks functionality to transfer data layer authority, likely within a blockchain contract. The relevant code shows a function `transferDataAuthority` that allows the owner to transfer authority to a new address, specifically passing control of a `data` resource. This indicates the need for a secure, owner-restricted method to hand over administrative control of a data layer in a decentralized application.",
        "url": 297
    },
    {
        "nl_input": "The query describes a function that resolves a challenge for a given proposal ID (`_propID`). It involves checking if the proposal has an associated challenge, determining the outcome of the challenge (passed or failed), distributing rewards accordingly, and updating the challenge state. Events are emitted based on the result, and tokens are transferred to the appropriate party.",
        "url": 298
    },
    {
        "nl_input": "The query requires a function to decrease the approved token amount for a spender. Among the provided codes, one includes a `decreaseApproval` function that reduces the allowance by a specified value, handling cases where the decrease exceeds the current allowance. This function modifies the spender's allowed amount and emits an approval event.",
        "url": 299
    },
    {
        "nl_input": "The query requires a function to whitelist a list of addresses in a smart contract. The function should accept an array of addresses and mark them as whitelisted. It should be accessible only to the owner or a designated role, ensuring that only authorized individuals can add addresses to the whitelist. Additionally, it may involve maintaining a mapping of whitelisted addresses for future reference.",
        "url": 300
    },
    {
        "nl_input": "The query seeks to identify a function that can only be called from the `shiftSale` context. Among the provided code snippets, the relevant function is `shiftSalePurchase()` in contract `c27408`, which appears to be designed for use in a shift sale scenario, incorporating modifiers like `isOpen`, `afterStart`, `hardCapNotReached`, and `aboveMinValue` to enforce specific conditions during execution.",
        "url": 301
    },
    {
        "nl_input": "The query requires extending the `transferFrom` function of OpenZeppelin's `StandardToken` to include functionality that records snapshots of token balances before a transfer occurs. This involves calling a `takeSnapshot` function for both the `_from` and `_to` addresses within the overridden `transferFrom` method.",
        "url": 302
    },
    {
        "nl_input": "The query requires a function that checks the amount of tokens delegated to a spender by an owner, returning the remaining allowance for the spender. It involves parameters for owner and spender addresses and returns a uint256 value representing the available token amount.",
        "url": 303
    },
    {
        "nl_input": "The query involves adding intervals to a tree structure, where intervals are stored in nodes based on their center values. The process includes creating an interval, traversing the tree to find the correct node by comparing intervals with node centers, and adding the interval to the appropriate node.",
        "url": 304
    },
    {
        "nl_input": "The query requires a functionality where users can withdraw tokens only after the crowdsale has ended and the crowdsale is finalized, ensuring that withdrawals are allowed post-finalization.",
        "url": 305
    },
    {
        "nl_input": "The query requires a function that retrieves the token balance of a specified owner address in a smart contract. The function should take an owner address as input and return the corresponding token balance, with implementations showing variations in naming, comments, and variable usage but maintaining the core functionality.",
        "url": 306
    },
    {
        "nl_input": "The query requires a function to update or set a token address in a smart contract, ensuring ownership control and proper validation of the new address.",
        "url": 307
    },
    {
        "nl_input": "The query requires a function that updates a board status when a player loses, specifically mapping the losing color to the appropriate winning status for the opposing player. The function should utilize a conditional structure to determine which color has lost and update the board's status accordingly, invoking `updateBoardStatus` with the correct `BoardStatus`.",
        "url": 308
    },
    {
        "nl_input": "The query seeks to determine if an event has ended. The relevant functionality is provided by the `hasEnded()` function in contracts, which returns true based on conditions like time comparison or token availability. One implementation checks if the current time exceeds the end time or if tokens are depleted, while another checks a boolean flag `isFinalized`.",
        "url": 309
    },
    {
        "nl_input": "The query requires checking whether a given address is an eligible burner in the smart contract. The relevant code should implement a modifier or function that validates if an address has burning permissions, such as checking against a list of allowed burners or verifying it matches a designated burn address.",
        "url": 310
    },
    {
        "nl_input": "The query involves a multisignature contract handling Ether, with functionality to deposit funds using `msg.value` and potentially execute transactions. It references a function that modifies the multisig state, stores the deposited Ether, and updates unlock timing parameters.",
        "url": 311
    },
    {
        "nl_input": "The query describes a process where a user's potatoes are thrown away due to rotting. The relevant code at url 312 represents this scenario, where the `recycle` function calculates the amount of rotten potatoes based on elapsed time and updates the farmer's cellar and trash balances accordingly.",
        "url": 312
    },
    {
        "nl_input": "The query seeks the renewal interval of a product in seconds. The relevant code defines a function `intervalOf` that retrieves the renewal interval for a given product ID from a mapping or storage variable called `products`. This function is publicly viewable and returns the interval as a `uint256`.",
        "url": 313
    },
    {
        "nl_input": "A wallet can use the `withdrawFailedOldOwnerTransferAmount` function to withdraw any owed value recorded under its address in the `addressToFailedOldOwnerTransferAmount` mapping. The function sends the owed amount to the caller, resets their stored balance, and reduces the total failed transfer amount accordingly.",
        "url": 314
    },
    {
        "nl_input": "The query requires a function that calculates winnings based on a given bet amount and percentage. The function should take two inputs, `bet` and `percent`, and return the calculated winnings by applying a mathematical formula using safe arithmetic operations to prevent overflow.",
        "url": 315
    },
    {
        "nl_input": "The query requires a function that allows the owner or admin to change the admin address, including validation checks for the new address and proper access control.",
        "url": 316
    },
    {
        "nl_input": "The query requires a function to simulate the creation of a leaderboard hash, using a name and an administrator address as inputs. The provided code at URL 317 fulfills this requirement by implementing a function that returns a keccak256 hash of the concatenated inputs.",
        "url": 317
    },
    {
        "nl_input": "The query seeks setter methods that are restricted to an unlocked state in a smart contract. The relevant code defines such setters using modifiers or conditions ensuring the contract is not locked before allowing modifications, as seen in functions like `setOversight` with the `onlyOwnerUnlocked` modifier.",
        "url": 318
    },
    {
        "nl_input": "The query requires a function to add content to an agreement, including parameters such as name, description, and reward. The function should ensure access control (e.g., onlyBrand), validate the reward, and return a success status. Additionally, it should interact with a content storage system to register the new entry.",
        "url": 319
    },
    {
        "nl_input": "The query requires a function that updates the rate for a specific round in a contract. The function should be accessible only to the owner and must set the rate value for the given round number, ensuring the round index is valid within the existing rounds array.",
        "url": 320
    },
    {
        "nl_input": "The query requires a function that allows marking a product with a hash, involving checks for active brands and apps, permission verification, and emitting events with fee transfers. The implementation should store the mark relationship and handle token transfers from the brand account to specified fee accounts.",
        "url": 321
    },
    {
        "nl_input": "End the auction and transfer the highest bid to the owner.",
        "url": 322
    },
    {
        "nl_input": "The query requires a function that retrieves an owner by a 0-indexed position. The suitable code provides a method `getOwner` taking an index, adjusting it by adding one to access the internal array, and returning the corresponding owner address.",
        "url": 323
    },
    {
        "nl_input": "The query requires a function that sets the initial date and token address in a smart contract, initializing parameters for a sale, including validating token supply and ownership.",
        "url": 324
    },
    {
        "nl_input": "The query requires a function that returns the ticket price for a bet. The relevant code provides a function `getTicketPrice()` which returns the current `ticketPrice` as a `uint256`. This function is public and view-only, meaning it does not modify the contract state and can be called externally to retrieve the ticket price.",
        "url": 325
    },
    {
        "nl_input": "The query describes a function that is triggered when tokens are purchased during a token sale. It involves transferring tokens to a beneficiary, updating the total supply, and emitting relevant events. The function includes validation checks for the beneficiary address, token amount, and contract state.",
        "url": 326
    },
    {
        "nl_input": "The query requires a function to enable token transfers and burn unsold tokens by setting the token offering address to zero. The function should be owner-only, allow transfers to commence, calculate and burn unsold tokens, and ensure no further approvals are allowed for the offering address. This functionality aligns with use cases involving post-sale token management and transfer control.",
        "url": 327
    },
    {
        "nl_input": "The query requires a function to place a bet using an Access Code and a Mode parameter, with logic for handling odds, validating bets, and restricting direct invocation. It involves checking minimum/maximum bet values, tracking game participation per block and player, generating random outcomes, and enabling promo-based access through hashed codes.",
        "url": 328
    },
    {
        "nl_input": "The query requires a function that computes the status of a transcoder by checking if it is registered in a pool, returning \"Registered\" if it is and \"NotRegistered\" otherwise.",
        "url": 329
    },
    {
        "nl_input": "The query requires a function that matches and fills a buy order with a sell order, involving calculations for fill amount, fees, and execution based on the exchange type. It should return updated token and ether amounts after the fill.",
        "url": 330
    },
    {
        "nl_input": "The query describes a requirement where any user should be able to transfer specific tokens (e.g., Reporter tokens) after trading has started. The function should allow public transfers, ensure trading has commenced, and possibly include additional checks or actions like pausing mechanisms, commissions, or custom token handling.",
        "url": 331
    },
    {
        "nl_input": "The query seeks a function that returns an address's available token allocation, checking eligibility based on time-stamped steps. It involves a mapping of buyers and their respective token allocations, with a mechanism to add available tokens based on timestamps (step1, step2, step3). The function is public, view, and accepts a recipient address as a parameter.",
        "url": 332
    },
    {
        "nl_input": "The query requires a function that transfers and locks a specified value, callable only by admins, with the locking subject to a time limit upon setting. The function must ensure administrative control over token transfer and locking mechanisms.",
        "url": 333
    },
    {
        "nl_input": "The query requires transferring Ether to a specified address, which can be achieved using a function that sends Ether to a beneficiary or target address. The functionality involves checking balance and ensuring the transfer is executed properly.",
        "url": 334
    },
    {
        "nl_input": "The query requires a function that returns the address of the library founder. The relevant code provides a function `founderOf(uint256 _tokenId)` which retrieves and returns the founder's address based on a given token ID, ensuring it is not a zero address.",
        "url": 335
    },
    {
        "nl_input": "The query requires a feature that allows users to delete their own accounts. From the provided code, the relevant function is `deleteUser()` in contract `c11532`, which removes user data from the system and emits a `UserDeleted` event.",
        "url": 336
    },
    {
        "nl_input": "The query describes a functionality that allows buyers to claim tokens they have purchased. The relevant code snippet is the `claimTokens` function in contract `c32531`, which enables users to claim their allocated tokens after stages like presale and main sale, by transferring the total token allocation to the buyer's address.",
        "url": 337
    },
    {
        "nl_input": "The query requires a function that allows the caller to transfer tokens to a new holder. The function should validate the transfer amount, ensure the sender has sufficient balance, and potentially include additional checks or fees. It may also involve invoking an internal transfer mechanism and returning a success status.",
        "url": 338
    },
    {
        "nl_input": "The query requires verifying that a sale has been configured and has not yet finished. The relevant code ensures the sale is initialized (`isConfigured`) and confirms it hasn't finalized (`isFinished`), aligning with these requirements.",
        "url": 339
    },
    {
        "nl_input": "To successfully purchase an item, the total amount of Ether required must account for the item's price, any associated fees, and ensure that the sender's balance covers these amounts. The Ether amount is calculated by considering the token rate, transaction fees, and ensuring sufficient funds are available for the transfer to succeed.",
        "url": 340
    },
    {
        "nl_input": "The query requires a function that calculates and returns the bonus percentage for the current ICO stage. It specifically refers to a contract that implements logic for returning decreasing bonus percentages (35%, 25%, 15%, 5%) during the first four weeks of a main public ICO, with no bonus after the fourth week.",
        "url": 341
    },
    {
        "nl_input": "The query requires functionality to permanently stop minting tokens and finalize the crowdsale process. This includes setting a flag to indicate minting is finished, recording the stop date, and potentially returning unsold tokens or transferring remaining funds.",
        "url": 342
    },
    {
        "nl_input": "The query requires a function that allows users to participate in an airdrop by claiming tokens under specific conditions such as stage, time, and participant limits. It involves checks for eligibility, prevents duplicate participation, and updates the participant count upon successful claim.",
        "url": 343
    },
    {
        "nl_input": "The query requires retrieving ELHT token information based on a transferred Token ID (up to 64). The relevant code should handle ERC20 token transfers, balance retrieval, or calculations involving token amounts.",
        "url": 344
    },
    {
        "nl_input": "The query requires a contract function that allows the owner to authorize redemptions in units of 1/1000 ETH. The function should validate sufficient contract balance and store authorized redemption amounts per address.",
        "url": 345
    },
    {
        "nl_input": "The query requires a functionality that allows the contract owner to transfer Ether, potentially to another contract or address, indicating a need for an ether-moving function.",
        "url": 346
    },
    {
        "nl_input": "The query requires identifying code that involves interaction with an Oracle contract address implementing `OracleInterface`. The relevant code should include functionality for proposing or handling oracles, potentially involving checks on addresses, balances, and interactions between a maker and taker. It may also involve modifiers ensuring specific address permissions and events related to oracle proposals.",
        "url": 347
    },
    {
        "nl_input": "The query requires a function that allows a user to create an offer for trading, specifically involving a payable transaction where `msg.value` is greater than zero. The relevant code includes a function that accepts a setting parameter and ensures a non-zero value is sent with the transaction.",
        "url": 348
    },
    {
        "nl_input": "The query refers to a function or functionality named \"balanceOfOnForHolder\" or \"balanceOfOn,\" likely related to managing or updating a balance status for a token holder in a smart contract. The relevant code should involve functions that retrieve or update token balances, particularly involving an owner or holder address. Based on the provided options, the most relevant code includes functions like `balanceOf(address _owner)` for retrieving token balances and `balanceOfOnUpdate(bool _on)` for updating balance status. These functions align with the query's focus on tracking or modifying balances for specific holders.\n\n**Description:**  \nThe query seeks information about tracking or updating token balances for specific holders in a smart contract, involving functions like `balanceOf` for retrieval and potentially `balanceOfOnUpdate` for managing balance status.",
        "url": 349
    },
    {
        "nl_input": "The query requires a function that checks the total funds raised in a fundraiser and converts the amount into USD using a predefined rate. The function should calculate and return the rated value of the raised funds by applying the rate, effectively providing the result in USD.",
        "url": 350
    },
    {
        "nl_input": "The query requires tracking the balances of rewards distributed from a token pool. The relevant functionality includes checking available tokens for a beneficiary, managing token balances, and transferring tokens based on claimable amounts. A key requirement is to monitor how many tokens are leaving the pool during distribution.",
        "url": 351
    },
    {
        "nl_input": "The query requires a function to collect a service or affiliate fee when purchasing, where the fee is deducted from the buyer's payment and transferred to an affiliate. The function should handle fee calculation, ensure sufficient balance, and return the remaining amount after the fee deduction.",
        "url": 352
    },
    {
        "nl_input": "The query requires an internal function that checks whether transferring a specific token is permitted. The function should take into account the sender, receiver, and token ID, and return a boolean indicating if the transfer is allowed. It may involve checking against a logic contract or specific conditions such as vesting dates and exceptions.",
        "url": 353
    },
    {
        "nl_input": "The query requires overriding the `transferFrom` function in a token contract to incorporate KYC (Know Your Customer) validation logic, ensuring transfers are only allowed from addresses that meet specific compliance requirements. The implementation should integrate KYC checks while retaining standard token transfer functionality through inheritance or direct modification.",
        "url": 354
    },
    {
        "nl_input": "The query requires a function that allows changing an address associated with a specific role. The function should emit an event upon the change, include authorization checks to ensure only permitted entities can make the change, and update the relevant storage variables to reflect the new address for the role.",
        "url": 355
    },
    {
        "nl_input": "The query requires a function to withdraw ZRX tokens from a contract when a new version is deployed. The function should allow an admin to transfer the specified amount of ZRX tokens to a designated address, ensuring proper token handling and administrative control.",
        "url": 356
    },
    {
        "nl_input": "The query requires a modifier that ensures transfers can only occur after minting is finished. The code at URL 357 provides this functionality with the `onlyWhenTransferEnabled` modifier, which enforces the condition `mintingFinished` to be true before allowing any transfer.",
        "url": 357
    },
    {
        "nl_input": "The query requires a function that refunds funds when the softcap is not met and the sale period has ended. The function should check if the sender is eligible for a refund, transfer the invested amount back to the sender, and update their investment status. Event logging for transparency is also needed.",
        "url": 358
    },
    {
        "nl_input": "The query seeks a function that checks whether a contribution period is currently active. It requires evaluating conditions such as whether the start time is in the past, the end time is in the future, and other related flags like `hardCapReached` and `isEnabled`. The function should return a boolean indicating if contributions are open.",
        "url": 359
    },
    {
        "nl_input": "The query seeks an internal function that manages the status of an ICO when tokens are sold out. The function should handle status changes based on token availability across different stages (PrivateICO, PreICO, ICO), setting the status to Waiting or Closed accordingly.",
        "url": 360
    },
    {
        "nl_input": "The query describes a feature that allows the contract owner to add addresses authorized to burn tokens, such as ICO or TGE contracts. The functionality involves maintaining a whitelist of burners and enabling token destruction from those addresses.",
        "url": 361
    },
    {
        "nl_input": "The query requires a function that allows a wallet to claim ownership of an account by verifying a signature linked to a specific web app and post, using Oraclize for off-chain data verification. It involves parameters such as the app nickname, post ID, gas price, and gas limit, and requires the sender to pay a fee covering gas costs.",
        "url": 362
    },
    {
        "nl_input": "The query describes a process to buy a collectible, involving a payable function that handles fees, validations, and token transfers. It implies the need for functionality such as checking account status, ensuring value in transactions, calculating fees, and transferring tokens upon purchase.",
        "url": 363
    },
    {
        "nl_input": "The query seeks a function that returns the next minimal bid or the final bid in an auction. The relevant code provides a `getRegionPrice` function which calculates and returns the next bid based on the current bid plus a minimal raise, or the start price if no bid has been placed. It effectively meets the requirement of determining the next minimal bid.",
        "url": 364
    },
    {
        "nl_input": "The query seeks functionality to create a promotional item (e.g., \"promo narco\") up to a predefined limit, ensuring controlled creation through checks and increments. The implementation should include access control (e.g., only specific roles), assignment of default owner if none provided, and enforcement of creation limits before invoking the internal creation function.",
        "url": 365
    },
    {
        "nl_input": "The query requires a function to modify basic ICO parameters, such as end date, low and hard caps (overall and per transaction), with the ability to apply changes only when not zero, and ensure the function can only be executed in the `Suspended` state by the owner.",
        "url": 366
    },
    {
        "nl_input": "The query requires a function that allows only the override address to change the override address, ensuring exclusive control for updating its own reference. The function must emit an event upon successful update and return a boolean confirmation. No other roles or addresses should have this permission.",
        "url": 367
    },
    {
        "nl_input": "The query seeks a function that allows a user to approve multiple token IDs for a given address in a smart contract. The ideal function should handle an array of token IDs, check ownership, and update approvals accordingly within a loop.",
        "url": 368
    },
    {
        "nl_input": "The query requires a mechanism to buy DOL tokens from VAULT by sending ETH. The code should facilitate transferring ETH, interacting with the VAULT address, and handling token supply distribution while ensuring time-based conditions are met.",
        "url": 369
    },
    {
        "nl_input": "When the crowdsale is finished, the remaining unsold tokens should be returned to the wallet. This process is handled in the finalization step, ensuring that any leftover tokens are sent back after the sale ends and finalization is complete.",
        "url": 370
    },
    {
        "nl_input": "The query requires a function that initiates a poll with specified parameters such as vote quorum, commit duration, and reveal duration. It should emit an event upon poll creation, store poll details on-chain, and return a unique poll ID. The implementation must allow public access, use timestamps for scheduling poll phases, and manage poll data in a mapping or similar structure.",
        "url": 371
    },
    {
        "nl_input": "The query seeks a function to set an individual cap for stage 2 of a crowdsale. The relevant code defines a function `setMaxStage2AllocationPerInvestor` that sets the cap and is accessible only to the controller.",
        "url": 372
    },
    {
        "nl_input": "The query seeks to calculate and withdraw unsold tokens from a contract, ensuring the seller can retrieve their remaining balance after accounting for purchased and withdrawn amounts. It involves checking token balances, handling withdrawals securely, and ensuring availability of funds post-transactions.",
        "url": 373
    },
    {
        "nl_input": "The query requires extracting price feed information from the provided contract code. The relevant function `setPriceFeed` in contract `c19741` sets price data with validations on nonce, block number, and signature verification, indicating a mechanism to update and verify price feeds securely.",
        "url": 374
    },
    {
        "nl_input": "The query requires a function to set a security check report URI in a smart contract. The function should accept a string parameter `_uri` and be restricted to the owner of the contract. It should assign the provided URI to a state variable `securityCheckURI`.",
        "url": 375
    },
    {
        "nl_input": "The query seeks a function that calculates the amount of tokens that can be purchased with a given amount of wei. It implies a need for a token purchase calculation based on current exchange rates, with potential tiered pricing or rate adjustments.",
        "url": 376
    },
    {
        "nl_input": "The query requires a function that sets the sale status of an account, allowing it to transfer tokens in a frozen state during the token sale phase. The function should be restricted to privileged users and update the sale status mapping for the specified account.",
        "url": 377
    },
    {
        "nl_input": "The query seeks a method that calculates the Developer's Cut in a game, specifically a function that takes a price as input and returns the calculated cut based on a predefined percentage (promille), using multiplication and division operations for accurate proportional computation.",
        "url": 378
    },
    {
        "nl_input": "The query seeks to extend the functionality of OpenZeppelin's StandardToken by adding a method that captures snapshots of token balances before executing a transfer between addresses. This is achieved by modifying the `transferFrom` function to include snapshot logic for both the sender and receiver prior to performing the standard token transfer.",
        "url": 379
    },
    {
        "nl_input": "The query requires a function modifier that ensures the caller is an authorized account. The modifier should revert the transaction if the caller is not authorized, with possible variations specifying particular authorized roles or accounts.",
        "url": 380
    },
    {
        "nl_input": "The query requires a function that sets the deposit gas cost within a smart contract. The referenced code includes a function `setDepositGasCost` that allows an authorized user to update the deposit gas cost, fulfilling this requirement.",
        "url": 381
    },
    {
        "nl_input": "The query requires a function that sends `_value` tokens to `_to` from the message sender's account. It involves parameters `_to` (address) and `_value` (uint256), and uses `msg.sender` as the sender. The function should ideally trigger a transfer event and perform necessary validations like sufficient balance and valid addresses.",
        "url": 382
    },
    {
        "nl_input": "The query seeks functions related to handling ERC20 tokens, specifically focusing on transferring tokens accidentally sent to the contract. The relevant functions allow the owner to transfer any received ERC20 tokens back to themselves, ensuring ownership control and safe token recovery.",
        "url": 383
    },
    {
        "nl_input": "The query requires functionality to disable token transfers within a smart contract. The code at URL 384 provides a `freeze()` function that pauses transfers, meeting the requirement. Other codes do not directly address disabling transfers.",
        "url": 384
    },
    {
        "nl_input": "The query requires a transfer function that can only be executed if trading is open, as enforced by the `tradingOpen` modifier. The relevant code implements this restriction in a `transferFrom` function, ensuring transfers are allowed only when trading is active.",
        "url": 385
    },
    {
        "nl_input": "The query requires a modifier that allows actions only when the funds are **not** locked. The relevant code should implement a condition to check that the `locked` state is **false** before permitting execution.",
        "url": 386
    },
    {
        "nl_input": "The query seeks an internal function that handles Ether refunds specifically during stage three of a contract's execution. The function must perform checks for the contract stage, sender authorization, and minimum contribution before recording the refund.",
        "url": 387
    },
    {
        "nl_input": "The query seeks a contract function that allows the owner to send bonuses, with restrictions such as being callable only by the owner and potentially having a limit or distribution mechanism.",
        "url": 388
    },
    {
        "nl_input": "The query requires a function to calculate the token amount based on a given input, typically involving a rate and an amount (e.g., wei or USD). The calculation may include tiered rates, bonuses, or conversions using external values like ether price in USD.",
        "url": 389
    },
    {
        "nl_input": "The query requires a function to withdraw ETH from a contract, where the owner can specify an amount or withdraw the entire balance. The function should ensure only the owner can call it and may include transferring to multiple addresses or checking sufficient balance.",
        "url": 390
    },
    {
        "nl_input": "The query refers to a functionality that allows for updating specific parameters or configurations within a smart contract. This includes actions such as modifying contribution requirements, enabling or disabling features, or upgrading the contract itself, typically restricted to authorized roles like management or owners.",
        "url": 391
    },
    {
        "nl_input": "The query requires overriding the token purchase logic to send additional tokens to a registered address. The referenced code demonstrates modifying the `_processPurchase` function in a crowdsale contract, adding logic to allocate extra tokens to a beneficiary based on the purchased amount. This customization allows for enhanced token distribution during purchase.",
        "url": 392
    },
    {
        "nl_input": "The query requires a function that returns the total supply of tokens as a `uint256`. It seeks a publicly accessible method, preferably with keywords like `public`, `view`, or `constant`, that accurately returns the total token amount in existence.",
        "url": 393
    },
    {
        "nl_input": "The query seeks to understand the concept of \"developer status\" within a smart contract system. The relevant code shows that developer status refers to a boolean attribute assigned to an address, indicating whether it is recognized or authorized as a developer within the contract. This status can be set by the owner and is emitted as an event when changed.",
        "url": 394
    },
    {
        "nl_input": "The query requires a function that allows any user to set rabbit data, provided they submit a signed message verified as coming from the COO. The function must validate the signature, ensure the task ID is unused, and update the rabbit's attributes securely.",
        "url": 395
    },
    {
        "nl_input": "The query requires a function that allows depositing tokens into a user's account within a game. The function should handle transferring tokens from the sender\u2019s balance, updating the respective balances, and emitting a deposit event. It may involve checks for sufficient balance and user validation.",
        "url": 396
    },
    {
        "nl_input": "The query describes a mechanism where the `pricePerToken` can be set to zero to disable a pre-ICO address. This implies a functionality to control participation in the pre-ICO phase by disabling certain addresses through price configuration.",
        "url": 397
    },
    {
        "nl_input": "If the last update occurred more than one day ago, the system should update the price and record the current update time.",
        "url": 398
    },
    {
        "nl_input": "The query requires a function to freeze multiple accounts at once, which is fulfilled by the `freezeMultiAccounts` function in the first code. It allows the owner to pass an array of addresses and set their frozen status collectively.",
        "url": 399
    },
    {
        "nl_input": "The query requires a function that updates the payout for burritos owned by an owner, calculating the owed amount based on pool total and previously withdrawn amounts, and updating payout balances accordingly.",
        "url": 400
    },
    {
        "nl_input": "The query requires an admin function to withdraw PLAT tokens from a contract. The function should ensure only the admin can call it, allow the transfer of PLAT tokens to the admin's address, and handle the current token balance correctly. Additionally, it may include a check to ensure the withdrawal amount does not exceed the contract's balance and emit an event upon successful withdrawal.",
        "url": 401
    },
    {
        "nl_input": "The query requires verifying whether all contributors have successfully received their tokens. The relevant code should check token distribution status for all contributors and confirm completion.",
        "url": 402
    },
    {
        "nl_input": "The query seeks to identify code that provides functionality for managing and interacting with a list of contributors in a smart contract. Specifically, it emphasizes retrieving all contributors, compensating them based on certain conditions, and checking the distribution status of their tokens. The contracts referenced involve operations such as reading contributor data, handling compensation logic, and verifying token distribution completeness.",
        "url": 403
    },
    {
        "nl_input": "The query requires retrieving the current authorization limit that allows account `_spender` to withdraw tokens from account `_owner`.",
        "url": 404
    },
    {
        "nl_input": "The query seeks to determine the amount of tokens available or returnable for a user, based on their address, token address, or contributed wei amount. It involves functions that calculate token availability either from pre-allocated amounts or by converting ether to tokens using a defined rate.",
        "url": 405
    },
    {
        "nl_input": "The query requires a function to start or create an auction, involving parameters such as item ID, price range, and duration. The function should include access control (e.g., only owner or authorized user), input validation, and interaction with other functions or contracts, such as checking ownership and initiating the auction process.",
        "url": 406
    },
    {
        "nl_input": "The query seeks a function that reenables token transfers after a freeze has been initiated. The function should be triggered by the owner, accept a reason or explanation for the unfreeze, update the freeze status in the contract, and emit an event with relevant details.",
        "url": 407
    },
    {
        "nl_input": "The query requires a function to finalize a crowdsale, including steps such as minting remaining tokens, transferring unsold tokens back to a wallet, and triggering events or state changes to indicate completion. It should be callable only by the owner and ensure the crowdsale has ended before executing.",
        "url": 408
    },
    {
        "nl_input": "The query requires a function that calculates points for the round of sixteen, quarter-finals, and semifinals based on match predictions. It should take parameters such as the number of matches, the specific round, and prediction data, then return the calculated points.",
        "url": 409
    },
    {
        "nl_input": "The query requires a function that transfers all Ether held by the contract to a specified address controlled by the owner. The function should ensure only the owner can trigger the transfer.",
        "url": 410
    },
    {
        "nl_input": "The query seeks a function that sets default vesting schedule parameters, specifically focusing on defining bonus and principal lock percentages, lock periods, and pricing for early participants within a whitelist context.",
        "url": 411
    },
    {
        "nl_input": "The query highlights a scenario where all ETH rewards have been withdrawn, but the contract still requires ETH to cover transaction transfer costs. It seeks functionality that ensures transactions can be paid for even when no ETH remains in the contract. The ideal solution would manage withdrawal logic and ensure sufficient funds are retained or retrieved for transaction fees.",
        "url": 412
    },
    {
        "nl_input": "The query requires a burn function that allows the owner to burn all tokens owned by a specified address. The function should ensure only the owner can call it, validate the burn amount, reduce the balance and total supply accordingly, and emit a burn event.",
        "url": 413
    },
    {
        "nl_input": "The query seeks a utility function within a smart contract that restricts the number of times a function can be executed to only once. The relevant code should include a modifier that tracks and limits function call attempts using a counter variable, ensuring execution is limited to a single instance.",
        "url": 414
    },
    {
        "nl_input": "The query requires a function that checks whether a given amount of fuel can be sold today, returning false if the amount exceeds the available supply after accounting for what has already been sold and reserved. The function should use data from the `Day` struct to determine the validity of the sale.",
        "url": 415
    },
    {
        "nl_input": "The query requires a function that retrieves the total number of tweets for a specific round. The relevant code provides a function `getTweets(uint256 round)` which returns the tweet count for the specified round using a mapping or array `pastRoundsTweets`.",
        "url": 416
    },
    {
        "nl_input": "The query requires a function to set allowances for other addresses, enabling an authorized address to spend a specified maximum amount of tokens on behalf of the sender. The function should accept the spender address and the value limit as parameters, and return a boolean indicating success.",
        "url": 417
    },
    {
        "nl_input": "The query asks for the total supply of \"xlmgold\" tokens. The provided code snippets define `totalSupply()` functions in three different contracts, each returning a variable that likely represents the total token supply (`totalSupply`, `numTokens`, or `totalSupply_`). However, none of the contracts explicitly refer to \"xlmgold\" tokens, making it unclear which contract, if any, is relevant without additional context.",
        "url": 418
    },
    {
        "nl_input": "The query seeks a time-related utility function in the provided contracts. The relevant functions include: retrieving the current time, setting time periods, and displaying timelock details. Emphasis is on time manipulation and representation functionalities within smart contracts.",
        "url": 419
    },
    {
        "nl_input": "The query requires a function that allows the owner to withdraw DGZ tokens to a beneficiary address. The function should ensure that the withdrawal can only be performed by the owner, and it should emit an event indicating the withdrawal of DGZ tokens. Additionally, it may affect internal accounting such as increasing a sold token counter.",
        "url": 420
    },
    {
        "nl_input": "The query requires a function that returns the sum of two unsigned integers, `x` and `y`, and throws an exception (or reverts) in case of overflow. The function should be safe for use in smart contracts to prevent arithmetic errors leading to vulnerabilities.",
        "url": 421
    },
    {
        "nl_input": "The owner allocates tokens for a private sale by processing purchases with a predefined rate and available token pool, ensuring beneficiaries receive tokens based on sent ether, and handling overflow by updating the stage and refunding excess ether.",
        "url": 422
    },
    {
        "nl_input": "The query requires a function to preallocate a liquid portion of tokens, involving minting tokens for a specified address with restrictions on allocation and administrative control.",
        "url": 423
    },
    {
        "nl_input": "The query requires a function that returns the total number of Zodiacs currently in existence. The most relevant code is from contract `c12251`, which defines a `totalSupply` function returning `zodiacs.length - 1`. This implies that the array `zodiacs` tracks all existing Zodiacs, and the total count is derived by subtracting one from its length.",
        "url": 424
    },
    {
        "nl_input": "The query refers to a contract constructor. However, none of the provided code snippets explicitly contain a constructor function within their respective contracts. A constructor is typically defined using the `constructor` keyword in Solidity, which does not appear in the given examples. The contracts shown define functions and modifiers related to contributions, contractor access, and time-based conditions, but not initialization logic via a constructor.",
        "url": 425
    },
    {
        "nl_input": "The query requirement is for a function used in transport, challenge, and train operations to retrieve the genes of a specific hero. If the user has no hero, it allows them to claim one. The function `_getHeroGenesOrClaimFirstHero` fulfills this need by checking hero ownership and fetching gene data accordingly.",
        "url": 426
    },
    {
        "nl_input": "The query requires setting up a transform agent that handles specific functionalities, involving validation checks such as non-zero address, current transform state, and verifying original supply and funds match. It includes updating the transform agent and triggering an event upon successful setup.",
        "url": 427
    },
    {
        "nl_input": "The query requires a function to withdraw all Ether from a contract to the owner's address. The ideal function should use `transfer` and ensure only the owner can call it, without any additional parameters or complex logic.",
        "url": 428
    },
    {
        "nl_input": "The query requires a function to mint Kin tokens, specifying the recipient address and the token amount. The function should include access control (e.g., only owner), validation checks (e.g., non-zero address), and emit relevant events upon successful minting.",
        "url": 429
    },
    {
        "nl_input": "The query requires a function to execute periodic subscription payments, handling chargeable subscriptions by transferring funds between parties and updating subscription states upon successful payment. It involves validation checks, contract interaction, and event triggering for payment execution.",
        "url": 430
    },
    {
        "nl_input": "The query seeks a description of requirements for a function that can be called by users and token holders to verify whether Trump is still president. The function should likely involve checks based on external data, be accessible to users and token holders, and return a boolean or related status indicating the result.",
        "url": 431
    },
    {
        "nl_input": "The query requires a function or modifier that ensures only a designated burnable account can perform a token burning operation. It emphasizes access control, allowing the burn function to be called exclusively by the authorized burner account.",
        "url": 432
    },
    {
        "nl_input": "The query seeks to determine whether an early purchase has been amended within a smart contract. The relevant function `isAmendedEarlyPurchase` checks if a given early purchase index exists in the list of amended indexes, returning true if it has been amended.",
        "url": 433
    },
    {
        "nl_input": "Marks the document with the specified ID as visible by setting its visibility status to false in a mapping, and emits an event indicating the change. The function is accessible only to an editor and applies to documents that are currently marked as invisible.",
        "url": 434
    },
    {
        "nl_input": "The query requires a function that returns the current round in a contract, where each round may have specific conditions or checks to determine its applicability. The function should provide information about the current round, potentially including its status, boundaries, or associated data.",
        "url": 435
    },
    {
        "nl_input": "The query requires a function that updates a listingHash's status from 'application' to 'listing' or resolves an existing challenge. The function checks if the listingHash can be whitelisted or if its challenge can be resolved, performing the respective action. If neither condition is met, it reverts the transaction.",
        "url": 436
    },
    {
        "nl_input": "The query refers to a refund poll mechanism, checking specific dates for eligibility. The relevant code includes logic to determine if the current time falls within a valid refund poll window, using timestamps and checking against an array of dates. It involves internal date validation for refund conditions in a token sale or investment context.",
        "url": 437
    },
    {
        "nl_input": "The query requires a description of a minting function in a smart contract. The function should allow for the addition of a minter address, ensuring it is only callable by the owner and that the provided address is valid and not already a minter. It should return a boolean indicating success.",
        "url": 438
    },
    {
        "nl_input": "The query requires a function to transfer tokens from one address to another, while checking if the sender has dividends to pay before proceeding with the transfer. The function should handle dividend validation using a mechanism like `checkDividend(_from)` and ensure secure token deduction and transfer.",
        "url": 439
    },
    {
        "nl_input": "The query requires a function to refund investment to investors, involving conditions like time constraints, investor address handling, and fund transfer operations. It includes features such as checking eligibility for refunds, updating investment records, and transferring funds back to the investor.",
        "url": 440
    },
    {
        "nl_input": "The query requires a function that sets a KYC contribution cap for a given address based on a level. The function must be owner-restricted, handle different levels (0 to 3), and assign corresponding caps using ether or USD conversions with SafeMath.",
        "url": 441
    },
    {
        "nl_input": "The query requires retrieving the current exchange rate of LNC per Ether, which involves obtaining the rate used for converting Ether to tokens. The relevant code indicates that the `RATE` variable is utilized for this purpose, particularly in contracts where the rate can be updated based on financial metrics like total supply and escrow balance.",
        "url": 442
    },
    {
        "nl_input": "The query requires a function that allows updating the minimum contribution or bet amount required for participation or betting. The function must ensure the new value is greater than zero, be updatable only by a privileged role (e.g., owner or management), and optionally emit an event upon successful update.",
        "url": 443
    },
    {
        "nl_input": "The query requires a function to manually send tokens to a specified address, with checks for pre-ICO or ICO status, available token balance, and proper authorization. It involves transferring tokens from the contract, updating purchase information, and ensuring compliance with minting conditions.",
        "url": 444
    },
    {
        "nl_input": "The query seeks to determine the number of voters who have voted for a specific proposal. It requires accessing a function that, given a proposal identifier (such as a root hash), returns the total count of voters associated with that proposal.",
        "url": 445
    },
    {
        "nl_input": "The query requires a function that adds a user address to a list of participants. The function must check if the user is already in the list to avoid duplicates, and if not, add them to the participants array. It should be internal, accept an address parameter, and operate within a lottery context.",
        "url": 446
    },
    {
        "nl_input": "The query requires a function to deauthorize an issuer, which is achieved by removing the issuer's authorization status in a smart contract. The function should be restricted to the owner and emit an event upon successful removal.",
        "url": 447
    },
    {
        "nl_input": "The query requires a function to calculate the amount of non-vested tokens at a specific time for a given token grant, based on the difference between the total grant value and the vested tokens up to that time.",
        "url": 448
    },
    {
        "nl_input": "The query requires setting up an array to define vesting stages with specific dates and corresponding token unlock percentages. The referenced code initializes multiple stages with timestamps and percentage values to control token vesting over time.",
        "url": 449
    },
    {
        "nl_input": "The query describes a token purchase process where users send Ether to buy tokens. The function is public and payable, requiring a minimum Ether value (e.g., 0.00104 ether or 20 finney). It calculates the number of tokens based on the sent Ether and a predefined rate or price, updates balances or issues tokens accordingly, and forwards the received Ether to a designated wallet address. Additionally, it includes safety checks like non-zero addresses and valid message values.",
        "url": 450
    },
    {
        "nl_input": "The query requires retrieving the number of contributors for all campaigns. The relevant code provides a function that returns an array of contributor IDs, allowing the caller to determine the total count by checking the length of the returned array.",
        "url": 451
    },
    {
        "nl_input": "The query requires a function to sell tokens during a crowd sale. The function should handle transferring tokens from the contract to an investor, reduce the available token supply accordingly, and operate internally within the contract.",
        "url": 452
    },
    {
        "nl_input": "The query requires checking if a token transfer destination address is valid by ensuring it is not the zero address or the token contract address itself. The validation is implemented using a modifier that enforces these conditions before allowing a token transfer.",
        "url": 453
    },
    {
        "nl_input": "The query requires adding an administrator address that can manage the token even when it is paused. The functionality should allow the owner to add or set an administrator, ensuring administrative control irrespective of the token's operational state.",
        "url": 454
    },
    {
        "nl_input": "The query requires functions that can extract an address and a `bytes32` value from a byte array without requiring manual casting. It emphasizes type compatibility for easier usage, indicating a need for low-level data parsing in Solidity, particularly handling `address` and `bytes32` types efficiently within smart contracts.",
        "url": 455
    },
    {
        "nl_input": "The query requires a function that adds a fee associated with an address in a private context. The function should update the fee value by either setting it initially or adding to the existing amount. The operation must be private, indicating restricted access.",
        "url": 456
    },
    {
        "nl_input": "The query seeks a re-entry protection mechanism in the provided code. Re-entry protection prevents a function from being called recursively, typically during contract execution. The relevant code uses a `modifier` with a `require` statement to ensure the contract is not already running, blocking repeated invocations until completion.",
        "url": 457
    },
    {
        "nl_input": "The query requires a function that filters buyers from a list based on whether they are approved investors. The function should take a boolean input indicating the investor status and return a filtered list of addresses. It should perform this operation privately and without modifying the original list.",
        "url": 458
    },
    {
        "nl_input": "The query seeks information on whether \"modifiers are inherited\" in Solidity, specifically examining the \"onlyOwner\" pattern across provided code examples. It references Solidity's official documentation for clarification and includes code samples that define the onlyOwner modifier in different contracts.",
        "url": 459
    },
    {
        "nl_input": "The query requires a function that sets the `paused` variable to `false`, typically used to resume normal contract operations after being paused. The function should be callable by the owner, execute only when the contract is paused, and emit an `Unpause` event upon successful execution.",
        "url": 460
    },
    {
        "nl_input": "The query highlights a common theme where tokens are initially not released, and their release is controlled through specific functions. These functions often include access restrictions (e.g., only the owner can call them), validation checks to ensure the release state, and functionalities that unlock or move tokens only after certain conditions or times are met.",
        "url": 461
    },
    {
        "nl_input": "The query requires a function to check how many ACE Equity Tokens a spender is allowed to spend from an owner. The function should take the owner's and spender's addresses as parameters and return the remaining token allowance as a uint256.",
        "url": 462
    },
    {
        "nl_input": "The query describes a process where bonus tokens are distributed and then sent back to the coin itself. The relevant code would involve functionality to handle unsold or leftover tokens post-distribution, specifically returning them to a wallet or contract. The requirement is to finalize a token sale by redirecting remaining tokens to a designated address, typically after a crowdsale ends.",
        "url": 463
    },
    {
        "nl_input": "The query requires a function that retrieves the balance of a specified account in a smart contract. The function should accept an address parameter representing the account owner and return the corresponding balance, which can be used to determine the number of tokens or funds associated with that account.",
        "url": 464
    },
    {
        "nl_input": "The query requires a function that allows a user to claim ownership of a specific unicorn ID. The function should take the unicorn's ID as a parameter, validate the caller's allowance to claim it, and then transfer ownership from the current owner to the caller. This includes checking approval rights and handling the transfer process securely.",
        "url": 465
    },
    {
        "nl_input": "The query seeks functionality related to handling asset redemption during both paused and non-paused states. The relevant code defines a contract with a function `receiveAssets` that updates deposited assets and emits an event, without checking for a paused state, implying it works in both scenarios. It also includes logic to manage the \"paused\" variable, suggesting a mechanism to control contract functionality based on this state.",
        "url": 466
    },
    {
        "nl_input": "The query requires a function that transfers advisor tokens to an advisor's wallet under specific conditions, including time locking and vesting schedules. The function should be callable only by the owner and include checks to ensure the transfer occurs only after a specified time and before reaching the maximum vesting limit.",
        "url": 467
    },
    {
        "nl_input": "The query describes a function that allows the owner to transfer ERC20 tokens to a multi-signature vault. Among the provided code options, the first contract (`c21667`) directly matches this requirement by implementing a `retrieveTokens` function that transfers ERC20 tokens from the contract to the multisig vault, using the `onlyOwner` modifier for access control.\n\n**Description of query requirements (within 80 words):**  \nA function that enables the owner to transfer all ERC20 tokens held by the contract to a multi-signature vault for secure custody, ensuring only the owner can initiate the transfer.",
        "url": 468
    },
    {
        "nl_input": "The query requires a function that allows approving token transfer and invoking a call to another contract in a single step. It involves parameters such as the recipient address, token amount, and additional data for the called contract function.",
        "url": 469
    },
    {
        "nl_input": "The query requires a function to transfer ownership of a contract from the current owner (`this`) to a new specified address. The function should ensure that only the current owner can execute the transfer, and it must correctly update the ownership state in compliance with standard practices.",
        "url": 470
    },
    {
        "nl_input": "The query requests a function that retrieves a list of token IDs owned by a specified address. The required functionality is to input an address and return an array of `uint256` representing the token IDs associated with that address.",
        "url": 471
    },
    {
        "nl_input": "The query indicates that the functions `endCrowdsale()` and `endCrowdsalePublic()` have been moved to the Steak contract. It references other contracts where similar functions exist, implying a need to identify and possibly consolidate crowdsale-ending logic into the Steak contract. The goal appears to be centralizing or refactoring functionality related to ending a crowdsale, likely for improved code organization, access control, or integration with other functionalities in the Steak contract.",
        "url": 472
    },
    {
        "nl_input": "The query requires a function that calculates the amount of tokens based on a given wei amount, involving a rate or exchange mechanism. The implementation may include tiered rates and conversion logic using ether or other defined units to determine the token value.",
        "url": 473
    },
    {
        "nl_input": "The query describes a function that allows the token owner to rename the token after operations are completed and direct users to the token contract. The function `setTokenInformation` in both contracts c33165 and c4239 meets this requirement by allowing the owner to update the token's name and symbol and emit an event to notify the change, aligning with the described functionality.",
        "url": 474
    },
    {
        "nl_input": "The query refers to a functionality where users can purchase option tokens. The code indicates that there is a `buyOptions` function which allows buying tokens by specifying the buyer, USD cents value, and a transaction hash. It sequentially attempts purchases using different token types (`gvOptionToken30`, `gvOptionToken20`, `gvOptionToken10`) with varying percentages (`option30perCent`, `option20perCent`, `option10perCent`). The function utilizes `buyIfAvailable` to check availability and deduct remaining USD cents accordingly. Requirements include non-zero USD cents input and ICO-only access control.\n\n**Short Description (under 80 words):**  \nThe query describes a system for buying option tokens with USD cents during an ICO. Users can purchase tokens in tiers (`30%`, `20%`, `10%`) using a transaction hash, with availability checks and sequential allocation.",
        "url": 475
    },
    {
        "nl_input": "The query requires a function that calculates unclaimed fees for a fund manager. These fees consist of both time-based management fees and performance-based fees derived from the increase in share price. The calculation should return the individual fees and their sum, based on the gross asset value (gav) and predefined fee rates.",
        "url": 476
    },
    {
        "nl_input": "The query requires a time-based restriction of 3 weeks after a sale has closed before trading can commence. The provided code snippets do not include logic for enforcing a 3-week delay or tracking time-based conditions, thus failing to meet the requirement.",
        "url": 477
    },
    {
        "nl_input": "The query requires a function that allows purchasing soldiers by paying a specific amount of ether. The function should accept an army ID and the number of soldiers to purchase. Different tiers of purchases exist, each requiring a specific ether value and soldier count combination to increment the total soldiers in an army.",
        "url": 478
    },
    {
        "nl_input": "The query requires a function to add a minter to a list of authorized minters in a smart contract. The function should take an address parameter, validate it is not zero or already a minter, update the minter list, and return a success boolean. It should be publicly accessible and restricted to the owner with a custom modifier like `onlyOwner`.",
        "url": 479
    },
    {
        "nl_input": "The query requires a function to start a token distribution phase in a smart contract, allowing owners to claim their tokens. The function must validate the token is whitelisted, ensure distribution is not already active, and confirm the contract balance meets the minimum distribution limit before initiating the distribution process.",
        "url": 480
    },
    {
        "nl_input": "The query requires an internal function that removes a deed ID from the list associated with a given address, updating relevant data structures and indices accordingly.",
        "url": 481
    },
    {
        "nl_input": "The query requires a function that returns the share balance of the sender (msg.sender) in a smart contract. The function should be view-only, accessible publicly, and return a uint256 value representing the sender's current share balance.",
        "url": 482
    },
    {
        "nl_input": "The query requires a function that allows a bidder to submit the properties of a bid to reveal them. The function should accept parameters for a hash, bid value, and salt, validate the bid, update auction state, handle deed transfers, and emit events based on the bid's outcome such as being too low, replacing a prior bid, or closing the deed.",
        "url": 483
    },
    {
        "nl_input": "The query requires a function that allows the contract owner to securely add a new Sale wallet for holding funds. The function must ensure only the owner can execute it, validate the provided wallet address, and successfully return a confirmation upon execution.",
        "url": 484
    },
    {
        "nl_input": "The query requires a modifier in a smart contract that restricts function execution to only the Contractor. The modifier should take an address parameter for comparison with `msg.sender`, ensuring access control is based on the Contractor's identity.",
        "url": 485
    },
    {
        "nl_input": "The query describes a functionality where locked tokens are moved to a team account, specifically after a release time. The relevant code reflects this by showing a function that releases team tokens from a timelock, ensuring they can only be moved once the designated time has passed.",
        "url": 486
    },
    {
        "nl_input": "The query requires adjusting the `hasEnded` function to reflect a scenario where all tokens have been sold. The function should return true when either the sale time has ended or there are no tokens left (`tokensLeft <= 0`). This ensures the sale ends automatically once all tokens are sold out, regardless of time.",
        "url": 487
    },
    {
        "nl_input": "The query requires a function that returns the name of the token. The relevant code provides a `name()` function that returns the token's name as a string.",
        "url": 488
    },
    {
        "nl_input": "The query requires functionality to set and update the exchange rate for converting tokens (TCR) to Ether (ETH), where only the owner can modify this rate. The implementation should include a function that allows the owner to input a new rate, enforce constraints on valid rate values, and store or update the rate accordingly.",
        "url": 489
    },
    {
        "nl_input": "The query requires a `SafeMath` `divide` function that performs safe division of two unsigned integers, ensuring no division by zero and returning the correct quotient. It may also involve using the result of a multiplication operation as part of the division, ensuring overall arithmetic safety.",
        "url": 490
    },
    {
        "nl_input": "The query requires a function to airdrop tokens to multiple addresses, transferring specified token amounts from a source address to each recipient. The function should support batch transfers, handle whole token values only, and ensure the number of recipients matches the number of token values provided.",
        "url": 491
    },
    {
        "nl_input": "The query requires a function to refund Ether to investors, which can be invoked only from a token contract. It involves verifying conditions like time and refund allowance, calculating investor contributions, and transferring Ether back while updating contract balances and states accordingly.",
        "url": 492
    },
    {
        "nl_input": "The query requires a function to perform a batch transfer of ETH to multiple addresses, with the amount distributed equally among them. The function should accept an array of addresses and handle the transfer of ETH from the sender's payment.",
        "url": 493
    },
    {
        "nl_input": "The query requires a function that allows the owner to propose a new address for ownership, with the change needing confirmation by a third party (e.g., a notary or through an event). The proposed address should be stored temporarily and not take effect immediately.",
        "url": 494
    },
    {
        "nl_input": "The query seeks information related to interface declarations in the provided code. The relevant requirement is the presence of functions that serve as interface markers, such as `isPricingStrategy()` and `isCrowdsale()`, which return a boolean constant value. These functions are used to identify contract interfaces within the codebase, indicating specific roles or functionalities associated with the contracts.",
        "url": 495
    },
    {
        "nl_input": "The query requires a function to cancel reserved tokens, specifying the wallet address and amount. The function should validate the inputs, ensure the sale has not ended, update the reserved token amounts, emit an event, and be restricted to the owner.",
        "url": 496
    },
    {
        "nl_input": "The query requires identifying functions that restrict execution to the owner of the contract. The relevant code examples define an `onlyOwner` modifier that ensures only the contract's owner can call specific functions, with varying syntax and condition checks (e.g., equality or inequality). These modifiers are used to enforce access control in smart contracts.",
        "url": 497
    },
    {
        "nl_input": "A consulta refere-se a funcionalidades relacionadas \u00e0 transfer\u00eancia de tokens em contratos inteligentes Ethereum. A principal necessidade identificada \u00e9 a implementa\u00e7\u00e3o de fun\u00e7\u00f5es que permitam o envio de tokens entre endere\u00e7os, com destaque para requisitos como autoriza\u00e7\u00e3o, verifica\u00e7\u00e3o de saldos e poss\u00edveis restri\u00e7\u00f5es temporais ou de participa\u00e7\u00e3o no contrato.",
        "url": 498
    },
    {
        "nl_input": "The query describes an \"approve\" function in a token contract that allows a user to authorize another address (the spender) to spend a specified amount of tokens on their behalf. The function typically takes parameters for the spender's address and the token amount, updates an allowance mapping, and emits an approval event.",
        "url": 499
    },
    {
        "nl_input": "The query requires a function that returns funds to a specific party, potentially the curator or investors, under defined conditions such as failed sales or available refunds. It involves checking eligibility and transferring the balance or invested amount back to the sender.",
        "url": 500
    },
    {
        "nl_input": "The query seeks a function that initializes or starts a process in a contract, specifically one that can be executed after deployment and is separate from the constructor. It should allow setting up key parameters or stages, and ideally includes owner restrictions and proper state management.",
        "url": 501
    },
    {
        "nl_input": "The query requires a function to transfer token balance from one address to another, including parameters for the recipient address and transfer amount, along with proper validation and event emission.",
        "url": 502
    },
    {
        "nl_input": "The query requires a function that allows depositing wei into an exchange contract. The function should be payable, ensure the sender is whitelisted, update the sender's token balance in wei, and emit a deposit event with relevant details.",
        "url": 503
    },
    {
        "nl_input": "The query seeks proof that terms and conditions have been read and understood. The relevant code involves a function that verifies a digital signature, confirming that the sender has signed the terms using Ethereum's `ecrecover` function.",
        "url": 504
    },
    {
        "nl_input": "The query seeks a function that calculates the number of tokens that can be obtained for a given amount of ether (or wei). Among the provided codes, one defines such a functionality, returning both the token amount and any excess. The other two codes are related to token transfer but do not meet the query's specific requirement.",
        "url": 505
    },
    {
        "nl_input": "The query requires a function that allows a token holder to permit another address to transfer tokens on their behalf, using the `transferFrom` mechanism. This includes features like checking allowance, deducting from the sender's balance, and updating the recipient's balance.",
        "url": 506
    },
    {
        "nl_input": "The query requires a function that allows selling keys (or assets) for ETH, involving balance checks, transfers, and ensuring the seller receives the correct amount. The function should be public, include a payable mechanism, and validate that the contract holds sufficient funds before executing the sale.",
        "url": 507
    },
    {
        "nl_input": "The query requires a function that returns the child address for a given parent address. Among the provided code options, only the first contract `c37108` fulfills this requirement with its `returnChildAddressForParent` function, which takes an `address parent` as input and returns the corresponding child address by calling an external contract at address `0xEe22430595aE400a30FFBA37883363Fbf293e24e`.",
        "url": 508
    },
    {
        "nl_input": "The query seeks a function or modifier that allows certain actions to be performed by anyone. The relevant code provides a modifier named `whenEveryone`, which permits execution if not explicitly disabled, aligning with the requirement of being callable by everyone.",
        "url": 509
    },
    {
        "nl_input": "The query seeks functionality related to checking or distributing rewards in a smart contract. The relevant code would involve mechanisms for tracking, adding, or distributing reward amounts, potentially including checks for balance and limits.",
        "url": 510
    },
    {
        "nl_input": "The query requires a function that checks whether the parameters of a sale are valid. Specifically, it validates that either the sale is of type `FixedPrice` or the `expirationTime` is greater than zero. The function is internal, pure, and returns a boolean indicating the validity of the parameters.",
        "url": 511
    },
    {
        "nl_input": "The query seeks a function that checks whether a given rate is within predefined limits, specifically an internal function that returns a boolean indicating validity based on minimum and maximum rate constraints.",
        "url": 512
    },
    {
        "nl_input": "The query requires a function that retrieves the token balance of a specified wallet address. The function should take an address as input and return the number of tokens owned by that address.",
        "url": 513
    },
    {
        "nl_input": "The query requires a function that checks whether one value is equal to or greater than another value. The function should take two numeric inputs and return a boolean result indicating the comparison outcome.",
        "url": 514
    },
    {
        "nl_input": "The query focuses on benefits for the owner in a smart contract. The relevant code provides functions to transfer funds to the owner, allowing only the owner to call it, and includes checks to ensure correct fund transfers. It involves transferring benefit funds to the owner, resetting the benefit pool, and validating balance consistency after the transfer.",
        "url": 515
    },
    {
        "nl_input": "The query requires logging a diary entry with the current timestamp. The system must record the log time using the current time (`now`) and store the diary content along with an incremental ID. Additionally, access is restricted to authorized entities (e.g., via modifiers like `oneOfOwners` and `callByBank`).",
        "url": 516
    },
    {
        "nl_input": "The query seeks a function that allows burning tokens from a user's account. It requires checking if the user has sufficient balance and allowance, reducing the balance and total supply accordingly, and emitting a burn event. The implementation should include safety checks to prevent unauthorized or excessive burns.",
        "url": 517
    },
    {
        "nl_input": "The query seeks to identify code that allows setting a value related to a card, watt, or month. The relevant code enables updating a monthly cents amount by the owner in a smart contract.",
        "url": 518
    },
    {
        "nl_input": "The query requires a function to approve the removal of an owner, callable only by existing owners who have not previously approved the removal. The function must validate ownership, check approval conditions, and execute the removal upon meeting required confirmations.",
        "url": 519
    },
    {
        "nl_input": "The query requires a function that refunds funds to investors if the ICO does not meet its funding goal or deadline. The function should check if the ICO was unsuccessful, then transfer the invested amount back to the investor's address.",
        "url": 520
    },
    {
        "nl_input": "The query describes a scenario where an individual has permanently lost their ETH but receives a consolation prize. The relevant functionality in the provided code allows users to claim a prize based on token ownership, with mechanisms in place to prevent abuse and ensure fair distribution.",
        "url": 521
    },
    {
        "nl_input": "The query seeks to determine the maximum investment in wei that can be accepted during a sale. The relevant information includes functions that return or set maximum funding limits in wei, particularly focusing on logic where `_max` is used to define the upper limit for purchases.",
        "url": 522
    },
    {
        "nl_input": "The query requires a function that transfers a tulip to another address without confirmation, ensuring the receiver's address is valid and the sender owns the tulip. It includes safety checks and uses an internal transfer function.",
        "url": 523
    },
    {
        "nl_input": "The query requires a function modifier that ensures functions can only be executed once the vesting period has elapsed. The logic should involve checking the elapsed time or specific conditions tied to the vesting schedule before allowing execution.",
        "url": 524
    },
    {
        "nl_input": "The query requires a function that accepts a value of exactly 0.1 ether, indicating a need for a smart contract mechanism that validates and processes transactions specifically at this Ether amount.",
        "url": 525
    },
    {
        "nl_input": "The query describes a function that sends funds from the Bankroll to provide additional dividends. It involves transferring Ether (ETH) from a contract to a specified address, ensuring that the amount being sent is greater than 1 and updating related tracking variables. The operation uses SafeMath for arithmetic safety and reverts the transfer if it fails.",
        "url": 526
    },
    {
        "nl_input": "The query requires ensuring that the caller's account has enough tokens to approve a specified action, such as spending or minting tokens, typically involving checks for balance sufficiency and proper authorization before executing the approval.",
        "url": 527
    },
    {
        "nl_input": "The query requires a function that allows the owner to change the token exchange rate, ensuring that only the owner wallet can call this function. The function should update the rate variable based on input and may include logic for conditional rate adjustments based on contract balance or other parameters.",
        "url": 528
    },
    {
        "nl_input": "The query requires a function that distributes ERC20 tokens to multiple holders based on predefined ratios. The selected code should handle internal distribution, calculate each holder's share using total supply and ratio data, and ensure the distribution occurs only once. It should also emit a confirmation event after distribution.",
        "url": 529
    },
    {
        "nl_input": "The query requires a function to transfer tokens from a specified address to an owner address, with appropriate validations and ownership checks. The function should allow the owner to initiate token transfers, include safety checks such as non-zero addresses and valid token amounts, and ensure only the owner can perform the transfer.",
        "url": 530
    },
    {
        "nl_input": "The query refers to a blockchain-based betting system where users can bet on a number between 0 and 36. The system checks for valid bet size, fund availability, and number range, then generates a random number. If the user's chosen number matches, they win 36 times their bet; otherwise, the casino keeps the bet.",
        "url": 531
    },
    {
        "nl_input": "The query requires a function to manually refund a bet if the Oraclize callback was not received. This implies handling cases where an expected result from an external service (Oraclize) does not arrive, necessitating a fallback mechanism to return funds or cancel the bet under controlled conditions.",
        "url": 532
    },
    {
        "nl_input": "The query requires a function to set a verification slashing period in blocks, callable only by the controller owner, ensuring it is added to the verification period and capped at 256.",
        "url": 533
    },
    {
        "nl_input": "The query requires a function that sets a time lock for a given allocation address, ensuring the address is non-zero and the lock time is in the future. The function should be callable externally, emit an event upon execution, and store the lock time for the specified address.",
        "url": 534
    },
    {
        "nl_input": "The query requires a function that declines token minting for a specified investor by removing their allocated tokens from the hold map and updating the contract state accordingly.",
        "url": 535
    },
    {
        "nl_input": "The query requires a function that allows setting or updating the percentage of tokens reserved for a wallet. It involves changing the reserved tokens percentage value through a function that accepts a new percentage as input and updates the corresponding variable in the contract. The function should be owner-restricted and may include an event to log the change.",
        "url": 536
    },
    {
        "nl_input": "The query requires setting up an interface to the Blocklord contract by providing a function that allows the owner to set or update the Blocklord interface address. Among the provided codes, the relevant one includes a `setBLInterface` function that meets this requirement. \n\n**Description:** Setup the interface to the Blocklord contract by setting its address through an owner-only function.",
        "url": 537
    },
    {
        "nl_input": "The query seeks a contract mechanism ensuring original tokens are equally distributed without the possibility of a \"divine dump,\" promoting healthy longevity. The relevant code should handle token distribution fairly, prevent unauthorized or uneven token release, and possibly include safeguards against dumping, such as controlled transfers, ownership restrictions, or unsold token returns.",
        "url": 538
    },
    {
        "nl_input": "The query highlights the need for a safety mechanism to ensure unsold tokens are securely withdrawn back to the seller or owner after a transaction or auction concludes. It emphasizes preserving token availability until buyers complete their withdrawals and includes ownership controls, time conditions, and accurate balance calculations to prevent errors or misuse during withdrawal.",
        "url": 539
    },
    {
        "nl_input": "The query requires a function that updates a whitelisted contribution counter by subtracting a specified planned contribution value. The function should be private, modify the `whitelistedPlannedContributions` state variable, and emit an event with the updated value and the subtracted contribution.",
        "url": 540
    },
    {
        "nl_input": "The query requires setting the price for summoning a hero using Ether (Eth). The function should allow users to pay in Eth, include checks for correct payment and contract status, and determine the hero's rank based on randomness. Additionally, it should handle transfer of funds, potentially increase the summoning cost upon purchase, and mint the summoned hero to the user's address.",
        "url": 541
    },
    {
        "nl_input": "The query requires a function to log wallet interactions off-chain, specifically tracking deposits by recording the token address, amount deposited, and updated wallet balance. The event should be triggered externally and include the sender's address. No wallet address modification functionality is needed.",
        "url": 542
    },
    {
        "nl_input": "The query describes a scenario in a game where player two approves the SlammerTime contract to allow token transfer, triggering an event to notify player one that a battle (rumble) is initiated. The focus is on token approval and event broadcasting between players in a game context.",
        "url": 543
    },
    {
        "nl_input": "The query seeks to identify a modifier or function that restricts function access to a specific address, such as a contract owner or a designated address like \"Etheraffle.\" The desired functionality involves access control in Solidity contracts using modifiers like `onlyOwner` or custom ones like `onlyEtheraffle`, ensuring that only authorized addresses can execute certain functions.",
        "url": 544
    },
    {
        "nl_input": "The query requires a function to check if the ICO stage is active at a given time. The function should accept a timestamp and return a boolean indicating whether the time falls within the ICO period. Additionally, it should default to the current time if no timestamp is provided.",
        "url": 545
    },
    {
        "nl_input": "The query seeks a function that can be called without the owner's consent, is internal, and relates to token purchasing. The relevant code shows `buyToken()` being called internally in a payable `buy()` function that enforces basic purchase conditions like non-zero value and unfrozen accounts.",
        "url": 546
    },
    {
        "nl_input": "The query requires a function that allows the owner to set or change the number of tokens available for an ICO, ensuring that the total does not exceed 70 million. Additionally, this function must include a restriction that only the owner can execute it and should ideally be callable before the ICO starts.",
        "url": 547
    },
    {
        "nl_input": "The query requires a function that retrieves the asset allowance from one holder to another. The function should take parameters for the owner and spender addresses, and return the remaining allowed token amount. This functionality is commonly used in token contracts to check approval limits for transfers.",
        "url": 548
    },
    {
        "nl_input": "The query requires proposing a transfer of ownership of the EngravedToken contract to a specified address, `_engravedAddress`, with functionality to manage approval stages and deadlines for the transfer proposal.",
        "url": 549
    },
    {
        "nl_input": "The query requires a function to complete a breeding auction by placing a bid. The function should validate ownership, check breeding conditions, ensure sufficient payment, and handle the bidding process. It should return the result of breeding two entities (e.g., momId and dadId) while transferring excess funds appropriately.",
        "url": 550
    },
    {
        "nl_input": "The query highlights the idea that even small contributions can have a significant impact. From the given code, the most relevant aspect is the function `participantWithdrawIfMinimumFundingNotReached`, which allows participants to withdraw funds if the minimum funding goal is not met, emphasizing individual influence in collective outcomes.",
        "url": 551
    },
    {
        "nl_input": "The query requires an internal function that clears the current approval and transfers ownership of a specific token ID from one address to another. The function should handle validation checks, update token ownership, and emit a transfer event.",
        "url": 552
    },
    {
        "nl_input": "The query requires a function that allows the owner of an ICO contract to unpause a token contract. The function should be callable only by the ICO contract's owner and should trigger the unpause function of the token contract.",
        "url": 553
    },
    {
        "nl_input": "Participate in an auction by sending a bid with the transaction value, ensuring it exceeds the highest existing bid and adhering to the auction's time constraints.",
        "url": 554
    },
    {
        "nl_input": "The query requires a description of the process to buy HQX tokens. The code indicates that users can buy HQX by sending ETH, with tokens stored in the contract until a claim stage. Excess funds are returned if the max token limit is exceeded.",
        "url": 555
    },
    {
        "nl_input": "The query describes a scenario where proceeds are paid out immediately, but the contract may receive unexpected funds. The relevant code defines a function that allows the owner to withdraw a specified amount of ETH from the contract to a given address, ensuring the destination is valid and the amount does not exceed the contract's balance.",
        "url": 556
    },
    {
        "nl_input": "The query requires a function to batch set or update a quota for a user (e.g., \"admin\") only if a condition (e.g., `openTag == 0`) is met. The operation should involve a safety check, such as ensuring non-zero addresses and potentially removing or resetting values. The function should support batch processing and include appropriate access control (e.g., only owner or specific role).",
        "url": 557
    },
    {
        "nl_input": "The query seeks to determine if a game is currently active. The relevant functionality checks whether a specific game identifier has its \"active\" flag set, typically returning a boolean value based on this state.",
        "url": 558
    },
    {
        "nl_input": "The query seeks a function that enables writing to a grid in a pyramid structure, involving pixel manipulation with capabilities to set multiple pixels in a single transaction, including checks to ensure successful updates.",
        "url": 559
    },
    {
        "nl_input": "The query seeks a function that returns the total supply of tokens in a smart contract. The desired function is public, view or constant, and returns a uint256 value representing the total number of tokens currently in existence within the contract.\n\nToken count: 39",
        "url": 560
    },
    {
        "nl_input": "The query requires a function that calculates or retrieves the MET value for ETH. The relevant code provides a function `getMetForEthResult` that returns MET based on an ETH deposit amount using `convertingReturn`. Additionally, there's logic in another contract to calculate token amounts based on ETH contributions, which supports the MET calculation indirectly.",
        "url": 561
    },
    {
        "nl_input": "The query requires a function to disapprove a user's KYC, setting their KYC status to false and emitting an event to log the change. The function should be restricted to a KYC manager and update the user's status in storage.",
        "url": 562
    },
    {
        "nl_input": "The query requires a function to unpause a smart contract, setting the `paused` state to `false`. It should be callable only by an authorized role (e.g., owner or manager) and may include an event `Unpause()` to log the action. The function should ensure it can only be executed when the contract is currently paused.",
        "url": 563
    },
    {
        "nl_input": "The query requires a function to sell a specific amount of tokens (0.000000000000000001) to a contract. The suitable code should include a `sell` function that accepts the token amount, updates balances, and performs necessary transfers. It must handle internal or user-initiated token selling with proper validations and transaction processing.",
        "url": 564
    },
    {
        "nl_input": "The query requires a function that allows updating the maximum gas price, specifying the maximum gas price parameter in Gwei, and ensuring it is greater than zero.",
        "url": 565
    },
    {
        "nl_input": "The query describes a scenario where a user buys artworks automatically when a LikeCoin transfer is made. The callback triggers the `giveArtworks` function, which processes the purchase by validating artwork types, checking costs, and distributing artworks to the receiver. It ensures the transferred value is sufficient and updates artwork ownership and tracking data.",
        "url": 566
    },
    {
        "nl_input": "The query seeks information related to methods and functionality for managing an ICO (Initial Coin Offering) within smart contracts. This includes starting the ICO, checking if a time falls within the ICO period, and updating the ICO status based on token availability across different stages like Private ICO, Pre-ICO, and main ICO. It emphasizes tracking ICO phases, time constraints, and token sales status.",
        "url": 567
    },
    {
        "nl_input": "The query requires a function that allows a coin holder to vote by adding their account balance as votes to an option in an active ballot. The function must prevent transferring coins until the ballot ends and ensure voting only occurs during the active period.",
        "url": 568
    },
    {
        "nl_input": "The query requires a modifier that ensures a function can only be called by the `pendingOwner`, and it should throw an error if accessed by any other account.",
        "url": 569
    },
    {
        "nl_input": "The query checks whether a given address represents a certificate authority by verifying if the `lookup_api` field for that address in the `certificate_authority` mapping has a non-zero length. This is done through the `isCA` function in the provided contract code.",
        "url": 570
    },
    {
        "nl_input": "The query requires a function that assigns winnings, including bounty and bonds, to all users who provided the accepted answer. The function should handle fund distribution, manage prize pools, account for referral bonuses, and ensure proper allocation based on contributions or ownership.",
        "url": 571
    },
    {
        "nl_input": "The query focuses on the crowdsale process and token manipulations. It involves returning unsold tokens to the wallet upon sale completion, processing token purchases by assigning them to beneficiaries, and minting tokens for pre-crowdsale purchases before the crowdsale begins.",
        "url": 572
    },
    {
        "nl_input": "The query refers to a situation where a soft cap in a crowdfunding or investment contract has not been reached. The relevant functionality includes setting the soft cap, refunding funds if the soft cap is not met after the sale period ends, and potentially allowing manual intervention by the owner to adjust timelines based on soft cap conditions.",
        "url": 573
    },
    {
        "nl_input": "The query requires a function to set or update the reward divisor in a smart contract. The relevant code defines a function `setRewardDivisor` that allows only the owner to set the divisor value, fulfilling this requirement directly.",
        "url": 574
    },
    {
        "nl_input": "The query requires functionality to create a new series with a unique name, root hash, and initial count, while ensuring the creator is the owner of a specified nodehash. The series creation must validate ownership, prevent duplicate initialization, and emit an event upon success.",
        "url": 575
    },
    {
        "nl_input": "The query requires a function that returns the number of coins owned by a specific address. The function should take an `address` parameter and return a `uint` value representing the count. The implementation should be constant or view-only, without modifying the contract state.",
        "url": 576
    },
    {
        "nl_input": "The query seeks a function that finalizes a token sale or crowdsale, typically involving actions such as burning remaining tokens, transferring funds, or updating contract states. It likely requires access control (e.g., onlyOwner), checks for sale end conditions, and performs cleanup or distribution tasks.",
        "url": 577
    },
    {
        "nl_input": "The query requires a function that allows the maker to propose an oracle. It should accept parameters for an IPFS hash and a taker address, perform balance checks, deduct fees, and store oracle proposal details. An event should be emitted upon successful proposal, and it must return the index of the newly created proposal.",
        "url": 578
    },
    {
        "nl_input": "The query requires setting a new owner for a proxy contract and removing the old owner. The function should allow ownership transfer, include access control (e.g., `onlyOwner`), and emit an event upon successful change. It may involve updating the owner state variable and delegating ownership transfer to another contract.",
        "url": 579
    },
    {
        "nl_input": "The query describes a system where anyone can donate tokens to a manufacturer's pool. The relevant code defines a function `depositTokens` that allows a user to deposit tokens into a specific manufacturer's pool by providing the `manufacturerId` and `amount`. It ensures valid input, checks if the manufacturer exists, transfers tokens from the donor to the contract, and emits an event upon success.",
        "url": 580
    },
    {
        "nl_input": "The query requires retrieving a user's balance, typically involving a function that accepts a user address and returns their token balance. Some implementations include additional parameters like a target block for historical balance checks.",
        "url": 581
    },
    {
        "nl_input": "The query requires functionality to grant a wallet the permission to freeze tokens. The relevant code defines a function that allows the owner to set a `canFreezeTokens` flag for specified wallets, enabling or disabling their ability to freeze tokens.",
        "url": 582
    },
    {
        "nl_input": "The query requires a function that handles fund transfers to a smart contract, typically triggered when a user or another contract sends funds. It involves transferring funds internally, notifying the receiving contract of the transfer, and returning a success status. The function may include interactions with token contracts and utilize callbacks to ensure proper handling of incoming funds.",
        "url": 583
    },
    {
        "nl_input": "The query describes a function that allows the owner to withdraw unsold tokens after an auction ends. It ensures withdrawal only once the auction time has passed and not all tokens were sold. Tokens are transferred to a recipient address specified in the function.",
        "url": 584
    },
    {
        "nl_input": "The query seeks a function that converts fees to tokens using a calculation involving supply and pledged fees at specific blocks. The function `getFeeToTokenConversion` in the first code snippet fulfills this by calculating new tokens based on contributed amount, previous and initial supply, and total pledged fees at a given block.",
        "url": 585
    },
    {
        "nl_input": "The query requires a function to approve a new borrower, granting them certain permissions. The suitable code defines an `addBorrower` function that sets the approval status of a borrower address to true, accessible only by the owner.",
        "url": 586
    },
    {
        "nl_input": "The query requires a function that retrieves or calculates the current token price, potentially involving logic for different stages, price updates, or time-based conditions.",
        "url": 587
    },
    {
        "nl_input": "The query requires a function that returns the total number of games. The relevant code provides a function `getTotalGames()` which returns the length of the `games` array, indicating the total count of games stored in the contract.",
        "url": 588
    },
    {
        "nl_input": "The query seeks information related to an interface marker within the provided code. Specifically, it references a contract with a function `isCrowdsale()` that returns true, indicating a marker interface pattern used to identify crowdsale contracts in Ethereum-based projects.",
        "url": 589
    },
    {
        "nl_input": "The query requires a getter function for a `paused` contract variable that allows external access to retrieve the current value of the boolean `paused` state variable. The function should be public, constant (view), and return a boolean result.",
        "url": 590
    },
    {
        "nl_input": "The query seeks to determine whether a given key or address is registered in a smart contract. The relevant functions check if a specified address or user has been registered, returning a boolean value (true if registered, false otherwise). These functions are used for access control or membership verification within the contract.",
        "url": 591
    },
    {
        "nl_input": "The query seeks functions related to status management or retrieval in smart contracts. The provided code includes functions for checking sale status, getting action status, and activating an ICO status. These functions involve returning or modifying the state of a contract's status variables, such as `isSaleActive`, `actions[action_id]`, and `status = IcoStatus.Active`. There is a focus on reading status information and updating it in specific cases.\n\n**Description:**  \nThe query requires extracting functions that manage or retrieve contract status variables, including reading or modifying statuses like sale activity, action details, and ICO activation.",
        "url": 592
    },
    {
        "nl_input": "The query requires a function to check a user's REB token balance and return their tier level based on predefined thresholds. The function should take a user address as input, retrieve their current token balance, and classify them into one of several tiers (e.g., Platinum, Gold, Titanium, Free, or \"Possess no REB\") depending on the amount held.",
        "url": 593
    },
    {
        "nl_input": "The query requires a function that creates a new promo team with a specified name and price, assigns it to an address, and handles default values for the owner and price. The function should be accessible only to a COO, include checks for creation limits, and trigger a team creation process.",
        "url": 594
    },
    {
        "nl_input": "The query requires a function that pays the creator upon success, involving checks for completion and payment status, transferring Ether and tokens to the creator, and potentially burning tokens based on certain conditions.",
        "url": 595
    },
    {
        "nl_input": "The query requires overriding the `getRate` function to integrate with a rate provider, allowing dynamic rate retrieval based on sender, sold tokens, and input value.",
        "url": 596
    },
    {
        "nl_input": "The query requires a contract function that moves or transfers funds after a contract ends. The function should be restricted to the owner, execute after contract closure, and transfer the remaining balance to a specified wallet or address.",
        "url": 597
    },
    {
        "nl_input": "The query requires a token-holder to authorize this contract's address using an `approve` function, which allows the contract to spend tokens on the holder's behalf. This typically involves calling `approve(address _spender, uint256 _amount)` where `_spender` is this contract's address and `_amount` is the number of tokens authorized for spending.",
        "url": 598
    },
    {
        "nl_input": "The query seeks to determine the rate in FARM tokens per 1 ETH, based on the transaction time and the FARM pricing mechanism defined in the contracts. It involves extracting logic from multiple contract codes that define rate-setting functions, exchange rates, and dynamic rate adjustments based on certain thresholds or events.",
        "url": 599
    },
    {
        "nl_input": "The query seeks a functionality that allows immediate refunds in a contract. The relevant code includes a `refund()` function that checks refund availability and user balance, then transfers the funds. It emphasizes sender eligibility, balance clearance, and direct Ether transfer. Additional logic includes refund conditions and event logging.",
        "url": 600
    },
    {
        "nl_input": "The query describes a system to manage token purchases at a given price, involving functions that handle buyer validation, token calculation based on funds sent, transferring funds to a beneficiary, updating token balances, and emitting relevant events. The process includes safety checks like non-zero addresses, valid transfers, and sufficient token supply.",
        "url": 601
    },
    {
        "nl_input": "The query requires setting the historical balance for an address owner at specific snapshot indexes within a given range. It involves updating the balance as it existed during those snapshots, using a function that accepts the owner's address, start and end indexes, and the balance value to be set.",
        "url": 602
    },
    {
        "nl_input": "The query requires validating input parameters for changing signature requirement thresholds, ensuring the new required value is not zero and does not exceed the allowed limit based on the given length.",
        "url": 603
    },
    {
        "nl_input": "The query requires a function that retrieves the amount of tokens released for a vesting. The function should take parameters including the token address, granter address, and vester address, and return the number of tokens available. It should be an external constant function, using stored grant data to calculate the released token balance.",
        "url": 604
    },
    {
        "nl_input": "The query requires a function that returns the total supply of tokens in a contract. The function should be publicly accessible, view or constant, and return a uint256 value representing the total supply.",
        "url": 605
    },
    {
        "nl_input": "The query seeks a function that retrieves statistics, as evidenced by the inclusion of functions named `getStats` and `getMonsterStats` in the provided code. These functions return various statistical values related to contributions, supply, and monster attributes. No function is shown that directly matches a \"get some stats\" requirement without further context.",
        "url": 606
    },
    {
        "nl_input": "The query requires a function that resets all user balances to zero and updates certain state variables to `false`. It involves iterating through a list of addresses, resetting each beneficiary's balance and airdrop values, and emitting an event after the operation.",
        "url": 607
    },
    {
        "nl_input": "The query requires a token purchase mechanism that includes anti-money laundering (AML) and know your customer (KYC) checks. The system should verify a user's identity and purchase limits using a digital signature and restrict transactions based on predefined minimum and maximum purchase amounts.",
        "url": 608
    },
    {
        "nl_input": "The query requires a function to set news in a smart contract, specifically allowing the owner to update a news string and emit an event upon successful update.",
        "url": 609
    },
    {
        "nl_input": "The query requires transferring the balance from a sale auction contract to the ZodiacCore contract. The relevant functionality is found in a function that enforces transfers only to the contract itself, handles withdrawal of ETH balance and share pot upon specific token transfers, and restricts token movement between users. It ensures tokens are sent to the contract for processing ETH distribution accordingly.",
        "url": 610
    },
    {
        "nl_input": "The query requires a function that shuts down or removes a contract from the blockchain state. The function should be restricted to specific authorized callers, such as the owner or a designated address, and utilizes the `selfdestruct` mechanism to achieve contract removal.",
        "url": 611
    },
    {
        "nl_input": "The query requires a delete function used to remove or terminate elements within a smart contract, particularly when bugs occur. The function should allow for the removal of contract data or termination of the contract itself. Examples include deleting specific entries from mappings or arrays, resetting values to zero or null, or completely self-destructing the contract. The function must be implemented securely and often includes access control (e.g., owner-only restriction) to prevent unauthorized deletions.",
        "url": 612
    },
    {
        "nl_input": "The query indicates that requesting a certification document by index is a paid feature, requiring users to pay a fee. The code at URL 613 aligns most closely with this requirement, as it specifies that the `getCertificationDocumentAtIndex` function is payable, confirming that accessing certification documents by index involves a payment.",
        "url": 613
    },
    {
        "nl_input": "The query seeks to verify whether an address is recognized as an investor. The relevant functionality is implemented through functions like `isInvestor` and `isInvestorAllowed`, which check if an address exists in a list or mapping of investors, confirming their status.",
        "url": 614
    },
    {
        "nl_input": "The query seeks to retrieve various details about a match and its current state, such as team names, total amounts, participants, win index, match completion status, minimum bet amount, match number, and betting status.",
        "url": 615
    },
    {
        "nl_input": "The query requires a function to transfer tokens to a specified address, where the sender is represented by `tx.origin` instead of `msg.sender`. The function should handle basic transfer logic, including balance checks and emitting a `Transfer` event with the correct parameters.",
        "url": 616
    },
    {
        "nl_input": "The owner can withdraw any accidentally sent ERC20 tokens from the contract, except for the specific token that the contract is designed to handle. This ensures that unintended tokens can be transferred back to the owner while preventing the withdrawal of the main intended token.",
        "url": 617
    },
    {
        "nl_input": "The query requires a function that updates the `startTimestamp` property with a new value `_start`, including validation to ensure `_start` is less than `endTimestamp` and greater than the current time, and emits an event upon successful update.",
        "url": 618
    },
    {
        "nl_input": "The query requires a function to create a new offer by setting a value, involving a payable transaction and validation checks. The function should accept a `setting` parameter, enforce non-zero values for both the payment and the setting, and trigger an internal process to handle the offer creation.",
        "url": 619
    },
    {
        "nl_input": "The query requires transferring the sender's balance to a specified address `_to` with additional data `_data`. The transfer function should handle both regular address and contract transfers, validate sufficient balance, and emit a `Transfer` event with the provided data.",
        "url": 620
    },
    {
        "nl_input": "The query seeks a function to set or update token prices within a smart contract, specifically requiring owner-only access and involving parameters such as buy/sell price, EXH token price, or rate per wei.",
        "url": 621
    },
    {
        "nl_input": "The query requires functionality to add a Kin token vesting grant, enabling token release calculations, tracking of vested and non-vested amounts, and allowing grantees to unlock and transfer vested tokens over time.",
        "url": 622
    },
    {
        "nl_input": "The query requires a function to freeze tokens and lock them to a specific address with a specified release date, preventing the tokens from being transferred until that date. It involves updating balances, managing freezing records, and emitting relevant events.",
        "url": 623
    },
    {
        "nl_input": "The query requires retrieving all relevant information about a specific waifu, such as its name, selling price, and current owner. This functionality is provided by the `getWaifu` function in the contract at URL 624, which returns these details when given a token ID. No other functions or contracts are relevant to this query.",
        "url": 624
    },
    {
        "nl_input": "The query requires a function that assigns a new address to a specific role, such as CEO or admin, with access control (e.g., onlyOwner or onlyCEO modifier), and includes a requirement to ensure the new address is not null.",
        "url": 625
    },
    {
        "nl_input": "The query requires a function that retrieves the released token amount for a specified address. The function should take an address as input and return a `uint256` value representing the released token balance. It should be a `view` function, meaning it does not modify the contract state, and should be accessible publicly.",
        "url": 626
    },
    {
        "nl_input": "The query describes a scenario where a predator attacks and kills animals in a game. The number of animals killed depends on the total number present: up to 10% if less than 100 animals exist, or up to 10 if there are 100 or more. The attack is triggered through a callback function that processes the result of an Oraclize query, selects random animals to kill, calculates gas costs, and distributes rewards if applicable.",
        "url": 627
    },
    {
        "nl_input": "The query requires a function to extend the ICO end date in a smart contract. The suitable code provides a function `setICOEndDate` that sets a new ICO end date, ensuring it has not been previously set.",
        "url": 628
    },
    {
        "nl_input": "The query requires a function that allows a pre-approved user to claim ownership of a specific item (e.g., color, product, or unicorn) by verifying their approval status and transferring ownership accordingly. The function should ensure that only the approved address can take ownership and should handle the transfer securely.",
        "url": 629
    },
    {
        "nl_input": "The query describes a function that sends pooled Ether to a receiving address, determines the amount of unused Ether to return, and progresses the contract to stage two. The matching code should handle Ether transfer, refund calculation, and contract state advancement.",
        "url": 630
    },
    {
        "nl_input": "The query requires a function that retrieves connection details between two entities in a smart contract system. It specifically seeks a method returning a tuple with fields like entity active status, connection active status, data, direction, and expiration. The function takes parameters such as entity addresses and a connection type. The relevant code defines this structure within a contract's `getConnection` function.",
        "url": 631
    },
    {
        "nl_input": "The query seeks a contract mechanism that allows certain functions to be executed only when an agreement or state is **not locked**. This involves a modifier checking a `locked` condition, ensuring operations can proceed only if `locked` is false. The implementation typically uses a `require(!locked)` check within a modifier or function.",
        "url": 632
    },
    {
        "nl_input": "The query checks whether a given sequence can be represented in the form of `4815162342 * 10^i` for some non-negative integer `i`. It involves validating if the sequence matches this mathematical pattern at any power-of-ten scaling.",
        "url": 633
    },
    {
        "nl_input": "The query requires calculating a fee from the losing portion of a total pot. The fee is determined as a percentage of the remaining amount after subtracting the winners' pot from the total pot. Additionally, the fee calculation involves safe mathematical operations to prevent overflow and ensure accuracy.",
        "url": 634
    },
    {
        "nl_input": "The query requires functionality to update network constants, such as price or inflation rate, with access control and time-based restrictions. It implies the need for a function that allows only authorized users to make changes under certain conditions.",
        "url": 635
    },
    {
        "nl_input": "The query requires a function to perform the initial token allocation between founders' addresses, which should be executed only once after contract deployment. The function must ensure that the allocation is done manually, prevents re-execution, and transfers tokens to predefined addresses such as founders, support, and bounty addresses.",
        "url": 636
    },
    {
        "nl_input": "The query requires a function that creates and stores a new promise object while updating the `promisedTokenBalance`. The relevant code should involve creating a promise with details like `recipient`, `amount`, `lockedUntil`, and updating the total promised balance.",
        "url": 637
    },
    {
        "nl_input": "The query requires a function to transfer tokens from an allowance, where the sender must have sufficient approved allowance to transfer on behalf of the owner. The function should deduct the transferred amount from the allowance and perform the token transfer.",
        "url": 638
    },
    {
        "nl_input": "The query requires a function to batch transfer a specified value to multiple receivers, with support for transferring the same amount of ETH or tokens to each receiver. It emphasizes handling multiple addresses efficiently in a single call, typically used for distributing funds or freezing accounts.",
        "url": 639
    },
    {
        "nl_input": "The query requires a description of the total supply function for a token. The relevant information from the provided code snippets indicates that this function returns the total supply of tokens in different implementations, using variables like `totalSupply`, `numTokens`, and `_totalSupply`. All functions are either constant or view, ensuring no state changes during execution.",
        "url": 640
    },
    {
        "nl_input": "The query requires a function to manually start a crowdsale, callable only by the owner. It should allow starting the sale before a specified start date and may involve setting or updating start and end blocks for multiple phases of the crowdsale.",
        "url": 641
    },
    {
        "nl_input": "The query requires functionality to remove or delete a contract, either by deactivating it from a list of active contracts, completely destroying the contract, or removing associated data. The solution should support operations like address removal, contract self-destruction, or data nullification.",
        "url": 642
    },
    {
        "nl_input": "The query requires a function that allows the owner to change the `coldwallet2` address. The function should include access control (`onlyOwner`), input validation to ensure the new address is not zero, and update the stored wallet address.",
        "url": 643
    },
    {
        "nl_input": "The query requirement is to implement a \"Pay with Mileage\" functionality, where users can pay using mileage points. The function should validate the sender, check the mileage balance, and allow purchasing of bundles (1\u20135), each yielding a randomly generated hero rank based on probability ranges.",
        "url": 644
    },
    {
        "nl_input": "The query requires a function to approve a proxy for token transfers, enabling a user to authorize another address to spend tokens on their behalf. The function should handle the approval process, update the allowance, and emit an approval event.",
        "url": 645
    },
    {
        "nl_input": "The query checks whether a given zodiac is ready to breed. According to the code, a zodiac is ready to breed if it is not already siring (`siringWithId == 0`) and its cooldown period has ended (`cooldownEndBlock <= current block number`).",
        "url": 646
    },
    {
        "nl_input": "The query describes a function to deposit funds, typically involving a payable function that updates user balances and emits a deposit event. The ideal implementation includes validation (e.g., whitelisting or state checks), updating token or wallet balances, and logging the deposit with relevant details like sender, amount, and updated balance.",
        "url": 647
    },
    {
        "nl_input": "The query requires a method that allows anyone to withdraw funds to a coindrops wallet after a locking period has ended. The method should check that the current time is past the lock period and that the withdrawal status is not already triggered. Upon successful validation, the funds should be transferred to the designated wallet, and the status should be updated accordingly.",
        "url": 648
    },
    {
        "nl_input": "The query requires a function that returns a newly allocated string formed by concatenating two input strings, `self` and `other`. The function should perform memory copying operations to combine the contents of both inputs into a new string with no overlap.",
        "url": 649
    },
    {
        "nl_input": "The query requires a function to execute a multi-signature transaction from a wallet using two signers: one being `msg.sender` and the other recovered via `ecrecover`. The transaction must include `toAddress`, `value`, `data`, `expireTime`, `sequenceId`, and a `signature`. It also implies the need for replay protection through incrementing sequence IDs and verification of the operation hash.",
        "url": 650
    },
    {
        "nl_input": "The query seeks functionality related to issuing unlocked tokens. The relevant code provides a method `issueTokens` that allows an admin to issue unlocked tokens to a specified address by calling `issueTokensWithLocking` with zero lock parameters.",
        "url": 651
    },
    {
        "nl_input": "The query requires a function to add or contribute dividends, where users can send funds to increase the dividend pool. The function should update the total dividend amount and potentially calculate shares or trigger events accordingly.",
        "url": 652
    },
    {
        "nl_input": "The query requires a function to disable the whitelist state in a smart contract. The relevant code provides a `disableWhitelist()` function that sets `whitelistEnable` to `false`, emits a corresponding event, and returns the updated state. It is accessible only to the contract owner.",
        "url": 653
    },
    {
        "nl_input": "The query requires a function that can only be executed after a presale has concluded. It implies a need to check the presale status and perform actions, such as finalization, once it is confirmed that the presale has ended.",
        "url": 654
    },
    {
        "nl_input": "The query requires a function to cancel an outstanding multisig call, where the caller must be an authorized master key. The function should handle cases where there is no pending call to cancel and emit appropriate events upon successful cancellation.",
        "url": 655
    },
    {
        "nl_input": "The query requires a function that allows the owner to reclaim or withdraw all Ether held by the contract, including any fees, with the transferred amount going to a specified beneficiary or the owner directly.",
        "url": 656
    },
    {
        "nl_input": "The query seeks public functions named \"give\" and \"take\" that can only be executed by the contract owner. These functions should facilitate transferring value or ownership, with \"give\" likely handling token transfers and \"take\" possibly reclaiming ownership or assets. Only owner-restricted methods are relevant.",
        "url": 657
    },
    {
        "nl_input": "The query requires a function that issues tokens to a beneficiary, specifically transferring tokens from the `ethFundDeposit` to a user. The function should handle internal token transfers, update balances, and potentially interact with a deposit system.",
        "url": 658
    },
    {
        "nl_input": "The query requires a token sale mechanism that is only active within a specified time window, enforces purchase limits, and adjusts token pricing based on the number of tokens sold. It involves transferring funds, updating balances, and emitting events upon successful purchase.",
        "url": 659
    },
    {
        "nl_input": "The query requires identifying functions that perform addition operations within smart contracts. The relevant functions include: `add` which appends a value to a set, `add_reward` which increases a reward by a payable amount, and `safeAdd` which performs overflow-checked addition. These functions address different aspects of adding values in the context of blockchain smart contracts.",
        "url": 660
    },
    {
        "nl_input": "The query describes a functionality that allows the factory owner to withdraw any ERC20 tokens from the contract. The code snippets provided implement this functionality with varying naming conventions and minor differences in implementation details, such as using `onlyOwner`, `safeTransfer`, or direct transfer methods. All three contracts enable the owner to withdraw or transfer out ERC20 tokens accidentally sent to the contract.\n\n**Requirement Description (within 80 words):**  \nAllow the factory owner to withdraw any ERC20 token from the contract, ensuring ownership control and safe token transfer functionality.",
        "url": 661
    },
    {
        "nl_input": "The query requires a mechanism to seal or finalize a Crowdsale once it has ended. The code should include a function that performs finalization tasks, such as transferring funds, enabling refunds, or minting tokens, and ensures the Crowdsale cannot be altered afterward by setting a finalization status.",
        "url": 662
    },
    {
        "nl_input": "The query seeks to retrieve the total supply of tokens in a smart contract. The required functionality is implemented in all three provided code snippets, where each defines a `totalSupply` function that returns the current total token supply as a `uint` or `uint256` value.",
        "url": 663
    },
    {
        "nl_input": "The query requirement is to allow the requester to cancel their adoption request. The function should enable the requester to cancel a previously made adoption request, refund the price paid, and update the request status accordingly.",
        "url": 664
    },
    {
        "nl_input": "The query requires an internal function that allows the Payer to create, accept, and add additional amounts to a request. It involves validating the payer, extracting and verifying payee details, calculating expected amounts, collecting fees, and updating request data with the payer's address. It also includes handling Bitcoin addresses for payment and refund, returning the request ID upon success.",
        "url": 665
    },
    {
        "nl_input": "The function `tokensAmount` calculates the number of tokens a sender is purchasing based on the amount of wei sent, taking into account various sale stages, discounts, caps, and user-specific conditions like private or public events and membership status.",
        "url": 666
    },
    {
        "nl_input": "The query highlights challenges with variable-length arrays in Solidity, particularly when returning such arrays from functions. It references three code examples: one validating string length, another concatenating strings using low-level memory operations, and a third returning the length of a dynamic array. The core need is understanding how to effectively handle variable-length data structures, especially regarding memory management and function return behaviors.",
        "url": 667
    },
    {
        "nl_input": "The query requires setting up a token sale smart contract that allows the owner to configure key parameters such as the token address, start date, and sale duration. It should include functionality to validate token supply and ownership, set sale stages, and transition to a ready state after setup. Additionally, it may involve defining token pricing logic, purchase limits, and fund management during the sale process.",
        "url": 668
    },
    {
        "nl_input": "The query requires a function that can be called by the owner to lock functionality within a smart contract. The function must ensure that only the owner can trigger it, and it should set a locking state (e.g., a `locked` flag), optionally emitting an event upon locking. The ideal implementation includes a check to prevent re-locking after unlocking, ensuring secure and controlled access.",
        "url": 669
    },
    {
        "nl_input": "The query requires a function to create a company with parameters including name, owner, and price. The function should handle company data initialization, store the company, assign shares to the owner, and emit an event upon successful creation. Additionally, it enforces conditions such as price divisibility by 100 and valid company ID indexing.",
        "url": 670
    },
    {
        "nl_input": "Set the cooldown end time for a Dog based on its current cooldown index, using a formula that incorporates block number and cooldown duration.",
        "url": 671
    },
    {
        "nl_input": "The query seeks functions related to update operations in smart contracts, such as updating addresses, amounts, or parameters like minimum contribution. These functions often involve access control (e.g., only editors or management), emit events upon execution, and may include validation checks.",
        "url": 672
    },
    {
        "nl_input": "The query requires a function that handles the distribution of buyout proceeds. The function should send funds to the current owner or allocate part of the winnings to the prize pool if no owner exists, distribute dividends to beneficiaries, apply referral bonuses, and ensure leftover fees are added to the prize pool. It must also update the prize pool balance accordingly.",
        "url": 673
    },
    {
        "nl_input": "The query requires retrieving the RDN price in WEI at the time of function call during an auction. The suitable code should return the current bid or calculated price dynamically based on auction rules. None of the provided codes fully meet this requirement, as they handle region bids, price adjustments, or fixed-stage pricing without directly reflecting the auction\u2019s real-time RDN price in WEI.",
        "url": 674
    },
    {
        "nl_input": "The query requires a function that allows the transaction creator to approve a specified amount of tokens to be sent to a recipient. The function should set the allowance for the recipient to the specified amount and emit an approval event.",
        "url": 675
    },
    {
        "nl_input": "The query requires a modifier that ensures a function can only be executed if the crowdsale is currently running. It checks whether the current state is either PreFunding or Funding, and halts execution otherwise.",
        "url": 676
    },
    {
        "nl_input": "The query requires identifying functions in the provided smart contract code that are used to set or update an address of a dependent contract or manager, with a focus on access control and validation checks such as ensuring the new address is not zero.",
        "url": 677
    },
    {
        "nl_input": "The query requires locking the DAICO supply until a specific date and time (2018-09-01 14:00:00). The lock should be enforceable by the owner, apply to a specific address or overall supply, and potentially allow configuration of the lock period with restrictions.",
        "url": 678
    },
    {
        "nl_input": "The query requires functionality to adjust the gas reimbursement for token transfers when the sender's account balance is below a minimum threshold, particularly in response to gas price changes. It involves modifying or setting a gas value in a smart contract, with restrictions on the gas amount and conditions for execution.",
        "url": 679
    },
    {
        "nl_input": "The query describes a scenario where a token transfer occurs during an ICO. The relevant code should involve a function that allows the transfer of tokens from one address to another, specifically in the context of an ICO. It may include checks related to ICO state, sender validation, balance adjustments, and emitting a transfer event.",
        "url": 680
    },
    {
        "nl_input": "The query requires a function that transfers tokens from one address to another, specifically handling the deduction from the sender's balance, addition to the receiver's balance, and emitting a transfer event. The function should return a boolean indicating success.",
        "url": 681
    },
    {
        "nl_input": "The query requires a function that accepts Ether from a user and exchanges it for tokens on their behalf, using `msg.value` to determine the amount of Ether sent. The function should calculate the corresponding token amount based on a rate, issue those tokens to the beneficiary/buyer, and forward the received Ether to a designated wallet or beneficiary.",
        "url": 682
    },
    {
        "nl_input": "The query requires determining whether a given account is allowed to buy tokens. The relevant code should check for conditions such as whether the account is frozen, if the purchase value is valid, and if the buyer is authorized. Specifically, it should include checks like `require(!frozenAccount[msg.sender])`, `require(msg.value > 0)`, and similar validations to ensure a legitimate token purchase.",
        "url": 683
    },
    {
        "nl_input": "The query requires a function that checks whether a specified project has been canceled. The function should take a project ID as input and return a boolean value indicating the cancellation status. It may involve checking stored data, handling inheritance through parent projects, and ensuring proper access to administrative types.",
        "url": 684
    },
    {
        "nl_input": "The query checks whether the market maker contract has a mechanism to verify if it is open for public participation, specifically looking for a function or modifier that enforces this condition.",
        "url": 685
    },
    {
        "nl_input": "The query requires a function that updates a value in a sequence, specifically at the next snapshot. It involves checking the current snapshot ID, comparing it with the last entry, and either adding a new snapshot or modifying an existing one to ensure accurate tracking of changes over time.",
        "url": 686
    },
    {
        "nl_input": "The query describes a `proxyPayment` function that allows a caller to send Ether to a Campaign and have CampaignTokens created in a specified address. It requires identifying code that enables a proxy to facilitate payments and allocate tokens to a chosen receiver.\n\nBased on the provided code:\n\n- **Functionality Required**:\n  - A payable `proxyPayment` function.\n  - Accepts Ether and creates tokens for a specified address.\n  - May involve checks like contribution limits, campaign dates, and token allocation logic.\n  - Optionally logs events like token purchase and transfers funds to a wallet.\n\n**Best Matching Code**: The third contract (url: 682) provides a full implementation of `proxyPayment`, including date-based token rates, cap enforcement, balance updates, and fund transfer to a wallet.\n\n**Description of Query Requirements** (within 80 words):\n\nA payable function that forwards Ether to a campaign and mints corresponding tokens for a specified participant, including validations like time window, contribution limits, and dynamic token rate calculation, with event logging and fund forwarding to a wallet.",
        "url": 687
    },
    {
        "nl_input": "The query requires determining whether a specified promise can be collected by the recipient. The relevant condition is that the promise's state must be either \"confirmed\" or \"pending,\" and the current timestamp must be greater than or equal to the promise's `lockedUntil` time.",
        "url": 688
    },
    {
        "nl_input": "The query requires identifying conditions or functions that control the start of a crowdsale or contribution period in smart contracts. Specifically, it looks for logic that enforces a start time or block number, such as modifiers, functions, or boolean checks that determine whether the sale has begun.",
        "url": 689
    },
    {
        "nl_input": "The query requires a function that allows an admin to finalize a sale, complete token allocations, and potentially handle actions such as transferring funds or enabling refunds after finalization.",
        "url": 690
    },
    {
        "nl_input": "The query requires a function to withdraw tokens, typically restricted to specific conditions such as after a crowdsale ends or by a designated address like the owner or beneficiary. It involves transferring tokens from the contract to an external account, often with safety checks and event logging.",
        "url": 691
    },
    {
        "nl_input": "The query describes a scenario where someone purchases tokens on behalf of a benefactor. The payment is forwarded to a multisig wallet, and events are logged to track investments. The purchased tokens are added to the benefactor's account, and the transaction must be processed with checks for valid input and proper fund distribution.",
        "url": 692
    },
    {
        "nl_input": "The query seeks a description of the function that prepares compression data and triggers an event for buy or reload transactions. The relevant code handles timestamp and team encoding into compressed data, emits an event with transaction details, and is tied to player and reward identifiers.",
        "url": 693
    },
    {
        "nl_input": "The query requires functionality to permanently stop or decline token minting, such as finishing minting, setting a stop date, or reducing mintable tokens to zero. The desired contract should allow only the owner to execute these actions and emit appropriate events.",
        "url": 694
    },
    {
        "nl_input": "The query requires a function to add a bonus to a block, involving parameters x, y, and bonus, and utilizing a key derived from x and y. The operation should be restricted to a primary role and involve setting a bonus value in storage.",
        "url": 695
    },
    {
        "nl_input": "The query seeks a function that allows the owner to set or update a rate, typically for converting tokens (e.g., TCR to ETH or token price rate). The function should be publicly accessible, restricted to the owner, and may include validation such as requiring the rate to be within a specified range or greater than zero.",
        "url": 696
    },
    {
        "nl_input": "The query requires a function that calculates and returns the remaining releasing period for a specified account in a token vesting or freezing system. It involves checking time records associated with the account and determining the time left until the next release, based on current time and predefined release periods.",
        "url": 697
    },
    {
        "nl_input": "The query requires a function to payout or transfer tokens to a user, likely involving balance checks and emitting events upon successful transfer.",
        "url": 698
    },
    {
        "nl_input": "The query requires transferring token ownership after a token sale is completed. The code should allow the current owner to transfer ownership to a new address, ensuring the new owner is valid and updating relevant token ownership records.",
        "url": 699
    },
    {
        "nl_input": "The query describes a scenario where the owner can change the revoke address, and it involves a function that updates the revoke address with access control checks.",
        "url": 700
    },
    {
        "nl_input": "The query requires an admin function to change the bankroll address in a smart contract. The relevant code provides a function `setBankroll(address bankrollAddress)` that allows setting a new bankroll address, restricted to specific roles.",
        "url": 701
    },
    {
        "nl_input": "The query seeks to determine whether a function named `isPreSale` exists in the provided code snippets. The relevant information shows that one contract includes a function named `isPreSale` which checks and returns a boolean indicating if the presale is active based on time and an enable flag.",
        "url": 702
    },
    {
        "nl_input": "The query requirement is to find a code snippet where the Director has the ability to open a contribution. The relevant code shows a function `openSale()` that is restricted to the Director, sets `saleClosed` to false, and returns true upon success.",
        "url": 703
    },
    {
        "nl_input": "The query requires a function that clones a token at a specified snapshot block, allowing for the transfer of control to a specified address. It must return the cloned token's address and emit an event upon creation.",
        "url": 704
    },
    {
        "nl_input": "The query requires a contract feature that allows for self-destruction and transferring funds to the owner. The implementation should include a function accessible only by the owner, check for a time condition before self-destructing, transfer any token balance to the owner, and ensure the contract can be destroyed safely.",
        "url": 705
    },
    {
        "nl_input": "The query requires a function that allows claiming tokens from an economic reserve wallet under specific vesting conditions, including checks for time locks, claimed amounts, and token transfers. It involves calculating unlocked amounts based on vesting stages and updating claim status accordingly.",
        "url": 706
    },
    {
        "nl_input": "The query requires a function that transfers the raised amount to a company address. The function should ensure the transfer occurs only under specific conditions, such as the end of a stage, and should handle potential failures in the transfer process.",
        "url": 707
    },
    {
        "nl_input": "The query requires a helper function that calculates the valuation of an asset in terms of ART token quantity, based on user input such as ether amount. The function should return the corresponding token amount using predefined rates, possibly varying by tier or dynamic calculation involving exchange rates.",
        "url": 708
    },
    {
        "nl_input": "The query requires a function that retrieves data based on an identifier (`id` or `_id`), specifically fetching and returning associated values such as `id` and `owner`. The function should be constant (view-only) and ideally return multiple relevant fields.",
        "url": 709
    },
    {
        "nl_input": "The query requires counting the number of ELHTs (likely \"games\" or \"matches\") tracked by a contract. The relevant functions from the provided code include `getNumMatches()` and `getTotalGames()`, which return the count of matches or games, respectively. No direct reference to ELHTs is found, but these functions align with the query's intent.",
        "url": 710
    },
    {
        "nl_input": "When a user visits for the first time, they should be initiated with default resources (5 units each of 5 types) and placed at map coordinates (6,6). The initiation ensures they are marked as initialized and contributes to an increase in total cities.",
        "url": 711
    },
    {
        "nl_input": "Users can swap old proxy tokens for new tokens at a 1:2 ratio using the `swapProxyTokens` function in contract `c24886`. The function retrieves the sender's old token balance, transfers it to a designated owner, and distributes twice the amount in new tokens to the user.",
        "url": 712
    },
    {
        "nl_input": "The query describes a process of buying tokens from sellers. The relevant code shows that the function `_buyTokensFromSeller` handles purchasing tokens by iterating through seller addresses, deducting sold tokens, transferring payment to sellers, and updating token balances. It also accounts for commission and ensures fair transactions. \n\n**Description:**  \nBuys a specified number of tokens from multiple sellers, transfers payment to each seller, updates token balances, and accounts for transaction commission while ensuring no self-purchase and handling potential transfer errors.",
        "url": 713
    },
    {
        "nl_input": "The query requires a function that calculates the token amount based on the provided wei value and exchange rate, considering different rate tiers for varying input amounts. It involves handling Ethereum decimal precision (18 zeros) and potentially returning different token amounts based on the investment tier.",
        "url": 714
    },
    {
        "nl_input": "The query requires a function that allows removing an admin. The function should verify the sender's authority, ensure the target address is valid and currently an admin, prevent self-removal, and successfully remove the admin status. It should return a boolean indicating success and emit an event upon removal.",
        "url": 715
    },
    {
        "nl_input": "The query requires a function that verifies or checks whether an address is registered or valid. The desired functionality includes returning a boolean value (`true` or `false`) based on the verification status of a given address, potentially involving access control or record checks.",
        "url": 716
    },
    {
        "nl_input": "The query requires a modifier in a smart contract that restricts function execution to the owner only. It checks if the message sender is the owner, reverting the transaction if not. This pattern is implemented across multiple contracts using different syntax variations but with the same core logic.",
        "url": 717
    },
    {
        "nl_input": "The query seeks to retrieve the total number of tokens in existence. The relevant information is obtained from functions named `totalSupply()` across different contracts, which return values such as `totalSupply_`, `totalSupply`, and `numTokens`. These functions provide the total token supply as a `uint256` or `uint` value.",
        "url": 718
    },
    {
        "nl_input": "The query requires a function that retrieves the type of a token (either long or short) based on a provided token address, returning a value that distinguishes between the two types (e.g., 1 for short and 2 for long).",
        "url": 719
    },
    {
        "nl_input": "The query requires a function that verifies whether a specified owner holds at least a given number of shares in a company. The function should take parameters for the company ID, the owner's address, and the required share amount, and should revert if the condition is not met.",
        "url": 720
    },
    {
        "nl_input": "The query requires a function or mechanism to check whether an ICO is currently active. It involves evaluating time-based conditions to determine if the current timestamp falls within the predefined ICO start and end times.",
        "url": 721
    },
    {
        "nl_input": "The query seeks to determine whether a token burning process was executed successfully. The relevant code should involve functions that perform token burning, include success checks, and potentially update supply values upon successful execution.",
        "url": 722
    },
    {
        "nl_input": "The query requirement is to find a function within a smart contract that allows a decentralized application (\u0110App) to accept Bitcoin transfers. The function should handle the reception of Bitcoin and potentially trigger an investment or record-keeping action within the contract.",
        "url": 723
    },
    {
        "nl_input": "The query seeks to determine the number of tokens that have vested. The relevant code calculates vested tokens based on elapsed time, total vesting duration, and total vesting amount, returning the proportionally vested amount.",
        "url": 724
    },
    {
        "nl_input": "The query requires a function to calculate token amount based on wei, using an exchange rate. It implies handling different rate tiers and converting the result to the appropriate decimal precision (18 zeros for ETH, 2 for NVT). The calculation should use multiplication followed by division to maintain precision, and may involve safe math operations to prevent overflow.",
        "url": 725
    },
    {
        "nl_input": "The query requires a function that checks if an order is expired, throwing an error if it is. The function should compare the current time with the expiration time plus a delay and revert when the condition is not met.",
        "url": 726
    },
    {
        "nl_input": "The query requires a function that allows users to claim back their Ether if their token purchase request is rejected. The function should check if the user has a non-zero rejected mint balance, transfer the corresponding Ether back to the user, and emit an event to log the claim.",
        "url": 727
    },
    {
        "nl_input": "The query requires a function to transfer tokens between addresses, involving adjustments to balances and emitting a transfer event. The function should handle token transfers within a contract that maintains per-token balances and allowances, ensuring the sender has sufficient funds.",
        "url": 728
    },
    {
        "nl_input": "The query seeks an internal function for handling Ether transactions, specifically focusing on functions that allow withdrawal of Ether from a contract. The function should include features like balance checks, transferring Ether to an address, and potentially dividing the transfer among multiple addresses. Security aspects like access restriction (e.g., `onlyOwner`) and safe Ether transfers are also relevant.",
        "url": 729
    },
    {
        "nl_input": "The query requires a function that transfers ERC20 tokens, adhering to the standard transfer mechanism, and is wrapped with an `activated` modifier for additional control.",
        "url": 730
    },
    {
        "nl_input": "The query requires calculating the result of multiplying two numbers `x` and `y`, then dividing the product by 2^128. The calculation should handle large integers accurately, using fixed-point arithmetic to avoid overflow and maintain precision. Additionally, it needs to ensure safe mathematical operations and proper bit manipulation.",
        "url": 731
    },
    {
        "nl_input": "The query describes a post-ICO process where, after sale closure and meeting minimum token sales, 10% of funds are initially allocated to the company for operating expenses, with the remaining 90% intended for distribution. The function `icoCheckup()` in the first code aligns with this logic, handling staged remuneration and fund transfers based on ICO status and conditions.",
        "url": 732
    },
    {
        "nl_input": "The query requires a function that can be used by derived contracts to permanently disable or nullify the contract functionality, ideally through a mechanism like sealing, self-destruction, or setting a disabled state. The function should be restricted to authorized callers such as the owner or a designated address, ensuring it cannot be reversed once executed.",
        "url": 733
    },
    {
        "nl_input": "The query requires setting the IPFS hash of an image representing a couple. The relevant code should allow storing or updating an IPFS image hash, ideally with an event to log the action.",
        "url": 734
    },
    {
        "nl_input": "The query requires functionality for finalizing a funding process, where funds are either executed (sent to a destination) if the funding goal is met or refunded if the goal is not reached. The code should handle conditions such as checking the funding status, closing or enabling refunds in a vault, and ensuring proper timing and validations before executing the finalization logic.",
        "url": 735
    },
    {
        "nl_input": "The query requires a functionality that allows the owner to control the start and stop of trading within a smart contract. The most relevant code provides a function where the owner can toggle a boolean value to start or stop trading. Other codes referenced are for opening trading with admin rights and starting a crowdsale, which are less aligned with the core requirement of owner-controlled trading toggling.",
        "url": 736
    },
    {
        "nl_input": "The query requires functionality to update and tweak game-related parameters in a smart contract, such as modifying game settings, updating addresses, and retrieving game data. It involves operations like validating active games, updating configuration values, and fetching total game count.",
        "url": 737
    },
    {
        "nl_input": "The query describes a system that allows users to buy outcome tokens from a market maker. Users specify the outcome token index, the number of tokens to buy, and the maximum cost they are willing to pay. The system calculates the cost and fees, transfers collateral tokens from the user, and delivers the purchased outcome tokens.",
        "url": 738
    },
    {
        "nl_input": "This query refers to a function that allows users to withdraw deposits and bonuses during stage three, based on specified dates. The function processes an array of dates, checks withdrawal eligibility, updates user status, and transfers the calculated amount to the user.",
        "url": 739
    },
    {
        "nl_input": "The query requires a mechanism that allows smart contracts (SCs) to upgrade themselves even after being locked down. It emphasizes self-upgrade functionality that remains operational post-lockdown, indicating the need for flexibility in contract management despite restrictive measures like locking.",
        "url": 740
    },
    {
        "nl_input": "The query requires a function to update or modify the whitelist in a smart contract. The desired functionality includes changing the whitelist address or adding/removing addresses from the whitelist, accessible typically through owner or operator-restricted functions.",
        "url": 741
    },
    {
        "nl_input": "The query requires a function that allows the contract to transfer tokens it owns to another address. The function should handle transferring a specified value of tokens, ensure valid transfers, and emit an event reflecting the transfer. It should be callable by the owner or as part of an internal process, and must update balances accordingly.",
        "url": 742
    },
    {
        "nl_input": "The query requires a function to transfer tokens from one address to another on behalf of a third party, involving parameters `_from`, `_to`, and `_value`, and ensuring proper allowance and balance adjustments.",
        "url": 743
    },
    {
        "nl_input": "The query seeks to determine how many tokens can be obtained for a given amount of wei, with the calculation potentially involving a discount. The relevant function should accept the wei value and possibly a discount rate, then return the corresponding token amount based on a pricing formula.",
        "url": 744
    },
    {
        "nl_input": "The query requires a function that returns the composition price of a specific token ID. The function should take a `uint256` token ID as input and return the corresponding composition price, which is retrieved based on the provided token ID.",
        "url": 745
    },
    {
        "nl_input": "The query seeks a function that enables trading for all users, typically called once to allow public participation. The ideal function is accessible externally, possibly restricted to an admin or owner, and sets a state variable to indicate trading is open.",
        "url": 746
    },
    {
        "nl_input": "The query requires a functionality where requesting confirmation that a document is a certification is a paid feature, implying that users must pay a fee to access this verification.",
        "url": 747
    },
    {
        "nl_input": "The query seeks to determine whether a pre-sale or sale functionality is enabled within the provided smart contract code. It focuses on identifying conditions, variables, or functions that control the activation of a sale or pre-sale phase, such as flags like `enablePreSale`, time-based checks, or account-specific sale status.",
        "url": 748
    },
    {
        "nl_input": "The query requires a function that allows refunding ETH to specified destination addresses. The function should accept multiple addresses and corresponding refund amounts, ensuring equal array lengths, and transfer the specified amounts to each address.",
        "url": 749
    },
    {
        "nl_input": "The query requires a function that can change or trigger a state related to the release of tokens, specifically ensuring that certain actions can only occur before or after the token release. It implies a need for a modifier or function that enforces a condition based on whether tokens are released or not.",
        "url": 750
    },
    {
        "nl_input": "The query requires a function that returns the number of signers for any given function. Among the provided codes, none directly fulfill this requirement as written, but the most relevant logic appears in the first contract where `activeSignersCount` tracks the number of signers added. This value is not tied to a specific function, however, it represents the total number of signers in the contract.",
        "url": 751
    },
    {
        "nl_input": "The query is asking whether there is a token address in the provided code. Based on the response requirements, the focus is on identifying if the code includes mechanisms to set or validate a token address.\n\n**Description of query's needs (within 80 words):**  \nThe query seeks to determine if the provided code contains logic for setting or validating a token address, such as functions or modifiers that handle or enforce the presence of a token address.",
        "url": 752
    },
    {
        "nl_input": "The query describes a process to purchase tokens from a reserve. The code shows three different implementations of token purchase functions in smart contracts. Each function accepts Ether, calculates the corresponding amount of tokens based on a price or rate, updates balances, and transfers tokens and funds accordingly.",
        "url": 753
    },
    {
        "nl_input": "The query requires a function to update statistics for a token, specifically taking a token ID and an array of stats as input. It should modify the stats associated with that token. The function must be accessible publicly, include validation for the token, and restrict access to granted contracts. Additionally, it updates values within a mapping or storage structure tied to token assets.",
        "url": 754
    },
    {
        "nl_input": "The query requires a function that returns the total count of \"dicks\" recorded in the contract. The relevant code provides a function `howManyDicks()` that returns the length of the `biggestDicks` array, indicating the number of dicks there have been.",
        "url": 755
    },
    {
        "nl_input": "The query focuses on the emission or creation of a WorkOrder in a smart contract system. It involves a function that allows a requester to generate a WorkOrder by interacting with a marketplace and a WorkerPool, ensuring proper cost calculation and event emission. Key aspects include validating market order consumption, locking costs, deploying a new WorkOrder contract, registering it, and emitting a confirmation event. The process requires external interaction with multiple contracts and ensures traceability and correctness through require statements and event logging.",
        "url": 756
    },
    {
        "nl_input": "The query requires a function that creates a CDP using all Dai in the sender's balance (after approval), then continuously mints and reinvests Dai into the CDP until either the target liquidation price or a minimum investment threshold is met.",
        "url": 757
    },
    {
        "nl_input": "The query requires a function that overrides the `_processPurchase` method from `Crowdsale`, adding purchased tokens to the beneficiary's balance. The function should take `_beneficiary` and `_tokenAmount` as parameters, use an internal method to calculate the token amount, and update the deposited tokens mapping for the beneficiary.",
        "url": 758
    },
    {
        "nl_input": "The query requires a function that calculates a fee charged on top of a value being sent. The function should take a value as input, apply a fee rate to it, and return the resulting fee. Additionally, there is a suggestion that transfers below a certain threshold may be subject to special handling, potentially consuming the entire value as fee.",
        "url": 759
    },
    {
        "nl_input": "The query requires a function that loads the ETH balances of all accounts, returning both an array of individual balances and the total sum. The implementation should iterate through a list of account addresses, retrieve each account's ETH balance, and calculate the total balance. It should return these values in a view function without modifying the contract state.",
        "url": 760
    },
    {
        "nl_input": "The query requires checking whether a specific amount of an asset or currency has been approved in the Oversight address, ensuring that spending is authorized through a validation mechanism.",
        "url": 761
    },
    {
        "nl_input": "The query requires a function to distribute or calculate tokens for investors, ideally with mechanisms to ensure correct allocation and support for pre-crowdsale purchases. The function should be callable by the owner, include validation checks, and emit relevant events. It may also involve rate calculation based on ether investment.",
        "url": 762
    },
    {
        "nl_input": "The query describes a function that processes a list of transfers and performs checks while deconstructing a combined input (amount and receiving address) to optimize gas usage and reduce unnecessary zeros stored on the blockchain. It involves internal handling of token transfers, validation of addresses, and efficient data manipulation for blockchain storage.",
        "url": 763
    },
    {
        "nl_input": "The query seeks a function that allocates or assigns tokens to a specified address, potentially involving parameters like address, amount, and other optional tracking identifiers. It appears related to token distribution logic in a smart contract, focusing on functions that handle internal allocations, track customer payments, or enforce constraints like pausing and ownership.",
        "url": 764
    },
    {
        "nl_input": "The query requires extracting the amount of tokens approved for transfer from a contract. Among the provided code options, only one contract (`c9848`) contains an `approve` function that sets and returns the number of tokens allowed for transfer by a spender. The approved token amount is stored in the `allowed` mapping and emitted via the `Approval` event. This function matches the requirement of determining the approved token amount for transfers. \n\n**Description (within 80 words):**  \nThe query seeks to determine the amount of tokens approved for transfer in a contract. The relevant function `approve` in contract `c9848` allows setting and retrieving the approved token amount for a spender, fulfilling the requirement.",
        "url": 765
    },
    {
        "nl_input": "The query requires an event handler that processes a token received event, specifically triggered when a token amount is received on the contract's address. It should log or track details such as the token contract, sender, and value received, ensuring proper validation and internal handling of the event.",
        "url": 766
    },
    {
        "nl_input": "The query describes a scenario where an investor can manually trigger or \"latch\" an Fci (possibly a financial checkpoint or metric) on their own. The relevant functionality is found in a smart contract function `latchFciUser`, which allows investors to lock in their stake under specific conditions like paused state, open round, and non-withdrawable status.",
        "url": 767
    },
    {
        "nl_input": "The query requires a function to remove an existing certificate authority (CA), preventing it from issuing new certificates. The function should be owner-restricted, delete the CA information, and emit a log or event to record the removal.",
        "url": 768
    },
    {
        "nl_input": "The query refers to a function that discards or drains stored assets, likely in a smart contract context. Among the provided codes, it matches most closely with the `downTheDrain` function in contract `c18357`, which handles the draining of funds based on certain conditions.",
        "url": 769
    },
    {
        "nl_input": "The query requires a function to withdraw Ether from a contract to a wallet, ensuring ownership validation and proper transfer mechanics. The function should handle specified withdrawal amounts, utilize secure transfer methods, and may involve additional checks like balance verification or splitting transfers among multiple addresses.",
        "url": 770
    },
    {
        "nl_input": "The query requires a function that checks if a sale is currently active and returns a boolean value (`true` if active, `false` otherwise). The function should be publicly accessible and ideally constant/pure to indicate it does not modify the contract state. A simple flag or time-based condition can be used to determine the sale status.",
        "url": 771
    },
    {
        "nl_input": "The query requires functionality to migrate tokens or data, involving methods like setting migration addresses, transferring balances, and logging migration events. It includes safety checks such as ensuring valid values, non-zero addresses, and ownership controls.",
        "url": 772
    },
    {
        "nl_input": "The query requires a function to withdraw funds from a contract, where the function should ensure only an authorized user (e.g., owner or admin) can call it, validate the withdrawal amount against the contract's balance, and transfer the specified amount to a designated address.",
        "url": 773
    },
    {
        "nl_input": "The query seeks the maximum number of extant nomins, calculated as the sum of the nomin pool and the total (circulating) supply.",
        "url": 774
    },
    {
        "nl_input": "The query describes a function that must be called after a crowdsale ends to perform additional finalization tasks, such as finalizing the sale, transferring funds, enabling refunds, or returning unsold tokens. It emphasizes post-crowdsale actions like executing final transfers, triggering refund mechanisms, and ensuring proper closure of the sale process.",
        "url": 775
    },
    {
        "nl_input": "The query describes a functionality to control the pause status of NFTs in a smart contract, allowing the owner to set whether NFTs are paused or not.",
        "url": 776
    },
    {
        "nl_input": "The query requires a function that allows selling outcome tokens to a market maker. The function should calculate profit, deduct fees, ensure the seller receives a minimum profit, transfer tokens from the seller, and update the market's token sale statistics.",
        "url": 777
    },
    {
        "nl_input": "The query requirement is for a free daily summon feature in a smart contract. It includes checking if the user is eligible based on time, generating a random value to determine the summon rank, and invoking the summon function.",
        "url": 778
    },
    {
        "nl_input": "The query requires granting an address the right to transfer a specific monster using the `transferFrom()` function. This involves setting permissions for a specific address to allow token or monster transfers on behalf of another address.",
        "url": 779
    },
    {
        "nl_input": "The query requires generating a unique key for a stock by concatenating the market and symbol. The key should be 12 bytes long, with the first 6 bytes from the market input and the next 6 bytes from the symbol input.",
        "url": 780
    },
    {
        "nl_input": "The query describes a function developed by Pickeringware Ltd to process refunds if KYC analysis fails. It allows participants to withdraw their Ether, updates crowdsale statistics, reclaims and burns tokens, and blacklists the user to prevent future token purchases. The function requires participant balances to be non-zero and is accessible only by the contract owner.",
        "url": 781
    },
    {
        "nl_input": "The query requires a modifier function that restricts the execution of certain functions in a smart contract to only the Etheraffle address. This modifier should check if the message sender (`msg.sender`) is equal to the Etheraffle address and allow execution only in that case, ensuring that only authorized functions can proceed.",
        "url": 782
    },
    {
        "nl_input": "The query requires a setter function for `arbitrationFeePerJuror` that allows the governor to update its value. The function should take a `uint` parameter, enforce governance access control, and assign the new fee value.",
        "url": 783
    },
    {
        "nl_input": "The query requires changing the DINRegistrar contract by setting a new registrar address through a function that restricts access to the owner. The relevant code provides the `setRegistrar` function, which updates the registrar and emits an event upon successful change.",
        "url": 784
    },
    {
        "nl_input": "The query requires a function to enable batch transfer of tokens from the owner's balance to multiple addresses, ensuring secure and efficient distribution with proper validation.",
        "url": 785
    },
    {
        "nl_input": "The query requires enabling the TeamWithdraw state, which allows for team withdrawals to be processed. The relevant code sets the contract state to TeamWithdraw, initializes a budget plan with withdrawal parameters, and emits an event indicating that TeamWithdraw is enabled.",
        "url": 786
    },
    {
        "nl_input": "The query requires a function to set or add initial shareholders for a contract. The function should allow adding new shareholders, ensure they are not the owner or a duplicate, and track up to three shareholders with an incrementing count.",
        "url": 787
    },
    {
        "nl_input": "The query requires a function to modify gift properties such as price, description, and URL using a unique gift ID. It involves updating stored gift data and ensuring the gift exists before making changes. The function should be restricted to the owner.",
        "url": 788
    },
    {
        "nl_input": "The query requires a function that calculates and returns the locked token amount for investors, considering a release schedule with three time-based tranches. The lockup should decrease the locked amount progressively as time passes, with specific intervals and corresponding fractions of the initial locked amount.",
        "url": 789
    },
    {
        "nl_input": "If a bag has not been purchased within the timeout period, its level should reset to 0. However, the current owner of the bag should remain unchanged, ensuring ownership is retained even after the level reset.",
        "url": 790
    },
    {
        "nl_input": "The query requires functionality to make an investment based on a pricing strategy. The investment process involves sending funds, calculating the token amount received according to the strategy, and specifying a receiver address and optional customer ID. The implementation includes a wrapper function that leverages a pricing strategy contract to determine token purchase amounts dynamically.",
        "url": 791
    },
    {
        "nl_input": "The query requires a system that handles both locked and unlocked tokens, supporting functionalities such as issuing unlocked tokens, releasing locked tokens after a time lock, and unlocking vested tokens over time with transferability based on calculated vesting schedules.",
        "url": 792
    },
    {
        "nl_input": "The query requires a function that allows the owner to set a time duration after which a price is considered stale. The function must be public, restricted to the owner, and update a state variable to control price staleness based on elapsed time.",
        "url": 793
    },
    {
        "nl_input": "The query describes a function called by the owner (or manager) to unpause a smart contract, returning it to a normal operational state. The function sets a `paused` flag to `false`, includes an access control modifier (e.g., `onlyOwner` or `onlyManager`), and a state check (`whenPaused`). It optionally emits an `Unpause` event.",
        "url": 794
    },
    {
        "nl_input": "The query requires a modifier in a smart contract that restricts token purchases to occur only between specified start and end dates set during contract creation. The modifier should check the current time against these timestamps to allow or block purchase transactions accordingly.",
        "url": 795
    },
    {
        "nl_input": "The query requires a function that allows users to buy presale tokens with Ether, including checks for sale timing, token availability, purchase limits, and correct price calculation based on tiers or steps. It also involves updating balances, tracking funds raised, and emitting relevant events upon successful purchase.",
        "url": 796
    },
    {
        "nl_input": "Participants can withdraw funds if the presale does not reach the minimum funding level after the deadline. The function verifies that the current time is past the presale end date, the total funding is below the minimum required, and the sender has sufficient balance before sending back the funds.",
        "url": 797
    },
    {
        "nl_input": "The query requires a function to claim all vested tokens up to the current date on behalf of a user. The function should allow the owner to trigger the claim for a specified address, ensuring that only eligible tokens up to the present date are released according to the vesting schedule.",
        "url": 798
    },
    {
        "nl_input": "The query requires a function where the owner can mint new coins, ensuring that only the owner, minter, or creator of the contract can perform the minting. The function should include access control (e.g., `onlyOwner`), and may involve updating total supply, balances, and using safe math operations to prevent overflow.",
        "url": 799
    },
    {
        "nl_input": "The query requires a function that checks whether the crowdsale has started by verifying if the current block number is greater than or equal to the start block.",
        "url": 800
    },
    {
        "nl_input": "The query requires a function that checks if a transcoding options string is valid. The validation condition specifies that the string's length must be a non-zero multiple of `VIDEO_PROFILE_SIZE`. This ensures the string is composed correctly of video profile segments.",
        "url": 801
    },
    {
        "nl_input": "The query describes a function that calculates and sets the points for a range of tokens, based on previously collected data. It updates the token-to-points mapping, tracks the worst-performing tokens, and processes in chunks up to a given amount.",
        "url": 802
    },
    {
        "nl_input": "The query requires a function that removes a received foreign token from the contract. The function should take the token address as a parameter, ensure it's not a zero address, delete it from a mapping, and emit an event for the removal. It should be accessible externally and restricted to the owner.",
        "url": 803
    },
    {
        "nl_input": "The query requires a function that allows specific addresses to participate early in a funding event. The functionality should include setting a whitelist for early participation, specifying minimum and maximum contribution caps, and ensuring the process is secure and time-bound. It also involves maintaining a list of whitelisted participants and validating their status.",
        "url": 804
    },
    {
        "nl_input": "The query requires a function to add a wallet to additional bonus members, accessible only by the contract owner. It involves setting the state of the specified wallet to active within a mapping or data structure. The implementation should ensure authorization control and proper state management for bonus members.",
        "url": 805
    },
    {
        "nl_input": "The query requires creating an auction for a given deed. The relevant code defines a `createAuction` function that takes parameters `_deedId`, `_startPrice`, `_endPrice`, and `_duration`. It validates the deed owner, ensures proper pricing and duration constraints, and stores the auction details. Only the deed contract or its owner can initiate the auction.",
        "url": 806
    },
    {
        "nl_input": "The query requires a function to add a holder to the `holders` list within a smart contract. The function should ensure that a holder is only added if they are not already present in the list, and it should track the holder's index position.",
        "url": 807
    },
    {
        "nl_input": "The query requires checking whether a specific asset exists, likely by verifying if the asset's owner is set (non-zero), indicating its creation or presence in the system.",
        "url": 808
    },
    {
        "nl_input": "The query requires a function to withdraw Ether from a contract, accessible only by the owner. The function should handle the transfer of funds, either in full or split between addresses, and may include a balance check prior to withdrawal.",
        "url": 809
    },
    {
        "nl_input": "A pet can only participate in one sponsored leaderboard at a time, indicating a restriction that prevents multiple concurrent sponsorships for the same pet.",
        "url": 810
    },
    {
        "nl_input": "The query requires a function to read transfer configurations, including parameters such as base, rate, collector, no transfer fee flag, and minimum transfer amount. It should return these configuration values to provide visibility into the transfer settings of the contract.",
        "url": 811
    },
    {
        "nl_input": "The query requires a function that allows only master accounts to service transfer tokens between addresses. The function must restrict access to authorized masters and perform a token transfer from one address to another.",
        "url": 812
    },
    {
        "nl_input": "The query seeks a function to withdraw the house stake, specifically allowing the owner to withdraw a specified value from the house stake while ensuring the remaining stake meets minimum requirements and transferring the withdrawn amount to the owner.",
        "url": 813
    },
    {
        "nl_input": "The query describes a function `switchToNextRound` that updates the start time, end time, and token cap for the next phase, and sets it as the current phase. It involves logic to calculate the next round's duration and token allocation, and emits an event upon switching.",
        "url": 814
    },
    {
        "nl_input": "The query requires a function to change the crowdsale stage, allowing the owner to set it to either \"PreICO\" or \"ICO\". The implementation should include a method that takes a numerical value as input and updates the stage accordingly.",
        "url": 815
    },
    {
        "nl_input": "The query seeks a function that returns `true` if provided parameters are valid. The function should perform checks such as matching array lengths, ensuring ascending order of amounts and dates, and optionally validating rate limits or sale parameters. It emphasizes validation logic for structured data inputs.",
        "url": 816
    },
    {
        "nl_input": "The query describes a functionality where the contract owner has the ability to reclaim or transfer ownership of top-level domains owned by the contract. The relevant code includes a function that allows the owner to set a new owner for a specific domain node, aligning with the described requirement.",
        "url": 817
    },
    {
        "nl_input": "The query seeks to identify external functions related to wineries within the provided code snippets. The relevant function `addWineryOperation` allows only designated winery addresses to add operational data on-chain, ensuring secure and verified entries tied to specific wine batches using track IDs and other parameters.",
        "url": 818
    },
    {
        "nl_input": "The query requires modifying the payroll system so that if a payday is missed, the owed payment is carried over and added to the next pay period's amount.",
        "url": 819
    },
    {
        "nl_input": "The user wants to sell tokens for ETH and must first set an allowance for the contract. The contract should handle token transfers from the user, send ETH in return, and include checks for balance and valid transfers.",
        "url": 820
    },
    {
        "nl_input": "The query requires a function that returns the token amount based on a given rate, aligning with functionalities related to token conversion or purchasing logic.",
        "url": 821
    },
    {
        "nl_input": "The query requires a function that subtracts two numbers and reverts on overflow, ensuring the subtrahend is not greater than the minuend. It emphasizes safe arithmetic operations, specifically subtraction, with an overflow check to prevent incorrect results.",
        "url": 822
    },
    {
        "nl_input": "The query requires a function to permanently lock the maximum supply of a token contract. The function should set a lock status flag, emit an event with the locked supply details, and ensure that the max supply cannot be changed thereafter. Access should be restricted to the contract owner.",
        "url": 823
    },
    {
        "nl_input": "The query seeks to identify code that allows users to claim tokens under specific conditions, such as sale stage validation, time-based restrictions, and bonus calculations. It involves checking eligibility, updating balances, and transferring tokens upon successful claim.",
        "url": 824
    },
    {
        "nl_input": "The query focuses on functionalities related to the creation or activation of a special manager within smart contracts. It involves operations such as setting, enabling, or turning on a special manager address, with checks for ownership, validity, and existing status. Events and mappings are used to track and manage these special addresses.",
        "url": 825
    },
    {
        "nl_input": "The query describes an initialization function intended to be called after contract deployment. It emphasizes that the function is used to finalize certain parameters and simplify contract compilation, indicating a need for post-deployment setup logic that ensures key variables are initialized only once and cannot change afterward.",
        "url": 826
    },
    {
        "nl_input": "The query requires a function to send tokens to a specified address, ensuring the sender is authorized, the amount is valid, and the token transfer is executed properly.",
        "url": 827
    },
    {
        "nl_input": "The query seeks to determine if two orders' calldata specifications can match. The relevant code provides a function that checks this by applying replacement patterns to both buy and sell calldata, then comparing the results to see if they are equal. It utilizes array manipulation functions to replace portions of the calldata based on given masks and returns a boolean indicating whether a match is possible.",
        "url": 828
    },
    {
        "nl_input": "The query describes a scenario where the contract owner proposes to transfer ownership of the contract to a new address. The function is accessible only to the current owner, and it updates the owner variable to the new address provided as input, effectively transferring control of the contract.",
        "url": 829
    },
    {
        "nl_input": "The query requires a function that retrieves the balance of a specific account in a smart contract. The function should accept an address parameter representing the account owner and return a `uint256` value indicating the balance. It should be a read-only (view or constant) operation, using appropriate documentation comments to describe the parameters and return value clearly.",
        "url": 830
    },
    {
        "nl_input": "The query requires a function to pay unpaid dividends to shareholders. The function should handle dividend distribution, potentially involving sender validation, dividend calculation, and fund transfer. It may include mechanisms to ensure only eligible participants receive dividends and update relevant balances and records accordingly.",
        "url": 831
    },
    {
        "nl_input": "The query requires a function that calculates and returns the percentage of shares a user holds on a specific date, based on some form of deposit or participation metric (e.g., BMC days). The function should accept a user identifier and a date, then compute the proportion of their contribution relative to the total, returning the result in percents. It may involve handling period indexing and fallback logic for missing or current dates.",
        "url": 832
    },
    {
        "nl_input": "The query seeks code functionalities useful for debugging purposes in Solidity online environments like Remix and sandboxes. Specifically, it refers to a contract allowing an admin to toggle a prebridge state, a function to check user ETH contributions, and another to list all spaceship IDs as an alternative to ERC721Enumerable.",
        "url": 833
    },
    {
        "nl_input": "The query requires a modifier in a smart contract that restricts function execution to only the exchange contract. The modifier should check if the caller (`msg.sender`) is equal to the exchange address, ensuring exclusive access by the designated exchange entity.",
        "url": 834
    },
    {
        "nl_input": "The query requires a function to unlock and transfer vested tokens to the grantee. The function must calculate vested tokens, subtract already transferred amounts, update the transferred balance, reduce total vesting, and trigger the token transfer with an event emission.",
        "url": 835
    },
    {
        "nl_input": "The query requires a function that calculates the average of two signed integers, with rounding towards zero when the result is a non-integer.",
        "url": 836
    },
    {
        "nl_input": "The query requires a function that allows the owner to withdraw Ether from a contract. The function should take an amount in wei as input and ensure only the owner can execute it. It should transfer the specified Ether amount from the contract to the owner's address, with a check to ensure sufficient balance before transferring.",
        "url": 837
    },
    {
        "nl_input": "The query requires a function that retrieves a contract by its name. The function should take the contract name as a parameter and return the corresponding contract address. Additionally, it should include a check to ensure the provided name corresponds to an existing contract.",
        "url": 838
    },
    {
        "nl_input": "The query focuses on internal balances in a smart contract. The relevant code defines a function `setBalance` that updates an address's balance internally, indicating manipulation of internal balance states without external interaction.",
        "url": 839
    },
    {
        "nl_input": "The query requires a function to transfer ownership of an SSP record from one address to another. The suitable code should involve a method that allows transferring the ownership of a record or contract, potentially involving a registry or ownership control mechanism.",
        "url": 840
    },
    {
        "nl_input": "The query seeks functionality that allows the withdrawal or draining of Ether in a smart contract. The relevant requirements include a function to transfer Ether, restricted access to authorized users (e.g., owner), and potentially handling logic for amount validation or emergency scenarios.",
        "url": 841
    },
    {
        "nl_input": "The query requires a function that issues tokens based on the amount of Ether received. The function should handle token minting, track issued tokens and received Ether, enforce a minimum contribution, and ensure the total issued tokens do not exceed a hard cap. It must also support pausing and verify the sender's address is not null.",
        "url": 842
    },
    {
        "nl_input": "The query requires a function that appends an unsigned integer (uint) in decimal format to a given string. The function should take a string and a uint as input, and return the resulting concatenated string.",
        "url": 843
    },
    {
        "nl_input": "The query requires a function callable by the owner after the contribution period ends, which distributes tokens (DNT) proportionally to contributors based on their contribution amount. The function should track and prevent duplicate distributions, use a calculated ratio based on total contributions, and emit events upon successful transfers.",
        "url": 844
    },
    {
        "nl_input": "The query describes a function to remove a \"destroyer\" from a contract when they no longer require or need the privilege. The function should be accessible externally, ensure the caller has the appropriate authority (e.g., \"onlyEtheraffle\"), verify the destroyer exists, update the destroyer list, and emit a removal event with a timestamp.",
        "url": 845
    },
    {
        "nl_input": "The query describes a functionality that allows an account to place a higher bid on a token. The relevant code should involve a function where a user can submit a bid, ensure it is higher than the existing bid, and update the bid details. Among the provided options, the second code (url: 846) satisfies this requirement by implementing a bidding mechanism for tokens, ensuring the new bid is greater than the existing one and updating the bid information accordingly.",
        "url": 846
    },
    {
        "nl_input": "The query requires retrieving the balance of a Faucet contract by calling the `balanceOf` function, which returns the token balance for a specified address. The relevant code includes functions that either directly query the Faucet's balance or implement the standard ERC20 `balanceOf` method to fetch account balances.",
        "url": 847
    },
    {
        "nl_input": "The query requires a function to set the price for an EXH token, accessible only by the owner, ensuring that the price is validated and properly assigned. The implementation should emit a state change and use appropriate access control and validation checks.",
        "url": 848
    },
    {
        "nl_input": "The query requires a function that calculates the total payout per tier using the odds method. The payout should be determined by multiplying the number of winners by the odds for the corresponding match index. This functionality is described in the first code snippet, where the `oddsTotal` function returns the total payout based on `_numWinners` and `_matchesIndex`.",
        "url": 849
    },
    {
        "nl_input": "The query requires a function that allows the owner to withdraw a specified amount of ether from the contract, ensuring only the owner can execute the withdrawal and transferring the funds to the owner's address.",
        "url": 850
    },
    {
        "nl_input": "The query requires a function that allows the caller to create an original artwork using a provided genome. The function should handle ownership assignment, enforce creation limits, and include conditions for validating fees or permissions, ensuring secure and controlled artwork generation based on the given genetic data.",
        "url": 851
    },
    {
        "nl_input": "The query requires a function to transfer tokens between addresses, potentially involving approvals and ownership checks. The function may need to handle token transfers from one address to another, manage balances, handle allowances, and emit transfer events. Some implementations include owner restrictions, time constraints, or additional logic like transferring to an owner address upon spending.",
        "url": 852
    },
    {
        "nl_input": "The query requires a function that returns the index in an array for a given position and throws an error if the position is out of bounds.",
        "url": 853
    },
    {
        "nl_input": "The query requires a function that extracts 20 contiguous bytes from a given bytes array, starting at a specified offset. The extracted bytes should be returned as a `bytes20` type. Among the provided code options, one closely matches this requirement by slicing 20 bytes and returning them as a `bytes20`. Other functions either handle different byte sizes or are unrelated to slicing functionality.",
        "url": 854
    },
    {
        "nl_input": "The query requires a function modifier that checks if `msg.sender` is a specific address, such as a contract or a designated agent. The modifier should enforce access control by validating the sender against a predefined value or contract before executing the function body.",
        "url": 855
    },
    {
        "nl_input": "The query requires a function that returns an array containing the weapons of an army. Specifically, it seeks to retrieve the counts of four types of military units (drones, planes, helicopters, and tanks) associated with a given army ID.",
        "url": 856
    },
    {
        "nl_input": "The query requires a function to set the PriceSetter address, granting access to set a token price in wei. Only the owner should be able to call this function, ensuring restricted and secure price-setting capabilities.",
        "url": 857
    },
    {
        "nl_input": "The query requirement describes a token withdrawal function that allows users to withdraw their tokens after specific conditions are met, such as the end and finalization of a crowdsale. It involves checking eligibility, retrieving the token amount, and executing the transfer while ensuring security and access control.",
        "url": 858
    },
    {
        "nl_input": "The query requires functionality to prevent users from submitting the same bet again. Specifically, it needs a mechanism to check for duplicate bets based on user address, match ID, and betting price, ensuring that identical bets cannot be resubmitted.",
        "url": 859
    },
    {
        "nl_input": "The query requires a function that multiplies two numbers and throws an exception if the result overflows. The function should ensure that the multiplication is safe and handles edge cases properly.",
        "url": 860
    },
    {
        "nl_input": "A modifier function that executes before the main function it is applied to, used to restrict access or control execution conditions. Examples include restricting usage to a specific address, ensuring the caller is the owner, or allowing execution only when certain conditions (like a pause period) are met.",
        "url": 861
    },
    {
        "nl_input": "Each angel can participate in only one sponsored leaderboard at a time, ensuring exclusive placement and preventing duplication across multiple leaderboards.",
        "url": 862
    },
    {
        "nl_input": "The query requires determining the maximum available amount that can be taken from an order. The relevant code computes this by taking the minimum of two values: the remaining taker token amount and the equivalent maker token balance converted using the order's token ratio.",
        "url": 863
    },
    {
        "nl_input": "The query describes a scenario where a developer initiates a withdrawal that is split equally among all contract owners. The function `devWithdraw` in the first code fulfills this by dividing the amount by the number of owners and transferring equal portions to each. Other codes only allow single-owner withdrawals.",
        "url": 864
    },
    {
        "nl_input": "The query requires a function that reverts on transfer errors instead of returning false, includes standard checks, and explicitly throws if transfers are disabled. It involves an account or contract attempting to receive coins, with parameters for source, target, and amount. The function must minimize user errors by enforcing correct behavior through assertions and modifiers like `transfersAllowed`.",
        "url": 865
    },
    {
        "nl_input": "The query requires a function that allows the owner to update a minimum value denominated in Wei, with checks to ensure the new value is greater than zero and adheres to specific constraints. The updated value should be stored as a contract state variable for use in subsequent operations.",
        "url": 866
    },
    {
        "nl_input": "The query requires a function that returns the current round in a contract, where the round is determined based on certain conditions such as token sales. The function should be constant/view and return either an address or structured round data.",
        "url": 867
    },
    {
        "nl_input": "The query requires a function to publish an article with a hash, key hash, and token count, ensuring ownership, rate limiting, uniqueness, and proper token limits. It involves checks for authorization, duplicate articles, time constraints, and maximum tokens per article, while updating relevant state variables and emitting results.",
        "url": 868
    },
    {
        "nl_input": "The query requires a function that allows the contract owner to enable token transfers. The function should be accessible only to the owner and, upon execution, should activate the transfer capability within the contract.",
        "url": 869
    },
    {
        "nl_input": "The query requires a function that removes an admin address and returns true upon successful removal. The function should include checks to ensure the admin exists and is not the caller, and it should delete or update the admin status accordingly.",
        "url": 870
    },
    {
        "nl_input": "The query requires a function that allows the `pendingAdmin` address to complete the process of becoming the new admin, by claiming the admin role. This involves verifying the caller is the pending admin, updating the admin address, and clearing the pending admin field.",
        "url": 871
    },
    {
        "nl_input": "The query requires checking if a token transfer destination is valid by ensuring it is not the zero address, not the token contract address, and optionally excluding additional restricted addresses like owner, admin, or token sale addresses.",
        "url": 872
    },
    {
        "nl_input": "The query requires a function to update the minting agent's status in a smart contract. The function should take an address and a boolean status as parameters, be accessible only to the owner, and update a mapping of minting agents with the provided status.",
        "url": 873
    },
    {
        "nl_input": "The query seeks to determine the total number of tokens that can currently be purchased. The relevant code includes checks on token availability, such as `require(balances[fundsWallet] >= numberOfTokens)` and `require(tokensSold < 3700)`, ensuring there are remaining tokens for sale. Additionally, it calculates pricing based on the number of tokens sold in different tiers.",
        "url": 874
    },
    {
        "nl_input": "The query describes a process where an administrator finalizes an ownership change after a day. The relevant code should involve a method that allows a pending admin or owner to confirm and complete the transfer of control, typically by validating the caller's address and updating the current admin or owner.",
        "url": 875
    },
    {
        "nl_input": "The query requires a function that stakes a specific amount of tokens, transferring them from the caller's account. It must ensure the transfer occurs and emits a Staked event. Optional data can be included, and the stake is made on behalf of a specified user.",
        "url": 876
    },
    {
        "nl_input": "The query requires a function to place a bid in an auction, ensuring the bid is higher than the current highest bid and updating relevant variables. It includes handling bid placement, updating highest bidder details, emitting events, and managing returns for the previous highest bidder.",
        "url": 877
    },
    {
        "nl_input": "The query requires a function that allows a token owner to approve a spender to spend a specified amount of tokens on their behalf, emitting an approval event and updating the allowance mapping.",
        "url": 878
    },
    {
        "nl_input": "The query requires a function that allows the owner to update the token exchange rate, potentially based on predefined conditions or with dynamic calculations involving revenue or balance thresholds.",
        "url": 879
    },
    {
        "nl_input": "The query requires a function that compares two values and throws an exception if they are not equal. The function should revert the transaction when the compared values do not match, ensuring equality is enforced.",
        "url": 880
    },
    {
        "nl_input": "The query requires a function to create a new proxy contract with specified owner and recovery key, emitting an event upon creation. It involves setting up ownership and recovery mechanisms for the proxy contract.",
        "url": 881
    },
    {
        "nl_input": "The query highlights a function marked as dangerous, which allows the contract owner to skip a participant in the payout order. This poses risks if a malicious user exploits gas consumption in ETH transfers, potentially jamming the contract. The skipped participant can appeal to reverse the action. The function emits an event on skipping and updates internal tracking for appeals and payout order.",
        "url": 882
    },
    {
        "nl_input": "The query requires a function that allows changing the successor address in a smart contract, ensuring the new address is valid and updating the successor state accordingly.",
        "url": 883
    },
    {
        "nl_input": "The query is asking for a calculation or retrieval of profit. The relevant code should return a specific profit value, such as a share or reward, based on user interaction or predefined parameters.",
        "url": 884
    },
    {
        "nl_input": "The query requires a function that checks whether a customer's transaction (Tx) for payment of MCW has already been spent. The function should take the transaction hash as input and return a boolean indicating if it is spent, typically by verifying the presence of a timestamp or other indicator in a registry.",
        "url": 885
    },
    {
        "nl_input": "The query requires a function that sets the free memory pointer to point beyond all accessed memory. The relevant code achieves this using inline assembly, storing the value of `msize` at memory address `0x40`, effectively updating the free memory pointer.",
        "url": 886
    },
    {
        "nl_input": "The query requires the ability to quickly check Round1, specifically for Round1 and only once. The relevant functionality should involve checking conditions related to Round1, likely involving round data such as start block, lock status, or token sold, and returning a result based on that check.",
        "url": 887
    },
    {
        "nl_input": "The query requires a function to remove an address from a whitelist. The relevant code provides a function `removeWhitelist` that sets the specified address's whitelist status to false, effectively removing it from the whitelist.",
        "url": 888
    },
    {
        "nl_input": "The query refers to processing a combat scenario that is expensive, indicating the need for sufficient gas. The relevant code involves logic where gas cost calculations are made based on actions taken, particularly in relation to triggering events like an attack and ensuring enough gas is provided to cover associated costs.",
        "url": 889
    },
    {
        "nl_input": "The query requires a function to withdraw balance and share pot, where users send tokens to the contract under specific conditions. If the game is finished, any token amount allows withdrawal of ETH balance and share pot. If not finished, only 0.08 or 0.01 token transfers are valid for withdrawal or rebuy, respectively. The function overrides ERC20 transfer, restricts transfers to the contract only, calculates each player's share, and handles fee deductions before sending ETH.",
        "url": 890
    },
    {
        "nl_input": "The query requires identifying functions related to \"air deliver\" that use `count` instead of `wei_amount` or `wei` in the provided code snippets. The relevant function is `airDeliver(address _to, uint256 _amount)` from contract `c2654`, which handles token transfers using an `_amount` parameter without involving `wei`.",
        "url": 891
    },
    {
        "nl_input": "The query describes a function that allows a qualified crowdsale partner to purchase Star Tokens. It involves checks for message value, updates the partner's raised amount, ensures it does not exceed the cap, calculates the token amount based on exchange rate, and handles commission fees.",
        "url": 892
    },
    {
        "nl_input": "The query requires a modifier in a smart contract that restricts function execution to only the owner. The modifier should ensure that the caller (`msg.sender`) is the owner, and if not, the function should revert or deny execution.",
        "url": 893
    },
    {
        "nl_input": "The query requires determining the contract size of an ERC223 token, specifically ensuring it is non-zero to confirm it is a contract. None of the provided code snippets directly fulfill this requirement.",
        "url": 894
    },
    {
        "nl_input": "The query requires a function that calculates the output amount based on compounding interest for a given input and number of payouts, applying an interest rate and tax deduction.",
        "url": 895
    },
    {
        "nl_input": "The query requires computing the second-round winners from the first-round winners by comparing their hero powers. It uses a random number to determine the winner based on power comparisons, and the results are stored in `secondRoundWinners`. The logic involves four initial winners split into two pairs, with each pair competing to determine the final two winners.",
        "url": 896
    },
    {
        "nl_input": "The query seeks to determine whether the current round is in a lock period. The relevant code should check if the elapsed blocks since the round start are within the locked block range, derived from the round length and lock percentage.",
        "url": 897
    },
    {
        "nl_input": "The query describes a scenario where a purchaser's cap is reset if a specified window duration has been met. The relevant code should track purchases, determine if the time window has expired, and reset the cap accordingly. It involves internal logic to update or reset the purchase amount based on the elapsed time.",
        "url": 898
    },
    {
        "nl_input": "The query requires a function to set or update a global activation fee in a smart contract, ensuring the new fee is greater than zero and different from the current fee, with an event emitted upon successful update.",
        "url": 899
    },
    {
        "nl_input": "The query requires a function to set token prices, accessible only by the owner, ensuring price updates are secure and controlled.",
        "url": 900
    },
    {
        "nl_input": "The query requires a function that allows the contract owner to retrieve or sweep all Ether currently held by the contract, transferring it to a specified address or the owner's wallet. The function should be accessible only to the owner and must handle any Ether that may become \"trapped\" in the contract.",
        "url": 901
    },
    {
        "nl_input": "The query requires a function that checks if a gift exists and has not been redeemed. It must return true only when both conditions are met: the gift exists and is unredeemed.",
        "url": 902
    },
    {
        "nl_input": "The query seeks to identify functions within smart contracts that involve handling Ether (ETH), specifically focusing on functionalities related to depositing ETH, withdrawing ETH, or transferring ETH for transaction purposes. It also highlights scenarios where ETH management is conditional or involves special operations like self-destruction of the contract or restrictions based on ownership or successful execution.",
        "url": 903
    },
    {
        "nl_input": "The query describes a function `fixedExpUnsafe` that approximates e^x using a Maclauren series. It involves successive multiplication and bit-shifting operations to maintain precision, with the result scaled up by a factor determined by the input precision. The function relies on precomputed constants for its approximation and returns the computed value divided by a fixed constant.",
        "url": 904
    },
    {
        "nl_input": "The query requires identifying functions in the provided contracts that can only be executed by specific roles or addresses, such as the contract owner or a designated address like \"etheraffle.\" It focuses on access control mechanisms and restrictions applied to critical functions within the smart contracts.",
        "url": 905
    },
    {
        "nl_input": "The query requires a function to create a new tank type with specified attributes such as price, earnings, health, attack, armor, and speed. It involves setting up a data structure to store tank types, assigning a unique ID, and ensuring access control (e.g., owner-only permission).",
        "url": 906
    },
    {
        "nl_input": "The query requires a function that determines and returns the current state or phase based on the timestamp, involving checks against predefined time intervals and associated active flags.",
        "url": 907
    },
    {
        "nl_input": "The query requires a function that allows the owner to transfer ownership of a contract to a new address, ensuring only the current owner can initiate the change. The function should validate the new owner's address and update the ownership accordingly.",
        "url": 908
    },
    {
        "nl_input": "The query requirement is to start a game by providing the game handle `_hGame`, maximum housekeeping value `_hkMax`, and a list of player addresses `_players`. The function verifies the sender is a valid arbiter, checks if the number of players is correct, cancels any active game with the same handle, performs housekeeping if needed, allocates the game, and initializes game parameters like pot, players, and timestamps.",
        "url": 909
    },
    {
        "nl_input": "The query requires identifying code segments that implement a restriction based on `msg.sender`. Specifically, it looks for contracts that enforce conditions on the sender of the message, such as being a specific contract, a payer, or the owner. The goal is to extract and analyze access control mechanisms tied to `msg.sender` in the provided code snippets.",
        "url": 910
    },
    {
        "nl_input": "The query requires setting addresses that will receive the vested team tokens upon finalization. The function should allow specifying allocations for team members and contributors, ensuring these addresses are properly configured to receive their respective token shares when the process completes.",
        "url": 911
    },
    {
        "nl_input": "The query requires a function to sell eggs for ETH, involving calculations for egg value, applying fees, and transferring ETH to the seller. The function should update contract states like resetting claimed eggs, adjusting hatchery balances, and adding to the market eggs supply.",
        "url": 912
    },
    {
        "nl_input": "The query requires a function that allows the admin to toggle or switch the prebridge state. The relevant code provides a function `togglePrebrdige()` which flips the `prebridge` boolean state, and is accessible only by the owner of the contract.",
        "url": 913
    },
    {
        "nl_input": "The query requires a function to retrieve the invested Ethereum from a Pre ICO. The function should ensure it is called after the Pre ICO end date, be accessible only to the owner, and transfer the invested amount to the caller's address while updating the state accordingly.",
        "url": 914
    },
    {
        "nl_input": "The query describes a function to execute a proposal with parameters for a proposal number, refund amount, and fees. It involves validating the proposal, adjusting balances, and emitting events upon successful execution.",
        "url": 915
    },
    {
        "nl_input": "The query seeks to identify code related to setting minimum and maximum withdrawal limits, particularly focusing on functions that enforce constraints on withdrawal amounts. The relevant code includes a function that sets a minimum withdrawal limit using a `minWithdraw` variable and enforces it via a requirement check. However, no explicit maximum withdrawal limit is defined in the provided contracts. The withdrawal functions lack caps on the withdrawal amount, relying only on balance checks or external control through administrative roles. Therefore, the query\u2019s requirements are partially met by the code that defines a minimum withdrawal threshold but not a maximum limit. \n\n**Description of query's needs (within 80 words):**  \nThe query aims to find code that enforces both minimum and maximum withdrawal limits for a contract. Only a minimum withdrawal is implemented; a maximum limit is missing.",
        "url": 916
    },
    {
        "nl_input": "The query requires a function that retrieves the token balance of a specified address. The function should be part of a smart contract, marked as public and view (or constant), accept an address parameter, and return a uint256 or uint representing the balance.",
        "url": 917
    },
    {
        "nl_input": "The query requires a function that decodes an RLPItem and extracts an address from it. The suitable code provides an internal constant function named `toAddress` that takes an `RLPItem` in memory, checks if it contains data, decodes it, validates the length as 20 bytes (for an Ethereum address), and returns the resulting address using low-level assembly operations.",
        "url": 918
    },
    {
        "nl_input": "The query requires a function to remove a policy rule associated with a signature, contract address, and group name. The function must perform validation checks, update policy data accordingly, emit an event upon successful removal, and return a status code. It involves interaction with a policy mapping structure and group management logic.",
        "url": 919
    },
    {
        "nl_input": "The query requires a function that restricts token transfers for specific addresses by setting Unix unlock times, preventing them from sending or receiving tokens until after the specified time. The function should handle multiple targets and include validation checks.",
        "url": 920
    },
    {
        "nl_input": "The query describes a method that contains core game logic, specifically tracking a unique button \"click\" event and storing associated metadata. It involves generating events (ButtonClick and Transfer), limiting calls to once per game generation, and handling game state changes based on block numbers. The function returns the ID of the latest click.",
        "url": 921
    },
    {
        "nl_input": "The query describes a function that can be called by anyone to update the inflation rate yearly. It requires a one-year interval between updates and involves adjusting the inflation rate and related values based on predefined calculations.",
        "url": 922
    },
    {
        "nl_input": "The query seeks a function that calculates the time remaining until the next interest payout in a blockchain contract. It refers to a public, constant function returning a uint256 value representing the Unix timestamp difference, without modifying contract state.",
        "url": 923
    },
    {
        "nl_input": "The query seeks a description of the price calculation mechanism based on provided code. The functionality involves returning a price for a given key `n`, scaling it by a factor of `n` and applying decimals to handle precision, avoiding floating-point numbers. The core requirement is to compute and return asset prices with associated decimal places in a view function.",
        "url": 924
    },
    {
        "nl_input": "The query describes a function that allows a spender to withdraw tokens from an account up to a specified value. It emphasizes setting or updating an allowance, indicating a typical token approval mechanism in smart contracts for controlling delegated spending.",
        "url": 925
    },
    {
        "nl_input": "The query seeks functions related to withdrawing funds from a smart contract. The relevant functions include: `withdrawl(uint amt)` in contract c5281, which allows an admin to withdraw a specified amount; `withdraw()` in contract c16365, which enables broadcasters to withdraw deposited funds under certain conditions; and `withdraw()` in contract c222, which permits the admin to withdraw the contract's entire balance.",
        "url": 926
    },
    {
        "nl_input": "The query seeks a function that converts all of the caller's affiliate rewards into tokens, involving updating the caller's balance and emitting a reinvestment event.",
        "url": 927
    },
    {
        "nl_input": "The query requires a function to transfer ownership specifically for a Vanity URL, involving checks on address mappings and emitting a transfer event.",
        "url": 928
    },
    {
        "nl_input": "The query seeks to identify functions within smart contracts that are classified as internal. From the provided code, it is observed that one contract contains an internal function `runJackpot()` which executes specific logic involving time-based conditions and Ether transfers. The function is not accessible externally, aligning with the nature of internal functions. Other listed functions are either external or public, not meeting the internal criterion.\n\n**Description (within 80 words):**  \nInternal functions in the given contracts include `runJackpot()`, which runs logic using time-based conditions and Ether transfers. It is inaccessible externally, fitting the internal modifier. No other internal functions are found across the provided contracts.",
        "url": 929
    },
    {
        "nl_input": "The query requires a description of an internal token transfer function for \"AIRA\" that enables moving tokens between addresses while ensuring the sender has sufficient balance. It involves parameters `_from`, `_to`, and `_value`, and emits a `Transfer` event upon successful execution.",
        "url": 930
    },
    {
        "nl_input": "The query requires retrieving the balance of a specified Ethereum address within a smart contract. The function `balanceOf` is used, taking an address as input and returning the corresponding balance stored in the contract's mapping. Multiple contract examples demonstrate this functionality with varying parameter names and return types, but all serve the same purpose of querying account balances.",
        "url": 931
    },
    {
        "nl_input": "The query requires a function or mechanism to check whether a blockchain-based process (such as a crowdsale or contract stage) has started, typically by comparing the current block number with a predefined start block.",
        "url": 932
    },
    {
        "nl_input": "The query seeks a function that allows setting multiple pixels in a single transaction, ensuring efficiency and cautioning against gas limitations. The function must validate input length equality, iterate through pixel indexes, apply color changes if applicable, and ensure at least one pixel is set to avoid failure.",
        "url": 933
    },
    {
        "nl_input": "The query describes a requirement where a function or modifier in a smart contract enforces that certain actions cannot be executed before the crowdsale start time. It involves checks to ensure that operations are only allowed once the sale has officially started, typically enforced using a timestamp comparison with `now`.",
        "url": 934
    },
    {
        "nl_input": "The query requires a function that sends profits to a token contract. The relevant code should involve transferring tokens, updating supply, or triggering profit distribution mechanisms. It may include interactions with token transfer functions, contract calls for distributing funds, or minting and allocation routines.",
        "url": 935
    },
    {
        "nl_input": "The query requires a function that sets the id of the last token eligible for a prize. The function should restrict the token ID to be less than the total number of tokens and update the validation state accordingly. It should also reset tracking variables for token checking, calculation, and winner counting. The operation should be restricted to an admin and involve updating the payout distribution ID.",
        "url": 936
    },
    {
        "nl_input": "The query seeks to determine the conditions under which a stage starts in a smart contract. The relevant code should define a function that checks or sets the starting conditions for a stage, potentially involving comparisons of stage identifiers and contract variables to validate the start condition.",
        "url": 937
    },
    {
        "nl_input": "The query requires a function that allows an external manager to set or change an interface implementer address, typically involving access control and delegation of permissions.",
        "url": 938
    },
    {
        "nl_input": "The query requires implementing a whitelist mechanism in a smart contract to manage funder addresses, including functionalities to add, remove, and verify addresses in the whitelist.",
        "url": 939
    },
    {
        "nl_input": "The query requires a function to set buy limits in wei, validate min and max values, update contract state, and emit an event when limits change. It involves internal logic with parameter checks and state updates.",
        "url": 940
    },
    {
        "nl_input": "The query describes a token creation and distribution scenario, where the AVALANCHE ICE Tokens are created and held in an address to manage community contributions. Funds or tokens for the community will be drawn from this central address. The requirement involves initializing token allocations for different roles like advisors, bounty, community, company, and presale participants. It also indicates a need for functions that allow token creation, allocation management, and distribution control.",
        "url": 941
    },
    {
        "nl_input": "The query seeks to determine whether a given date falls within a pre-sale period, typically by checking if the date is between specified start and end times and if other conditions, such as available pre-sale amount, are met. The goal is to validate eligibility for participation in a pre-sale event based on time constraints and availability.",
        "url": 942
    },
    {
        "nl_input": "The query requires retrieving the block numbers for all revisions of a specific blob. The relevant code defines a function `_getAllRevisionBlockNumbers` that takes a `blobId` as input and returns an array of block numbers corresponding to each revision of the blob.",
        "url": 943
    },
    {
        "nl_input": "The query requires a function to set up a bounty pool by assigning a bounty pool address, accessible only by the creator of the contract.",
        "url": 944
    },
    {
        "nl_input": "The query requires a function that retrieves player information, specifically involving getters for player data such as ID, name, address, score, and related attributes. The function should be publicly accessible, optionally constant or view, and may involve parameters like board hash, player ID, or address.",
        "url": 945
    },
    {
        "nl_input": "The query describes a scenario where an admin finalizes a delegation after a day. The relevant code indicates that only an admin or owner can call the `finalizeDelegation` function, which deletes the current delegation operation and delegates to a new contract after verifying conditions like admin match and block deferment.",
        "url": 946
    },
    {
        "nl_input": "The query requires a function that allows one user to transfer WEDU tokens to another user. The function should include parameters for the sender address, receiver address, and token amount, and it should return a boolean indicating transfer success.",
        "url": 947
    },
    {
        "nl_input": "The query requires obtaining the price for tokens during the current stage. The relevant code should calculate or return the token price based on the current stage, potentially involving conditions like sale periods or stages.",
        "url": 948
    },
    {
        "nl_input": "The query requires a contract function to retrieve base stats for monsters by ID, enabling efficient storage and updates during evolution by only storing the monster ID on-chain. This helps reduce gas costs and transaction overhead.",
        "url": 949
    },
    {
        "nl_input": "The query requires a function to release purchased tokens to buyers during the main sale, as mandated by Eidoo's ICOEngineInterface. The function must handle token distribution, including calculating bonuses, managing refunds if overpayment occurs, and ensuring transfers are executed correctly. It should also emit appropriate events for transparency and logging purposes.",
        "url": 950
    },
    {
        "nl_input": "The query requires a function or modifier that restricts access to only specific authorized roles\u2014specifically, the owner, depositor, or beneficiary\u2014and reverts if called by any other account. This functionality is enforced through a require statement checking the caller's address against these three roles before allowing execution to proceed.",
        "url": 951
    },
    {
        "nl_input": "The query requires a function that allows for the distribution of tokens to multiple accounts in specified amounts. It involves taking tokens from a source address and transferring them to a list of destination addresses, with support for whole token values only. The function should be owner-restricted and ensure that the number of destinations matches the number of token amounts provided.",
        "url": 952
    },
    {
        "nl_input": "The query checks whether a specific address has transfer approval for a certain Cutie. The relevant code defines a function `_approvedFor` that checks if the approved address for a given Cutie ID matches the provided address.",
        "url": 953
    },
    {
        "nl_input": "The query requires a function modifier that restricts access to only the GDPOracle account, ensuring that the associated function can only be called by this specific address. Any unauthorized caller should trigger a revert.",
        "url": 954
    },
    {
        "nl_input": "The query requires a function that retrieves data about a specific redemption made by a given address. The function should accept the address and an index as parameters and return details such as the redemption ID, reason, and value. This is fulfilled by a contract that stores redemptions in a mapping and allows indexed access to retrieve the data.",
        "url": 955
    },
    {
        "nl_input": "The query describes a functionality that allows transferring animals from one contract to another. It involves moving ownership of animal assets between contracts, including handling winnings and maintaining records of transferred items. This process supports easier contract updates.",
        "url": 956
    },
    {
        "nl_input": "The query requires a function to mint tokens, specifying the recipient address and the amount or ID of tokens to be minted. It implies the need for internal handling, address validation, supply tracking, and ownership transfer mechanisms.",
        "url": 957
    },
    {
        "nl_input": "The query describes a functionality where the owner can delist an address by setting its cap to zero. This implies a requirement for a function that allows the owner to update or remove an address's participation limit, effectively disabling it by setting a zero cap. The function should be owner-restricted and may involve updating mapping values related to user caps.",
        "url": 958
    },
    {
        "nl_input": "The query requires a function to manually start the crowdsale that can only be called by the owner. This function should allow starting the ICO before the scheduled date and undo a previous stop caused by human error. It must ensure that the crowdsale can resume under the owner's control.",
        "url": 959
    },
    {
        "nl_input": "The query requires a function that returns the deed identifier of an owner at a specific index. The function should take an owner's address and an index as input and return the corresponding deed identifier. It must ensure that the provided index is valid (less than the total count of deeds owned by the owner).",
        "url": 960
    },
    {
        "nl_input": "The query requires a modifier that restricts a function to being called only once. The relevant code implements a modifier named `onlyOnce` that enforces this limitation using a state variable `functAttempts` to track the number of calls, ensuring execution is restricted to a single invocation.",
        "url": 961
    },
    {
        "nl_input": "The query requires a function that allows changing a developer fee. The relevant code provides a function `SetDevFee` which sets the developer fee, restricting the value to a maximum of 650 and ensuring the caller is the owner.",
        "url": 962
    },
    {
        "nl_input": "The query requires overriding the `transferFrom` function in a token contract to add custom logic, such as checking transferability, verifying unlocked tokens, or validating sender permissions before allowing a token transfer. The overridden function should still call the parent implementation and return a boolean indicating success.",
        "url": 963
    },
    {
        "nl_input": "The query requires a function to sell a specified amount of tokens to a contract. The function should handle the transfer of tokens from the contract to the investor, deduct the sold tokens from the available supply, and ensure internal execution without exposing sensitive operations externally. It must maintain proper accounting of token balances and supply.",
        "url": 964
    },
    {
        "nl_input": "The query seeks functionality to enable or disable an address as a sender of EUR-T. The relevant code should include a method to set permissions for addresses, specifically allowing or disallowing transfers from a given address, likely involving a mapping to track allowed addresses and an event or log to record changes.",
        "url": 965
    },
    {
        "nl_input": "The query focuses on refund functionality in smart contracts. It seeks to identify and describe functions that allow users to claim refunds, particularly highlighting conditions under which refunds are available, such as failure to reach a softcap or the end of a sale period. The functions typically involve resetting user balances or invested amounts and transferring funds back to the sender.",
        "url": 966
    },
    {
        "nl_input": "The query requires a description of functionality that allows users to buy shares. The relevant code implements a `buy()` function that handles share purchases, calculates amounts based on provided logic, updates balances and total supply, and includes checks like `mintingFinished`. It also involves events and transfers, ensuring the process is tracked and executed correctly within a smart contract.",
        "url": 967
    },
    {
        "nl_input": "The query requires a function that sends an Oraclize query for a given API, handles query fees, and ensures queries are only sent when conditions such as time intervals and funding are met. It involves event logging, time-based checks, and interaction with the Oraclize service for external data retrieval.",
        "url": 968
    },
    {
        "nl_input": "The query requires a function to confirm an autosell operation, specifically validating if a given amount can be sold. The function should return false if the available tokens are insufficient and true otherwise.",
        "url": 969
    },
    {
        "nl_input": "The query requires an internal method that creates a new Zodiac instance, initializes its properties including genes, generation, and zodiac type, stores it in a collection, and emits a birth event with relevant details. It also involves validation checks and ensures the uniqueness of the generated ID.",
        "url": 970
    },
    {
        "nl_input": "The query requirement is to identify code that involves setting up or deploying functionality related to a whitelist, contribution start, or time-based access control. The relevant code should include actions such as initializing a whitelist address, starting a contribution phase, or enforcing access based on a release date.",
        "url": 971
    },
    {
        "nl_input": "The query requires a function that creates a snapshot of token holder balances and returns the index of the newly created snapshot. The function should update the snapshots array, store relevant data such as token count and the first address, and trigger an event upon creation.",
        "url": 972
    },
    {
        "nl_input": "The query requires a function that retrieves the level of a hero. The relevant code provides a function `getHeroLevel` that returns the current level of a hero based on its token ID from a mapping, fulfilling the requirement.",
        "url": 973
    },
    {
        "nl_input": "The query seeks a function that returns the total number of tokens in existence. The desired function is named `totalSupply`, is publicly accessible, and returns a `uint256` value representing the total token supply.",
        "url": 974
    },
    {
        "nl_input": "The query requires a function that withdraws all released vesting coins to the user's balance. The function should calculate the released amount based on vesting parameters, subtract already withdrawn amounts, and update both the vesting and balance records accordingly.",
        "url": 975
    },
    {
        "nl_input": "The query describes a function `doProxyAccounting` that is internal and responsible for handling fee pledges by an owner, creating tokens accordingly, and emitting contribution logs. It involves interactions with a token contract to generate tokens for the pledging owner.",
        "url": 976
    },
    {
        "nl_input": "The query requires a function that allows marketing contributors to withdraw their rewarded tokens. The function should validate the contributor's address, ensure sufficient reward tokens are available, transfer the specified tokens, and update the contributor's reward balance. Additionally, it should emit an event to log the withdrawal.",
        "url": 977
    },
    {
        "nl_input": "The query requires a function that releases vested tokens, specifically returning them to a Hut34 wallet after verifying the release date. It involves transferring a portion of vested tokens, updating the next release date, and emitting relevant events.",
        "url": 978
    },
    {
        "nl_input": "The query requires a function that sets or updates the symbol of a token contract. It involves accepting a parameter representing the symbol and modifying the contract's `symbol` state variable, potentially with access control such as `onlyOwner`.",
        "url": 979
    },
    {
        "nl_input": "The query describes a requirement where any user should be able to transfer Change tokens to another address once trading has started. The function should take the recipient address and the number of tokens as parameters and return a boolean indicating success. It must ensure transfers are only allowed after trading has commenced, potentially involving checks or conditions to enforce this rule.",
        "url": 980
    },
    {
        "nl_input": "The query requires implementing a smart contract mechanism where only a whitelisted agent (sender) can perform certain actions. The functionality should include restricting access to a function using a modifier that checks if the sender is the whitelisted agent, allowing the owner to disable the whitelist state, and enabling removal of an address from the whitelist.",
        "url": 981
    },
    {
        "nl_input": "The inflation rate starts at 100 and decreases by 30 each year until reaching 10, after which it decreases by 0.5 annually. The adjustment occurs periodically, updating the inflation rate and recalculating minting rates based on the updated rate.",
        "url": 982
    },
    {
        "nl_input": "The query requires a function to transfer tokens to a specified user address, including parameters for the recipient address and token amount, with proper validation and emission of a transfer event.",
        "url": 983
    },
    {
        "nl_input": "The query requires a function that removes an auction from public view and returns the token to the seller. It involves canceling the auction, transferring the token back to the seller, and updating storage to reflect the removal. The function should be internal, handle auction cancellation, and include appropriate event logging.",
        "url": 984
    },
    {
        "nl_input": "The query requires a function to approve the minting of a specified number of tokens (`_amount`) and assign them to a given address (`_owner`), ensuring that the minting process is authorized and properly accounted for within the contract.",
        "url": 985
    },
    {
        "nl_input": "The query seeks to obtain the total jackpot value, which is the contract's balance if the jackpot has not been completed. If it is completed, the final jackpot value is returned instead.",
        "url": 986
    },
    {
        "nl_input": "The query requires a function that calculates how much ETH a user can receive when selling a specified amount of BOB tokens. The calculation should be based on a predefined rate, returning zero if the rate is not set.",
        "url": 987
    },
    {
        "nl_input": "The query requires a modifier in a smart contract that allows only authorized users to access deposit functionality. The modifier should ensure that only the owner or addresses with explicit deposit access can proceed, enhancing security for deposit operations.",
        "url": 988
    },
    {
        "nl_input": "The query requires a function to determine whether an address is permitted to bypass the global freeze. The relevant code provides a function that updates the freeze bypass status for a given address, enabling or disabling its ability to bypass restrictions.",
        "url": 989
    },
    {
        "nl_input": "The query requires a smart contract callback function to handle Oraclize random number generation for a betting scenario. It verifies the random number proof, calculates results, and distributes winnings based on the generated numbers, ensuring fairness and handling edge cases like equal values or failed transfers.",
        "url": 990
    },
    {
        "nl_input": "The query requirement is that the owner should be able to update the exchange rate for converting TCR to ETH. The function must ensure only the owner can call it and may include validations such as rate range checks or dynamic rate adjustments based on certain conditions like escrow balance.",
        "url": 991
    },
    {
        "nl_input": "The query requires a function to check if an account is frozen. The relevant code provides a `checkFrozenAccounts` function that returns whether an account is frozen by querying a mapping `frozenAccount`.",
        "url": 992
    },
    {
        "nl_input": "The query requires a contract mechanism that allows the owner to send transactions freely, similar to a multi-sig setup, ensuring flexibility in transferring tokens between DACs or campaigns. This functionality is necessary to handle pledge transfers and token movements initiated by the owner, while maintaining secure and controlled execution.",
        "url": 993
    },
    {
        "nl_input": "The query seeks a function that disables or terminates a smart contract. The relevant code provides three functions: `nullify()` sets a state variable to disable the contract, `disableWhitelist()` turns off a whitelist feature, and `shutdown()` destroys the contract. The main requirement is to disable contract functionality, best met by `nullify()`.",
        "url": 994
    },
    {
        "nl_input": "The query requires a function to remove a minor owner that can only be executed by the major or actual owner wallet. The function must enforce ownership checks and perform necessary updates upon removal.",
        "url": 995
    },
    {
        "nl_input": "The query requires retrieving the value of a node using a function that takes a `bytes32 nodeId` as input and returns an integer value associated with that node.",
        "url": 996
    },
    {
        "nl_input": "The query defines that only the owner and designated distributors can transfer tokens. The code enforces this through a modifier `canTransfer()` that checks if the sender is either the owner or in the distributors list, ensuring token transfers are restricted to authorized addresses.",
        "url": 997
    },
    {
        "nl_input": "The query requires a function to set a charity address in a smart contract, accessible only by the owner. The function should allow updating the charity address and store it as a state variable.",
        "url": 998
    },
    {
        "nl_input": "The query requires a function that allows setting or changing an administrative or signer address on the server side, typically by the contract owner. The function should include access control (e.g., `onlyOwner`), perform validation checks, and emit an event upon successful update.",
        "url": 999
    }
]
